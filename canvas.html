<html>
  <head> </head>

  <style>
    canvas {
      width: 640px;
      height: 400px;
      outline: solid black;
    }
  </style>

  <body>
    <canvas width="640" height="400"></canvas>
  </body>
  <script>
    const canvas = document.querySelector("canvas");
    const context = canvas.getContext("2d");

    function fillRect(
      center_x,
      center_y,
      width,
      height,
      fillColor,
      lineColor,
      lineWidth,
      angle
    ) {
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = fillColor;
      context.strokeStyle = lineColor;

      const cos_theta = Math.cos(angle);
      const sin_theta = Math.sin(angle);

      const half_w = width / 2;
      const half_h = height / 2;

      // Compute bounding box of the rotated rectangle
      const corners_x = [
        -half_w * cos_theta - -half_h * sin_theta,
        half_w * cos_theta - -half_h * sin_theta,
        half_w * cos_theta - half_h * sin_theta,
        -half_w * cos_theta - half_h * sin_theta,
      ];
      const corners_y = [
        -half_w * sin_theta + -half_h * cos_theta,
        half_w * sin_theta + -half_h * cos_theta,
        half_w * sin_theta + half_h * cos_theta,
        -half_w * sin_theta + half_h * cos_theta,
      ];

      // Determine bounding box
      let min_x = corners_x[0],
        max_x = corners_x[0];
      let min_y = corners_y[0],
        max_y = corners_y[0];

      for (let i = 1; i < 4; i++) {
        if (corners_x[i] < min_x) min_x = corners_x[i];
        if (corners_x[i] > max_x) max_x = corners_x[i];
        if (corners_y[i] < min_y) min_y = corners_y[i];
        if (corners_y[i] > max_y) max_y = corners_y[i];
      }

      const start_x = center_x + min_x;
      const end_x = center_x + max_x;
      const start_y = center_y + min_y;
      const end_y = center_y + max_y;

      // Prepare for pixel filling
      const buf_width = end_x - start_x + 1;
      const buf_height = end_y - start_y + 1;

      context.strokeRect(start_x, start_y, buf_width, buf_height);

      for (let y = start_y; y <= end_y; y++) {
        for (let x = start_x; x <= end_x; x++) {
          // Translate point to rectangle's local space
          const dx = x - center_x;
          const dy = y - center_y;

          // Rotate point back (inverse rotation)
          const local_x = dx * cos_theta + dy * sin_theta;
          const local_y = -dx * sin_theta + dy * cos_theta;

          if (Math.abs(local_x) <= half_w && Math.abs(local_y) <= half_h) {
            // Fill pixel at (x - start_x, y - start_y)
            //display_set_pixel_in_buffer(x - start_x, y - start_y, color_index);
            //console.log(x - start_x, y - start_y);
            context.fillRect(half_w + x - start_x, half_h + y - start_y, 1, 1);
          }
        }
      }
    }
  </script>
</html>
