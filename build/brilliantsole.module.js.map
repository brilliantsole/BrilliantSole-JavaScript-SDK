{"version":3,"file":"brilliantsole.module.js","sources":["../node_modules/tslib/tslib.es6.js","../brilliantsole/utils/environment.ts","../brilliantsole/utils/Console.ts","../brilliantsole/utils/EventDispatcher.ts","../brilliantsole/utils/Timer.ts","../brilliantsole/utils/checksum.ts","../brilliantsole/utils/Text.ts","../brilliantsole/utils/ArrayBufferUtils.ts","../node_modules/auto-bind/index.js","../brilliantsole/FileTransferManager.ts","../brilliantsole/utils/MathUtils.ts","../brilliantsole/utils/RangeHelper.ts","../brilliantsole/utils/CenterOfPressureHelper.ts","../brilliantsole/utils/ArrayUtils.ts","../brilliantsole/sensor/PressureSensorDataManager.ts","../brilliantsole/sensor/MotionSensorDataManager.ts","../brilliantsole/sensor/BarometerSensorDataManager.ts","../brilliantsole/utils/ParseUtils.ts","../brilliantsole/CameraManager.ts","../brilliantsole/utils/AudioUtils.ts","../brilliantsole/MicrophoneManager.ts","../brilliantsole/sensor/SensorDataManager.ts","../brilliantsole/sensor/SensorConfigurationManager.ts","../brilliantsole/TfliteManager.ts","../brilliantsole/DeviceInformationManager.ts","../brilliantsole/InformationManager.ts","../brilliantsole/vibration/VibrationWaveformEffects.ts","../brilliantsole/vibration/VibrationManager.ts","../brilliantsole/WifiManager.ts","../brilliantsole/utils/ColorUtils.ts","../brilliantsole/utils/DisplayContextState.ts","../brilliantsole/utils/ObjectUtils.ts","../brilliantsole/utils/DisplayContextStateHelper.ts","../brilliantsole/utils/DisplayUtils.ts","../node_modules/rgbquant/src/rgbquant.js","../brilliantsole/utils/BitmapUtils.ts","../brilliantsole/utils/DisplayContextCommand.ts","../brilliantsole/utils/DisplayManagerInterface.ts","../brilliantsole/DisplayManager.ts","../brilliantsole/connection/BaseConnectionManager.ts","../brilliantsole/utils/stringUtils.ts","../brilliantsole/utils/EventUtils.ts","../brilliantsole/connection/bluetooth/bluetoothUUIDs.ts","../brilliantsole/connection/bluetooth/BluetoothConnectionManager.ts","../brilliantsole/connection/bluetooth/WebBluetoothConnectionManager.ts","../brilliantsole/utils/cbor.js","../brilliantsole/utils/mcumgr.js","../brilliantsole/FirmwareManager.ts","../brilliantsole/DeviceManager.ts","../brilliantsole/server/ServerUtils.ts","../brilliantsole/server/websocket/WebSocketUtils.ts","../brilliantsole/connection/websocket/WebSocketConnectionManager.ts","../brilliantsole/Device.ts","../brilliantsole/utils/DisplayCanvasHelper.ts","../brilliantsole/devicePair/DevicePairPressureSensorDataManager.ts","../brilliantsole/devicePair/DevicePairSensorDataManager.ts","../brilliantsole/devicePair/DevicePair.ts","../brilliantsole/utils/ThrottleUtils.ts","../brilliantsole/connection/ClientConnectionManager.ts","../brilliantsole/server/BaseClient.ts","../brilliantsole/server/websocket/WebSocketClient.ts","../brilliantsole/BS.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","type ENVIRONMENT_FLAG = \"__BRILLIANTSOLE__DEV__\" | \"__BRILLIANTSOLE__PROD__\";\nconst __BRILLIANTSOLE__ENVIRONMENT__: ENVIRONMENT_FLAG = \"__BRILLIANTSOLE__DEV__\";\n\n//@ts-expect-error\nconst isInProduction = __BRILLIANTSOLE__ENVIRONMENT__ == \"__BRILLIANTSOLE__PROD__\";\nconst isInDev = __BRILLIANTSOLE__ENVIRONMENT__ == \"__BRILLIANTSOLE__DEV__\";\n\n// https://github.com/flexdinesh/browser-or-node/blob/master/src/index.ts\nconst isInBrowser = typeof window !== \"undefined\" && typeof window?.document !== \"undefined\";\nconst isInNode = typeof process !== \"undefined\" && process?.versions?.node != null;\n\nconst userAgent = (isInBrowser && navigator.userAgent) || \"\";\n\nlet isBluetoothSupported = false;\nif (isInBrowser) {\n  isBluetoothSupported = Boolean(navigator.bluetooth);\n} else if (isInNode) {\n  isBluetoothSupported = true;\n}\n\nconst isInBluefy = isInBrowser && /Bluefy/i.test(userAgent);\nconst isInWebBLE = isInBrowser && /WebBLE/i.test(userAgent);\n\nconst isAndroid = isInBrowser && /Android/i.test(userAgent);\nconst isSafari = isInBrowser && /Safari/i.test(userAgent) && !/Chrome/i.test(userAgent);\n\nconst isIOS = isInBrowser && /iPad|iPhone|iPod/i.test(userAgent);\nconst isMac = isInBrowser && /Macintosh/i.test(userAgent);\n\n// @ts-expect-error\nconst isInLensStudio = !isInBrowser && !isInNode && typeof global !== \"undefined\" && typeof Studio !== \"undefined\";\n\nexport {\n  isInDev,\n  isInProduction,\n  isInBrowser,\n  isInNode,\n  isAndroid,\n  isInBluefy,\n  isInWebBLE,\n  isSafari,\n  isInLensStudio,\n  isIOS,\n  isMac,\n  isBluetoothSupported,\n};\n","import { isInDev, isInLensStudio, isInNode } from \"./environment.ts\";\n\ndeclare var Studio: any | undefined;\n\nexport type LogFunction = (...data: any[]) => void;\nexport type AssertLogFunction = (condition: boolean, ...data: any[]) => void;\n\nexport interface ConsoleLevelFlags {\n  log?: boolean;\n  warn?: boolean;\n  error?: boolean;\n  assert?: boolean;\n  table?: boolean;\n}\n\ninterface ConsoleLike {\n  log?: LogFunction;\n  warn?: LogFunction;\n  error?: LogFunction;\n  assert?: AssertLogFunction;\n  table?: LogFunction;\n}\n\nvar __console: ConsoleLike;\nif (isInLensStudio) {\n  const log = function (...args: any[]) {\n    Studio.log(args.map((value) => new String(value)).join(\",\"));\n  };\n  __console = {};\n  __console.log = log;\n  __console.warn = log.bind(__console, \"WARNING\");\n  __console.error = log.bind(__console, \"ERROR\");\n} else {\n  __console = console;\n}\n\nfunction getCallerFunctionPath(): string {\n  const stack = new Error().stack;\n  if (!stack) return \"\";\n\n  const lines = stack.split(\"\\n\");\n  const callerLine = lines[3] || lines[2];\n\n  const match = callerLine.match(/at (.*?) \\(/) || callerLine.match(/at (.*)/);\n  if (!match) return \"\";\n\n  const fullFn = match[1].trim();\n  return `[${fullFn}]`;\n}\n\nfunction wrapWithLocation(fn: LogFunction): LogFunction {\n  return (...args: any[]) => {\n    if (isInNode) {\n      const functionPath = getCallerFunctionPath();\n      fn(functionPath, ...args);\n    } else {\n      fn(...args);\n    }\n  };\n}\n\n// console.assert not supported in WebBLE\nif (!__console.assert) {\n  const assert: AssertLogFunction = (condition, ...data) => {\n    if (!condition) {\n      __console.warn!(...data);\n    }\n  };\n  __console.assert = assert;\n}\n\n// console.table not supported in WebBLE\nif (!__console.table) {\n  const table: LogFunction = (...data) => {\n    __console.log!(...data);\n  };\n  __console.table = table;\n}\n\nfunction emptyFunction() {}\n\nconst log: LogFunction = isInNode\n  ? wrapWithLocation(__console.log!.bind(__console))\n  : __console.log!.bind(__console);\nconst warn: LogFunction = isInNode\n  ? wrapWithLocation(__console.warn!.bind(__console))\n  : __console.warn!.bind(__console);\nconst error: LogFunction = isInNode\n  ? wrapWithLocation(__console.error!.bind(__console))\n  : __console.error!.bind(__console);\nconst table: LogFunction = isInNode\n  ? wrapWithLocation(__console.table!.bind(__console))\n  : __console.table!.bind(__console);\nconst assert: AssertLogFunction = __console.assert.bind(__console);\n\nclass Console {\n  static #consoles: { [type: string]: Console } = {};\n\n  constructor(type: string) {\n    if (Console.#consoles[type]) {\n      throw new Error(`\"${type}\" console already exists`);\n    }\n    Console.#consoles[type] = this;\n  }\n\n  #levelFlags: ConsoleLevelFlags = {\n    log: isInDev,\n    warn: isInDev,\n    assert: true,\n    error: true,\n    table: true,\n  };\n\n  setLevelFlags(levelFlags: ConsoleLevelFlags) {\n    Object.assign(this.#levelFlags, levelFlags);\n  }\n\n  /** @throws {Error} if no console with type \"type\" is found */\n  static setLevelFlagsForType(type: string, levelFlags: ConsoleLevelFlags) {\n    if (!this.#consoles[type]) {\n      throw new Error(`no console found with type \"${type}\"`);\n    }\n    this.#consoles[type].setLevelFlags(levelFlags);\n  }\n\n  static setAllLevelFlags(levelFlags: ConsoleLevelFlags) {\n    for (const type in this.#consoles) {\n      this.#consoles[type].setLevelFlags(levelFlags);\n    }\n  }\n\n  static create(type: string, levelFlags?: ConsoleLevelFlags): Console {\n    const console = this.#consoles[type] || new Console(type);\n    if (isInDev && levelFlags) {\n      console.setLevelFlags(levelFlags);\n    }\n    return console;\n  }\n\n  get log() {\n    return this.#levelFlags.log ? log : emptyFunction;\n  }\n\n  get warn() {\n    return this.#levelFlags.warn ? warn : emptyFunction;\n  }\n\n  get error() {\n    return this.#levelFlags.error ? error : emptyFunction;\n  }\n\n  get assert() {\n    return this.#levelFlags.assert ? assert : emptyFunction;\n  }\n\n  get table() {\n    return this.#levelFlags.table ? table : emptyFunction;\n  }\n\n  /** @throws {Error} if condition is not met */\n  assertWithError(condition: any, message: string) {\n    if (!Boolean(condition)) {\n      throw new Error(message);\n    }\n  }\n\n  /** @throws {Error} if value's type doesn't match */\n  assertTypeWithError(value: any, type: string) {\n    this.assertWithError(\n      typeof value == type,\n      `value ${value} of type \"${typeof value}\" not of type \"${type}\"`\n    );\n  }\n\n  /** @throws {Error} if value's type doesn't match */\n  assertEnumWithError(value: string, enumeration: readonly string[]) {\n    this.assertWithError(\n      enumeration.includes(value),\n      `invalid enum \"${value}\"`\n    );\n  }\n\n  /** @throws {Error} if value is not within some range */\n  assertRangeWithError(name: string, value: number, min: number, max: number) {\n    this.assertWithError(\n      value >= min && value <= max,\n      `${name} ${value} must be within ${min}-${max}`\n    );\n  }\n}\n\nexport function createConsole(\n  type: string,\n  levelFlags?: ConsoleLevelFlags\n): Console {\n  return Console.create(type, levelFlags);\n}\n\n/** @throws {Error} if no console with type is found */\nexport function setConsoleLevelFlagsForType(\n  type: string,\n  levelFlags: ConsoleLevelFlags\n) {\n  Console.setLevelFlagsForType(type, levelFlags);\n}\n\nexport function setAllConsoleLevelFlags(levelFlags: ConsoleLevelFlags) {\n  Console.setAllLevelFlags(levelFlags);\n}\n","import { createConsole } from \"./Console.ts\";\nimport { deepEqual } from \"./ObjectUtils.ts\";\n\nconst _console = createConsole(\"EventDispatcher\", { log: false });\n\nexport type EventMap<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [T in keyof EventMessages]: {\n    type: T;\n    target: Target;\n    message: EventMessages[T];\n  };\n};\nexport type EventListenerMap<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [T in keyof EventMessages]: (event: {\n    type: T;\n    target: Target;\n    message: EventMessages[T];\n  }) => void;\n};\n\nexport type Event<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = EventMap<Target, EventType, EventMessages>[keyof EventMessages];\n\ntype SpecificEvent<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>,\n  SpecificEventType extends EventType\n> = {\n  type: SpecificEventType;\n  target: Target;\n  message: EventMessages[SpecificEventType];\n};\n\nexport type BoundEventListeners<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [SpecificEventType in keyof EventMessages]?: (\n    // @ts-expect-error\n    event: SpecificEvent<Target, EventType, EventMessages, SpecificEventType>\n  ) => void;\n};\n\nclass EventDispatcher<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> {\n  private listeners: {\n    [T in EventType]?: {\n      listener: (event: {\n        type: T;\n        target: Target;\n        message: EventMessages[T];\n      }) => void;\n      once?: boolean;\n      shouldRemove?: boolean;\n    }[];\n  } = {};\n\n  constructor(\n    private target: Target,\n    private validEventTypes: readonly EventType[]\n  ) {\n    this.addEventListener = this.addEventListener.bind(this);\n    this.removeEventListener = this.removeEventListener.bind(this);\n    this.removeEventListeners = this.removeEventListeners.bind(this);\n    this.removeAllEventListeners = this.removeAllEventListeners.bind(this);\n    this.dispatchEvent = this.dispatchEvent.bind(this);\n    this.waitForEvent = this.waitForEvent.bind(this);\n  }\n\n  private isValidEventType(type: any): type is EventType {\n    return this.validEventTypes.includes(type);\n  }\n\n  private updateEventListeners(type: EventType) {\n    if (!this.listeners[type]) return;\n    this.listeners[type] = this.listeners[type]!.filter((listenerObj) => {\n      if (listenerObj.shouldRemove) {\n        _console.log(`removing \"${type}\" eventListener`, listenerObj);\n      }\n      return !listenerObj.shouldRemove;\n    });\n  }\n\n  addEventListener<T extends EventType>(\n    type: T,\n    listener: (event: {\n      type: T;\n      target: Target;\n      message: EventMessages[T];\n    }) => void,\n    options: { once?: boolean } = { once: false }\n  ): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n      _console.log(`creating \"${type}\" listeners array`, this.listeners[type]!);\n    }\n    const alreadyAdded = this.listeners[type].find((listenerObject) => {\n      return (\n        listenerObject.listener == listener &&\n        listenerObject.once == options.once\n      );\n    });\n    if (alreadyAdded) {\n      _console.log(\"already added listener\");\n      return;\n    }\n    _console.log(`adding \"${type}\" listener`, listener, options);\n    this.listeners[type]!.push({ listener, once: options.once });\n\n    _console.log(\n      `currently have ${this.listeners[type]!.length} \"${type}\" listeners`\n    );\n  }\n\n  removeEventListener<T extends EventType>(\n    type: T,\n    listener: (event: {\n      type: T;\n      target: Target;\n      message: EventMessages[T];\n    }) => void\n  ): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    _console.log(`removing \"${type}\" listener...`, listener);\n    this.listeners[type]!.forEach((listenerObj) => {\n      const isListenerToRemove = listenerObj.listener === listener;\n      if (isListenerToRemove) {\n        _console.log(`flagging \"${type}\" listener`, listener);\n        listenerObj.shouldRemove = true;\n      }\n    });\n\n    this.updateEventListeners(type);\n  }\n\n  removeEventListeners<T extends EventType>(type: T): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    _console.log(`removing \"${type}\" listeners...`);\n    this.listeners[type] = [];\n  }\n\n  removeAllEventListeners(): void {\n    _console.log(`removing listeners...`);\n    this.listeners = {};\n  }\n\n  dispatchEvent<T extends EventType>(type: T, message: EventMessages[T]): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    this.listeners[type]!.forEach((listenerObj) => {\n      if (listenerObj.shouldRemove) {\n        return;\n      }\n\n      _console.log(`dispatching \"${type}\" listener`, listenerObj);\n      try {\n        listenerObj.listener({ type, target: this.target, message });\n      } catch (error) {\n        console.error(error);\n      }\n\n      if (listenerObj.once) {\n        _console.log(`flagging \"${type}\" listener`, listenerObj);\n        listenerObj.shouldRemove = true;\n      }\n    });\n    this.updateEventListeners(type);\n  }\n\n  waitForEvent<T extends EventType>(\n    type: T\n  ): Promise<{ type: T; target: Target; message: EventMessages[T] }> {\n    return new Promise((resolve) => {\n      const onceListener = (event: {\n        type: T;\n        target: Target;\n        message: EventMessages[T];\n      }) => {\n        resolve(event);\n      };\n\n      this.addEventListener(type, onceListener, { once: true });\n    });\n  }\n}\n\nexport default EventDispatcher;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"Timer\", { log: false });\n\nexport async function wait(delay: number) {\n  _console.log(`waiting for ${delay}ms`);\n  return new Promise((resolve: Function) => {\n    setTimeout(() => resolve(), delay);\n  });\n}\n\nclass Timer {\n  #callback!: Function;\n  get callback() {\n    return this.#callback;\n  }\n  set callback(newCallback) {\n    _console.assertTypeWithError(newCallback, \"function\");\n    _console.log({ newCallback });\n    this.#callback = newCallback;\n    if (this.isRunning) {\n      this.restart();\n    }\n  }\n\n  #interval!: number;\n  get interval() {\n    return this.#interval;\n  }\n  set interval(newInterval) {\n    _console.assertTypeWithError(newInterval, \"number\");\n    _console.assertWithError(newInterval > 0, \"interval must be above 0\");\n    _console.log({ newInterval });\n    this.#interval = newInterval;\n    if (this.isRunning) {\n      this.restart();\n    }\n  }\n\n  constructor(callback: Function, interval: number) {\n    this.interval = interval;\n    this.callback = callback;\n  }\n\n  #intervalId: number | undefined;\n  get isRunning() {\n    return this.#intervalId != undefined;\n  }\n\n  start(immediately = false) {\n    if (this.isRunning) {\n      _console.log(\"interval already running\");\n      return;\n    }\n    _console.log(`starting interval every ${this.#interval}ms`);\n    this.#intervalId = setInterval(this.#callback, this.#interval);\n    if (immediately) {\n      this.#callback();\n    }\n  }\n  stop() {\n    if (!this.isRunning) {\n      _console.log(\"interval already not running\");\n      return;\n    }\n    _console.log(\"stopping interval\");\n    clearInterval(this.#intervalId);\n    this.#intervalId = undefined;\n  }\n  restart(startImmediately = false) {\n    this.stop();\n    this.start(startImmediately);\n  }\n}\nexport default Timer;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"checksum\", { log: false });\n\n// https://github.com/googlecreativelab/tiny-motion-trainer/blob/5fceb49f018ae0c403bf9f0ccc437309c2acb507/frontend/src/tf4micro-motion-kit/modules/bleFileTransfer#L195\n\n// See http://home.thep.lu.se/~bjorn/crc/ for more information on simple CRC32 calculations.\nexport function crc32ForByte(r: number) {\n  for (let j = 0; j < 8; ++j) {\n    r = (r & 1 ? 0 : 0xedb88320) ^ (r >>> 1);\n  }\n  return r ^ 0xff000000;\n}\n\nconst tableSize = 256;\nconst crc32Table = new Uint32Array(tableSize);\nfor (let i = 0; i < tableSize; ++i) {\n  crc32Table[i] = crc32ForByte(i);\n}\n\nexport function crc32(dataIterable: ArrayBuffer | number[]) {\n  let dataBytes = new Uint8Array(dataIterable);\n  let crc = 0;\n  for (let i = 0; i < dataBytes.byteLength; ++i) {\n    const crcLowByte = crc & 0x000000ff;\n    const dataByte = dataBytes[i];\n    const tableIndex = crcLowByte ^ dataByte;\n    // The last >>> is to convert this into an unsigned 32-bit integer.\n    crc = (crc32Table[tableIndex] ^ (crc >>> 8)) >>> 0;\n  }\n  return crc;\n}\n\n// This is a small test function for the CRC32 implementation, not normally called but left in\n// for debugging purposes. We know the expected CRC32 of [97, 98, 99, 100, 101] is 2240272485,\n// or 0x8587d865, so if anything else is output we know there's an error in the implementation.\nexport function testCrc32() {\n  const testArray = [97, 98, 99, 100, 101];\n  const testArrayCrc32 = crc32(testArray);\n  _console.log(\"CRC32 for [97, 98, 99, 100, 101] is 0x\" + testArrayCrc32.toString(16) + \" (\" + testArrayCrc32 + \")\");\n}\n","var _TextEncoder;\nif (typeof TextEncoder == \"undefined\") {\n  _TextEncoder = class {\n    encode(string: string) {\n      const encoding = Array.from(string).map((char) => char.charCodeAt(0));\n      return Uint8Array.from(encoding);\n    }\n  };\n} else {\n  _TextEncoder = TextEncoder;\n}\n\nvar _TextDecoder;\nif (typeof TextDecoder == \"undefined\") {\n  _TextDecoder = class {\n    decode(data: ArrayBuffer) {\n      const byteArray = Array.from(new Uint8Array(data));\n      return byteArray\n        .map((value) => {\n          return String.fromCharCode(value);\n        })\n        .join(\"\");\n    }\n  };\n} else {\n  _TextDecoder = TextDecoder;\n}\n\nexport const textEncoder = new _TextEncoder();\nexport const textDecoder = new _TextDecoder();\n","import { createConsole } from \"./Console.ts\";\nimport { textEncoder } from \"./Text.ts\";\n\nconst _console = createConsole(\"ArrayBufferUtils\", { log: false });\n\nexport function concatenateArrayBuffers(...arrayBuffers: any[]): ArrayBuffer {\n  arrayBuffers = arrayBuffers.filter(\n    (arrayBuffer) => arrayBuffer != undefined || arrayBuffer != null\n  );\n  arrayBuffers = arrayBuffers.map((arrayBuffer) => {\n    if (typeof arrayBuffer == \"number\") {\n      const number = arrayBuffer;\n      return Uint8Array.from([Math.floor(number)]);\n    } else if (typeof arrayBuffer == \"boolean\") {\n      const boolean = arrayBuffer;\n      return Uint8Array.from([boolean ? 1 : 0]);\n    } else if (typeof arrayBuffer == \"string\") {\n      const string = arrayBuffer;\n      return stringToArrayBuffer(string);\n    } else if (arrayBuffer instanceof Array) {\n      const array = arrayBuffer;\n      return concatenateArrayBuffers(...array);\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      return arrayBuffer;\n    } else if (\n      \"buffer\" in arrayBuffer &&\n      arrayBuffer.buffer instanceof ArrayBuffer\n    ) {\n      const bufferContainer = arrayBuffer;\n      return bufferContainer.buffer;\n    } else if (arrayBuffer instanceof DataView) {\n      const dataView = arrayBuffer;\n      return dataView.buffer;\n    } else if (typeof arrayBuffer == \"object\") {\n      const object = arrayBuffer;\n      return objectToArrayBuffer(object);\n    } else {\n      return arrayBuffer;\n    }\n  });\n  arrayBuffers = arrayBuffers.filter(\n    (arrayBuffer) => arrayBuffer && \"byteLength\" in arrayBuffer\n  );\n  const length = arrayBuffers.reduce(\n    (length, arrayBuffer) => length + arrayBuffer.byteLength,\n    0\n  );\n  const uint8Array = new Uint8Array(length);\n  let byteOffset = 0;\n  arrayBuffers.forEach((arrayBuffer) => {\n    uint8Array.set(new Uint8Array(arrayBuffer), byteOffset);\n    byteOffset += arrayBuffer.byteLength;\n  });\n  return uint8Array.buffer;\n}\n\nexport function dataToArrayBuffer(data: Buffer) {\n  return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n}\n\nexport function stringToArrayBuffer(string: string) {\n  const encoding = textEncoder.encode(string);\n  return concatenateArrayBuffers(encoding.byteLength, encoding);\n}\n\nexport function objectToArrayBuffer(object: object) {\n  return stringToArrayBuffer(JSON.stringify(object));\n}\n\nexport function sliceDataView(\n  dataView: DataView,\n  begin: number,\n  length?: number\n) {\n  let end;\n  if (length != undefined) {\n    end = dataView.byteOffset + begin + length;\n  }\n  _console.log({ dataView, begin, end, length });\n  return new DataView(dataView.buffer.slice(dataView.byteOffset + begin, end));\n}\n\nexport type FileLike = number[] | ArrayBuffer | DataView | URL | string | File;\n\nexport async function getFileBuffer(file: FileLike) {\n  let fileBuffer;\n  if (file instanceof Array) {\n    fileBuffer = Uint8Array.from(file);\n  } else if (file instanceof DataView) {\n    fileBuffer = file.buffer;\n  } else if (typeof file == \"string\" || file instanceof URL) {\n    const response = await fetch(file);\n    fileBuffer = await response.arrayBuffer();\n  } else if (file instanceof File) {\n    fileBuffer = await file.arrayBuffer();\n  } else if (file instanceof ArrayBuffer) {\n    fileBuffer = file;\n  } else {\n    throw { error: \"invalid file type\", file };\n  }\n  return fileBuffer;\n}\n\nexport function UInt8ByteBuffer(value: number) {\n  return Uint8Array.from([value]).buffer;\n}\n","// Gets all non-builtin properties up the prototype chain.\nconst getAllProperties = object => {\n\tconst properties = new Set();\n\n\tdo {\n\t\tfor (const key of Reflect.ownKeys(object)) {\n\t\t\tproperties.add([object, key]);\n\t\t}\n\t} while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);\n\n\treturn properties;\n};\n\nexport default function autoBind(self, {include, exclude} = {}) {\n\tconst filter = key => {\n\t\tconst match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\n\t\tif (include) {\n\t\t\treturn include.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\tif (exclude) {\n\t\t\treturn !exclude.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tfor (const [object, key] of getAllProperties(self.constructor.prototype)) {\n\t\tif (key === 'constructor' || !filter(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(object, key);\n\t\tif (descriptor && typeof descriptor.value === 'function') {\n\t\t\tself[key] = self[key].bind(self);\n\t\t}\n\t}\n\n\treturn self;\n}\n","import { createConsole } from \"./utils/Console.ts\";\nimport { crc32 } from \"./utils/checksum.ts\";\nimport { getFileBuffer, UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { FileLike } from \"./utils/ArrayBufferUtils.ts\";\nimport Device, { SendMessageCallback } from \"./Device.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"FileTransferManager\", { log: false });\n\nexport const FileTransferMessageTypes = [\n  \"getFileTypes\",\n  \"maxFileLength\",\n  \"getFileType\",\n  \"setFileType\",\n  \"getFileLength\",\n  \"setFileLength\",\n  \"getFileChecksum\",\n  \"setFileChecksum\",\n  \"setFileTransferCommand\",\n  \"fileTransferStatus\",\n  \"getFileBlock\",\n  \"setFileBlock\",\n  \"fileBytesTransferred\",\n] as const;\nexport type FileTransferMessageType = (typeof FileTransferMessageTypes)[number];\n\nexport const FileTypes = [\"tflite\", \"wifiServerCert\", \"wifiServerKey\"] as const;\nexport type FileType = (typeof FileTypes)[number];\n\nexport const FileTransferStatuses = [\"idle\", \"sending\", \"receiving\"] as const;\nexport type FileTransferStatus = (typeof FileTransferStatuses)[number];\n\nexport const FileTransferCommands = [\n  \"startSend\",\n  \"startReceive\",\n  \"cancel\",\n] as const;\nexport type FileTransferCommand = (typeof FileTransferCommands)[number];\n\nexport const FileTransferDirections = [\"sending\", \"receiving\"] as const;\nexport type FileTransferDirection = (typeof FileTransferDirections)[number];\n\nexport const FileTransferEventTypes = [\n  ...FileTransferMessageTypes,\n  \"fileTransferProgress\",\n  \"fileTransferComplete\",\n  \"fileReceived\",\n] as const;\nexport type FileTransferEventType = (typeof FileTransferEventTypes)[number];\n\nexport const RequiredFileTransferMessageTypes: FileTransferMessageType[] = [\n  \"maxFileLength\",\n  \"getFileLength\",\n  \"getFileChecksum\",\n  \"getFileType\",\n  \"fileTransferStatus\",\n];\n\nexport interface FileConfiguration {\n  file: FileLike;\n  type: FileType;\n}\n\nexport interface FileTransferEventMessages {\n  getFileTypes: { fileTypes: FileType[] };\n  maxFileLength: { maxFileLength: number };\n  getFileType: { fileType: FileType };\n  getFileLength: { fileLength: number };\n  getFileChecksum: { fileChecksum: number };\n  fileTransferStatus: { fileTransferStatus: FileTransferStatus };\n  getFileBlock: { fileTransferBlock: DataView };\n  fileTransferProgress: { progress: number };\n  fileTransferComplete: { direction: FileTransferDirection };\n  fileReceived: { file: File | Blob };\n}\n\nexport type FileTransferEventDispatcher = EventDispatcher<\n  Device,\n  FileTransferEventType,\n  FileTransferEventMessages\n>;\nexport type SendFileTransferMessageCallback =\n  SendMessageCallback<FileTransferMessageType>;\n\nclass FileTransferManager {\n  constructor() {\n    autoBind(this);\n  }\n  sendMessage!: SendFileTransferMessageCallback;\n\n  eventDispatcher!: FileTransferEventDispatcher;\n  get addEventListener() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  #assertValidType(type: FileType) {\n    _console.assertEnumWithError(type, FileTypes);\n  }\n  #isValidType(type: FileType) {\n    return FileTypes.includes(type);\n  }\n  #assertValidTypeEnum(typeEnum: number) {\n    _console.assertWithError(\n      typeEnum in FileTypes,\n      `invalid typeEnum ${typeEnum}`\n    );\n  }\n\n  #assertValidStatusEnum(statusEnum: number) {\n    _console.assertWithError(\n      statusEnum in FileTransferStatuses,\n      `invalid statusEnum ${statusEnum}`\n    );\n  }\n  #assertValidCommand(command: FileTransferCommand) {\n    _console.assertEnumWithError(command, FileTransferCommands);\n  }\n\n  #fileTypes: FileType[] = [];\n  get fileTypes() {\n    return this.#fileTypes;\n  }\n  #parseFileTypes(dataView: DataView) {\n    const fileTypes = Array.from(new Uint8Array(dataView.buffer))\n      .map((index) => FileTypes[index])\n      .filter(Boolean);\n    this.#fileTypes = fileTypes;\n    _console.log(\"fileTypes\", fileTypes);\n    this.#dispatchEvent(\"getFileTypes\", {\n      fileTypes: this.#fileTypes,\n    });\n  }\n\n  static #MaxLength = 0; // kB\n  static get MaxLength() {\n    return this.#MaxLength;\n  }\n  #maxLength = FileTransferManager.MaxLength;\n  /** kB */\n  get maxLength() {\n    return this.#maxLength;\n  }\n  #parseMaxLength(dataView: DataView) {\n    _console.log(\"parseFileMaxLength\", dataView);\n    const maxLength = dataView.getUint32(0, true);\n    _console.log(`maxLength: ${maxLength / 1024}kB`);\n    this.#updateMaxLength(maxLength);\n  }\n  #updateMaxLength(maxLength: number) {\n    _console.log({ maxLength });\n    this.#maxLength = maxLength;\n    this.#dispatchEvent(\"maxFileLength\", { maxFileLength: maxLength });\n  }\n  #assertValidLength(length: number) {\n    _console.assertWithError(\n      length <= this.maxLength,\n      `file length ${length}kB too large - must be ${this.maxLength}kB or less`\n    );\n  }\n\n  #type: FileType | undefined;\n  get type() {\n    return this.#type;\n  }\n  #parseType(dataView: DataView) {\n    _console.log(\"parseFileType\", dataView);\n    const typeEnum = dataView.getUint8(0);\n    this.#assertValidTypeEnum(typeEnum);\n    const type = FileTypes[typeEnum];\n    this.#updateType(type);\n  }\n  #updateType(type: FileType) {\n    _console.log({ fileTransferType: type });\n    this.#type = type;\n    this.#dispatchEvent(\"getFileType\", { fileType: type });\n  }\n  async #setType(newType: FileType, sendImmediately?: boolean) {\n    this.#assertValidType(newType);\n    if (this.type == newType) {\n      _console.log(`redundant type assignment ${newType}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getFileType\");\n\n    const typeEnum = FileTypes.indexOf(newType);\n\n    this.sendMessage(\n      [{ type: \"setFileType\", data: UInt8ByteBuffer(typeEnum) }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #length = 0;\n  get length() {\n    return this.#length;\n  }\n  #parseLength(dataView: DataView) {\n    _console.log(\"parseFileLength\", dataView);\n    const length = dataView.getUint32(0, true);\n\n    this.#updateLength(length);\n  }\n  #updateLength(length: number) {\n    _console.log(`length: ${length / 1024}kB`);\n    this.#length = length;\n    this.#dispatchEvent(\"getFileLength\", { fileLength: length });\n  }\n  async #setLength(newLength: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newLength, \"number\");\n    this.#assertValidLength(newLength);\n    if (this.length == newLength) {\n      _console.log(`redundant length assignment ${newLength}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getFileLength\");\n\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setUint32(0, newLength, true);\n    this.sendMessage(\n      [{ type: \"setFileLength\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #checksum = 0;\n  get checksum() {\n    return this.#checksum;\n  }\n  #parseChecksum(dataView: DataView) {\n    _console.log(\"checksum\", dataView);\n    const checksum = dataView.getUint32(0, true);\n    this.#updateChecksum(checksum);\n  }\n  #updateChecksum(checksum: number) {\n    _console.log({ checksum });\n    this.#checksum = checksum;\n    this.#dispatchEvent(\"getFileChecksum\", { fileChecksum: checksum });\n  }\n  async #setChecksum(newChecksum: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newChecksum, \"number\");\n    if (this.checksum == newChecksum) {\n      _console.log(`redundant checksum assignment ${newChecksum}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getFileChecksum\");\n\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setUint32(0, newChecksum, true);\n    this.sendMessage(\n      [{ type: \"setFileChecksum\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  async #setCommand(command: FileTransferCommand, sendImmediately?: boolean) {\n    this.#assertValidCommand(command);\n\n    const promise = this.waitForEvent(\"fileTransferStatus\");\n    _console.log(`setting command ${command}`);\n    const commandEnum = FileTransferCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"setFileTransferCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #status: FileTransferStatus = \"idle\";\n  get status() {\n    return this.#status;\n  }\n  #parseStatus(dataView: DataView) {\n    _console.log(\"parseFileStatus\", dataView);\n    const statusEnum = dataView.getUint8(0);\n    this.#assertValidStatusEnum(statusEnum);\n    const status = FileTransferStatuses[statusEnum];\n    this.#updateStatus(status);\n  }\n  #updateStatus(status: FileTransferStatus) {\n    _console.log({ status });\n    this.#status = status;\n    this.#dispatchEvent(\"fileTransferStatus\", { fileTransferStatus: status });\n    this.#receivedBlocks.length = 0;\n    this.#isCancelling = false;\n  }\n  #assertIsIdle() {\n    _console.assertWithError(this.#status == \"idle\", \"status is not idle\");\n  }\n  #assertIsNotIdle() {\n    _console.assertWithError(this.#status != \"idle\", \"status is idle\");\n  }\n\n  // BLOCK\n\n  #receivedBlocks: ArrayBuffer[] = [];\n\n  async #parseBlock(dataView: DataView) {\n    _console.log(\"parseFileBlock\", dataView);\n    this.#receivedBlocks.push(dataView.buffer);\n\n    const bytesReceived = this.#receivedBlocks.reduce(\n      (sum, arrayBuffer) => (sum += arrayBuffer.byteLength),\n      0\n    );\n    const progress = bytesReceived / this.#length;\n\n    _console.log(\n      `received ${bytesReceived} of ${this.#length} bytes (${progress * 100}%)`\n    );\n\n    this.#dispatchEvent(\"fileTransferProgress\", { progress });\n\n    if (bytesReceived != this.#length) {\n      const dataView = new DataView(new ArrayBuffer(4));\n      dataView.setUint32(0, bytesReceived, true);\n\n      if (this.isServerSide) {\n        return;\n      }\n      await this.sendMessage([\n        { type: \"fileBytesTransferred\", data: dataView.buffer },\n      ]);\n      return;\n    }\n\n    _console.log(\"file transfer complete\");\n\n    let fileName = new Date().toLocaleString();\n    switch (this.type) {\n      case \"tflite\":\n        fileName += \".tflite\";\n        break;\n      case \"wifiServerCert\":\n        fileName += \"_server.crt\";\n        break;\n      case \"wifiServerKey\":\n        fileName += \"_server.key\";\n        break;\n    }\n\n    let file: File | Blob;\n    if (typeof File !== \"undefined\") {\n      file = new File(this.#receivedBlocks, fileName);\n    } else {\n      file = new Blob(this.#receivedBlocks);\n    }\n\n    const arrayBuffer = await file.arrayBuffer();\n    const checksum = crc32(arrayBuffer);\n    _console.log({ checksum });\n\n    if (checksum != this.#checksum) {\n      _console.error(\n        `wrong checksum - expected ${this.#checksum}, got ${checksum}`\n      );\n      return;\n    }\n\n    _console.log(\"received file\", file);\n\n    this.#dispatchEvent(\"getFileBlock\", { fileTransferBlock: dataView });\n    this.#dispatchEvent(\"fileTransferComplete\", { direction: \"receiving\" });\n    this.#dispatchEvent(\"fileReceived\", { file });\n  }\n\n  parseMessage(messageType: FileTransferMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getFileTypes\":\n        this.#parseFileTypes(dataView);\n        break;\n      case \"maxFileLength\":\n        this.#parseMaxLength(dataView);\n        break;\n      case \"getFileType\":\n      case \"setFileType\":\n        this.#parseType(dataView);\n        break;\n      case \"getFileLength\":\n      case \"setFileLength\":\n        this.#parseLength(dataView);\n        break;\n      case \"getFileChecksum\":\n      case \"setFileChecksum\":\n        this.#parseChecksum(dataView);\n        break;\n      case \"fileTransferStatus\":\n        this.#parseStatus(dataView);\n        break;\n      case \"getFileBlock\":\n        this.#parseBlock(dataView);\n        break;\n      case \"fileBytesTransferred\":\n        this.#parseBytesTransferred(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  async send(type: FileType, file: FileLike) {\n    if (true) {\n      this.#assertIsIdle();\n      this.#assertValidType(type);\n    } else {\n      if (this.status != \"idle\") {\n        _console.warn(`cannot send file - status is ${this.status}`);\n        return false;\n      }\n      if (!this.#isValidType(type)) {\n        _console.warn(`invalid fileType ${type}`);\n        return false;\n      }\n    }\n\n    const fileBuffer = await getFileBuffer(file);\n    const fileLength = fileBuffer.byteLength;\n    const checksum = crc32(fileBuffer);\n\n    if (type != this.type) {\n      _console.log(\"different fileTypes - sending\");\n    } else if (fileLength != this.length) {\n      _console.log(\"different fileLengths - sending\");\n    } else if (checksum != this.checksum) {\n      _console.log(\"different fileChecksums - sending\");\n    } else {\n      _console.log(\"already sent file\");\n      return false;\n    }\n\n    const promises: Promise<any>[] = [];\n\n    promises.push(this.#setType(type, false));\n    promises.push(this.#setLength(fileLength, false));\n    promises.push(this.#setChecksum(checksum, false));\n    promises.push(this.#setCommand(\"startSend\", false));\n\n    this.sendMessage();\n\n    await Promise.all(promises);\n\n    await this.#send(fileBuffer);\n\n    return true;\n  }\n\n  #buffer?: ArrayBuffer;\n  #bytesTransferred = 0;\n  async #send(buffer: ArrayBuffer) {\n    this.#buffer = buffer;\n    this.#bytesTransferred = 0;\n    return this.#sendBlock();\n  }\n\n  mtu!: number;\n  async #sendBlock(): Promise<void> {\n    if (this.status != \"sending\") {\n      return;\n    }\n    if (this.#isCancelling) {\n      _console.error(\"not sending block - busy cancelling\");\n      return;\n    }\n    if (!this.#buffer) {\n      if (!this.isServerSide) {\n        _console.error(\"no buffer defined\");\n      }\n      return;\n    }\n\n    const buffer = this.#buffer;\n    let offset = this.#bytesTransferred;\n\n    const slicedBuffer = buffer.slice(offset, offset + (this.mtu - 3 - 3));\n    _console.log(\"slicedBuffer\", slicedBuffer);\n    const bytesLeft = buffer.byteLength - offset;\n\n    const progress = 1 - bytesLeft / buffer.byteLength;\n    _console.log(\n      `sending bytes ${offset}-${offset + slicedBuffer.byteLength} of ${\n        buffer.byteLength\n      } bytes (${progress * 100}%)`\n    );\n    this.#dispatchEvent(\"fileTransferProgress\", { progress });\n    if (slicedBuffer.byteLength == 0) {\n      _console.log(\"finished sending buffer\");\n      this.#dispatchEvent(\"fileTransferComplete\", { direction: \"sending\" });\n    } else {\n      await this.sendMessage([{ type: \"setFileBlock\", data: slicedBuffer }]);\n      this.#bytesTransferred = offset + slicedBuffer.byteLength;\n      //return this.#sendBlock(buffer, offset + slicedBuffer.byteLength);\n    }\n  }\n\n  async #parseBytesTransferred(dataView: DataView) {\n    _console.log(\"parseBytesTransferred\", dataView);\n    const bytesTransferred = dataView.getUint32(0, true);\n    _console.log({ bytesTransferred });\n    if (this.status != \"sending\") {\n      _console.error(`not currently sending file`);\n      return;\n    }\n    if (!this.isServerSide && this.#bytesTransferred != bytesTransferred) {\n      _console.error(\n        `bytesTransferred are not equal - got ${bytesTransferred}, expected ${\n          this.#bytesTransferred\n        }`\n      );\n      this.cancel();\n      return;\n    }\n    this.#sendBlock();\n  }\n\n  async receive(type: FileType) {\n    this.#assertIsIdle();\n\n    this.#assertValidType(type);\n\n    await this.#setType(type);\n    await this.#setCommand(\"startReceive\");\n  }\n\n  #isCancelling = false;\n  async cancel() {\n    this.#assertIsNotIdle();\n    _console.log(\"cancelling file transfer...\");\n    this.#isCancelling = true;\n    await this.#setCommand(\"cancel\");\n  }\n\n  // SERVER SIDE\n  #isServerSide = false;\n  get isServerSide() {\n    return this.#isServerSide;\n  }\n  set isServerSide(newIsServerSide) {\n    if (this.#isServerSide == newIsServerSide) {\n      _console.log(\"redundant isServerSide assignment\");\n      return;\n    }\n    _console.log({ newIsServerSide });\n    this.#isServerSide = newIsServerSide;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required fileTransfer information\");\n    const messages = RequiredFileTransferMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n}\n\nexport default FileTransferManager;\n","import { PressureSensorPosition } from \"../sensor/PressureSensorDataManager.ts\";\nimport { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"MathUtils\", { log: false });\n\nexport function getInterpolation(\n  value: number,\n  min: number,\n  max: number,\n  span: number\n) {\n  if (span == undefined) {\n    span = max - min;\n  }\n  return (value - min) / span;\n}\n\nexport const Uint16Max = 2 ** 16;\nexport const Int16Max = 2 ** 15;\nexport const Int16Min = -(2 ** 15) - 1;\n\nfunction removeLower2Bytes(number: number) {\n  const lower2Bytes = number % Uint16Max;\n  return number - lower2Bytes;\n}\n\nconst timestampThreshold = 60_000;\n\nexport function parseTimestamp(dataView: DataView, byteOffset: number) {\n  const now = Date.now();\n  const nowWithoutLower2Bytes = removeLower2Bytes(now);\n  const lower2Bytes = dataView.getUint16(byteOffset, true);\n  let timestamp = nowWithoutLower2Bytes + lower2Bytes;\n  if (Math.abs(now - timestamp) > timestampThreshold) {\n    _console.log(\"correcting timestamp delta\");\n    timestamp += Uint16Max * Math.sign(now - timestamp);\n  }\n  return timestamp;\n}\n\nexport interface Vector2 {\n  x: number;\n  y: number;\n}\n\nexport function getVector2Length(vector: Vector2) {\n  const { x, y } = vector;\n  return Math.sqrt(x ** 2 + y ** 2);\n}\n\nexport function getVector2Angle(vector: Vector2) {\n  const { x, y } = vector;\n  return Math.atan2(y, x);\n}\n\nexport function multiplyVector2ByScalar(\n  vector: Vector2,\n  scalar: number\n): Vector2 {\n  let { x, y } = vector;\n  x *= scalar;\n  y *= scalar;\n  return { x, y };\n}\nexport function normalizedVector2(vector: Vector2): Vector2 {\n  return multiplyVector2ByScalar(vector, 1 / getVector2Length(vector));\n}\n\nexport interface Vector3 extends Vector2 {\n  z: number;\n}\n\nexport interface Quaternion {\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\nexport interface Euler {\n  heading: number;\n  pitch: number;\n  roll: number;\n}\n\nexport function computeVoronoiWeights(\n  points: PressureSensorPosition[],\n  sampleCount = 100000\n) {\n  const n = points.length;\n  const counts = new Array(n).fill(0);\n\n  for (let i = 0; i < sampleCount; i++) {\n    const x = Math.random();\n    const y = Math.random();\n\n    // Find the closest input point\n    let minDist = Infinity;\n    let closestIndex = -1;\n\n    for (let j = 0; j < n; j++) {\n      const { x: px, y: py } = points[j];\n      const dist = (px - x) ** 2 + (py - y) ** 2; // Squared Euclidean distance\n      if (dist < minDist) {\n        minDist = dist;\n        closestIndex = j;\n      }\n    }\n\n    // Increment count for the closest point\n    counts[closestIndex]++;\n  }\n\n  // Convert counts to weights (sum to 1)\n  return counts.map((c) => c / sampleCount);\n}\n\nexport function getVector3Length(vector: Vector3) {\n  const { x, y, z } = vector;\n  return Math.sqrt(x ** 2 + y ** 2 + z ** 2);\n}\n\nexport function clamp(value: number, min: number = 0, max: number = 1) {\n  return Math.min(Math.max(value, min), max);\n}\n\nexport function degToRad(deg: number) {\n  return deg * (Math.PI / 180);\n}\n\nexport function radToDeg(rad: number) {\n  return rad * (180 / Math.PI);\n}\n\nexport const twoPi = Math.PI * 2;\nexport function normalizeRadians(rad: number): number {\n  return ((rad % twoPi) + twoPi) % twoPi;\n}\n","import { getInterpolation } from \"./MathUtils.ts\";\n\ninterface Range {\n  min: number;\n  max: number;\n  span: number;\n}\n\nconst initialRange: Range = { min: Infinity, max: -Infinity, span: 0 };\n\nclass RangeHelper {\n  #range: Range = Object.assign({}, initialRange);\n  get min() {\n    return this.#range.min;\n  }\n  get max() {\n    return this.#range.max;\n  }\n\n  set min(newMin) {\n    this.#range.min = newMin;\n    this.#range.max = Math.max(newMin, this.#range.max);\n    this.#updateSpan();\n  }\n  set max(newMax) {\n    this.#range.max = newMax;\n    this.#range.min = Math.min(newMax, this.#range.min);\n    this.#updateSpan();\n  }\n\n  #updateSpan() {\n    this.#range.span = this.#range.max - this.#range.min;\n  }\n\n  reset() {\n    Object.assign(this.#range, initialRange);\n  }\n\n  update(value: number) {\n    this.#range.min = Math.min(value, this.#range.min);\n    this.#range.max = Math.max(value, this.#range.max);\n    this.#updateSpan();\n  }\n\n  getNormalization(value: number, weightByRange: boolean) {\n    let normalization = getInterpolation(value, this.#range.min, this.#range.max, this.#range.span);\n    if (weightByRange) {\n      normalization *= this.#range.span;\n    }\n    return normalization || 0;\n  }\n\n  updateAndGetNormalization(value: number, weightByRange: boolean) {\n    this.update(value);\n    return this.getNormalization(value, weightByRange);\n  }\n}\n\nexport default RangeHelper;\n","import RangeHelper from \"./RangeHelper.ts\";\n\nimport { Vector2 } from \"./MathUtils.ts\";\n\nexport type CenterOfPressure = Vector2;\n\nexport interface CenterOfPressureRange {\n  x: RangeHelper;\n  y: RangeHelper;\n}\n\nclass CenterOfPressureHelper {\n  #range: CenterOfPressureRange = {\n    x: new RangeHelper(),\n    y: new RangeHelper(),\n  };\n  reset() {\n    this.#range.x.reset();\n    this.#range.y.reset();\n  }\n\n  update(centerOfPressure: CenterOfPressure) {\n    this.#range.x.update(centerOfPressure.x);\n    this.#range.y.update(centerOfPressure.y);\n  }\n  getNormalization(centerOfPressure: CenterOfPressure, weightByRange: boolean): CenterOfPressure {\n    return {\n      x: this.#range.x.getNormalization(centerOfPressure.x, weightByRange),\n      y: this.#range.y.getNormalization(centerOfPressure.y, weightByRange),\n    };\n  }\n\n  updateAndGetNormalization(centerOfPressure: CenterOfPressure, weightByRange: boolean) {\n    this.update(centerOfPressure);\n    return this.getNormalization(centerOfPressure, weightByRange);\n  }\n}\n\nexport default CenterOfPressureHelper;\n","export function createArray(arrayLength: number, objectOrCallback: ((index: number) => any) | object) {\n  return new Array(arrayLength).fill(1).map((_, index) => {\n    if (typeof objectOrCallback == \"function\") {\n      const callback = objectOrCallback;\n      return callback(index);\n    } else {\n      const object = objectOrCallback;\n      return Object.assign({}, object);\n    }\n  });\n}\n\nexport function arrayWithoutDuplicates(array: any[]) {\n  return array.filter((value, index) => array.indexOf(value) == index);\n}\n","import { createConsole } from \"../utils/Console.ts\";\nimport CenterOfPressureHelper from \"../utils/CenterOfPressureHelper.ts\";\nimport RangeHelper from \"../utils/RangeHelper.ts\";\nimport { createArray } from \"../utils/ArrayUtils.ts\";\n\nconst _console = createConsole(\"PressureDataManager\", { log: false });\n\nexport const PressureSensorTypes = [\"pressure\"] as const;\nexport type PressureSensorType = (typeof PressureSensorTypes)[number];\n\nexport const ContinuousPressureSensorTypes = PressureSensorTypes;\nexport type ContinuousPressureSensorType =\n  (typeof ContinuousPressureSensorTypes)[number];\n\nimport { computeVoronoiWeights, Vector2 } from \"../utils/MathUtils.ts\";\nexport type PressureSensorPosition = Vector2;\n\nimport { CenterOfPressure } from \"../utils/CenterOfPressureHelper.ts\";\n\nexport interface PressureSensorValue {\n  position: PressureSensorPosition;\n  rawValue: number;\n  scaledValue: number;\n  normalizedValue: number;\n  weightedValue: number;\n}\n\nexport interface PressureData {\n  sensors: PressureSensorValue[];\n  scaledSum: number;\n  normalizedSum: number;\n  center?: CenterOfPressure;\n  normalizedCenter?: CenterOfPressure;\n}\n\nexport interface PressureDataEventMessages {\n  pressure: { pressure: PressureData };\n}\n\nexport const DefaultNumberOfPressureSensors = 8;\n\nclass PressureSensorDataManager {\n  #positions: PressureSensorPosition[] = [];\n  get positions() {\n    return this.#positions;\n  }\n\n  get numberOfSensors() {\n    return this.positions.length;\n  }\n\n  parsePositions(dataView: DataView) {\n    const positions: PressureSensorPosition[] = [];\n\n    for (\n      let pressureSensorIndex = 0, byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      pressureSensorIndex++, byteOffset += 2\n    ) {\n      positions.push({\n        x: dataView.getUint8(byteOffset) / 2 ** 8,\n        y: dataView.getUint8(byteOffset + 1) / 2 ** 8,\n      });\n    }\n\n    _console.log({ positions });\n\n    this.#positions = positions;\n\n    this.#sensorRangeHelpers = createArray(\n      this.numberOfSensors,\n      () => new RangeHelper()\n    );\n\n    this.resetRange();\n  }\n\n  #sensorRangeHelpers!: RangeHelper[];\n  #normalizedSumRangeHelper = new RangeHelper();\n\n  #centerOfPressureHelper = new CenterOfPressureHelper();\n\n  resetRange() {\n    this.#sensorRangeHelpers?.forEach((rangeHelper) => rangeHelper.reset());\n    this.#centerOfPressureHelper.reset();\n    this.#normalizedSumRangeHelper.reset();\n  }\n\n  parseData(dataView: DataView, scalar: number) {\n    const pressure: PressureData = {\n      sensors: [],\n      scaledSum: 0,\n      normalizedSum: 0,\n    };\n    for (\n      let index = 0, byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      index++, byteOffset += 2\n    ) {\n      const rawValue = dataView.getUint16(byteOffset, true);\n      let scaledValue = (rawValue * scalar) / this.numberOfSensors;\n      const rangeHelper = this.#sensorRangeHelpers[index];\n      const normalizedValue = rangeHelper.updateAndGetNormalization(\n        scaledValue,\n        false\n      );\n      //scaledValue -= rangeHelper.min;\n\n      const position = this.positions[index];\n      pressure.sensors[index] = {\n        rawValue,\n        scaledValue,\n        normalizedValue,\n        position,\n        weightedValue: 0,\n      };\n\n      pressure.scaledSum += scaledValue;\n      //pressure.normalizedSum += normalizedValue;\n    }\n    pressure.normalizedSum =\n      this.#normalizedSumRangeHelper.updateAndGetNormalization(\n        pressure.scaledSum,\n        false\n      );\n\n    if (pressure.scaledSum > 0) {\n      pressure.center = { x: 0, y: 0 };\n      pressure.sensors.forEach((sensor) => {\n        sensor.weightedValue = sensor.scaledValue / pressure.scaledSum;\n        pressure.center!.x += sensor.position.x * sensor.weightedValue;\n        pressure.center!.y += sensor.position.y * sensor.weightedValue;\n      });\n      pressure.normalizedCenter =\n        this.#centerOfPressureHelper.updateAndGetNormalization(\n          pressure.center,\n          false\n        );\n    }\n\n    _console.log({ pressure });\n    return pressure;\n  }\n}\n\nexport default PressureSensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\n\nconst _console = createConsole(\"MotionSensorDataManager\", { log: false });\n\nexport const MotionSensorTypes = [\n  \"acceleration\",\n  \"gravity\",\n  \"linearAcceleration\",\n  \"gyroscope\",\n  \"magnetometer\",\n  \"gameRotation\",\n  \"rotation\",\n  \"orientation\",\n  \"activity\",\n  \"stepCounter\",\n  \"stepDetector\",\n  \"deviceOrientation\",\n  \"tapDetector\",\n] as const;\nexport type MotionSensorType = (typeof MotionSensorTypes)[number];\n\nexport const ContinuousMotionTypes = [\n  \"acceleration\",\n  \"gravity\",\n  \"linearAcceleration\",\n  \"gyroscope\",\n  \"magnetometer\",\n  \"gameRotation\",\n  \"rotation\",\n  \"orientation\",\n] as const;\nexport type ContinuousMotionType = (typeof ContinuousMotionTypes)[number];\n\nimport { Vector3, Quaternion, Euler } from \"../utils/MathUtils.ts\";\nimport { ValueOf } from \"../utils/TypeScriptUtils.ts\";\n\nexport const Vector2Size = 2 * 2;\nexport const Vector3Size = 3 * 2;\nexport const QuaternionSize = 4 * 2;\n\nexport const ActivityTypes = [\n  \"still\",\n  \"walking\",\n  \"running\",\n  \"bicycle\",\n  \"vehicle\",\n  \"tilting\",\n] as const;\nexport type ActivityType = (typeof ActivityTypes)[number];\n\nexport interface Activity {\n  still: boolean;\n  walking: boolean;\n  running: boolean;\n  bicycle: boolean;\n  vehicle: boolean;\n  tilting: boolean;\n}\n\nexport const DeviceOrientations = [\n  \"portraitUpright\",\n  \"landscapeLeft\",\n  \"portraitUpsideDown\",\n  \"landscapeRight\",\n  \"unknown\",\n] as const;\nexport type DeviceOrientation = (typeof DeviceOrientations)[number];\n\nexport interface MotionSensorDataEventMessages {\n  acceleration: { acceleration: Vector3 };\n  gravity: { gravity: Vector3 };\n  linearAcceleration: { linearAcceleration: Vector3 };\n  gyroscope: { gyroscope: Vector3 };\n  magnetometer: { magnetometer: Vector3 };\n  gameRotation: { gameRotation: Quaternion };\n  rotation: { rotation: Quaternion };\n  orientation: { orientation: Euler };\n  stepDetector: { stepDetector: Object };\n  stepCounter: { stepCounter: number };\n  activity: { activity: Activity };\n  deviceOrientation: { deviceOrientation: DeviceOrientation };\n  tapDetector: { tapDetector: Object };\n}\n\nexport type MotionSensorDataEventMessage =\n  ValueOf<MotionSensorDataEventMessages>;\n\nclass MotionSensorDataManager {\n  parseVector3(dataView: DataView, scalar: number): Vector3 {\n    let [x, y, z] = [\n      dataView.getInt16(0, true),\n      dataView.getInt16(2, true),\n      dataView.getInt16(4, true),\n    ].map((value) => value * scalar);\n\n    const vector: Vector3 = { x, y, z };\n\n    _console.log({ vector });\n    return vector;\n  }\n\n  parseQuaternion(dataView: DataView, scalar: number): Quaternion {\n    let [x, y, z, w] = [\n      dataView.getInt16(0, true),\n      dataView.getInt16(2, true),\n      dataView.getInt16(4, true),\n      dataView.getInt16(6, true),\n    ].map((value) => value * scalar);\n\n    const quaternion: Quaternion = { x, y, z, w };\n\n    _console.log({ quaternion });\n    return quaternion;\n  }\n\n  parseEuler(dataView: DataView, scalar: number): Euler {\n    let [heading, pitch, roll] = [\n      dataView.getInt16(0, true),\n      dataView.getInt16(2, true),\n      dataView.getInt16(4, true),\n    ].map((value) => value * scalar);\n\n    pitch *= -1;\n    heading *= -1;\n    if (heading < 0) {\n      heading += 360;\n    }\n\n    const euler: Euler = { heading, pitch, roll };\n\n    _console.log({ euler });\n    return euler;\n  }\n\n  parseStepCounter(dataView: DataView) {\n    _console.log(\"parseStepCounter\", dataView);\n    const stepCount = dataView.getUint32(0, true);\n    _console.log({ stepCount });\n    return stepCount;\n  }\n\n  parseActivity(dataView: DataView) {\n    _console.log(\"parseActivity\", dataView);\n    const activity: Partial<Activity> = {};\n\n    const activityBitfield = dataView.getUint8(0);\n    _console.log(\"activityBitfield\", activityBitfield.toString(2));\n    ActivityTypes.forEach((activityType, index) => {\n      activity[activityType] = Boolean(activityBitfield & (1 << index));\n    });\n\n    _console.log(\"activity\", activity);\n\n    return activity as Activity;\n  }\n\n  parseDeviceOrientation(dataView: DataView) {\n    _console.log(\"parseDeviceOrientation\", dataView);\n    const index = dataView.getUint8(0);\n    const deviceOrientation = DeviceOrientations[index];\n    _console.assertWithError(deviceOrientation, \"undefined deviceOrientation\");\n    _console.log({ deviceOrientation });\n    return deviceOrientation;\n  }\n}\n\nexport default MotionSensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\n\nexport const BarometerSensorTypes = [\"barometer\"] as const;\nexport type BarometerSensorType = (typeof BarometerSensorTypes)[number];\n\nexport const ContinuousBarometerSensorTypes = BarometerSensorTypes;\nexport type ContinuousBarometerSensorType = (typeof ContinuousBarometerSensorTypes)[number];\n\nexport interface BarometerSensorDataEventMessages {\n  barometer: {\n    barometer: number;\n    //altitude: number;\n  };\n}\n\nconst _console = createConsole(\"BarometerSensorDataManager\", { log: false });\n\nclass BarometerSensorDataManager {\n  #calculcateAltitude(pressure: number) {\n    const P0 = 101325; // Standard atmospheric pressure at sea level in Pascals\n    const T0 = 288.15; // Standard temperature at sea level in Kelvin\n    const L = 0.0065; // Temperature lapse rate in K/m\n    const R = 8.3144598; // Universal gas constant in J/(mol·K)\n    const g = 9.80665; // Acceleration due to gravity in m/s²\n    const M = 0.0289644; // Molar mass of Earth's air in kg/mol\n\n    const exponent = (R * L) / (g * M);\n    const h = (T0 / L) * (1 - Math.pow(pressure / P0, exponent));\n\n    return h;\n  }\n\n  parseData(dataView: DataView, scalar: number) {\n    const pressure = dataView.getUint32(0, true) * scalar;\n    const altitude = this.#calculcateAltitude(pressure);\n    _console.log({ pressure, altitude });\n    return { pressure };\n  }\n}\n\nexport default BarometerSensorDataManager;\n","import { sliceDataView } from \"./ArrayBufferUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { textDecoder } from \"./Text.ts\";\n\nconst _console = createConsole(\"ParseUtils\", { log: false });\n\nexport function parseStringFromDataView(\n  dataView: DataView,\n  byteOffset: number = 0\n) {\n  const stringLength = dataView.getUint8(byteOffset++);\n  const string = textDecoder.decode(\n    dataView.buffer.slice(\n      dataView.byteOffset + byteOffset,\n      dataView.byteOffset + byteOffset + stringLength\n    )\n  );\n  byteOffset += stringLength;\n  return { string, byteOffset };\n}\n\nexport function parseMessage<MessageType extends string>(\n  dataView: DataView,\n  messageTypes: readonly MessageType[],\n  callback: (\n    messageType: MessageType,\n    dataView: DataView,\n    context?: any\n  ) => void,\n  context?: any,\n  parseMessageLengthAsUint16: boolean = false\n) {\n  let byteOffset = 0;\n  while (byteOffset < dataView.byteLength) {\n    const messageTypeEnum = dataView.getUint8(byteOffset++);\n    _console.assertWithError(\n      messageTypeEnum in messageTypes,\n      `invalid messageTypeEnum ${messageTypeEnum}`\n    );\n    const messageType = messageTypes[messageTypeEnum];\n\n    let messageLength: number;\n    if (parseMessageLengthAsUint16) {\n      messageLength = dataView.getUint16(byteOffset, true);\n      byteOffset += 2;\n    } else {\n      messageLength = dataView.getUint8(byteOffset++);\n    }\n\n    _console.log({\n      messageTypeEnum,\n      messageType,\n      messageLength,\n      dataView,\n      byteOffset,\n    });\n\n    const _dataView = sliceDataView(dataView, byteOffset, messageLength);\n    _console.log({ _dataView });\n\n    callback(messageType, _dataView, context);\n\n    byteOffset += messageLength;\n  }\n}\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInNode } from \"./utils/environment.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\nimport { parseMessage } from \"./utils/ParseUtils.ts\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./utils/ArrayBufferUtils.ts\";\n\nconst _console = createConsole(\"CameraManager\", { log: false });\n\nexport const CameraSensorTypes = [\"camera\"] as const;\nexport type CameraSensorType = (typeof CameraSensorTypes)[number];\n\nexport const CameraCommands = [\n  \"focus\",\n  \"takePicture\",\n  \"stop\",\n  \"sleep\",\n  \"wake\",\n] as const;\nexport type CameraCommand = (typeof CameraCommands)[number];\n\nexport const CameraStatuses = [\n  \"idle\",\n  \"focusing\",\n  \"takingPicture\",\n  \"asleep\",\n] as const;\nexport type CameraStatus = (typeof CameraStatuses)[number];\n\nexport const CameraDataTypes = [\n  \"headerSize\",\n  \"header\",\n  \"imageSize\",\n  \"image\",\n  \"footerSize\",\n  \"footer\",\n] as const;\nexport type CameraDataType = (typeof CameraDataTypes)[number];\n\nexport const CameraConfigurationTypes = [\n  \"resolution\",\n  \"qualityFactor\",\n  \"shutter\",\n  \"gain\",\n  \"redGain\",\n  \"greenGain\",\n  \"blueGain\",\n] as const;\nexport type CameraConfigurationType = (typeof CameraConfigurationTypes)[number];\n\nexport const CameraMessageTypes = [\n  \"cameraStatus\",\n  \"cameraCommand\",\n  \"getCameraConfiguration\",\n  \"setCameraConfiguration\",\n  \"cameraData\",\n] as const;\nexport type CameraMessageType = (typeof CameraMessageTypes)[number];\n\nexport type CameraConfiguration = {\n  [cameraConfigurationType in CameraConfigurationType]?: number;\n};\nexport type CameraConfigurationRanges = {\n  [cameraConfigurationType in CameraConfigurationType]: {\n    min: number;\n    max: number;\n  };\n};\n\nexport const RequiredCameraMessageTypes: CameraMessageType[] = [\n  \"getCameraConfiguration\",\n  \"cameraStatus\",\n] as const;\n\nexport const CameraEventTypes = [\n  ...CameraMessageTypes,\n  \"cameraImageProgress\",\n  \"cameraImage\",\n] as const;\nexport type CameraEventType = (typeof CameraEventTypes)[number];\n\nexport interface CameraEventMessages {\n  cameraStatus: {\n    cameraStatus: CameraStatus;\n    previousCameraStatus: CameraStatus;\n  };\n  getCameraConfiguration: { cameraConfiguration: CameraConfiguration };\n  cameraImageProgress: { progress: number; type: CameraDataType };\n  cameraImage: { blob: Blob; url: string };\n}\n\nexport type CameraEventDispatcher = EventDispatcher<\n  Device,\n  CameraEventType,\n  CameraEventMessages\n>;\nexport type SendCameraMessageCallback = SendMessageCallback<CameraMessageType>;\n\nclass CameraManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendCameraMessageCallback;\n\n  eventDispatcher!: CameraEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required camera information\");\n    const messages = RequiredCameraMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // CAMERA STATUS\n  #cameraStatus!: CameraStatus;\n  get cameraStatus() {\n    return this.#cameraStatus;\n  }\n  #parseCameraStatus(dataView: DataView) {\n    const cameraStatusIndex = dataView.getUint8(0);\n    const newCameraStatus = CameraStatuses[cameraStatusIndex];\n    this.#updateCameraStatus(newCameraStatus);\n  }\n  #updateCameraStatus(newCameraStatus: CameraStatus) {\n    _console.assertEnumWithError(newCameraStatus, CameraStatuses);\n    if (newCameraStatus == this.#cameraStatus) {\n      _console.log(`redundant cameraStatus ${newCameraStatus}`);\n      return;\n    }\n    const previousCameraStatus = this.#cameraStatus;\n    this.#cameraStatus = newCameraStatus;\n    _console.log(`updated cameraStatus to \"${this.cameraStatus}\"`);\n    this.#dispatchEvent(\"cameraStatus\", {\n      cameraStatus: this.cameraStatus,\n      previousCameraStatus,\n    });\n\n    if (\n      this.#cameraStatus != \"takingPicture\" &&\n      this.#imageProgress > 0 &&\n      !this.#didBuildImage\n    ) {\n      this.#buildImage();\n    }\n  }\n\n  // CAMERA COMMAND\n  async #sendCameraCommand(command: CameraCommand, sendImmediately?: boolean) {\n    _console.assertEnumWithError(command, CameraCommands);\n    _console.log(`sending camera command \"${command}\"`);\n\n    const promise = this.waitForEvent(\"cameraStatus\");\n    _console.log(`setting command \"${command}\"`);\n    const commandEnum = CameraCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"cameraCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  #assertIsAsleep() {\n    _console.assertWithError(\n      this.#cameraStatus == \"asleep\",\n      `camera is not asleep - currently ${this.#cameraStatus}`\n    );\n  }\n  #assertIsAwake() {\n    _console.assertWithError(\n      this.#cameraStatus != \"asleep\",\n      `camera is not awake - currently ${this.#cameraStatus}`\n    );\n  }\n  async focus() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"focus\");\n  }\n  async takePicture() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"takePicture\");\n  }\n  async stop() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"stop\");\n  }\n  async sleep() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"sleep\");\n  }\n  async wake() {\n    this.#assertIsAsleep();\n    await this.#sendCameraCommand(\"wake\");\n  }\n\n  // CAMERA DATA\n  #parseCameraData(dataView: DataView) {\n    _console.log(\"parsing camera data\", dataView);\n    parseMessage(\n      dataView,\n      CameraDataTypes,\n      this.#onCameraData.bind(this),\n      null,\n      true\n    );\n  }\n  #onCameraData(cameraDataType: CameraDataType, dataView: DataView) {\n    _console.log({ cameraDataType, dataView });\n    switch (cameraDataType) {\n      case \"headerSize\":\n        this.#headerSize = dataView.getUint16(0, true);\n        _console.log({ headerSize: this.#headerSize });\n        this.#headerData = undefined;\n        this.#headerProgress == 0;\n        break;\n      case \"header\":\n        this.#headerData = concatenateArrayBuffers(this.#headerData, dataView);\n        _console.log({ headerData: this.#headerData });\n        this.#headerProgress = this.#headerData?.byteLength / this.#headerSize;\n        _console.log({ headerProgress: this.#headerProgress });\n        this.#dispatchEvent(\"cameraImageProgress\", {\n          progress: this.#headerProgress,\n          type: \"header\",\n        });\n        if (this.#headerProgress == 1) {\n          _console.log(\"finished getting header data\");\n        }\n        break;\n      case \"imageSize\":\n        this.#imageSize = dataView.getUint16(0, true);\n        _console.log({ imageSize: this.#imageSize });\n        this.#imageData = undefined;\n        this.#imageProgress == 0;\n        this.#didBuildImage = false;\n        break;\n      case \"image\":\n        this.#imageData = concatenateArrayBuffers(this.#imageData, dataView);\n        _console.log({ imageData: this.#imageData });\n        this.#imageProgress = this.#imageData?.byteLength / this.#imageSize;\n        _console.log({ imageProgress: this.#imageProgress });\n        this.#dispatchEvent(\"cameraImageProgress\", {\n          progress: this.#imageProgress,\n          type: \"image\",\n        });\n        if (this.#imageProgress == 1) {\n          _console.log(\"finished getting image data\");\n          if (this.#headerProgress == 1) {\n            this.#buildImage();\n          }\n        }\n        break;\n      case \"footerSize\":\n        this.#footerSize = dataView.getUint16(0, true);\n        _console.log({ footerSize: this.#footerSize });\n        this.#footerData = undefined;\n        this.#footerProgress == 0;\n        break;\n      case \"footer\":\n        this.#footerData = concatenateArrayBuffers(this.#footerData, dataView);\n        _console.log({ footerData: this.#footerData });\n        this.#footerProgress = this.#footerData?.byteLength / this.#footerSize;\n        _console.log({ footerProgress: this.#footerProgress });\n        this.#dispatchEvent(\"cameraImageProgress\", {\n          progress: this.#footerProgress,\n          type: \"footer\",\n        });\n        if (this.#footerProgress == 1) {\n          _console.log(\"finished getting footer data\");\n          if (this.#imageProgress == 1) {\n            this.#buildImage();\n          }\n        }\n        break;\n    }\n  }\n\n  #headerSize: number = 0;\n  #headerData?: ArrayBuffer;\n  #headerProgress: number = 0;\n\n  #imageSize: number = 0;\n  #imageData?: ArrayBuffer;\n  #imageProgress: number = 0;\n\n  #footerSize: number = 0;\n  #footerData?: ArrayBuffer;\n  #footerProgress: number = 0;\n\n  #didBuildImage: boolean = false;\n  #buildImage() {\n    _console.log(\"building image...\");\n    const imageData = concatenateArrayBuffers(\n      this.#headerData,\n      this.#imageData,\n      this.#footerData\n    );\n    _console.log({ imageData });\n\n    let blob = new Blob([imageData], { type: \"image/jpeg\" });\n    _console.log(\"created blob\", blob);\n\n    const url = URL.createObjectURL(blob);\n    _console.log(\"created url\", url);\n\n    this.#dispatchEvent(\"cameraImage\", { url, blob });\n\n    this.#didBuildImage = true;\n  }\n\n  // CONFIG\n  #cameraConfiguration: CameraConfiguration = {};\n  get cameraConfiguration() {\n    return this.#cameraConfiguration;\n  }\n  #availableCameraConfigurationTypes!: CameraConfigurationType[];\n  get availableCameraConfigurationTypes() {\n    return this.#availableCameraConfigurationTypes;\n  }\n\n  #cameraConfigurationRanges: CameraConfigurationRanges = {\n    resolution: { min: 100, max: 720 },\n    qualityFactor: { min: 15, max: 60 },\n    shutter: { min: 4, max: 16383 },\n    gain: { min: 1, max: 248 },\n    redGain: { min: 0, max: 1023 },\n    greenGain: { min: 0, max: 1023 },\n    blueGain: { min: 0, max: 1023 },\n  };\n  get cameraConfigurationRanges() {\n    return this.#cameraConfigurationRanges;\n  }\n\n  #parseCameraConfiguration(dataView: DataView) {\n    const parsedCameraConfiguration: CameraConfiguration = {};\n\n    let byteOffset = 0;\n    while (byteOffset < dataView.byteLength) {\n      const cameraConfigurationTypeIndex = dataView.getUint8(byteOffset++);\n      const cameraConfigurationType =\n        CameraConfigurationTypes[cameraConfigurationTypeIndex];\n      _console.assertWithError(\n        cameraConfigurationType,\n        `invalid cameraConfigurationTypeIndex ${cameraConfigurationTypeIndex}`\n      );\n      parsedCameraConfiguration[cameraConfigurationType] = dataView.getUint16(\n        byteOffset,\n        true\n      );\n      byteOffset += 2;\n    }\n\n    _console.log({ parsedCameraConfiguration });\n    this.#availableCameraConfigurationTypes = Object.keys(\n      parsedCameraConfiguration\n    ) as CameraConfigurationType[];\n    this.#cameraConfiguration = parsedCameraConfiguration;\n    this.#dispatchEvent(\"getCameraConfiguration\", {\n      cameraConfiguration: this.#cameraConfiguration,\n    });\n  }\n\n  #isCameraConfigurationRedundant(cameraConfiguration: CameraConfiguration) {\n    let cameraConfigurationTypes = Object.keys(\n      cameraConfiguration\n    ) as CameraConfigurationType[];\n    return cameraConfigurationTypes.every((cameraConfigurationType) => {\n      return (\n        this.cameraConfiguration[cameraConfigurationType] ==\n        cameraConfiguration[cameraConfigurationType]\n      );\n    });\n  }\n  async setCameraConfiguration(newCameraConfiguration: CameraConfiguration) {\n    _console.log({ newCameraConfiguration });\n    if (this.#isCameraConfigurationRedundant(newCameraConfiguration)) {\n      _console.log(\"redundant camera configuration\");\n      return;\n    }\n    const setCameraConfigurationData = this.#createData(newCameraConfiguration);\n    _console.log({ setCameraConfigurationData });\n\n    const promise = this.waitForEvent(\"getCameraConfiguration\");\n    this.sendMessage([\n      {\n        type: \"setCameraConfiguration\",\n        data: setCameraConfigurationData.buffer,\n      },\n    ]);\n    await promise;\n  }\n\n  #assertAvailableCameraConfigurationType(\n    cameraConfigurationType: CameraConfigurationType\n  ) {\n    _console.assertWithError(\n      this.#availableCameraConfigurationTypes,\n      \"must get initial cameraConfiguration\"\n    );\n    const isCameraConfigurationTypeAvailable =\n      this.#availableCameraConfigurationTypes?.includes(\n        cameraConfigurationType\n      );\n    _console.assertWithError(\n      isCameraConfigurationTypeAvailable,\n      `unavailable camera configuration type \"${cameraConfigurationType}\"`\n    );\n    return isCameraConfigurationTypeAvailable;\n  }\n\n  static AssertValidCameraConfigurationType(\n    cameraConfigurationType: CameraConfigurationType\n  ) {\n    _console.assertEnumWithError(\n      cameraConfigurationType,\n      CameraConfigurationTypes\n    );\n  }\n  static AssertValidCameraConfigurationTypeEnum(\n    cameraConfigurationTypeEnum: number\n  ) {\n    _console.assertTypeWithError(cameraConfigurationTypeEnum, \"number\");\n    _console.assertWithError(\n      cameraConfigurationTypeEnum in CameraConfigurationTypes,\n      `invalid cameraConfigurationTypeEnum ${cameraConfigurationTypeEnum}`\n    );\n  }\n\n  #createData(cameraConfiguration: CameraConfiguration) {\n    let cameraConfigurationTypes = Object.keys(\n      cameraConfiguration\n    ) as CameraConfigurationType[];\n    cameraConfigurationTypes = cameraConfigurationTypes.filter(\n      (cameraConfigurationType) =>\n        this.#assertAvailableCameraConfigurationType(cameraConfigurationType)\n    );\n\n    const dataView = new DataView(\n      new ArrayBuffer(cameraConfigurationTypes.length * 3)\n    );\n    cameraConfigurationTypes.forEach((cameraConfigurationType, index) => {\n      CameraManager.AssertValidCameraConfigurationType(cameraConfigurationType);\n      const cameraConfigurationTypeEnum = CameraConfigurationTypes.indexOf(\n        cameraConfigurationType\n      );\n      dataView.setUint8(index * 3, cameraConfigurationTypeEnum);\n\n      const value = cameraConfiguration[cameraConfigurationType]!;\n      //this.#assertValidCameraConfigurationValue(cameraConfigurationType, value);\n      dataView.setUint16(index * 3 + 1, value, true);\n    });\n    _console.log({ sensorConfigurationData: dataView });\n    return dataView;\n  }\n\n  // MESSAGE\n  parseMessage(messageType: CameraMessageType, dataView: DataView) {\n    _console.log({ messageType, dataView });\n\n    switch (messageType) {\n      case \"cameraStatus\":\n        this.#parseCameraStatus(dataView);\n        break;\n      case \"getCameraConfiguration\":\n      case \"setCameraConfiguration\":\n        this.#parseCameraConfiguration(dataView);\n        break;\n      case \"cameraData\":\n        this.#parseCameraData(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    // @ts-ignore\n    this.#cameraStatus = undefined;\n    this.#headerProgress = 0;\n    this.#imageProgress = 0;\n    this.#footerProgress = 0;\n  }\n}\n\nexport default CameraManager;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"AudioUtils\", { log: false });\n\nexport function float32ArrayToWav(\n  audioData: Float32Array,\n  sampleRate: number,\n  numChannels: number\n): Blob {\n  const wavBuffer = encodeWAV(audioData, sampleRate, numChannels);\n  return new Blob([wavBuffer], { type: \"audio/wav\" });\n}\n\nfunction encodeWAV(\n  interleaved: Float32Array,\n  sampleRate: number,\n  numChannels: number\n): ArrayBuffer {\n  const buffer = new ArrayBuffer(44 + interleaved.length * 2); // 44 bytes for WAV header\n  const view = new DataView(buffer);\n\n  // RIFF identifier\n  writeString(view, 0, \"RIFF\");\n  // File length minus RIFF identifier length and file description length\n  view.setUint32(4, 36 + interleaved.length * 2, true);\n  // RIFF type\n  writeString(view, 8, \"WAVE\");\n  // Format chunk identifier\n  writeString(view, 12, \"fmt \");\n  // Format chunk length\n  view.setUint32(16, 16, true);\n  // Sample format (raw)\n  view.setUint16(20, 1, true);\n  // Channel count\n  view.setUint16(22, numChannels, true);\n  // Sample rate\n  view.setUint32(24, sampleRate, true);\n  // Byte rate (sample rate * block align)\n  view.setUint32(28, sampleRate * numChannels * 2, true);\n  // Block align (channel count * bytes per sample)\n  view.setUint16(32, numChannels * 2, true);\n  // Bits per sample\n  view.setUint16(34, 16, true);\n  // Data chunk identifier\n  writeString(view, 36, \"data\");\n  // Data chunk length\n  view.setUint32(40, interleaved.length * 2, true);\n\n  // Write interleaved audio data\n  for (let i = 0; i < interleaved.length; i++) {\n    view.setInt16(44 + i * 2, interleaved[i] * 0x7fff, true); // Convert float [-1, 1] to int16\n  }\n\n  return buffer;\n}\n\nexport function writeString(\n  view: DataView,\n  offset: number,\n  string: string\n): void {\n  for (let i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./utils/ArrayBufferUtils.ts\";\nimport { float32ArrayToWav } from \"./utils/AudioUtils.ts\";\n\nconst _console = createConsole(\"MicrophoneManager\", { log: false });\n\nexport const MicrophoneSensorTypes = [\"microphone\"] as const;\nexport type MicrophoneSensorType = (typeof MicrophoneSensorTypes)[number];\n\nexport const MicrophoneCommands = [\"start\", \"stop\", \"vad\"] as const;\nexport type MicrophoneCommand = (typeof MicrophoneCommands)[number];\n\nexport const MicrophoneStatuses = [\"idle\", \"streaming\", \"vad\"] as const;\nexport type MicrophoneStatus = (typeof MicrophoneStatuses)[number];\n\nexport const MicrophoneConfigurationTypes = [\"sampleRate\", \"bitDepth\"] as const;\nexport type MicrophoneConfigurationType =\n  (typeof MicrophoneConfigurationTypes)[number];\n\nexport const MicrophoneSampleRates = [\"8000\", \"16000\"] as const;\nexport type MicrophoneSampleRate = (typeof MicrophoneSampleRates)[number];\n\nexport const MicrophoneBitDepths = [\"8\", \"16\"] as const;\nexport type MicrophoneBitDepth = (typeof MicrophoneBitDepths)[number];\n\nexport const MicrophoneMessageTypes = [\n  \"microphoneStatus\",\n  \"microphoneCommand\",\n  \"getMicrophoneConfiguration\",\n  \"setMicrophoneConfiguration\",\n  \"microphoneData\",\n] as const;\nexport type MicrophoneMessageType = (typeof MicrophoneMessageTypes)[number];\n\nexport type MicrophoneConfiguration = {\n  sampleRate?: MicrophoneSampleRate;\n  bitDepth?: MicrophoneBitDepth;\n};\n\nexport const MicrophoneConfigurationValues = {\n  sampleRate: MicrophoneSampleRates,\n  bitDepth: MicrophoneBitDepths,\n};\n\nexport const RequiredMicrophoneMessageTypes: MicrophoneMessageType[] = [\n  \"getMicrophoneConfiguration\",\n  \"microphoneStatus\",\n] as const;\n\nexport const MicrophoneEventTypes = [\n  ...MicrophoneMessageTypes,\n  \"isRecordingMicrophone\",\n  \"microphoneRecording\",\n] as const;\nexport type MicrophoneEventType = (typeof MicrophoneEventTypes)[number];\n\nexport interface MicrophoneEventMessages {\n  microphoneStatus: {\n    microphoneStatus: MicrophoneStatus;\n    previousMicrophoneStatus: MicrophoneStatus;\n  };\n  getMicrophoneConfiguration: {\n    microphoneConfiguration: MicrophoneConfiguration;\n  };\n  microphoneData: {\n    samples: Float32Array;\n    sampleRate: MicrophoneSampleRate;\n    bitDepth: MicrophoneBitDepth;\n  };\n  isRecordingMicrophone: {\n    isRecordingMicrophone: boolean;\n  };\n  microphoneRecording: {\n    samples: Float32Array;\n    sampleRate: MicrophoneSampleRate;\n    bitDepth: MicrophoneBitDepth;\n    blob: Blob;\n    url: string;\n  };\n}\n\nexport type MicrophoneEventDispatcher = EventDispatcher<\n  Device,\n  MicrophoneEventType,\n  MicrophoneEventMessages\n>;\nexport type SendMicrophoneMessageCallback =\n  SendMessageCallback<MicrophoneMessageType>;\n\nclass MicrophoneManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendMicrophoneMessageCallback;\n\n  eventDispatcher!: MicrophoneEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required microphone information\");\n    const messages = RequiredMicrophoneMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // MICROPHONE STATUS\n  #microphoneStatus!: MicrophoneStatus;\n  get microphoneStatus() {\n    return this.#microphoneStatus;\n  }\n  #parseMicrophoneStatus(dataView: DataView) {\n    const microphoneStatusIndex = dataView.getUint8(0);\n    const newMicrophoneStatus = MicrophoneStatuses[microphoneStatusIndex];\n    this.#updateMicrophoneStatus(newMicrophoneStatus);\n  }\n  #updateMicrophoneStatus(newMicrophoneStatus: MicrophoneStatus) {\n    _console.assertEnumWithError(newMicrophoneStatus, MicrophoneStatuses);\n    if (newMicrophoneStatus == this.#microphoneStatus) {\n      _console.log(`redundant microphoneStatus ${newMicrophoneStatus}`);\n      return;\n    }\n    const previousMicrophoneStatus = this.#microphoneStatus;\n    this.#microphoneStatus = newMicrophoneStatus;\n    _console.log(`updated microphoneStatus to \"${this.microphoneStatus}\"`);\n    this.#dispatchEvent(\"microphoneStatus\", {\n      microphoneStatus: this.microphoneStatus,\n      previousMicrophoneStatus,\n    });\n  }\n\n  // MICROPHONE COMMAND\n  async #sendMicrophoneCommand(\n    command: MicrophoneCommand,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(command, MicrophoneCommands);\n    _console.log(`sending microphone command \"${command}\"`);\n\n    const promise = this.waitForEvent(\"microphoneStatus\");\n    _console.log(`setting command \"${command}\"`);\n    const commandEnum = MicrophoneCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"microphoneCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  #assertIsIdle() {\n    _console.assertWithError(\n      this.#microphoneStatus == \"idle\",\n      `microphone is not idle - currently ${this.#microphoneStatus}`\n    );\n  }\n  #assertIsNotIdle() {\n    _console.assertWithError(\n      this.#microphoneStatus != \"idle\",\n      `microphone is idle`\n    );\n  }\n  #assertIsStreaming() {\n    _console.assertWithError(\n      this.#microphoneStatus == \"streaming\",\n      `microphone is not recording - currently ${this.#microphoneStatus}`\n    );\n  }\n\n  async start() {\n    await this.#sendMicrophoneCommand(\"start\");\n  }\n  async stop() {\n    this.#assertIsNotIdle();\n    await this.#sendMicrophoneCommand(\"stop\");\n  }\n  async vad() {\n    await this.#sendMicrophoneCommand(\"vad\");\n  }\n  async toggle() {\n    switch (this.microphoneStatus) {\n      case \"idle\":\n        this.start();\n        break;\n      case \"streaming\":\n        this.stop();\n        break;\n    }\n  }\n\n  // MICROPHONE DATA\n  #assertValidBitDepth() {\n    _console.assertEnumWithError(this.bitDepth!, MicrophoneBitDepths);\n  }\n  #fadeDuration = 0.001;\n  #playbackTime = 0;\n  #parseMicrophoneData(dataView: DataView) {\n    this.#assertValidBitDepth();\n\n    _console.log(\"parsing microphone data\", dataView);\n\n    const numberOfSamples = dataView.byteLength / this.#bytesPerSample!;\n    const samples = new Float32Array(numberOfSamples);\n\n    for (let i = 0; i < numberOfSamples; i++) {\n      let sample;\n      switch (this.bitDepth) {\n        case \"16\":\n          sample = dataView.getInt16(i * 2, true);\n          samples[i] = sample / 2 ** 15; // Normalize to [-1, 1]\n          break;\n        case \"8\":\n          sample = dataView.getInt8(i);\n          samples[i] = sample / 2 ** 7; // Normalize to [-1, 1]\n          break;\n      }\n    }\n\n    _console.log(\"samples\", samples);\n\n    if (this.#isRecording && this.#microphoneRecordingData) {\n      this.#microphoneRecordingData!.push(samples);\n    }\n\n    if (this.#audioContext) {\n      if (this.#gainNode) {\n        const audioBuffer = this.#audioContext.createBuffer(\n          1,\n          samples.length,\n          Number(this.sampleRate!)\n        );\n        audioBuffer.getChannelData(0).set(samples);\n\n        const bufferSource = this.#audioContext.createBufferSource();\n        bufferSource.buffer = audioBuffer;\n\n        const channelData = audioBuffer.getChannelData(0);\n        const sampleRate = Number(this.sampleRate!);\n\n        for (let i = 0; i < this.#fadeDuration * sampleRate; i++) {\n          channelData[i] *= i / (this.#fadeDuration * sampleRate);\n        }\n\n        for (\n          let i = channelData.length - 1;\n          i >= channelData.length - this.#fadeDuration * sampleRate;\n          i--\n        ) {\n          channelData[i] *=\n            (channelData.length - i) / (this.#fadeDuration * sampleRate);\n        }\n\n        bufferSource.connect(this.#gainNode!);\n\n        if (this.#playbackTime < this.#audioContext.currentTime) {\n          this.#playbackTime = this.#audioContext.currentTime;\n        }\n        bufferSource.start(this.#playbackTime);\n        this.#playbackTime += audioBuffer.duration;\n      }\n    }\n\n    this.#dispatchEvent(\"microphoneData\", {\n      samples,\n      sampleRate: this.sampleRate!,\n      bitDepth: this.bitDepth!,\n    });\n  }\n  get #bytesPerSample() {\n    switch (this.bitDepth) {\n      case \"8\":\n        return 1;\n      case \"16\":\n        return 2;\n    }\n  }\n\n  // CONFIG\n  #microphoneConfiguration: MicrophoneConfiguration = {};\n  get microphoneConfiguration() {\n    return this.#microphoneConfiguration;\n  }\n  #availableMicrophoneConfigurationTypes!: MicrophoneConfigurationType[];\n  get availableMicrophoneConfigurationTypes() {\n    return this.#availableMicrophoneConfigurationTypes;\n  }\n\n  get bitDepth() {\n    return this.#microphoneConfiguration.bitDepth;\n  }\n  get sampleRate() {\n    return this.#microphoneConfiguration.sampleRate;\n  }\n\n  #parseMicrophoneConfiguration(dataView: DataView) {\n    const parsedMicrophoneConfiguration: MicrophoneConfiguration = {};\n\n    let byteOffset = 0;\n    while (byteOffset < dataView.byteLength) {\n      const microphoneConfigurationTypeIndex = dataView.getUint8(byteOffset++);\n      const microphoneConfigurationType =\n        MicrophoneConfigurationTypes[microphoneConfigurationTypeIndex];\n      _console.assertWithError(\n        microphoneConfigurationType,\n        `invalid microphoneConfigurationTypeIndex ${microphoneConfigurationTypeIndex}`\n      );\n      let rawValue = dataView.getUint8(byteOffset++);\n      const values = MicrophoneConfigurationValues[microphoneConfigurationType];\n      const value = values[rawValue];\n      _console.assertEnumWithError(value, values);\n      _console.log({ microphoneConfigurationType, value });\n      // @ts-expect-error\n      parsedMicrophoneConfiguration[microphoneConfigurationType] = value;\n    }\n\n    _console.log({ parsedMicrophoneConfiguration });\n    this.#availableMicrophoneConfigurationTypes = Object.keys(\n      parsedMicrophoneConfiguration\n    ) as MicrophoneConfigurationType[];\n    this.#microphoneConfiguration = parsedMicrophoneConfiguration;\n    this.#dispatchEvent(\"getMicrophoneConfiguration\", {\n      microphoneConfiguration: this.#microphoneConfiguration,\n    });\n  }\n\n  #isMicrophoneConfigurationRedundant(\n    microphoneConfiguration: MicrophoneConfiguration\n  ) {\n    let microphoneConfigurationTypes = Object.keys(\n      microphoneConfiguration\n    ) as MicrophoneConfigurationType[];\n    return microphoneConfigurationTypes.every((microphoneConfigurationType) => {\n      return (\n        this.microphoneConfiguration[microphoneConfigurationType] ==\n        microphoneConfiguration[microphoneConfigurationType]\n      );\n    });\n  }\n  async setMicrophoneConfiguration(\n    newMicrophoneConfiguration: MicrophoneConfiguration\n  ) {\n    _console.log({ newMicrophoneConfiguration });\n    if (this.#isMicrophoneConfigurationRedundant(newMicrophoneConfiguration)) {\n      _console.log(\"redundant microphone configuration\");\n      return;\n    }\n    const setMicrophoneConfigurationData = this.#createData(\n      newMicrophoneConfiguration\n    );\n    _console.log({ setMicrophoneConfigurationData });\n\n    const promise = this.waitForEvent(\"getMicrophoneConfiguration\");\n    this.sendMessage([\n      {\n        type: \"setMicrophoneConfiguration\",\n        data: setMicrophoneConfigurationData.buffer,\n      },\n    ]);\n    await promise;\n  }\n\n  #assertAvailableMicrophoneConfigurationType(\n    microphoneConfigurationType: MicrophoneConfigurationType\n  ) {\n    _console.assertWithError(\n      this.#availableMicrophoneConfigurationTypes,\n      \"must get initial microphoneConfiguration\"\n    );\n    const isMicrophoneConfigurationTypeAvailable =\n      this.#availableMicrophoneConfigurationTypes?.includes(\n        microphoneConfigurationType\n      );\n    _console.assertWithError(\n      isMicrophoneConfigurationTypeAvailable,\n      `unavailable microphone configuration type \"${microphoneConfigurationType}\"`\n    );\n    return isMicrophoneConfigurationTypeAvailable;\n  }\n\n  static AssertValidMicrophoneConfigurationType(\n    microphoneConfigurationType: MicrophoneConfigurationType\n  ) {\n    _console.assertEnumWithError(\n      microphoneConfigurationType,\n      MicrophoneConfigurationTypes\n    );\n  }\n  static AssertValidMicrophoneConfigurationTypeEnum(\n    microphoneConfigurationTypeEnum: number\n  ) {\n    _console.assertTypeWithError(microphoneConfigurationTypeEnum, \"number\");\n    _console.assertWithError(\n      microphoneConfigurationTypeEnum in MicrophoneConfigurationTypes,\n      `invalid microphoneConfigurationTypeEnum ${microphoneConfigurationTypeEnum}`\n    );\n  }\n\n  #createData(microphoneConfiguration: MicrophoneConfiguration) {\n    let microphoneConfigurationTypes = Object.keys(\n      microphoneConfiguration\n    ) as MicrophoneConfigurationType[];\n    microphoneConfigurationTypes = microphoneConfigurationTypes.filter(\n      (microphoneConfigurationType) =>\n        this.#assertAvailableMicrophoneConfigurationType(\n          microphoneConfigurationType\n        )\n    );\n\n    const dataView = new DataView(\n      new ArrayBuffer(microphoneConfigurationTypes.length * 2)\n    );\n    microphoneConfigurationTypes.forEach(\n      (microphoneConfigurationType, index) => {\n        MicrophoneManager.AssertValidMicrophoneConfigurationType(\n          microphoneConfigurationType\n        );\n        const microphoneConfigurationTypeEnum =\n          MicrophoneConfigurationTypes.indexOf(microphoneConfigurationType);\n        dataView.setUint8(index * 2, microphoneConfigurationTypeEnum);\n\n        let value = microphoneConfiguration[microphoneConfigurationType]!;\n        if (typeof value == \"number\") {\n          // @ts-ignore\n          value = value.toString();\n        }\n        const values =\n          MicrophoneConfigurationValues[microphoneConfigurationType];\n        _console.assertEnumWithError(value, values);\n        // @ts-expect-error\n        const rawValue = values.indexOf(value);\n        dataView.setUint8(index * 2 + 1, rawValue);\n      }\n    );\n    _console.log({ sensorConfigurationData: dataView });\n    return dataView;\n  }\n\n  // MESSAGE\n  parseMessage(messageType: MicrophoneMessageType, dataView: DataView) {\n    _console.log({ messageType, dataView });\n\n    switch (messageType) {\n      case \"microphoneStatus\":\n        this.#parseMicrophoneStatus(dataView);\n        break;\n      case \"getMicrophoneConfiguration\":\n      case \"setMicrophoneConfiguration\":\n        this.#parseMicrophoneConfiguration(dataView);\n        break;\n      case \"microphoneData\":\n        this.#parseMicrophoneData(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  #audioContext?: AudioContext;\n  get audioContext() {\n    return this.#audioContext;\n  }\n  set audioContext(newAudioContext) {\n    if (this.#audioContext == newAudioContext) {\n      _console.log(\"redundant audioContext assignment\", this.#audioContext);\n      return;\n    }\n\n    this.#audioContext = newAudioContext;\n\n    _console.log(\"assigned new audioContext\", this.#audioContext);\n    if (this.#audioContext) {\n      this.#playbackTime = this.#audioContext.currentTime;\n    } else {\n      if (this.#mediaStreamDestination) {\n        this.#mediaStreamDestination.disconnect();\n        this.#mediaStreamDestination = undefined;\n      }\n      if (this.#gainNode) {\n        this.#gainNode.disconnect();\n        this.#gainNode = undefined;\n      }\n    }\n  }\n\n  #gainNode?: GainNode;\n  get gainNode() {\n    _console.assertWithError(\n      this.#audioContext,\n      \"audioContext assignment required for gainNode\"\n    );\n    if (!this.#gainNode) {\n      _console.log(\"creating gainNode...\");\n      this.#gainNode = this.#audioContext!.createGain();\n      _console.log(\"created gainNode\", this.#gainNode);\n    }\n    return this.#gainNode;\n  }\n\n  #mediaStreamDestination?: MediaStreamAudioDestinationNode;\n  get mediaStreamDestination() {\n    _console.assertWithError(\n      this.#audioContext,\n      \"audioContext assignment required for mediaStreamDestination\"\n    );\n    if (!this.#mediaStreamDestination) {\n      _console.log(\"creating mediaStreamDestination...\");\n      this.#mediaStreamDestination =\n        this.#audioContext!.createMediaStreamDestination();\n      this.gainNode?.connect(this.#mediaStreamDestination);\n      _console.log(\n        \"created mediaStreamDestination\",\n        this.#mediaStreamDestination\n      );\n    }\n    return this.#mediaStreamDestination;\n  }\n\n  #isRecording = false;\n  get isRecording() {\n    return this.#isRecording;\n  }\n  #microphoneRecordingData?: Float32Array[];\n  startRecording() {\n    if (this.isRecording) {\n      _console.log(\"already recording\");\n      return;\n    }\n    this.#microphoneRecordingData = [];\n    this.#isRecording = true;\n    this.#dispatchEvent(\"isRecordingMicrophone\", {\n      isRecordingMicrophone: this.isRecording,\n    });\n  }\n  stopRecording() {\n    if (!this.isRecording) {\n      _console.log(\"already not recording\");\n      return;\n    }\n    this.#isRecording = false;\n    if (\n      this.#microphoneRecordingData &&\n      this.#microphoneRecordingData.length > 0\n    ) {\n      _console.log(\n        \"parsing microphone data...\",\n        this.#microphoneRecordingData.length\n      );\n      const arrayBuffer = concatenateArrayBuffers(\n        ...this.#microphoneRecordingData\n      );\n      const samples = new Float32Array(arrayBuffer);\n\n      const blob = float32ArrayToWav(samples, Number(this.sampleRate)!, 1);\n      const url = URL.createObjectURL(blob);\n      this.#dispatchEvent(\"microphoneRecording\", {\n        samples,\n        sampleRate: this.sampleRate!,\n        bitDepth: this.bitDepth!,\n        blob,\n        url,\n      });\n    }\n    this.#microphoneRecordingData = undefined;\n    this.#dispatchEvent(\"isRecordingMicrophone\", {\n      isRecordingMicrophone: this.isRecording,\n    });\n  }\n  toggleRecording() {\n    if (this.#isRecording) {\n      this.stopRecording();\n    } else {\n      this.startRecording();\n    }\n  }\n\n  clear() {\n    // @ts-ignore\n    this.#microphoneStatus = undefined;\n    this.#microphoneConfiguration = {};\n    if (this.isRecording) {\n      this.stopRecording();\n    }\n  }\n}\n\nexport default MicrophoneManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport { parseTimestamp } from \"../utils/MathUtils.ts\";\nimport PressureSensorDataManager, {\n  PressureDataEventMessages,\n} from \"./PressureSensorDataManager.ts\";\nimport MotionSensorDataManager, {\n  MotionSensorDataEventMessages,\n} from \"./MotionSensorDataManager.ts\";\nimport BarometerSensorDataManager, {\n  BarometerSensorDataEventMessages,\n} from \"./BarometerSensorDataManager.ts\";\nimport { parseMessage } from \"../utils/ParseUtils.ts\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\nimport {\n  MotionSensorTypes,\n  ContinuousMotionTypes,\n} from \"./MotionSensorDataManager.ts\";\nimport {\n  PressureSensorTypes,\n  ContinuousPressureSensorTypes,\n} from \"./PressureSensorDataManager.ts\";\nimport {\n  BarometerSensorTypes,\n  ContinuousBarometerSensorTypes,\n} from \"./BarometerSensorDataManager.ts\";\nimport Device from \"../Device.ts\";\nimport {\n  AddKeysAsPropertyToInterface,\n  ExtendInterfaceValues,\n  ValueOf,\n} from \"../utils/TypeScriptUtils.ts\";\nimport { CameraSensorTypes } from \"../CameraManager.ts\";\nimport { MicrophoneSensorTypes } from \"../MicrophoneManager.ts\";\n\nconst _console = createConsole(\"SensorDataManager\", { log: false });\n\nexport const SensorTypes = [\n  ...PressureSensorTypes,\n  ...MotionSensorTypes,\n  ...BarometerSensorTypes,\n  ...CameraSensorTypes,\n  ...MicrophoneSensorTypes,\n] as const;\nexport type SensorType = (typeof SensorTypes)[number];\n\nexport const ContinuousSensorTypes = [\n  ...ContinuousPressureSensorTypes,\n  ...ContinuousMotionTypes,\n  ...ContinuousBarometerSensorTypes,\n] as const;\nexport type ContinuousSensorType = (typeof ContinuousSensorTypes)[number];\n\nexport const SensorDataMessageTypes = [\n  \"getPressurePositions\",\n  \"getSensorScalars\",\n  \"sensorData\",\n] as const;\nexport type SensorDataMessageType = (typeof SensorDataMessageTypes)[number];\n\nexport const RequiredPressureMessageTypes: SensorDataMessageType[] = [\n  \"getPressurePositions\",\n] as const;\n\nexport const SensorDataEventTypes = [\n  ...SensorDataMessageTypes,\n  ...SensorTypes,\n] as const;\nexport type SensorDataEventType = (typeof SensorDataEventTypes)[number];\n\ninterface BaseSensorDataEventMessage {\n  timestamp: number;\n}\n\ntype BaseSensorDataEventMessages = BarometerSensorDataEventMessages &\n  MotionSensorDataEventMessages &\n  PressureDataEventMessages;\ntype _SensorDataEventMessages = ExtendInterfaceValues<\n  AddKeysAsPropertyToInterface<BaseSensorDataEventMessages, \"sensorType\">,\n  BaseSensorDataEventMessage\n>;\nexport type SensorDataEventMessage = ValueOf<_SensorDataEventMessages>;\ninterface AnySensorDataEventMessages {\n  sensorData: SensorDataEventMessage;\n}\nexport type SensorDataEventMessages = _SensorDataEventMessages &\n  AnySensorDataEventMessages;\n\nexport type SensorDataEventDispatcher = EventDispatcher<\n  Device,\n  SensorDataEventType,\n  SensorDataEventMessages\n>;\n\nclass SensorDataManager {\n  pressureSensorDataManager = new PressureSensorDataManager();\n  motionSensorDataManager = new MotionSensorDataManager();\n  barometerSensorDataManager = new BarometerSensorDataManager();\n\n  #scalars: Map<SensorType, number> = new Map();\n\n  static AssertValidSensorType(sensorType: SensorType) {\n    _console.assertEnumWithError(sensorType, SensorTypes);\n  }\n  static AssertValidSensorTypeEnum(sensorTypeEnum: number) {\n    _console.assertTypeWithError(sensorTypeEnum, \"number\");\n    _console.assertWithError(\n      sensorTypeEnum in SensorTypes,\n      `invalid sensorTypeEnum ${sensorTypeEnum}`\n    );\n  }\n\n  eventDispatcher!: SensorDataEventDispatcher;\n  get dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  parseMessage(messageType: SensorDataMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getSensorScalars\":\n        this.parseScalars(dataView);\n        break;\n      case \"getPressurePositions\":\n        this.pressureSensorDataManager.parsePositions(dataView);\n        break;\n      case \"sensorData\":\n        this.parseData(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  parseScalars(dataView: DataView) {\n    for (\n      let byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      byteOffset += 5\n    ) {\n      const sensorTypeIndex = dataView.getUint8(byteOffset);\n      const sensorType = SensorTypes[sensorTypeIndex];\n      if (!sensorType) {\n        _console.warn(`unknown sensorType index ${sensorTypeIndex}`);\n        continue;\n      }\n      const sensorScalar = dataView.getFloat32(byteOffset + 1, true);\n      _console.log({ sensorType, sensorScalar });\n      this.#scalars.set(sensorType, sensorScalar);\n    }\n  }\n\n  private parseData(dataView: DataView) {\n    _console.log(\"sensorData\", Array.from(new Uint8Array(dataView.buffer)));\n\n    let byteOffset = 0;\n    const timestamp = parseTimestamp(dataView, byteOffset);\n    byteOffset += 2;\n\n    const _dataView = new DataView(dataView.buffer, byteOffset);\n\n    parseMessage(_dataView, SensorTypes, this.parseDataCallback.bind(this), {\n      timestamp,\n    });\n  }\n\n  private parseDataCallback(\n    sensorType: SensorType,\n    dataView: DataView,\n    { timestamp }: { timestamp: number }\n  ) {\n    const scalar = this.#scalars.get(sensorType) || 1;\n\n    let sensorData = null;\n    switch (sensorType) {\n      case \"pressure\":\n        sensorData = this.pressureSensorDataManager.parseData(dataView, scalar);\n        break;\n      case \"acceleration\":\n      case \"gravity\":\n      case \"linearAcceleration\":\n      case \"gyroscope\":\n      case \"magnetometer\":\n        sensorData = this.motionSensorDataManager.parseVector3(\n          dataView,\n          scalar\n        );\n        break;\n      case \"gameRotation\":\n      case \"rotation\":\n        sensorData = this.motionSensorDataManager.parseQuaternion(\n          dataView,\n          scalar\n        );\n        break;\n      case \"orientation\":\n        sensorData = this.motionSensorDataManager.parseEuler(dataView, scalar);\n        break;\n      case \"stepCounter\":\n        sensorData = this.motionSensorDataManager.parseStepCounter(dataView);\n        break;\n      case \"stepDetector\":\n        sensorData = {};\n        break;\n      case \"activity\":\n        sensorData = this.motionSensorDataManager.parseActivity(dataView);\n        break;\n      case \"deviceOrientation\":\n        sensorData =\n          this.motionSensorDataManager.parseDeviceOrientation(dataView);\n        break;\n      case \"tapDetector\":\n        sensorData = {};\n        break;\n      case \"barometer\":\n        sensorData = this.barometerSensorDataManager.parseData(\n          dataView,\n          scalar\n        );\n        break;\n      case \"camera\":\n        // we parse camera data using CameraManager\n        return;\n      case \"microphone\":\n        // we parse microphone data using MicrophoneManager\n        return;\n      default:\n        _console.error(`uncaught sensorType \"${sensorType}\"`);\n    }\n\n    _console.assertWithError(\n      sensorData != null,\n      `no sensorData defined for sensorType \"${sensorType}\"`\n    );\n\n    _console.log({ sensorType, sensorData });\n    // @ts-expect-error\n    this.dispatchEvent(sensorType, {\n      sensorType,\n      [sensorType]: sensorData,\n      timestamp,\n    });\n    // @ts-expect-error\n    this.dispatchEvent(\"sensorData\", {\n      sensorType,\n      [sensorType]: sensorData,\n      timestamp,\n    });\n  }\n}\n\nexport default SensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport SensorDataManager, {\n  SensorTypes,\n  SensorType,\n} from \"./SensorDataManager.ts\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\nimport Device, { SendMessageCallback } from \"../Device.ts\";\nimport autoBind from \"../../node_modules/auto-bind/index.js\";\n\nconst _console = createConsole(\"SensorConfigurationManager\", { log: false });\n\nexport type SensorConfiguration = { [sensorType in SensorType]?: number };\n\nexport const MaxSensorRate = 2 ** 16 - 1;\nexport const SensorRateStep = 5;\n\nexport const SensorConfigurationMessageTypes = [\n  \"getSensorConfiguration\",\n  \"setSensorConfiguration\",\n] as const;\nexport type SensorConfigurationMessageType =\n  (typeof SensorConfigurationMessageTypes)[number];\n\nexport const SensorConfigurationEventTypes = SensorConfigurationMessageTypes;\nexport type SensorConfigurationEventType =\n  (typeof SensorConfigurationEventTypes)[number];\n\nexport interface SensorConfigurationEventMessages {\n  getSensorConfiguration: { sensorConfiguration: SensorConfiguration };\n}\n\nexport type SensorConfigurationEventDispatcher = EventDispatcher<\n  Device,\n  SensorConfigurationEventType,\n  SensorConfigurationEventMessages\n>;\n\nexport type SendSensorConfigurationMessageCallback =\n  SendMessageCallback<SensorConfigurationMessageType>;\n\nclass SensorConfigurationManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendSensorConfigurationMessageCallback;\n\n  eventDispatcher!: SensorConfigurationEventDispatcher;\n  get addEventListener() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  #availableSensorTypes!: SensorType[];\n  #assertAvailableSensorType(sensorType: SensorType) {\n    _console.assertWithError(\n      this.#availableSensorTypes,\n      \"must get initial sensorConfiguration\"\n    );\n    const isSensorTypeAvailable =\n      this.#availableSensorTypes?.includes(sensorType);\n    _console.log(\n      isSensorTypeAvailable,\n      `unavailable sensor type \"${sensorType}\"`\n    );\n    return isSensorTypeAvailable;\n  }\n\n  #configuration: SensorConfiguration = {};\n  get configuration() {\n    return this.#configuration;\n  }\n\n  #updateConfiguration(updatedConfiguration: SensorConfiguration) {\n    this.#configuration = updatedConfiguration;\n    _console.log({ updatedConfiguration: this.#configuration });\n    this.#dispatchEvent(\"getSensorConfiguration\", {\n      sensorConfiguration: this.configuration,\n    });\n  }\n\n  #isRedundant(sensorConfiguration: SensorConfiguration) {\n    let sensorTypes = Object.keys(sensorConfiguration) as SensorType[];\n    return sensorTypes.every((sensorType) => {\n      return this.configuration[sensorType] == sensorConfiguration[sensorType];\n    });\n  }\n\n  async setConfiguration(\n    newSensorConfiguration: SensorConfiguration,\n    clearRest?: boolean,\n    sendImmediately?: boolean\n  ) {\n    if (clearRest) {\n      newSensorConfiguration = Object.assign(\n        structuredClone(this.zeroSensorConfiguration),\n        newSensorConfiguration\n      );\n    }\n    _console.log({ newSensorConfiguration });\n    if (this.#isRedundant(newSensorConfiguration)) {\n      _console.log(\"redundant sensor configuration\");\n      return;\n    }\n    const setSensorConfigurationData = this.#createData(newSensorConfiguration);\n    _console.log({ setSensorConfigurationData });\n\n    const promise = this.waitForEvent(\"getSensorConfiguration\");\n    this.sendMessage(\n      [\n        {\n          type: \"setSensorConfiguration\",\n          data: setSensorConfigurationData.buffer,\n        },\n      ],\n      sendImmediately\n    );\n    await promise;\n  }\n\n  #parse(dataView: DataView) {\n    const parsedSensorConfiguration: SensorConfiguration = {};\n    for (\n      let byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      byteOffset += 3\n    ) {\n      const sensorTypeIndex = dataView.getUint8(byteOffset);\n      const sensorType = SensorTypes[sensorTypeIndex];\n\n      const sensorRate = dataView.getUint16(byteOffset + 1, true);\n      _console.log({ sensorType, sensorRate });\n\n      if (!sensorType) {\n        _console.warn(`unknown sensorType index ${sensorTypeIndex}`);\n        continue;\n      }\n      parsedSensorConfiguration[sensorType] = sensorRate;\n    }\n    _console.log({ parsedSensorConfiguration });\n    this.#availableSensorTypes = Object.keys(\n      parsedSensorConfiguration\n    ) as SensorType[];\n    return parsedSensorConfiguration;\n  }\n\n  static #AssertValidSensorRate(sensorRate: number) {\n    _console.assertTypeWithError(sensorRate, \"number\");\n    _console.assertWithError(\n      sensorRate >= 0,\n      `sensorRate must be 0 or greater (got ${sensorRate})`\n    );\n    _console.assertWithError(\n      sensorRate < MaxSensorRate,\n      `sensorRate must be 0 or greater (got ${sensorRate})`\n    );\n    _console.assertWithError(\n      sensorRate % SensorRateStep == 0,\n      `sensorRate must be multiple of ${SensorRateStep}`\n    );\n  }\n\n  #assertValidSensorRate(sensorRate: number) {\n    SensorConfigurationManager.#AssertValidSensorRate(sensorRate);\n  }\n\n  #createData(sensorConfiguration: SensorConfiguration) {\n    let sensorTypes = Object.keys(sensorConfiguration) as SensorType[];\n    sensorTypes = sensorTypes.filter((sensorType) =>\n      this.#assertAvailableSensorType(sensorType)\n    );\n\n    const dataView = new DataView(new ArrayBuffer(sensorTypes.length * 3));\n    sensorTypes.forEach((sensorType, index) => {\n      SensorDataManager.AssertValidSensorType(sensorType);\n      const sensorTypeEnum = SensorTypes.indexOf(sensorType);\n      dataView.setUint8(index * 3, sensorTypeEnum);\n\n      const sensorRate = sensorConfiguration[sensorType]!;\n      this.#assertValidSensorRate(sensorRate);\n      dataView.setUint16(index * 3 + 1, sensorRate, true);\n    });\n    _console.log({ sensorConfigurationData: dataView });\n    return dataView;\n  }\n\n  // ZERO\n  static #ZeroSensorConfiguration: SensorConfiguration = {};\n  static get ZeroSensorConfiguration() {\n    return this.#ZeroSensorConfiguration;\n  }\n  static {\n    SensorTypes.forEach((sensorType) => {\n      this.#ZeroSensorConfiguration[sensorType] = 0;\n    });\n  }\n  get zeroSensorConfiguration() {\n    const zeroSensorConfiguration: SensorConfiguration = {};\n    this.#availableSensorTypes.forEach((sensorType) => {\n      zeroSensorConfiguration[sensorType] = 0;\n    });\n    return zeroSensorConfiguration;\n  }\n  async clearSensorConfiguration() {\n    return this.setConfiguration(this.zeroSensorConfiguration);\n  }\n\n  // MESSAGE\n  parseMessage(\n    messageType: SensorConfigurationMessageType,\n    dataView: DataView\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getSensorConfiguration\":\n      case \"setSensorConfiguration\":\n        const newSensorConfiguration = this.#parse(dataView);\n        this.#updateConfiguration(newSensorConfiguration);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default SensorConfigurationManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport SensorDataManager, { SensorTypes } from \"./sensor/SensorDataManager.ts\";\nimport { arrayWithoutDuplicates } from \"./utils/ArrayUtils.ts\";\nimport { SensorRateStep } from \"./sensor/SensorConfigurationManager.ts\";\nimport { parseTimestamp } from \"./utils/MathUtils.ts\";\nimport { SensorType } from \"./sensor/SensorDataManager.ts\";\nimport Device, { SendMessageCallback } from \"./Device.ts\";\nimport autoBind from \"auto-bind\";\nimport { FileConfiguration as BaseFileConfiguration } from \"./FileTransferManager.ts\";\nimport { UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\n\nconst _console = createConsole(\"TfliteManager\", { log: false });\n\nexport const TfliteMessageTypes = [\n  \"getTfliteName\",\n  \"setTfliteName\",\n  \"getTfliteTask\",\n  \"setTfliteTask\",\n  \"getTfliteSampleRate\",\n  \"setTfliteSampleRate\",\n  \"getTfliteSensorTypes\",\n  \"setTfliteSensorTypes\",\n  \"tfliteIsReady\",\n  \"getTfliteCaptureDelay\",\n  \"setTfliteCaptureDelay\",\n  \"getTfliteThreshold\",\n  \"setTfliteThreshold\",\n  \"getTfliteInferencingEnabled\",\n  \"setTfliteInferencingEnabled\",\n  \"tfliteInference\",\n] as const;\nexport type TfliteMessageType = (typeof TfliteMessageTypes)[number];\n\nexport const TfliteEventTypes = TfliteMessageTypes;\nexport type TfliteEventType = (typeof TfliteEventTypes)[number];\n\nexport const RequiredTfliteMessageTypes: TfliteMessageType[] = [\n  \"getTfliteName\",\n  \"getTfliteTask\",\n  \"getTfliteSampleRate\",\n  \"getTfliteSensorTypes\",\n  \"tfliteIsReady\",\n  \"getTfliteCaptureDelay\",\n  \"getTfliteThreshold\",\n  \"getTfliteInferencingEnabled\",\n];\n\nexport const TfliteTasks = [\"classification\", \"regression\"] as const;\nexport type TfliteTask = (typeof TfliteTasks)[number];\n\nexport interface TfliteEventMessages {\n  getTfliteName: { tfliteName: string };\n  getTfliteTask: { tfliteTask: TfliteTask };\n  getTfliteSampleRate: { tfliteSampleRate: number };\n  getTfliteSensorTypes: { tfliteSensorTypes: SensorType[] };\n  tfliteIsReady: { tfliteIsReady: boolean };\n  getTfliteCaptureDelay: { tfliteCaptureDelay: number };\n  getTfliteThreshold: { tfliteThreshold: number };\n  getTfliteInferencingEnabled: { tfliteInferencingEnabled: boolean };\n  tfliteInference: { tfliteInference: TfliteInference };\n}\n\nexport interface TfliteInference {\n  timestamp: number;\n  values: number[];\n  maxValue?: number;\n  maxIndex?: number;\n  maxClass?: string;\n  classValues?: { [key: string]: number };\n}\n\nexport type TfliteEventDispatcher = EventDispatcher<\n  Device,\n  TfliteEventType,\n  TfliteEventMessages\n>;\nexport type SendTfliteMessageCallback = SendMessageCallback<TfliteMessageType>;\n\nexport const TfliteSensorTypes = [\n  \"pressure\",\n  \"linearAcceleration\",\n  \"gyroscope\",\n  \"magnetometer\",\n] as const satisfies readonly SensorType[];\nexport type TfliteSensorType = (typeof TfliteSensorTypes)[number];\n\nexport interface TfliteFileConfiguration extends BaseFileConfiguration {\n  type: \"tflite\";\n  name: string;\n  sensorTypes: TfliteSensorType[];\n  task: TfliteTask;\n  sampleRate: number;\n  captureDelay?: number;\n  threshold?: number;\n  classes?: string[];\n}\n\nclass TfliteManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendTfliteMessageCallback;\n\n  #assertValidTask(task: TfliteTask) {\n    _console.assertEnumWithError(task, TfliteTasks);\n  }\n  #assertValidTaskEnum(taskEnum: number) {\n    _console.assertWithError(\n      taskEnum in TfliteTasks,\n      `invalid taskEnum ${taskEnum}`\n    );\n  }\n\n  eventDispatcher!: TfliteEventDispatcher;\n  get addEventListenter() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  // PROPERTIES\n\n  #name!: string;\n  get name() {\n    return this.#name;\n  }\n  #parseName(dataView: DataView) {\n    _console.log(\"parseName\", dataView);\n    const name = textDecoder.decode(dataView.buffer);\n    this.#updateName(name);\n  }\n  #updateName(name: string) {\n    _console.log({ name });\n    this.#name = name;\n    this.#dispatchEvent(\"getTfliteName\", { tfliteName: name });\n  }\n  async setName(newName: string, sendImmediately?: boolean) {\n    _console.assertTypeWithError(newName, \"string\");\n    if (this.name == newName) {\n      _console.log(`redundant name assignment ${newName}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteName\");\n\n    const setNameData = textEncoder.encode(newName);\n    this.sendMessage(\n      [{ type: \"setTfliteName\", data: setNameData.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #task!: TfliteTask;\n  get task() {\n    return this.#task;\n  }\n  #parseTask(dataView: DataView) {\n    _console.log(\"parseTask\", dataView);\n    const taskEnum = dataView.getUint8(0);\n    this.#assertValidTaskEnum(taskEnum);\n    const task = TfliteTasks[taskEnum];\n    this.#updateTask(task);\n  }\n  #updateTask(task: TfliteTask) {\n    _console.log({ task });\n    this.#task = task;\n    this.#dispatchEvent(\"getTfliteTask\", { tfliteTask: task });\n  }\n  async setTask(newTask: TfliteTask, sendImmediately?: boolean) {\n    this.#assertValidTask(newTask);\n    if (this.task == newTask) {\n      _console.log(`redundant task assignment ${newTask}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteTask\");\n\n    const taskEnum = TfliteTasks.indexOf(newTask);\n    ≈\n    this.sendMessage(\n      [{ type: \"setTfliteTask\", data: UInt8ByteBuffer(commandEnum) }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #sampleRate!: number;\n  get sampleRate() {\n    return this.#sampleRate;\n  }\n  #parseSampleRate(dataView: DataView) {\n    _console.log(\"parseSampleRate\", dataView);\n    const sampleRate = dataView.getUint16(0, true);\n    this.#updateSampleRate(sampleRate);\n  }\n  #updateSampleRate(sampleRate: number) {\n    _console.log({ sampleRate });\n    this.#sampleRate = sampleRate;\n    this.#dispatchEvent(\"getTfliteSampleRate\", {\n      tfliteSampleRate: sampleRate,\n    });\n  }\n  async setSampleRate(newSampleRate: number, sendImmediately?: boolean) {\n    _console.assertTypeWithError(newSampleRate, \"number\");\n    newSampleRate -= newSampleRate % SensorRateStep;\n    _console.assertWithError(\n      newSampleRate >= SensorRateStep,\n      `sampleRate must be multiple of ${SensorRateStep} greater than 0 (got ${newSampleRate})`\n    );\n    if (this.#sampleRate == newSampleRate) {\n      _console.log(`redundant sampleRate assignment ${newSampleRate}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteSampleRate\");\n\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, newSampleRate, true);\n    this.sendMessage(\n      [{ type: \"setTfliteSampleRate\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  static AssertValidSensorType(sensorType: SensorType) {\n    SensorDataManager.AssertValidSensorType(sensorType);\n    const tfliteSensorType = sensorType as TfliteSensorType;\n    _console.assertWithError(\n      TfliteSensorTypes.includes(tfliteSensorType),\n      `invalid tflite sensorType \"${sensorType}\"`\n    );\n  }\n\n  #sensorTypes: TfliteSensorType[] = [];\n  get sensorTypes() {\n    return this.#sensorTypes.slice();\n  }\n  #parseSensorTypes(dataView: DataView) {\n    _console.log(\"parseSensorTypes\", dataView);\n    const sensorTypes: TfliteSensorType[] = [];\n    for (let index = 0; index < dataView.byteLength; index++) {\n      const sensorTypeEnum = dataView.getUint8(index);\n      const sensorType = SensorTypes[sensorTypeEnum] as TfliteSensorType;\n      if (sensorType) {\n        if (TfliteSensorTypes.includes(sensorType)) {\n          sensorTypes.push(sensorType);\n        } else {\n          _console.error(`invalid tfliteSensorType ${sensorType}`);\n        }\n      } else {\n        _console.error(`invalid sensorTypeEnum ${sensorTypeEnum}`);\n      }\n    }\n    this.#updateSensorTypes(sensorTypes);\n  }\n  #updateSensorTypes(sensorTypes: TfliteSensorType[]) {\n    _console.log({ sensorTypes });\n    this.#sensorTypes = sensorTypes;\n    this.#dispatchEvent(\"getTfliteSensorTypes\", {\n      tfliteSensorTypes: sensorTypes,\n    });\n  }\n  async setSensorTypes(\n    newSensorTypes: SensorType[],\n    sendImmediately?: boolean\n  ) {\n    newSensorTypes.forEach((sensorType) => {\n      TfliteManager.AssertValidSensorType(sensorType);\n    });\n\n    const promise = this.waitForEvent(\"getTfliteSensorTypes\");\n\n    newSensorTypes = arrayWithoutDuplicates(newSensorTypes);\n    const newSensorTypeEnums = newSensorTypes\n      .map((sensorType) => SensorTypes.indexOf(sensorType))\n      .sort();\n    _console.log(newSensorTypes, newSensorTypeEnums);\n    this.sendMessage(\n      [\n        {\n          type: \"setTfliteSensorTypes\",\n          data: Uint8Array.from(newSensorTypeEnums).buffer,\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #isReady!: boolean;\n  get isReady() {\n    return this.#isReady;\n  }\n  #parseIsReady(dataView: DataView) {\n    _console.log(\"parseIsReady\", dataView);\n    const isReady = Boolean(dataView.getUint8(0));\n    this.#updateIsReady(isReady);\n  }\n  #updateIsReady(isReady: boolean) {\n    _console.log({ isReady });\n    this.#isReady = isReady;\n    this.#dispatchEvent(\"tfliteIsReady\", { tfliteIsReady: isReady });\n  }\n  #assertIsReady() {\n    _console.assertWithError(this.isReady, `tflite is not ready`);\n  }\n\n  #captureDelay!: number;\n  get captureDelay() {\n    return this.#captureDelay;\n  }\n  #parseCaptureDelay(dataView: DataView) {\n    _console.log(\"parseCaptureDelay\", dataView);\n    const captureDelay = dataView.getUint16(0, true);\n    this.#updateCaptueDelay(captureDelay);\n  }\n  #updateCaptueDelay(captureDelay: number) {\n    _console.log({ captureDelay });\n    this.#captureDelay = captureDelay;\n    this.#dispatchEvent(\"getTfliteCaptureDelay\", {\n      tfliteCaptureDelay: captureDelay,\n    });\n  }\n  async setCaptureDelay(newCaptureDelay: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newCaptureDelay, \"number\");\n    if (this.#captureDelay == newCaptureDelay) {\n      _console.log(`redundant captureDelay assignment ${newCaptureDelay}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteCaptureDelay\");\n\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, newCaptureDelay, true);\n    this.sendMessage(\n      [{ type: \"setTfliteCaptureDelay\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #threshold!: number;\n  get threshold() {\n    return this.#threshold;\n  }\n  #parseThreshold(dataView: DataView) {\n    _console.log(\"parseThreshold\", dataView);\n    const threshold = dataView.getFloat32(0, true);\n    this.#updateThreshold(threshold);\n  }\n  #updateThreshold(threshold: number) {\n    _console.log({ threshold });\n    this.#threshold = threshold;\n    this.#dispatchEvent(\"getTfliteThreshold\", { tfliteThreshold: threshold });\n  }\n  async setThreshold(newThreshold: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newThreshold, \"number\");\n    _console.assertWithError(\n      newThreshold >= 0,\n      `threshold must be positive (got ${newThreshold})`\n    );\n    if (this.#threshold == newThreshold) {\n      _console.log(`redundant threshold assignment ${newThreshold}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteThreshold\");\n\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setFloat32(0, newThreshold, true);\n    this.sendMessage(\n      [{ type: \"setTfliteThreshold\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #inferencingEnabled!: boolean;\n  get inferencingEnabled() {\n    return this.#inferencingEnabled;\n  }\n  #parseInferencingEnabled(dataView: DataView) {\n    _console.log(\"parseInferencingEnabled\", dataView);\n    const inferencingEnabled = Boolean(dataView.getUint8(0));\n    this.#updateInferencingEnabled(inferencingEnabled);\n  }\n  #updateInferencingEnabled(inferencingEnabled: boolean) {\n    _console.log({ inferencingEnabled });\n    this.#inferencingEnabled = inferencingEnabled;\n    this.#dispatchEvent(\"getTfliteInferencingEnabled\", {\n      tfliteInferencingEnabled: inferencingEnabled,\n    });\n  }\n  async setInferencingEnabled(\n    newInferencingEnabled: boolean,\n    sendImmediately: boolean = true\n  ) {\n    _console.assertTypeWithError(newInferencingEnabled, \"boolean\");\n    if (!newInferencingEnabled && !this.isReady) {\n      return;\n    }\n    this.#assertIsReady();\n    if (this.#inferencingEnabled == newInferencingEnabled) {\n      _console.log(\n        `redundant inferencingEnabled assignment ${newInferencingEnabled}`\n      );\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteInferencingEnabled\");\n\n    this.sendMessage(\n      [\n        {\n          type: \"setTfliteInferencingEnabled\",\n          \n          data: UInt8ByteBuffer(Number(newInferencingEnabled)),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  async toggleInferencingEnabled() {\n    return this.setInferencingEnabled(!this.inferencingEnabled);\n  }\n\n  async enableInferencing() {\n    if (this.inferencingEnabled) {\n      return;\n    }\n    this.setInferencingEnabled(true);\n  }\n  async disableInferencing() {\n    if (!this.inferencingEnabled) {\n      return;\n    }\n    this.setInferencingEnabled(false);\n  }\n\n  #parseInference(dataView: DataView) {\n    _console.log(\"parseInference\", dataView);\n\n    const timestamp = parseTimestamp(dataView, 0);\n    _console.log({ timestamp });\n\n    const values: number[] = [];\n    for (\n      let index = 0, byteOffset = 2;\n      byteOffset < dataView.byteLength;\n      index++, byteOffset += 4\n    ) {\n      const value = dataView.getFloat32(byteOffset, true);\n      values.push(value);\n    }\n    _console.log(\"values\", values);\n\n    const inference: TfliteInference = {\n      timestamp,\n      values,\n    };\n\n    if (this.task == \"classification\") {\n      let maxValue = 0;\n      let maxIndex = 0;\n      values.forEach((value, index) => {\n        if (value > maxValue) {\n          maxValue = value;\n          maxIndex = index;\n        }\n      });\n      _console.log({ maxIndex, maxValue });\n      inference.maxIndex = maxIndex;\n      inference.maxValue = maxValue;\n      if (this.#configuration?.classes) {\n        const { classes } = this.#configuration;\n        inference.maxClass = classes[maxIndex];\n        inference.classValues = {};\n        values.forEach((value, index) => {\n          const key = classes[index];\n          inference.classValues![key] = value;\n        });\n      }\n    }\n\n    this.#dispatchEvent(\"tfliteInference\", { tfliteInference: inference });\n  }\n\n  parseMessage(messageType: TfliteMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getTfliteName\":\n      case \"setTfliteName\":\n        this.#parseName(dataView);\n        break;\n      case \"getTfliteTask\":\n      case \"setTfliteTask\":\n        this.#parseTask(dataView);\n        break;\n      case \"getTfliteSampleRate\":\n      case \"setTfliteSampleRate\":\n        this.#parseSampleRate(dataView);\n        break;\n      case \"getTfliteSensorTypes\":\n      case \"setTfliteSensorTypes\":\n        this.#parseSensorTypes(dataView);\n        break;\n      case \"tfliteIsReady\":\n        this.#parseIsReady(dataView);\n        break;\n      case \"getTfliteCaptureDelay\":\n      case \"setTfliteCaptureDelay\":\n        this.#parseCaptureDelay(dataView);\n        break;\n      case \"getTfliteThreshold\":\n      case \"setTfliteThreshold\":\n        this.#parseThreshold(dataView);\n        break;\n      case \"getTfliteInferencingEnabled\":\n      case \"setTfliteInferencingEnabled\":\n        this.#parseInferencingEnabled(dataView);\n        break;\n      case \"tfliteInference\":\n        this.#parseInference(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  #configuration?: TfliteFileConfiguration;\n  get configuration() {\n    return this.#configuration;\n  }\n  sendConfiguration(\n    configuration: TfliteFileConfiguration,\n    sendImmediately?: boolean\n  ) {\n    if (configuration == this.#configuration) {\n      _console.log(\"redundant tflite configuration assignment\");\n      return;\n    }\n    this.#configuration = configuration;\n    _console.log(\"assigned new tflite configuration\", this.configuration);\n    if (!this.configuration) {\n      return;\n    }\n    const { name, task, captureDelay, sampleRate, threshold, sensorTypes } =\n      this.configuration;\n    this.setName(name, false);\n    this.setTask(task, false);\n    if (captureDelay != undefined) {\n      this.setCaptureDelay(captureDelay, false);\n    }\n    this.setSampleRate(sampleRate, false);\n    if (threshold != undefined) {\n      this.setThreshold(threshold, false);\n    }\n    this.setSensorTypes(sensorTypes, sendImmediately);\n  }\n\n  clear() {\n    this.#configuration = undefined;\n    this.#inferencingEnabled = false;\n    this.#sensorTypes = [];\n    this.#sampleRate = 0;\n    this.#isReady = false;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required tflite information\");\n    const messages = RequiredTfliteMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n}\n\nexport default TfliteManager;\n","import Device from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder } from \"./utils/Text.ts\";\n\nconst _console = createConsole(\"DeviceInformationManager\", { log: false });\n\nexport interface PnpId {\n  source: \"Bluetooth\" | \"USB\";\n  vendorId: number;\n  productId: number;\n  productVersion: number;\n}\n\nexport interface DeviceInformation {\n  manufacturerName: string;\n  modelNumber: string;\n  softwareRevision: string;\n  hardwareRevision: string;\n  firmwareRevision: string;\n  pnpId: PnpId;\n  serialNumber: string;\n}\n\nexport const DeviceInformationTypes = [\n  \"manufacturerName\",\n  \"modelNumber\",\n  \"hardwareRevision\",\n  \"firmwareRevision\",\n  \"softwareRevision\",\n  \"pnpId\",\n  \"serialNumber\",\n] as const;\nexport type DeviceInformationType = (typeof DeviceInformationTypes)[number];\n\nexport const DeviceInformationEventTypes = [\n  ...DeviceInformationTypes,\n  \"deviceInformation\",\n] as const;\nexport type DeviceInformationEventType =\n  (typeof DeviceInformationEventTypes)[number];\n\nexport interface DeviceInformationEventMessages {\n  manufacturerName: { manufacturerName: string };\n  modelNumber: { modelNumber: string };\n  softwareRevision: { softwareRevision: string };\n  hardwareRevision: { hardwareRevision: string };\n  firmwareRevision: { firmwareRevision: string };\n  pnpId: { pnpId: PnpId };\n  serialNumber: { serialNumber: string };\n  deviceInformation: { deviceInformation: DeviceInformation };\n}\n\nexport type DeviceInformationEventDispatcher = EventDispatcher<\n  Device,\n  DeviceInformationEventType,\n  DeviceInformationEventMessages\n>;\n\nclass DeviceInformationManager {\n  eventDispatcher!: DeviceInformationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  #information: Partial<DeviceInformation> = {};\n  get information() {\n    return this.#information as DeviceInformation;\n  }\n  clear() {\n    this.#information = {};\n  }\n  get #isComplete() {\n    return DeviceInformationTypes.filter((key) => key != \"serialNumber\").every(\n      (key) => key in this.#information\n    );\n  }\n\n  #update(partialDeviceInformation: Partial<DeviceInformation>) {\n    _console.log({ partialDeviceInformation });\n    const deviceInformationNames = Object.keys(\n      partialDeviceInformation\n    ) as (keyof DeviceInformation)[];\n    deviceInformationNames.forEach((deviceInformationName) => {\n      // @ts-expect-error\n      this.#dispatchEvent(deviceInformationName, {\n        [deviceInformationName]:\n          partialDeviceInformation[deviceInformationName],\n      });\n    });\n\n    Object.assign(this.#information, partialDeviceInformation);\n    _console.log({ deviceInformation: this.#information });\n    if (this.#isComplete) {\n      _console.log(\"completed deviceInformation\");\n      this.#dispatchEvent(\"deviceInformation\", {\n        deviceInformation: this.information,\n      });\n    }\n  }\n\n  parseMessage(messageType: DeviceInformationType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"manufacturerName\":\n        const manufacturerName = textDecoder.decode(dataView.buffer);\n        _console.log({ manufacturerName });\n        this.#update({ manufacturerName });\n        break;\n      case \"modelNumber\":\n        const modelNumber = textDecoder.decode(dataView.buffer);\n        _console.log({ modelNumber });\n        this.#update({ modelNumber });\n        break;\n      case \"softwareRevision\":\n        const softwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ softwareRevision });\n        this.#update({ softwareRevision });\n        break;\n      case \"hardwareRevision\":\n        const hardwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ hardwareRevision });\n        this.#update({ hardwareRevision });\n        break;\n      case \"firmwareRevision\":\n        const firmwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ firmwareRevision });\n        this.#update({ firmwareRevision });\n        break;\n      case \"pnpId\":\n        const pnpId: PnpId = {\n          source: dataView.getUint8(0) === 1 ? \"Bluetooth\" : \"USB\",\n          productId: dataView.getUint16(3, true),\n          productVersion: dataView.getUint16(5, true),\n          vendorId: 0,\n        };\n        if (pnpId.source == \"Bluetooth\") {\n          pnpId.vendorId = dataView.getUint16(1, true);\n        } else {\n          // no need to implement\n        }\n        _console.log({ pnpId });\n        this.#update({ pnpId });\n        break;\n      case \"serialNumber\":\n        const serialNumber = textDecoder.decode(dataView.buffer);\n        _console.log({ serialNumber });\n        // will only be used for node\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default DeviceInformationManager;\n","import { ConnectionType } from \"./connection/BaseConnectionManager.ts\";\nimport Device, { SendMessageCallback } from \"./Device.ts\";\nimport { UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { Uint16Max } from \"./utils/MathUtils.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"InformationManager\", { log: false });\n\nexport const DeviceTypes = [\n  \"leftInsole\",\n  \"rightInsole\",\n  \"leftGlove\",\n  \"rightGlove\",\n  \"glasses\",\n  \"generic\",\n] as const;\nexport type DeviceType = (typeof DeviceTypes)[number];\n\nexport const Sides = [\"left\", \"right\"] as const;\nexport type Side = (typeof Sides)[number];\n\nexport const MinNameLength = 2;\nexport const MaxNameLength = 30;\n\nexport const InformationMessageTypes = [\n  \"isCharging\",\n  \"getBatteryCurrent\",\n  \"getMtu\",\n  \"getId\",\n  \"getName\",\n  \"setName\",\n  \"getType\",\n  \"setType\",\n  \"getCurrentTime\",\n  \"setCurrentTime\",\n] as const;\nexport type InformationMessageType = (typeof InformationMessageTypes)[number];\n\nexport const InformationEventTypes = InformationMessageTypes;\nexport type InformationEventType = (typeof InformationEventTypes)[number];\n\nexport interface InformationEventMessages {\n  isCharging: { isCharging: boolean };\n  getBatteryCurrent: { batteryCurrent: number };\n  getMtu: { mtu: number };\n  getId: { id: string };\n  getName: { name: string };\n  getType: { type: DeviceType };\n  getCurrentTime: { currentTime: number };\n}\n\nexport type InformationEventDispatcher = EventDispatcher<\n  Device,\n  InformationEventType,\n  InformationEventMessages\n>;\nexport type SendInformationMessageCallback =\n  SendMessageCallback<InformationMessageType>;\n\nclass InformationManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendInformationMessageCallback;\n\n  eventDispatcher!: InformationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  // PROPERTIES\n\n  #isCharging = false;\n  get isCharging() {\n    return this.#isCharging;\n  }\n  #updateIsCharging(updatedIsCharging: boolean) {\n    _console.assertTypeWithError(updatedIsCharging, \"boolean\");\n    this.#isCharging = updatedIsCharging;\n    _console.log({ isCharging: this.#isCharging });\n    this.#dispatchEvent(\"isCharging\", { isCharging: this.#isCharging });\n  }\n\n  #batteryCurrent!: number;\n  get batteryCurrent() {\n    return this.#batteryCurrent;\n  }\n  async getBatteryCurrent() {\n    _console.log(\"getting battery current...\");\n    const promise = this.waitForEvent(\"getBatteryCurrent\");\n    this.sendMessage([{ type: \"getBatteryCurrent\" }]);\n    await promise;\n  }\n  #updateBatteryCurrent(updatedBatteryCurrent: number) {\n    _console.assertTypeWithError(updatedBatteryCurrent, \"number\");\n    this.#batteryCurrent = updatedBatteryCurrent;\n    _console.log({ batteryCurrent: this.#batteryCurrent });\n    this.#dispatchEvent(\"getBatteryCurrent\", {\n      batteryCurrent: this.#batteryCurrent,\n    });\n  }\n\n  #id!: string;\n  get id() {\n    return this.#id;\n  }\n  #updateId(updatedId: string) {\n    _console.assertTypeWithError(updatedId, \"string\");\n    this.#id = updatedId;\n    _console.log({ id: this.#id });\n    this.#dispatchEvent(\"getId\", { id: this.#id });\n  }\n\n  #name = \"\";\n  get name() {\n    return this.#name;\n  }\n\n  updateName(updatedName: string) {\n    _console.assertTypeWithError(updatedName, \"string\");\n    this.#name = updatedName;\n    _console.log({ updatedName: this.#name });\n    this.#dispatchEvent(\"getName\", { name: this.#name });\n  }\n  async setName(newName: string) {\n    _console.assertTypeWithError(newName, \"string\");\n    _console.assertRangeWithError(\n      \"newName\",\n      newName.length,\n      MinNameLength,\n      MaxNameLength\n    );\n    const setNameData = textEncoder.encode(newName);\n    _console.log({ setNameData });\n\n    const promise = this.waitForEvent(\"getName\");\n    this.sendMessage([{ type: \"setName\", data: setNameData.buffer }]);\n    await promise;\n  }\n\n  // TYPE\n  #type!: DeviceType;\n  get type() {\n    return this.#type;\n  }\n  get typeEnum() {\n    return DeviceTypes.indexOf(this.type);\n  }\n  #assertValidDeviceType(type: DeviceType) {\n    _console.assertEnumWithError(type, DeviceTypes);\n  }\n  #assertValidDeviceTypeEnum(typeEnum: number) {\n    _console.assertTypeWithError(typeEnum, \"number\");\n    _console.assertWithError(\n      typeEnum in DeviceTypes,\n      `invalid typeEnum ${typeEnum}`\n    );\n  }\n  updateType(updatedType: DeviceType) {\n    this.#assertValidDeviceType(updatedType);\n    // if (updatedType == this.type) {\n    //   _console.log(\"redundant type assignment\");\n    //   return;\n    // }\n    this.#type = updatedType;\n    _console.log({ updatedType: this.#type });\n\n    this.#dispatchEvent(\"getType\", { type: this.#type });\n  }\n  async #setTypeEnum(newTypeEnum: number) {\n    this.#assertValidDeviceTypeEnum(newTypeEnum);\n\n    const setTypeData = UInt8ByteBuffer(newTypeEnum);\n    _console.log({ setTypeData });\n    const promise = this.waitForEvent(\"getType\");\n    this.sendMessage([{ type: \"setType\", data: setTypeData }]);\n    await promise;\n  }\n  async setType(newType: DeviceType) {\n    this.#assertValidDeviceType(newType);\n    const newTypeEnum = DeviceTypes.indexOf(newType);\n    this.#setTypeEnum(newTypeEnum);\n  }\n\n  get isInsole() {\n    switch (this.type) {\n      case \"leftInsole\":\n      case \"rightInsole\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  get isGlove() {\n    switch (this.type) {\n      case \"leftGlove\":\n      case \"rightGlove\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  get side(): Side {\n    switch (this.type) {\n      case \"leftInsole\":\n      case \"leftGlove\":\n        return \"left\";\n      case \"rightInsole\":\n      case \"rightGlove\":\n        return \"right\";\n      default:\n        return \"left\";\n    }\n  }\n\n  #mtu = 0;\n  get mtu() {\n    return this.#mtu;\n  }\n  #updateMtu(newMtu: number) {\n    _console.assertTypeWithError(newMtu, \"number\");\n    if (this.#mtu == newMtu) {\n      _console.log(\"redundant mtu assignment\", newMtu);\n      return;\n    }\n    this.#mtu = newMtu;\n\n    this.#dispatchEvent(\"getMtu\", { mtu: this.#mtu });\n  }\n\n  #isCurrentTimeSet = false;\n  get isCurrentTimeSet() {\n    return this.#isCurrentTimeSet;\n  }\n\n  #onCurrentTime(currentTime: number) {\n    _console.log({ currentTime });\n    this.#isCurrentTimeSet =\n      currentTime != 0 || Math.abs(Date.now() - currentTime) < Uint16Max;\n    if (!this.#isCurrentTimeSet) {\n      this.#setCurrentTime(false);\n    }\n  }\n  async #setCurrentTime(sendImmediately?: boolean) {\n    _console.log(\"setting current time...\");\n    const dataView = new DataView(new ArrayBuffer(8));\n    dataView.setBigUint64(0, BigInt(Date.now()), true);\n    const promise = this.waitForEvent(\"getCurrentTime\");\n    this.sendMessage(\n      [{ type: \"setCurrentTime\", data: dataView.buffer }],\n      sendImmediately\n    );\n    await promise;\n  }\n\n  // MESSAGE\n  parseMessage(messageType: InformationMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"isCharging\":\n        const isCharging = Boolean(dataView.getUint8(0));\n        _console.log({ isCharging });\n        this.#updateIsCharging(isCharging);\n        break;\n      case \"getBatteryCurrent\":\n        const batteryCurrent = dataView.getFloat32(0, true);\n        _console.log({ batteryCurrent });\n        this.#updateBatteryCurrent(batteryCurrent);\n        break;\n      case \"getId\":\n        const id = textDecoder.decode(dataView.buffer);\n        _console.log({ id });\n        this.#updateId(id);\n        break;\n      case \"getName\":\n      case \"setName\":\n        const name = textDecoder.decode(dataView.buffer);\n        _console.log({ name });\n        this.updateName(name);\n        break;\n      case \"getType\":\n      case \"setType\":\n        const typeEnum = dataView.getUint8(0);\n        const type = DeviceTypes[typeEnum];\n        _console.log({ typeEnum, type });\n        this.updateType(type);\n        break;\n      case \"getMtu\":\n        let mtu = dataView.getUint16(0, true);\n        if (\n          this.connectionType != \"webSocket\" &&\n          this.connectionType != \"udp\"\n        ) {\n          mtu = Math.min(mtu, 512);\n        }\n        _console.log({ mtu });\n        this.#updateMtu(mtu);\n        break;\n      case \"getCurrentTime\":\n      case \"setCurrentTime\":\n        const currentTime = Number(dataView.getBigUint64(0, true));\n        this.#onCurrentTime(currentTime);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    this.#isCurrentTimeSet = false;\n  }\n\n  connectionType?: ConnectionType;\n}\n\nexport default InformationManager;\n","export const VibrationWaveformEffects = [\n  \"none\",\n  \"strongClick100\",\n  \"strongClick60\",\n  \"strongClick30\",\n  \"sharpClick100\",\n  \"sharpClick60\",\n  \"sharpClick30\",\n  \"softBump100\",\n  \"softBump60\",\n  \"softBump30\",\n  \"doubleClick100\",\n  \"doubleClick60\",\n  \"tripleClick100\",\n  \"softFuzz60\",\n  \"strongBuzz100\",\n  \"alert750ms\",\n  \"alert1000ms\",\n  \"strongClick1_100\",\n  \"strongClick2_80\",\n  \"strongClick3_60\",\n  \"strongClick4_30\",\n  \"mediumClick100\",\n  \"mediumClick80\",\n  \"mediumClick60\",\n  \"sharpTick100\",\n  \"sharpTick80\",\n  \"sharpTick60\",\n  \"shortDoubleClickStrong100\",\n  \"shortDoubleClickStrong80\",\n  \"shortDoubleClickStrong60\",\n  \"shortDoubleClickStrong30\",\n  \"shortDoubleClickMedium100\",\n  \"shortDoubleClickMedium80\",\n  \"shortDoubleClickMedium60\",\n  \"shortDoubleSharpTick100\",\n  \"shortDoubleSharpTick80\",\n  \"shortDoubleSharpTick60\",\n  \"longDoubleSharpClickStrong100\",\n  \"longDoubleSharpClickStrong80\",\n  \"longDoubleSharpClickStrong60\",\n  \"longDoubleSharpClickStrong30\",\n  \"longDoubleSharpClickMedium100\",\n  \"longDoubleSharpClickMedium80\",\n  \"longDoubleSharpClickMedium60\",\n  \"longDoubleSharpTick100\",\n  \"longDoubleSharpTick80\",\n  \"longDoubleSharpTick60\",\n  \"buzz100\",\n  \"buzz80\",\n  \"buzz60\",\n  \"buzz40\",\n  \"buzz20\",\n  \"pulsingStrong100\",\n  \"pulsingStrong60\",\n  \"pulsingMedium100\",\n  \"pulsingMedium60\",\n  \"pulsingSharp100\",\n  \"pulsingSharp60\",\n  \"transitionClick100\",\n  \"transitionClick80\",\n  \"transitionClick60\",\n  \"transitionClick40\",\n  \"transitionClick20\",\n  \"transitionClick10\",\n  \"transitionHum100\",\n  \"transitionHum80\",\n  \"transitionHum60\",\n  \"transitionHum40\",\n  \"transitionHum20\",\n  \"transitionHum10\",\n  \"transitionRampDownLongSmooth2_100\",\n  \"transitionRampDownLongSmooth1_100\",\n  \"transitionRampDownMediumSmooth1_100\",\n  \"transitionRampDownMediumSmooth2_100\",\n  \"transitionRampDownShortSmooth1_100\",\n  \"transitionRampDownShortSmooth2_100\",\n  \"transitionRampDownLongSharp1_100\",\n  \"transitionRampDownLongSharp2_100\",\n  \"transitionRampDownMediumSharp1_100\",\n  \"transitionRampDownMediumSharp2_100\",\n  \"transitionRampDownShortSharp1_100\",\n  \"transitionRampDownShortSharp2_100\",\n  \"transitionRampUpLongSmooth1_100\",\n  \"transitionRampUpLongSmooth2_100\",\n  \"transitionRampUpMediumSmooth1_100\",\n  \"transitionRampUpMediumSmooth2_100\",\n  \"transitionRampUpShortSmooth1_100\",\n  \"transitionRampUpShortSmooth2_100\",\n  \"transitionRampUpLongSharp1_100\",\n  \"transitionRampUpLongSharp2_100\",\n  \"transitionRampUpMediumSharp1_100\",\n  \"transitionRampUpMediumSharp2_100\",\n  \"transitionRampUpShortSharp1_100\",\n  \"transitionRampUpShortSharp2_100\",\n  \"transitionRampDownLongSmooth1_50\",\n  \"transitionRampDownLongSmooth2_50\",\n  \"transitionRampDownMediumSmooth1_50\",\n  \"transitionRampDownMediumSmooth2_50\",\n  \"transitionRampDownShortSmooth1_50\",\n  \"transitionRampDownShortSmooth2_50\",\n  \"transitionRampDownLongSharp1_50\",\n  \"transitionRampDownLongSharp2_50\",\n  \"transitionRampDownMediumSharp1_50\",\n  \"transitionRampDownMediumSharp2_50\",\n  \"transitionRampDownShortSharp1_50\",\n  \"transitionRampDownShortSharp2_50\",\n  \"transitionRampUpLongSmooth1_50\",\n  \"transitionRampUpLongSmooth2_50\",\n  \"transitionRampUpMediumSmooth1_50\",\n  \"transitionRampUpMediumSmooth2_50\",\n  \"transitionRampUpShortSmooth1_50\",\n  \"transitionRampUpShortSmooth2_50\",\n  \"transitionRampUpLongSharp1_50\",\n  \"transitionRampUpLongSharp2_50\",\n  \"transitionRampUpMediumSharp1_50\",\n  \"transitionRampUpMediumSharp2_50\",\n  \"transitionRampUpShortSharp1_50\",\n  \"transitionRampUpShortSharp2_50\",\n  \"longBuzz100\",\n  \"smoothHum50\",\n  \"smoothHum40\",\n  \"smoothHum30\",\n  \"smoothHum20\",\n  \"smoothHum10\",\n] as const;\n\nexport type VibrationWaveformEffect = (typeof VibrationWaveformEffects)[number];\n","import { createConsole } from \"../utils/Console.ts\";\nimport {\n  VibrationWaveformEffect,\n  VibrationWaveformEffects,\n} from \"./VibrationWaveformEffects.ts\";\nimport { concatenateArrayBuffers } from \"../utils/ArrayBufferUtils.ts\";\nimport Device, { SendMessageCallback } from \"../Device.ts\";\nimport autoBind from \"auto-bind\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\n\nconst _console = createConsole(\"VibrationManager\", { log: false });\n\nexport const VibrationLocations = [\"front\", \"rear\"] as const;\nexport type VibrationLocation = (typeof VibrationLocations)[number];\n\nexport const VibrationTypes = [\"waveformEffect\", \"waveform\"] as const;\nexport type VibrationType = (typeof VibrationTypes)[number];\n\nexport interface VibrationWaveformEffectSegment {\n  effect?: VibrationWaveformEffect;\n  delay?: number;\n  loopCount?: number;\n}\n\nexport interface VibrationWaveformSegment {\n  duration: number;\n  amplitude: number;\n}\n\nexport const VibrationMessageTypes = [\n  \"getVibrationLocations\",\n  \"triggerVibration\",\n] as const;\nexport type VibrationMessageType = (typeof VibrationMessageTypes)[number];\n\nexport const VibrationEventTypes = VibrationMessageTypes;\nexport type VibrationEventType = (typeof VibrationEventTypes)[number];\n\nexport interface VibrationEventMessages {\n  getVibrationLocations: { vibrationLocations: VibrationLocation[] };\n}\n\nexport const MaxNumberOfVibrationWaveformEffectSegments = 8;\nexport const MaxVibrationWaveformSegmentDuration = 2550;\nexport const MaxVibrationWaveformEffectSegmentDelay = 1270;\nexport const MaxVibrationWaveformEffectSegmentLoopCount = 3;\nexport const MaxNumberOfVibrationWaveformSegments = 20;\nexport const MaxVibrationWaveformEffectSequenceLoopCount = 6;\n\ninterface BaseVibrationConfiguration {\n  type: VibrationType;\n  locations?: VibrationLocation[];\n}\n\nexport interface VibrationWaveformEffectConfiguration\n  extends BaseVibrationConfiguration {\n  type: \"waveformEffect\";\n  segments: VibrationWaveformEffectSegment[];\n  loopCount?: number;\n}\n\nexport interface VibrationWaveformConfiguration\n  extends BaseVibrationConfiguration {\n  type: \"waveform\";\n  segments: VibrationWaveformSegment[];\n}\n\nexport type VibrationConfiguration =\n  | VibrationWaveformEffectConfiguration\n  | VibrationWaveformConfiguration;\n\nexport type SendVibrationMessageCallback =\n  SendMessageCallback<VibrationMessageType>;\n\nexport type VibrationEventDispatcher = EventDispatcher<\n  Device,\n  VibrationEventType,\n  VibrationEventMessages\n>;\n\nclass VibrationManager {\n  constructor() {\n    autoBind(this);\n  }\n  sendMessage!: SendVibrationMessageCallback;\n\n  eventDispatcher!: VibrationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  #verifyLocation(location: VibrationLocation) {\n    _console.assertTypeWithError(location, \"string\");\n    _console.assertWithError(\n      VibrationLocations.includes(location),\n      `invalid location \"${location}\"`\n    );\n  }\n  #verifyLocations(locations: VibrationLocation[]) {\n    this.#assertNonEmptyArray(locations);\n    locations.forEach((location) => {\n      this.#verifyLocation(location);\n    });\n  }\n  #createLocationsBitmask(locations: VibrationLocation[]) {\n    this.#verifyLocations(locations);\n\n    let locationsBitmask = 0;\n    locations.forEach((location) => {\n      const locationIndex = VibrationLocations.indexOf(location);\n      locationsBitmask |= 1 << locationIndex;\n    });\n    _console.log({ locationsBitmask });\n    _console.assertWithError(\n      locationsBitmask > 0,\n      `locationsBitmask must not be zero`\n    );\n    return locationsBitmask;\n  }\n\n  #assertNonEmptyArray(array: any[]) {\n    _console.assertWithError(Array.isArray(array), \"passed non-array\");\n    _console.assertWithError(array.length > 0, \"passed empty array\");\n  }\n\n  #verifyWaveformEffect(waveformEffect: VibrationWaveformEffect) {\n    _console.assertWithError(\n      VibrationWaveformEffects.includes(waveformEffect),\n      `invalid waveformEffect \"${waveformEffect}\"`\n    );\n  }\n\n  #verifyWaveformEffectSegment(\n    waveformEffectSegment: VibrationWaveformEffectSegment\n  ) {\n    if (waveformEffectSegment.effect != undefined) {\n      const waveformEffect = waveformEffectSegment.effect;\n      this.#verifyWaveformEffect(waveformEffect);\n    } else if (waveformEffectSegment.delay != undefined) {\n      const { delay } = waveformEffectSegment;\n      _console.assertWithError(\n        delay >= 0,\n        `delay must be 0ms or greater (got ${delay})`\n      );\n      _console.assertWithError(\n        delay <= MaxVibrationWaveformEffectSegmentDelay,\n        `delay must be ${MaxVibrationWaveformEffectSegmentDelay}ms or less (got ${delay})`\n      );\n    } else {\n      throw Error(\"no effect or delay found in waveformEffectSegment\");\n    }\n\n    if (waveformEffectSegment.loopCount != undefined) {\n      const { loopCount } = waveformEffectSegment;\n      this.#verifyWaveformEffectSegmentLoopCount(loopCount);\n    }\n  }\n\n  #verifyWaveformEffectSegmentLoopCount(\n    waveformEffectSegmentLoopCount: number\n  ) {\n    _console.assertTypeWithError(waveformEffectSegmentLoopCount, \"number\");\n    _console.assertWithError(\n      waveformEffectSegmentLoopCount >= 0,\n      `waveformEffectSegmentLoopCount must be 0 or greater (got ${waveformEffectSegmentLoopCount})`\n    );\n    _console.assertWithError(\n      waveformEffectSegmentLoopCount <=\n        MaxVibrationWaveformEffectSegmentLoopCount,\n      `waveformEffectSegmentLoopCount must be ${MaxVibrationWaveformEffectSegmentLoopCount} or fewer (got ${waveformEffectSegmentLoopCount})`\n    );\n  }\n\n  #verifyWaveformEffectSegments(\n    waveformEffectSegments: VibrationWaveformEffectSegment[]\n  ) {\n    this.#assertNonEmptyArray(waveformEffectSegments);\n    _console.assertWithError(\n      waveformEffectSegments.length <=\n        MaxNumberOfVibrationWaveformEffectSegments,\n      `must have ${MaxNumberOfVibrationWaveformEffectSegments} waveformEffectSegments or fewer (got ${waveformEffectSegments.length})`\n    );\n    waveformEffectSegments.forEach((waveformEffectSegment) => {\n      this.#verifyWaveformEffectSegment(waveformEffectSegment);\n    });\n  }\n\n  #verifyWaveformEffectSequenceLoopCount(\n    waveformEffectSequenceLoopCount: number\n  ) {\n    _console.assertTypeWithError(waveformEffectSequenceLoopCount, \"number\");\n    _console.assertWithError(\n      waveformEffectSequenceLoopCount >= 0,\n      `waveformEffectSequenceLoopCount must be 0 or greater (got ${waveformEffectSequenceLoopCount})`\n    );\n    _console.assertWithError(\n      waveformEffectSequenceLoopCount <=\n        MaxVibrationWaveformEffectSequenceLoopCount,\n      `waveformEffectSequenceLoopCount must be ${MaxVibrationWaveformEffectSequenceLoopCount} or fewer (got ${waveformEffectSequenceLoopCount})`\n    );\n  }\n\n  #verifyWaveformSegment(waveformSegment: VibrationWaveformSegment) {\n    _console.assertTypeWithError(waveformSegment.amplitude, \"number\");\n    _console.assertWithError(\n      waveformSegment.amplitude >= 0,\n      `amplitude must be 0 or greater (got ${waveformSegment.amplitude})`\n    );\n    _console.assertWithError(\n      waveformSegment.amplitude <= 1,\n      `amplitude must be 1 or less (got ${waveformSegment.amplitude})`\n    );\n\n    _console.assertTypeWithError(waveformSegment.duration, \"number\");\n    _console.assertWithError(\n      waveformSegment.duration > 0,\n      `duration must be greater than 0ms (got ${waveformSegment.duration}ms)`\n    );\n    _console.assertWithError(\n      waveformSegment.duration <= MaxVibrationWaveformSegmentDuration,\n      `duration must be ${MaxVibrationWaveformSegmentDuration}ms or less (got ${waveformSegment.duration}ms)`\n    );\n  }\n\n  #verifyWaveformSegments(waveformSegments: VibrationWaveformSegment[]) {\n    this.#assertNonEmptyArray(waveformSegments);\n    _console.assertWithError(\n      waveformSegments.length <= MaxNumberOfVibrationWaveformSegments,\n      `must have ${MaxNumberOfVibrationWaveformSegments} waveformSegments or fewer (got ${waveformSegments.length})`\n    );\n    waveformSegments.forEach((waveformSegment) => {\n      this.#verifyWaveformSegment(waveformSegment);\n    });\n  }\n\n  #createWaveformEffectsData(\n    locations: VibrationLocation[],\n    waveformEffectSegments: VibrationWaveformEffectSegment[],\n    waveformEffectSequenceLoopCount: number = 0\n  ) {\n    this.#verifyWaveformEffectSegments(waveformEffectSegments);\n    this.#verifyWaveformEffectSequenceLoopCount(\n      waveformEffectSequenceLoopCount\n    );\n\n    let dataArray = [];\n    let byteOffset = 0;\n\n    const hasAtLeast1WaveformEffectWithANonzeroLoopCount =\n      waveformEffectSegments.some((waveformEffectSegment) => {\n        const { loopCount } = waveformEffectSegment;\n        return loopCount != undefined && loopCount > 0;\n      });\n\n    const includeAllWaveformEffectSegments =\n      hasAtLeast1WaveformEffectWithANonzeroLoopCount ||\n      waveformEffectSequenceLoopCount != 0;\n\n    for (\n      let index = 0;\n      index < waveformEffectSegments.length ||\n      (includeAllWaveformEffectSegments &&\n        index < MaxNumberOfVibrationWaveformEffectSegments);\n      index++\n    ) {\n      const waveformEffectSegment = waveformEffectSegments[index] || {\n        effect: \"none\",\n      };\n      if (waveformEffectSegment.effect != undefined) {\n        const waveformEffect = waveformEffectSegment.effect;\n        dataArray[byteOffset++] =\n          VibrationWaveformEffects.indexOf(waveformEffect);\n      } else if (waveformEffectSegment.delay != undefined) {\n        const { delay } = waveformEffectSegment;\n        dataArray[byteOffset++] = (1 << 7) | Math.floor(delay / 10); // set most significant bit to 1\n      } else {\n        throw Error(\"invalid waveformEffectSegment\");\n      }\n    }\n\n    const includeAllWaveformEffectSegmentLoopCounts =\n      waveformEffectSequenceLoopCount != 0;\n    for (\n      let index = 0;\n      index < waveformEffectSegments.length ||\n      (includeAllWaveformEffectSegmentLoopCounts &&\n        index < MaxNumberOfVibrationWaveformEffectSegments);\n      index++\n    ) {\n      const waveformEffectSegmentLoopCount =\n        waveformEffectSegments[index]?.loopCount || 0;\n      if (index == 0 || index == 4) {\n        dataArray[byteOffset] = 0;\n      }\n      const bitOffset = 2 * (index % 4);\n      dataArray[byteOffset] |= waveformEffectSegmentLoopCount << bitOffset;\n      if (index == 3 || index == 7) {\n        byteOffset++;\n      }\n    }\n\n    if (waveformEffectSequenceLoopCount != 0) {\n      dataArray[byteOffset++] = waveformEffectSequenceLoopCount;\n    }\n    const dataView = new DataView(Uint8Array.from(dataArray).buffer);\n    _console.log({ dataArray, dataView });\n    return this.#createData(locations, \"waveformEffect\", dataView);\n  }\n  #createWaveformData(\n    locations: VibrationLocation[],\n    waveformSegments: VibrationWaveformSegment[]\n  ) {\n    this.#verifyWaveformSegments(waveformSegments);\n    const dataView = new DataView(new ArrayBuffer(waveformSegments.length * 2));\n    waveformSegments.forEach((waveformSegment, index) => {\n      dataView.setUint8(index * 2, Math.floor(waveformSegment.amplitude * 127));\n      dataView.setUint8(\n        index * 2 + 1,\n        Math.floor(waveformSegment.duration / 10)\n      );\n    });\n    _console.log({ dataView });\n    return this.#createData(locations, \"waveform\", dataView);\n  }\n\n  #verifyVibrationType(vibrationType: VibrationType) {\n    _console.assertTypeWithError(vibrationType, \"string\");\n    _console.assertWithError(\n      VibrationTypes.includes(vibrationType),\n      `invalid vibrationType \"${vibrationType}\"`\n    );\n  }\n\n  #createData(\n    locations: VibrationLocation[],\n    vibrationType: VibrationType,\n    dataView: DataView\n  ) {\n    _console.assertWithError(dataView?.byteLength > 0, \"no data received\");\n    const locationsBitmask = this.#createLocationsBitmask(locations);\n    this.#verifyVibrationType(vibrationType);\n    const vibrationTypeIndex = VibrationTypes.indexOf(vibrationType);\n    _console.log({ locationsBitmask, vibrationTypeIndex, dataView });\n    const data = concatenateArrayBuffers(\n      locationsBitmask,\n      vibrationTypeIndex,\n      dataView.byteLength,\n      dataView\n    );\n    _console.log({ data });\n    return data;\n  }\n\n  async triggerVibration(\n    vibrationConfigurations: VibrationConfiguration[],\n    sendImmediately: boolean = true\n  ) {\n    let triggerVibrationData!: ArrayBuffer;\n    vibrationConfigurations.forEach((vibrationConfiguration) => {\n      const { type } = vibrationConfiguration;\n\n      let { locations } = vibrationConfiguration;\n      locations = locations || this.vibrationLocations.slice();\n      locations = locations.filter((location) =>\n        this.vibrationLocations.includes(location)\n      );\n\n      let arrayBuffer: ArrayBuffer;\n\n      switch (type) {\n        case \"waveformEffect\":\n          {\n            const { segments, loopCount } = vibrationConfiguration;\n            arrayBuffer = this.#createWaveformEffectsData(\n              locations,\n              segments,\n              loopCount\n            );\n          }\n          break;\n        case \"waveform\":\n          {\n            const { segments } = vibrationConfiguration;\n            arrayBuffer = this.#createWaveformData(locations, segments);\n          }\n          break;\n        default:\n          throw Error(`invalid vibration type \"${type}\"`);\n      }\n      _console.log({ type, arrayBuffer });\n      triggerVibrationData = concatenateArrayBuffers(\n        triggerVibrationData,\n        arrayBuffer\n      );\n    });\n    await this.sendMessage(\n      [{ type: \"triggerVibration\", data: triggerVibrationData }],\n      sendImmediately\n    );\n  }\n\n  #vibrationLocations: VibrationLocation[] = [];\n  get vibrationLocations() {\n    return this.#vibrationLocations;\n  }\n  #onVibrationLocations(vibrationLocations: VibrationLocation[]) {\n    this.#vibrationLocations = vibrationLocations;\n    _console.log(\"vibrationLocations\", vibrationLocations);\n    this.#dispatchEvent(\"getVibrationLocations\", {\n      vibrationLocations: this.#vibrationLocations,\n    });\n  }\n\n  // MESSAGE\n  parseMessage(messageType: VibrationMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getVibrationLocations\":\n        const vibrationLocations = Array.from(new Uint8Array(dataView.buffer))\n          .map((index) => VibrationLocations[index])\n          .filter(Boolean);\n        this.#onVibrationLocations(vibrationLocations);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default VibrationManager;\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport { UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInNode } from \"./utils/environment.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"WifiManager\", { log: false });\n\nexport const MinWifiSSIDLength = 1;\nexport const MaxWifiSSIDLength = 32;\n\nexport const MinWifiPasswordLength = 8;\nexport const MaxWifiPasswordLength = 64;\n\nexport const WifiMessageTypes = [\n  \"isWifiAvailable\",\n  \"getWifiSSID\",\n  \"setWifiSSID\",\n  \"getWifiPassword\",\n  \"setWifiPassword\",\n  \"getWifiConnectionEnabled\",\n  \"setWifiConnectionEnabled\",\n  \"isWifiConnected\",\n  \"ipAddress\",\n  \"isWifiSecure\",\n] as const;\nexport type WifiMessageType = (typeof WifiMessageTypes)[number];\n\nexport const RequiredWifiMessageTypes: WifiMessageType[] = [\n  \"getWifiSSID\",\n  \"getWifiPassword\",\n  \"getWifiConnectionEnabled\",\n  \"isWifiConnected\",\n  \"ipAddress\",\n  \"isWifiSecure\",\n] as const;\n\nexport const WifiEventTypes = WifiMessageTypes;\nexport type WifiEventType = (typeof WifiEventTypes)[number];\n\nexport interface WifiEventMessages {\n  isWifiAvailable: { isWifiAvailable: boolean };\n  getWifiSSID: { wifiSSID: string };\n  getWifiPassword: { wifiPassword: string };\n  getEnableWifiConnection: { wifiConnectionEnabled: boolean };\n  isWifiConnected: { isWifiConnected: boolean };\n  ipAddress: { ipAddress?: string };\n}\n\nexport type WifiEventDispatcher = EventDispatcher<\n  Device,\n  WifiEventType,\n  WifiEventMessages\n>;\nexport type SendWifiMessageCallback = SendMessageCallback<WifiMessageType>;\n\nclass WifiManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendWifiMessageCallback;\n\n  eventDispatcher!: WifiEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required wifi information\");\n    const messages = RequiredWifiMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // PROPERTIES\n\n  #isWifiAvailable = false;\n  get isWifiAvailable() {\n    return this.#isWifiAvailable;\n  }\n  #updateIsWifiAvailable(updatedIsWifiAvailable: boolean) {\n    _console.assertTypeWithError(updatedIsWifiAvailable, \"boolean\");\n    this.#isWifiAvailable = updatedIsWifiAvailable;\n    _console.log({ isWifiAvailable: this.#isWifiAvailable });\n    this.#dispatchEvent(\"isWifiAvailable\", {\n      isWifiAvailable: this.#isWifiAvailable,\n    });\n  }\n\n  #assertWifiIsAvailable() {\n    _console.assertWithError(this.#isWifiAvailable, \"wifi is not available\");\n  }\n\n  // WIFI SSID\n  #wifiSSID = \"\";\n  get wifiSSID() {\n    return this.#wifiSSID;\n  }\n\n  #updateWifiSSID(updatedWifiSSID: string) {\n    _console.assertTypeWithError(updatedWifiSSID, \"string\");\n    this.#wifiSSID = updatedWifiSSID;\n    _console.log({ wifiSSID: this.#wifiSSID });\n    this.#dispatchEvent(\"getWifiSSID\", { wifiSSID: this.#wifiSSID });\n  }\n  async setWifiSSID(newWifiSSID: string) {\n    this.#assertWifiIsAvailable();\n    if (this.#wifiConnectionEnabled) {\n      _console.error(\"cannot change ssid while wifi connection is enabled\");\n      return;\n    }\n    _console.assertTypeWithError(newWifiSSID, \"string\");\n    _console.assertRangeWithError(\n      \"wifiSSID\",\n      newWifiSSID.length,\n      MinWifiSSIDLength,\n      MaxWifiSSIDLength\n    );\n\n    const setWifiSSIDData = textEncoder.encode(newWifiSSID);\n    _console.log({ setWifiSSIDData });\n\n    const promise = this.waitForEvent(\"getWifiSSID\");\n    this.sendMessage([{ type: \"setWifiSSID\", data: setWifiSSIDData.buffer }]);\n    await promise;\n  }\n\n  // WIFI PASSWORD\n  #wifiPassword = \"\";\n  get wifiPassword() {\n    return this.#wifiPassword;\n  }\n\n  #updateWifiPassword(updatedWifiPassword: string) {\n    _console.assertTypeWithError(updatedWifiPassword, \"string\");\n    this.#wifiPassword = updatedWifiPassword;\n    _console.log({ wifiPassword: this.#wifiPassword });\n    this.#dispatchEvent(\"getWifiPassword\", {\n      wifiPassword: this.#wifiPassword,\n    });\n  }\n  async setWifiPassword(newWifiPassword: string) {\n    this.#assertWifiIsAvailable();\n    if (this.#wifiConnectionEnabled) {\n      _console.error(\"cannot change password while wifi connection is enabled\");\n      return;\n    }\n    _console.assertTypeWithError(newWifiPassword, \"string\");\n    if (newWifiPassword.length > 0) {\n      _console.assertRangeWithError(\n        \"wifiPassword\",\n        newWifiPassword.length,\n        MinWifiPasswordLength,\n        MaxWifiPasswordLength\n      );\n    }\n\n    const setWifiPasswordData = textEncoder.encode(newWifiPassword);\n    _console.log({ setWifiPasswordData });\n\n    const promise = this.waitForEvent(\"getWifiPassword\");\n    this.sendMessage([\n      { type: \"setWifiPassword\", data: setWifiPasswordData.buffer },\n    ]);\n    await promise;\n  }\n\n  // ENABLE WIFI CONNECTION\n  #wifiConnectionEnabled!: boolean;\n  get wifiConnectionEnabled() {\n    return this.#wifiConnectionEnabled;\n  }\n  #updateWifiConnectionEnabled(wifiConnectionEnabled: boolean) {\n    _console.log({ wifiConnectionEnabled });\n    this.#wifiConnectionEnabled = wifiConnectionEnabled;\n    this.#dispatchEvent(\"getWifiConnectionEnabled\", {\n      wifiConnectionEnabled: wifiConnectionEnabled,\n    });\n  }\n  async setWifiConnectionEnabled(\n    newWifiConnectionEnabled: boolean,\n    sendImmediately: boolean = true\n  ) {\n    this.#assertWifiIsAvailable();\n    _console.assertTypeWithError(newWifiConnectionEnabled, \"boolean\");\n    if (this.#wifiConnectionEnabled == newWifiConnectionEnabled) {\n      _console.log(\n        `redundant wifiConnectionEnabled assignment ${newWifiConnectionEnabled}`\n      );\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getWifiConnectionEnabled\");\n\n    this.sendMessage(\n      [\n        {\n          type: \"setWifiConnectionEnabled\",\n\n          data: UInt8ByteBuffer(Number(newWifiConnectionEnabled)),\n        },\n      ],\n      sendImmediately\n    );\n    await promise;\n  }\n  async toggleWifiConnection() {\n    return this.setWifiConnectionEnabled(!this.wifiConnectionEnabled);\n  }\n  async enableWifiConnection() {\n    return this.setWifiConnectionEnabled(true);\n  }\n  async disableWifiConnection() {\n    return this.setWifiConnectionEnabled(false);\n  }\n\n  // IS WIFI CONNECTED\n  #isWifiConnected = false;\n  get isWifiConnected() {\n    return this.#isWifiConnected;\n  }\n  #updateIsWifiConnected(updatedIsWifiConnected: boolean) {\n    _console.assertTypeWithError(updatedIsWifiConnected, \"boolean\");\n    this.#isWifiConnected = updatedIsWifiConnected;\n    _console.log({ isWifiConnected: this.#isWifiConnected });\n    this.#dispatchEvent(\"isWifiConnected\", {\n      isWifiConnected: this.#isWifiConnected,\n    });\n  }\n\n  // IP ADDRESS\n  #ipAddress?: string;\n  get ipAddress() {\n    return this.#ipAddress;\n  }\n\n  #updateIpAddress(updatedIpAddress?: string) {\n    this.#ipAddress = updatedIpAddress;\n    _console.log({ ipAddress: this.#ipAddress });\n    this.#dispatchEvent(\"ipAddress\", {\n      ipAddress: this.#ipAddress,\n    });\n  }\n\n  // IS WIFI SECURE\n  #isWifiSecure = false;\n  get isWifiSecure() {\n    return this.#isWifiSecure;\n  }\n  #updateIsWifiSecure(updatedIsWifiSecure: boolean) {\n    _console.assertTypeWithError(updatedIsWifiSecure, \"boolean\");\n    this.#isWifiSecure = updatedIsWifiSecure;\n    _console.log({ isWifiSecure: this.#isWifiSecure });\n    this.#dispatchEvent(\"isWifiSecure\", {\n      isWifiSecure: this.#isWifiSecure,\n    });\n  }\n\n  // MESSAGE\n  parseMessage(messageType: WifiMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"isWifiAvailable\":\n        const isWifiAvailable = Boolean(dataView.getUint8(0));\n        _console.log({ isWifiAvailable });\n        this.#updateIsWifiAvailable(isWifiAvailable);\n        break;\n      case \"getWifiSSID\":\n      case \"setWifiSSID\":\n        const ssid = textDecoder.decode(dataView.buffer);\n        _console.log({ ssid });\n        this.#updateWifiSSID(ssid);\n        break;\n      case \"getWifiPassword\":\n      case \"setWifiPassword\":\n        const password = textDecoder.decode(dataView.buffer);\n        _console.log({ password });\n        this.#updateWifiPassword(password);\n        break;\n      case \"getWifiConnectionEnabled\":\n      case \"setWifiConnectionEnabled\":\n        const enableWifiConnection = Boolean(dataView.getUint8(0));\n        _console.log({ enableWifiConnection });\n        this.#updateWifiConnectionEnabled(enableWifiConnection);\n        break;\n      case \"isWifiConnected\":\n        const isWifiConnected = Boolean(dataView.getUint8(0));\n        _console.log({ isWifiConnected });\n        this.#updateIsWifiConnected(isWifiConnected);\n        break;\n      case \"ipAddress\":\n        let ipAddress: string | undefined = undefined;\n        if (dataView.byteLength == 4) {\n          ipAddress = new Uint8Array(dataView.buffer.slice(0, 4)).join(\".\");\n        }\n        _console.log({ ipAddress });\n        this.#updateIpAddress(ipAddress);\n        break;\n      case \"isWifiSecure\":\n        const isWifiSecure = Boolean(dataView.getUint8(0));\n        _console.log({ isWifiSecure });\n        this.#updateIsWifiSecure(isWifiSecure);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    this.#wifiSSID = \"\";\n    this.#wifiPassword = \"\";\n    this.#ipAddress = \"\";\n    this.#isWifiConnected = false;\n    this.#isWifiAvailable = false;\n  }\n}\n\nexport default WifiManager;\n","import { DisplayColorRGB } from \"../DisplayManager.ts\";\nimport { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"ColorUtils\", { log: false });\n\nexport function hexToRGB(hex: string): DisplayColorRGB {\n  hex = hex.replace(/^#/, \"\");\n\n  if (hex.length == 3) {\n    hex = hex\n      .split(\"\")\n      .map((char) => char + char)\n      .join(\"\");\n  }\n\n  _console.assertWithError(\n    hex.length == 6,\n    `hex length must be 6 (got ${hex.length})`\n  );\n\n  const r = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n\n  return { r, g, b };\n}\n\nconst blackColor: DisplayColorRGB = { r: 0, g: 0, b: 0 };\nexport function colorNameToRGB(colorName: string): DisplayColorRGB {\n  const temp = document.createElement(\"div\");\n  temp.style.color = colorName;\n  document.body.appendChild(temp);\n\n  const computedColor = getComputedStyle(temp).color;\n  document.body.removeChild(temp);\n\n  // Match \"rgb(r, g, b)\" or \"rgba(r, g, b, a)\"\n  const match = computedColor.match(/^rgba?\\((\\d+), (\\d+), (\\d+)/);\n  if (!match) return blackColor;\n\n  return {\n    r: parseInt(match[1], 10),\n    g: parseInt(match[2], 10),\n    b: parseInt(match[3], 10),\n  };\n}\n\nexport function stringToRGB(string: string): DisplayColorRGB {\n  if (string.startsWith(\"#\")) {\n    return hexToRGB(string);\n  } else {\n    return colorNameToRGB(string);\n  }\n}\n\nexport function rgbToHex({ r, g, b }: DisplayColorRGB): string {\n  const toHex = (value: number) =>\n    value.toString(16).padStart(2, \"0\").toLowerCase();\n\n  _console.assertWithError(\n    [r, g, b].every((v) => v >= 0 && v <= 255),\n    `RGB values must be between 0 and 255 (got r=${r}, g=${g}, b=${b})`\n  );\n\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n}\n","export const DisplaySegmentCaps = [\"flat\", \"round\"] as const;\nexport type DisplaySegmentCap = (typeof DisplaySegmentCaps)[number];\n\nexport type DisplayContextState = {\n  fillColorIndex: number;\n  lineColorIndex: number;\n  lineWidth: number;\n\n  rotation: number;\n\n  segmentStartCap: DisplaySegmentCap;\n  segmentEndCap: DisplaySegmentCap;\n\n  segmentStartRadius: number;\n  segmentEndRadius: number;\n\n  cropTop: number;\n  cropRight: number;\n  cropBottom: number;\n  cropLeft: number;\n\n  rotationCropTop: number;\n  rotationCropRight: number;\n  rotationCropBottom: number;\n  rotationCropLeft: number;\n\n  bitmapColorIndices: number[];\n  bitmapScaleX: number;\n  bitmapScaleY: number;\n\n  // FILL - text stuff\n};\nexport type DisplayContextStateKey = keyof DisplayContextState;\nexport type PartialDisplayContextState = Partial<DisplayContextState>;\n\nexport const DefaultDisplayContextState: DisplayContextState = {\n  fillColorIndex: 1,\n\n  lineColorIndex: 1,\n  lineWidth: 0,\n\n  rotation: 0,\n\n  segmentStartCap: \"flat\",\n  segmentEndCap: \"flat\",\n\n  segmentStartRadius: 1,\n  segmentEndRadius: 1,\n\n  cropTop: 0,\n  cropRight: 0,\n  cropBottom: 0,\n  cropLeft: 0,\n\n  rotationCropTop: 0,\n  rotationCropRight: 0,\n  rotationCropBottom: 0,\n  rotationCropLeft: 0,\n\n  bitmapColorIndices: new Array(0).fill(0),\n  bitmapScaleX: 1,\n  bitmapScaleY: 1,\n};\n","export function deepEqual(obj1: any, obj2: any): boolean {\n  if (obj1 === obj2) {\n    return true;\n  }\n\n  if (\n    typeof obj1 !== \"object\" ||\n    obj1 === null ||\n    typeof obj2 !== \"object\" ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  if (keys1.length !== keys2.length) return false;\n\n  for (let key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { createConsole } from \"./Console.ts\";\nimport {\n  DefaultDisplayContextState,\n  DisplayContextState,\n  DisplayContextStateKey,\n  PartialDisplayContextState,\n} from \"./DisplayContextState.ts\";\nimport { deepEqual } from \"./ObjectUtils.ts\";\n\nconst _console = createConsole(\"DisplayContextStateHelper\", { log: false });\n\nclass DisplayContextStateHelper {\n  #state: DisplayContextState = Object.assign({}, DefaultDisplayContextState);\n  get state() {\n    return this.#state;\n  }\n\n  diff(other: PartialDisplayContextState) {\n    let differences: DisplayContextStateKey[] = [];\n    const keys = Object.keys(other) as DisplayContextStateKey[];\n    keys.forEach((key) => {\n      const value = other[key]!;\n\n      if (!deepEqual(this.#state[key], value)) {\n        differences.push(key);\n      }\n    });\n    _console.log(\"diff\", other, differences);\n    return differences;\n  }\n  update(newState: PartialDisplayContextState) {\n    let differences = this.diff(newState);\n    if (differences.length == 0) {\n      _console.log(\"redundant contextState\", newState);\n    }\n    differences.forEach((key) => {\n      const value = newState[key]!;\n      // @ts-expect-error\n      this.#state[key] = value;\n    });\n    return differences;\n  }\n  reset() {\n    Object.assign(this.#state, DefaultDisplayContextState);\n  }\n}\n\nexport default DisplayContextStateHelper;\n","import {\n  DisplayBrightness,\n  DisplayBrightnesses,\n  DisplayPixelDepth,\n  DisplayPixelDepths,\n} from \"../DisplayManager.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { DisplayContextCommand } from \"./DisplayContextCommand.ts\";\nimport {\n  DisplayContextStateKey,\n  DisplaySegmentCap,\n  DisplaySegmentCaps,\n} from \"./DisplayContextState.ts\";\nimport { Int16Max, Uint16Max } from \"./MathUtils.ts\";\n\nconst _console = createConsole(\"DisplayUtils\", { log: false });\n\nexport function formatRotation(\n  rotation: number,\n  isRadians?: boolean,\n  isSigned?: boolean\n) {\n  if (isRadians) {\n    const rotationRad = rotation;\n    _console.log({ rotationRad });\n    rotation %= 2 * Math.PI;\n    rotation /= 2 * Math.PI;\n  } else {\n    const rotationDeg = rotation;\n    _console.log({ rotationDeg });\n    rotation %= 360;\n    rotation /= 360;\n  }\n  if (isSigned) {\n    rotation *= Int16Max;\n  } else {\n    rotation *= Uint16Max;\n  }\n  rotation = Math.floor(rotation);\n  _console.log({ formattedRotation: rotation });\n  return rotation;\n}\n\nexport function roundToStep(value: number, step: number) {\n  const roundedValue = Math.floor(value / step) * step;\n  _console.log(value, step, roundedValue);\n  return roundedValue;\n}\n\nexport const maxDisplayBitmapScale = 100;\nexport const displayBitmapScaleStep = 0.002;\nexport function formatBitmapScale(bitmapScale: number) {\n  bitmapScale /= displayBitmapScaleStep;\n  _console.log({ formattedBitmapScale: bitmapScale });\n  return bitmapScale;\n}\nexport function roundBitmapScale(bitmapScale: number) {\n  return roundToStep(bitmapScale, displayBitmapScaleStep);\n}\n\nexport function assertValidSegmentCap(segmentCap: DisplaySegmentCap) {\n  _console.assertEnumWithError(segmentCap, DisplaySegmentCaps);\n}\n\nexport function assertValidDisplayBrightness(\n  displayBrightness: DisplayBrightness\n) {\n  _console.assertEnumWithError(displayBrightness, DisplayBrightnesses);\n}\n\nexport function assertValidColorValue(name: string, value: number) {\n  _console.assertRangeWithError(name, value, 0, 255);\n}\nexport function assertValidColor(color: DisplayColorRGB) {\n  assertValidColorValue(\"red\", color.r);\n  assertValidColorValue(\"green\", color.g);\n  assertValidColorValue(\"blue\", color.b);\n}\n\nexport function assertValidOpacity(value: number) {\n  _console.assertRangeWithError(\"opacity\", value, 0, 1);\n}\n\nexport const DisplayCropDirections = [\n  \"top\",\n  \"right\",\n  \"bottom\",\n  \"left\",\n] as const;\nexport type DisplayCropDirection = (typeof DisplayCropDirections)[number];\n\nexport const DisplayCropDirectionToStateKey: Record<\n  DisplayCropDirection,\n  DisplayContextStateKey\n> = {\n  top: \"cropTop\",\n  right: \"cropRight\",\n  bottom: \"cropBottom\",\n  left: \"cropLeft\",\n};\nexport const DisplayCropDirectionToCommand: Record<\n  DisplayCropDirection,\n  DisplayContextCommand\n> = {\n  top: \"setCropTop\",\n  right: \"setCropRight\",\n  bottom: \"setCropBottom\",\n  left: \"setCropLeft\",\n};\n\nexport const DisplayRotationCropDirectionToStateKey: Record<\n  DisplayCropDirection,\n  DisplayContextStateKey\n> = {\n  top: \"rotationCropTop\",\n  right: \"rotationCropRight\",\n  bottom: \"rotationCropBottom\",\n  left: \"rotationCropLeft\",\n};\nexport const DisplayRotationCropDirectionToCommand: Record<\n  DisplayCropDirection,\n  DisplayContextCommand\n> = {\n  top: \"setRotationCropTop\",\n  right: \"setRotationCropRight\",\n  bottom: \"setRotationCropBottom\",\n  left: \"setRotationCropLeft\",\n};\n\nexport function pixelDepthToNumberOfColors(pixelDepth: DisplayPixelDepth) {\n  return 2 ** Number(pixelDepth);\n}\nexport function pixelDepthToPixelsPerByte(pixelDepth: DisplayPixelDepth) {\n  return 8 / Number(pixelDepth);\n}\nexport function pixelDepthToPixelBitWidth(pixelDepth: DisplayPixelDepth) {\n  return Number(pixelDepth);\n}\nexport function numberOfColorsToPixelDepth(numberOfColors: number) {\n  return DisplayPixelDepths.find(\n    (pixelDepth) => numberOfColors <= pixelDepthToNumberOfColors(pixelDepth)\n  );\n}\n\nexport const DisplayBitmapScaleDirections = [\"x\", \"y\", \"all\"] as const;\nexport type DisplayBitmapScaleDirection =\n  (typeof DisplayBitmapScaleDirections)[number];\nexport const DisplayBitmapScaleDirectionToCommand: Record<\n  DisplayBitmapScaleDirection,\n  DisplayContextCommand\n> = {\n  x: \"setBitmapScaleX\",\n  y: \"setBitmapScaleY\",\n  all: \"setBitmapScale\",\n};\n\nexport type DisplayColorRGB = {\n  r: number;\n  g: number;\n  b: number;\n};\nexport type DisplayColorYCbCr = {\n  y: number;\n  cb: number;\n  cr: number;\n};\n","/*\n* Copyright (c) 2015, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* RgbQuant.js - an image quantization lib\n*/\n\n(function(){\n\tfunction RgbQuant(opts) {\n\t\topts = opts || {};\n\n\t\t// 1 = by global population, 2 = subregion population threshold\n\t\tthis.method = opts.method || 2;\n\t\t// desired final palette size\n\t\tthis.colors = opts.colors || 256;\n\t\t// # of highest-frequency colors to start with for palette reduction\n\t\tthis.initColors = opts.initColors || 4096;\n\t\t// color-distance threshold for initial reduction pass\n\t\tthis.initDist = opts.initDist || 0.01;\n\t\t// subsequent passes threshold\n\t\tthis.distIncr = opts.distIncr || 0.005;\n\t\t// palette grouping\n\t\tthis.hueGroups = opts.hueGroups || 10;\n\t\tthis.satGroups = opts.satGroups || 10;\n\t\tthis.lumGroups = opts.lumGroups || 10;\n\t\t// if > 0, enables hues stats and min-color retention per group\n\t\tthis.minHueCols = opts.minHueCols || 0;\n\t\t// HueStats instance\n\t\tthis.hueStats = this.minHueCols ? new HueStats(this.hueGroups, this.minHueCols) : null;\n\n\t\t// subregion partitioning box size\n\t\tthis.boxSize = opts.boxSize || [64,64];\n\t\t// number of same pixels required within box for histogram inclusion\n\t\tthis.boxPxls = opts.boxPxls || 2;\n\t\t// palette locked indicator\n\t\tthis.palLocked = false;\n\t\t// palette sort order\n//\t\tthis.sortPal = ['hue-','lum-','sat-'];\n\n\t\t// dithering/error diffusion kernel name\n\t\tthis.dithKern = opts.dithKern || null;\n\t\t// dither serpentine pattern\n\t\tthis.dithSerp = opts.dithSerp || false;\n\t\t// minimum color difference (0-1) needed to dither\n\t\tthis.dithDelta = opts.dithDelta || 0;\n\n\t\t// accumulated histogram\n\t\tthis.histogram = {};\n\t\t// palette - rgb triplets\n\t\tthis.idxrgb = opts.palette ? opts.palette.slice(0) : [];\n\t\t// palette - int32 vals\n\t\tthis.idxi32 = [];\n\t\t// reverse lookup {i32:idx}\n\t\tthis.i32idx = {};\n\t\t// {i32:rgb}\n\t\tthis.i32rgb = {};\n\t\t// enable color caching (also incurs overhead of cache misses and cache building)\n\t\tthis.useCache = opts.useCache !== false;\n\t\t// min color occurance count needed to qualify for caching\n\t\tthis.cacheFreq = opts.cacheFreq || 10;\n\t\t// allows pre-defined palettes to be re-indexed (enabling palette compacting and sorting)\n\t\tthis.reIndex = opts.reIndex || this.idxrgb.length == 0;\n\t\t// selection of color-distance equation\n\t\tthis.colorDist = opts.colorDist == \"manhattan\" ? distManhattan : distEuclidean;\n\n\t\t// if pre-defined palette, build lookups\n\t\tif (this.idxrgb.length > 0) {\n\t\t\tvar self = this;\n\t\t\tthis.idxrgb.forEach(function(rgb, i) {\n\t\t\t\tvar i32 = (\n\t\t\t\t\t(255    << 24) |\t// alpha\n\t\t\t\t\t(rgb[2] << 16) |\t// blue\n\t\t\t\t\t(rgb[1] <<  8) |\t// green\n\t\t\t\t\t rgb[0]\t\t\t\t// red\n\t\t\t\t) >>> 0;\n\n\t\t\t\tself.idxi32[i]\t\t= i32;\n\t\t\t\tself.i32idx[i32]\t= i;\n\t\t\t\tself.i32rgb[i32]\t= rgb;\n\t\t\t});\n\t\t}\n\t}\n\n\t// gathers histogram info\n\tRgbQuant.prototype.sample = function sample(img, width) {\n\t\tif (this.palLocked)\n\t\t\tthrow \"Cannot sample additional images, palette already assembled.\";\n\n\t\tvar data = getImageData(img, width);\n\n\t\tswitch (this.method) {\n\t\t\tcase 1: this.colorStats1D(data.buf32); break;\n\t\t\tcase 2: this.colorStats2D(data.buf32, data.width); break;\n\t\t}\n\t};\n\n\t// image quantizer\n\t// todo: memoize colors here also\n\t// @retType: 1 - Uint8Array (default), 2 - Indexed array, 3 - Match @img type (unimplemented, todo)\n\tRgbQuant.prototype.reduce = function reduce(img, retType, dithKern, dithSerp) {\n\t\tif (!this.palLocked)\n\t\t\tthis.buildPal();\n\n\t\tdithKern = dithKern || this.dithKern;\n\t\tdithSerp = typeof dithSerp != \"undefined\" ? dithSerp : this.dithSerp;\n\n\t\tretType = retType || 1;\n\n\t\t// reduce w/dither\n\t\tif (dithKern)\n\t\t\tvar out32 = this.dither(img, dithKern, dithSerp);\n\t\telse {\n\t\t\tvar data = getImageData(img),\n\t\t\t\tbuf32 = data.buf32,\n\t\t\t\tlen = buf32.length,\n\t\t\t\tout32 = new Uint32Array(len);\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar i32 = buf32[i];\n\t\t\t\tout32[i] = this.nearestColor(i32);\n\t\t\t}\n\t\t}\n\n\t\tif (retType == 1)\n\t\t\treturn new Uint8Array(out32.buffer);\n\n\t\tif (retType == 2) {\n\t\t\tvar out = [],\n\t\t\t\tlen = out32.length;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar i32 = out32[i];\n\t\t\t\tout[i] = this.i32idx[i32];\n\t\t\t}\n\n\t\t\treturn out;\n\t\t}\n\t};\n\n\t// adapted from http://jsbin.com/iXofIji/2/edit by PAEz\n\tRgbQuant.prototype.dither = function(img, kernel, serpentine) {\n\t\t// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\n\t\tvar kernels = {\n\t\t\tFloydSteinberg: [\n\t\t\t\t[7 / 16, 1, 0],\n\t\t\t\t[3 / 16, -1, 1],\n\t\t\t\t[5 / 16, 0, 1],\n\t\t\t\t[1 / 16, 1, 1]\n\t\t\t],\n\t\t\tFalseFloydSteinberg: [\n\t\t\t\t[3 / 8, 1, 0],\n\t\t\t\t[3 / 8, 0, 1],\n\t\t\t\t[2 / 8, 1, 1]\n\t\t\t],\n\t\t\tStucki: [\n\t\t\t\t[8 / 42, 1, 0],\n\t\t\t\t[4 / 42, 2, 0],\n\t\t\t\t[2 / 42, -2, 1],\n\t\t\t\t[4 / 42, -1, 1],\n\t\t\t\t[8 / 42, 0, 1],\n\t\t\t\t[4 / 42, 1, 1],\n\t\t\t\t[2 / 42, 2, 1],\n\t\t\t\t[1 / 42, -2, 2],\n\t\t\t\t[2 / 42, -1, 2],\n\t\t\t\t[4 / 42, 0, 2],\n\t\t\t\t[2 / 42, 1, 2],\n\t\t\t\t[1 / 42, 2, 2]\n\t\t\t],\n\t\t\tAtkinson: [\n\t\t\t\t[1 / 8, 1, 0],\n\t\t\t\t[1 / 8, 2, 0],\n\t\t\t\t[1 / 8, -1, 1],\n\t\t\t\t[1 / 8, 0, 1],\n\t\t\t\t[1 / 8, 1, 1],\n\t\t\t\t[1 / 8, 0, 2]\n\t\t\t],\n\t\t\tJarvis: [\t\t\t// Jarvis, Judice, and Ninke / JJN?\n\t\t\t\t[7 / 48, 1, 0],\n\t\t\t\t[5 / 48, 2, 0],\n\t\t\t\t[3 / 48, -2, 1],\n\t\t\t\t[5 / 48, -1, 1],\n\t\t\t\t[7 / 48, 0, 1],\n\t\t\t\t[5 / 48, 1, 1],\n\t\t\t\t[3 / 48, 2, 1],\n\t\t\t\t[1 / 48, -2, 2],\n\t\t\t\t[3 / 48, -1, 2],\n\t\t\t\t[5 / 48, 0, 2],\n\t\t\t\t[3 / 48, 1, 2],\n\t\t\t\t[1 / 48, 2, 2]\n\t\t\t],\n\t\t\tBurkes: [\n\t\t\t\t[8 / 32, 1, 0],\n\t\t\t\t[4 / 32, 2, 0],\n\t\t\t\t[2 / 32, -2, 1],\n\t\t\t\t[4 / 32, -1, 1],\n\t\t\t\t[8 / 32, 0, 1],\n\t\t\t\t[4 / 32, 1, 1],\n\t\t\t\t[2 / 32, 2, 1],\n\t\t\t],\n\t\t\tSierra: [\n\t\t\t\t[5 / 32, 1, 0],\n\t\t\t\t[3 / 32, 2, 0],\n\t\t\t\t[2 / 32, -2, 1],\n\t\t\t\t[4 / 32, -1, 1],\n\t\t\t\t[5 / 32, 0, 1],\n\t\t\t\t[4 / 32, 1, 1],\n\t\t\t\t[2 / 32, 2, 1],\n\t\t\t\t[2 / 32, -1, 2],\n\t\t\t\t[3 / 32, 0, 2],\n\t\t\t\t[2 / 32, 1, 2],\n\t\t\t],\n\t\t\tTwoSierra: [\n\t\t\t\t[4 / 16, 1, 0],\n\t\t\t\t[3 / 16, 2, 0],\n\t\t\t\t[1 / 16, -2, 1],\n\t\t\t\t[2 / 16, -1, 1],\n\t\t\t\t[3 / 16, 0, 1],\n\t\t\t\t[2 / 16, 1, 1],\n\t\t\t\t[1 / 16, 2, 1],\n\t\t\t],\n\t\t\tSierraLite: [\n\t\t\t\t[2 / 4, 1, 0],\n\t\t\t\t[1 / 4, -1, 1],\n\t\t\t\t[1 / 4, 0, 1],\n\t\t\t],\n\t\t};\n\n\t\tif (!kernel || !kernels[kernel]) {\n\t\t\tthrow 'Unknown dithering kernel: ' + kernel;\n\t\t}\n\n\t\tvar ds = kernels[kernel];\n\n\t\tvar data = getImageData(img),\n//\t\t\tbuf8 = data.buf8,\n\t\t\tbuf32 = data.buf32,\n\t\t\twidth = data.width,\n\t\t\theight = data.height,\n\t\t\tlen = buf32.length;\n\n\t\tvar dir = serpentine ? -1 : 1;\n\n\t\tfor (var y = 0; y < height; y++) {\n\t\t\tif (serpentine)\n\t\t\t\tdir = dir * -1;\n\n\t\t\tvar lni = y * width;\n\n\t\t\tfor (var x = (dir == 1 ? 0 : width - 1), xend = (dir == 1 ? width : 0); x !== xend; x += dir) {\n\t\t\t\t// Image pixel\n\t\t\t\tvar idx = lni + x,\n\t\t\t\t\ti32 = buf32[idx],\n\t\t\t\t\tr1 = (i32 & 0xff),\n\t\t\t\t\tg1 = (i32 & 0xff00) >> 8,\n\t\t\t\t\tb1 = (i32 & 0xff0000) >> 16;\n\n\t\t\t\t// Reduced pixel\n\t\t\t\tvar i32x = this.nearestColor(i32),\n\t\t\t\t\tr2 = (i32x & 0xff),\n\t\t\t\t\tg2 = (i32x & 0xff00) >> 8,\n\t\t\t\t\tb2 = (i32x & 0xff0000) >> 16;\n\n\t\t\t\tbuf32[idx] =\n\t\t\t\t\t(255 << 24)\t|\t// alpha\n\t\t\t\t\t(b2  << 16)\t|\t// blue\n\t\t\t\t\t(g2  <<  8)\t|\t// green\n\t\t\t\t\t r2;\n\n\t\t\t\t// dithering strength\n\t\t\t\tif (this.dithDelta) {\n\t\t\t\t\tvar dist = this.colorDist([r1, g1, b1], [r2, g2, b2]);\n\t\t\t\t\tif (dist < this.dithDelta)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Component distance\n\t\t\t\tvar er = r1 - r2,\n\t\t\t\t\teg = g1 - g2,\n\t\t\t\t\teb = b1 - b2;\n\n\t\t\t\tfor (var i = (dir == 1 ? 0 : ds.length - 1), end = (dir == 1 ? ds.length : 0); i !== end; i += dir) {\n\t\t\t\t\tvar x1 = ds[i][1] * dir,\n\t\t\t\t\t\ty1 = ds[i][2];\n\n\t\t\t\t\tvar lni2 = y1 * width;\n\n\t\t\t\t\tif (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n\t\t\t\t\t\tvar d = ds[i][0];\n\t\t\t\t\t\tvar idx2 = idx + (lni2 + x1);\n\n\t\t\t\t\t\tvar r3 = (buf32[idx2] & 0xff),\n\t\t\t\t\t\t\tg3 = (buf32[idx2] & 0xff00) >> 8,\n\t\t\t\t\t\t\tb3 = (buf32[idx2] & 0xff0000) >> 16;\n\n\t\t\t\t\t\tvar r4 = Math.max(0, Math.min(255, r3 + er * d)),\n\t\t\t\t\t\t\tg4 = Math.max(0, Math.min(255, g3 + eg * d)),\n\t\t\t\t\t\t\tb4 = Math.max(0, Math.min(255, b3 + eb * d));\n\n\t\t\t\t\t\tbuf32[idx2] =\n\t\t\t\t\t\t\t(255 << 24)\t|\t// alpha\n\t\t\t\t\t\t\t(b4  << 16)\t|\t// blue\n\t\t\t\t\t\t\t(g4  <<  8)\t|\t// green\n\t\t\t\t\t\t\t r4;\t\t\t// red\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn buf32;\n\t};\n\n\t// reduces histogram to palette, remaps & memoizes reduced colors\n\tRgbQuant.prototype.buildPal = function buildPal(noSort) {\n\t\tif (this.palLocked || this.idxrgb.length > 0 && this.idxrgb.length <= this.colors) return;\n\n\t\tvar histG  = this.histogram,\n\t\t\tsorted = sortedHashKeys(histG, true);\n\n\t\tif (sorted.length == 0)\n\t\t\tthrow \"Nothing has been sampled, palette cannot be built.\";\n\n\t\tswitch (this.method) {\n\t\t\tcase 1:\n\t\t\t\tvar cols = this.initColors,\n\t\t\t\t\tlast = sorted[cols - 1],\n\t\t\t\t\tfreq = histG[last];\n\n\t\t\t\tvar idxi32 = sorted.slice(0, cols);\n\n\t\t\t\t// add any cut off colors with same freq as last\n\t\t\t\tvar pos = cols, len = sorted.length;\n\t\t\t\twhile (pos < len && histG[sorted[pos]] == freq)\n\t\t\t\t\tidxi32.push(sorted[pos++]);\n\n\t\t\t\t// inject min huegroup colors\n\t\t\t\tif (this.hueStats)\n\t\t\t\t\tthis.hueStats.inject(idxi32);\n\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tvar idxi32 = sorted;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// int32-ify values\n\t\tidxi32 = idxi32.map(function(v){return +v;});\n\n\t\tthis.reducePal(idxi32);\n\n\t\tif (!noSort && this.reIndex)\n\t\t\tthis.sortPal();\n\n\t\t// build cache of top histogram colors\n\t\tif (this.useCache)\n\t\t\tthis.cacheHistogram(idxi32);\n\n\t\tthis.palLocked = true;\n\t};\n\n\tRgbQuant.prototype.palette = function palette(tuples, noSort) {\n\t\tthis.buildPal(noSort);\n\t\treturn tuples ? this.idxrgb : new Uint8Array((new Uint32Array(this.idxi32)).buffer);\n\t};\n\n\tRgbQuant.prototype.prunePal = function prunePal(keep) {\n\t\tvar i32;\n\n\t\tfor (var j = 0; j < this.idxrgb.length; j++) {\n\t\t\tif (!keep[j]) {\n\t\t\t\ti32 = this.idxi32[j];\n\t\t\t\tthis.idxrgb[j] = null;\n\t\t\t\tthis.idxi32[j] = null;\n\t\t\t\tdelete this.i32idx[i32];\n\t\t\t}\n\t\t}\n\n\t\t// compact\n\t\tif (this.reIndex) {\n\t\t\tvar idxrgb = [],\n\t\t\t\tidxi32 = [],\n\t\t\t\ti32idx = {};\n\n\t\t\tfor (var j = 0, i = 0; j < this.idxrgb.length; j++) {\n\t\t\t\tif (this.idxrgb[j]) {\n\t\t\t\t\ti32 = this.idxi32[j];\n\t\t\t\t\tidxrgb[i] = this.idxrgb[j];\n\t\t\t\t\ti32idx[i32] = i;\n\t\t\t\t\tidxi32[i] = i32;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.idxrgb = idxrgb;\n\t\t\tthis.idxi32 = idxi32;\n\t\t\tthis.i32idx = i32idx;\n\t\t}\n\t};\n\n\t// reduces similar colors from an importance-sorted Uint32 rgba array\n\tRgbQuant.prototype.reducePal = function reducePal(idxi32) {\n\t\t// if pre-defined palette's length exceeds target\n\t\tif (this.idxrgb.length > this.colors) {\n\t\t\t// quantize histogram to existing palette\n\t\t\tvar len = idxi32.length, keep = {}, uniques = 0, idx, pruned = false;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\t// palette length reached, unset all remaining colors (sparse palette)\n\t\t\t\tif (uniques == this.colors && !pruned) {\n\t\t\t\t\tthis.prunePal(keep);\n\t\t\t\t\tpruned = true;\n\t\t\t\t}\n\n\t\t\t\tidx = this.nearestIndex(idxi32[i]);\n\n\t\t\t\tif (uniques < this.colors && !keep[idx]) {\n\t\t\t\t\tkeep[idx] = true;\n\t\t\t\t\tuniques++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pruned) {\n\t\t\t\tthis.prunePal(keep);\n\t\t\t\tpruned = true;\n\t\t\t}\n\t\t}\n\t\t// reduce histogram to create initial palette\n\t\telse {\n\t\t\t// build full rgb palette\n\t\t\tvar idxrgb = idxi32.map(function(i32) {\n\t\t\t\treturn [\n\t\t\t\t\t(i32 & 0xff),\n\t\t\t\t\t(i32 & 0xff00) >> 8,\n\t\t\t\t\t(i32 & 0xff0000) >> 16,\n\t\t\t\t];\n\t\t\t});\n\n\t\t\tvar len = idxrgb.length,\n\t\t\t\tpalLen = len,\n\t\t\t\tthold = this.initDist;\n\n\t\t\t// palette already at or below desired length\n\t\t\tif (palLen > this.colors) {\n\t\t\t\twhile (palLen > this.colors) {\n\t\t\t\t\tvar memDist = [];\n\n\t\t\t\t\t// iterate palette\n\t\t\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\t\t\tvar pxi = idxrgb[i], i32i = idxi32[i];\n\t\t\t\t\t\tif (!pxi) continue;\n\n\t\t\t\t\t\tfor (var j = i + 1; j < len; j++) {\n\t\t\t\t\t\t\tvar pxj = idxrgb[j], i32j = idxi32[j];\n\t\t\t\t\t\t\tif (!pxj) continue;\n\n\t\t\t\t\t\t\tvar dist = this.colorDist(pxi, pxj);\n\n\t\t\t\t\t\t\tif (dist < thold) {\n\t\t\t\t\t\t\t\t// store index,rgb,dist\n\t\t\t\t\t\t\t\tmemDist.push([j, pxj, i32j, dist]);\n\n\t\t\t\t\t\t\t\t// kill squashed value\n\t\t\t\t\t\t\t\tdelete(idxrgb[j]);\n\t\t\t\t\t\t\t\tpalLen--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// palette reduction pass\n\t\t\t\t\t// console.log(\"palette length: \" + palLen);\n\n\t\t\t\t\t// if palette is still much larger than target, increment by larger initDist\n\t\t\t\t\tthold += (palLen > this.colors * 3) ? this.initDist : this.distIncr;\n\t\t\t\t}\n\n\t\t\t\t// if palette is over-reduced, re-add removed colors with largest distances from last round\n\t\t\t\tif (palLen < this.colors) {\n\t\t\t\t\t// sort descending\n\t\t\t\t\tsort.call(memDist, function(a,b) {\n\t\t\t\t\t\treturn b[3] - a[3];\n\t\t\t\t\t});\n\n\t\t\t\t\tvar k = 0;\n\t\t\t\t\twhile (palLen < this.colors) {\n\t\t\t\t\t\t// re-inject rgb into final palette\n\t\t\t\t\t\tidxrgb[memDist[k][0]] = memDist[k][1];\n\n\t\t\t\t\t\tpalLen++;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar len = idxrgb.length;\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tif (!idxrgb[i]) continue;\n\n\t\t\t\tthis.idxrgb.push(idxrgb[i]);\n\t\t\t\tthis.idxi32.push(idxi32[i]);\n\n\t\t\t\tthis.i32idx[idxi32[i]] = this.idxi32.length - 1;\n\t\t\t\tthis.i32rgb[idxi32[i]] = idxrgb[i];\n\t\t\t}\n\t\t}\n\t};\n\n\t// global top-population\n\tRgbQuant.prototype.colorStats1D = function colorStats1D(buf32) {\n\t\tvar histG = this.histogram,\n\t\t\tnum = 0, col,\n\t\t\tlen = buf32.length;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tcol = buf32[i];\n\n\t\t\t// skip transparent\n\t\t\tif ((col & 0xff000000) >> 24 == 0) continue;\n\n\t\t\t// collect hue stats\n\t\t\tif (this.hueStats)\n\t\t\t\tthis.hueStats.check(col);\n\n\t\t\tif (col in histG)\n\t\t\t\thistG[col]++;\n\t\t\telse\n\t\t\t\thistG[col] = 1;\n\t\t}\n\t};\n\n\t// population threshold within subregions\n\t// FIXME: this can over-reduce (few/no colors same?), need a way to keep\n\t// important colors that dont ever reach local thresholds (gradients?)\n\tRgbQuant.prototype.colorStats2D = function colorStats2D(buf32, width) {\n\t\tvar boxW = this.boxSize[0],\n\t\t\tboxH = this.boxSize[1],\n\t\t\tarea = boxW * boxH,\n\t\t\tboxes = makeBoxes(width, buf32.length / width, boxW, boxH),\n\t\t\thistG = this.histogram,\n\t\t\tself = this;\n\n\t\tboxes.forEach(function(box) {\n\t\t\tvar effc = Math.max(Math.round((box.w * box.h) / area) * self.boxPxls, 2),\n\t\t\t\thistL = {}, col;\n\n\t\t\titerBox(box, width, function(i) {\n\t\t\t\tcol = buf32[i];\n\n\t\t\t\t// skip transparent\n\t\t\t\tif ((col & 0xff000000) >> 24 == 0) return;\n\n\t\t\t\t// collect hue stats\n\t\t\t\tif (self.hueStats)\n\t\t\t\t\tself.hueStats.check(col);\n\n\t\t\t\tif (col in histG)\n\t\t\t\t\thistG[col]++;\n\t\t\t\telse if (col in histL) {\n\t\t\t\t\tif (++histL[col] >= effc)\n\t\t\t\t\t\thistG[col] = histL[col];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thistL[col] = 1;\n\t\t\t});\n\t\t});\n\n\t\tif (this.hueStats)\n\t\t\tthis.hueStats.inject(histG);\n\t};\n\n\t// TODO: group very low lum and very high lum colors\n\t// TODO: pass custom sort order\n\tRgbQuant.prototype.sortPal = function sortPal() {\n\t\tvar self = this;\n\n\t\tthis.idxi32.sort(function(a,b) {\n\t\t\tvar idxA = self.i32idx[a],\n\t\t\t\tidxB = self.i32idx[b],\n\t\t\t\trgbA = self.idxrgb[idxA],\n\t\t\t\trgbB = self.idxrgb[idxB];\n\n\t\t\tvar hslA = rgb2hsl(rgbA[0],rgbA[1],rgbA[2]),\n\t\t\t\thslB = rgb2hsl(rgbB[0],rgbB[1],rgbB[2]);\n\n\t\t\t// sort all grays + whites together\n\t\t\tvar hueA = (rgbA[0] == rgbA[1] && rgbA[1] == rgbA[2]) ? -1 : hueGroup(hslA.h, self.hueGroups);\n\t\t\tvar hueB = (rgbB[0] == rgbB[1] && rgbB[1] == rgbB[2]) ? -1 : hueGroup(hslB.h, self.hueGroups);\n\n\t\t\tvar hueDiff = hueB - hueA;\n\t\t\tif (hueDiff) return -hueDiff;\n\n\t\t\tvar lumDiff = lumGroup(+hslB.l.toFixed(2)) - lumGroup(+hslA.l.toFixed(2));\n\t\t\tif (lumDiff) return -lumDiff;\n\n\t\t\tvar satDiff = satGroup(+hslB.s.toFixed(2)) - satGroup(+hslA.s.toFixed(2));\n\t\t\tif (satDiff) return -satDiff;\n\t\t});\n\n\t\t// sync idxrgb & i32idx\n\t\tthis.idxi32.forEach(function(i32, i) {\n\t\t\tself.idxrgb[i] = self.i32rgb[i32];\n\t\t\tself.i32idx[i32] = i;\n\t\t});\n\t};\n\n\t// TOTRY: use HUSL - http://boronine.com/husl/\n\tRgbQuant.prototype.nearestColor = function nearestColor(i32) {\n\t\tvar idx = this.nearestIndex(i32);\n\t\treturn idx === null ? 0 : this.idxi32[idx];\n\t};\n\n\t// TOTRY: use HUSL - http://boronine.com/husl/\n\tRgbQuant.prototype.nearestIndex = function nearestIndex(i32) {\n\t\t// alpha 0 returns null index\n\t\tif ((i32 & 0xff000000) >> 24 == 0)\n\t\t\treturn null;\n\n\t\tif (this.useCache && (\"\"+i32) in this.i32idx)\n\t\t\treturn this.i32idx[i32];\n\n\t\tvar min = 1000,\n\t\t\tidx,\n\t\t\trgb = [\n\t\t\t\t(i32 & 0xff),\n\t\t\t\t(i32 & 0xff00) >> 8,\n\t\t\t\t(i32 & 0xff0000) >> 16,\n\t\t\t],\n\t\t\tlen = this.idxrgb.length;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tif (!this.idxrgb[i]) continue;\t\t// sparse palettes\n\n\t\t\tvar dist = this.colorDist(rgb, this.idxrgb[i]);\n\n\t\t\tif (dist < min) {\n\t\t\t\tmin = dist;\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t}\n\n\t\treturn idx;\n\t};\n\n\tRgbQuant.prototype.cacheHistogram = function cacheHistogram(idxi32) {\n\t\tfor (var i = 0, i32 = idxi32[i]; i < idxi32.length && this.histogram[i32] >= this.cacheFreq; i32 = idxi32[i++])\n\t\t\tthis.i32idx[i32] = this.nearestIndex(i32);\n\t};\n\n\tfunction HueStats(numGroups, minCols) {\n\t\tthis.numGroups = numGroups;\n\t\tthis.minCols = minCols;\n\t\tthis.stats = {};\n\n\t\tfor (var i = -1; i < numGroups; i++)\n\t\t\tthis.stats[i] = {num: 0, cols: []};\n\n\t\tthis.groupsFull = 0;\n\t}\n\n\tHueStats.prototype.check = function checkHue(i32) {\n\t\tif (this.groupsFull == this.numGroups + 1)\n\t\t\tthis.check = function() {return;};\n\n\t\tvar r = (i32 & 0xff),\n\t\t\tg = (i32 & 0xff00) >> 8,\n\t\t\tb = (i32 & 0xff0000) >> 16,\n\t\t\thg = (r == g && g == b) ? -1 : hueGroup(rgb2hsl(r,g,b).h, this.numGroups),\n\t\t\tgr = this.stats[hg],\n\t\t\tmin = this.minCols;\n\n\t\tgr.num++;\n\n\t\tif (gr.num > min)\n\t\t\treturn;\n\t\tif (gr.num == min)\n\t\t\tthis.groupsFull++;\n\n\t\tif (gr.num <= min)\n\t\t\tthis.stats[hg].cols.push(i32);\n\t};\n\n\tHueStats.prototype.inject = function injectHues(histG) {\n\t\tfor (var i = -1; i < this.numGroups; i++) {\n\t\t\tif (this.stats[i].num <= this.minCols) {\n\t\t\t\tswitch (typeOf(histG)) {\n\t\t\t\t\tcase \"Array\":\n\t\t\t\t\t\tthis.stats[i].cols.forEach(function(col){\n\t\t\t\t\t\t\tif (histG.indexOf(col) == -1)\n\t\t\t\t\t\t\t\thistG.push(col);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"Object\":\n\t\t\t\t\t\tthis.stats[i].cols.forEach(function(col){\n\t\t\t\t\t\t\tif (!histG[col])\n\t\t\t\t\t\t\t\thistG[col] = 1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\thistG[col]++;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Rec. 709 (sRGB) luma coef\n\tvar Pr = .2126,\n\t\tPg = .7152,\n\t\tPb = .0722;\n\n\t// http://alienryderflex.com/hsp.html\n\tfunction rgb2lum(r,g,b) {\n\t\treturn Math.sqrt(\n\t\t\tPr * r*r +\n\t\t\tPg * g*g +\n\t\t\tPb * b*b\n\t\t);\n\t}\n\n\tvar rd = 255,\n\t\tgd = 255,\n\t\tbd = 255;\n\n\tvar euclMax = Math.sqrt(Pr*rd*rd + Pg*gd*gd + Pb*bd*bd);\n\t// perceptual Euclidean color distance\n\tfunction distEuclidean(rgb0, rgb1) {\n\t\tvar rd = rgb1[0]-rgb0[0],\n\t\t\tgd = rgb1[1]-rgb0[1],\n\t\t\tbd = rgb1[2]-rgb0[2];\n\n\t\treturn Math.sqrt(Pr*rd*rd + Pg*gd*gd + Pb*bd*bd) / euclMax;\n\t}\n\n\tvar manhMax = Pr*rd + Pg*gd + Pb*bd;\n\t// perceptual Manhattan color distance\n\tfunction distManhattan(rgb0, rgb1) {\n\t\tvar rd = Math.abs(rgb1[0]-rgb0[0]),\n\t\t\tgd = Math.abs(rgb1[1]-rgb0[1]),\n\t\t\tbd = Math.abs(rgb1[2]-rgb0[2]);\n\n\t\treturn (Pr*rd + Pg*gd + Pb*bd) / manhMax;\n\t}\n\n\t// http://rgb2hsl.nichabi.com/javascript-function.php\n\tfunction rgb2hsl(r, g, b) {\n\t\tvar max, min, h, s, l, d;\n\t\tr /= 255;\n\t\tg /= 255;\n\t\tb /= 255;\n\t\tmax = Math.max(r, g, b);\n\t\tmin = Math.min(r, g, b);\n\t\tl = (max + min) / 2;\n\t\tif (max == min) {\n\t\t\th = s = 0;\n\t\t} else {\n\t\t\td = max - min;\n\t\t\ts = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\t\t\tswitch (max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g:\th = (b - r) / d + 2; break;\n\t\t\t\tcase b:\th = (r - g) / d + 4; break\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n//\t\th = Math.floor(h * 360)\n//\t\ts = Math.floor(s * 100)\n//\t\tl = Math.floor(l * 100)\n\t\treturn {\n\t\t\th: h,\n\t\t\ts: s,\n\t\t\tl: rgb2lum(r,g,b),\n\t\t};\n\t}\n\n\tfunction hueGroup(hue, segs) {\n\t\tvar seg = 1/segs,\n\t\t\thaf = seg/2;\n\n\t\tif (hue >= 1 - haf || hue <= haf)\n\t\t\treturn 0;\n\n\t\tfor (var i = 1; i < segs; i++) {\n\t\t\tvar mid = i*seg;\n\t\t\tif (hue >= mid - haf && hue <= mid + haf)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\tfunction satGroup(sat) {\n\t\treturn sat;\n\t}\n\n\tfunction lumGroup(lum) {\n\t\treturn lum;\n\t}\n\n\tfunction typeOf(val) {\n\t\treturn Object.prototype.toString.call(val).slice(8,-1);\n\t}\n\n\tvar sort = isArrSortStable() ? Array.prototype.sort : stableSort;\n\n\t// must be used via stableSort.call(arr, fn)\n\tfunction stableSort(fn) {\n\t\tvar type = typeOf(this[0]);\n\n\t\tif (type == \"Number\" || type == \"String\") {\n\t\t\tvar ord = {}, len = this.length, val;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tval = this[i];\n\t\t\t\tif (ord[val] || ord[val] === 0) continue;\n\t\t\t\tord[val] = i;\n\t\t\t}\n\n\t\t\treturn this.sort(function(a,b) {\n\t\t\t\treturn fn(a,b) || ord[a] - ord[b];\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tvar ord = this.map(function(v){return v});\n\n\t\t\treturn this.sort(function(a,b) {\n\t\t\t\treturn fn(a,b) || ord.indexOf(a) - ord.indexOf(b);\n\t\t\t});\n\t\t}\n\t}\n\n\t// test if js engine's Array#sort implementation is stable\n\tfunction isArrSortStable() {\n\t\tvar str = \"abcdefghijklmnopqrstuvwxyz\";\n\n\t\treturn \"xyzvwtursopqmnklhijfgdeabc\" == str.split(\"\").sort(function(a,b) {\n\t\t\treturn ~~(str.indexOf(b)/2.3) - ~~(str.indexOf(a)/2.3);\n\t\t}).join(\"\");\n\t}\n\n\t// returns uniform pixel data from various img\n\t// TODO?: if array is passed, createimagedata, createlement canvas? take a pxlen?\n\tfunction getImageData(img, width) {\n\t\tvar can, ctx, imgd, buf8, buf32, height;\n\n\t\tswitch (typeOf(img)) {\n\t\t\tcase \"HTMLImageElement\":\n\t\t\t\tcan = document.createElement(\"canvas\");\n\t\t\t\tcan.width = img.naturalWidth;\n\t\t\t\tcan.height = img.naturalHeight;\n\t\t\t\tctx = can.getContext(\"2d\");\n\t\t\t\tctx.drawImage(img,0,0);\n\t\t\tcase \"Canvas\":\n\t\t\tcase \"HTMLCanvasElement\":\n\t\t\t\tcan = can || img;\n\t\t\t\tctx = ctx || can.getContext(\"2d\");\n\t\t\tcase \"CanvasRenderingContext2D\":\n\t\t\t\tctx = ctx || img;\n\t\t\t\tcan = can || ctx.canvas;\n\t\t\t\timgd = ctx.getImageData(0, 0, can.width, can.height);\n\t\t\tcase \"ImageData\":\n\t\t\t\timgd = imgd || img;\n\t\t\t\twidth = imgd.width;\n\t\t\t\tif (typeOf(imgd.data) == \"CanvasPixelArray\")\n\t\t\t\t\tbuf8 = new Uint8Array(imgd.data);\n\t\t\t\telse\n\t\t\t\t\tbuf8 = imgd.data;\n\t\t\tcase \"Array\":\n\t\t\tcase \"CanvasPixelArray\":\n\t\t\t\tbuf8 = buf8 || new Uint8Array(img);\n\t\t\tcase \"Uint8Array\":\n\t\t\tcase \"Uint8ClampedArray\":\n\t\t\t\tbuf8 = buf8 || img;\n\t\t\t\tbuf32 = new Uint32Array(buf8.buffer);\n\t\t\tcase \"Uint32Array\":\n\t\t\t\tbuf32 = buf32 || img;\n\t\t\t\tbuf8 = buf8 || new Uint8Array(buf32.buffer);\n\t\t\t\twidth = width || buf32.length;\n\t\t\t\theight = buf32.length / width;\n\t\t}\n\n\t\treturn {\n\t\t\tcan: can,\n\t\t\tctx: ctx,\n\t\t\timgd: imgd,\n\t\t\tbuf8: buf8,\n\t\t\tbuf32: buf32,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t};\n\t}\n\n\t// partitions a rect of wid x hgt into\n\t// array of bboxes of w0 x h0 (or less)\n\tfunction makeBoxes(wid, hgt, w0, h0) {\n\t\tvar wnum = ~~(wid/w0), wrem = wid%w0,\n\t\t\thnum = ~~(hgt/h0), hrem = hgt%h0,\n\t\t\txend = wid-wrem, yend = hgt-hrem;\n\n\t\tvar bxs = [];\n\t\tfor (var y = 0; y < hgt; y += h0)\n\t\t\tfor (var x = 0; x < wid; x += w0)\n\t\t\t\tbxs.push({x:x, y:y, w:(x==xend?wrem:w0), h:(y==yend?hrem:h0)});\n\n\t\treturn bxs;\n\t}\n\n\t// iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\n\tfunction iterBox(bbox, wid, fn) {\n\t\tvar b = bbox,\n\t\t\ti0 = b.y * wid + b.x,\n\t\t\ti1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1),\n\t\t\tcnt = 0, incr = wid - b.w + 1, i = i0;\n\n\t\tdo {\n\t\t\tfn.call(this, i);\n\t\t\ti += (++cnt % b.w == 0) ? incr : 1;\n\t\t} while (i <= i1);\n\t}\n\n\t// returns array of hash keys sorted by their values\n\tfunction sortedHashKeys(obj, desc) {\n\t\tvar keys = [];\n\n\t\tfor (var key in obj)\n\t\t\tkeys.push(key);\n\n\t\treturn sort.call(keys, function(a,b) {\n\t\t\treturn desc ? obj[b] - obj[a] : obj[a] - obj[b];\n\t\t});\n\t}\n\n\t// expose\n\tthis.RgbQuant = RgbQuant;\n\n\t// expose to commonJS\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = RgbQuant;\n\t}\n\n}).call(this);","import RGBQuant from \"rgbquant\";\nimport { createConsole } from \"./Console.ts\";\nimport { hexToRGB, rgbToHex } from \"./ColorUtils.ts\";\nimport {\n  DisplayBitmap,\n  DisplayColorRGB,\n  DisplayContextState,\n} from \"../DisplayManager.ts\";\nimport { getVector3Length, Vector3 } from \"./MathUtils.ts\";\nimport {\n  numberOfColorsToPixelDepth,\n  pixelDepthToPixelsPerByte,\n} from \"./DisplayUtils.ts\";\n\nconst _console = createConsole(\"BitmapUtils\", { log: true });\n\nexport async function quantizeImage(\n  image: HTMLImageElement,\n  width: number,\n  height: number,\n  numberOfColors: number\n) {\n  _console.assertWithError(\n    numberOfColors > 1,\n    \"numberOfColors must be greater than 1\"\n  );\n\n  _console.log({ numberOfColors });\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\")!;\n\n  let { naturalWidth: imageWidth, naturalHeight: imageHeight } = image;\n  _console.log({ imageWidth, imageHeight });\n\n  canvas.width = width;\n  canvas.height = height;\n\n  ctx.imageSmoothingEnabled = false;\n\n  ctx.drawImage(image, 0, 0, width, height);\n\n  const imageData = ctx.getImageData(0, 0, width, height);\n  const data = imageData.data;\n\n  // turn any non-opaque pixel to black\n  for (let i = 0; i < data.length; i += 4) {\n    const alpha = data[i + 3];\n\n    if (alpha < 255) {\n      data[i] = 0;\n      data[i + 1] = 0;\n      data[i + 2] = 0;\n      data[i + 3] = 255;\n    }\n  }\n\n  ctx.putImageData(imageData, 0, 0);\n\n  const quantOptions = {\n    method: 0,\n    colors: numberOfColors,\n    dithKern: null, // Disable dithering\n    useCache: false, // Disable color caching to force exact matches\n    reIndex: true, // Ensure strict re-indexing to the palette\n    orDist: \"manhattan\",\n  };\n  _console.log(\"quantOptions\", quantOptions);\n\n  _console.log(\"quantizeImage options\", quantOptions);\n  const quantizer = new RGBQuant(quantOptions);\n  quantizer.sample(imageData);\n\n  const quantizedPixels = quantizer.reduce(imageData.data);\n  const quantizedImageData = new ImageData(\n    new Uint8ClampedArray(quantizedPixels.buffer),\n    width,\n    height\n  );\n  ctx.putImageData(quantizedImageData, 0, 0);\n\n  const pixels = quantizedImageData.data;\n\n  const quantizedPaletteData: Uint8Array = quantizer.palette();\n  const numberOfQuantizedPaletteColors = quantizedPaletteData.byteLength / 4;\n  _console.log(\"quantized palette data\", quantizedPaletteData);\n  const quantizedPaletteColors: DisplayColorRGB[] = [];\n  let closestColorIndexToBlack = 0;\n  let closestColorDistanceToBlack = Infinity;\n  const vector3: Vector3 = { x: 0, y: 0, z: 0 };\n  for (\n    let colorIndex = 0;\n    colorIndex < numberOfQuantizedPaletteColors;\n    colorIndex++\n  ) {\n    const rgb: DisplayColorRGB = {\n      r: quantizedPaletteData[colorIndex * 4],\n      g: quantizedPaletteData[colorIndex * 4 + 1],\n      b: quantizedPaletteData[colorIndex * 4 + 2],\n    };\n    quantizedPaletteColors.push(rgb);\n    vector3.x = rgb.r;\n    vector3.y = rgb.g;\n    vector3.z = rgb.b;\n\n    const distanceToBlack = getVector3Length(vector3);\n    if (distanceToBlack < closestColorDistanceToBlack) {\n      closestColorDistanceToBlack = distanceToBlack;\n      closestColorIndexToBlack = colorIndex;\n    }\n  }\n  _console.log({ closestColorIndexToBlack, closestColorDistanceToBlack });\n  if (closestColorIndexToBlack != 0) {\n    const [currentBlack, newBlack] = [\n      quantizedPaletteColors[0],\n      quantizedPaletteColors[closestColorIndexToBlack],\n    ];\n    quantizedPaletteColors[0] = newBlack;\n    quantizedPaletteColors[closestColorIndexToBlack] = currentBlack;\n  }\n  _console.log(\"quantizedPaletteColors\", quantizedPaletteColors);\n  const quantizedColors = quantizedPaletteColors.map((rgb, index) => {\n    const hex = rgbToHex(rgb);\n    return hex;\n  });\n  _console.log(\"quantizedColors\", quantizedColors);\n\n  const quantizedColorIndices: number[] = [];\n  for (let i = 0; i < pixels.length; i += 4) {\n    const r = pixels[i];\n    const g = pixels[i + 1];\n    const b = pixels[i + 2];\n    const a = pixels[i + 3];\n\n    const hex = rgbToHex({ r, g, b });\n    quantizedColorIndices.push(quantizedColors.indexOf(hex));\n  }\n  _console.log(\"quantizedColorIndices\", quantizedColorIndices);\n\n  const promise = new Promise<Blob>((resolve, reject) => {\n    canvas.toBlob((blob) => {\n      if (blob) {\n        resolve(blob);\n      } else {\n        reject();\n      }\n    }, \"image/png\");\n  });\n\n  const blob = await promise;\n  return {\n    blob,\n    colors: quantizedColors,\n    colorIndices: quantizedColorIndices,\n  };\n}\n\nexport async function resizeAndQuantizeImage(\n  image: HTMLImageElement,\n  width: number,\n  height: number,\n  colors: string[]\n) {\n  _console.assertWithError(\n    colors.length > 1,\n    \"colors.length must be greater than 1\"\n  );\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\")!;\n\n  let { naturalWidth: imageWidth, naturalHeight: imageHeight } = image;\n  _console.log({ imageWidth, imageHeight });\n\n  canvas.width = width;\n  canvas.height = height;\n\n  ctx.imageSmoothingEnabled = false;\n\n  ctx.drawImage(image, 0, 0, width, height);\n\n  const imageData = ctx.getImageData(0, 0, width, height);\n  const data = imageData.data;\n\n  // turn any non-opaque pixel to black\n  for (let i = 0; i < data.length; i += 4) {\n    const alpha = data[i + 3];\n\n    if (alpha < 255) {\n      data[i] = 0;\n      data[i + 1] = 0;\n      data[i + 2] = 0;\n      data[i + 3] = 255;\n    }\n  }\n\n  ctx.putImageData(imageData, 0, 0);\n\n  const quantOptions = {\n    method: 0,\n    colors: colors.length,\n    dithKern: null, // Disable dithering\n    useCache: false, // Disable color caching to force exact matches\n    reIndex: true, // Ensure strict re-indexing to the palette\n    orDist: \"manhattan\",\n  };\n  _console.log(\"quantOptions\", quantOptions);\n\n  // @ts-ignore\n  quantOptions.palette = colors.map((color) => {\n    const rgb = hexToRGB(color);\n    if (rgb) {\n      const { r, g, b } = rgb;\n      return [r, g, b];\n    } else {\n      _console.error(`invalid rgb hex \"${color}\"`);\n    }\n  });\n  _console.log(\"quantizeImage options\", quantOptions);\n  const quantizer = new RGBQuant(quantOptions);\n  quantizer.sample(imageData);\n\n  const quantizedPixels = quantizer.reduce(imageData.data);\n  const quantizedImageData = new ImageData(\n    new Uint8ClampedArray(quantizedPixels.buffer),\n    width,\n    height\n  );\n  ctx.putImageData(quantizedImageData, 0, 0);\n\n  const pixels = quantizedImageData.data;\n\n  const quantizedColorIndices: number[] = [];\n  for (let i = 0; i < pixels.length; i += 4) {\n    const r = pixels[i];\n    const g = pixels[i + 1];\n    const b = pixels[i + 2];\n    const a = pixels[i + 3];\n\n    const hex = rgbToHex({ r, g, b });\n\n    const colorIndex = colors.findIndex((color) => color == hex);\n    if (colorIndex == -1) {\n      _console.error(`no color found for ${hex}`);\n      quantizedColorIndices.push(0);\n      continue;\n    }\n    quantizedColorIndices.push(colorIndex);\n  }\n  _console.log(\"quantizedColorIndices\", quantizedColorIndices);\n\n  const promise = new Promise<Blob>((resolve, reject) => {\n    canvas.toBlob((blob) => {\n      if (blob) {\n        resolve(blob);\n      } else {\n        reject();\n      }\n    }, \"image/png\");\n  });\n  const blob = await promise;\n  return {\n    blob,\n    colorIndices: quantizedColorIndices,\n  };\n}\n\nexport async function imageToBitmap(\n  image: HTMLImageElement,\n  width: number,\n  height: number,\n  colors: string[],\n  contextState: DisplayContextState,\n  numberOfColors?: number\n) {\n  if (numberOfColors == undefined) {\n    numberOfColors = colors.length;\n  }\n  const bitmapColors = contextState.bitmapColorIndices\n    .map((bitmapColorIndex) => colors[bitmapColorIndex])\n    .slice(0, numberOfColors);\n  const { blob, colorIndices: bitmapColorIndices } =\n    await resizeAndQuantizeImage(image, width, height, bitmapColors);\n  const bitmap: DisplayBitmap = {\n    numberOfColors,\n    pixels: bitmapColorIndices,\n    width,\n    height,\n  };\n  return { blob, bitmap };\n}\n\nexport function getBitmapNumberOfBytes(bitmap: DisplayBitmap) {\n  const pixelDepth = numberOfColorsToPixelDepth(bitmap.numberOfColors)!;\n  const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);\n  const numberOfPixels = bitmap.pixels.length;\n  const pixelDataLength = Math.ceil(numberOfPixels / pixelsPerByte);\n  _console.log({\n    pixelDepth,\n    pixelsPerByte,\n    numberOfPixels,\n    pixelDataLength,\n  });\n  return pixelDataLength;\n}\nexport function assertValidBitmapPixels(bitmap: DisplayBitmap) {\n  _console.assertRangeWithError(\n    \"bitmap.pixels.length\",\n    bitmap.pixels.length,\n    bitmap.width * (bitmap.height - 1) + 1,\n    bitmap.width * bitmap.height\n  );\n  bitmap.pixels.forEach((pixel, index) => {\n    _console.assertRangeWithError(\n      `bitmap.pixels[${index}]`,\n      pixel,\n      0,\n      bitmap.numberOfColors - 1\n    );\n  });\n}\n","import { DisplayBitmap, DisplayBitmapColorPair } from \"../DisplayManager.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { DisplaySegmentCap } from \"./DisplayContextState.ts\";\nimport { DisplayColorRGB } from \"./DisplayUtils.ts\";\nimport { Vector2 } from \"./MathUtils.ts\";\n\nconst _console = createConsole(\"DisplayContextCommand\", { log: false });\n\nexport const DisplayContextCommands = [\n  \"show\",\n  \"clear\",\n\n  \"setColor\",\n  \"setColorOpacity\",\n  \"setOpacity\",\n\n  \"saveContext\",\n  \"restoreContext\",\n\n  \"selectFillColor\",\n  \"selectLineColor\",\n  \"setLineWidth\",\n  \"setRotation\",\n  \"clearRotation\",\n\n  \"setSegmentStartCap\",\n  \"setSegmentEndCap\",\n  \"setSegmentCap\",\n\n  \"setSegmentStartRadius\",\n  \"setSegmentEndRadius\",\n  \"setSegmentRadius\",\n\n  \"setCropTop\",\n  \"setCropRight\",\n  \"setCropBottom\",\n  \"setCropLeft\",\n  \"clearCrop\",\n\n  \"setRotationCropTop\",\n  \"setRotationCropRight\",\n  \"setRotationCropBottom\",\n  \"setRotationCropLeft\",\n  \"clearRotationCrop\",\n\n  \"selectBitmapColor\",\n  \"selectBitmapColors\",\n  \"setBitmapScaleX\",\n  \"setBitmapScaleY\",\n  \"setBitmapScale\",\n  \"resetBitmapScale\",\n\n  \"clearRect\",\n\n  \"drawRect\",\n  \"drawRoundRect\",\n  \"drawCircle\",\n  \"drawEllipse\",\n  \"drawPolygon\",\n  \"drawSegment\",\n  \"drawSegments\",\n\n  \"drawArc\",\n  \"drawArcEllipse\",\n\n  \"drawBitmap\",\n\n  \"selectSpriteSheet\",\n  \"drawSprite\",\n] as const;\nexport type DisplayContextCommand = (typeof DisplayContextCommands)[number];\n\ninterface BaseDisplayContextCommandMessage {\n  command: DisplayContextCommand;\n}\n\ninterface SimpleDisplayCommandMessage extends BaseDisplayContextCommandMessage {\n  command:\n    | \"show\"\n    | \"clear\"\n    | \"saveContext\"\n    | \"restoreContext\"\n    | \"clearRotation\"\n    | \"clearCrop\"\n    | \"clearRotationCrop\"\n    | \"resetBitmapScale\";\n}\n\ninterface SetDisplayColorCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setColor\";\n  colorIndex: number;\n  color: DisplayColorRGB | string;\n}\ninterface SetDisplayColorOpacityCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setColorOpacity\";\n  colorIndex: number;\n  opacity: number;\n}\ninterface SetDisplayOpacityCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setOpacity\";\n  opacity: number;\n}\n\ninterface SelectDisplayFillColorCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"selectFillColor\";\n  fillColorIndex: number;\n}\ninterface SelectDisplayLineColorCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"selectLineColor\";\n  lineColorIndex: number;\n}\ninterface SetDisplayLineWidthCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setLineWidth\";\n  lineWidth: number;\n}\ninterface SetDisplayRotationCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setRotation\";\n  rotation: number;\n  isRadians?: boolean;\n}\n\ninterface SetDisplaySegmentStartCapCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setSegmentStartCap\";\n  segmentStartCap: DisplaySegmentCap;\n}\ninterface SetDisplaySegmentEndCapCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setSegmentEndCap\";\n  segmentEndCap: DisplaySegmentCap;\n}\ninterface SetDisplaySegmentCapCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setSegmentCap\";\n  segmentCap: DisplaySegmentCap;\n}\n\ninterface SetDisplaySegmentStartRadiusCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setSegmentStartRadius\";\n  segmentStartRadius: number;\n}\ninterface SetDisplaySegmentEndRadiusCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setSegmentEndRadius\";\n  segmentEndRadius: number;\n}\ninterface SetDisplaySegmentRadiusCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setSegmentRadius\";\n  segmentRadius: number;\n}\n\ninterface SetDisplayCropTopCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setCropTop\";\n  cropTop: number;\n}\ninterface SetDisplayCropRightCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setCropRight\";\n  cropRight: number;\n}\ninterface SetDisplayCropBottomCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setCropBottom\";\n  cropBottom: number;\n}\ninterface SetDisplayCropLeftCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setCropLeft\";\n  cropLeft: number;\n}\n\ninterface SetDisplayRotationCropTopCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setRotationCropTop\";\n  rotationCropTop: number;\n}\ninterface SetDisplayRotationCropRightCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setRotationCropRight\";\n  rotationCropRight: number;\n}\ninterface SetDisplayRotationCropBottomCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setRotationCropBottom\";\n  rotationCropBottom: number;\n}\ninterface SetDisplayRotationCropLeftCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setRotationCropLeft\";\n  rotationCropLeft: number;\n}\n\ninterface SelectDisplayBitmapColorIndexCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"selectBitmapColor\";\n  bitmapColorIndex: number;\n  colorIndex: number;\n}\ninterface SelectDisplayBitmapColorIndicesCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"selectBitmapColors\";\n  bitmapColorPairs: DisplayBitmapColorPair[];\n}\n\ninterface SetDisplayBitmapScaleXCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setBitmapScaleX\";\n  bitmapScaleX: number;\n}\ninterface SetDisplayBitmapScaleYCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setBitmapScaleY\";\n  bitmapScaleY: number;\n}\ninterface SetDisplayBitmapScaleCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  command: \"setBitmapScale\";\n  bitmapScale: number;\n}\n\ninterface BasePositionDisplayContextCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  x: number;\n  y: number;\n}\ninterface BaseCenterPositionDisplayContextCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  centerX: number;\n  centerY: number;\n}\ninterface BaseSizeDisplayContextCommandMessage\n  extends BaseDisplayContextCommandMessage {\n  width: number;\n  height: number;\n}\n\ninterface BaseDisplayRectCommandMessage\n  extends BasePositionDisplayContextCommandMessage,\n    BaseSizeDisplayContextCommandMessage {}\ninterface BaseDisplayCenterRectCommandMessage\n  extends BasePositionDisplayContextCommandMessage,\n    BaseSizeDisplayContextCommandMessage {}\n\ninterface ClearDisplayRectCommandMessage extends BaseDisplayRectCommandMessage {\n  command: \"clearRect\";\n}\ninterface DrawDisplayRectCommandMessage\n  extends BaseDisplayCenterRectCommandMessage {\n  command: \"drawRect\";\n}\n\ninterface DrawDisplayRoundedRectCommandMessage\n  extends BaseCenterPositionDisplayContextCommandMessage,\n    BaseSizeDisplayContextCommandMessage {\n  command: \"drawRoundRect\";\n  borderRadius: number;\n}\n\ninterface DrawDisplayCircleCommandMessage\n  extends BaseCenterPositionDisplayContextCommandMessage {\n  command: \"drawCircle\";\n  radius: number;\n}\ninterface DrawDisplayEllipseCommandMessage\n  extends BaseCenterPositionDisplayContextCommandMessage {\n  command: \"drawEllipse\";\n  radiusX: number;\n  radiusY: number;\n}\n\ninterface DrawDisplayPolygonCommandMessage\n  extends BaseCenterPositionDisplayContextCommandMessage {\n  command: \"drawPolygon\";\n  radius: number;\n  numberOfSides: number;\n}\ninterface DrawDisplaySegmentCommandMessage\n  extends BaseCenterPositionDisplayContextCommandMessage {\n  command: \"drawSegment\";\n  startX: number;\n  startY: number;\n  endX: number;\n  endY: number;\n}\ninterface DrawDisplaySegmentsCommandMessage\n  extends BaseCenterPositionDisplayContextCommandMessage {\n  command: \"drawSegments\";\n  points: Vector2[];\n}\n\ninterface DrawDisplayArcCommandMessage\n  extends BaseCenterPositionDisplayContextCommandMessage {\n  command: \"drawArc\";\n  radius: number;\n  startAngle: number;\n  angleOffset: number;\n  isRadians?: boolean;\n}\ninterface DrawDisplayArcEllipseCommandMessage\n  extends BaseCenterPositionDisplayContextCommandMessage {\n  command: \"drawArcEllipse\";\n  radiusX: number;\n  radiusY: number;\n  startAngle: number;\n  angleOffset: number;\n  isRadians?: boolean;\n}\n\ninterface DrawDisplayBitmapCommandMessage\n  extends BaseCenterPositionDisplayContextCommandMessage {\n  command: \"drawBitmap\";\n  centerX: number;\n  centerY: number;\n  bitmap: DisplayBitmap;\n}\n\nexport type DisplayContextCommandMessage =\n  | SimpleDisplayCommandMessage\n  | SetDisplayColorCommandMessage\n  | SetDisplayColorOpacityCommandMessage\n  | SetDisplayOpacityCommandMessage\n  | SelectDisplayFillColorCommandMessage\n  | SelectDisplayLineColorCommandMessage\n  | SetDisplayLineWidthCommandMessage\n  | SetDisplayRotationCommandMessage\n  | SetDisplaySegmentStartCapCommandMessage\n  | SetDisplaySegmentEndCapCommandMessage\n  | SetDisplaySegmentCapCommandMessage\n  | SetDisplaySegmentStartRadiusCommandMessage\n  | SetDisplaySegmentEndRadiusCommandMessage\n  | SetDisplaySegmentRadiusCommandMessage\n  | SetDisplayCropTopCommandMessage\n  | SetDisplayCropRightCommandMessage\n  | SetDisplayCropBottomCommandMessage\n  | SetDisplayCropLeftCommandMessage\n  | SetDisplayRotationCropTopCommandMessage\n  | SetDisplayRotationCropRightCommandMessage\n  | SetDisplayRotationCropBottomCommandMessage\n  | SetDisplayRotationCropLeftCommandMessage\n  | SelectDisplayBitmapColorIndexCommandMessage\n  | SelectDisplayBitmapColorIndicesCommandMessage\n  | SetDisplayBitmapScaleXCommandMessage\n  | SetDisplayBitmapScaleYCommandMessage\n  | SetDisplayBitmapScaleCommandMessage\n  | ClearDisplayRectCommandMessage\n  | DrawDisplayRectCommandMessage\n  | DrawDisplayRoundedRectCommandMessage\n  | DrawDisplayCircleCommandMessage\n  | DrawDisplayEllipseCommandMessage\n  | DrawDisplayPolygonCommandMessage\n  | DrawDisplaySegmentCommandMessage\n  | DrawDisplaySegmentsCommandMessage\n  | DrawDisplayArcCommandMessage\n  | DrawDisplayArcEllipseCommandMessage\n  | DrawDisplayBitmapCommandMessage;\n","import {\n  DisplayBitmap,\n  DisplayBitmapColorPair,\n  DisplayBrightness,\n} from \"../DisplayManager.ts\";\nimport { DisplayContextCommandMessage } from \"./DisplayContextCommand.ts\";\nimport {\n  DisplayContextState,\n  DisplaySegmentCap,\n} from \"./DisplayContextState.ts\";\nimport {\n  DisplayBitmapScaleDirection,\n  DisplayColorRGB,\n  DisplayCropDirection,\n} from \"./DisplayUtils.ts\";\nimport { Vector2 } from \"./MathUtils.ts\";\n\nexport interface DisplayManagerInterface {\n  get isReady(): boolean;\n\n  get contextState(): DisplayContextState;\n\n  get brightness(): DisplayBrightness;\n  setBrightness(\n    newDisplayBrightness: DisplayBrightness,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  showDisplay(sendImmediately?: boolean): Promise<void>;\n  clearDisplay(sendImmediately?: boolean): Promise<void>;\n\n  get colors(): string[];\n  setColor(\n    colorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  get opacities(): number[];\n  setColorOpacity(\n    colorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setOpacity(opacity: number, sendImmediately?: boolean): Promise<void>;\n\n  saveContext(sendImmediately?: boolean): Promise<void>;\n  restoreContext(sendImmediately?: boolean): Promise<void>;\n\n  selectFillColor(\n    fillColorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  selectLineColor(\n    lineColorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setLineWidth(lineWidth: number, sendImmediately?: boolean): Promise<void>;\n\n  setRotation(\n    rotation: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  clearRotation(sendImmediately?: boolean): Promise<void>;\n\n  setSegmentStartCap(\n    segmentStartCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentEndCap(\n    segmentEndCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentCap(\n    segmentCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setSegmentStartRadius(\n    segmentStartRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentEndRadius(\n    segmentEndRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentRadius(\n    segmentRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setCropTop(cropTop: number, sendImmediately?: boolean): Promise<void>;\n  setCropRight(cropRight: number, sendImmediately?: boolean): Promise<void>;\n  setCropBottom(cropBottom: number, sendImmediately?: boolean): Promise<void>;\n  setCropLeft(cropLeft: number, sendImmediately?: boolean): Promise<void>;\n  clearCrop(sendImmediately?: boolean): Promise<void>;\n\n  setRotationCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropTop(\n    rotationCropTop: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropRight(\n    rotationCropRight: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropBottom(\n    rotationCropBottom: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropLeft(\n    rotationCropLeft: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  clearRotationCrop(sendImmediately?: boolean): Promise<void>;\n\n  selectBitmapColor(\n    bitmapColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  get bitmapColorIndices(): number[];\n  get bitmapColors(): string[];\n  selectBitmapColors(\n    bitmapColorPairs: DisplayBitmapColorPair[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setBitmapColor(\n    bitmapColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapColorOpacity(\n    bitmapColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setBitmapScaleDirection(\n    direction: DisplayBitmapScaleDirection,\n    bitmapScale: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapScaleX(\n    bitmapScaleX: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapScaleY(\n    bitmapScaleY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapScale(bitmapScale: number, sendImmediately?: boolean): Promise<void>;\n  resetBitmapScale(sendImmediately?: boolean): Promise<void>;\n\n  clearRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawRect(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawRoundRect(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawCircle(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawEllipse(\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawPolygon(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    numberOfSides: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  drawSegment(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawSegments(points: Vector2[], sendImmediately?: boolean): Promise<void>;\n\n  drawArc(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawArcEllipse(\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  drawBitmap(\n    centerX: number,\n    centerY: number,\n    bitmap: DisplayBitmap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  runContextCommandMessage(\n    commandMessage: DisplayContextCommandMessage,\n    position?: Vector2,\n    sendImmediately?: boolean\n  ): Promise<void>;\n}\n\nexport async function runDisplayContextCommand(\n  displayManager: DisplayManagerInterface,\n  commandMessage: DisplayContextCommandMessage,\n  position?: Vector2,\n  sendImmediately?: boolean\n) {\n  const { x: _x, y: _y } = position || { x: 0, y: 0 };\n\n  switch (commandMessage.command) {\n    case \"show\":\n      await displayManager.showDisplay(sendImmediately);\n      break;\n    case \"clear\":\n      await displayManager.clearDisplay(sendImmediately);\n      break;\n    case \"saveContext\":\n      await displayManager.saveContext(sendImmediately);\n      break;\n    case \"restoreContext\":\n      await displayManager.restoreContext(sendImmediately);\n      break;\n    case \"clearRotation\":\n      await displayManager.clearRotation(sendImmediately);\n      break;\n    case \"clearCrop\":\n      await displayManager.clearCrop(sendImmediately);\n      break;\n    case \"clearRotationCrop\":\n      await displayManager.clearRotationCrop(sendImmediately);\n      break;\n    case \"resetBitmapScale\":\n      await displayManager.resetBitmapScale(sendImmediately);\n      break;\n    case \"setColor\":\n      {\n        const { colorIndex, color } = commandMessage;\n        await displayManager.setColor(colorIndex, color, sendImmediately);\n      }\n      break;\n    case \"setColorOpacity\":\n      {\n        const { colorIndex, opacity } = commandMessage;\n        await displayManager.setColorOpacity(\n          colorIndex,\n          opacity,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setOpacity\":\n      {\n        const { opacity } = commandMessage;\n        await displayManager.setOpacity(opacity, sendImmediately);\n      }\n      break;\n    case \"selectFillColor\":\n      {\n        const { fillColorIndex } = commandMessage;\n        await displayManager.selectFillColor(fillColorIndex, sendImmediately);\n      }\n      break;\n    case \"selectLineColor\":\n      {\n        const { lineColorIndex } = commandMessage;\n        await displayManager.selectLineColor(lineColorIndex, sendImmediately);\n      }\n      break;\n    case \"setLineWidth\":\n      {\n        const { lineWidth } = commandMessage;\n        await displayManager.setLineWidth(lineWidth, sendImmediately);\n      }\n      break;\n    case \"setRotation\":\n      {\n        const { rotation, isRadians } = commandMessage;\n        await displayManager.setRotation(rotation, isRadians, sendImmediately);\n      }\n      break;\n    case \"setSegmentStartCap\":\n      {\n        const { segmentStartCap } = commandMessage;\n        await displayManager.setSegmentStartCap(\n          segmentStartCap,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSegmentEndCap\":\n      {\n        const { segmentEndCap } = commandMessage;\n        await displayManager.setSegmentEndCap(segmentEndCap, sendImmediately);\n      }\n      break;\n    case \"setSegmentCap\":\n      {\n        const { segmentCap } = commandMessage;\n        await displayManager.setSegmentCap(segmentCap, sendImmediately);\n      }\n      break;\n    case \"setSegmentStartRadius\":\n      {\n        const { segmentStartRadius } = commandMessage;\n        await displayManager.setSegmentStartRadius(\n          segmentStartRadius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSegmentEndRadius\":\n      {\n        const { segmentEndRadius } = commandMessage;\n        await displayManager.setSegmentEndRadius(\n          segmentEndRadius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSegmentRadius\":\n      {\n        const { segmentRadius } = commandMessage;\n        await displayManager.setSegmentRadius(segmentRadius, sendImmediately);\n      }\n      break;\n    case \"setCropTop\":\n      {\n        const { cropTop } = commandMessage;\n        await displayManager.setCropTop(cropTop, sendImmediately);\n      }\n      break;\n    case \"setCropRight\":\n      {\n        const { cropRight } = commandMessage;\n        await displayManager.setCropRight(cropRight, sendImmediately);\n      }\n      break;\n    case \"setCropBottom\":\n      {\n        const { cropBottom } = commandMessage;\n        await displayManager.setCropBottom(cropBottom, sendImmediately);\n      }\n      break;\n    case \"setCropLeft\":\n      {\n        const { cropLeft } = commandMessage;\n        await displayManager.setCropLeft(cropLeft, sendImmediately);\n      }\n      break;\n    case \"setRotationCropTop\":\n      {\n        const { rotationCropTop } = commandMessage;\n        await displayManager.setRotationCropTop(\n          rotationCropTop,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setRotationCropRight\":\n      {\n        const { rotationCropRight } = commandMessage;\n        await displayManager.setRotationCropRight(\n          rotationCropRight,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setRotationCropBottom\":\n      {\n        const { rotationCropBottom } = commandMessage;\n        await displayManager.setRotationCropBottom(\n          rotationCropBottom,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setRotationCropLeft\":\n      {\n        const { rotationCropLeft } = commandMessage;\n        await displayManager.setRotationCropLeft(\n          rotationCropLeft,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectBitmapColor\":\n      {\n        const { bitmapColorIndex, colorIndex } = commandMessage;\n        await displayManager.selectBitmapColor(\n          bitmapColorIndex,\n          colorIndex,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectBitmapColors\":\n      {\n        const { bitmapColorPairs } = commandMessage;\n        await displayManager.selectBitmapColors(\n          bitmapColorPairs,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setBitmapScaleX\":\n      {\n        const { bitmapScaleX } = commandMessage;\n        await displayManager.setBitmapScaleX(bitmapScaleX, sendImmediately);\n      }\n      break;\n    case \"setBitmapScaleY\":\n      {\n        const { bitmapScaleY } = commandMessage;\n        await displayManager.setBitmapScaleY(bitmapScaleY, sendImmediately);\n      }\n      break;\n    case \"setBitmapScale\":\n      {\n        const { bitmapScale } = commandMessage;\n        await displayManager.setBitmapScale(bitmapScale, sendImmediately);\n      }\n      break;\n    case \"clearRect\":\n      {\n        const { x, y, width, height } = commandMessage;\n        await displayManager.clearRect(\n          x + _x,\n          y + _y,\n          width,\n          height,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawRect\":\n      {\n        const { x, y, width, height } = commandMessage;\n        await displayManager.drawRect(\n          x + _x,\n          y + _y,\n          width,\n          height,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawRoundRect\":\n      {\n        const { centerX, centerY, width, height, borderRadius } =\n          commandMessage;\n        await displayManager.drawRoundRect(\n          centerX + _x,\n          centerY + _y,\n          width,\n          height,\n          borderRadius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawCircle\":\n      {\n        const { centerX, centerY, radius } = commandMessage;\n        await displayManager.drawCircle(\n          centerX + _x,\n          centerY + _y,\n          radius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawEllipse\":\n      {\n        const { centerX, centerY, radiusX, radiusY } = commandMessage;\n        await displayManager.drawEllipse(\n          centerX + _x,\n          centerY + _y,\n          radiusX,\n          radiusY,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawPolygon\":\n      {\n        const { centerX, centerY, radius, numberOfSides } = commandMessage;\n        await displayManager.drawEllipse(\n          centerX + _x,\n          centerY + _y,\n          radius,\n          numberOfSides,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawSegment\":\n      {\n        const { startX, startY, endX, endY } = commandMessage;\n        await displayManager.drawSegment(\n          startX + _x,\n          startY + _y,\n          endX + _x,\n          endY + _y,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawSegments\":\n      {\n        const { points } = commandMessage;\n        await displayManager.drawSegments(\n          points.map(({ x, y }) => ({ x: x + _x, y: y + _y })),\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawArc\":\n      {\n        const { centerX, centerY, radius, startAngle, angleOffset, isRadians } =\n          commandMessage;\n        await displayManager.drawArc(\n          centerX + _x,\n          centerY + _y,\n          radius,\n          startAngle,\n          angleOffset,\n          isRadians,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawArcEllipse\":\n      {\n        const {\n          centerX,\n          centerY,\n          radiusX,\n          radiusY,\n          startAngle,\n          angleOffset,\n          isRadians,\n        } = commandMessage;\n        await displayManager.drawArcEllipse(\n          centerX + _x,\n          centerY + _y,\n          radiusX,\n          radiusY,\n          startAngle,\n          angleOffset,\n          isRadians,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawBitmap\":\n      {\n        const { centerX, centerY, bitmap } = commandMessage;\n        await displayManager.drawBitmap(\n          centerX + _x,\n          centerY + _y,\n          bitmap,\n          sendImmediately\n        );\n      }\n      break;\n  }\n}\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\nimport {\n  clamp,\n  degToRad,\n  Int16Max,\n  Int16Min,\n  normalizeRadians,\n  twoPi,\n  Vector2,\n} from \"./utils/MathUtils.ts\";\nimport { rgbToHex, stringToRGB } from \"./utils/ColorUtils.ts\";\nimport DisplayContextStateHelper from \"./utils/DisplayContextStateHelper.ts\";\nimport {\n  assertValidColor,\n  assertValidDisplayBrightness,\n  assertValidOpacity,\n  assertValidSegmentCap,\n  DisplayBitmapScaleDirection,\n  DisplayBitmapScaleDirectionToCommand,\n  displayBitmapScaleStep,\n  DisplayColorRGB,\n  DisplayCropDirection,\n  DisplayCropDirections,\n  DisplayCropDirectionToCommand,\n  DisplayCropDirectionToStateKey,\n  DisplayRotationCropDirectionToCommand,\n  DisplayRotationCropDirectionToStateKey,\n  formatBitmapScale,\n  formatRotation,\n  maxDisplayBitmapScale,\n  numberOfColorsToPixelDepth,\n  pixelDepthToPixelBitWidth,\n  pixelDepthToPixelsPerByte,\n  roundBitmapScale,\n} from \"./utils/DisplayUtils.ts\";\nimport { DisplaySegmentCaps } from \"./BS.ts\";\nimport {\n  assertValidBitmapPixels,\n  getBitmapNumberOfBytes,\n  imageToBitmap,\n  quantizeImage,\n} from \"./utils/BitmapUtils.ts\";\nimport {\n  DisplayContextState,\n  DisplayContextStateKey,\n  DisplaySegmentCap,\n  PartialDisplayContextState,\n} from \"./utils/DisplayContextState.ts\";\nimport {\n  DisplayContextCommand,\n  DisplayContextCommandMessage,\n  DisplayContextCommands,\n} from \"./utils/DisplayContextCommand.ts\";\nimport {\n  DisplayManagerInterface,\n  runDisplayContextCommand,\n} from \"./utils/DisplayManagerInterface.ts\";\n\nconst _console = createConsole(\"DisplayManager\", { log: true });\n\nexport const DefaultNumberOfDisplayColors = 16;\n\nexport const DisplayCommands = [\"sleep\", \"wake\"] as const;\nexport type DisplayCommand = (typeof DisplayCommands)[number];\n\nexport const DisplayStatuses = [\"awake\", \"asleep\"] as const;\nexport type DisplayStatus = (typeof DisplayStatuses)[number];\n\nexport const DisplayInformationTypes = [\n  \"type\",\n  \"width\",\n  \"height\",\n  \"pixelDepth\",\n] as const;\nexport type DisplayInformationType = (typeof DisplayInformationTypes)[number];\n\nexport const DisplayTypes = [\n  \"none\",\n  \"generic\",\n  \"monocularLeft\",\n  \"monocularRight\",\n  \"binocular\",\n] as const;\nexport type DisplayType = (typeof DisplayTypes)[number];\n\nexport const DisplayPixelDepths = [\"1\", \"2\", \"4\"] as const;\nexport type DisplayPixelDepth = (typeof DisplayPixelDepths)[number];\n\nexport const DisplayBrightnesses = [\n  \"veryLow\",\n  \"low\",\n  \"medium\",\n  \"high\",\n  \"veryHigh\",\n] as const;\nexport type DisplayBrightness = (typeof DisplayBrightnesses)[number];\n\nexport const DisplayMessageTypes = [\n  \"isDisplayAvailable\",\n  \"displayStatus\",\n  \"displayInformation\",\n  \"displayCommand\",\n  \"getDisplayBrightness\",\n  \"setDisplayBrightness\",\n  \"displayContextCommands\",\n  \"displayReady\",\n] as const;\nexport type DisplayMessageType = (typeof DisplayMessageTypes)[number];\n\nexport type DisplaySize = {\n  width: number;\n  height: number;\n};\nexport type DisplayInformation = {\n  type: DisplayType;\n  width: number;\n  height: number;\n  pixelDepth: DisplayPixelDepth;\n};\n\nexport type DisplayBitmapColorPair = {\n  bitmapColorIndex: number;\n  colorIndex: number;\n};\n\nexport type DisplayBitmap = {\n  width: number;\n  height: number;\n  numberOfColors: number;\n  pixels: number[];\n};\n\nexport const DisplayInformationValues = {\n  type: DisplayTypes,\n  pixelDepth: DisplayPixelDepths,\n};\n\nexport const RequiredDisplayMessageTypes: DisplayMessageType[] = [\n  \"isDisplayAvailable\",\n  \"displayInformation\",\n  \"displayStatus\",\n  \"getDisplayBrightness\",\n] as const;\n\nexport const DisplayEventTypes = [\n  ...DisplayMessageTypes,\n  \"displayContextState\",\n  \"displayColor\",\n  \"displayColorOpacity\",\n  \"displayOpacity\",\n] as const;\nexport type DisplayEventType = (typeof DisplayEventTypes)[number];\n\nexport interface DisplayEventMessages {\n  isDisplayAvailable: { isDisplayAvailable: boolean };\n  displayStatus: {\n    displayStatus: DisplayStatus;\n    previousDisplayStatus: DisplayStatus;\n  };\n  displayInformation: {\n    displayInformation: DisplayInformation;\n  };\n  getDisplayBrightness: {\n    displayBrightness: DisplayBrightness;\n  };\n  displayContextState: {\n    displayContextState: DisplayContextState;\n    differences: DisplayContextStateKey[];\n  };\n  displayColor: {\n    colorIndex: number;\n    colorRGB: DisplayColorRGB;\n    colorHex: string;\n  };\n  displayColorOpacity: {\n    opacity: number;\n    colorIndex: number;\n  };\n  displayOpacity: {\n    opacity: number;\n  };\n  displayReady: {};\n}\n\nexport type DisplayEventDispatcher = EventDispatcher<\n  Device,\n  DisplayEventType,\n  DisplayEventMessages\n>;\nexport type SendDisplayMessageCallback =\n  SendMessageCallback<DisplayMessageType>;\n\nclass DisplayManager implements DisplayManagerInterface {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendDisplayMessageCallback;\n\n  eventDispatcher!: DisplayEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required display information\");\n    const messages = RequiredDisplayMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // IS DISPLAY AVAILABLE\n  #isAvailable = false;\n  get isAvailable() {\n    return this.#isAvailable;\n  }\n\n  #assertDisplayIsAvailable() {\n    _console.assertWithError(this.#isAvailable, \"display is not available\");\n  }\n\n  #parseIsDisplayAvailable(dataView: DataView) {\n    const newIsDisplayAvailable = dataView.getUint8(0) == 1;\n    this.#isAvailable = newIsDisplayAvailable;\n    _console.log({ isDisplayAvailable: this.#isAvailable });\n    this.#dispatchEvent(\"isDisplayAvailable\", {\n      isDisplayAvailable: this.#isAvailable,\n    });\n  }\n\n  // DISPLAY CONTEXT STATE\n  #contextStateHelper = new DisplayContextStateHelper();\n  get contextState() {\n    return this.#contextStateHelper.state;\n  }\n  #onContextStateUpdate(differences: DisplayContextStateKey[]) {\n    this.#dispatchEvent(\"displayContextState\", {\n      displayContextState: structuredClone(this.contextState),\n      differences,\n    });\n  }\n  async setContextState(\n    newState: PartialDisplayContextState,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.diff(newState);\n    if (differences.length == 0) {\n      return;\n    }\n    differences.forEach((difference) => {\n      switch (difference) {\n        case \"fillColorIndex\":\n          this.selectFillColor(newState.fillColorIndex!);\n          break;\n        case \"lineColorIndex\":\n          this.selectLineColor(newState.lineColorIndex!);\n          break;\n        case \"lineWidth\":\n          this.setLineWidth(newState.lineWidth!);\n          break;\n        case \"rotation\":\n          this.setRotation(newState.rotation!, true);\n          break;\n        case \"segmentStartCap\":\n          this.setSegmentStartCap(newState.segmentStartCap!);\n          break;\n        case \"segmentEndCap\":\n          this.setSegmentEndCap(newState.segmentEndCap!);\n          break;\n        case \"segmentStartRadius\":\n          this.setSegmentStartRadius(newState.segmentStartRadius!);\n          break;\n        case \"segmentEndRadius\":\n          this.setSegmentEndRadius(newState.segmentEndRadius!);\n          break;\n        case \"cropTop\":\n          this.setCropTop(newState.cropTop!);\n          break;\n        case \"cropRight\":\n          this.setCropRight(newState.cropRight!);\n          break;\n        case \"cropBottom\":\n          this.setCropBottom(newState.cropBottom!);\n          break;\n        case \"cropLeft\":\n          this.setCropLeft(newState.cropLeft!);\n          break;\n        case \"rotationCropTop\":\n          this.setRotationCropTop(newState.rotationCropTop!);\n          break;\n        case \"rotationCropRight\":\n          this.setRotationCropRight(newState.rotationCropRight!);\n          break;\n        case \"rotationCropBottom\":\n          this.setRotationCropBottom(newState.rotationCropBottom!);\n          break;\n        case \"rotationCropLeft\":\n          this.setRotationCropLeft(newState.rotationCropLeft!);\n          break;\n        case \"bitmapColorIndices\":\n          const bitmapColors: DisplayBitmapColorPair[] = [];\n          newState.bitmapColorIndices!.forEach(\n            (colorIndex, bitmapColorIndex) => {\n              bitmapColors.push({ bitmapColorIndex, colorIndex });\n            }\n          );\n          this.selectBitmapColors(bitmapColors);\n          break;\n        case \"bitmapScaleX\":\n          this.setBitmapScaleX(newState.bitmapScaleX!);\n          break;\n        case \"bitmapScaleY\":\n          this.setBitmapScaleY(newState.bitmapScaleY!);\n          break;\n      }\n    });\n    if (sendImmediately) {\n      await this.#sendDisplayContextCommands();\n    }\n  }\n\n  // DISPLAY STATUS\n  #displayStatus!: DisplayStatus;\n  get displayStatus() {\n    return this.#displayStatus;\n  }\n  get isDisplayAwake() {\n    return this.#displayStatus == \"awake\";\n  }\n  #parseDisplayStatus(dataView: DataView) {\n    const displayStatusIndex = dataView.getUint8(0);\n    const newDisplayStatus = DisplayStatuses[displayStatusIndex];\n    this.#updateDisplayStatus(newDisplayStatus);\n  }\n  #updateDisplayStatus(newDisplayStatus: DisplayStatus) {\n    _console.assertEnumWithError(newDisplayStatus, DisplayStatuses);\n    if (newDisplayStatus == this.#displayStatus) {\n      _console.log(`redundant displayStatus ${newDisplayStatus}`);\n      return;\n    }\n    const previousDisplayStatus = this.#displayStatus;\n    this.#displayStatus = newDisplayStatus;\n    _console.log(`updated displayStatus to \"${this.displayStatus}\"`);\n    this.#dispatchEvent(\"displayStatus\", {\n      displayStatus: this.displayStatus,\n      previousDisplayStatus,\n    });\n  }\n\n  // DISPLAY COMMAND\n  async #sendDisplayCommand(\n    command: DisplayCommand,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(command, DisplayCommands);\n    _console.log(`sending display command \"${command}\"`);\n\n    const promise = this.waitForEvent(\"displayStatus\");\n    _console.log(`setting command \"${command}\"`);\n    const commandEnum = DisplayCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"displayCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  #assertIsAwake() {\n    _console.assertWithError(\n      this.#displayStatus == \"awake\",\n      `display is not awake - currently ${this.#displayStatus}`\n    );\n  }\n  #assertIsNotAwake() {\n    _console.assertWithError(\n      this.#displayStatus != \"awake\",\n      `display is awake`\n    );\n  }\n\n  async wake() {\n    this.#assertIsNotAwake();\n    await this.#sendDisplayCommand(\"wake\");\n  }\n  async sleep() {\n    this.#assertIsAwake();\n    await this.#sendDisplayCommand(\"sleep\");\n  }\n  async toggle() {\n    switch (this.displayStatus) {\n      case \"asleep\":\n        this.wake();\n        break;\n      case \"awake\":\n        this.sleep();\n        break;\n    }\n  }\n\n  get numberOfColors() {\n    return 2 ** Number(this.pixelDepth!);\n  }\n\n  // INFORMATION\n  #displayInformation?: DisplayInformation;\n  get displayInformation() {\n    return this.#displayInformation;\n  }\n\n  get pixelDepth() {\n    return this.#displayInformation?.pixelDepth!;\n  }\n  get width() {\n    return this.#displayInformation?.width!;\n  }\n  get height() {\n    return this.#displayInformation?.width!;\n  }\n  get size() {\n    return {\n      width: this.width!,\n      height: this.height!,\n    };\n  }\n  get type() {\n    return this.#displayInformation?.type!;\n  }\n\n  #parseDisplayInformation(dataView: DataView) {\n    // @ts-expect-error\n    const parsedDisplayInformation: DisplayInformation = {};\n\n    let byteOffset = 0;\n    while (byteOffset < dataView.byteLength) {\n      const displayInformationTypeIndex = dataView.getUint8(byteOffset++);\n      const displayInformationType =\n        DisplayInformationTypes[displayInformationTypeIndex];\n      _console.assertWithError(\n        displayInformationType,\n        `invalid displayInformationTypeIndex ${displayInformationType}`\n      );\n      _console.log({ displayInformationType });\n\n      switch (displayInformationType) {\n        case \"width\":\n        case \"height\":\n          {\n            const value = dataView.getUint16(byteOffset, true);\n            parsedDisplayInformation[displayInformationType] = value;\n            byteOffset += 2;\n          }\n          break;\n        case \"pixelDepth\":\n        case \"type\":\n          {\n            const values = DisplayInformationValues[displayInformationType];\n            let rawValue = dataView.getUint8(byteOffset++);\n            const value = values[rawValue];\n            _console.assertEnumWithError(value, values);\n            // @ts-expect-error\n            parsedDisplayInformation[displayInformationType] = value;\n          }\n          break;\n      }\n    }\n\n    _console.log({ parsedDisplayInformation });\n    const missingDisplayInformationType = DisplayInformationTypes.find(\n      (type) => !(type in parsedDisplayInformation)\n    );\n    _console.assertWithError(\n      !missingDisplayInformationType,\n      `missingDisplayInformationType ${missingDisplayInformationType}`\n    );\n    this.#displayInformation = parsedDisplayInformation;\n    this.#colors = new Array(this.numberOfColors).fill(\"#000000\");\n    this.#opacities = new Array(this.numberOfColors).fill(1);\n    this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.#dispatchEvent(\"displayInformation\", {\n      displayInformation: this.#displayInformation,\n    });\n  }\n\n  // DISPLAY BRIGHTNESS\n  #brightness!: DisplayBrightness;\n  get brightness() {\n    return this.#brightness;\n  }\n\n  #parseDisplayBrightness(dataView: DataView) {\n    const newDisplayBrightnessEnum = dataView.getUint8(0);\n    const newDisplayBrightness = DisplayBrightnesses[newDisplayBrightnessEnum];\n    assertValidDisplayBrightness(newDisplayBrightness);\n\n    this.#brightness = newDisplayBrightness;\n    _console.log({ displayBrightness: this.#brightness });\n    this.#dispatchEvent(\"getDisplayBrightness\", {\n      displayBrightness: this.#brightness,\n    });\n  }\n\n  async setBrightness(\n    newDisplayBrightness: DisplayBrightness,\n    sendImmediately?: boolean\n  ) {\n    this.#assertDisplayIsAvailable();\n    assertValidDisplayBrightness(newDisplayBrightness);\n    if (this.brightness == newDisplayBrightness) {\n      _console.log(`redundant displayBrightness ${newDisplayBrightness}`);\n      return;\n    }\n    const newDisplayBrightnessEnum =\n      DisplayBrightnesses.indexOf(newDisplayBrightness);\n    const newDisplayBrightnessData = UInt8ByteBuffer(newDisplayBrightnessEnum);\n\n    const promise = this.waitForEvent(\"getDisplayBrightness\");\n    this.sendMessage(\n      [{ type: \"setDisplayBrightness\", data: newDisplayBrightnessData }],\n      sendImmediately\n    );\n    await promise;\n  }\n\n  // DISPLAY CONTEXT\n  #assertValidDisplayContextCommand(\n    displayContextCommand: DisplayContextCommand\n  ) {\n    _console.assertEnumWithError(displayContextCommand, DisplayContextCommands);\n  }\n\n  get #maxCommandDataLength() {\n    return this.mtu - 7;\n  }\n  #displayContextCommandBuffers: ArrayBuffer[] = [];\n  async #sendDisplayContextCommand(\n    displayContextCommand: DisplayContextCommand,\n    arrayBuffer?: ArrayBuffer,\n    sendImmediately?: boolean\n  ) {\n    this.#assertValidDisplayContextCommand(displayContextCommand);\n    _console.log(\n      \"sendDisplayContextCommand\",\n      { displayContextCommand, sendImmediately },\n      arrayBuffer\n    );\n    const displayContextCommandEnum = DisplayContextCommands.indexOf(\n      displayContextCommand\n    );\n    const _arrayBuffer = concatenateArrayBuffers(\n      displayContextCommandEnum,\n      arrayBuffer\n    );\n    const newLength = this.#displayContextCommandBuffers.reduce(\n      (sum, buffer) => sum + buffer.byteLength,\n      _arrayBuffer.byteLength\n    );\n    if (newLength > this.#maxCommandDataLength) {\n      _console.log(\"displayContextCommandBuffers too full - sending now\");\n      await this.#sendDisplayContextCommands();\n    }\n    this.#displayContextCommandBuffers.push(_arrayBuffer);\n    if (sendImmediately) {\n      await this.#sendDisplayContextCommands();\n    }\n  }\n  async #sendDisplayContextCommands() {\n    if (this.#displayContextCommandBuffers.length == 0) {\n      return;\n    }\n    const data = concatenateArrayBuffers(this.#displayContextCommandBuffers);\n    _console.log(\n      `sending displayContextCommands`,\n      this.#displayContextCommandBuffers.slice(),\n      data\n    );\n    this.#displayContextCommandBuffers.length = 0;\n    await this.sendMessage([{ type: \"displayContextCommands\", data }], true);\n  }\n  async flushDisplayContextCommands() {\n    await this.#sendDisplayContextCommands();\n  }\n  async showDisplay(sendImmediately = true) {\n    _console.log(\"showDisplay\");\n    this.#isReady = false;\n    await this.#sendDisplayContextCommand(\"show\", undefined, sendImmediately);\n  }\n  async clearDisplay(sendImmediately = true) {\n    _console.log(\"clearDisplay\");\n    this.#isReady = false;\n    await this.#sendDisplayContextCommand(\"clear\", undefined, sendImmediately);\n  }\n\n  #assertValidColorIndex(colorIndex: number) {\n    _console.assertRangeWithError(\n      \"colorIndex\",\n      colorIndex,\n      0,\n      this.numberOfColors\n    );\n  }\n  #colors: string[] = [];\n  get colors() {\n    return this.#colors;\n  }\n  async setColor(\n    colorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    let colorRGB: DisplayColorRGB;\n    if (typeof color == \"string\") {\n      colorRGB = stringToRGB(color);\n    } else {\n      colorRGB = color;\n    }\n    const colorHex = rgbToHex(colorRGB);\n    if (this.colors[colorIndex] == colorHex) {\n      _console.log(`redundant color #${colorIndex} ${colorHex}`);\n      return;\n    }\n\n    _console.log(`setting color #${colorIndex}`, colorRGB);\n    this.#assertValidColorIndex(colorIndex);\n    assertValidColor(colorRGB);\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setUint8(0, colorIndex);\n    dataView.setUint8(1, colorRGB.r);\n    dataView.setUint8(2, colorRGB.g);\n    dataView.setUint8(3, colorRGB.b);\n    await this.#sendDisplayContextCommand(\n      \"setColor\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.colors[colorIndex] = colorHex;\n    this.#dispatchEvent(\"displayColor\", {\n      colorIndex,\n      colorRGB,\n      colorHex,\n    });\n  }\n  #opacities: number[] = [];\n  get opacities() {\n    return this.#opacities;\n  }\n  async setColorOpacity(\n    colorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    this.#assertValidColorIndex(colorIndex);\n    assertValidOpacity(opacity);\n    if (\n      Math.floor(255 * this.#opacities[colorIndex]) == Math.floor(255 * opacity)\n    ) {\n      _console.log(`redundant opacity #${colorIndex} ${opacity}`);\n      return;\n    }\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint8(0, colorIndex);\n    dataView.setUint8(1, opacity * 255);\n    await this.#sendDisplayContextCommand(\n      \"setColorOpacity\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#opacities[colorIndex] = opacity;\n    this.#dispatchEvent(\"displayColorOpacity\", { colorIndex, opacity });\n  }\n  async setOpacity(opacity: number, sendImmediately?: boolean) {\n    assertValidOpacity(opacity);\n    await this.#sendDisplayContextCommand(\n      \"setOpacity\",\n      UInt8ByteBuffer(Math.round(opacity * 255)),\n      sendImmediately\n    );\n    this.#opacities.fill(opacity);\n    this.#dispatchEvent(\"displayOpacity\", { opacity });\n  }\n\n  async saveContext(sendImmediately?: boolean) {\n    await this.#sendDisplayContextCommand(\n      \"saveContext\",\n      undefined,\n      sendImmediately\n    );\n  }\n  async restoreContext(sendImmediately?: boolean) {\n    await this.#sendDisplayContextCommand(\n      \"restoreContext\",\n      undefined,\n      sendImmediately\n    );\n  }\n\n  async selectFillColor(fillColorIndex: number, sendImmediately?: boolean) {\n    this.#assertValidColorIndex(fillColorIndex);\n    const differences = this.#contextStateHelper.update({\n      fillColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"selectFillColor\",\n      UInt8ByteBuffer(fillColorIndex),\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async selectLineColor(lineColorIndex: number, sendImmediately?: boolean) {\n    this.#assertValidColorIndex(lineColorIndex);\n    const differences = this.#contextStateHelper.update({\n      lineColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"selectLineColor\",\n      UInt8ByteBuffer(lineColorIndex),\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  #assertValidLineWidth(lineWidth: number) {\n    _console.assertRangeWithError(\"lineWidth\", lineWidth, 0, this.width);\n  }\n  async setLineWidth(lineWidth: number, sendImmediately?: boolean) {\n    this.#assertValidLineWidth(lineWidth);\n    const differences = this.#contextStateHelper.update({\n      lineWidth,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, lineWidth, true);\n    await this.#sendDisplayContextCommand(\n      \"setLineWidth\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setRotation(\n    rotation: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    rotation = isRadians ? rotation : degToRad(rotation);\n    rotation = normalizeRadians(rotation);\n    _console.log({ rotation });\n\n    const differences = this.#contextStateHelper.update({\n      rotation,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, formatRotation(rotation, true), true);\n    await this.#sendDisplayContextCommand(\n      \"setRotation\",\n      dataView.buffer,\n      sendImmediately\n    );\n\n    this.#onContextStateUpdate(differences);\n  }\n  async clearRotation(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotation: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"clearRotation\",\n      undefined,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSegmentStartCap(\n    segmentStartCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentStartCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentStartCap });\n    const dataView = new DataView(new ArrayBuffer(1));\n    const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentStartCap);\n    dataView.setUint8(0, segmentCapEnum);\n    await this.#sendDisplayContextCommand(\n      \"setSegmentStartCap\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndCap(\n    segmentEndCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentEndCap);\n    const differences = this.#contextStateHelper.update({\n      segmentEndCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    _console.log({ segmentEndCap });\n    const dataView = new DataView(new ArrayBuffer(1));\n    const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentEndCap);\n    dataView.setUint8(0, segmentCapEnum);\n    await this.#sendDisplayContextCommand(\n      \"setSegmentEndCap\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentCap(\n    segmentCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap: segmentCap,\n      segmentEndCap: segmentCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentCap });\n    const dataView = new DataView(new ArrayBuffer(1));\n    const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentCap);\n    dataView.setUint8(0, segmentCapEnum);\n    await this.#sendDisplayContextCommand(\n      \"setSegmentCap\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSegmentStartRadius(\n    segmentStartRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentStartRadius });\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, segmentStartRadius, true);\n    await this.#sendDisplayContextCommand(\n      \"setSegmentStartRadius\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndRadius(\n    segmentEndRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentEndRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentEndRadius });\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, segmentEndRadius, true);\n    await this.#sendDisplayContextCommand(\n      \"setSegmentEndRadius\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentRadius(segmentRadius: number, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius: segmentRadius,\n      segmentEndRadius: segmentRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentRadius });\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, segmentRadius, true);\n    await this.#sendDisplayContextCommand(\n      \"setSegmentRadius\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    crop = Math.max(0, crop);\n    const cropCommand = DisplayCropDirectionToCommand[cropDirection];\n    const cropKey = DisplayCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ [cropCommand]: crop });\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, crop, true);\n    await this.#sendDisplayContextCommand(\n      cropCommand,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setCropTop(cropTop: number, sendImmediately?: boolean) {\n    await this.setCrop(\"top\", cropTop, sendImmediately);\n  }\n  async setCropRight(cropRight: number, sendImmediately?: boolean) {\n    await this.setCrop(\"right\", cropRight, sendImmediately);\n  }\n  async setCropBottom(cropBottom: number, sendImmediately?: boolean) {\n    await this.setCrop(\"bottom\", cropBottom, sendImmediately);\n  }\n  async setCropLeft(cropLeft: number, sendImmediately?: boolean) {\n    await this.setCrop(\"left\", cropLeft, sendImmediately);\n  }\n  async clearCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      cropTop: 0,\n      cropRight: 0,\n      cropBottom: 0,\n      cropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"clearCrop\",\n      undefined,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setRotationCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    const cropCommand = DisplayRotationCropDirectionToCommand[cropDirection];\n    const cropKey = DisplayRotationCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ [cropCommand]: crop });\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, crop, true);\n    await this.#sendDisplayContextCommand(\n      cropCommand,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setRotationCropTop(rotationCropTop: number, sendImmediately?: boolean) {\n    await this.setRotationCrop(\"top\", rotationCropTop, sendImmediately);\n  }\n  async setRotationCropRight(\n    rotationCropRight: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"right\", rotationCropRight, sendImmediately);\n  }\n  async setRotationCropBottom(\n    rotationCropBottom: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"bottom\", rotationCropBottom, sendImmediately);\n  }\n  async setRotationCropLeft(\n    rotationCropLeft: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"left\", rotationCropLeft, sendImmediately);\n  }\n  async clearRotationCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotationCropTop: 0,\n      rotationCropRight: 0,\n      rotationCropBottom: 0,\n      rotationCropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"clearRotationCrop\",\n      undefined,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async selectBitmapColor(\n    bitmapColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.#assertValidColorIndex(bitmapColorIndex);\n    this.#assertValidColorIndex(colorIndex);\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint8(0, bitmapColorIndex);\n    dataView.setUint8(1, colorIndex);\n    await this.#sendDisplayContextCommand(\n      \"selectBitmapColor\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  get bitmapColorIndices() {\n    return this.contextState.bitmapColorIndices;\n  }\n  get bitmapColors() {\n    return this.bitmapColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  async selectBitmapColors(\n    bitmapColorPairs: DisplayBitmapColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"bitmapColors\",\n      bitmapColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n      this.#assertValidColorIndex(bitmapColorIndex);\n      this.#assertValidColorIndex(colorIndex);\n      bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    });\n\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = new DataView(\n      new ArrayBuffer(bitmapColorPairs.length * 2 + 1)\n    );\n    let offset = 0;\n    dataView.setUint8(offset++, bitmapColorPairs.length);\n    bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }, index) => {\n      dataView.setUint8(offset, bitmapColorIndex);\n      dataView.setUint8(offset + 1, colorIndex);\n      offset += 2;\n    });\n    await this.#sendDisplayContextCommand(\n      \"selectBitmapColors\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setBitmapColor(\n    bitmapColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.bitmapColorIndices[bitmapColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setBitmapColorOpacity(\n    bitmapColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.bitmapColorIndices[bitmapColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n  async setBitmapScaleDirection(\n    direction: DisplayBitmapScaleDirection,\n    bitmapScale: number,\n    sendImmediately?: boolean\n  ) {\n    bitmapScale = clamp(\n      bitmapScale,\n      displayBitmapScaleStep,\n      maxDisplayBitmapScale\n    );\n    bitmapScale = roundBitmapScale(bitmapScale);\n    const command = DisplayBitmapScaleDirectionToCommand[direction];\n    _console.log({ command: bitmapScale });\n    const newState: PartialDisplayContextState = {};\n    switch (direction) {\n      case \"all\":\n        newState.bitmapScaleX = bitmapScale;\n        newState.bitmapScaleY = bitmapScale;\n        break;\n      case \"x\":\n        newState.bitmapScaleX = bitmapScale;\n        break;\n      case \"y\":\n        newState.bitmapScaleY = bitmapScale;\n        break;\n    }\n    const differences = this.#contextStateHelper.update(newState);\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, formatBitmapScale(bitmapScale), true);\n    await this.#sendDisplayContextCommand(\n      command,\n      dataView.buffer,\n      sendImmediately\n    );\n\n    this.#onContextStateUpdate(differences);\n  }\n  async setBitmapScaleX(bitmapScaleX: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"x\", bitmapScaleX, sendImmediately);\n  }\n  async setBitmapScaleY(bitmapScaleY: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"y\", bitmapScaleY, sendImmediately);\n  }\n  async setBitmapScale(bitmapScale: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"all\", bitmapScale, sendImmediately);\n  }\n  async resetBitmapScale(sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"all\", 1, sendImmediately);\n  }\n\n  #clampX(x: number) {\n    return clamp(x, 0, this.width - 1);\n  }\n  #clampWidth(x: number, width: number) {\n    return clamp(width, 1, this.width - x);\n  }\n  #clampY(y: number) {\n    return clamp(y, 0, this.height - 1);\n  }\n  #clampHeight(y: number, height: number) {\n    return clamp(height, 1, this.height - y);\n  }\n  #clampBox(x: number, y: number, width: number, height: number) {\n    //x = this.#clampX(x);\n    //width = this.#clampWidth(x, width);\n    //y = this.#clampY(y);\n    //height = this.#clampHeight(y, height);\n\n    _console.log(\"clampBox\", { x, y, width, height });\n\n    return { x, y, width, height };\n  }\n  async clearRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const {\n      x: _x,\n      y: _y,\n      width: _width,\n      height: _height,\n    } = this.#clampBox(x, y, width, height);\n    const dataView = new DataView(new ArrayBuffer(2 * 4));\n    dataView.setUint16(0, _x, true);\n    dataView.setUint16(2, _y, true);\n    dataView.setUint16(4, _width, true);\n    dataView.setUint16(6, _height, true);\n    await this.#sendDisplayContextCommand(\n      \"clearRect\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawRect(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = new DataView(new ArrayBuffer(2 * 4));\n    dataView.setInt16(0, centerX, true);\n    dataView.setInt16(2, centerY, true);\n    dataView.setUint16(4, width, true);\n    dataView.setUint16(6, height, true);\n    _console.log(\"drawRect data\", dataView);\n    await this.#sendDisplayContextCommand(\n      \"drawRect\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawRoundRect(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = new DataView(new ArrayBuffer(2 * 4 + 1));\n    dataView.setInt16(0, centerX, true);\n    dataView.setInt16(2, centerY, true);\n    dataView.setUint16(4, width, true);\n    dataView.setUint16(6, height, true);\n    dataView.setUint8(8, borderRadius);\n    _console.log(\"drawRoundRect data\", dataView);\n    await this.#sendDisplayContextCommand(\n      \"drawRoundRect\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawCircle(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = new DataView(new ArrayBuffer(2 * 3));\n    dataView.setInt16(0, centerX, true);\n    dataView.setInt16(2, centerY, true);\n    dataView.setUint16(4, radius, true);\n    _console.log(\"drawCircle data\", dataView);\n    await this.#sendDisplayContextCommand(\n      \"drawCircle\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawEllipse(\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = new DataView(new ArrayBuffer(2 * 4));\n    dataView.setInt16(0, centerX, true);\n    dataView.setInt16(2, centerY, true);\n    dataView.setUint16(4, radiusX, true);\n    dataView.setUint16(6, radiusY, true);\n    _console.log(\"drawEllipse data\", dataView);\n    await this.#sendDisplayContextCommand(\n      \"drawEllipse\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawPolygon(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    numberOfSides: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = new DataView(new ArrayBuffer(2 * 3 + 1));\n    dataView.setInt16(0, centerX, true);\n    dataView.setInt16(2, centerY, true);\n    dataView.setUint16(4, radius, true);\n    dataView.setUint8(6, numberOfSides);\n    _console.log(\"drawPolygon data\", dataView);\n    await this.#sendDisplayContextCommand(\n      \"drawPolygon\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawSegment(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = new DataView(new ArrayBuffer(2 * 4));\n    _console.log({ startX, startY, endX, endY });\n    dataView.setInt16(0, startX, true);\n    dataView.setInt16(2, startY, true);\n    dataView.setInt16(4, endX, true);\n    dataView.setInt16(6, endY, true);\n    _console.log(\"drawSegment data\", dataView);\n    await this.#sendDisplayContextCommand(\n      \"drawSegment\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawSegments(points: Vector2[], sendImmediately?: boolean) {\n    _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n    _console.log({ points });\n    const dataViewLength = 1 + points.length * 4;\n    if (dataViewLength > this.#maxCommandDataLength) {\n      const mid = Math.floor(points.length / 2);\n      const firstHalf = points.slice(0, mid + 1);\n      const secondHalf = points.slice(mid);\n      _console.log({ firstHalf, secondHalf });\n      _console.log(\"sending first half\", firstHalf);\n      await this.drawSegments(firstHalf, false);\n      _console.log(\"sending second half\", secondHalf);\n      await this.drawSegments(secondHalf, sendImmediately);\n      return;\n    }\n    const dataView = new DataView(new ArrayBuffer(dataViewLength));\n    let offset = 0;\n    dataView.setUint8(offset++, points.length);\n    points.forEach((segment) => {\n      dataView.setInt16(offset, segment.x, true);\n      offset += 2;\n      dataView.setInt16(offset, segment.y, true);\n      offset += 2;\n    });\n    _console.log(\"drawSegments data\", dataView);\n    await this.#sendDisplayContextCommand(\n      \"drawSegments\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawArc(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    startAngle = isRadians ? startAngle : degToRad(startAngle);\n    startAngle = normalizeRadians(startAngle);\n\n    angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n    angleOffset = clamp(angleOffset, -twoPi, twoPi);\n    _console.log({ startAngle, angleOffset });\n\n    angleOffset /= twoPi;\n    angleOffset *= (angleOffset > 0 ? Int16Max - 1 : -Int16Min) - 1;\n\n    console.log({ angleOffset });\n\n    const dataView = new DataView(new ArrayBuffer(2 * 5));\n    dataView.setInt16(0, centerX, true);\n    dataView.setInt16(2, centerY, true);\n    dataView.setUint16(4, radius, true);\n    dataView.setUint16(6, formatRotation(startAngle, true), true);\n    dataView.setInt16(8, angleOffset, true);\n    _console.log(\"drawArc data\", dataView);\n    await this.#sendDisplayContextCommand(\n      \"drawArc\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawArcEllipse(\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    startAngle = isRadians ? startAngle : degToRad(startAngle);\n    startAngle = normalizeRadians(startAngle);\n\n    angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n    angleOffset = clamp(angleOffset, -twoPi, twoPi);\n    _console.log({ startAngle, angleOffset });\n\n    angleOffset /= twoPi;\n    angleOffset *= (angleOffset > 0 ? Int16Max : -Int16Min) - 1;\n\n    const dataView = new DataView(new ArrayBuffer(2 * 6));\n    dataView.setInt16(0, centerX, true);\n    dataView.setInt16(2, centerY, true);\n    dataView.setUint16(4, radiusX, true);\n    dataView.setUint16(6, radiusY, true);\n    dataView.setUint16(8, formatRotation(startAngle, true), true);\n    dataView.setUint16(10, angleOffset, true);\n    _console.log(\"drawArcEllipse data\", dataView);\n    await this.#sendDisplayContextCommand(\n      \"drawArcEllipse\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  #assertValidNumberOfColors(numberOfColors: number) {\n    _console.assertRangeWithError(\n      \"numberOfColors\",\n      numberOfColors,\n      2,\n      this.numberOfColors\n    );\n  }\n\n  #assertValidBitmap(bitmap: DisplayBitmap, limitToMtu?: boolean) {\n    this.#assertValidNumberOfColors(bitmap.numberOfColors);\n    assertValidBitmapPixels(bitmap);\n    if (limitToMtu) {\n      const pixelDataLength = getBitmapNumberOfBytes(bitmap);\n      _console.assertRangeWithError(\n        \"bitmap.pixels.length\",\n        pixelDataLength,\n        1,\n        this.#maxCommandDataLength - this.#drawBitmapHeaderLength\n      );\n    }\n  }\n  #getBitmapData(bitmap: DisplayBitmap) {\n    const pixelDataLength = getBitmapNumberOfBytes(bitmap);\n    const dataView = new DataView(new ArrayBuffer(pixelDataLength));\n    const pixelDepth = numberOfColorsToPixelDepth(bitmap.numberOfColors)!;\n    const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);\n    bitmap.pixels.forEach((bitmapColorIndex, pixelIndex) => {\n      const byteIndex = Math.floor(pixelIndex / pixelsPerByte);\n      const byteSlot = pixelIndex % pixelsPerByte;\n      const pixelBitWidth = pixelDepthToPixelBitWidth(pixelDepth);\n      const bitOffset = pixelBitWidth * byteSlot;\n      const shift = 8 - pixelBitWidth - bitOffset;\n      let value = dataView.getUint8(byteIndex);\n      value |= bitmapColorIndex << shift;\n      dataView.setUint8(byteIndex, value);\n    });\n    _console.log(\"getBitmapData\", bitmap, dataView);\n    return dataView;\n  }\n\n  get #drawBitmapHeaderLength() {\n    return 2 + 2 + 2 + 2 + 1 + 2; // x, y, width, numberOfPixels, numberOfColors, dataLength\n  }\n  async drawBitmap(\n    centerX: number,\n    centerY: number,\n    bitmap: DisplayBitmap,\n    sendImmediately?: boolean\n  ) {\n    this.#assertValidBitmap(bitmap, true);\n    _console.log(\"drawBitmap\", bitmap);\n    const dataView = new DataView(\n      new ArrayBuffer(this.#drawBitmapHeaderLength)\n    );\n    dataView.setInt16(0, centerX, true);\n    dataView.setInt16(2, centerY, true);\n    dataView.setUint16(4, bitmap.width, true);\n    dataView.setUint16(6, bitmap.pixels.length, true);\n    dataView.setUint8(8, bitmap.numberOfColors);\n\n    const bitmapData = this.#getBitmapData(bitmap);\n    dataView.setUint16(9, bitmapData.byteLength, true);\n\n    const buffer = concatenateArrayBuffers(dataView, bitmapData);\n    _console.log(\"drawBitmap data\", buffer);\n    await this.#sendDisplayContextCommand(\n      \"drawBitmap\",\n      buffer,\n      sendImmediately\n    );\n  }\n\n  async imageToBitmap(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors?: number\n  ) {\n    return imageToBitmap(\n      image,\n      width,\n      height,\n      this.colors,\n      this.contextState,\n      numberOfColors\n    );\n  }\n  async quantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number\n  ) {\n    return quantizeImage(image, width, height, numberOfColors);\n  }\n\n  // SPRITE SHEET\n  selectSpriteSheet(index: number, sendImmediately?: boolean) {\n    // FILL\n  }\n  drawSprite(index: number, x: number, y: number, sendImmediately?: boolean) {\n    // FILL\n  }\n\n  async runContextCommandMessage(\n    commandMessage: DisplayContextCommandMessage,\n    position: Vector2,\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommand(\n      this,\n      commandMessage,\n      position,\n      sendImmediately\n    );\n  }\n\n  #isReady = true;\n  get isReady() {\n    return this.isAvailable && this.#isReady;\n  }\n  #parseDisplayReady(dataView: DataView) {\n    this.#isReady = true;\n    this.#dispatchEvent(\"displayReady\", {});\n  }\n\n  // MESSAGE\n  parseMessage(messageType: DisplayMessageType, dataView: DataView) {\n    _console.log({ messageType, dataView });\n\n    switch (messageType) {\n      case \"isDisplayAvailable\":\n        this.#parseIsDisplayAvailable(dataView);\n        break;\n      case \"displayStatus\":\n        this.#parseDisplayStatus(dataView);\n        break;\n      case \"displayInformation\":\n        this.#parseDisplayInformation(dataView);\n        break;\n      case \"getDisplayBrightness\":\n      case \"setDisplayBrightness\":\n        this.#parseDisplayBrightness(dataView);\n        break;\n      case \"displayReady\":\n        this.#parseDisplayReady(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    _console.log(\"clearing displayManager\");\n    // @ts-ignore\n    this.#displayStatus = undefined;\n    this.#isAvailable = false;\n    this.#displayInformation = undefined;\n    // @ts-ignore\n    this.#brightness = undefined;\n    this.#displayContextCommandBuffers = [];\n    this.#isAvailable = false;\n\n    this.#contextStateHelper.reset();\n    this.#colors.length = 0;\n    this.#opacities.length = 0;\n\n    this.#isReady = true;\n  }\n\n  // MTU\n  #mtu!: number;\n  get mtu() {\n    return this.#mtu;\n  }\n  set mtu(newMtu: number) {\n    this.#mtu = newMtu;\n  }\n}\n\nexport default DisplayManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport Timer from \"../utils/Timer.ts\";\n\nimport { FileTransferMessageTypes } from \"../FileTransferManager.ts\";\nimport { TfliteMessageTypes } from \"../TfliteManager.ts\";\nimport { concatenateArrayBuffers } from \"../utils/ArrayBufferUtils.ts\";\nimport { parseMessage } from \"../utils/ParseUtils.ts\";\nimport { DeviceInformationTypes } from \"../DeviceInformationManager.ts\";\nimport { InformationMessageTypes } from \"../InformationManager.ts\";\nimport { VibrationMessageTypes } from \"../vibration/VibrationManager.ts\";\nimport { SensorConfigurationMessageTypes } from \"../sensor/SensorConfigurationManager.ts\";\nimport { SensorDataMessageTypes } from \"../sensor/SensorDataManager.ts\";\nimport { WifiMessageTypes } from \"../WifiManager.ts\";\nimport { CameraMessageTypes } from \"../CameraManager.ts\";\nimport { MicrophoneMessageTypes } from \"../MicrophoneManager.ts\";\nimport { DisplayMessageTypes } from \"../DisplayManager.ts\";\n\nconst _console = createConsole(\"BaseConnectionManager\", { log: false });\n\nexport const ConnectionTypes = [\n  \"webBluetooth\",\n  \"noble\",\n  \"client\",\n  \"webSocket\",\n  \"udp\",\n] as const;\nexport type ConnectionType = (typeof ConnectionTypes)[number];\n\nexport const ClientConnectionTypes = [\"noble\", \"webSocket\", \"udp\"] as const;\nexport type ClientConnectionType = (typeof ClientConnectionTypes)[number];\n\ninterface BaseConnectOptions {\n  type: \"client\" | \"webBluetooth\" | \"webSocket\" | \"udp\";\n}\nexport interface WebBluetoothConnectOptions extends BaseConnectOptions {\n  type: \"webBluetooth\";\n}\ninterface BaseWifiConnectOptions extends BaseConnectOptions {\n  ipAddress: string;\n}\nexport interface ClientConnectOptions extends BaseConnectOptions {\n  type: \"client\";\n  subType?: \"noble\" | \"webSocket\" | \"udp\";\n}\nexport interface WebSocketConnectOptions extends BaseWifiConnectOptions {\n  type: \"webSocket\";\n  isWifiSecure?: boolean;\n}\nexport interface UDPConnectOptions extends BaseWifiConnectOptions {\n  type: \"udp\";\n  //sendPort: number;\n  receivePort?: number;\n}\nexport type ConnectOptions =\n  | WebBluetoothConnectOptions\n  | WebSocketConnectOptions\n  | UDPConnectOptions\n  | ClientConnectOptions;\n\nexport const ConnectionStatuses = [\n  \"notConnected\",\n  \"connecting\",\n  \"connected\",\n  \"disconnecting\",\n] as const;\nexport type ConnectionStatus = (typeof ConnectionStatuses)[number];\n\nexport const ConnectionEventTypes = [\n  ...ConnectionStatuses,\n  \"connectionStatus\",\n  \"isConnected\",\n] as const;\nexport type ConnectionEventType = (typeof ConnectionEventTypes)[number];\n\nexport interface ConnectionStatusEventMessages {\n  notConnected: any;\n  connecting: any;\n  connected: any;\n  disconnecting: any;\n  connectionStatus: { connectionStatus: ConnectionStatus };\n  isConnected: { isConnected: boolean };\n}\n\nexport interface TxMessage {\n  type: TxRxMessageType;\n  data?: ArrayBuffer;\n}\n\nexport const TxRxMessageTypes = [\n  ...InformationMessageTypes,\n  ...SensorConfigurationMessageTypes,\n  ...SensorDataMessageTypes,\n  ...VibrationMessageTypes,\n  ...FileTransferMessageTypes,\n  ...TfliteMessageTypes,\n  ...WifiMessageTypes,\n  ...CameraMessageTypes,\n  ...MicrophoneMessageTypes,\n  ...DisplayMessageTypes,\n] as const;\nexport type TxRxMessageType = (typeof TxRxMessageTypes)[number];\n\nexport const SMPMessageTypes = [\"smp\"] as const;\nexport type SMPMessageType = (typeof SMPMessageTypes)[number];\n\nexport const BatteryLevelMessageTypes = [\"batteryLevel\"] as const;\nexport type BatteryLevelMessageType = (typeof BatteryLevelMessageTypes)[number];\n\nexport const MetaConnectionMessageTypes = [\"rx\", \"tx\"] as const;\nexport type MetaConnectionMessageType =\n  (typeof MetaConnectionMessageTypes)[number];\n\nexport const ConnectionMessageTypes = [\n  ...BatteryLevelMessageTypes,\n  ...DeviceInformationTypes,\n  ...MetaConnectionMessageTypes,\n  ...TxRxMessageTypes,\n  ...SMPMessageTypes,\n] as const;\nexport type ConnectionMessageType = (typeof ConnectionMessageTypes)[number];\n\nexport type ConnectionStatusCallback = (status: ConnectionStatus) => void;\nexport type MessageReceivedCallback = (\n  messageType: ConnectionMessageType,\n  dataView: DataView\n) => void;\nexport type MessagesReceivedCallback = () => void;\n\nabstract class BaseConnectionManager {\n  static #AssertValidTxRxMessageType(messageType: TxRxMessageType) {\n    _console.assertEnumWithError(messageType, TxRxMessageTypes);\n  }\n\n  abstract get bluetoothId(): string;\n\n  // CALLBACKS\n  onStatusUpdated?: ConnectionStatusCallback;\n  onMessageReceived?: MessageReceivedCallback;\n  onMessagesReceived?: MessagesReceivedCallback;\n\n  protected get baseConstructor() {\n    return this.constructor as typeof BaseConnectionManager;\n  }\n  static get isSupported() {\n    return false;\n  }\n  get isSupported() {\n    return this.baseConstructor.isSupported;\n  }\n\n  get canUpdateFirmware() {\n    return false;\n  }\n\n  static type: ConnectionType;\n  get type(): ConnectionType {\n    return this.baseConstructor.type;\n  }\n\n  /** @throws {Error} if not supported */\n  #assertIsSupported() {\n    _console.assertWithError(\n      this.isSupported,\n      `${this.constructor.name} is not supported`\n    );\n  }\n\n  constructor() {\n    this.#assertIsSupported();\n  }\n\n  #status: ConnectionStatus = \"notConnected\";\n  get status() {\n    return this.#status;\n  }\n  protected set status(newConnectionStatus) {\n    _console.assertEnumWithError(newConnectionStatus, ConnectionStatuses);\n    if (this.#status == newConnectionStatus) {\n      _console.log(\n        `tried to assign same connection status \"${newConnectionStatus}\"`\n      );\n      return;\n    }\n    _console.log(`new connection status \"${newConnectionStatus}\"`);\n    this.#status = newConnectionStatus;\n    this.onStatusUpdated!(this.status);\n\n    if (this.isConnected) {\n      this.#timer.start();\n    } else {\n      this.#timer.stop();\n    }\n\n    if (this.#status == \"notConnected\") {\n      this.mtu = this.defaultMtu;\n    }\n  }\n\n  get isConnected() {\n    return this.status == \"connected\";\n  }\n\n  get isAvailable() {\n    return false;\n  }\n\n  /** @throws {Error} if connected */\n  protected assertIsNotConnected() {\n    _console.assertWithError(!this.isConnected, \"device is already connected\");\n  }\n  /** @throws {Error} if connecting */\n  #assertIsNotConnecting() {\n    _console.assertWithError(\n      this.status != \"connecting\",\n      \"device is already connecting\"\n    );\n  }\n  /** @throws {Error} if not connected */\n  protected assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"device is not connected\");\n  }\n  /** @throws {Error} if disconnecting */\n  #assertIsNotDisconnecting() {\n    _console.assertWithError(\n      this.status != \"disconnecting\",\n      \"device is already disconnecting\"\n    );\n  }\n  /** @throws {Error} if not connected or is disconnecting */\n  assertIsConnectedAndNotDisconnecting() {\n    this.assertIsConnected();\n    this.#assertIsNotDisconnecting();\n  }\n\n  async connect() {\n    this.assertIsNotConnected();\n    this.#assertIsNotConnecting();\n    this.status = \"connecting\";\n  }\n  get canReconnect() {\n    return false;\n  }\n  async reconnect() {\n    this.assertIsNotConnected();\n    this.#assertIsNotConnecting();\n    _console.assertWithError(this.canReconnect, \"unable to reconnect\");\n    this.status = \"connecting\";\n    _console.log(\"attempting to reconnect...\");\n  }\n  async disconnect() {\n    this.assertIsConnected();\n    this.#assertIsNotDisconnecting();\n    this.status = \"disconnecting\";\n    _console.log(\"disconnecting from device...\");\n  }\n\n  async sendSmpMessage(data: ArrayBuffer) {\n    this.assertIsConnectedAndNotDisconnecting();\n    _console.log(\"sending smp message\", data);\n  }\n\n  #pendingMessages: TxMessage[] = [];\n  #isSendingMessages = false;\n  async sendTxMessages(\n    messages: TxMessage[] | undefined,\n    sendImmediately: boolean = true\n  ) {\n    this.assertIsConnectedAndNotDisconnecting();\n\n    if (messages) {\n      this.#pendingMessages.push(...messages);\n      _console.log(`appended ${messages.length} messages`);\n    }\n\n    if (!sendImmediately) {\n      _console.log(\"not sending immediately - waiting until later\");\n      return;\n    }\n\n    if (this.#isSendingMessages) {\n      _console.log(\"already sending messages - waiting until later\");\n      return;\n    }\n    if (this.#pendingMessages.length == 0) {\n      _console.log(\"no pendingMessages\");\n      return;\n    }\n    this.#isSendingMessages = true;\n\n    _console.log(\"sendTxMessages\", this.#pendingMessages.slice());\n\n    const arrayBuffers = this.#pendingMessages.map((message) => {\n      BaseConnectionManager.#AssertValidTxRxMessageType(message.type);\n      const messageTypeEnum = TxRxMessageTypes.indexOf(message.type);\n      const dataLength = new DataView(new ArrayBuffer(2));\n      dataLength.setUint16(0, message.data?.byteLength || 0, true);\n      return concatenateArrayBuffers(messageTypeEnum, dataLength, message.data);\n    });\n    this.#pendingMessages.length = 0;\n\n    if (this.mtu) {\n      while (arrayBuffers.length > 0) {\n        if (\n          arrayBuffers.every(\n            (arrayBuffer) => arrayBuffer.byteLength > this.mtu! - 3\n          )\n        ) {\n          _console.log(\"every arrayBuffer is too big to send\");\n          break;\n        }\n        _console.log(\"remaining arrayBuffers.length\", arrayBuffers.length);\n        let arrayBufferByteLength = 0;\n        let arrayBufferCount = 0;\n        arrayBuffers.some((arrayBuffer) => {\n          if (arrayBufferByteLength + arrayBuffer.byteLength > this.mtu! - 3) {\n            _console.log(\n              `stopping appending arrayBuffers ( length ${arrayBuffer.byteLength} too much)`\n            );\n            return true;\n          }\n          _console.log(\n            `allowing arrayBuffer with length ${arrayBuffer.byteLength}`\n          );\n          arrayBufferCount++;\n          arrayBufferByteLength += arrayBuffer.byteLength;\n        });\n        const arrayBuffersToSend = arrayBuffers.splice(0, arrayBufferCount);\n        _console.log({ arrayBufferCount, arrayBuffersToSend });\n\n        const arrayBuffer = concatenateArrayBuffers(...arrayBuffersToSend);\n        _console.log(\"sending arrayBuffer (partitioned)\", arrayBuffer);\n        await this.sendTxData(arrayBuffer);\n      }\n    } else {\n      const arrayBuffer = concatenateArrayBuffers(...arrayBuffers);\n      _console.log(\"sending arrayBuffer (all)\", arrayBuffer);\n      await this.sendTxData(arrayBuffer);\n    }\n\n    this.#isSendingMessages = false;\n\n    this.sendTxMessages(undefined, true);\n  }\n\n  protected defaultMtu = 23;\n  //mtu?: number;\n  mtu?: number = this.defaultMtu;\n\n  async sendTxData(data: ArrayBuffer) {\n    _console.log(\"sendTxData\", data);\n  }\n\n  parseRxMessage(dataView: DataView) {\n    parseMessage(\n      dataView,\n      TxRxMessageTypes,\n      this.#onRxMessage.bind(this),\n      null,\n      true\n    );\n    this.onMessagesReceived!();\n  }\n\n  #onRxMessage(messageType: TxRxMessageType, dataView: DataView) {\n    _console.log({ messageType, dataView });\n    this.onMessageReceived!(messageType, dataView);\n  }\n\n  #timer = new Timer(this.#checkConnection.bind(this), 5000);\n  #checkConnection() {\n    //console.log(\"checking connection...\");\n    if (!this.isConnected) {\n      _console.log(\"timer detected disconnection\");\n      this.status = \"notConnected\";\n    }\n  }\n\n  clear() {\n    this.#isSendingMessages = false;\n    this.#pendingMessages.length = 0;\n  }\n\n  remove() {\n    this.clear();\n\n    this.onStatusUpdated = undefined;\n    this.onMessageReceived = undefined;\n    this.onMessagesReceived = undefined;\n  }\n}\n\nexport default BaseConnectionManager;\n","export function spacesToPascalCase(string: string) {\n  return string\n    .replace(/(?:^\\w|\\b\\w)/g, function (match) {\n      return match.toUpperCase();\n    })\n    .replace(/\\s+/g, \"\");\n}\n\nexport function capitalizeFirstCharacter(string: string) {\n  return string[0].toUpperCase() + string.slice(1);\n}\n","import { createConsole } from \"./Console.ts\";\nimport { spacesToPascalCase } from \"./stringUtils.ts\";\n\nconst _console = createConsole(\"EventUtils\", { log: false });\n\ntype BoundEventListeners = { [eventType: string]: EventListener };\nexport type BoundGenericEventListeners = { [eventType: string]: Function };\n\nexport function bindEventListeners(\n  eventTypes: readonly string[],\n  boundEventListeners: BoundGenericEventListeners,\n  target: any\n) {\n  _console.log(\"bindEventListeners\", { eventTypes, boundEventListeners, target });\n  eventTypes.forEach((eventType) => {\n    const _eventType = `_on${spacesToPascalCase(eventType)}`;\n    _console.assertWithError(target[_eventType], `no event \"${_eventType}\" found in target`);\n    _console.log(`binding eventType \"${eventType}\" as ${_eventType} from target`, target);\n    const boundEvent = target[_eventType].bind(target);\n    target[_eventType] = boundEvent;\n    boundEventListeners[eventType] = boundEvent;\n  });\n}\n\nexport function addEventListeners(target: any, boundEventListeners: BoundGenericEventListeners) {\n  let addEventListener = target.addEventListener || target.addListener || target.on || target.AddEventListener;\n  _console.assertWithError(addEventListener, \"no add listener function found for target\");\n  addEventListener = addEventListener.bind(target);\n  Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {\n    addEventListener(eventType, eventListener);\n  });\n}\n\nexport function removeEventListeners(target: any, boundEventListeners: BoundGenericEventListeners) {\n  let removeEventListener = target.removeEventListener || target.removeListener || target.RemoveEventListener;\n  _console.assertWithError(removeEventListener, \"no remove listener function found for target\");\n  removeEventListener = removeEventListener.bind(target);\n  Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {\n    removeEventListener(eventType, eventListener);\n  });\n}\n","import {\n  isInBrowser,\n  isInLensStudio,\n  isInNode,\n} from \"../../utils/environment.ts\";\nimport { createConsole } from \"../../utils/Console.ts\";\n\nconst _console = createConsole(\"bluetoothUUIDs\", { log: false });\n\n/** NODE_START */\nimport * as webbluetooth from \"webbluetooth\";\nvar BluetoothUUID = webbluetooth.BluetoothUUID;\n/** NODE_END */\n\n/** BROWSER_START */\nif (isInBrowser) {\n  var BluetoothUUID = window.BluetoothUUID;\n}\n/** BROWSER_END */\n\n/** LS_START */\n\nvar BluetoothUUID = {\n  getService: (uuid: number | string): string => toUUID(uuid),\n\n  getCharacteristic: (uuid: number | string): string => toUUID(uuid),\n\n  getDescriptor: (uuid: number | string): string => toUUID(uuid),\n\n  getCharacteristicName: (uuid: number | string): string | null => null,\n\n  getServiceName: (uuid: number | string): string | null => null,\n\n  getDescriptorName: (uuid: number | string): string | null => null,\n};\n\nfunction toUUID(uuid: number | string): string {\n  if (typeof uuid === \"number\") {\n    uuid = uuid.toString(16).padStart(4, \"0\");\n  }\n\n  if (/^[0-9a-fA-F]{4,8}$/.test(uuid)) {\n    return `0000${uuid.padStart(8, \"0\")}-0000-1000-8000-00805f9b34fb`;\n  }\n\n  return uuid.toLowerCase();\n}\n\n/** LS_END */\n\nfunction generateBluetoothUUID(value: string): BluetoothServiceUUID {\n  _console.assertTypeWithError(value, \"string\");\n  _console.assertWithError(\n    value.length == 4,\n    \"value must be 4 characters long\"\n  );\n  return `ea6d${value}-a725-4f9b-893d-c3913e33b39f`;\n}\n\nfunction stringToCharacteristicUUID(\n  identifier: string\n): BluetoothCharacteristicUUID {\n  return BluetoothUUID?.getCharacteristic?.(identifier);\n}\n\nfunction stringToServiceUUID(identifier: string): BluetoothServiceUUID {\n  return BluetoothUUID?.getService?.(identifier);\n}\n\nexport type BluetoothServiceName =\n  | \"deviceInformation\"\n  | \"battery\"\n  | \"main\"\n  | \"smp\";\nimport { DeviceInformationType } from \"../../DeviceInformationManager.ts\";\nexport type BluetoothCharacteristicName =\n  | DeviceInformationType\n  | \"batteryLevel\"\n  | \"rx\"\n  | \"tx\"\n  | \"smp\";\n\ninterface BluetoothCharacteristicInformation {\n  uuid: BluetoothCharacteristicUUID;\n}\ninterface BluetoothServiceInformation {\n  uuid: BluetoothServiceUUID;\n  characteristics: {\n    [characteristicName in BluetoothCharacteristicName]?: BluetoothCharacteristicInformation;\n  };\n}\ninterface BluetoothServicesInformation {\n  services: {\n    [serviceName in BluetoothServiceName]: BluetoothServiceInformation;\n  };\n}\nconst bluetoothUUIDs: BluetoothServicesInformation = Object.freeze({\n  services: {\n    deviceInformation: {\n      uuid: stringToServiceUUID(\"device_information\"),\n      characteristics: {\n        manufacturerName: {\n          uuid: stringToCharacteristicUUID(\"manufacturer_name_string\"),\n        },\n        modelNumber: {\n          uuid: stringToCharacteristicUUID(\"model_number_string\"),\n        },\n        hardwareRevision: {\n          uuid: stringToCharacteristicUUID(\"hardware_revision_string\"),\n        },\n        firmwareRevision: {\n          uuid: stringToCharacteristicUUID(\"firmware_revision_string\"),\n        },\n        softwareRevision: {\n          uuid: stringToCharacteristicUUID(\"software_revision_string\"),\n        },\n        pnpId: {\n          uuid: stringToCharacteristicUUID(\"pnp_id\"),\n        },\n        serialNumber: {\n          uuid: stringToCharacteristicUUID(\"serial_number_string\"),\n        },\n      },\n    },\n    battery: {\n      uuid: stringToServiceUUID(\"battery_service\"),\n      characteristics: {\n        batteryLevel: {\n          uuid: stringToCharacteristicUUID(\"battery_level\"),\n        },\n      },\n    },\n    main: {\n      uuid: generateBluetoothUUID(\"0000\"),\n      characteristics: {\n        rx: { uuid: generateBluetoothUUID(\"1000\") },\n        tx: { uuid: generateBluetoothUUID(\"1001\") },\n      },\n    },\n    smp: {\n      uuid: \"8d53dc1d-1db7-4cd3-868b-8a527460aa84\",\n      characteristics: {\n        smp: { uuid: \"da2e7828-fbce-4e01-ae9e-261174997c48\" },\n      },\n    },\n  },\n});\n\nexport const serviceUUIDs = [bluetoothUUIDs.services.main.uuid];\nexport const optionalServiceUUIDs = [\n  bluetoothUUIDs.services.deviceInformation.uuid,\n  bluetoothUUIDs.services.battery.uuid,\n  bluetoothUUIDs.services.smp.uuid,\n];\nexport const allServiceUUIDs = [...serviceUUIDs, ...optionalServiceUUIDs];\n\nexport function getServiceNameFromUUID(\n  serviceUUID: BluetoothServiceUUID\n): BluetoothServiceName | undefined {\n  serviceUUID = serviceUUID.toString().toLowerCase();\n  const serviceNames = Object.keys(\n    bluetoothUUIDs.services\n  ) as BluetoothServiceName[];\n  return serviceNames.find((serviceName) => {\n    const serviceInfo = bluetoothUUIDs.services[serviceName];\n    let serviceInfoUUID = serviceInfo.uuid.toString();\n    if (serviceUUID.length == 4) {\n      serviceInfoUUID = serviceInfoUUID.slice(4, 8);\n    }\n    if (!serviceUUID.includes(\"-\")) {\n      serviceInfoUUID = serviceInfoUUID.replaceAll(\"-\", \"\");\n    }\n    return serviceUUID == serviceInfoUUID;\n  });\n}\n\nexport const characteristicUUIDs: BluetoothCharacteristicUUID[] = [];\nexport const allCharacteristicUUIDs: BluetoothCharacteristicUUID[] = [];\n\nexport const characteristicNames: BluetoothCharacteristicName[] = [];\nexport const allCharacteristicNames: BluetoothCharacteristicName[] = [];\n\nObject.values(bluetoothUUIDs.services).forEach((serviceInfo) => {\n  if (!serviceInfo.characteristics) {\n    return;\n  }\n  const characteristicNames = Object.keys(\n    serviceInfo.characteristics\n  ) as BluetoothCharacteristicName[];\n  characteristicNames.forEach((characteristicName) => {\n    const characteristicInfo = serviceInfo.characteristics[characteristicName]!;\n    if (serviceUUIDs.includes(serviceInfo.uuid)) {\n      characteristicUUIDs.push(characteristicInfo.uuid);\n      characteristicNames.push(characteristicName);\n    }\n    allCharacteristicUUIDs.push(characteristicInfo.uuid);\n    allCharacteristicNames.push(characteristicName);\n  });\n}, []);\n\n//_console.log({ characteristicUUIDs, allCharacteristicUUIDs });\n\nexport function getCharacteristicNameFromUUID(\n  characteristicUUID: BluetoothCharacteristicUUID\n): BluetoothCharacteristicName | undefined {\n  //_console.log({ characteristicUUID });\n  characteristicUUID = characteristicUUID.toString().toLowerCase();\n  var characteristicName: BluetoothCharacteristicName | undefined;\n  Object.values(bluetoothUUIDs.services).some((serviceInfo) => {\n    const characteristicNames = Object.keys(\n      serviceInfo.characteristics\n    ) as BluetoothCharacteristicName[];\n    characteristicName = characteristicNames.find((_characteristicName) => {\n      const characteristicInfo =\n        serviceInfo.characteristics[_characteristicName]!;\n      let characteristicInfoUUID = characteristicInfo.uuid.toString();\n      if (characteristicUUID.length == 4) {\n        characteristicInfoUUID = characteristicInfoUUID.slice(4, 8);\n      }\n      if (!characteristicUUID.includes(\"-\")) {\n        characteristicInfoUUID = characteristicInfoUUID.replaceAll(\"-\", \"\");\n      }\n      return characteristicUUID == characteristicInfoUUID;\n    });\n    return characteristicName;\n  });\n  return characteristicName;\n}\n\nexport function getCharacteristicProperties(\n  characteristicName: BluetoothCharacteristicName\n): BluetoothCharacteristicProperties {\n  const properties = {\n    broadcast: false,\n    read: true,\n    writeWithoutResponse: false,\n    write: false,\n    notify: false,\n    indicate: false,\n    authenticatedSignedWrites: false,\n    reliableWrite: false,\n    writableAuxiliaries: false,\n  };\n\n  // read\n  switch (characteristicName) {\n    case \"rx\":\n    case \"tx\":\n    case \"smp\":\n      properties.read = false;\n      break;\n  }\n\n  // notify\n  switch (characteristicName) {\n    case \"batteryLevel\":\n    case \"rx\":\n    case \"smp\":\n      properties.notify = true;\n      break;\n  }\n\n  // write without response\n  switch (characteristicName) {\n    case \"smp\":\n      properties.writeWithoutResponse = true;\n      break;\n  }\n\n  // write\n  switch (characteristicName) {\n    case \"tx\":\n      properties.write = true;\n      break;\n  }\n\n  return properties;\n}\n\nexport const serviceDataUUID = \"0000\";\n","import { createConsole } from \"../../utils/Console.ts\";\nimport BaseConnectionManager from \"../BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"BluetoothConnectionManager\", { log: false });\n\nimport { BluetoothCharacteristicName } from \"./bluetoothUUIDs.ts\";\n\nabstract class BluetoothConnectionManager extends BaseConnectionManager {\n  get isAvailable() {\n    // no way to tell if the user has turned bluetooth on or off\n    return true;\n  }\n\n  isInRange = true;\n\n  protected onCharacteristicValueChanged(\n    characteristicName: BluetoothCharacteristicName,\n    dataView: DataView\n  ) {\n    if (characteristicName == \"rx\") {\n      this.parseRxMessage(dataView);\n    } else {\n      this.onMessageReceived?.(characteristicName, dataView);\n    }\n  }\n\n  protected async writeCharacteristic(\n    characteristicName: BluetoothCharacteristicName,\n    data: ArrayBuffer\n  ) {\n    _console.log(\"writeCharacteristic\", ...arguments);\n  }\n\n  async sendSmpMessage(data: ArrayBuffer) {\n    super.sendSmpMessage(data);\n    await this.writeCharacteristic(\"smp\", data);\n  }\n\n  async sendTxData(data: ArrayBuffer) {\n    super.sendTxData(data);\n    if (data.byteLength == 0) {\n      return;\n    }\n    await this.writeCharacteristic(\"tx\", data);\n  }\n}\n\nexport default BluetoothConnectionManager;\n","import { createConsole } from \"../../utils/Console.ts\";\nimport {\n  isInNode,\n  isInBrowser,\n  isInBluefy,\n  isInWebBLE,\n} from \"../../utils/environment.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../../utils/EventUtils.ts\";\nimport {\n  serviceUUIDs,\n  optionalServiceUUIDs,\n  getServiceNameFromUUID,\n  getCharacteristicNameFromUUID,\n  getCharacteristicProperties,\n} from \"./bluetoothUUIDs.ts\";\nimport BluetoothConnectionManager from \"./BluetoothConnectionManager.ts\";\nimport {\n  BluetoothCharacteristicName,\n  BluetoothServiceName,\n} from \"./bluetoothUUIDs.ts\";\nimport { ConnectionType } from \"../BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"WebBluetoothConnectionManager\", { log: false });\n\ntype WebBluetoothInterface = webbluetooth.Bluetooth | Bluetooth;\n\ninterface BluetoothService extends BluetoothRemoteGATTService {\n  name?: BluetoothServiceName;\n}\ninterface BluetoothCharacteristic extends BluetoothRemoteGATTCharacteristic {\n  name?: BluetoothCharacteristicName;\n}\n\nvar bluetooth: WebBluetoothInterface | undefined;\n/** NODE_START */\nimport * as webbluetooth from \"webbluetooth\";\nif (isInNode) {\n  bluetooth = webbluetooth.bluetooth;\n}\n/** NODE_END */\n\n/** BROWSER_START */\nif (isInBrowser) {\n  bluetooth = window.navigator.bluetooth;\n}\n/** BROWSER_END */\n\nclass WebBluetoothConnectionManager extends BluetoothConnectionManager {\n  get bluetoothId() {\n    return this.device!.id;\n  }\n\n  get canUpdateFirmware() {\n    return this.#characteristics.has(\"smp\");\n  }\n\n  #boundBluetoothCharacteristicEventListeners: {\n    [eventType: string]: EventListener;\n  } = {\n    characteristicvaluechanged: this.#onCharacteristicvaluechanged.bind(this),\n  };\n  #boundBluetoothDeviceEventListeners: { [eventType: string]: EventListener } =\n    {\n      gattserverdisconnected: this.#onGattserverdisconnected.bind(this),\n    };\n\n  static get isSupported() {\n    return Boolean(bluetooth);\n  }\n  static get type(): ConnectionType {\n    return \"webBluetooth\";\n  }\n\n  #device?: BluetoothDevice;\n  get device() {\n    return this.#device;\n  }\n  set device(newDevice) {\n    if (this.#device == newDevice) {\n      _console.log(\"tried to assign the same BluetoothDevice\");\n      return;\n    }\n    if (this.#device) {\n      removeEventListeners(\n        this.#device,\n        this.#boundBluetoothDeviceEventListeners\n      );\n    }\n    if (newDevice) {\n      addEventListeners(newDevice, this.#boundBluetoothDeviceEventListeners);\n    }\n    this.#device = newDevice;\n  }\n\n  get server(): BluetoothRemoteGATTServer | undefined {\n    return this.#device?.gatt;\n  }\n  get isConnected() {\n    return this.server?.connected || false;\n  }\n\n  #services: Map<BluetoothServiceName, BluetoothService> = new Map();\n  #characteristics: Map<BluetoothCharacteristicName, BluetoothCharacteristic> =\n    new Map();\n\n  async connect() {\n    await super.connect();\n\n    try {\n      const device = await bluetooth!.requestDevice({\n        filters: [{ services: serviceUUIDs }],\n        optionalServices: isInBrowser ? optionalServiceUUIDs : [],\n      });\n\n      _console.log(\"got BluetoothDevice\");\n      this.device = device;\n\n      _console.log(\"connecting to device...\");\n      const server = await this.server!.connect();\n      _console.log(`connected to device? ${server.connected}`);\n\n      await this.#getServicesAndCharacteristics();\n\n      _console.log(\"fully connected\");\n\n      this.status = \"connected\";\n    } catch (error) {\n      _console.error(error);\n      this.status = \"notConnected\";\n      this.server?.disconnect();\n      this.#removeEventListeners();\n    }\n  }\n  async #getServicesAndCharacteristics() {\n    this.#removeEventListeners();\n\n    _console.log(\"getting services...\");\n    const services = await this.server!.getPrimaryServices();\n    _console.log(\"got services\", services.length);\n    //const service = await this.server!.getPrimaryService(\"8d53dc1d-1db7-4cd3-868b-8a527460aa84\");\n\n    _console.log(\"getting characteristics...\");\n    for (const serviceIndex in services) {\n      const service = services[serviceIndex] as BluetoothService;\n      _console.log({ service });\n      const serviceName = getServiceNameFromUUID(service.uuid)!;\n      _console.assertWithError(\n        serviceName,\n        `no name found for service uuid \"${service.uuid}\"`\n      );\n      _console.log(`got \"${serviceName}\" service`);\n      service.name = serviceName;\n      this.#services.set(serviceName, service);\n      _console.log(`getting characteristics for \"${serviceName}\" service`);\n      const characteristics = await service.getCharacteristics();\n      _console.log(`got characteristics for \"${serviceName}\" service`);\n      for (const characteristicIndex in characteristics) {\n        const characteristic = characteristics[\n          characteristicIndex\n        ] as BluetoothCharacteristic;\n        _console.log({ characteristic });\n        const characteristicName = getCharacteristicNameFromUUID(\n          characteristic.uuid\n        )!;\n        _console.assertWithError(\n          Boolean(characteristicName),\n          `no name found for characteristic uuid \"${characteristic.uuid}\" in \"${serviceName}\" service`\n        );\n        _console.log(\n          `got \"${characteristicName}\" characteristic in \"${serviceName}\" service`\n        );\n        characteristic.name = characteristicName;\n        this.#characteristics.set(characteristicName, characteristic);\n        addEventListeners(\n          characteristic,\n          this.#boundBluetoothCharacteristicEventListeners\n        );\n        const characteristicProperties =\n          characteristic.properties ||\n          getCharacteristicProperties(characteristicName);\n        if (characteristicProperties.notify) {\n          _console.log(\n            `starting notifications for \"${characteristicName}\" characteristic`\n          );\n          await characteristic.startNotifications();\n        }\n        if (characteristicProperties.read) {\n          _console.log(`reading \"${characteristicName}\" characteristic...`);\n          await characteristic.readValue();\n          if (isInBluefy || isInWebBLE) {\n            this.#onCharacteristicValueChanged(characteristic);\n          }\n        }\n      }\n    }\n  }\n  async #removeEventListeners() {\n    if (this.device) {\n      removeEventListeners(\n        this.device,\n        this.#boundBluetoothDeviceEventListeners\n      );\n    }\n\n    const promises = Array.from(this.#characteristics.keys()).map(\n      (characteristicName) => {\n        const characteristic = this.#characteristics.get(characteristicName)!;\n        removeEventListeners(\n          characteristic,\n          this.#boundBluetoothCharacteristicEventListeners\n        );\n        const characteristicProperties =\n          characteristic.properties ||\n          getCharacteristicProperties(characteristicName);\n        if (characteristicProperties.notify) {\n          _console.log(\n            `stopping notifications for \"${characteristicName}\" characteristic`\n          );\n          return characteristic.stopNotifications();\n        }\n      }\n    );\n\n    return Promise.allSettled(promises);\n  }\n  async disconnect() {\n    await this.#removeEventListeners();\n    await super.disconnect();\n    this.server?.disconnect();\n    this.status = \"notConnected\";\n  }\n\n  #onCharacteristicvaluechanged(event: Event) {\n    _console.log(\"oncharacteristicvaluechanged\");\n\n    const characteristic = event.target as BluetoothCharacteristic;\n    this.#onCharacteristicValueChanged(characteristic);\n  }\n\n  #onCharacteristicValueChanged(characteristic: BluetoothCharacteristic) {\n    _console.log(\"onCharacteristicValue\");\n\n    const characteristicName = characteristic.name!;\n    _console.assertWithError(\n      Boolean(characteristicName),\n      `no name found for characteristic with uuid \"${characteristic.uuid}\"`\n    );\n\n    _console.log(\n      `oncharacteristicvaluechanged for \"${characteristicName}\" characteristic`\n    );\n    const dataView = characteristic.value!;\n    _console.assertWithError(\n      dataView,\n      `no data found for \"${characteristicName}\" characteristic`\n    );\n    _console.log(\n      `data for \"${characteristicName}\" characteristic`,\n      Array.from(new Uint8Array(dataView.buffer))\n    );\n\n    try {\n      this.onCharacteristicValueChanged(characteristicName, dataView);\n    } catch (error) {\n      _console.error(error);\n    }\n  }\n\n  async writeCharacteristic(\n    characteristicName: BluetoothCharacteristicName,\n    data: ArrayBuffer\n  ) {\n    super.writeCharacteristic(characteristicName, data);\n\n    const characteristic = this.#characteristics.get(characteristicName)!;\n    _console.assertWithError(\n      characteristic,\n      `${characteristicName} characteristic not found`\n    );\n    _console.log(\"writing characteristic\", characteristic, data);\n    const characteristicProperties =\n      characteristic.properties ||\n      getCharacteristicProperties(characteristicName);\n    if (characteristicProperties.writeWithoutResponse) {\n      _console.log(\"writing without response\");\n      await characteristic.writeValueWithoutResponse(data);\n    } else {\n      _console.log(\"writing with response\");\n      await characteristic.writeValueWithResponse(data);\n    }\n    _console.log(\"wrote characteristic\");\n\n    if (characteristicProperties.read && !characteristicProperties.notify) {\n      _console.log(\"reading value after write...\");\n      await characteristic.readValue();\n      if (isInBluefy || isInWebBLE) {\n        this.#onCharacteristicValueChanged(characteristic);\n      }\n    }\n  }\n\n  #onGattserverdisconnected() {\n    _console.log(\"gattserverdisconnected\");\n    this.status = \"notConnected\";\n  }\n\n  get canReconnect() {\n    return Boolean(this.server && !this.server.connected && this.isInRange);\n  }\n  async reconnect() {\n    await super.reconnect();\n    try {\n      await this.server!.connect();\n    } catch (error) {\n      _console.error(error);\n      this.isInRange = false;\n    }\n\n    if (this.isConnected) {\n      _console.log(\"successfully reconnected!\");\n      await this.#getServicesAndCharacteristics();\n      this.status = \"connected\";\n    } else {\n      _console.log(\"unable to reconnect\");\n      this.status = \"notConnected\";\n    }\n  }\n\n  remove() {\n    super.remove();\n    this.device = undefined;\n  }\n}\n\nexport default WebBluetoothConnectionManager;\n","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2016 Patrick Gansterer <paroga@paroga.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst POW_2_24 = 5.960464477539063e-8;\nconst POW_2_32 = 4294967296;\nconst POW_2_53 = 9007199254740992;\n\nexport function encode(value) {\n  let data = new ArrayBuffer(256);\n  let dataView = new DataView(data);\n  let lastLength;\n  let offset = 0;\n\n  function prepareWrite(length) {\n    let newByteLength = data.byteLength;\n    const requiredLength = offset + length;\n    while (newByteLength < requiredLength) {\n      newByteLength <<= 1;\n    }\n    if (newByteLength !== data.byteLength) {\n      const oldDataView = dataView;\n      data = new ArrayBuffer(newByteLength);\n      dataView = new DataView(data);\n      const uint32count = (offset + 3) >> 2;\n      for (let i = 0; i < uint32count; ++i) {\n        dataView.setUint32(i << 2, oldDataView.getUint32(i << 2));\n      }\n    }\n\n    lastLength = length;\n    return dataView;\n  }\n  function commitWrite() {\n    offset += lastLength;\n  }\n  function writeFloat64(value) {\n    commitWrite(prepareWrite(8).setFloat64(offset, value));\n  }\n  function writeUint8(value) {\n    commitWrite(prepareWrite(1).setUint8(offset, value));\n  }\n  function writeUint8Array(value) {\n    const dataView = prepareWrite(value.length);\n    for (let i = 0; i < value.length; ++i) {\n      dataView.setUint8(offset + i, value[i]);\n    }\n    commitWrite();\n  }\n  function writeUint16(value) {\n    commitWrite(prepareWrite(2).setUint16(offset, value));\n  }\n  function writeUint32(value) {\n    commitWrite(prepareWrite(4).setUint32(offset, value));\n  }\n  function writeUint64(value) {\n    const low = value % POW_2_32;\n    const high = (value - low) / POW_2_32;\n    const dataView = prepareWrite(8);\n    dataView.setUint32(offset, high);\n    dataView.setUint32(offset + 4, low);\n    commitWrite();\n  }\n  function writeTypeAndLength(type, length) {\n    if (length < 24) {\n      writeUint8((type << 5) | length);\n    } else if (length < 0x100) {\n      writeUint8((type << 5) | 24);\n      writeUint8(length);\n    } else if (length < 0x10000) {\n      writeUint8((type << 5) | 25);\n      writeUint16(length);\n    } else if (length < 0x100000000) {\n      writeUint8((type << 5) | 26);\n      writeUint32(length);\n    } else {\n      writeUint8((type << 5) | 27);\n      writeUint64(length);\n    }\n  }\n\n  function encodeItem(value) {\n    let i;\n    const utf8data = [];\n    let length;\n\n    if (value === false) {\n      return writeUint8(0xf4);\n    }\n    if (value === true) {\n      return writeUint8(0xf5);\n    }\n    if (value === null) {\n      return writeUint8(0xf6);\n    }\n    if (value === undefined) {\n      return writeUint8(0xf7);\n    }\n\n    switch (typeof value) {\n      case \"number\":\n        if (Math.floor(value) === value) {\n          if (value >= 0 && value <= POW_2_53) {\n            return writeTypeAndLength(0, value);\n          }\n          if (-POW_2_53 <= value && value < 0) {\n            return writeTypeAndLength(1, -(value + 1));\n          }\n        }\n        writeUint8(0xfb);\n        return writeFloat64(value);\n\n      case \"string\":\n        for (i = 0; i < value.length; ++i) {\n          let charCode = value.charCodeAt(i);\n          if (charCode < 0x80) {\n            utf8data.push(charCode);\n          } else if (charCode < 0x800) {\n            utf8data.push(0xc0 | (charCode >> 6));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          } else if (charCode < 0xd800) {\n            utf8data.push(0xe0 | (charCode >> 12));\n            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          } else {\n            charCode = (charCode & 0x3ff) << 10;\n            charCode |= value.charCodeAt(++i) & 0x3ff;\n            charCode += 0x10000;\n\n            utf8data.push(0xf0 | (charCode >> 18));\n            utf8data.push(0x80 | ((charCode >> 12) & 0x3f));\n            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          }\n        }\n\n        writeTypeAndLength(3, utf8data.length);\n        return writeUint8Array(utf8data);\n\n      default:\n        if (Array.isArray(value)) {\n          length = value.length;\n          writeTypeAndLength(4, length);\n          for (i = 0; i < length; ++i) {\n            encodeItem(value[i]);\n          }\n        } else if (value instanceof Uint8Array) {\n          writeTypeAndLength(2, value.length);\n          writeUint8Array(value);\n        } else {\n          const keys = Object.keys(value);\n          length = keys.length;\n          writeTypeAndLength(5, length);\n          for (i = 0; i < length; ++i) {\n            const key = keys[i];\n            encodeItem(key);\n            encodeItem(value[key]);\n          }\n        }\n    }\n  }\n\n  encodeItem(value);\n\n  if (\"slice\" in data) {\n    return data.slice(0, offset);\n  }\n\n  const ret = new ArrayBuffer(offset);\n  const retView = new DataView(ret);\n  for (let i = 0; i < offset; ++i) {\n    retView.setUint8(i, dataView.getUint8(i));\n  }\n  return ret;\n}\n\nexport function decode(data, tagger, simpleValue) {\n  const dataView = new DataView(data);\n  let offset = 0;\n\n  if (typeof tagger !== \"function\") {\n    tagger = function (value) {\n      return value;\n    };\n  }\n  if (typeof simpleValue !== \"function\") {\n    simpleValue = function () {\n      return undefined;\n    };\n  }\n\n  function commitRead(length, value) {\n    offset += length;\n    return value;\n  }\n  function readArrayBuffer(length) {\n    return commitRead(length, new Uint8Array(data, offset, length));\n  }\n  function readFloat16() {\n    const tempArrayBuffer = new ArrayBuffer(4);\n    const tempDataView = new DataView(tempArrayBuffer);\n    const value = readUint16();\n\n    const sign = value & 0x8000;\n    let exponent = value & 0x7c00;\n    const fraction = value & 0x03ff;\n\n    if (exponent === 0x7c00) {\n      exponent = 0xff << 10;\n    } else if (exponent !== 0) {\n      exponent += (127 - 15) << 10;\n    } else if (fraction !== 0) {\n      return (sign ? -1 : 1) * fraction * POW_2_24;\n    }\n\n    tempDataView.setUint32(0, (sign << 16) | (exponent << 13) | (fraction << 13));\n    return tempDataView.getFloat32(0);\n  }\n  function readFloat32() {\n    return commitRead(4, dataView.getFloat32(offset));\n  }\n  function readFloat64() {\n    return commitRead(8, dataView.getFloat64(offset));\n  }\n  function readUint8() {\n    return commitRead(1, dataView.getUint8(offset));\n  }\n  function readUint16() {\n    return commitRead(2, dataView.getUint16(offset));\n  }\n  function readUint32() {\n    return commitRead(4, dataView.getUint32(offset));\n  }\n  function readUint64() {\n    return readUint32() * POW_2_32 + readUint32();\n  }\n  function readBreak() {\n    if (dataView.getUint8(offset) !== 0xff) {\n      return false;\n    }\n    offset += 1;\n    return true;\n  }\n  function readLength(additionalInformation) {\n    if (additionalInformation < 24) {\n      return additionalInformation;\n    }\n    if (additionalInformation === 24) {\n      return readUint8();\n    }\n    if (additionalInformation === 25) {\n      return readUint16();\n    }\n    if (additionalInformation === 26) {\n      return readUint32();\n    }\n    if (additionalInformation === 27) {\n      return readUint64();\n    }\n    if (additionalInformation === 31) {\n      return -1;\n    }\n    throw new Error(\"Invalid length encoding\");\n  }\n  function readIndefiniteStringLength(majorType) {\n    const initialByte = readUint8();\n    if (initialByte === 0xff) {\n      return -1;\n    }\n    const length = readLength(initialByte & 0x1f);\n    if (length < 0 || initialByte >> 5 !== majorType) {\n      throw new Error(\"Invalid indefinite length element\");\n    }\n    return length;\n  }\n\n  function appendUtf16Data(utf16data, length) {\n    for (let i = 0; i < length; ++i) {\n      let value = readUint8();\n      if (value & 0x80) {\n        if (value < 0xe0) {\n          value = ((value & 0x1f) << 6) | (readUint8() & 0x3f);\n          length -= 1;\n        } else if (value < 0xf0) {\n          value = ((value & 0x0f) << 12) | ((readUint8() & 0x3f) << 6) | (readUint8() & 0x3f);\n          length -= 2;\n        } else {\n          value =\n            ((value & 0x0f) << 18) | ((readUint8() & 0x3f) << 12) | ((readUint8() & 0x3f) << 6) | (readUint8() & 0x3f);\n          length -= 3;\n        }\n      }\n\n      if (value < 0x10000) {\n        utf16data.push(value);\n      } else {\n        value -= 0x10000;\n        utf16data.push(0xd800 | (value >> 10));\n        utf16data.push(0xdc00 | (value & 0x3ff));\n      }\n    }\n  }\n\n  function decodeItem() {\n    const initialByte = readUint8();\n    const majorType = initialByte >> 5;\n    const additionalInformation = initialByte & 0x1f;\n    let i;\n    let length;\n\n    if (majorType === 7) {\n      switch (additionalInformation) {\n        case 25:\n          return readFloat16();\n        case 26:\n          return readFloat32();\n        case 27:\n          return readFloat64();\n      }\n    }\n\n    length = readLength(additionalInformation);\n    if (length < 0 && (majorType < 2 || majorType > 6)) {\n      throw new Error(\"Invalid length\");\n    }\n\n    const utf16data = [];\n    let retArray;\n    const retObject = {};\n\n    switch (majorType) {\n      case 0:\n        return length;\n      case 1:\n        return -1 - length;\n      case 2:\n        if (length < 0) {\n          const elements = [];\n          let fullArrayLength = 0;\n          while ((length = readIndefiniteStringLength(majorType)) >= 0) {\n            fullArrayLength += length;\n            elements.push(readArrayBuffer(length));\n          }\n          const fullArray = new Uint8Array(fullArrayLength);\n          let fullArrayOffset = 0;\n          for (i = 0; i < elements.length; ++i) {\n            fullArray.set(elements[i], fullArrayOffset);\n            fullArrayOffset += elements[i].length;\n          }\n          return fullArray;\n        }\n        return readArrayBuffer(length);\n      case 3:\n        if (length < 0) {\n          while ((length = readIndefiniteStringLength(majorType)) >= 0) {\n            appendUtf16Data(utf16data, length);\n          }\n        } else {\n          appendUtf16Data(utf16data, length);\n        }\n        return String.fromCharCode.apply(null, utf16data);\n      case 4:\n        if (length < 0) {\n          retArray = [];\n          while (!readBreak()) {\n            retArray.push(decodeItem());\n          }\n        } else {\n          retArray = new Array(length);\n          for (i = 0; i < length; ++i) {\n            retArray[i] = decodeItem();\n          }\n        }\n        return retArray;\n      case 5:\n        for (i = 0; i < length || (length < 0 && !readBreak()); ++i) {\n          const key = decodeItem();\n          retObject[key] = decodeItem();\n        }\n        return retObject;\n      case 6:\n        return tagger(decodeItem(), length);\n      case 7:\n        switch (length) {\n          case 20:\n            return false;\n          case 21:\n            return true;\n          case 22:\n            return null;\n          case 23:\n            return undefined;\n          default:\n            return simpleValue(length);\n        }\n    }\n  }\n\n  const ret = decodeItem();\n  if (offset !== data.byteLength) {\n    throw new Error(\"Remaining bytes\");\n  }\n  return ret;\n}\n\nexport const CBOR = {\n  encode,\n  decode,\n};\n","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2023 Laird Connectivity\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * @file mcumgr\n * @brief Provides MCU manager operation functions for the Xbit USB Shell.\n * This file is inspired by the MIT licensed mcumgr file originally\n * authored by Andras Barthazi (https://github.com/boogie/mcumgr-web),\n * updated to also support file upload/download over SMP.\n */\n\nimport { CBOR } from \"./cbor.js\";\nimport { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"mcumgr\", { log: false });\n\nexport const constants = {\n  // Opcodes\n  MGMT_OP_READ: 0,\n  MGMT_OP_READ_RSP: 1,\n  MGMT_OP_WRITE: 2,\n  MGMT_OP_WRITE_RSP: 3,\n\n  // Groups\n  MGMT_GROUP_ID_OS: 0,\n  MGMT_GROUP_ID_IMAGE: 1,\n  MGMT_GROUP_ID_STAT: 2,\n  MGMT_GROUP_ID_CONFIG: 3,\n  MGMT_GROUP_ID_LOG: 4,\n  MGMT_GROUP_ID_CRASH: 5,\n  MGMT_GROUP_ID_SPLIT: 6,\n  MGMT_GROUP_ID_RUN: 7,\n  MGMT_GROUP_ID_FS: 8,\n  MGMT_GROUP_ID_SHELL: 9,\n\n  // OS group\n  OS_MGMT_ID_ECHO: 0,\n  OS_MGMT_ID_CONS_ECHO_CTRL: 1,\n  OS_MGMT_ID_TASKSTAT: 2,\n  OS_MGMT_ID_MPSTAT: 3,\n  OS_MGMT_ID_DATETIME_STR: 4,\n  OS_MGMT_ID_RESET: 5,\n\n  // Image group\n  IMG_MGMT_ID_STATE: 0,\n  IMG_MGMT_ID_UPLOAD: 1,\n  IMG_MGMT_ID_FILE: 2,\n  IMG_MGMT_ID_CORELIST: 3,\n  IMG_MGMT_ID_CORELOAD: 4,\n  IMG_MGMT_ID_ERASE: 5,\n\n  // Filesystem group\n  FS_MGMT_ID_FILE: 0,\n};\n\nexport class MCUManager {\n  constructor() {\n    this._mtu = 256;\n    this._messageCallback = null;\n    this._imageUploadProgressCallback = null;\n    this._imageUploadNextCallback = null;\n    this._fileUploadProgressCallback = null;\n    this._fileUploadNextCallback = null;\n    this._uploadIsInProgress = false;\n    this._downloadIsInProgress = false;\n    this._buffer = new Uint8Array();\n    this._seq = 0;\n  }\n\n  onMessage(callback) {\n    this._messageCallback = callback;\n    return this;\n  }\n\n  onImageUploadNext(callback) {\n    this._imageUploadNextCallback = callback;\n    return this;\n  }\n\n  onImageUploadProgress(callback) {\n    this._imageUploadProgressCallback = callback;\n    return this;\n  }\n\n  onImageUploadFinished(callback) {\n    this._imageUploadFinishedCallback = callback;\n    return this;\n  }\n\n  onFileUploadNext(callback) {\n    this._fileUploadNextCallback = callback;\n    return this;\n  }\n\n  onFileUploadProgress(callback) {\n    this._fileUploadProgressCallback = callback;\n    return this;\n  }\n\n  onFileUploadFinished(callback) {\n    this._fileUploadFinishedCallback = callback;\n    return this;\n  }\n\n  onFileDownloadNext(callback) {\n    this._fileDownloadNextCallback = callback;\n    return this;\n  }\n\n  onFileDownloadProgress(callback) {\n    this._fileDownloadProgressCallback = callback;\n    return this;\n  }\n\n  onFileDownloadFinished(callback) {\n    this._fileDownloadFinishedCallback = callback;\n    return this;\n  }\n\n  _getMessage(op, group, id, data) {\n    const _flags = 0;\n    let encodedData = [];\n    if (typeof data !== \"undefined\") {\n      encodedData = [...new Uint8Array(CBOR.encode(data))];\n    }\n    const lengthLo = encodedData.length & 255;\n    const lengthHi = encodedData.length >> 8;\n    const groupLo = group & 255;\n    const groupHi = group >> 8;\n    const message = [op, _flags, lengthHi, lengthLo, groupHi, groupLo, this._seq, id, ...encodedData];\n    this._seq = (this._seq + 1) % 256;\n\n    return message;\n  }\n\n  _notification(buffer) {\n    _console.log(\"mcumgr - message received\");\n    const message = new Uint8Array(buffer);\n    this._buffer = new Uint8Array([...this._buffer, ...message]);\n    const messageLength = this._buffer[2] * 256 + this._buffer[3];\n    if (this._buffer.length < messageLength + 8) return;\n    this._processMessage(this._buffer.slice(0, messageLength + 8));\n    this._buffer = this._buffer.slice(messageLength + 8);\n  }\n\n  _processMessage(message) {\n    const [op, , lengthHi, lengthLo, groupHi, groupLo, , id] = message;\n    const data = CBOR.decode(message.slice(8).buffer);\n    const length = lengthHi * 256 + lengthLo;\n    const group = groupHi * 256 + groupLo;\n\n    _console.log(\"mcumgr - Process Message - Group: \" + group + \", Id: \" + id + \", Off: \" + data.off);\n    if (group === constants.MGMT_GROUP_ID_IMAGE && id === constants.IMG_MGMT_ID_UPLOAD && data.off) {\n      this._uploadOffset = data.off;\n      this._uploadNext();\n      return;\n    }\n    if (\n      op === constants.MGMT_OP_WRITE_RSP &&\n      group === constants.MGMT_GROUP_ID_FS &&\n      id === constants.FS_MGMT_ID_FILE &&\n      data.off\n    ) {\n      this._uploadFileOffset = data.off;\n      this._uploadFileNext();\n      return;\n    }\n    if (op === constants.MGMT_OP_READ_RSP && group === constants.MGMT_GROUP_ID_FS && id === constants.FS_MGMT_ID_FILE) {\n      this._downloadFileOffset += data.data.length;\n      if (data.len != undefined) {\n        this._downloadFileLength = data.len;\n      }\n      _console.log(\"downloaded \" + this._downloadFileOffset + \" bytes of \" + this._downloadFileLength);\n      if (this._downloadFileLength > 0) {\n        this._fileDownloadProgressCallback({\n          percentage: Math.floor((this._downloadFileOffset / this._downloadFileLength) * 100),\n        });\n      }\n      if (this._messageCallback) this._messageCallback({ op, group, id, data, length });\n      this._downloadFileNext();\n      return;\n    }\n\n    if (this._messageCallback) this._messageCallback({ op, group, id, data, length });\n  }\n\n  cmdReset() {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_OS, constants.OS_MGMT_ID_RESET);\n  }\n\n  smpEcho(message) {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_OS, constants.OS_MGMT_ID_ECHO, {\n      d: message,\n    });\n  }\n\n  cmdImageState() {\n    return this._getMessage(constants.MGMT_OP_READ, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE);\n  }\n\n  cmdImageErase() {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_ERASE, {});\n  }\n\n  cmdImageTest(hash) {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE, {\n      hash,\n      confirm: false,\n    });\n  }\n\n  cmdImageConfirm(hash) {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE, {\n      hash,\n      confirm: true,\n    });\n  }\n\n  _hash(image) {\n    return crypto.subtle.digest(\"SHA-256\", image);\n  }\n\n  async _uploadNext() {\n    if (!this._uploadImage) {\n      return;\n    }\n\n    if (this._uploadOffset >= this._uploadImage.byteLength) {\n      this._uploadIsInProgress = false;\n      this._imageUploadFinishedCallback();\n      return;\n    }\n\n    const nmpOverhead = 8;\n    const message = { data: new Uint8Array(), off: this._uploadOffset };\n    if (this._uploadOffset === 0) {\n      message.len = this._uploadImage.byteLength;\n      message.sha = new Uint8Array(await this._hash(this._uploadImage));\n    }\n    this._imageUploadProgressCallback({\n      percentage: Math.floor((this._uploadOffset / this._uploadImage.byteLength) * 100),\n    });\n\n    const length = this._mtu - CBOR.encode(message).byteLength - nmpOverhead - 3 - 5;\n\n    message.data = new Uint8Array(this._uploadImage.slice(this._uploadOffset, this._uploadOffset + length));\n\n    this._uploadOffset += length;\n\n    const packet = this._getMessage(\n      constants.MGMT_OP_WRITE,\n      constants.MGMT_GROUP_ID_IMAGE,\n      constants.IMG_MGMT_ID_UPLOAD,\n      message\n    );\n\n    _console.log(\"mcumgr - _uploadNext: Message Length: \" + packet.length);\n\n    this._imageUploadNextCallback({ packet });\n  }\n  async reset() {\n    this._messageCallback = null;\n    this._imageUploadProgressCallback = null;\n    this._imageUploadNextCallback = null;\n    this._fileUploadProgressCallback = null;\n    this._fileUploadNextCallback = null;\n    this._uploadIsInProgress = false;\n    this._downloadIsInProgress = false;\n    this._buffer = new Uint8Array();\n    this._seq = 0;\n  }\n\n  async cmdUpload(image, slot = 0) {\n    if (this._uploadIsInProgress) {\n      _console.error(\"Upload is already in progress.\");\n      return;\n    }\n    this._uploadIsInProgress = true;\n\n    this._uploadOffset = 0;\n    this._uploadImage = image;\n    this._uploadSlot = slot;\n\n    this._uploadNext();\n  }\n\n  async cmdUploadFile(filebuf, destFilename) {\n    if (this._uploadIsInProgress) {\n      _console.error(\"Upload is already in progress.\");\n      return;\n    }\n    this._uploadIsInProgress = true;\n    this._uploadFileOffset = 0;\n    this._uploadFile = filebuf;\n    this._uploadFilename = destFilename;\n\n    this._uploadFileNext();\n  }\n\n  async _uploadFileNext() {\n    _console.log(\"uploadFileNext - offset: \" + this._uploadFileOffset + \", length: \" + this._uploadFile.byteLength);\n\n    if (this._uploadFileOffset >= this._uploadFile.byteLength) {\n      this._uploadIsInProgress = false;\n      this._fileUploadFinishedCallback();\n      return;\n    }\n\n    const nmpOverhead = 8;\n    const message = { data: new Uint8Array(), off: this._uploadFileOffset };\n    if (this._uploadFileOffset === 0) {\n      message.len = this._uploadFile.byteLength;\n    }\n    message.name = this._uploadFilename;\n    this._fileUploadProgressCallback({\n      percentage: Math.floor((this._uploadFileOffset / this._uploadFile.byteLength) * 100),\n    });\n\n    const length = this._mtu - CBOR.encode(message).byteLength - nmpOverhead;\n\n    message.data = new Uint8Array(this._uploadFile.slice(this._uploadFileOffset, this._uploadFileOffset + length));\n\n    this._uploadFileOffset += length;\n\n    const packet = this._getMessage(\n      constants.MGMT_OP_WRITE,\n      constants.MGMT_GROUP_ID_FS,\n      constants.FS_MGMT_ID_FILE,\n      message\n    );\n\n    _console.log(\"mcumgr - _uploadNext: Message Length: \" + packet.length);\n\n    this._fileUploadNextCallback({ packet });\n  }\n\n  async cmdDownloadFile(filename, destFilename) {\n    if (this._downloadIsInProgress) {\n      _console.error(\"Download is already in progress.\");\n      return;\n    }\n    this._downloadIsInProgress = true;\n    this._downloadFileOffset = 0;\n    this._downloadFileLength = 0;\n    this._downloadRemoteFilename = filename;\n    this._downloadLocalFilename = destFilename;\n\n    this._downloadFileNext();\n  }\n\n  async _downloadFileNext() {\n    if (this._downloadFileLength > 0) {\n      if (this._downloadFileOffset >= this._downloadFileLength) {\n        this._downloadIsInProgress = false;\n        this._fileDownloadFinishedCallback();\n        return;\n      }\n    }\n\n    const message = { off: this._downloadFileOffset };\n    if (this._downloadFileOffset === 0) {\n      message.name = this._downloadRemoteFilename;\n    }\n\n    const packet = this._getMessage(\n      constants.MGMT_OP_READ,\n      constants.MGMT_GROUP_ID_FS,\n      constants.FS_MGMT_ID_FILE,\n      message\n    );\n    _console.log(\"mcumgr - _downloadNext: Message Length: \" + packet.length);\n    this._fileDownloadNextCallback({ packet });\n  }\n\n  async imageInfo(image) {\n    const info = {};\n    const view = new Uint8Array(image);\n\n    // check header length\n    if (view.length < 32) {\n      throw new Error(\"Invalid image (too short file)\");\n    }\n\n    // check MAGIC bytes 0x96f3b83d\n    if (view[0] !== 0x3d || view[1] !== 0xb8 || view[2] !== 0xf3 || view[3] !== 0x96) {\n      throw new Error(\"Invalid image (wrong magic bytes)\");\n    }\n\n    // check load address is 0x00000000\n    if (view[4] !== 0x00 || view[5] !== 0x00 || view[6] !== 0x00 || view[7] !== 0x00) {\n      throw new Error(\"Invalid image (wrong load address)\");\n    }\n\n    const headerSize = view[8] + view[9] * 2 ** 8;\n\n    // check protected TLV area size is 0\n    if (view[10] !== 0x00 || view[11] !== 0x00) {\n      throw new Error(\"Invalid image (wrong protected TLV area size)\");\n    }\n\n    const imageSize = view[12] + view[13] * 2 ** 8 + view[14] * 2 ** 16 + view[15] * 2 ** 24;\n    info.imageSize = imageSize;\n\n    // check image size is correct\n    if (view.length < imageSize + headerSize) {\n      throw new Error(\"Invalid image (wrong image size)\");\n    }\n\n    // check flags is 0x00000000\n    if (view[16] !== 0x00 || view[17] !== 0x00 || view[18] !== 0x00 || view[19] !== 0x00) {\n      throw new Error(\"Invalid image (wrong flags)\");\n    }\n\n    const version = `${view[20]}.${view[21]}.${view[22] + view[23] * 2 ** 8}`;\n    info.version = version;\n\n    info.hash = [...new Uint8Array(await this._hash(image.slice(0, imageSize + 32)))]\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n\n    return info;\n  }\n}\n","import Device, { SendSmpMessageCallback } from \"./Device.ts\";\nimport { getFileBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { MCUManager, constants } from \"./utils/mcumgr.js\";\nimport { FileLike } from \"./utils/ArrayBufferUtils.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"FirmwareManager\", { log: false });\n\nexport const FirmwareMessageTypes = [\"smp\"] as const;\nexport type FirmwareMessageType = (typeof FirmwareMessageTypes)[number];\n\nexport const FirmwareEventTypes = [\n  ...FirmwareMessageTypes,\n  \"firmwareImages\",\n  \"firmwareUploadProgress\",\n  \"firmwareStatus\",\n  \"firmwareUploadComplete\",\n] as const;\nexport type FirmwareEventType = (typeof FirmwareEventTypes)[number];\n\nexport const FirmwareStatuses = [\"idle\", \"uploading\", \"uploaded\", \"pending\", \"testing\", \"erasing\"] as const;\nexport type FirmwareStatus = (typeof FirmwareStatuses)[number];\n\nexport interface FirmwareImage {\n  slot: number;\n  active: boolean;\n  confirmed: boolean;\n  pending: boolean;\n  permanent: boolean;\n  bootable: boolean;\n  version: string;\n  hash?: Uint8Array;\n  empty?: boolean;\n}\n\nexport interface FirmwareEventMessages {\n  smp: { dataView: DataView };\n  firmwareImages: { firmwareImages: FirmwareImage[] };\n  firmwareUploadProgress: { progress: number };\n  firmwareStatus: { firmwareStatus: FirmwareStatus };\n  //firmwareUploadComplete: {};\n}\n\nexport type FirmwareEventDispatcher = EventDispatcher<Device, FirmwareEventType, FirmwareEventMessages>;\n\nclass FirmwareManager {\n  sendMessage!: SendSmpMessageCallback;\n\n  constructor() {\n    this.#assignMcuManagerCallbacks();\n    autoBind(this);\n  }\n\n  eventDispatcher!: FirmwareEventDispatcher;\n  get addEventListenter() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  parseMessage(messageType: FirmwareMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"smp\":\n        this.#mcuManager._notification(Array.from(new Uint8Array(dataView.buffer)));\n        this.#dispatchEvent(\"smp\", { dataView });\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  async uploadFirmware(file: FileLike) {\n    _console.log(\"uploadFirmware\", file);\n\n    const promise = this.waitForEvent(\"firmwareUploadComplete\");\n\n    await this.getImages();\n\n    const arrayBuffer = await getFileBuffer(file);\n    const imageInfo = await this.#mcuManager.imageInfo(arrayBuffer);\n    _console.log({ imageInfo });\n\n    this.#mcuManager.cmdUpload(arrayBuffer, 1);\n\n    this.#updateStatus(\"uploading\");\n\n    await promise;\n  }\n\n  #status: FirmwareStatus = \"idle\";\n  get status() {\n    return this.#status;\n  }\n  #updateStatus(newStatus: FirmwareStatus) {\n    _console.assertEnumWithError(newStatus, FirmwareStatuses);\n    if (this.#status == newStatus) {\n      _console.log(`redundant firmwareStatus assignment \"${newStatus}\"`);\n      return;\n    }\n\n    this.#status = newStatus;\n    _console.log({ firmwareStatus: this.#status });\n    this.#dispatchEvent(\"firmwareStatus\", { firmwareStatus: this.#status });\n  }\n\n  // COMMANDS\n\n  #images!: FirmwareImage[];\n  get images() {\n    return this.#images;\n  }\n  #assertImages() {\n    _console.assertWithError(this.#images, \"didn't get imageState\");\n  }\n  #assertValidImageIndex(imageIndex: number) {\n    _console.assertTypeWithError(imageIndex, \"number\");\n    _console.assertWithError(imageIndex == 0 || imageIndex == 1, \"imageIndex must be 0 or 1\");\n  }\n  async getImages() {\n    const promise = this.waitForEvent(\"firmwareImages\");\n\n    _console.log(\"getting firmware image state...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageState()).buffer);\n\n    await promise;\n  }\n\n  async testImage(imageIndex: number = 1) {\n    this.#assertValidImageIndex(imageIndex);\n    this.#assertImages();\n    if (!this.#images[imageIndex]) {\n      _console.log(`image ${imageIndex} not found`);\n      return;\n    }\n    if (this.#images[imageIndex].pending == true) {\n      _console.log(`image ${imageIndex} is already pending`);\n      return;\n    }\n    if (this.#images[imageIndex].empty) {\n      _console.log(`image ${imageIndex} is empty`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"testing firmware image...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageTest(this.#images[imageIndex].hash)).buffer);\n\n    await promise;\n  }\n\n  async eraseImage() {\n    this.#assertImages();\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"erasing image...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageErase()).buffer);\n\n    this.#updateStatus(\"erasing\");\n\n    await promise;\n    await this.getImages();\n  }\n\n  async confirmImage(imageIndex: number = 0) {\n    this.#assertValidImageIndex(imageIndex);\n    this.#assertImages();\n    if (this.#images[imageIndex].confirmed === true) {\n      _console.log(`image ${imageIndex} is already confirmed`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"confirming image...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageConfirm(this.#images[imageIndex].hash)).buffer);\n\n    await promise;\n  }\n\n  async echo(string: string) {\n    _console.assertTypeWithError(string, \"string\");\n\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"sending echo...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.smpEcho(string)).buffer);\n\n    await promise;\n  }\n\n  async reset() {\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"resetting...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdReset()).buffer);\n\n    await promise;\n  }\n\n  // MTU\n  #mtu!: number;\n  get mtu() {\n    return this.#mtu;\n  }\n  set mtu(newMtu: number) {\n    this.#mtu = newMtu;\n    this.#mcuManager._mtu = newMtu;\n  }\n\n  // MCUManager\n  #mcuManager = new MCUManager();\n\n  #assignMcuManagerCallbacks() {\n    this.#mcuManager.onMessage(this.#onMcuMessage.bind(this));\n\n    this.#mcuManager.onFileDownloadNext(this.#onMcuFileDownloadNext);\n    this.#mcuManager.onFileDownloadProgress(this.#onMcuFileDownloadProgress.bind(this));\n    this.#mcuManager.onFileDownloadFinished(this.#onMcuFileDownloadFinished.bind(this));\n\n    this.#mcuManager.onFileUploadNext(this.#onMcuFileUploadNext.bind(this));\n    this.#mcuManager.onFileUploadProgress(this.#onMcuFileUploadProgress.bind(this));\n    this.#mcuManager.onFileUploadFinished(this.#onMcuFileUploadFinished.bind(this));\n\n    this.#mcuManager.onImageUploadNext(this.#onMcuImageUploadNext.bind(this));\n    this.#mcuManager.onImageUploadProgress(this.#onMcuImageUploadProgress.bind(this));\n    this.#mcuManager.onImageUploadFinished(this.#onMcuImageUploadFinished.bind(this));\n  }\n\n  #onMcuMessage({ op, group, id, data, length }: { op: number; group: number; id: number; data: any; length: number }) {\n    _console.log(\"onMcuMessage\", ...arguments);\n\n    switch (group) {\n      case constants.MGMT_GROUP_ID_OS:\n        switch (id) {\n          case constants.OS_MGMT_ID_ECHO:\n            _console.log(`echo \"${data.r}\"`);\n            break;\n          case constants.OS_MGMT_ID_TASKSTAT:\n            _console.table(data.tasks);\n            break;\n          case constants.OS_MGMT_ID_MPSTAT:\n            _console.log(data);\n            break;\n        }\n        break;\n      case constants.MGMT_GROUP_ID_IMAGE:\n        switch (id) {\n          case constants.IMG_MGMT_ID_STATE:\n            this.#onMcuImageState(data);\n        }\n        break;\n      default:\n        throw Error(`uncaught mcuMessage group ${group}`);\n    }\n  }\n\n  #onMcuFileDownloadNext() {\n    _console.log(\"onMcuFileDownloadNext\", ...arguments);\n  }\n  #onMcuFileDownloadProgress() {\n    _console.log(\"onMcuFileDownloadProgress\", ...arguments);\n  }\n  #onMcuFileDownloadFinished() {\n    _console.log(\"onMcuFileDownloadFinished\", ...arguments);\n  }\n\n  #onMcuFileUploadNext() {\n    _console.log(\"onMcuFileUploadNext\");\n  }\n  #onMcuFileUploadProgress() {\n    _console.log(\"onMcuFileUploadProgress\");\n  }\n  #onMcuFileUploadFinished() {\n    _console.log(\"onMcuFileUploadFinished\");\n  }\n\n  #onMcuImageUploadNext({ packet }: { packet: number[] }) {\n    _console.log(\"onMcuImageUploadNext\");\n    this.sendMessage(Uint8Array.from(packet).buffer);\n  }\n  #onMcuImageUploadProgress({ percentage }: { percentage: number }) {\n    const progress = percentage / 100;\n    _console.log(\"onMcuImageUploadProgress\", ...arguments);\n    this.#dispatchEvent(\"firmwareUploadProgress\", { progress });\n  }\n  async #onMcuImageUploadFinished() {\n    _console.log(\"onMcuImageUploadFinished\", ...arguments);\n\n    await this.getImages();\n\n    this.#dispatchEvent(\"firmwareUploadProgress\", { progress: 100 });\n    this.#dispatchEvent(\"firmwareUploadComplete\", {});\n  }\n\n  #onMcuImageState({ images }: { images?: FirmwareImage[] }) {\n    if (images) {\n      this.#images = images;\n      _console.log(\"images\", this.#images);\n    } else {\n      _console.log(\"no images found\");\n      return;\n    }\n\n    let newStatus: FirmwareStatus = \"idle\";\n\n    if (this.#images.length == 2) {\n      if (!this.#images[1].bootable) {\n        _console.warn('Slot 1 has a invalid image. Click \"Erase Image\" to erase it or upload a different image');\n      } else if (!this.#images[0].confirmed) {\n        _console.log(\n          'Slot 0 has a valid image. Click \"Confirm Image\" to confirm it or wait and the device will swap images back.'\n        );\n        newStatus = \"testing\";\n      } else {\n        if (this.#images[1].pending) {\n          _console.log(\"reset to upload to the new firmware image\");\n          newStatus = \"pending\";\n        } else {\n          _console.log(\"Slot 1 has a valid image. run testImage() to test it or upload a different image.\");\n          newStatus = \"uploaded\";\n        }\n      }\n    }\n\n    if (this.#images.length == 1) {\n      this.#images.push({\n        slot: 1,\n        empty: true,\n        version: \"Empty\",\n        pending: false,\n        confirmed: false,\n        bootable: false,\n        active: false,\n        permanent: false,\n      });\n\n      _console.log(\"Select a firmware upload image to upload to slot 1.\");\n    }\n\n    this.#updateStatus(newStatus);\n    this.#dispatchEvent(\"firmwareImages\", { firmwareImages: this.#images });\n  }\n}\n\nexport default FirmwareManager;\n","import { ConnectionStatus } from \"./connection/BaseConnectionManager.ts\";\nimport WebBluetoothConnectionManager from \"./connection/bluetooth/WebBluetoothConnectionManager.ts\";\nimport Device, { BoundDeviceEventListeners, DeviceEventMap } from \"./Device.ts\";\nimport { DeviceType } from \"./InformationManager.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInBluefy, isInBrowser } from \"./utils/environment.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"./utils/EventDispatcher.ts\";\nimport { addEventListeners } from \"./utils/EventUtils.ts\";\n\nconst _console = createConsole(\"DeviceManager\", { log: false });\n\nexport interface LocalStorageDeviceInformation {\n  type: DeviceType;\n  bluetoothId: string;\n  ipAddress?: string;\n  isWifiSecure?: boolean;\n}\n\nexport interface LocalStorageConfiguration {\n  devices: LocalStorageDeviceInformation[];\n}\n\nexport const DeviceManagerEventTypes = [\n  \"deviceConnected\",\n  \"deviceDisconnected\",\n  \"deviceIsConnected\",\n  \"availableDevices\",\n  \"connectedDevices\",\n] as const;\nexport type DeviceManagerEventType = (typeof DeviceManagerEventTypes)[number];\n\ninterface DeviceManagerEventMessage {\n  device: Device;\n}\nexport interface DeviceManagerEventMessages {\n  deviceConnected: DeviceManagerEventMessage;\n  deviceDisconnected: DeviceManagerEventMessage;\n  deviceIsConnected: DeviceManagerEventMessage;\n  availableDevices: { availableDevices: Device[] };\n  connectedDevices: { connectedDevices: Device[] };\n}\n\nexport type DeviceManagerEventDispatcher = EventDispatcher<\n  DeviceManager,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEventMap = EventMap<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEventListenerMap = EventListenerMap<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEvent = Event<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type BoundDeviceManagerEventListeners = BoundEventListeners<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\n\nclass DeviceManager {\n  static readonly shared = new DeviceManager();\n\n  constructor() {\n    if (DeviceManager.shared && this != DeviceManager.shared) {\n      throw Error(\"DeviceManager is a singleton - use DeviceManager.shared\");\n    }\n\n    if (this.CanUseLocalStorage) {\n      this.UseLocalStorage = true;\n    }\n  }\n\n  // DEVICE LISTENERS\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    getType: this.#onDeviceType.bind(this),\n    isConnected: this.#OnDeviceIsConnected.bind(this),\n  };\n  /** @private */\n  onDevice(device: Device) {\n    addEventListeners(device, this.#boundDeviceEventListeners);\n  }\n\n  #onDeviceType(event: DeviceEventMap[\"getType\"]) {\n    if (this.#UseLocalStorage) {\n      this.#UpdateLocalStorageConfigurationForDevice(event.target);\n    }\n  }\n\n  // CONNECTION STATUS\n  /** @private */\n  OnDeviceConnectionStatusUpdated(\n    device: Device,\n    connectionStatus: ConnectionStatus\n  ) {\n    if (\n      connectionStatus == \"notConnected\" &&\n      !device.canReconnect &&\n      this.#AvailableDevices.includes(device)\n    ) {\n      const deviceIndex = this.#AvailableDevices.indexOf(device);\n      this.AvailableDevices.splice(deviceIndex, 1);\n      this.#DispatchAvailableDevices();\n    }\n  }\n\n  // CONNECTED DEVICES\n\n  #ConnectedDevices: Device[] = [];\n  get ConnectedDevices() {\n    return this.#ConnectedDevices;\n  }\n\n  #UseLocalStorage = false;\n  get UseLocalStorage() {\n    return this.#UseLocalStorage;\n  }\n  set UseLocalStorage(newUseLocalStorage) {\n    this.#AssertLocalStorage();\n    _console.assertTypeWithError(newUseLocalStorage, \"boolean\");\n    this.#UseLocalStorage = newUseLocalStorage;\n    if (this.#UseLocalStorage && !this.#LocalStorageConfiguration) {\n      this.#LoadFromLocalStorage();\n    }\n  }\n\n  #DefaultLocalStorageConfiguration: LocalStorageConfiguration = {\n    devices: [],\n  };\n  #LocalStorageConfiguration?: LocalStorageConfiguration;\n\n  get CanUseLocalStorage() {\n    return isInBrowser && window.localStorage;\n  }\n\n  #AssertLocalStorage() {\n    _console.assertWithError(\n      isInBrowser,\n      \"localStorage is only available in the browser\"\n    );\n    _console.assertWithError(window.localStorage, \"localStorage not found\");\n  }\n  #LocalStorageKey = \"BS.Device\";\n  #SaveToLocalStorage() {\n    this.#AssertLocalStorage();\n    localStorage.setItem(\n      this.#LocalStorageKey,\n      JSON.stringify(this.#LocalStorageConfiguration)\n    );\n  }\n  async #LoadFromLocalStorage() {\n    this.#AssertLocalStorage();\n    let localStorageString = localStorage.getItem(this.#LocalStorageKey);\n    if (typeof localStorageString != \"string\") {\n      _console.log(\"no info found in localStorage\");\n      this.#LocalStorageConfiguration = Object.assign(\n        {},\n        this.#DefaultLocalStorageConfiguration\n      );\n      this.#SaveToLocalStorage();\n      return;\n    }\n    try {\n      const configuration = JSON.parse(localStorageString);\n      _console.log({ configuration });\n      this.#LocalStorageConfiguration = configuration;\n      if (this.CanGetDevices) {\n        await this.GetDevices(); // redundant?\n      }\n    } catch (error) {\n      _console.error(error);\n    }\n  }\n\n  #UpdateLocalStorageConfigurationForDevice(device: Device) {\n    if (device.connectionType != \"webBluetooth\") {\n      _console.log(\"localStorage is only for webBluetooth devices\");\n      return;\n    }\n    this.#AssertLocalStorage();\n    const deviceInformationIndex =\n      this.#LocalStorageConfiguration!.devices.findIndex(\n        (deviceInformation) => {\n          return deviceInformation.bluetoothId == device.bluetoothId;\n        }\n      );\n    if (deviceInformationIndex == -1) {\n      return;\n    }\n    this.#LocalStorageConfiguration!.devices[deviceInformationIndex].type =\n      device.type;\n    this.#SaveToLocalStorage();\n  }\n\n  // AVAILABLE DEVICES\n  #AvailableDevices: Device[] = [];\n  get AvailableDevices() {\n    return this.#AvailableDevices;\n  }\n\n  get CanGetDevices() {\n    return isInBrowser && navigator.bluetooth?.getDevices;\n  }\n  /**\n   * retrieves devices already connected via web bluetooth in other tabs/windows\n   *\n   * _only available on web-bluetooth enabled browsers_\n   */\n  async GetDevices(): Promise<Device[] | undefined> {\n    if (!isInBrowser) {\n      _console.warn(\"GetDevices is only available in the browser\");\n      return;\n    }\n\n    if (!navigator.bluetooth) {\n      _console.warn(\"bluetooth is not available in this browser\");\n      return;\n    }\n\n    if (isInBluefy) {\n      _console.warn(\"bluefy lists too many devices...\");\n      return;\n    }\n\n    if (!navigator.bluetooth.getDevices) {\n      _console.warn(\"bluetooth.getDevices() is not available in this browser\");\n      return;\n    }\n\n    if (!this.CanGetDevices) {\n      _console.log(\"CanGetDevices is false\");\n      return;\n    }\n\n    if (!this.#LocalStorageConfiguration) {\n      this.#LoadFromLocalStorage();\n    }\n\n    const configuration = this.#LocalStorageConfiguration!;\n    if (!configuration.devices || configuration.devices.length == 0) {\n      _console.log(\"no devices found in configuration\");\n      return;\n    }\n\n    const bluetoothDevices = await navigator.bluetooth.getDevices();\n\n    _console.log({ bluetoothDevices });\n\n    bluetoothDevices.forEach((bluetoothDevice) => {\n      if (!bluetoothDevice.gatt) {\n        return;\n      }\n      let deviceInformation = configuration.devices.find(\n        (deviceInformation) =>\n          bluetoothDevice.id == deviceInformation.bluetoothId\n      );\n      if (!deviceInformation) {\n        return;\n      }\n\n      let existingConnectedDevice = this.ConnectedDevices.filter(\n        (device) => device.connectionType == \"webBluetooth\"\n      ).find((device) => device.bluetoothId == bluetoothDevice.id);\n\n      const existingAvailableDevice = this.AvailableDevices.filter(\n        (device) => device.connectionType == \"webBluetooth\"\n      ).find((device) => device.bluetoothId == bluetoothDevice.id);\n      if (existingAvailableDevice) {\n        if (\n          existingConnectedDevice &&\n          existingConnectedDevice?.bluetoothId ==\n            existingAvailableDevice.bluetoothId &&\n          existingConnectedDevice != existingAvailableDevice\n        ) {\n          this.AvailableDevices[\n            this.#AvailableDevices.indexOf(existingAvailableDevice)\n          ] = existingConnectedDevice;\n        }\n        return;\n      }\n\n      if (existingConnectedDevice) {\n        this.AvailableDevices.push(existingConnectedDevice);\n        return;\n      }\n\n      const device = new Device();\n      const connectionManager = new WebBluetoothConnectionManager();\n      connectionManager.device = bluetoothDevice;\n      if (bluetoothDevice.name) {\n        device._informationManager.updateName(bluetoothDevice.name);\n      }\n      device._informationManager.updateType(deviceInformation.type);\n      device.connectionManager = connectionManager;\n      this.AvailableDevices.push(device);\n    });\n    this.#DispatchAvailableDevices();\n    return this.AvailableDevices;\n  }\n\n  // STATIC EVENTLISTENERS\n\n  #EventDispatcher: DeviceManagerEventDispatcher = new EventDispatcher(\n    this as DeviceManager,\n    DeviceManagerEventTypes\n  );\n\n  get AddEventListener() {\n    return this.#EventDispatcher.addEventListener;\n  }\n  get #DispatchEvent() {\n    return this.#EventDispatcher.dispatchEvent;\n  }\n  get RemoveEventListener() {\n    return this.#EventDispatcher.removeEventListener;\n  }\n  get RemoveEventListeners() {\n    return this.#EventDispatcher.removeEventListeners;\n  }\n  get RemoveAllEventListeners() {\n    return this.#EventDispatcher.removeAllEventListeners;\n  }\n\n  #OnDeviceIsConnected(event: DeviceEventMap[\"isConnected\"]) {\n    const { target: device } = event;\n    if (device.isConnected) {\n      if (!this.#ConnectedDevices.includes(device)) {\n        _console.log(\"adding device\", device);\n        this.#ConnectedDevices.push(device);\n        if (this.UseLocalStorage && device.connectionType == \"webBluetooth\") {\n          const deviceInformation: LocalStorageDeviceInformation = {\n            type: device.type,\n            bluetoothId: device.bluetoothId!,\n            ipAddress: device.ipAddress,\n            isWifiSecure: device.isWifiSecure,\n          };\n          const deviceInformationIndex =\n            this.#LocalStorageConfiguration!.devices.findIndex(\n              (_deviceInformation) =>\n                _deviceInformation.bluetoothId == deviceInformation.bluetoothId\n            );\n          if (deviceInformationIndex == -1) {\n            this.#LocalStorageConfiguration!.devices.push(deviceInformation);\n          } else {\n            this.#LocalStorageConfiguration!.devices[deviceInformationIndex] =\n              deviceInformation;\n          }\n          this.#SaveToLocalStorage();\n        }\n        this.#DispatchEvent(\"deviceConnected\", { device });\n        this.#DispatchEvent(\"deviceIsConnected\", { device });\n        this.#DispatchConnectedDevices();\n      } else {\n        _console.log(\"device already included\");\n      }\n    } else {\n      if (this.#ConnectedDevices.includes(device)) {\n        _console.log(\"removing device\", device);\n        this.#ConnectedDevices.splice(\n          this.#ConnectedDevices.indexOf(device),\n          1\n        );\n        this.#DispatchEvent(\"deviceDisconnected\", { device });\n        this.#DispatchEvent(\"deviceIsConnected\", { device });\n        this.#DispatchConnectedDevices();\n      } else {\n        _console.log(\"device already not included\");\n      }\n    }\n    if (this.CanGetDevices) {\n      this.GetDevices();\n    }\n    if (device.isConnected && !this.AvailableDevices.includes(device)) {\n      const existingAvailableDevice = this.AvailableDevices.find(\n        (_device) => _device.bluetoothId == device.bluetoothId\n      );\n      _console.log({ existingAvailableDevice });\n      if (existingAvailableDevice) {\n        this.AvailableDevices[\n          this.AvailableDevices.indexOf(existingAvailableDevice)\n        ] = device;\n      } else {\n        this.AvailableDevices.push(device);\n      }\n      this.#DispatchAvailableDevices();\n    }\n    this._CheckDeviceAvailability(device);\n  }\n\n  _CheckDeviceAvailability(device: Device) {\n    if (\n      !device.isConnected &&\n      !device.isAvailable &&\n      this.#AvailableDevices.includes(device)\n    ) {\n      _console.log(\"removing device from availableDevices...\");\n      this.#AvailableDevices.splice(this.#AvailableDevices.indexOf(device), 1);\n      this.#DispatchAvailableDevices();\n    }\n  }\n\n  #DispatchAvailableDevices() {\n    _console.log({ AvailableDevices: this.AvailableDevices });\n    this.#DispatchEvent(\"availableDevices\", {\n      availableDevices: this.AvailableDevices,\n    });\n  }\n  #DispatchConnectedDevices() {\n    _console.log({ ConnectedDevices: this.ConnectedDevices });\n    this.#DispatchEvent(\"connectedDevices\", {\n      connectedDevices: this.ConnectedDevices,\n    });\n  }\n}\n\nexport default DeviceManager.shared;\n","import { DeviceEventTypes } from \"../Device.ts\";\nimport {\n  ConnectionMessageType,\n  ConnectionMessageTypes,\n} from \"../connection/BaseConnectionManager.ts\";\nimport { concatenateArrayBuffers } from \"../utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"../utils/Console.ts\";\nimport { DeviceEventType } from \"../Device.ts\";\n\nconst _console = createConsole(\"ServerUtils\", { log: false });\n\nexport const ServerMessageTypes = [\n  \"isScanningAvailable\",\n  \"isScanning\",\n  \"startScan\",\n  \"stopScan\",\n  \"discoveredDevice\",\n  \"discoveredDevices\",\n  \"expiredDiscoveredDevice\",\n  \"connectToDevice\",\n  \"disconnectFromDevice\",\n  \"connectedDevices\",\n  \"deviceMessage\",\n  \"requiredDeviceInformation\",\n] as const;\nexport type ServerMessageType = (typeof ServerMessageTypes)[number];\n\nexport const DeviceMessageTypes = [\n  \"connectionStatus\",\n  \"batteryLevel\",\n  \"deviceInformation\",\n  \"rx\",\n  \"smp\",\n] as const;\nexport type DeviceMessageType = (typeof DeviceMessageTypes)[number];\n\n// MESSAGING\n\nexport type MessageLike =\n  | number\n  | number[]\n  | ArrayBufferLike\n  | DataView\n  | boolean\n  | string\n  | any;\n\nexport interface Message<MessageType extends string> {\n  type: MessageType;\n  data?: MessageLike | MessageLike[];\n}\n\nexport function createMessage<MessageType extends string>(\n  enumeration: readonly MessageType[],\n  ...messages: (Message<MessageType> | MessageType)[]\n) {\n  _console.log(\"createMessage\", ...messages);\n\n  const messageBuffers = messages.map((message) => {\n    if (typeof message == \"string\") {\n      message = { type: message };\n    }\n\n    if (message.data != undefined) {\n      if (!Array.isArray(message.data)) {\n        message.data = [message.data];\n      }\n    } else {\n      message.data = [];\n    }\n\n    const messageDataArrayBuffer = concatenateArrayBuffers(...message.data);\n    const messageDataArrayBufferByteLength = messageDataArrayBuffer.byteLength;\n\n    _console.assertEnumWithError(message.type, enumeration);\n    const messageTypeEnum = enumeration.indexOf(message.type);\n\n    const messageDataLengthDataView = new DataView(new ArrayBuffer(2));\n    messageDataLengthDataView.setUint16(\n      0,\n      messageDataArrayBufferByteLength,\n      true\n    );\n\n    return concatenateArrayBuffers(\n      messageTypeEnum,\n      messageDataLengthDataView,\n      messageDataArrayBuffer\n    );\n  });\n  _console.log(\"messageBuffers\", ...messageBuffers);\n  return concatenateArrayBuffers(...messageBuffers);\n}\n\nexport type ServerMessage = ServerMessageType | Message<ServerMessageType>;\nexport function createServerMessage(...messages: ServerMessage[]) {\n  _console.log(\"createServerMessage\", ...messages);\n  return createMessage(ServerMessageTypes, ...messages);\n}\n\nexport type DeviceMessage = DeviceEventType | Message<DeviceEventType>;\nexport function createDeviceMessage(...messages: DeviceMessage[]) {\n  _console.log(\"createDeviceMessage\", ...messages);\n  return createMessage(DeviceEventTypes, ...messages);\n}\n\nexport type ClientDeviceMessage =\n  | ConnectionMessageType\n  | Message<ConnectionMessageType>;\nexport function createClientDeviceMessage(...messages: ClientDeviceMessage[]) {\n  _console.log(\"createClientDeviceMessage\", ...messages);\n  return createMessage(ConnectionMessageTypes, ...messages);\n}\n\n// STATIC MESSAGES\nexport const isScanningAvailableRequestMessage = createServerMessage(\n  \"isScanningAvailable\"\n);\nexport const isScanningRequestMessage = createServerMessage(\"isScanning\");\nexport const startScanRequestMessage = createServerMessage(\"startScan\");\nexport const stopScanRequestMessage = createServerMessage(\"stopScan\");\nexport const discoveredDevicesMessage =\n  createServerMessage(\"discoveredDevices\");\n","import { createConsole } from \"../../utils/Console.ts\";\nimport { createMessage, Message } from \"../ServerUtils.ts\";\n\nconst _console = createConsole(\"WebSocketUtils\", { log: false });\n\nexport const webSocketPingTimeout = 30_000;\nexport const webSocketReconnectTimeout = 3_000;\n\nexport const WebSocketMessageTypes = [\"ping\", \"pong\", \"serverMessage\"] as const;\nexport type WebSocketMessageType = (typeof WebSocketMessageTypes)[number];\n\nexport type WebSocketMessage =\n  | WebSocketMessageType\n  | Message<WebSocketMessageType>;\nexport function createWebSocketMessage(...messages: WebSocketMessage[]) {\n  _console.log(\"createWebSocketMessage\", ...messages);\n  return createMessage(WebSocketMessageTypes, ...messages);\n}\n\n// STATIC MESSAGES\nexport const webSocketPingMessage = createWebSocketMessage(\"ping\");\nexport const webSocketPongMessage = createWebSocketMessage(\"pong\");\n","import { DeviceInformationTypes } from \"../../DeviceInformationManager.ts\";\nimport {\n  createMessage,\n  Message,\n  MessageLike,\n} from \"../../server/ServerUtils.ts\";\nimport { webSocketPingTimeout } from \"../../server/websocket/WebSocketUtils.ts\";\nimport { createConsole } from \"../../utils/Console.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../../utils/EventUtils.ts\";\nimport { parseMessage } from \"../../utils/ParseUtils.ts\";\nimport Timer from \"../../utils/Timer.ts\";\nimport BaseConnectionManager, {\n  ConnectionType,\n} from \"../BaseConnectionManager.ts\";\nimport type * as ws from \"ws\";\n\nconst _console = createConsole(\"WebSocketConnectionManager\", { log: false });\n\nconst WebSocketMessageTypes = [\n  \"ping\",\n  \"pong\",\n  \"batteryLevel\",\n  \"deviceInformation\",\n  \"message\",\n] as const;\ntype WebSocketMessageType = (typeof WebSocketMessageTypes)[number];\n\ntype WebSocketMessage = WebSocketMessageType | Message<WebSocketMessageType>;\nfunction createWebSocketMessage(...messages: WebSocketMessage[]) {\n  _console.log(\"createWebSocketMessage\", ...messages);\n  return createMessage(WebSocketMessageTypes, ...messages);\n}\n\nconst WebSocketDeviceInformationMessageTypes: WebSocketMessageType[] = [\n  \"deviceInformation\",\n  \"batteryLevel\",\n];\n\nclass WebSocketConnectionManager extends BaseConnectionManager {\n  #bluetoothId?: string;\n  get bluetoothId() {\n    return this.#bluetoothId ?? \"\";\n  }\n\n  defaultMtu = 2 ** 10;\n\n  constructor(\n    ipAddress: string,\n    isSecure: boolean = false,\n    bluetoothId?: string\n  ) {\n    super();\n    this.ipAddress = ipAddress;\n    this.isSecure = isSecure;\n    this.mtu = this.defaultMtu;\n    this.#bluetoothId = bluetoothId;\n  }\n\n  get isAvailable() {\n    return true;\n  }\n\n  static get isSupported() {\n    return true;\n  }\n  static get type(): ConnectionType {\n    return \"webSocket\";\n  }\n\n  // WEBSOCKET\n  #webSocket?: WebSocket;\n  get webSocket() {\n    return this.#webSocket;\n  }\n  set webSocket(newWebSocket) {\n    if (this.#webSocket == newWebSocket) {\n      _console.log(\"redundant webSocket assignment\");\n      return;\n    }\n\n    _console.log(\"assigning webSocket\", newWebSocket);\n\n    if (this.#webSocket) {\n      removeEventListeners(this.#webSocket, this.#boundWebSocketEventListeners);\n      if (this.#webSocket.readyState == this.#webSocket.OPEN) {\n        this.#webSocket.close();\n      }\n    }\n\n    if (newWebSocket) {\n      addEventListeners(newWebSocket, this.#boundWebSocketEventListeners);\n    }\n    this.#webSocket = newWebSocket;\n\n    _console.log(\"assigned webSocket\");\n  }\n\n  // IP ADDRESS\n  #ipAddress!: string;\n  get ipAddress() {\n    return this.#ipAddress;\n  }\n  set ipAddress(newIpAddress) {\n    this.assertIsNotConnected();\n    if (this.#ipAddress == newIpAddress) {\n      _console.log(`redundnant ipAddress assignment \"${newIpAddress}\"`);\n      return;\n    }\n    this.#ipAddress = newIpAddress;\n    _console.log(`updated ipAddress to \"${this.ipAddress}\"`);\n  }\n\n  // IS SECURE\n  #isSecure = false;\n  get isSecure() {\n    return this.#isSecure;\n  }\n  set isSecure(newIsSecure) {\n    this.assertIsNotConnected();\n    if (this.#isSecure == newIsSecure) {\n      _console.log(`redundant isSecure assignment ${newIsSecure}`);\n      return;\n    }\n    this.#isSecure = newIsSecure;\n    _console.log(`updated isSecure to \"${this.isSecure}\"`);\n  }\n\n  // URL\n  get url() {\n    return `${this.isSecure ? \"wss\" : \"ws\"}://${this.ipAddress}/ws`;\n  }\n\n  // CONNECTION\n  async connect() {\n    await super.connect();\n    try {\n      this.webSocket = new WebSocket(this.url);\n    } catch (error) {\n      _console.error(\"error connecting to webSocket\", error);\n      this.status = \"notConnected\";\n    }\n  }\n  async disconnect() {\n    await super.disconnect();\n    _console.log(\"closing websocket\");\n    this.#pingTimer.stop();\n    this.#webSocket?.close();\n  }\n\n  get canReconnect() {\n    return Boolean(this.webSocket);\n  }\n  async reconnect() {\n    await super.reconnect();\n    this.webSocket = new WebSocket(this.url);\n  }\n\n  // BASE CONNECTION MANAGER\n  async sendSmpMessage(data: ArrayBuffer) {\n    super.sendSmpMessage(data);\n    _console.error(\"smp not supported on webSockets\");\n  }\n\n  async sendTxData(data: ArrayBuffer) {\n    await super.sendTxData(data);\n    if (data.byteLength == 0) {\n      return;\n    }\n    this.#sendWebSocketMessage({ type: \"message\", data });\n  }\n\n  // WEBSOCKET MESSAGING\n  #sendMessage(message: MessageLike) {\n    this.assertIsConnected();\n    _console.log(\"sending webSocket message\", message);\n    this.#webSocket!.send(message);\n    this.#pingTimer.restart();\n  }\n\n  #sendWebSocketMessage(...messages: WebSocketMessage[]) {\n    this.#sendMessage(createWebSocketMessage(...messages));\n  }\n\n  // WEBSOCKET EVENTS\n  #boundWebSocketEventListeners: { [eventType: string]: Function } = {\n    open: this.#onWebSocketOpen.bind(this),\n    message: this.#onWebSocketMessage.bind(this),\n    close: this.#onWebSocketClose.bind(this),\n    error: this.#onWebSocketError.bind(this),\n  };\n\n  #onWebSocketOpen(event: ws.Event) {\n    _console.log(\"webSocket.open\", event);\n    this.#pingTimer.start();\n    this.status = \"connected\";\n    this.#requestDeviceInformation();\n  }\n  async #onWebSocketMessage(event: ws.MessageEvent) {\n    // this.#pingTimer.restart();\n    //@ts-expect-error\n    const arrayBuffer = await event.data.arrayBuffer();\n    const dataView = new DataView(arrayBuffer);\n    _console.log(`webSocket.message (${dataView.byteLength} bytes)`);\n    this.#parseWebSocketMessage(dataView);\n  }\n  #onWebSocketClose(event: ws.CloseEvent) {\n    _console.log(\"webSocket.close\", event);\n    this.status = \"notConnected\";\n    this.#pingTimer.stop();\n  }\n  #onWebSocketError(event: ws.ErrorEvent) {\n    _console.error(\"webSocket.error\", event);\n  }\n\n  // PARSING\n  #parseWebSocketMessage(dataView: DataView) {\n    parseMessage(\n      dataView,\n      WebSocketMessageTypes,\n      this.#onMessage.bind(this),\n      null,\n      true\n    );\n  }\n\n  #onMessage(messageType: WebSocketMessageType, dataView: DataView) {\n    _console.log(\n      `received \"${messageType}\" message (${dataView.byteLength} bytes)`\n    );\n    switch (messageType) {\n      case \"ping\":\n        this.#pong();\n        break;\n      case \"pong\":\n        break;\n      case \"batteryLevel\":\n        this.onMessageReceived?.(\"batteryLevel\", dataView);\n        break;\n      case \"deviceInformation\":\n        parseMessage(\n          dataView,\n          DeviceInformationTypes,\n          (deviceInformationType, dataView) => {\n            this.onMessageReceived!(deviceInformationType, dataView);\n          }\n        );\n        break;\n      case \"message\":\n        this.parseRxMessage(dataView);\n        break;\n      default:\n        _console.error(`uncaught messageType \"${messageType}\"`);\n        break;\n    }\n  }\n\n  // PING\n  #pingTimer = new Timer(this.#ping.bind(this), webSocketPingTimeout - 1_000);\n  #ping() {\n    _console.log(\"pinging\");\n    this.#sendWebSocketMessage(\"ping\");\n  }\n  #pong() {\n    _console.log(\"ponging\");\n    this.#sendWebSocketMessage(\"pong\");\n  }\n\n  // DEVICE INFORMATION\n  #requestDeviceInformation() {\n    this.#sendWebSocketMessage(...WebSocketDeviceInformationMessageTypes);\n  }\n\n  remove() {\n    super.remove();\n    this.webSocket = undefined;\n  }\n}\n\nexport default WebSocketConnectionManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"./utils/EventDispatcher.ts\";\nimport BaseConnectionManager, {\n  TxMessage,\n  TxRxMessageType,\n  ConnectionStatus,\n  ConnectionMessageType,\n  MetaConnectionMessageTypes,\n  BatteryLevelMessageTypes,\n  ConnectionEventTypes,\n  ConnectionStatusEventMessages,\n  ConnectionTypes,\n  ConnectionType,\n  ConnectOptions,\n} from \"./connection/BaseConnectionManager.ts\";\nimport { isInBrowser, isInNode } from \"./utils/environment.ts\";\nimport WebBluetoothConnectionManager from \"./connection/bluetooth/WebBluetoothConnectionManager.ts\";\nimport SensorConfigurationManager, {\n  SendSensorConfigurationMessageCallback,\n  SensorConfiguration,\n  SensorConfigurationEventDispatcher,\n  SensorConfigurationEventMessages,\n  SensorConfigurationEventTypes,\n  SensorConfigurationMessageType,\n  SensorConfigurationMessageTypes,\n} from \"./sensor/SensorConfigurationManager.ts\";\nimport SensorDataManager, {\n  SensorDataEventMessages,\n  SensorDataEventTypes,\n  SensorDataMessageType,\n  SensorDataMessageTypes,\n  SensorType,\n  ContinuousSensorTypes,\n  SensorDataEventDispatcher,\n  RequiredPressureMessageTypes,\n} from \"./sensor/SensorDataManager.ts\";\nimport VibrationManager, {\n  SendVibrationMessageCallback,\n  VibrationConfiguration,\n  VibrationEventDispatcher,\n  VibrationEventTypes,\n  VibrationMessageType,\n  VibrationMessageTypes,\n} from \"./vibration/VibrationManager.ts\";\nimport FileTransferManager, {\n  FileTransferEventTypes,\n  FileTransferEventMessages,\n  FileTransferEventDispatcher,\n  SendFileTransferMessageCallback,\n  FileTransferMessageTypes,\n  FileTransferMessageType,\n  FileType,\n  FileTypes,\n  RequiredFileTransferMessageTypes,\n} from \"./FileTransferManager.ts\";\nimport TfliteManager, {\n  TfliteEventTypes,\n  TfliteEventMessages,\n  TfliteEventDispatcher,\n  SendTfliteMessageCallback,\n  TfliteMessageTypes,\n  TfliteMessageType,\n  TfliteSensorTypes,\n  TfliteFileConfiguration,\n  TfliteSensorType,\n  RequiredTfliteMessageTypes,\n} from \"./TfliteManager.ts\";\nimport FirmwareManager, {\n  FirmwareEventDispatcher,\n  FirmwareEventMessages,\n  FirmwareEventTypes,\n  FirmwareMessageType,\n  FirmwareMessageTypes,\n} from \"./FirmwareManager.ts\";\nimport DeviceInformationManager, {\n  DeviceInformationEventDispatcher,\n  DeviceInformationEventTypes,\n  DeviceInformationType,\n  DeviceInformationTypes,\n  DeviceInformationEventMessages,\n} from \"./DeviceInformationManager.ts\";\nimport InformationManager, {\n  DeviceType,\n  InformationEventDispatcher,\n  InformationEventTypes,\n  InformationMessageType,\n  InformationMessageTypes,\n  InformationEventMessages,\n  SendInformationMessageCallback,\n} from \"./InformationManager.ts\";\nimport { FileLike } from \"./utils/ArrayBufferUtils.ts\";\nimport DeviceManager from \"./DeviceManager.ts\";\nimport CameraManager, {\n  CameraEventDispatcher,\n  CameraEventMessages,\n  CameraEventTypes,\n  CameraMessageType,\n  CameraMessageTypes,\n  RequiredCameraMessageTypes,\n  SendCameraMessageCallback,\n} from \"./CameraManager.ts\";\nimport MicrophoneManager, {\n  MicrophoneEventDispatcher,\n  MicrophoneEventMessages,\n  MicrophoneEventTypes,\n  MicrophoneMessageType,\n  MicrophoneMessageTypes,\n  RequiredMicrophoneMessageTypes,\n  SendMicrophoneMessageCallback,\n} from \"./MicrophoneManager.ts\";\nimport DisplayManager, {\n  DisplayEventDispatcher,\n  DisplayEventMessages,\n  DisplayEventTypes,\n  DisplayMessageType,\n  DisplayMessageTypes,\n  RequiredDisplayMessageTypes,\n  SendDisplayMessageCallback,\n} from \"./DisplayManager.ts\";\nimport WifiManager, {\n  RequiredWifiMessageTypes,\n  SendWifiMessageCallback,\n  WifiEventDispatcher,\n  WifiEventMessages,\n  WifiEventTypes,\n  WifiMessageType,\n  WifiMessageTypes,\n} from \"./WifiManager.ts\";\nimport WebSocketConnectionManager from \"./connection/websocket/WebSocketConnectionManager.ts\";\nimport ClientConnectionManager from \"./connection/ClientConnectionManager.ts\";\n\n/** NODE_START */\nimport UDPConnectionManager from \"./connection/udp/UDPConnectionManager.ts\";\n/** NODE_END */\n\nconst _console = createConsole(\"Device\", { log: false });\n\nexport const DeviceEventTypes = [\n  \"connectionMessage\",\n  ...ConnectionEventTypes,\n  ...MetaConnectionMessageTypes,\n  ...BatteryLevelMessageTypes,\n  ...InformationEventTypes,\n  ...DeviceInformationEventTypes,\n  ...SensorConfigurationEventTypes,\n  ...SensorDataEventTypes,\n  ...VibrationEventTypes,\n  ...FileTransferEventTypes,\n  ...TfliteEventTypes,\n  ...WifiEventTypes,\n  ...CameraEventTypes,\n  ...MicrophoneEventTypes,\n  ...DisplayEventTypes,\n  ...FirmwareEventTypes,\n] as const;\nexport type DeviceEventType = (typeof DeviceEventTypes)[number];\n\nexport interface DeviceEventMessages\n  extends ConnectionStatusEventMessages,\n    DeviceInformationEventMessages,\n    InformationEventMessages,\n    SensorDataEventMessages,\n    SensorConfigurationEventMessages,\n    TfliteEventMessages,\n    FileTransferEventMessages,\n    WifiEventMessages,\n    CameraEventMessages,\n    MicrophoneEventMessages,\n    DisplayEventMessages,\n    FirmwareEventMessages {\n  batteryLevel: { batteryLevel: number };\n  connectionMessage: { messageType: ConnectionMessageType; dataView: DataView };\n}\n\nexport type SendMessageCallback<MessageType extends string> = (\n  messages?: { type: MessageType; data?: ArrayBuffer }[],\n  sendImmediately?: boolean\n) => Promise<void>;\n\nexport type SendSmpMessageCallback = (data: ArrayBuffer) => Promise<void>;\n\nexport type DeviceEventDispatcher = EventDispatcher<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\nexport type DeviceEvent = Event<Device, DeviceEventType, DeviceEventMessages>;\nexport type DeviceEventMap = EventMap<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\nexport type DeviceEventListenerMap = EventListenerMap<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\nexport type BoundDeviceEventListeners = BoundEventListeners<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\n\nexport const RequiredInformationConnectionMessages: TxRxMessageType[] = [\n  \"isCharging\",\n  \"getBatteryCurrent\",\n  \"getId\",\n  \"getMtu\",\n\n  \"getName\",\n  \"getType\",\n  \"getCurrentTime\",\n  \"getSensorConfiguration\",\n  \"getSensorScalars\",\n\n  \"getVibrationLocations\",\n\n  \"getFileTypes\",\n\n  \"isWifiAvailable\",\n];\n\nclass Device {\n  get bluetoothId() {\n    return this.#connectionManager?.bluetoothId;\n  }\n\n  get isAvailable() {\n    return this.#connectionManager?.isAvailable;\n  }\n\n  constructor() {\n    this.#deviceInformationManager.eventDispatcher = this\n      .#eventDispatcher as DeviceInformationEventDispatcher;\n\n    this._informationManager.sendMessage = this\n      .sendTxMessages as SendInformationMessageCallback;\n    this._informationManager.eventDispatcher = this\n      .#eventDispatcher as InformationEventDispatcher;\n\n    this.#sensorConfigurationManager.sendMessage = this\n      .sendTxMessages as SendSensorConfigurationMessageCallback;\n    this.#sensorConfigurationManager.eventDispatcher = this\n      .#eventDispatcher as SensorConfigurationEventDispatcher;\n\n    this.#sensorDataManager.eventDispatcher = this\n      .#eventDispatcher as SensorDataEventDispatcher;\n\n    this.#vibrationManager.sendMessage = this\n      .sendTxMessages as SendVibrationMessageCallback;\n    this.#vibrationManager.eventDispatcher = this\n      .#eventDispatcher as VibrationEventDispatcher;\n\n    this.#tfliteManager.sendMessage = this\n      .sendTxMessages as SendTfliteMessageCallback;\n    this.#tfliteManager.eventDispatcher = this\n      .#eventDispatcher as TfliteEventDispatcher;\n\n    this.#fileTransferManager.sendMessage = this\n      .sendTxMessages as SendFileTransferMessageCallback;\n    this.#fileTransferManager.eventDispatcher = this\n      .#eventDispatcher as FileTransferEventDispatcher;\n\n    this.#wifiManager.sendMessage = this\n      .sendTxMessages as SendWifiMessageCallback;\n    this.#wifiManager.eventDispatcher = this\n      .#eventDispatcher as WifiEventDispatcher;\n\n    this.#cameraManager.sendMessage = this\n      .sendTxMessages as SendCameraMessageCallback;\n    this.#cameraManager.eventDispatcher = this\n      .#eventDispatcher as CameraEventDispatcher;\n\n    this.#microphoneManager.sendMessage = this\n      .sendTxMessages as SendMicrophoneMessageCallback;\n    this.#microphoneManager.eventDispatcher = this\n      .#eventDispatcher as MicrophoneEventDispatcher;\n\n    this.#displayManager.sendMessage = this\n      .sendTxMessages as SendDisplayMessageCallback;\n    this.#displayManager.eventDispatcher = this\n      .#eventDispatcher as DisplayEventDispatcher;\n\n    this.#firmwareManager.sendMessage = this\n      .sendSmpMessage as SendSmpMessageCallback;\n    this.#firmwareManager.eventDispatcher = this\n      .#eventDispatcher as FirmwareEventDispatcher;\n\n    this.addEventListener(\"getMtu\", () => {\n      this.#firmwareManager.mtu = this.mtu;\n      this.#fileTransferManager.mtu = this.mtu;\n      this.connectionManager!.mtu = this.mtu;\n      this.#displayManager.mtu = this.mtu;\n    });\n    this.addEventListener(\"getSensorConfiguration\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.sensorTypes.includes(\"pressure\")) {\n        _console.log(\"requesting required pressure information\");\n        const messages = RequiredPressureMessageTypes.map((messageType) => ({\n          type: messageType,\n        }));\n        this.sendTxMessages(messages, false);\n      } else {\n        _console.log(\"don't need to request pressure infomration\");\n      }\n\n      if (this.sensorTypes.includes(\"camera\")) {\n        _console.log(\"requesting required camera information\");\n        const messages = RequiredCameraMessageTypes.map((messageType) => ({\n          type: messageType,\n        }));\n        this.sendTxMessages(messages, false);\n      } else {\n        _console.log(\"don't need to request camera infomration\");\n      }\n\n      if (this.sensorTypes.includes(\"microphone\")) {\n        _console.log(\"requesting required microphone information\");\n        const messages = RequiredMicrophoneMessageTypes.map((messageType) => ({\n          type: messageType,\n        }));\n        this.sendTxMessages(messages, false);\n      } else {\n        _console.log(\"don't need to request microphone infomration\");\n      }\n    });\n    this.addEventListener(\"getFileTypes\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.fileTypes.length > 0) {\n        this.#fileTransferManager.requestRequiredInformation();\n      }\n      if (this.fileTypes.includes(\"tflite\")) {\n        this.#tfliteManager.requestRequiredInformation();\n      }\n    });\n    this.addEventListener(\"isWifiAvailable\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.connectionType == \"client\" && !isInNode) {\n        return;\n      }\n      if (this.isWifiAvailable) {\n        if (this.connectionType != \"client\") {\n          this.#wifiManager.requestRequiredInformation();\n        }\n      }\n    });\n    this.addEventListener(\"getType\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.type == \"glasses\") {\n        this.#displayManager.requestRequiredInformation();\n      }\n    });\n    DeviceManager.onDevice(this);\n    if (isInBrowser) {\n      window.addEventListener(\"beforeunload\", () => {\n        if (this.isConnected && this.clearSensorConfigurationOnLeave) {\n          this.clearSensorConfiguration();\n        }\n      });\n    }\n    if (isInNode) {\n      /** can add more node leave handlers https://gist.github.com/hyrious/30a878f6e6a057f09db87638567cb11a */\n      process.on(\"exit\", () => {\n        if (this.isConnected && this.clearSensorConfigurationOnLeave) {\n          this.clearSensorConfiguration();\n        }\n      });\n    }\n  }\n\n  static #DefaultConnectionManager(): BaseConnectionManager {\n    return new WebBluetoothConnectionManager();\n  }\n\n  #eventDispatcher: DeviceEventDispatcher = new EventDispatcher(\n    this as Device,\n    DeviceEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // CONNECTION MANAGER\n\n  #connectionManager?: BaseConnectionManager;\n  get connectionManager() {\n    return this.#connectionManager;\n  }\n  set connectionManager(newConnectionManager) {\n    if (this.connectionManager == newConnectionManager) {\n      _console.log(\"same connectionManager is already assigned\");\n      return;\n    }\n\n    if (this.connectionManager) {\n      this.connectionManager.remove();\n    }\n    if (newConnectionManager) {\n      newConnectionManager.onStatusUpdated =\n        this.#onConnectionStatusUpdated.bind(this);\n      newConnectionManager.onMessageReceived =\n        this.#onConnectionMessageReceived.bind(this);\n      newConnectionManager.onMessagesReceived =\n        this.#onConnectionMessagesReceived.bind(this);\n    }\n\n    this.#connectionManager = newConnectionManager;\n    _console.log(\"assigned new connectionManager\", this.#connectionManager);\n\n    this._informationManager.connectionType = this.connectionType;\n  }\n  async #sendTxMessages(messages?: TxMessage[], sendImmediately?: boolean) {\n    await this.#connectionManager?.sendTxMessages(messages, sendImmediately);\n  }\n  private sendTxMessages = this.#sendTxMessages.bind(this);\n\n  async connect(options?: ConnectOptions) {\n    _console.log(\"connect options\", options);\n    if (options) {\n      switch (options.type) {\n        case \"webBluetooth\":\n          if (this.connectionType != \"webBluetooth\") {\n            this.connectionManager = new WebBluetoothConnectionManager();\n          }\n          break;\n        case \"webSocket\":\n          {\n            let createConnectionManager = false;\n            if (this.connectionType == \"webSocket\") {\n              const connectionManager = this\n                .connectionManager as WebSocketConnectionManager;\n              if (\n                connectionManager.ipAddress != options.ipAddress ||\n                connectionManager.isSecure != options.isWifiSecure\n              ) {\n                createConnectionManager = true;\n              }\n            } else {\n              createConnectionManager = true;\n            }\n            if (createConnectionManager) {\n              this.connectionManager = new WebSocketConnectionManager(\n                options.ipAddress,\n                options.isWifiSecure,\n                this.bluetoothId\n              );\n            }\n          }\n\n          break;\n        case \"udp\":\n          {\n            let createConnectionManager = false;\n            if (this.connectionType == \"udp\") {\n              const connectionManager = this\n                .connectionManager as UDPConnectionManager;\n              if (connectionManager.ipAddress != options.ipAddress) {\n                createConnectionManager = true;\n              }\n              this.reconnectOnDisconnection = true;\n            } else {\n              createConnectionManager = true;\n            }\n            if (createConnectionManager) {\n              this.connectionManager = new UDPConnectionManager(\n                options.ipAddress,\n                this.bluetoothId\n              );\n            }\n          }\n          break;\n      }\n    }\n    if (!this.connectionManager) {\n      this.connectionManager = Device.#DefaultConnectionManager();\n    }\n    this.#clear();\n\n    if (options?.type == \"client\") {\n      _console.assertWithError(\n        this.connectionType == \"client\",\n        \"expected clientConnectionManager\"\n      );\n      const clientConnectionManager = this\n        .connectionManager as ClientConnectionManager;\n      clientConnectionManager.subType = options.subType;\n      return clientConnectionManager.connect();\n    }\n    _console.log(\"connectionManager type\", this.connectionManager.type);\n    return this.connectionManager.connect();\n  }\n  #isConnected = false;\n  get isConnected() {\n    return this.#isConnected;\n  }\n  /** @throws {Error} if not connected */\n  #assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"notConnected\");\n  }\n\n  #didReceiveMessageTypes(messageTypes: ConnectionMessageType[]) {\n    return messageTypes.every((messageType) => {\n      const hasConnectionMessage =\n        this.latestConnectionMessages.has(messageType);\n      if (!hasConnectionMessage) {\n        _console.log(`didn't receive \"${messageType}\" message`);\n      }\n      return hasConnectionMessage;\n    });\n  }\n  get #hasRequiredInformation() {\n    let hasRequiredInformation = this.#didReceiveMessageTypes(\n      RequiredInformationConnectionMessages\n    );\n    if (hasRequiredInformation && this.sensorTypes.includes(\"pressure\")) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredPressureMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.isWifiAvailable) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredWifiMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.fileTypes.length > 0) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredFileTransferMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.fileTypes.includes(\"tflite\")) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredTfliteMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.hasCamera) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredCameraMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.hasMicrophone) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredMicrophoneMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.isDisplayAvailable) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredDisplayMessageTypes\n      );\n    }\n    return hasRequiredInformation;\n  }\n  #requestRequiredInformation() {\n    _console.log(\"requesting required information\");\n    const messages: TxMessage[] = RequiredInformationConnectionMessages.map(\n      (messageType) => ({\n        type: messageType,\n      })\n    );\n    this.#sendTxMessages(messages);\n  }\n\n  get canReconnect() {\n    return this.connectionManager?.canReconnect;\n  }\n  #assertCanReconnect() {\n    _console.assertWithError(this.canReconnect, \"cannot reconnect to device\");\n  }\n  async reconnect() {\n    this.#assertCanReconnect();\n    this.#clear();\n    return this.connectionManager?.reconnect();\n  }\n\n  static async Connect() {\n    const device = new Device();\n    await device.connect();\n    return device;\n  }\n\n  static #ReconnectOnDisconnection = false;\n  static get ReconnectOnDisconnection() {\n    return this.#ReconnectOnDisconnection;\n  }\n  static set ReconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this.#ReconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  #reconnectOnDisconnection = Device.ReconnectOnDisconnection;\n  get reconnectOnDisconnection() {\n    return this.#reconnectOnDisconnection;\n  }\n  set reconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this.#reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n  #reconnectIntervalId?: NodeJS.Timeout | number;\n\n  get connectionType() {\n    return this.connectionManager?.type;\n  }\n  async disconnect() {\n    this.#assertIsConnected();\n    if (this.reconnectOnDisconnection) {\n      this.reconnectOnDisconnection = false;\n      this.addEventListener(\n        \"isConnected\",\n        () => {\n          this.reconnectOnDisconnection = true;\n        },\n        { once: true }\n      );\n    }\n\n    return this.connectionManager!.disconnect();\n  }\n\n  toggleConnection() {\n    if (this.isConnected) {\n      this.disconnect();\n    } else if (this.canReconnect) {\n      try {\n        this.reconnect();\n      } catch (error) {\n        _console.error(\"error trying to reconnect\", error);\n        this.connect();\n      }\n    } else {\n      this.connect();\n    }\n  }\n\n  get connectionStatus(): ConnectionStatus {\n    switch (this.#connectionManager?.status) {\n      case \"connected\":\n        return this.isConnected ? \"connected\" : \"connecting\";\n      case \"notConnected\":\n      case \"connecting\":\n      case \"disconnecting\":\n        return this.#connectionManager.status;\n      default:\n        return \"notConnected\";\n    }\n  }\n  get isConnectionBusy() {\n    return (\n      this.connectionStatus == \"connecting\" ||\n      this.connectionStatus == \"disconnecting\"\n    );\n  }\n\n  #onConnectionStatusUpdated(connectionStatus: ConnectionStatus) {\n    _console.log({ connectionStatus });\n\n    if (connectionStatus == \"notConnected\") {\n      this.#clearConnection();\n\n      if (this.canReconnect && this.reconnectOnDisconnection) {\n        _console.log(\"starting reconnect interval...\");\n        this.#reconnectIntervalId = setInterval(() => {\n          _console.log(\"attempting reconnect...\");\n          this.reconnect();\n        }, 1000);\n      }\n    } else {\n      if (this.#reconnectIntervalId != undefined) {\n        _console.log(\"clearing reconnect interval\");\n        clearInterval(this.#reconnectIntervalId);\n        this.#reconnectIntervalId = undefined;\n      }\n    }\n\n    this.#checkConnection();\n\n    if (connectionStatus == \"connected\" && !this.#isConnected) {\n      if (this.connectionType != \"client\") {\n        this.#requestRequiredInformation();\n      }\n    }\n\n    DeviceManager.OnDeviceConnectionStatusUpdated(this, connectionStatus);\n  }\n\n  #dispatchConnectionEvents(includeIsConnected: boolean = false) {\n    this.#dispatchEvent(\"connectionStatus\", {\n      connectionStatus: this.connectionStatus,\n    });\n    this.#dispatchEvent(this.connectionStatus, {});\n    if (includeIsConnected) {\n      this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    }\n  }\n  #checkConnection() {\n    this.#isConnected =\n      Boolean(this.connectionManager?.isConnected) &&\n      this.#hasRequiredInformation &&\n      this._informationManager.isCurrentTimeSet;\n\n    switch (this.connectionStatus) {\n      case \"connected\":\n        if (this.#isConnected) {\n          this.#dispatchConnectionEvents(true);\n        }\n        break;\n      case \"notConnected\":\n        this.#dispatchConnectionEvents(true);\n        break;\n      default:\n        this.#dispatchConnectionEvents(false);\n        break;\n    }\n  }\n\n  #clear() {\n    this.#clearConnection();\n    this._informationManager.clear();\n    this.#deviceInformationManager.clear();\n    this.#tfliteManager.clear();\n    this.#wifiManager.clear();\n    this.#cameraManager.clear();\n    this.#microphoneManager.clear();\n    this.#displayManager.clear();\n  }\n  #clearConnection() {\n    this.connectionManager?.clear();\n    this.latestConnectionMessages.clear();\n  }\n\n  #onConnectionMessageReceived(\n    messageType: ConnectionMessageType,\n    dataView: DataView\n  ) {\n    _console.log({ messageType, dataView });\n    switch (messageType) {\n      case \"batteryLevel\":\n        const batteryLevel = dataView.getUint8(0);\n        _console.log(\"received battery level\", { batteryLevel });\n        this.#updateBatteryLevel(batteryLevel);\n        break;\n\n      default:\n        if (\n          FileTransferMessageTypes.includes(\n            messageType as FileTransferMessageType\n          )\n        ) {\n          this.#fileTransferManager.parseMessage(\n            messageType as FileTransferMessageType,\n            dataView\n          );\n        } else if (\n          TfliteMessageTypes.includes(messageType as TfliteMessageType)\n        ) {\n          this.#tfliteManager.parseMessage(\n            messageType as TfliteMessageType,\n            dataView\n          );\n        } else if (\n          SensorDataMessageTypes.includes(messageType as SensorDataMessageType)\n        ) {\n          this.#sensorDataManager.parseMessage(\n            messageType as SensorDataMessageType,\n            dataView\n          );\n        } else if (\n          FirmwareMessageTypes.includes(messageType as FirmwareMessageType)\n        ) {\n          this.#firmwareManager.parseMessage(\n            messageType as FirmwareMessageType,\n            dataView\n          );\n        } else if (\n          DeviceInformationTypes.includes(messageType as DeviceInformationType)\n        ) {\n          this.#deviceInformationManager.parseMessage(\n            messageType as DeviceInformationType,\n            dataView\n          );\n        } else if (\n          InformationMessageTypes.includes(\n            messageType as InformationMessageType\n          )\n        ) {\n          this._informationManager.parseMessage(\n            messageType as InformationMessageType,\n            dataView\n          );\n        } else if (\n          SensorConfigurationMessageTypes.includes(\n            messageType as SensorConfigurationMessageType\n          )\n        ) {\n          this.#sensorConfigurationManager.parseMessage(\n            messageType as SensorConfigurationMessageType,\n            dataView\n          );\n        } else if (\n          VibrationMessageTypes.includes(messageType as VibrationMessageType)\n        ) {\n          this.#vibrationManager.parseMessage(\n            messageType as VibrationMessageType,\n            dataView\n          );\n        } else if (WifiMessageTypes.includes(messageType as WifiMessageType)) {\n          this.#wifiManager.parseMessage(\n            messageType as WifiMessageType,\n            dataView\n          );\n        } else if (\n          CameraMessageTypes.includes(messageType as CameraMessageType)\n        ) {\n          this.#cameraManager.parseMessage(\n            messageType as CameraMessageType,\n            dataView\n          );\n        } else if (\n          MicrophoneMessageTypes.includes(messageType as MicrophoneMessageType)\n        ) {\n          this.#microphoneManager.parseMessage(\n            messageType as MicrophoneMessageType,\n            dataView\n          );\n        } else if (\n          DisplayMessageTypes.includes(messageType as DisplayMessageType)\n        ) {\n          this.#displayManager.parseMessage(\n            messageType as DisplayMessageType,\n            dataView\n          );\n        } else {\n          throw Error(`uncaught messageType ${messageType}`);\n        }\n    }\n\n    this.latestConnectionMessages.set(messageType, dataView);\n    if (messageType.startsWith(\"set\")) {\n      this.latestConnectionMessages.set(\n        // @ts-expect-error\n        messageType.replace(\"set\", \"get\"),\n        dataView\n      );\n    }\n    this.#dispatchEvent(\"connectionMessage\", { messageType, dataView });\n  }\n  #onConnectionMessagesReceived() {\n    if (!this.isConnected && this.#hasRequiredInformation) {\n      this.#checkConnection();\n    }\n    if (\n      this.connectionStatus == \"notConnected\" ||\n      this.connectionStatus == \"disconnecting\"\n    ) {\n      return;\n    }\n    this.#sendTxMessages();\n  }\n\n  latestConnectionMessages: Map<ConnectionMessageType, DataView> = new Map();\n\n  // DEVICE INFORMATION\n  #deviceInformationManager = new DeviceInformationManager();\n  get deviceInformation() {\n    return this.#deviceInformationManager.information;\n  }\n\n  // BATTERY LEVEL\n  #batteryLevel = 0;\n  get batteryLevel() {\n    return this.#batteryLevel;\n  }\n  #updateBatteryLevel(updatedBatteryLevel: number) {\n    _console.assertTypeWithError(updatedBatteryLevel, \"number\");\n    if (this.#batteryLevel == updatedBatteryLevel) {\n      _console.log(`duplicate batteryLevel assignment ${updatedBatteryLevel}`);\n      return;\n    }\n    this.#batteryLevel = updatedBatteryLevel;\n    _console.log({ updatedBatteryLevel: this.#batteryLevel });\n    this.#dispatchEvent(\"batteryLevel\", { batteryLevel: this.#batteryLevel });\n  }\n\n  // INFORMATION\n  /** @private */\n  _informationManager = new InformationManager();\n\n  get id() {\n    return this._informationManager.id;\n  }\n\n  get isCharging() {\n    return this._informationManager.isCharging;\n  }\n  get batteryCurrent() {\n    return this._informationManager.batteryCurrent;\n  }\n  get getBatteryCurrent() {\n    return this._informationManager.getBatteryCurrent;\n  }\n\n  get name() {\n    return this._informationManager.name;\n  }\n  get setName() {\n    return this._informationManager.setName;\n  }\n\n  get type() {\n    return this._informationManager.type;\n  }\n  get setType() {\n    return this._informationManager.setType;\n  }\n\n  get isInsole() {\n    return this._informationManager.isInsole;\n  }\n  get isGlove() {\n    return this._informationManager.isGlove;\n  }\n  get side() {\n    return this._informationManager.side;\n  }\n\n  get mtu() {\n    return this._informationManager.mtu;\n  }\n\n  // SENSOR TYPES\n  get sensorTypes() {\n    return Object.keys(this.sensorConfiguration) as SensorType[];\n  }\n  get continuousSensorTypes() {\n    return ContinuousSensorTypes.filter((sensorType) =>\n      this.sensorTypes.includes(sensorType)\n    );\n  }\n\n  // SENSOR CONFIGURATION\n\n  #sensorConfigurationManager = new SensorConfigurationManager();\n\n  get sensorConfiguration() {\n    return this.#sensorConfigurationManager.configuration;\n  }\n\n  get setSensorConfiguration() {\n    return this.#sensorConfigurationManager.setConfiguration;\n  }\n\n  async clearSensorConfiguration() {\n    return this.#sensorConfigurationManager.clearSensorConfiguration();\n  }\n\n  static #ClearSensorConfigurationOnLeave = true;\n  static get ClearSensorConfigurationOnLeave() {\n    return this.#ClearSensorConfigurationOnLeave;\n  }\n  static set ClearSensorConfigurationOnLeave(\n    newClearSensorConfigurationOnLeave\n  ) {\n    _console.assertTypeWithError(newClearSensorConfigurationOnLeave, \"boolean\");\n    this.#ClearSensorConfigurationOnLeave = newClearSensorConfigurationOnLeave;\n  }\n\n  #clearSensorConfigurationOnLeave = Device.ClearSensorConfigurationOnLeave;\n  get clearSensorConfigurationOnLeave() {\n    return this.#clearSensorConfigurationOnLeave;\n  }\n  set clearSensorConfigurationOnLeave(newClearSensorConfigurationOnLeave) {\n    _console.assertTypeWithError(newClearSensorConfigurationOnLeave, \"boolean\");\n    this.#clearSensorConfigurationOnLeave = newClearSensorConfigurationOnLeave;\n  }\n\n  // PRESSURE\n  get numberOfPressureSensors() {\n    return this.#sensorDataManager.pressureSensorDataManager.numberOfSensors;\n  }\n\n  // SENSOR DATA\n  #sensorDataManager = new SensorDataManager();\n  resetPressureRange() {\n    this.#sensorDataManager.pressureSensorDataManager.resetRange();\n  }\n\n  // VIBRATION\n  get vibrationLocations() {\n    return this.#vibrationManager.vibrationLocations;\n  }\n\n  #vibrationManager = new VibrationManager();\n  async triggerVibration(\n    vibrationConfigurations: VibrationConfiguration[],\n    sendImmediately?: boolean\n  ) {\n    this.#vibrationManager.triggerVibration(\n      vibrationConfigurations,\n      sendImmediately\n    );\n  }\n\n  // FILE TRANSFER\n  #fileTransferManager = new FileTransferManager();\n\n  get fileTypes() {\n    return this.#fileTransferManager.fileTypes;\n  }\n  get maxFileLength() {\n    return this.#fileTransferManager.maxLength;\n  }\n  get validFileTypes() {\n    return FileTypes.filter((fileType) => {\n      if (fileType.includes(\"wifi\") && !this.isWifiAvailable) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  async sendFile(fileType: FileType, file: FileLike) {\n    _console.assertWithError(\n      this.validFileTypes.includes(fileType),\n      `invalid fileType ${fileType}`\n    );\n    const promise = this.waitForEvent(\"fileTransferComplete\");\n    this.#fileTransferManager.send(fileType, file);\n    await promise;\n  }\n  async receiveFile(fileType: FileType) {\n    const promise = this.waitForEvent(\"fileTransferComplete\");\n    this.#fileTransferManager.receive(fileType);\n    await promise;\n  }\n\n  get fileTransferStatus() {\n    return this.#fileTransferManager.status;\n  }\n\n  cancelFileTransfer() {\n    this.#fileTransferManager.cancel();\n  }\n\n  // TFLITE\n  #tfliteManager = new TfliteManager();\n\n  get tfliteName() {\n    return this.#tfliteManager.name;\n  }\n  get setTfliteName() {\n    return this.#tfliteManager.setName;\n  }\n\n  async sendTfliteConfiguration(configuration: TfliteFileConfiguration) {\n    configuration.type = \"tflite\";\n    this.#tfliteManager.sendConfiguration(configuration, false);\n    const didSendFile = await this.#fileTransferManager.send(\n      configuration.type,\n      configuration.file\n    );\n    if (!didSendFile) {\n      this.#sendTxMessages();\n    }\n  }\n\n  // TFLITE MODEL CONFIG\n  get tfliteTask() {\n    return this.#tfliteManager.task;\n  }\n  get setTfliteTask() {\n    return this.#tfliteManager.setTask;\n  }\n  get tfliteSampleRate() {\n    return this.#tfliteManager.sampleRate;\n  }\n  get setTfliteSampleRate() {\n    return this.#tfliteManager.setSampleRate;\n  }\n  get tfliteSensorTypes() {\n    return this.#tfliteManager.sensorTypes;\n  }\n  get allowedTfliteSensorTypes() {\n    return this.sensorTypes.filter((sensorType) =>\n      TfliteSensorTypes.includes(sensorType as TfliteSensorType)\n    );\n  }\n  get setTfliteSensorTypes() {\n    return this.#tfliteManager.setSensorTypes;\n  }\n  get tfliteIsReady() {\n    return this.#tfliteManager.isReady;\n  }\n\n  // TFLITE INFERENCING\n\n  get tfliteInferencingEnabled() {\n    return this.#tfliteManager.inferencingEnabled;\n  }\n  get setTfliteInferencingEnabled() {\n    return this.#tfliteManager.setInferencingEnabled;\n  }\n  async enableTfliteInferencing() {\n    return this.setTfliteInferencingEnabled(true);\n  }\n  async disableTfliteInferencing() {\n    return this.setTfliteInferencingEnabled(false);\n  }\n  get toggleTfliteInferencing() {\n    return this.#tfliteManager.toggleInferencingEnabled;\n  }\n\n  // TFLITE INFERENCE CONFIG\n\n  get tfliteCaptureDelay() {\n    return this.#tfliteManager.captureDelay;\n  }\n  get setTfliteCaptureDelay() {\n    return this.#tfliteManager.setCaptureDelay;\n  }\n  get tfliteThreshold() {\n    return this.#tfliteManager.threshold;\n  }\n  get setTfliteThreshold() {\n    return this.#tfliteManager.setThreshold;\n  }\n\n  // FIRMWARE MANAGER\n\n  #firmwareManager = new FirmwareManager();\n\n  get canUpdateFirmware() {\n    return this.#connectionManager?.canUpdateFirmware;\n  }\n  #assertCanUpdateFirmware() {\n    _console.assertWithError(this.canUpdateFirmware, \"can't update firmware\");\n  }\n\n  #sendSmpMessage(data: ArrayBuffer) {\n    this.#assertCanUpdateFirmware();\n    return this.#connectionManager!.sendSmpMessage(data);\n  }\n  private sendSmpMessage = this.#sendSmpMessage.bind(this);\n\n  get uploadFirmware() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.uploadFirmware;\n  }\n  get canReset() {\n    return this.canUpdateFirmware;\n  }\n  async reset() {\n    _console.assertWithError(\n      this.canReset,\n      \"reset is not enabled for this device\"\n    );\n    await this.#firmwareManager.reset();\n    return this.#connectionManager!.disconnect();\n  }\n  get firmwareStatus() {\n    return this.#firmwareManager.status;\n  }\n  get getFirmwareImages() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.getImages;\n  }\n  get firmwareImages() {\n    return this.#firmwareManager.images;\n  }\n  get eraseFirmwareImage() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.eraseImage;\n  }\n  get confirmFirmwareImage() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.confirmImage;\n  }\n  get testFirmwareImage() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.testImage;\n  }\n\n  // SERVER SIDE\n  #isServerSide = false;\n  get isServerSide() {\n    return this.#isServerSide;\n  }\n  set isServerSide(newIsServerSide) {\n    if (this.#isServerSide == newIsServerSide) {\n      _console.log(\"redundant isServerSide assignment\");\n      return;\n    }\n    _console.log({ newIsServerSide });\n    this.#isServerSide = newIsServerSide;\n\n    this.#fileTransferManager.isServerSide = this.isServerSide;\n  }\n\n  // UKATON\n  get isUkaton() {\n    return this.deviceInformation.modelNumber.includes(\"Ukaton\");\n  }\n\n  // WIFI MANAGER\n  #wifiManager = new WifiManager();\n  get isWifiAvailable() {\n    return this.#wifiManager.isWifiAvailable;\n  }\n  get wifiSSID() {\n    return this.#wifiManager.wifiSSID;\n  }\n  async setWifiSSID(newWifiSSID: string) {\n    return this.#wifiManager.setWifiSSID(newWifiSSID);\n  }\n  get wifiPassword() {\n    return this.#wifiManager.wifiPassword;\n  }\n  async setWifiPassword(newWifiPassword: string) {\n    return this.#wifiManager.setWifiPassword(newWifiPassword);\n  }\n  get isWifiConnected() {\n    return this.#wifiManager.isWifiConnected;\n  }\n  get ipAddress() {\n    return this.#wifiManager.ipAddress;\n  }\n  get wifiConnectionEnabled() {\n    return this.#wifiManager.wifiConnectionEnabled;\n  }\n  get enableWifiConnection() {\n    return this.#wifiManager.enableWifiConnection;\n  }\n  get setWifiConnectionEnabled() {\n    return this.#wifiManager.setWifiConnectionEnabled;\n  }\n  get disableWifiConnection() {\n    return this.#wifiManager.disableWifiConnection;\n  }\n  get toggleWifiConnection() {\n    return this.#wifiManager.toggleWifiConnection;\n  }\n  get isWifiSecure() {\n    return this.#wifiManager.isWifiSecure;\n  }\n\n  async reconnectViaWebSockets() {\n    _console.assertWithError(this.isWifiConnected, \"wifi is not connected\");\n    _console.assertWithError(\n      this.connectionType != \"webSocket\",\n      \"already connected via webSockets\"\n    );\n    _console.assertTypeWithError(this.ipAddress, \"string\");\n    _console.log(\"reconnecting via websockets...\");\n    await this.disconnect();\n    await this.connect({\n      type: \"webSocket\",\n      ipAddress: this.ipAddress!,\n      isWifiSecure: this.isWifiSecure,\n    });\n  }\n\n  async reconnectViaUDP() {\n    _console.assertWithError(isInNode, \"udp is only available in node\");\n    _console.assertWithError(this.isWifiConnected, \"wifi is not connected\");\n    _console.assertWithError(\n      this.connectionType != \"udp\",\n      \"already connected via udp\"\n    );\n    _console.assertTypeWithError(this.ipAddress, \"string\");\n    _console.log(\"reconnecting via udp...\");\n    await this.disconnect();\n    await this.connect({\n      type: \"udp\",\n      ipAddress: this.ipAddress!,\n    });\n  }\n\n  // CAMERA MANAGER\n  #cameraManager = new CameraManager();\n  get hasCamera() {\n    return this.sensorTypes.includes(\"camera\");\n  }\n  get cameraStatus() {\n    return this.#cameraManager.cameraStatus;\n  }\n  #assertHasCamera() {\n    _console.assertWithError(this.hasCamera, \"camera not available\");\n  }\n  async takePicture(sensorRate: number = 10) {\n    this.#assertHasCamera();\n    if (this.sensorConfiguration.camera == 0) {\n      this.setSensorConfiguration({ camera: sensorRate }, false, false);\n    }\n    await this.#cameraManager.takePicture();\n  }\n  async focusCamera(sensorRate: number = 10) {\n    this.#assertHasCamera();\n    if (this.sensorConfiguration.camera == 0) {\n      this.setSensorConfiguration({ camera: sensorRate }, false, false);\n    }\n    await this.#cameraManager.focus();\n  }\n  async stopCamera() {\n    this.#assertHasCamera();\n    await this.#cameraManager.stop();\n  }\n  async wakeCamera() {\n    this.#assertHasCamera();\n    await this.#cameraManager.wake();\n  }\n  async sleepCamera() {\n    this.#assertHasCamera();\n    await this.#cameraManager.sleep();\n  }\n\n  get cameraConfiguration() {\n    return this.#cameraManager.cameraConfiguration;\n  }\n  get availableCameraConfigurationTypes() {\n    return this.#cameraManager.availableCameraConfigurationTypes;\n  }\n  get cameraConfigurationRanges() {\n    return this.#cameraManager.cameraConfigurationRanges;\n  }\n\n  get setCameraConfiguration() {\n    return this.#cameraManager.setCameraConfiguration;\n  }\n\n  // MICROPHONE\n  #microphoneManager = new MicrophoneManager();\n  get hasMicrophone() {\n    return this.sensorTypes.includes(\"microphone\");\n  }\n  get microphoneStatus() {\n    return this.#microphoneManager.microphoneStatus;\n  }\n  #assertHasMicrophone() {\n    _console.assertWithError(this.hasMicrophone, \"microphone not available\");\n  }\n\n  async startMicrophone() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.start();\n  }\n  async stopMicrophone() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.stop();\n  }\n  async enableMicrophoneVad() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.vad();\n  }\n  async toggleMicrophone() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.toggle();\n  }\n\n  get microphoneConfiguration() {\n    return this.#microphoneManager.microphoneConfiguration;\n  }\n  get availableMicrophoneConfigurationTypes() {\n    return this.#microphoneManager.availableMicrophoneConfigurationTypes;\n  }\n  get setMicrophoneConfiguration() {\n    return this.#microphoneManager.setMicrophoneConfiguration;\n  }\n\n  #assertWebAudioSupport() {\n    _console.assertWithError(AudioContext, \"WebAudio is not supported\");\n  }\n\n  get audioContext() {\n    this.#assertWebAudioSupport();\n    return this.#microphoneManager.audioContext;\n  }\n  set audioContext(newAudioContext) {\n    this.#assertWebAudioSupport();\n    this.#microphoneManager.audioContext = newAudioContext;\n  }\n  get microphoneMediaStreamDestination() {\n    this.#assertWebAudioSupport();\n    return this.#microphoneManager.mediaStreamDestination;\n  }\n  get microphoneGainNode() {\n    this.#assertWebAudioSupport();\n    return this.#microphoneManager.gainNode;\n  }\n\n  get isRecordingMicrophone() {\n    return this.#microphoneManager.isRecording;\n  }\n  startRecordingMicrophone() {\n    this.#assertWebAudioSupport();\n    this.#microphoneManager.startRecording();\n  }\n  stopRecordingMicrophone() {\n    this.#assertWebAudioSupport();\n    this.#microphoneManager.stopRecording();\n  }\n  toggleMicrophoneRecording() {\n    this.#assertWebAudioSupport();\n    this.#microphoneManager.toggleRecording();\n  }\n\n  // DISPLAY\n  #displayManager = new DisplayManager();\n\n  get isDisplayAvailable() {\n    return this.#displayManager.isAvailable;\n  }\n  get isDisplayReady() {\n    return this.#displayManager.isReady;\n  }\n  get displayContextState() {\n    return this.#displayManager.contextState;\n  }\n  get displayColors() {\n    return this.#displayManager.colors;\n  }\n  get displayBitmapColors() {\n    return this.#displayManager.bitmapColors;\n  }\n  get displayBitmapColorIndices() {\n    return this.#displayManager.bitmapColorIndices;\n  }\n  get displayColorOpacities() {\n    return this.#displayManager.opacities;\n  }\n  #assertDisplayIsAvailable() {\n    _console.assertWithError(this.isDisplayAvailable, \"display not available\");\n  }\n  get displayStatus() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.displayStatus;\n  }\n  get displayBrightness() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.brightness;\n  }\n  get setDisplayBrightness() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBrightness;\n  }\n\n  get displayInformation() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.displayInformation;\n  }\n  get numberOfDisplayColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.numberOfColors;\n  }\n\n  get wakeDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.wake;\n  }\n  get sleepDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.sleep;\n  }\n  get toggleDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.toggle;\n  }\n  get isDisplayAwake() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.isDisplayAwake;\n  }\n\n  get showDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.showDisplay;\n  }\n  get clearDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearDisplay;\n  }\n\n  get setDisplayColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setColor;\n  }\n  get setDisplayColorOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setColorOpacity;\n  }\n  get setDisplayOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setOpacity;\n  }\n\n  get saveDisplayContext() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.saveContext;\n  }\n  get restoreDisplayContext() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.restoreContext;\n  }\n\n  get clearDisplayRect() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearRect;\n  }\n\n  get selectDisplayFillColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectFillColor;\n  }\n  get selectDisplayLineColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectLineColor;\n  }\n  get setDisplayLineWidth() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setLineWidth;\n  }\n  get setDisplayRotation() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotation;\n  }\n  get clearDisplayRotation() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearRotation;\n  }\n\n  get setDisplaySegmentStartCap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentStartCap;\n  }\n  get setDisplaySegmentEndCap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentEndCap;\n  }\n  get setDisplaySegmentCap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentCap;\n  }\n\n  get setDisplaySegmentStartRadius() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentStartRadius;\n  }\n  get setDisplaySegmentEndRadius() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentEndRadius;\n  }\n  get setDisplaySegmentRadius() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentRadius;\n  }\n\n  get setDisplayCropTop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropTop;\n  }\n  get setDisplayCropRight() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropRight;\n  }\n  get setDisplayCropBottom() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropBottom;\n  }\n  get setDisplayCropLeft() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropLeft;\n  }\n  get setDisplayCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCrop;\n  }\n  get clearDisplayCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearCrop;\n  }\n\n  get setDisplayRotationCropTop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropTop;\n  }\n  get setDisplayRotationCropRight() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropRight;\n  }\n  get setDisplayRotationCropBottom() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropBottom;\n  }\n  get setDisplayRotationCropLeft() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropLeft;\n  }\n  get setDisplayRotationCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCrop;\n  }\n  get clearDisplayRotationCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearRotationCrop;\n  }\n  get flushDisplayContextCommands() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.flushDisplayContextCommands;\n  }\n\n  get drawDisplayRect() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawRect;\n  }\n  get drawDisplayCircle() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawCircle;\n  }\n  get drawDisplayEllipse() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawEllipse;\n  }\n  get drawDisplayRoundRect() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawRoundRect;\n  }\n  get drawDisplayPolygon() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawPolygon;\n  }\n  get drawDisplaySegment() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawSegment;\n  }\n  get drawDisplaySegments() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawSegments;\n  }\n  get drawDisplayArc() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawArc;\n  }\n  get drawDisplayArcEllipse() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawArcEllipse;\n  }\n  get drawDisplayBitmap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawBitmap;\n  }\n  get imageToDisplayBitmap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.imageToBitmap;\n  }\n  get quantizeDisplayImage() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.quantizeImage;\n  }\n\n  get setDisplayContextState() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setContextState;\n  }\n\n  get selectDisplayBitmapColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectBitmapColor;\n  }\n  get selectDisplayBitmapColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectBitmapColors;\n  }\n  get setDisplayBitmapColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapColor;\n  }\n  get setDisplayBitmapColorOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapColorOpacity;\n  }\n\n  get setDisplayBitmapScaleDirection() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScaleDirection;\n  }\n  get setDisplayBitmapScaleX() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScaleX;\n  }\n  get setDisplayBitmapScaleY() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScaleY;\n  }\n  get setDisplayBitmapScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScale;\n  }\n  get resetDisplayBitmapScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.resetBitmapScale;\n  }\n\n  // FILL - spritesheet, text, etc\n}\n\nexport default Device;\n","import Device, {\n  BoundDeviceEventListeners,\n  DeviceEventMap,\n} from \"../Device.ts\";\nimport {\n  DisplayBitmap,\n  DisplayBitmapColorPair,\n  DisplayBrightness,\n} from \"../DisplayManager.ts\";\nimport { assertValidBitmapPixels } from \"./BitmapUtils.ts\";\nimport { hexToRGB, rgbToHex, stringToRGB } from \"./ColorUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { DisplayContextCommandMessage } from \"./DisplayContextCommand.ts\";\nimport {\n  DisplayContextState,\n  DisplayContextStateKey,\n  DisplaySegmentCap,\n  PartialDisplayContextState,\n} from \"./DisplayContextState.ts\";\nimport DisplayContextStateHelper from \"./DisplayContextStateHelper.ts\";\nimport {\n  DisplayManagerInterface,\n  runDisplayContextCommand,\n} from \"./DisplayManagerInterface.ts\";\nimport {\n  assertValidColor,\n  assertValidOpacity,\n  assertValidSegmentCap,\n  DisplayBitmapScaleDirection,\n  displayBitmapScaleStep,\n  DisplayColorRGB,\n  DisplayCropDirection,\n  DisplayCropDirections,\n  DisplayCropDirectionToCommand,\n  DisplayCropDirectionToStateKey,\n  DisplayRotationCropDirectionToCommand,\n  DisplayRotationCropDirectionToStateKey,\n  formatRotation,\n  maxDisplayBitmapScale,\n  roundBitmapScale,\n} from \"./DisplayUtils.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"./EventDispatcher.ts\";\nimport { addEventListeners, removeEventListeners } from \"./EventUtils.ts\";\nimport {\n  clamp,\n  degToRad,\n  getVector2Angle,\n  getVector2Length,\n  normalizedVector2,\n  normalizeRadians,\n  Vector2,\n} from \"./MathUtils.ts\";\nimport { wait } from \"./Timer.ts\";\n\nconst _console = createConsole(\"DisplayCanvasHelper\", { log: true });\n\nexport const DisplayCanvasHelperEventTypes = [\n  \"contextState\",\n  \"numberOfColors\",\n  \"brightness\",\n  \"color\",\n  \"colorOpacity\",\n  \"opacity\",\n  \"resize\",\n  \"update\",\n  \"ready\",\n] as const;\nexport type DisplayCanvasHelperEventType =\n  (typeof DisplayCanvasHelperEventTypes)[number];\n\nexport interface DisplayCanvasHelperEventMessages {\n  contextState: {\n    contextState: DisplayContextState;\n    differences: DisplayContextStateKey[];\n  };\n  numberOfColors: {\n    numberOfColors: number;\n  };\n  brightness: {\n    brightness: DisplayBrightness;\n  };\n  color: {\n    colorIndex: number;\n    colorRGB: DisplayColorRGB;\n    colorHex: string;\n  };\n  colorOpacity: {\n    opacity: number;\n    colorIndex: number;\n  };\n  opacity: {\n    opacity: number;\n  };\n  resize: {\n    width: number;\n    height: number;\n  };\n  update: {};\n  ready: {};\n}\n\nexport type DisplayCanvasHelperEventDispatcher = EventDispatcher<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type DisplayCanvasHelperEvent = Event<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type DisplayCanvasHelperEventMap = EventMap<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type DisplayCanvasHelperEventListenerMap = EventListenerMap<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type BoundDisplayCanvasHelperEventListeners = BoundEventListeners<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\n\nexport type DisplayBoundingBox = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nclass DisplayCanvasHelper implements DisplayManagerInterface {\n  constructor() {\n    this.numberOfColors = 16;\n    this.#bitmapContext = this.#bitmapCanvas.getContext(\"2d\")!;\n    this.#bitmapContext.imageSmoothingEnabled = false;\n  }\n\n  // EVENT DISPATCHER\n  #eventDispatcher: DisplayCanvasHelperEventDispatcher = new EventDispatcher(\n    this as DisplayCanvasHelper,\n    DisplayCanvasHelperEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // CANVAS\n  #canvas?: HTMLCanvasElement;\n  get canvas() {\n    return this.#canvas;\n  }\n  set canvas(newCanvas) {\n    _console.assertWithError(\n      newCanvas?.nodeName == \"CANVAS\",\n      `assigned non-canvas type ${newCanvas?.nodeName}`\n    );\n    if (this.#canvas == newCanvas) {\n      _console.log(\"redundant canvas assignment\", newCanvas);\n      return;\n    }\n    this.#canvas = newCanvas;\n    _console.log(\"assigned canvas\", this.canvas);\n\n    this.#context = this.#canvas?.getContext(\"2d\", {\n      willReadFrequently: true,\n    })!;\n    this.#updateCanvas();\n  }\n  #context!: CanvasRenderingContext2D;\n  get context() {\n    return this.#context;\n  }\n\n  get width() {\n    return this.canvas?.width || 0;\n  }\n  get height() {\n    return this.canvas?.height || 0;\n  }\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n\n  #updateCanvas() {\n    if (!this.canvas) {\n      return;\n    }\n    this.canvas!.style.aspectRatio = `${this.aspectRatio}`;\n    if (!this.device?.isConnected) {\n      return;\n    }\n\n    _console.log(\"updateCanvas\");\n\n    const { width, height } = this.device.displayInformation!;\n    _console.log({ width, height });\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.canvas.style.aspectRatio = `${width / height}`;\n\n    this.#dispatchEvent(\"resize\", { width: this.width, height: this.height });\n\n    this.clearDisplay();\n  }\n\n  // CONTEXT STACK\n  #frontDrawStack: Function[] = [];\n  #rearDrawStack: Function[] = [];\n  #drawFrontDrawStack() {\n    if (!this.context) {\n      return;\n    }\n    this.#context.imageSmoothingEnabled = false;\n    this.#context.clearRect(0, 0, this.width, this.height);\n\n    this.#drawBackground();\n    this.#frontDrawStack.forEach((callback) => callback());\n    if (this.#applyTransparency) {\n      this.#applyTransparencyToCanvas();\n    }\n    this.#dispatchEvent(\"update\", {});\n  }\n  #applyTransparencyToCanvas() {\n    const ctx = this.context;\n    const imageData = ctx.getImageData(\n      0,\n      0,\n      this.canvas!.width,\n      this.canvas!.height\n    );\n    const data = imageData.data;\n\n    const alphaBoost = 1.0; // >1 = more opaque, try 1.1–1.5 for subtlety\n\n    for (let i = 0; i < data.length; i += 4) {\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n\n      // Perceived brightness\n      const brightness = 0.299 * r + 0.587 * g + 0.114 * b;\n      const alpha = Math.min(255, brightness * alphaBoost);\n\n      // Unpremultiply for clarity\n      const scale = alpha > 0 ? 255 / alpha : 0;\n      data[i] = Math.min(255, r * scale);\n      data[i + 1] = Math.min(255, g * scale);\n      data[i + 2] = Math.min(255, b * scale);\n      data[i + 3] = alpha;\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n  }\n\n  #drawBackground() {\n    this.#save();\n    this.context.fillStyle = this.#colorIndexToRgbString(0);\n    this.context.fillRect(0, 0, this.width, this.height);\n    this.#restore();\n  }\n  #applyTransparency = false;\n  get applyTransparency() {\n    return this.#applyTransparency;\n  }\n  set applyTransparency(newValue) {\n    this.#applyTransparency = newValue;\n    _console.log({ applyTransparency: this.applyTransparency });\n    this.#drawFrontDrawStack();\n  }\n\n  // DEVICE\n  #device?: Device;\n  get device() {\n    return this.#device;\n  }\n  set device(newDevice) {\n    if (this.#device == newDevice) {\n      _console.log(\"redundant device assignment\", newDevice);\n      return;\n    }\n    if (newDevice) {\n      _console.assertWithError(\n        newDevice.isConnected,\n        \"device must be connected\"\n      );\n      _console.assertWithError(\n        newDevice.isDisplayAvailable,\n        \"display must have a display\"\n      );\n    }\n    if (this.#device) {\n      removeEventListeners(this.device, this.#boundDeviceEventListeners);\n      this.#isReady = true;\n    }\n    this.#device = newDevice;\n    addEventListeners(this.#device, this.#boundDeviceEventListeners);\n    _console.log(\"assigned device\", this.device);\n    if (this.device) {\n      this.numberOfColors = this.device.numberOfDisplayColors!;\n      this.#updateCanvas();\n      this.#updateDevice();\n      this.#isReady = this.device.isDisplayReady;\n    }\n  }\n\n  // DEVICE EVENTLISTENERS\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    connected: this.#onDeviceConnected.bind(this),\n    notConnected: this.#onDeviceNotConnected.bind(this),\n    displayReady: this.#onDeviceDisplayReady.bind(this),\n  };\n  #onDeviceConnected(event: DeviceEventMap[\"connected\"]) {\n    _console.log(\"device connected\");\n    this.#updateCanvas();\n    this.#updateDevice();\n    // FIX - messages flushed properly?\n  }\n  #onDeviceNotConnected(event: DeviceEventMap[\"notConnected\"]) {\n    _console.log(\"device not connected\");\n  }\n  async #onDeviceDisplayReady(event: DeviceEventMap[\"displayReady\"]) {\n    _console.log(\"device display ready\");\n    this.#isReady = true;\n    // await wait(5); // we need to wait for some reason\n    this.#dispatchEvent(\"ready\", {});\n  }\n\n  #updateDevice() {\n    this.#updateDeviceColors(true);\n    this.#updateDeviceOpacity(true);\n    this.#updateDeviceContextState(true);\n    this.#updateDeviceBrightness(true);\n  }\n\n  // NUMBER OF COLORS\n  #numberOfColors: number = 0;\n  get numberOfColors() {\n    return this.#numberOfColors;\n  }\n  set numberOfColors(newNumberOfColors) {\n    if (this.#numberOfColors == newNumberOfColors) {\n      return;\n    }\n\n    this.#numberOfColors = newNumberOfColors;\n    _console.log({ numberOfColors: this.numberOfColors });\n\n    this.#colors = new Array(this.numberOfColors).fill(\"#000000\");\n    this.#opacities = new Array(this.numberOfColors).fill(1);\n    this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n\n    this.#dispatchEvent(\"numberOfColors\", {\n      numberOfColors: this.numberOfColors,\n    });\n  }\n\n  // COLORS\n  #assertValidColorIndex(colorIndex: number) {\n    _console.assertRangeWithError(\n      \"colorIndex\",\n      colorIndex,\n      0,\n      this.numberOfColors\n    );\n  }\n  #colors: string[] = [];\n  get colors() {\n    return this.#colors;\n  }\n  #resetColors() {\n    this.#colors.length = 0;\n  }\n  async #updateDeviceColors(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    for (const [index, color] of this.colors.entries()) {\n      await this.device?.setDisplayColor(index, color, false);\n    }\n    if (sendImmediately) {\n      await this.#device?.flushDisplayContextCommands();\n    }\n  }\n\n  // OPACITIES\n  #opacities: number[] = [];\n  get opacities() {\n    return this.#opacities;\n  }\n  #resetOpacities() {\n    this.#opacities.length = 0;\n  }\n\n  async #updateDeviceOpacity(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    for (const [index, opacity] of this.#opacities.entries()) {\n      await this.device?.setDisplayColorOpacity(index, opacity, false);\n    }\n    if (sendImmediately) {\n      await this.#device?.flushDisplayContextCommands();\n    }\n  }\n\n  // CONEXT STATE\n  #displayContextStateHelper = new DisplayContextStateHelper();\n  get contextState() {\n    return this.#displayContextStateHelper.state;\n  }\n  #onDisplayContextStateUpdate(differences: DisplayContextStateKey[]) {\n    this.#dispatchEvent(\"contextState\", {\n      contextState: structuredClone(this.contextState),\n      differences,\n    });\n  }\n  #resetContextState() {\n    this.#displayContextStateHelper.reset();\n  }\n  #updateDeviceContextState(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    _console.log(\"updateDeviceContextState\");\n    this.device?.setDisplayContextState(this.contextState, sendImmediately);\n  }\n\n  async showDisplay(sendImmediately = true) {\n    _console.log(\"showDisplay\");\n\n    this.#frontDrawStack = this.#rearDrawStack.slice();\n    this.#rearDrawStack.length = 0;\n\n    this.#drawFrontDrawStack();\n\n    this.#isReady = false;\n\n    if (this.device?.isConnected) {\n      await this.device.showDisplay(sendImmediately);\n    } else {\n      await wait(this.#interval);\n      this.#isReady = true;\n      this.#dispatchEvent(\"ready\", {});\n    }\n  }\n  #interval = 50;\n  get interval() {\n    return this.#interval;\n  }\n  set interval(newInterval) {\n    this.#interval = newInterval;\n    _console.log({ interval: this.#interval });\n  }\n\n  #isReady = true;\n  get isReady() {\n    return this.#isReady;\n  }\n\n  async clearDisplay(sendImmediately = true) {\n    _console.log(\"clearDisplay\");\n\n    this.#frontDrawStack.length = 0;\n    this.#rearDrawStack.length = 0;\n\n    this.#isReady = false;\n\n    this.#context.clearRect(0, 0, this.width, this.height);\n    this.#drawBackground();\n\n    if (this.device?.isConnected) {\n      await this.device.clearDisplay(sendImmediately);\n    } else {\n      await wait(this.#interval);\n      this.#isReady = true;\n      this.#dispatchEvent(\"ready\", {});\n    }\n  }\n\n  async setColor(\n    colorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    let colorRGB: DisplayColorRGB;\n    if (typeof color == \"string\") {\n      colorRGB = stringToRGB(color);\n    } else {\n      colorRGB = color;\n    }\n    const colorHex = rgbToHex(colorRGB);\n    if (this.colors[colorIndex] == colorHex) {\n      _console.log(`redundant color #${colorIndex} ${colorHex}`);\n      return;\n    }\n\n    _console.log(`setting color #${colorIndex}`, color);\n    this.#assertValidColorIndex(colorIndex);\n    assertValidColor(colorRGB);\n\n    if (this.device?.isConnected) {\n      await this.device.setDisplayColor(colorIndex, color, sendImmediately);\n    }\n\n    this.colors[colorIndex] = colorHex;\n    this.#drawFrontDrawStack();\n    this.#dispatchEvent(\"color\", { colorIndex, colorHex, colorRGB });\n  }\n\n  async setColorOpacity(\n    colorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    this.#assertValidColorIndex(colorIndex);\n    assertValidOpacity(opacity);\n    if (\n      Math.floor(255 * this.#opacities[colorIndex]) == Math.floor(255 * opacity)\n    ) {\n      _console.log(`redundant opacity #${colorIndex} ${opacity}`);\n      return;\n    }\n    if (this.device?.isConnected) {\n      await this.device.setDisplayColorOpacity(\n        colorIndex,\n        opacity,\n        sendImmediately\n      );\n    }\n\n    this.#opacities[colorIndex] = opacity;\n    this.#drawFrontDrawStack();\n    this.#dispatchEvent(\"colorOpacity\", { colorIndex, opacity });\n  }\n  async setOpacity(opacity: number, sendImmediately?: boolean) {\n    assertValidOpacity(opacity);\n    if (this.device?.isConnected) {\n      await this.device.setDisplayOpacity(opacity, sendImmediately);\n    }\n    this.#opacities.fill(opacity);\n    this.#drawFrontDrawStack();\n    this.#dispatchEvent(\"opacity\", { opacity });\n  }\n\n  // CONTEXT COMMANDS\n  async saveContext(sendImmediately?: boolean) {\n    // FILL\n    if (this.device?.isConnected) {\n      await this.device.saveDisplayContext(sendImmediately);\n    }\n    //this.#onDisplayContextStateUpdate(differences);\n  }\n  async restoreContext(sendImmediately?: boolean) {\n    // FILL\n    if (this.device?.isConnected) {\n      await this.device.restoreDisplayContext(sendImmediately);\n    }\n    //this.#onDisplayContextStateUpdate(differences);\n  }\n  async selectFillColor(fillColorIndex: number, sendImmediately?: boolean) {\n    this.#assertValidColorIndex(fillColorIndex);\n    const differences = this.#displayContextStateHelper.update({\n      fillColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected) {\n      await this.device.selectDisplayFillColor(fillColorIndex, sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async selectLineColor(lineColorIndex: number, sendImmediately?: boolean) {\n    this.#assertValidColorIndex(lineColorIndex);\n    const differences = this.#displayContextStateHelper.update({\n      lineColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected) {\n      await this.device.selectDisplayLineColor(lineColorIndex, sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  #assertValidLineWidth(lineWidth: number) {\n    _console.assertRangeWithError(\"lineWidth\", lineWidth, 0, this.width);\n  }\n  async setLineWidth(lineWidth: number, sendImmediately?: boolean) {\n    this.#assertValidLineWidth(lineWidth);\n    const differences = this.#displayContextStateHelper.update({\n      lineWidth,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected) {\n      await this.device.setDisplayLineWidth(lineWidth, sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async setRotation(\n    rotation: number,\n    isRadians: boolean,\n    sendImmediately?: boolean\n  ) {\n    rotation = isRadians ? rotation : degToRad(rotation);\n    rotation = normalizeRadians(rotation);\n    _console.log({ rotation });\n\n    const differences = this.#displayContextStateHelper.update({\n      rotation,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected) {\n      await this.device.setDisplayRotation(rotation, true, sendImmediately);\n    }\n\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async clearRotation(sendImmediately?: boolean) {\n    const differences = this.#displayContextStateHelper.update({\n      rotation: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected) {\n      await this.device.clearDisplayRotation(sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async setSegmentStartCap(\n    segmentStartCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentStartCap);\n    const differences = this.#displayContextStateHelper.update({\n      segmentStartCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentStartCap });\n    if (this.device?.isConnected) {\n      await this.device.setDisplaySegmentStartCap(\n        segmentStartCap,\n        sendImmediately\n      );\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async setSegmentEndCap(\n    segmentEndCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentEndCap);\n    const differences = this.#displayContextStateHelper.update({\n      segmentEndCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentEndCap });\n    if (this.device?.isConnected) {\n      await this.device.setDisplaySegmentEndCap(segmentEndCap, sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async setSegmentCap(\n    segmentCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentCap);\n    const differences = this.#displayContextStateHelper.update({\n      segmentStartCap: segmentCap,\n      segmentEndCap: segmentCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentCap });\n    if (this.device?.isConnected) {\n      await this.device.setDisplaySegmentCap(segmentCap, sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async setSegmentStartRadius(\n    segmentStartRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#displayContextStateHelper.update({\n      segmentStartRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentStartRadius });\n    if (this.device?.isConnected) {\n      await this.device.setDisplaySegmentStartRadius(\n        segmentStartRadius,\n        sendImmediately\n      );\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async setSegmentEndRadius(\n    segmentEndRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#displayContextStateHelper.update({\n      segmentEndRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentEndRadius });\n    if (this.device?.isConnected) {\n      await this.device.setDisplaySegmentEndRadius(\n        segmentEndRadius,\n        sendImmediately\n      );\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  // START\n  async setSegmentRadius(segmentRadius: number, sendImmediately?: boolean) {\n    const differences = this.#displayContextStateHelper.update({\n      segmentStartRadius: segmentRadius,\n      segmentEndRadius: segmentRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ segmentRadius });\n    if (this.device?.isConnected) {\n      await this.device.setDisplaySegmentRadius(segmentRadius, sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async setCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    crop = Math.max(0, crop);\n    const cropCommand = DisplayCropDirectionToCommand[cropDirection];\n    const cropKey = DisplayCropDirectionToStateKey[cropDirection];\n    const differences = this.#displayContextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ [cropCommand]: crop });\n    if (this.device?.isConnected) {\n      await this.device.setDisplayCrop(cropDirection, crop, sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async setCropTop(cropTop: number, sendImmediately?: boolean) {\n    await this.setCrop(\"top\", cropTop, sendImmediately);\n  }\n  async setCropRight(cropRight: number, sendImmediately?: boolean) {\n    await this.setCrop(\"right\", cropRight, sendImmediately);\n  }\n  async setCropBottom(cropBottom: number, sendImmediately?: boolean) {\n    await this.setCrop(\"bottom\", cropBottom, sendImmediately);\n  }\n  async setCropLeft(cropLeft: number, sendImmediately?: boolean) {\n    await this.setCrop(\"left\", cropLeft, sendImmediately);\n  }\n  async clearCrop(sendImmediately?: boolean) {\n    const differences = this.#displayContextStateHelper.update({\n      cropTop: 0,\n      cropRight: 0,\n      cropBottom: 0,\n      cropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected) {\n      await this.device.clearDisplayCrop(sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n\n  async setRotationCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    const cropCommand = DisplayRotationCropDirectionToCommand[cropDirection];\n    const cropKey = DisplayRotationCropDirectionToStateKey[cropDirection];\n    const differences = this.#displayContextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    _console.log({ [cropCommand]: crop });\n    if (this.device?.isConnected) {\n      await this.device.setDisplayRotationCrop(\n        cropDirection,\n        crop,\n        sendImmediately\n      );\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n  async setRotationCropTop(rotationCropTop: number, sendImmediately?: boolean) {\n    await this.setRotationCrop(\"top\", rotationCropTop, sendImmediately);\n  }\n  async setRotationCropRight(\n    rotationCropRight: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"right\", rotationCropRight, sendImmediately);\n  }\n  async setRotationCropBottom(\n    rotationCropBottom: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"bottom\", rotationCropBottom, sendImmediately);\n  }\n  async setRotationCropLeft(\n    rotationCropLeft: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"left\", rotationCropLeft, sendImmediately);\n  }\n  async clearRotationCrop(sendImmediately?: boolean) {\n    const differences = this.#displayContextStateHelper.update({\n      rotationCropTop: 0,\n      rotationCropRight: 0,\n      rotationCropBottom: 0,\n      rotationCropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected) {\n      await this.device.clearDisplayRotationCrop(sendImmediately);\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n\n  get bitmapColorIndices() {\n    return this.contextState.bitmapColorIndices;\n  }\n  get bitmapColors() {\n    return this.bitmapColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  async selectBitmapColor(\n    bitmapColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.#assertValidColorIndex(bitmapColorIndex);\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    const differences = this.#displayContextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected) {\n      await this.device.selectDisplayBitmapColor(\n        bitmapColorIndex,\n        colorIndex,\n        sendImmediately\n      );\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n\n  async selectBitmapColors(\n    bitmapColorPairs: DisplayBitmapColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"bitmapColors\",\n      bitmapColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n      this.#assertValidColorIndex(bitmapColorIndex);\n      this.#assertValidColorIndex(colorIndex);\n      bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    });\n\n    const differences = this.#displayContextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected) {\n      await this.device.selectDisplayBitmapColors(\n        bitmapColorPairs,\n        sendImmediately\n      );\n    }\n    this.#onDisplayContextStateUpdate(differences);\n  }\n\n  async setBitmapColor(\n    bitmapColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.bitmapColorIndices[bitmapColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setBitmapColorOpacity(\n    bitmapColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.bitmapColorIndices[bitmapColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n\n  async setBitmapScaleDirection(\n    direction: DisplayBitmapScaleDirection,\n    bitmapScale: number,\n    sendImmediately?: boolean\n  ) {\n    bitmapScale = clamp(\n      bitmapScale,\n      displayBitmapScaleStep,\n      maxDisplayBitmapScale\n    );\n    bitmapScale = roundBitmapScale(bitmapScale);\n    const newState: PartialDisplayContextState = {};\n    switch (direction) {\n      case \"all\":\n        newState.bitmapScaleX = bitmapScale;\n        newState.bitmapScaleY = bitmapScale;\n        break;\n      case \"x\":\n        newState.bitmapScaleX = bitmapScale;\n        break;\n      case \"y\":\n        newState.bitmapScaleY = bitmapScale;\n        break;\n    }\n    const differences = this.#displayContextStateHelper.update(newState);\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected) {\n      await this.device.setDisplayBitmapScaleDirection(\n        direction,\n        bitmapScale,\n        sendImmediately\n      );\n    }\n\n    this.#onDisplayContextStateUpdate(differences);\n  }\n\n  async setBitmapScaleX(bitmapScaleX: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"x\", bitmapScaleX, sendImmediately);\n  }\n  async setBitmapScaleY(bitmapScaleY: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"y\", bitmapScaleY, sendImmediately);\n  }\n  async setBitmapScale(bitmapScale: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"all\", bitmapScale, sendImmediately);\n  }\n  async resetBitmapScale(sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"all\", 1, sendImmediately);\n  }\n\n  #clearRectToCanvas(x: number, y: number, width: number, height: number) {\n    this.#save();\n    this.context.resetTransform();\n    this.context.fillStyle = this.#colorIndexToRgbString(0);\n    this.context.fillRect(x, y, width, height);\n    this.#restore();\n  }\n  async clearRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    this.#rearDrawStack.push(() =>\n      this.#clearRectToCanvas(x, y, width, height)\n    );\n    if (this.device?.isConnected) {\n      await this.device.clearDisplayRect(x, y, width, height, sendImmediately);\n    }\n  }\n  #save() {\n    const ctx = this.context;\n    ctx.save();\n  }\n  #restore() {\n    const ctx = this.context;\n    ctx.restore();\n  }\n  #transformContext(centerX: number, centerY: number, rotation: number) {\n    const ctx = this.context;\n    ctx.translate(centerX, centerY);\n    ctx.rotate(rotation);\n  }\n  #rotateBoundingBox(\n    box: DisplayBoundingBox,\n    rotation: number\n  ): DisplayBoundingBox {\n    const centerX = box.x + box.width / 2;\n    const centerY = box.y + box.height / 2;\n    const hw = box.width / 2;\n    const hh = box.height / 2;\n\n    const cos = Math.cos(rotation);\n    const sin = Math.sin(rotation);\n\n    const corners = [\n      { x: -hw, y: -hh },\n      { x: hw, y: -hh },\n      { x: hw, y: hh },\n      { x: -hw, y: hh },\n    ];\n\n    const rotated = corners.map(({ x, y }) => ({\n      x: x * cos - y * sin,\n      y: x * sin + y * cos,\n    }));\n\n    const xs = rotated.map((p) => p.x);\n    const ys = rotated.map((p) => p.y);\n\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n\n    return {\n      x: centerX + minX,\n      y: centerY + minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  }\n  #clearBoundingBoxOnDraw = true;\n  #clearBoundingBox({ x, y, width, height }: DisplayBoundingBox) {\n    this.#clearRectToCanvas(x, y, width, height);\n  }\n  #getRectBoundingBox(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n    { lineWidth }: DisplayContextState\n  ): DisplayBoundingBox {\n    const outerPadding = Math.ceil(lineWidth / 2);\n    const boundingBox = {\n      x: centerX - width / 2 - outerPadding,\n      y: centerY - height / 2 - outerPadding,\n      width: width + outerPadding * 2,\n      height: height + outerPadding * 2,\n    };\n    return boundingBox;\n  }\n  #applyClip(\n    { x, y, height, width }: DisplayBoundingBox,\n    { cropTop, cropRight, cropBottom, cropLeft }: DisplayContextState\n  ) {\n    const ctx = this.context;\n    ctx.beginPath();\n    ctx.rect(x + cropLeft, y + cropTop, width - cropRight, height - cropBottom);\n    ctx.clip();\n  }\n  #applyRotationClip(\n    { x, y, height, width }: DisplayBoundingBox,\n    {\n      rotationCropTop,\n      rotationCropRight,\n      rotationCropBottom,\n      rotationCropLeft,\n    }: DisplayContextState\n  ) {\n    const ctx = this.context;\n    ctx.beginPath();\n    ctx.rect(\n      -width / 2 + rotationCropLeft,\n      -height / 2 + rotationCropTop,\n      width - rotationCropLeft - rotationCropRight,\n      height - rotationCropTop - rotationCropBottom\n    );\n    ctx.clip();\n  }\n\n  #hexToRgbWithOpacity(hex: string, opacity: number): DisplayColorRGB {\n    // Expand shorthand hex (#f00 → #ff0000)\n    if (hex.length === 4) {\n      hex = \"#\" + [...hex.slice(1)].map((c) => c + c).join(\"\");\n    }\n\n    const r = parseInt(hex.slice(1, 3), 16);\n    const g = parseInt(hex.slice(3, 5), 16);\n    const b = parseInt(hex.slice(5, 7), 16);\n\n    // Darken color by blending toward black\n    const darken = (c: number) => Math.round(c * opacity);\n\n    const dr = darken(r);\n    const dg = darken(g);\n    const db = darken(b);\n\n    return { r: dr, g: dg, b: db };\n  }\n  #hexToRgbStringWithOpacity(hex: string, opacity: number) {\n    const { r, g, b } = this.#hexToRgbWithOpacity(hex, opacity);\n    return `rgb(${r}, ${g}, ${b})`;\n  }\n  #getColorOpacity(colorIndex: number, includeBrightness = true) {\n    return this.opacities[colorIndex] * this.#brightnessOpacity;\n  }\n  #colorIndexToRgbString(colorIndex: number) {\n    return this.#hexToRgbStringWithOpacity(\n      this.colors[colorIndex],\n      this.#getColorOpacity(colorIndex, true)\n    );\n  }\n  #colorIndexToRgb(colorIndex: number) {\n    return this.#hexToRgbWithOpacity(\n      this.colors[colorIndex],\n      this.#getColorOpacity(colorIndex, true)\n    );\n  }\n  #updateContext({\n    lineWidth,\n    fillColorIndex,\n    lineColorIndex,\n  }: DisplayContextState) {\n    this.context.fillStyle = this.#colorIndexToRgbString(fillColorIndex);\n    this.context.strokeStyle = this.#colorIndexToRgbString(lineColorIndex);\n    this.context.lineWidth = lineWidth;\n  }\n  #drawRectToCanvas(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getRectBoundingBox(\n      centerX,\n      centerY,\n      width,\n      height,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(centerX, centerY, contextState.rotation);\n\n    this.#applyRotationClip(box, contextState);\n\n    const x = -width / 2;\n    const y = -height / 2;\n    this.context.fillRect(x, y, width, height);\n    if (contextState.lineWidth > 0) {\n      this.context.strokeRect(x, y, width, height);\n    }\n    this.#restore();\n  }\n  async drawRect(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawRectToCanvas(centerX, centerY, width, height, contextState)\n    );\n\n    if (this.device?.isConnected) {\n      await this.device.drawDisplayRect(\n        centerX,\n        centerY,\n        width,\n        height,\n        sendImmediately\n      );\n    }\n  }\n  #drawRoundRectToCanvas(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getRectBoundingBox(\n      centerX,\n      centerY,\n      width,\n      height,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(centerX, centerY, contextState.rotation);\n\n    this.#applyRotationClip(box, contextState);\n\n    const x = -width / 2;\n    const y = -height / 2;\n\n    this.context.beginPath();\n    this.context.roundRect(x, y, width, height, borderRadius);\n    this.context.fill();\n    if (contextState.lineWidth > 0) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawRoundRect(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawRoundRectToCanvas(\n        centerX,\n        centerY,\n        width,\n        height,\n        borderRadius,\n        contextState\n      )\n    );\n    if (this.device?.isConnected) {\n      await this.device.drawDisplayRoundRect(\n        centerX,\n        centerY,\n        width,\n        height,\n        borderRadius,\n        sendImmediately\n      );\n    }\n  }\n  #getCircleBoundingBox(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    contextState: DisplayContextState\n  ): DisplayBoundingBox {\n    const diameter = radius * 2;\n    return this.#getRectBoundingBox(\n      centerX,\n      centerY,\n      diameter,\n      diameter,\n      contextState\n    );\n  }\n  #drawCircleToCanvas(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getCircleBoundingBox(\n      centerX,\n      centerY,\n      radius,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n    this.#applyClip(box, contextState);\n\n    this.#transformContext(centerX, centerY, contextState.rotation);\n\n    this.#applyRotationClip(box, contextState);\n\n    this.context.beginPath();\n    this.context.arc(0, 0, radius, 0, 2 * Math.PI);\n    this.context.fill();\n    if (contextState.lineWidth) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawCircle(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawCircleToCanvas(centerX, centerY, radius, contextState)\n    );\n    if (this.device?.isConnected) {\n      await this.device.drawDisplayCircle(\n        centerX,\n        centerY,\n        radius,\n        sendImmediately\n      );\n    }\n  }\n  #getEllipseBoundingBox(\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    contextState: DisplayContextState\n  ): DisplayBoundingBox {\n    const diameterX = radiusX * 2;\n    const diameterY = radiusY * 2;\n    return this.#getRectBoundingBox(\n      centerX,\n      centerY,\n      diameterX,\n      diameterY,\n      contextState\n    );\n  }\n  #drawEllipseToCanvas(\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getEllipseBoundingBox(\n      centerX,\n      centerY,\n      radiusX,\n      radiusY,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(centerX, centerY, contextState.rotation);\n\n    this.#applyRotationClip(box, contextState);\n\n    this.context.beginPath();\n    this.context.ellipse(0, 0, radiusX, radiusY, 0, 0, 2 * Math.PI);\n    this.context.fill();\n    if (contextState.lineWidth > 0) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawEllipse(\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawEllipseToCanvas(\n        centerX,\n        centerY,\n        radiusX,\n        radiusY,\n        contextState\n      )\n    );\n    if (this.device?.isConnected) {\n      await this.device.drawDisplayEllipse(\n        centerX,\n        centerY,\n        radiusX,\n        radiusY,\n        sendImmediately\n      );\n    }\n  }\n  #getPolygonBoundingBox(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    numberOfSides: number,\n    { lineWidth }: DisplayContextState\n  ): DisplayBoundingBox {\n    let outerPadding = Math.ceil(lineWidth / 2);\n    const shapeFactor = 1 / Math.cos(Math.PI / numberOfSides);\n    outerPadding = Math.ceil(outerPadding * shapeFactor);\n\n    const diameter = radius * 2;\n    const boundingBox = {\n      x: centerX - radius - outerPadding,\n      y: centerY - radius - outerPadding,\n      width: diameter + outerPadding * 2,\n      height: diameter + outerPadding * 2,\n    };\n    return boundingBox;\n  }\n  #drawPolygonToCanvas(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    numberOfSides: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getPolygonBoundingBox(\n      centerX,\n      centerY,\n      radius,\n      numberOfSides,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyClip(box, contextState);\n\n    this.#transformContext(centerX, centerY, contextState.rotation);\n\n    this.#applyRotationClip(box, contextState);\n\n    this.context.beginPath();\n    const angleStep = (Math.PI * 2) / numberOfSides;\n    for (let i = 0; i < numberOfSides; i++) {\n      const angle = i * angleStep;\n      const x = radius * Math.cos(angle);\n      const y = radius * Math.sin(angle);\n      if (i === 0) {\n        this.context.moveTo(x, y);\n      } else {\n        this.context.lineTo(x, y);\n      }\n    }\n    this.context.closePath();\n\n    this.context.fill();\n    if (contextState.lineWidth > 0) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawPolygon(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    numberOfSides: number,\n    sendImmediately?: boolean\n  ) {\n    if (numberOfSides < 3) {\n      _console.error(`invalid numberOfSides ${numberOfSides}`);\n      return;\n    }\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawPolygonToCanvas(\n        centerX,\n        centerY,\n        radius,\n        numberOfSides,\n        contextState\n      )\n    );\n    if (this.device?.isConnected) {\n      await this.device.drawDisplayPolygon(\n        centerX,\n        centerY,\n        radius,\n        numberOfSides,\n        sendImmediately\n      );\n    }\n  }\n  #getSegmentBoundingBox(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    { lineWidth, segmentStartRadius, segmentEndRadius }: DisplayContextState\n  ): DisplayBoundingBox {\n    const outerPadding = Math.ceil(lineWidth / 2);\n    const segmentStartFullRadius = segmentStartRadius + outerPadding;\n    const segmentEndFullRadius = segmentEndRadius + outerPadding;\n    _console.log({ segmentStartFullRadius, segmentEndFullRadius });\n\n    const minX = Math.min(\n      startX - segmentStartFullRadius,\n      endX - segmentEndFullRadius\n    );\n    const maxX = Math.max(\n      startX + segmentStartFullRadius,\n      endX + segmentEndFullRadius\n    );\n    const minY = Math.min(\n      startY - segmentStartFullRadius,\n      endY - segmentEndFullRadius\n    );\n    const maxY = Math.max(\n      startY + segmentStartFullRadius,\n      endY + segmentEndFullRadius\n    );\n\n    _console.log(\"segmentBounds\", { minX, minY, maxX, maxY });\n\n    const boundingBox = {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n    _console.log(\"getSegmentBoundingBox\", boundingBox);\n    return boundingBox;\n  }\n  #getSegmentMidpoint(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    {\n      lineWidth,\n      segmentStartRadius,\n      segmentEndRadius,\n      segmentEndCap,\n      segmentStartCap,\n    }: DisplayContextState\n  ): Vector2 {\n    const outerPadding = Math.ceil(lineWidth / 2);\n    const vector: Vector2 = {\n      x: endX - startX,\n      y: endY - startY,\n    };\n    const segmentStartLength =\n      segmentStartCap == \"round\"\n        ? segmentStartRadius + outerPadding\n        : outerPadding;\n    const segmentEndLength =\n      segmentEndCap == \"round\" ? segmentEndRadius + outerPadding : outerPadding;\n    const unitVector = normalizedVector2(vector);\n\n    const innerStartX = startX - unitVector.x * segmentStartLength;\n    const innerStartY = startY - unitVector.y * segmentStartLength;\n    const innerEndX = endX + unitVector.x * segmentEndLength;\n    const innerEndY = endY + unitVector.y * segmentEndLength;\n\n    const midpoint: Vector2 = {\n      x: (innerStartX + innerEndX) / 2,\n      y: (innerStartY + innerEndY) / 2,\n    };\n    //_console.log(\"midpoint\", midpoint);\n    return midpoint;\n  }\n  #getOrientedSegmentBoundingBox(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    {\n      lineWidth,\n      segmentStartRadius,\n      segmentEndRadius,\n      segmentEndCap,\n      segmentStartCap,\n    }: DisplayContextState\n  ): DisplayBoundingBox {\n    const outerPadding = Math.ceil(lineWidth / 2);\n    const vector: Vector2 = {\n      x: endX - startX,\n      y: endY - startY,\n    };\n    const segmentStartLength =\n      segmentStartCap == \"round\"\n        ? segmentStartRadius + outerPadding\n        : outerPadding;\n    const segmentEndLength =\n      segmentEndCap == \"round\" ? segmentEndRadius + outerPadding : outerPadding;\n    const length =\n      getVector2Length(vector) + segmentStartLength + segmentEndLength;\n    const width =\n      (Math.max(segmentStartRadius, segmentEndRadius) + outerPadding) * 2;\n\n    const boundingBox = {\n      x: -width / 2,\n      y: -length / 2,\n      width: width,\n      height: length,\n    };\n    return boundingBox;\n  }\n  #applySegmentRotationClip(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    contextState: DisplayContextState\n  ) {\n    const vector: Vector2 = {\n      x: endX - startX,\n      y: endY - startY,\n    };\n    let rotation = getVector2Angle(vector);\n    rotation -= Math.PI / 2;\n    _console.log({ segmentRotation: rotation });\n    const midpoint: Vector2 = this.#getSegmentMidpoint(\n      startX,\n      startY,\n      endX,\n      endY,\n      contextState\n    );\n    this.context.translate(midpoint.x, midpoint.y);\n    this.context.rotate(rotation);\n    const box = this.#getOrientedSegmentBoundingBox(\n      startX,\n      startY,\n      endX,\n      endY,\n      contextState\n    );\n    this.#applyRotationClip(box, contextState);\n    this.context.resetTransform();\n  }\n  #drawSegmentToCanvas(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    contextState: DisplayContextState,\n    clearBoundingBox = true\n  ) {\n    this.#updateContext(contextState);\n\n    _console.log(\"drawSegmentToCanvas\", { startX, startY, endX, endY });\n\n    this.#save();\n    const box = this.#getSegmentBoundingBox(\n      startX,\n      startY,\n      endX,\n      endY,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw && clearBoundingBox) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyClip(box, contextState);\n\n    this.#applySegmentRotationClip(startX, startY, endX, endY, contextState);\n\n    const x0 = startX;\n    const x1 = endX;\n    const y0 = startY;\n    const y1 = endY;\n\n    const r0 = contextState.segmentStartRadius;\n    const r1 = contextState.segmentEndRadius;\n\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const len = Math.sqrt(dx * dx + dy * dy);\n    if (len === 0) return;\n\n    const ux = dx / len;\n    const uy = dy / len;\n\n    // Perpendicular vector\n    const px = -uy;\n    const py = ux;\n\n    // Start circle edge points\n    const sx1 = x0 + px * r0;\n    const sy1 = y0 + py * r0;\n    const sx2 = x0 - px * r0;\n    const sy2 = y0 - py * r0;\n\n    // End circle edge points\n    const ex1 = x1 + px * r1;\n    const ey1 = y1 + py * r1;\n    const ex2 = x1 - px * r1;\n    const ey2 = y1 - py * r1;\n\n    if (contextState.segmentStartCap == \"round\") {\n      this.context.beginPath();\n      this.context.arc(x0, y0, r0, 0, Math.PI * 2);\n      this.context.closePath();\n      this.context.fill();\n      if (contextState.lineWidth > 0) {\n        this.context.stroke();\n      }\n    }\n    if (contextState.segmentEndCap == \"round\") {\n      this.context.beginPath();\n      this.context.arc(x1, y1, r1, 0, Math.PI * 2);\n      this.context.closePath();\n      this.context.fill();\n      if (contextState.lineWidth > 0) {\n        this.context.stroke();\n      }\n    }\n\n    // full trapezoid\n    this.context.beginPath();\n    this.context.moveTo(sx1, sy1);\n    this.context.lineTo(ex1, ey1);\n    this.context.lineTo(ex2, ey2);\n    this.context.lineTo(sx2, sy2);\n    this.context.closePath();\n    this.context.fill();\n\n    // Stroke only the side edges\n    if (contextState.lineWidth > 0) {\n      this.context.beginPath();\n\n      // Start edge → end edge\n      this.context.moveTo(sx1, sy1);\n      this.context.lineTo(ex1, ey1);\n\n      // End cap (flat or not)\n      if (contextState.segmentEndCap === \"flat\") {\n        this.context.lineTo(ex2, ey2);\n      } else {\n        this.context.moveTo(ex2, ey2);\n      }\n\n      // Back to start side\n      this.context.lineTo(sx2, sy2);\n\n      // If both ends are flat, close the loop\n      if (\n        contextState.segmentStartCap === \"flat\" &&\n        contextState.segmentEndCap === \"flat\"\n      ) {\n        this.context.closePath();\n      }\n      // If only the start is flat, manually return to start to avoid gaps\n      else if (contextState.segmentStartCap === \"flat\") {\n        this.context.lineTo(sx1, sy1);\n        this.context.lineTo(ex1, ey1);\n      }\n\n      this.context.stroke();\n    }\n\n    this.#restore();\n  }\n  async drawSegment(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    sendImmediately?: boolean\n  ) {\n    if (startX == endX && startY == endY) {\n      _console.error(`cannot draw segment of length 0`);\n      return;\n    }\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawSegmentToCanvas(startX, startY, endX, endY, contextState)\n    );\n    if (this.device?.isConnected) {\n      await this.device.drawDisplaySegment(\n        startX,\n        startY,\n        endX,\n        endY,\n        sendImmediately\n      );\n    }\n  }\n  #drawSegmentsToCanvas(points: Vector2[], contextState: DisplayContextState) {\n    this.#updateContext(contextState);\n\n    _console.log(\"drawSegmentsToCanvas\", { segments: points });\n\n    points.forEach((segment, index) => {\n      if (index > 0) {\n        const previousPoint = points[index - 1];\n\n        const startX = previousPoint.x;\n        const startY = previousPoint.y;\n        const endX = segment.x;\n        const endY = segment.y;\n\n        const box = this.#getSegmentBoundingBox(\n          startX,\n          startY,\n          endX,\n          endY,\n          contextState\n        );\n        if (this.#clearBoundingBoxOnDraw) {\n          this.#clearBoundingBox(box);\n        }\n      }\n    });\n\n    points.forEach((segment, index) => {\n      if (index > 0) {\n        const previousPoint = points[index - 1];\n\n        const startX = previousPoint.x;\n        const startY = previousPoint.y;\n        const endX = segment.x;\n        const endY = segment.y;\n\n        this.#drawSegmentToCanvas(\n          startX,\n          startY,\n          endX,\n          endY,\n          contextState,\n          false\n        );\n      }\n    });\n  }\n  async drawSegments(points: Vector2[], sendImmediately?: boolean) {\n    _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n    _console.log({ points });\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawSegmentsToCanvas(points, contextState)\n    );\n    if (this.device?.isConnected) {\n      await this.device.drawDisplaySegments(points, sendImmediately);\n    }\n  }\n  #drawArcToCanvas(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians: boolean,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getCircleBoundingBox(\n      centerX,\n      centerY,\n      radius,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n    this.#applyClip(box, contextState);\n\n    this.#transformContext(centerX, centerY, contextState.rotation);\n\n    this.#applyRotationClip(box, contextState);\n\n    // Draw the filled pie slice (includes radial lines)\n    this.context.beginPath();\n    this.context.moveTo(0, 0);\n    const clockwise = angleOffset > 0;\n    const endAngle = startAngle + angleOffset;\n\n    this.context.arc(0, 0, radius, startAngle, endAngle, !clockwise);\n    this.context.closePath();\n    this.context.fill();\n\n    // Stroke only the arc part\n    if (contextState.lineWidth) {\n      this.context.beginPath();\n      this.context.arc(0, 0, radius, startAngle, endAngle, !clockwise);\n      this.context.stroke();\n    }\n\n    this.#restore();\n  }\n  async drawArc(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    startAngle = isRadians ? startAngle : degToRad(startAngle);\n    angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawArcToCanvas(\n        centerX,\n        centerY,\n        radius,\n        startAngle,\n        angleOffset,\n        true,\n        contextState\n      )\n    );\n    if (this.device?.isConnected) {\n      await this.device.drawDisplayArc(\n        centerX,\n        centerY,\n        radius,\n        startAngle,\n        angleOffset,\n        true,\n        sendImmediately\n      );\n    }\n  }\n  #drawArcEllipseToCanvas(\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians: boolean,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getEllipseBoundingBox(\n      centerX,\n      centerY,\n      radiusX,\n      radiusY,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(centerX, centerY, contextState.rotation);\n\n    this.#applyRotationClip(box, contextState);\n\n    // draw elliptical pie slice (includes radial lines)\n    this.context.beginPath();\n    this.context.moveTo(0, 0);\n    const clockwise = angleOffset > 0;\n    const endAngle = startAngle + angleOffset;\n\n    this.context.ellipse(\n      0,\n      0,\n      radiusX,\n      radiusY,\n      0,\n      startAngle,\n      endAngle,\n      !clockwise\n    );\n    this.context.closePath();\n    this.context.fill();\n\n    // Stroke only the elliptical arc\n    if (contextState.lineWidth > 0) {\n      this.context.beginPath();\n      this.context.ellipse(\n        0,\n        0,\n        radiusX,\n        radiusY,\n        0,\n        startAngle,\n        endAngle,\n        !clockwise\n      );\n      this.context.stroke();\n    }\n\n    this.#restore();\n  }\n  async drawArcEllipse(\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    startAngle = isRadians ? startAngle : degToRad(startAngle);\n    angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawArcEllipseToCanvas(\n        centerX,\n        centerY,\n        radiusX,\n        radiusY,\n        startAngle,\n        angleOffset,\n        true,\n        contextState\n      )\n    );\n    if (this.device?.isConnected) {\n      await this.device.drawDisplayArcEllipse(\n        centerX,\n        centerY,\n        radiusX,\n        radiusY,\n        startAngle,\n        angleOffset,\n        true,\n        sendImmediately\n      );\n    }\n  }\n\n  #bitmapCanvas = document.createElement(\"canvas\");\n  #bitmapContext!: CanvasRenderingContext2D;\n  async #drawBitmapToCanvas(\n    centerX: number,\n    centerY: number,\n    bitmap: DisplayBitmap,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    // _console.log(\"drawBitmapToCanvas\", { centerX, centerY, bitmap });\n\n    const { bitmapScaleX, bitmapScaleY } = this.contextState;\n    const width = bitmap.width * bitmapScaleX;\n    const height = bitmap.height * bitmapScaleY;\n\n    // _console.log({ width, height });\n\n    this.#save();\n    const box = this.#getRectBoundingBox(\n      centerX,\n      centerY,\n      width,\n      height,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(centerX, centerY, contextState.rotation);\n\n    this.#applyRotationClip(box, contextState);\n\n    this.#bitmapCanvas.width = bitmap.width;\n    this.#bitmapCanvas.height = bitmap.height;\n\n    const bitmapImageData = this.#bitmapContext.createImageData(\n      bitmap.width,\n      bitmap.height\n    );\n    const rawBitmapImageData = bitmapImageData.data;\n\n    const x = -width / 2;\n    const y = -height / 2;\n    bitmap.pixels.forEach((pixel, pixelIndex) => {\n      const colorIndex = this.bitmapColorIndices[pixel];\n      const color = hexToRGB(this.colors[colorIndex]);\n      const opacity = this.#getColorOpacity(colorIndex, true);\n\n      const imageDataOffset = pixelIndex * 4;\n\n      rawBitmapImageData[imageDataOffset + 0] = color.r;\n      rawBitmapImageData[imageDataOffset + 1] = color.g;\n      rawBitmapImageData[imageDataOffset + 2] = color.b;\n      rawBitmapImageData[imageDataOffset + 3] = Math.floor(opacity * 255);\n    });\n\n    // console.log(\"rawBitmapImageData\", rawBitmapImageData);\n\n    this.#bitmapContext.putImageData(bitmapImageData, 0, 0);\n    this.#context.drawImage(this.#bitmapCanvas, x, y, width, height);\n\n    this.#restore();\n  }\n\n  #assertValidNumberOfColors(numberOfColors: number) {\n    _console.assertRangeWithError(\n      \"numberOfColors\",\n      numberOfColors,\n      2,\n      this.numberOfColors\n    );\n  }\n  #assertValidBitmap(bitmap: DisplayBitmap) {\n    this.#assertValidNumberOfColors(bitmap.numberOfColors);\n    assertValidBitmapPixels(bitmap);\n  }\n  async drawBitmap(\n    centerX: number,\n    centerY: number,\n    bitmap: DisplayBitmap,\n    sendImmediately?: boolean\n  ) {\n    this.#assertValidBitmap(bitmap);\n    _console.log(\"drawBitmap\", { centerX, centerY, bitmap, sendImmediately });\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawBitmapToCanvas(centerX, centerY, bitmap, contextState)\n    );\n    if (this.device?.isConnected) {\n      await this.device.drawDisplayBitmap(\n        centerX,\n        centerY,\n        bitmap,\n        sendImmediately\n      );\n    }\n  }\n\n  // FILL - sprites\n\n  #brightness: DisplayBrightness = \"medium\";\n  get brightness() {\n    return this.#brightness;\n  }\n  #brightnessOpacities: Record<DisplayBrightness, number> = {\n    veryLow: 0.5,\n    low: 0.7,\n    medium: 0.9,\n    high: 0.95,\n    veryHigh: 1,\n  };\n  get #brightnessOpacity() {\n    return this.#brightnessOpacities[this.brightness];\n  }\n  async setBrightness(\n    newBrightness: DisplayBrightness,\n    sendImmediately?: boolean\n  ) {\n    if (this.#brightness == newBrightness) {\n      _console.log(`redundant brightness ${newBrightness}`);\n      return;\n    }\n    this.#brightness = newBrightness;\n    _console.log({ brightness: this.brightness });\n    if (this.device?.isConnected) {\n      await this.device.setDisplayBrightness(newBrightness, sendImmediately);\n    }\n    this.#drawFrontDrawStack();\n    this.#dispatchEvent(\"brightness\", { brightness: this.brightness });\n  }\n  async #resetBrightness() {\n    await this.setBrightness(\"medium\");\n  }\n  async #updateDeviceBrightness(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    _console.log(\"updateDeviceBrightness\");\n    await this.device?.setDisplayBrightness(this.brightness, sendImmediately);\n  }\n\n  async runContextCommandMessage(\n    commandMessage: DisplayContextCommandMessage,\n    position: Vector2,\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommand(\n      this,\n      commandMessage,\n      position,\n      sendImmediately\n    );\n  }\n\n  #reset() {\n    this.#resetColors();\n    this.#resetOpacities();\n    this.#resetContextState();\n    this.#resetBrightness();\n  }\n}\nexport default DisplayCanvasHelper;\n","import { createConsole } from \"../utils/Console.ts\";\nimport CenterOfPressureHelper from \"../utils/CenterOfPressureHelper.ts\";\nimport {\n  PressureData,\n  PressureSensorPosition,\n  PressureSensorValue,\n} from \"../sensor/PressureSensorDataManager.ts\";\nimport { CenterOfPressure } from \"../utils/CenterOfPressureHelper.ts\";\nimport { Side, Sides } from \"../InformationManager.ts\";\nimport { DeviceEventMap } from \"../Device.ts\";\nimport { RangeHelper } from \"../BS.ts\";\n\nconst _console = createConsole(\"DevicePairPressureSensorDataManager\", {\n  log: false,\n});\n\nexport type DevicePairRawPressureData = { [side in Side]: PressureData };\n\nexport interface DevicePairPressureData {\n  sensors: { [key in Side]: PressureSensorValue[] };\n  scaledSum: number;\n  normalizedSum: number;\n  center?: CenterOfPressure;\n  normalizedCenter?: CenterOfPressure;\n}\n\nexport interface DevicePairPressureDataEventMessage {\n  pressure: DevicePairPressureData;\n}\n\nexport interface DevicePairPressureDataEventMessages {\n  pressure: DevicePairPressureDataEventMessage;\n}\n\nclass DevicePairPressureSensorDataManager {\n  #rawPressure: Partial<DevicePairRawPressureData> = {};\n\n  #centerOfPressureHelper = new CenterOfPressureHelper();\n\n  #normalizedSumRangeHelper = new RangeHelper();\n\n  constructor() {\n    this.resetPressureRange();\n  }\n\n  resetPressureRange() {\n    this.#centerOfPressureHelper.reset();\n    this.#normalizedSumRangeHelper.reset();\n  }\n\n  onDevicePressureData(event: DeviceEventMap[\"pressure\"]) {\n    const { pressure } = event.message;\n    const { side } = event.target;\n    _console.log({ pressure, side });\n    this.#rawPressure[side] = pressure;\n    if (this.#hasAllPressureData) {\n      return this.#updatePressureData();\n    } else {\n      _console.log(\"doesn't have all pressure data yet...\");\n    }\n  }\n\n  get #hasAllPressureData() {\n    return Sides.every((side) => side in this.#rawPressure);\n  }\n\n  #updatePressureData() {\n    const pressure: DevicePairPressureData = {\n      scaledSum: 0,\n      normalizedSum: 0,\n      sensors: { left: [], right: [] },\n    };\n\n    Sides.forEach((side) => {\n      const sidePressure = this.#rawPressure[side]!;\n      pressure.scaledSum += sidePressure.scaledSum;\n      //pressure.normalizedSum += this.#rawPressure[side]!.normalizedSum;\n    });\n    pressure.normalizedSum +=\n      this.#normalizedSumRangeHelper.updateAndGetNormalization(\n        pressure.scaledSum,\n        false\n      );\n\n    if (pressure.scaledSum > 0) {\n      pressure.center = { x: 0, y: 0 };\n      Sides.forEach((side) => {\n        const sidePressure = this.#rawPressure[side]!;\n\n        if (false) {\n          const sidePressureWeight =\n            sidePressure.scaledSum / pressure.scaledSum;\n          if (sidePressureWeight > 0) {\n            if (sidePressure.normalizedCenter?.y != undefined) {\n              pressure.center!.y +=\n                sidePressure.normalizedCenter!.y * sidePressureWeight;\n            }\n            if (side == \"right\") {\n              pressure.center!.x = sidePressureWeight;\n            }\n          }\n        } else {\n          sidePressure.sensors.forEach((sensor) => {\n            const _sensor: PressureSensorValue = structuredClone(sensor);\n            _sensor.weightedValue = sensor.scaledValue / pressure.scaledSum;\n            let { x, y } = sensor.position;\n            x /= 2;\n            if (side == \"right\") {\n              x += 0.5;\n            }\n            _sensor.position = { x, y };\n            pressure.center!.x += _sensor.position.x * _sensor.weightedValue;\n            pressure.center!.y += _sensor.position.y * _sensor.weightedValue;\n            pressure.sensors[side].push(_sensor);\n          });\n        }\n      });\n\n      pressure.normalizedCenter =\n        this.#centerOfPressureHelper.updateAndGetNormalization(\n          pressure.center,\n          false\n        );\n    }\n\n    _console.log({ devicePairPressure: pressure });\n\n    return pressure;\n  }\n}\n\nexport default DevicePairPressureSensorDataManager;\n","import DevicePairPressureSensorDataManager, {\n  DevicePairPressureDataEventMessages,\n} from \"./DevicePairPressureSensorDataManager.ts\";\nimport { createConsole } from \"../utils/Console.ts\";\nimport { Side } from \"../InformationManager.ts\";\nimport { SensorType } from \"../sensor/SensorDataManager.ts\";\nimport { DeviceEventMap } from \"../Device.ts\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\nimport DevicePair from \"./DevicePair.ts\";\nimport { AddKeysAsPropertyToInterface, ExtendInterfaceValues, ValueOf } from \"../utils/TypeScriptUtils.ts\";\n\nconst _console = createConsole(\"DevicePairSensorDataManager\", { log: false });\n\nexport const DevicePairSensorTypes = [\"pressure\", \"sensorData\"] as const;\nexport type DevicePairSensorType = (typeof DevicePairSensorTypes)[number];\n\nexport const DevicePairSensorDataEventTypes = DevicePairSensorTypes;\nexport type DevicePairSensorDataEventType = (typeof DevicePairSensorDataEventTypes)[number];\n\nexport type DevicePairSensorDataTimestamps = { [side in Side]: number };\n\ninterface BaseDevicePairSensorDataEventMessage {\n  timestamps: DevicePairSensorDataTimestamps;\n}\n\ntype BaseDevicePairSensorDataEventMessages = DevicePairPressureDataEventMessages;\ntype _DevicePairSensorDataEventMessages = ExtendInterfaceValues<\n  AddKeysAsPropertyToInterface<BaseDevicePairSensorDataEventMessages, \"sensorType\">,\n  BaseDevicePairSensorDataEventMessage\n>;\n\nexport type DevicePairSensorDataEventMessage = ValueOf<_DevicePairSensorDataEventMessages>;\ninterface AnyDevicePairSensorDataEventMessages {\n  sensorData: DevicePairSensorDataEventMessage;\n}\nexport type DevicePairSensorDataEventMessages = _DevicePairSensorDataEventMessages &\n  AnyDevicePairSensorDataEventMessages;\n\nexport type DevicePairSensorDataEventDispatcher = EventDispatcher<\n  DevicePair,\n  DevicePairSensorDataEventType,\n  DevicePairSensorDataEventMessages\n>;\n\nclass DevicePairSensorDataManager {\n  eventDispatcher!: DevicePairSensorDataEventDispatcher;\n  get dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  #timestamps: { [sensorType in SensorType]?: Partial<DevicePairSensorDataTimestamps> } = {};\n\n  pressureSensorDataManager = new DevicePairPressureSensorDataManager();\n  resetPressureRange() {\n    this.pressureSensorDataManager.resetPressureRange();\n  }\n\n  onDeviceSensorData(event: DeviceEventMap[\"sensorData\"]) {\n    const { timestamp, sensorType } = event.message;\n\n    _console.log({ sensorType, timestamp, event });\n\n    if (!this.#timestamps[sensorType]) {\n      this.#timestamps[sensorType] = {};\n    }\n    this.#timestamps[sensorType]![event.target.side] = timestamp;\n\n    let value;\n    switch (sensorType) {\n      case \"pressure\":\n        value = this.pressureSensorDataManager.onDevicePressureData(event as unknown as DeviceEventMap[\"pressure\"]);\n        break;\n      default:\n        _console.log(`uncaught sensorType \"${sensorType}\"`);\n        break;\n    }\n\n    if (value) {\n      const timestamps = Object.assign({}, this.#timestamps[sensorType]) as DevicePairSensorDataTimestamps;\n      // @ts-expect-error\n      this.dispatchEvent(sensorType as DevicePairSensorDataEventType, { sensorType, timestamps, [sensorType]: value });\n      // @ts-expect-error\n      this.dispatchEvent(\"sensorData\", { sensorType, timestamps, [sensorType]: value });\n    } else {\n      _console.log(\"no value received\");\n    }\n  }\n}\n\nexport default DevicePairSensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"../utils/EventDispatcher.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../utils/EventUtils.ts\";\nimport Device, {\n  DeviceEvent,\n  DeviceEventType,\n  DeviceEventMessages,\n  DeviceEventTypes,\n  BoundDeviceEventListeners,\n  DeviceEventMap,\n} from \"../Device.ts\";\nimport DevicePairSensorDataManager, {\n  DevicePairSensorDataEventDispatcher,\n} from \"./DevicePairSensorDataManager.ts\";\nimport { capitalizeFirstCharacter } from \"../utils/stringUtils.ts\";\nimport { Side, Sides } from \"../InformationManager.ts\";\nimport { VibrationConfiguration } from \"../vibration/VibrationManager.ts\";\nimport { SensorConfiguration } from \"../sensor/SensorConfigurationManager.ts\";\nimport {\n  DevicePairSensorDataEventMessages,\n  DevicePairSensorDataEventTypes,\n} from \"./DevicePairSensorDataManager.ts\";\nimport {\n  AddPrefixToInterfaceKeys,\n  ExtendInterfaceValues,\n  KeyOf,\n} from \"../utils/TypeScriptUtils.ts\";\nimport DeviceManager from \"../DeviceManager.ts\";\n\nconst _console = createConsole(\"DevicePair\", { log: false });\n\ninterface BaseDevicePairDeviceEventMessage {\n  device: Device;\n  side: Side;\n}\ntype DevicePairDeviceEventMessages = ExtendInterfaceValues<\n  AddPrefixToInterfaceKeys<DeviceEventMessages, \"device\">,\n  BaseDevicePairDeviceEventMessage\n>;\ntype DevicePairDeviceEventType = KeyOf<DevicePairDeviceEventMessages>;\nfunction getDevicePairDeviceEventType(deviceEventType: DeviceEventType) {\n  return `device${capitalizeFirstCharacter(\n    deviceEventType\n  )}` as DevicePairDeviceEventType;\n}\nconst DevicePairDeviceEventTypes = DeviceEventTypes.map((eventType) =>\n  getDevicePairDeviceEventType(eventType)\n) as DevicePairDeviceEventType[];\n\nexport const DevicePairConnectionEventTypes = [\"isConnected\"] as const;\nexport type DevicePairConnectionEventType =\n  (typeof DevicePairConnectionEventTypes)[number];\n\nexport interface DevicePairConnectionEventMessages {\n  isConnected: { isConnected: boolean };\n}\n\nexport const DevicePairEventTypes = [\n  ...DevicePairConnectionEventTypes,\n  ...DevicePairSensorDataEventTypes,\n  ...DevicePairDeviceEventTypes,\n] as const;\nexport type DevicePairEventType = (typeof DevicePairEventTypes)[number];\n\nexport type DevicePairEventMessages = DevicePairConnectionEventMessages &\n  DevicePairSensorDataEventMessages &\n  DevicePairDeviceEventMessages;\n\nexport type DevicePairEventDispatcher = EventDispatcher<\n  DevicePair,\n  DevicePairEventType,\n  DevicePairEventMessages\n>;\nexport type DevicePairEventMap = EventMap<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\nexport type DevicePairEventListenerMap = EventListenerMap<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\nexport type DevicePairEvent = Event<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\nexport type BoundDevicePairEventListeners = BoundEventListeners<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\n\nexport const DevicePairTypes = [\"insoles\", \"gloves\"] as const;\nexport type DevicePairType = (typeof DevicePairTypes)[number];\n\nclass DevicePair {\n  constructor(type: DevicePairType) {\n    this.#type = type;\n    this.#sensorDataManager.eventDispatcher = this\n      .#eventDispatcher as DevicePairSensorDataEventDispatcher;\n  }\n\n  get sides() {\n    return Sides;\n  }\n\n  #type: DevicePairType;\n  get type() {\n    return this.#type;\n  }\n\n  #eventDispatcher: DevicePairEventDispatcher = new EventDispatcher(\n    this as DevicePair,\n    DevicePairEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // SIDES\n  #left?: Device;\n  get left() {\n    return this.#left;\n  }\n\n  #right?: Device;\n  get right() {\n    return this.#right;\n  }\n\n  get isConnected() {\n    return Sides.every((side) => this[side]?.isConnected);\n  }\n  get isPartiallyConnected() {\n    return Sides.some((side) => this[side]?.isConnected);\n  }\n  get isHalfConnected() {\n    return this.isPartiallyConnected && !this.isConnected;\n  }\n  #assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"devicePair must be connected\");\n  }\n\n  #isDeviceCorrectType(device: Device) {\n    switch (this.type) {\n      case \"insoles\":\n        return device.isInsole;\n      case \"gloves\":\n        return device.isGlove;\n    }\n  }\n\n  assignDevice(device: Device) {\n    if (!this.#isDeviceCorrectType(device)) {\n      _console.log(\n        `device is incorrect type ${device.type} for ${this.type} devicePair`\n      );\n      return;\n    }\n    const side = device.side;\n\n    const currentDevice = this[side];\n\n    if (device == currentDevice) {\n      _console.log(\"device already assigned\");\n      return;\n    }\n\n    if (currentDevice) {\n      this.#removeDeviceEventListeners(currentDevice);\n    }\n    this.#addDeviceEventListeners(device);\n\n    switch (side) {\n      case \"left\":\n        this.#left = device;\n        break;\n      case \"right\":\n        this.#right = device;\n        break;\n    }\n\n    _console.log(`assigned ${side} ${this.type} device`, device);\n\n    this.resetPressureRange();\n\n    this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    this.#dispatchEvent(\"deviceIsConnected\", {\n      device,\n      isConnected: device.isConnected,\n      side,\n    });\n\n    return currentDevice;\n  }\n\n  #addDeviceEventListeners(device: Device) {\n    addEventListeners(device, this.#boundDeviceEventListeners);\n    DeviceEventTypes.forEach((deviceEventType) => {\n      device.addEventListener(\n        // @ts-expect-error\n        deviceEventType,\n        this.#redispatchDeviceEvent.bind(this)\n      );\n    });\n  }\n  #removeDeviceEventListeners(device: Device) {\n    removeEventListeners(device, this.#boundDeviceEventListeners);\n    DeviceEventTypes.forEach((deviceEventType) => {\n      device.removeEventListener(\n        // @ts-expect-error\n        deviceEventType,\n        this.#redispatchDeviceEvent.bind(this)\n      );\n    });\n  }\n\n  #removeDevice(device: Device) {\n    const foundDevice = Sides.some((side) => {\n      if (this[side] != device) {\n        return false;\n      }\n\n      _console.log(`removing ${side} ${this.type} device`, device);\n      removeEventListeners(device, this.#boundDeviceEventListeners);\n\n      switch (side) {\n        case \"left\":\n          this.#left = undefined;\n          break;\n        case \"right\":\n          this.#right = undefined;\n          break;\n      }\n\n      return true;\n    });\n    if (foundDevice) {\n      this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    }\n    return foundDevice;\n  }\n\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    isConnected: this.#onDeviceIsConnected.bind(this),\n    sensorData: this.#onDeviceSensorData.bind(this),\n    getType: this.#onDeviceType.bind(this),\n  };\n\n  #redispatchDeviceEvent(deviceEvent: DeviceEvent) {\n    const { type, target: device, message } = deviceEvent;\n    this.#dispatchEvent(getDevicePairDeviceEventType(type), {\n      ...message,\n      device,\n      side: device.side,\n    });\n  }\n\n  #onDeviceIsConnected(deviceEvent: DeviceEventMap[\"isConnected\"]) {\n    this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n  }\n\n  #onDeviceType(deviceEvent: DeviceEventMap[\"getType\"]) {\n    const { target: device } = deviceEvent;\n    if (this[device.side] == device) {\n      return;\n    }\n    const foundDevice = this.#removeDevice(device);\n    if (!foundDevice) {\n      return;\n    }\n    this.assignDevice(device);\n  }\n\n  // SENSOR CONFIGURATION\n  async setSensorConfiguration(sensorConfiguration: SensorConfiguration) {\n    for (let i = 0; i < Sides.length; i++) {\n      const side = Sides[i];\n      if (this[side]?.isConnected) {\n        await this[side].setSensorConfiguration(sensorConfiguration);\n      }\n    }\n  }\n\n  // SENSOR DATA\n  #sensorDataManager = new DevicePairSensorDataManager();\n  #onDeviceSensorData(deviceEvent: DeviceEventMap[\"sensorData\"]) {\n    if (this.isConnected) {\n      this.#sensorDataManager.onDeviceSensorData(deviceEvent);\n    }\n  }\n  resetPressureRange() {\n    Sides.forEach((side) => this[side]?.resetPressureRange());\n    this.#sensorDataManager.resetPressureRange();\n  }\n\n  // VIBRATION\n  async triggerVibration(\n    vibrationConfigurations: VibrationConfiguration[],\n    sendImmediately?: boolean\n  ) {\n    const promises = Sides.map((side) => {\n      return this[side]?.triggerVibration(\n        vibrationConfigurations,\n        sendImmediately\n      );\n    }).filter(Boolean);\n    return Promise.allSettled(promises);\n  }\n\n  // SHARED INSTANCES\n  static #insoles = new DevicePair(\"insoles\");\n  static get insoles() {\n    return this.#insoles;\n  }\n  static #gloves = new DevicePair(\"gloves\");\n  static get gloves() {\n    return this.#gloves;\n  }\n  static {\n    DeviceManager.AddEventListener(\"deviceConnected\", (event) => {\n      const { device } = event.message;\n      if (device.isInsole) {\n        this.#insoles.assignDevice(device);\n      }\n      if (device.isGlove) {\n        this.#gloves.assignDevice(device);\n      }\n    });\n  }\n}\n\nexport default DevicePair;\n","export function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  interval: number,\n  trailing = false\n): (...args: Parameters<T>) => void {\n  let lastTime = 0;\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let lastArgs: Parameters<T> | null = null;\n\n  return function (...args: Parameters<T>) {\n    const now = Date.now();\n    const remaining = interval - (now - lastTime);\n\n    if (remaining <= 0) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      lastTime = now;\n      fn(...args);\n    } else if (trailing) {\n      lastArgs = args;\n      if (!timeout) {\n        timeout = setTimeout(() => {\n          lastTime = Date.now();\n          timeout = null;\n          if (lastArgs) {\n            fn(...lastArgs);\n            lastArgs = null;\n          }\n        }, remaining);\n      }\n    }\n  };\n}\n\nexport function debounce<T extends (...args: any[]) => void>(\n  fn: T,\n  interval: number,\n  callImmediately = false\n): (...args: Parameters<T>) => void {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n\n  return function (...args: Parameters<T>) {\n    const callNow = callImmediately && !timeout;\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (!callImmediately) {\n        fn(...args);\n      }\n    }, interval);\n\n    if (callNow) {\n      fn(...args);\n    }\n  };\n}\n","import { createConsole } from \"../utils/Console.ts\";\nimport { isInBrowser } from \"../utils/environment.ts\";\nimport BaseConnectionManager, {\n  ConnectionType,\n  ConnectionMessageType,\n  ClientConnectionType,\n} from \"./BaseConnectionManager.ts\";\nimport { DeviceEventTypes } from \"../Device.ts\";\nimport { parseMessage } from \"../utils/ParseUtils.ts\";\nimport { DeviceInformationTypes } from \"../DeviceInformationManager.ts\";\nimport { DeviceEventType } from \"../Device.ts\";\nimport { ClientDeviceMessage } from \"../server/ServerUtils.ts\";\nimport BaseClient from \"../server/BaseClient.ts\";\nimport { DiscoveredDevice } from \"../BS.ts\";\n\nconst _console = createConsole(\"ClientConnectionManager\", { log: false });\n\nexport type SendClientMessageCallback = (\n  ...messages: ClientDeviceMessage[]\n) => void;\n\nexport type SendClientConnectMessageCallback = (\n  connectionType?: ClientConnectionType\n) => void;\n\nconst ClientDeviceInformationMessageTypes: ConnectionMessageType[] = [\n  ...DeviceInformationTypes,\n  \"batteryLevel\",\n];\n\nclass ClientConnectionManager extends BaseConnectionManager {\n  static get isSupported() {\n    return isInBrowser;\n  }\n  static get type(): ConnectionType {\n    return \"client\";\n  }\n\n  subType?: ClientConnectionType;\n\n  get canUpdateFirmware() {\n    // FIX - how to know if it has an smp characteristic?\n    return false;\n  }\n\n  client!: BaseClient;\n  discoveredDevice!: DiscoveredDevice;\n\n  #bluetoothId!: string;\n  get bluetoothId() {\n    return this.#bluetoothId!;\n  }\n  set bluetoothId(newBluetoothId) {\n    _console.assertTypeWithError(newBluetoothId, \"string\");\n    if (this.#bluetoothId == newBluetoothId) {\n      _console.log(\"redundant bluetoothId assignment\");\n      return;\n    }\n    this.#bluetoothId = newBluetoothId;\n  }\n\n  #isConnected = false;\n  get isConnected() {\n    return this.#isConnected;\n  }\n  set isConnected(newIsConnected) {\n    _console.assertTypeWithError(newIsConnected, \"boolean\");\n    if (this.#isConnected == newIsConnected) {\n      _console.log(\"redundant newIsConnected assignment\", newIsConnected);\n      return;\n    }\n    this.#isConnected = newIsConnected;\n\n    this.status = this.#isConnected ? \"connected\" : \"notConnected\";\n\n    if (this.isConnected) {\n      this.#requestDeviceInformation();\n    }\n  }\n\n  get isAvailable() {\n    return this.client.isConnected;\n  }\n\n  async connect() {\n    await super.connect();\n    this.sendClientConnectMessage(this.subType);\n  }\n  async disconnect() {\n    await super.disconnect();\n    this.sendClientDisconnectMessage();\n  }\n\n  get canReconnect() {\n    return true;\n  }\n  async reconnect() {\n    await super.reconnect();\n    this.sendClientConnectMessage();\n  }\n\n  sendClientMessage!: SendClientMessageCallback;\n  sendClientConnectMessage!: SendClientConnectMessageCallback;\n  sendClientDisconnectMessage!: Function;\n  sendRequiredDeviceInformationMessage!: Function;\n\n  async sendSmpMessage(data: ArrayBuffer) {\n    super.sendSmpMessage(data);\n    this.sendClientMessage({ type: \"smp\", data });\n  }\n\n  async sendTxData(data: ArrayBuffer) {\n    super.sendTxData(data);\n    if (data.byteLength == 0) {\n      return;\n    }\n    this.sendClientMessage({ type: \"tx\", data });\n  }\n\n  #requestDeviceInformation() {\n    //this.sendClientMessage(...ClientDeviceInformationMessageTypes);\n    this.sendRequiredDeviceInformationMessage();\n  }\n\n  onClientMessage(dataView: DataView) {\n    _console.log({ dataView });\n    parseMessage(\n      dataView,\n      DeviceEventTypes,\n      this.#onClientMessageCallback.bind(this),\n      null,\n      true\n    );\n    this.onMessagesReceived!();\n  }\n\n  #onClientMessageCallback(messageType: DeviceEventType, dataView: DataView) {\n    let byteOffset = 0;\n\n    _console.log({ messageType }, dataView);\n\n    switch (messageType) {\n      case \"isConnected\":\n        const isConnected = Boolean(dataView.getUint8(byteOffset++));\n        _console.log({ isConnected });\n        this.isConnected = isConnected;\n        break;\n\n      case \"rx\":\n        this.parseRxMessage(dataView);\n        break;\n\n      default:\n        this.onMessageReceived!(messageType as ConnectionMessageType, dataView);\n        break;\n    }\n  }\n}\n\nexport default ClientConnectionManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport {\n  ServerMessageTypes,\n  discoveredDevicesMessage,\n  ServerMessage,\n  MessageLike,\n  ClientDeviceMessage,\n  createClientDeviceMessage,\n  ServerMessageType,\n} from \"./ServerUtils.ts\";\nimport { parseMessage, parseStringFromDataView } from \"../utils/ParseUtils.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n} from \"../utils/EventDispatcher.ts\";\nimport Device from \"../Device.ts\";\nimport {\n  concatenateArrayBuffers,\n  sliceDataView,\n  stringToArrayBuffer,\n} from \"../utils/ArrayBufferUtils.ts\";\nimport {\n  DiscoveredDevice,\n  DiscoveredDevicesMap,\n  ScannerEventMessages,\n} from \"../scanner/BaseScanner.ts\";\nimport ClientConnectionManager from \"../connection/ClientConnectionManager.ts\";\nimport { DeviceManager } from \"../BS.ts\";\nimport {\n  ClientConnectionType,\n  ConnectionTypes,\n} from \"../connection/BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"BaseClient\", { log: false });\n\nexport const ClientConnectionStatuses = [\n  \"notConnected\",\n  \"connecting\",\n  \"connected\",\n  \"disconnecting\",\n] as const;\nexport type ClientConnectionStatus = (typeof ClientConnectionStatuses)[number];\n\nexport const ClientEventTypes = [\n  ...ClientConnectionStatuses,\n  \"connectionStatus\",\n  \"isConnected\",\n  \"isScanningAvailable\",\n  \"isScanning\",\n  \"discoveredDevice\",\n  \"expiredDiscoveredDevice\",\n] as const;\nexport type ClientEventType = (typeof ClientEventTypes)[number];\n\ninterface ClientConnectionEventMessages {\n  connectionStatus: { connectionStatus: ClientConnectionStatus };\n  isConnected: { isConnected: boolean };\n}\n\nexport type ClientEventMessages = ClientConnectionEventMessages &\n  ScannerEventMessages;\n\nexport type ClientEventDispatcher = EventDispatcher<\n  BaseClient,\n  ClientEventType,\n  ClientEventMessages\n>;\nexport type ClientEvent = Event<\n  BaseClient,\n  ClientEventType,\n  ClientEventMessages\n>;\nexport type BoundClientEventListeners = BoundEventListeners<\n  BaseClient,\n  ClientEventType,\n  ClientEventMessages\n>;\n\nexport type ServerURL = string | URL;\n\ntype DevicesMap = { [deviceId: string]: Device };\n\nabstract class BaseClient {\n  protected get baseConstructor() {\n    return this.constructor as typeof BaseClient;\n  }\n\n  #reset() {\n    this.#isScanningAvailable = false;\n    this.#isScanning = false;\n    for (const id in this.#devices) {\n      const device = this.#devices[id];\n      const connectionManager =\n        device.connectionManager! as ClientConnectionManager;\n      connectionManager.isConnected = false;\n      //device.removeAllEventListeners();\n    }\n    this.#receivedMessageTypes.length = 0;\n    //this.#devices = {};\n  }\n\n  // DEVICES\n  #devices: DevicesMap = {};\n  get devices(): Readonly<DevicesMap> {\n    return this.#devices;\n  }\n\n  #eventDispatcher: ClientEventDispatcher = new EventDispatcher(\n    this as BaseClient,\n    ClientEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  protected get dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n\n  abstract isConnected: boolean;\n  protected assertConnection() {\n    _console.assertWithError(this.isConnected, \"notConnected\");\n  }\n\n  abstract isDisconnected: boolean;\n  protected assertDisconnection() {\n    _console.assertWithError(this.isDisconnected, \"not disconnected\");\n  }\n\n  abstract connect(): void;\n  abstract disconnect(): void;\n  abstract reconnect(): void;\n  abstract toggleConnection(url?: ServerURL): void;\n\n  static _reconnectOnDisconnection = true;\n  static get ReconnectOnDisconnection() {\n    return this._reconnectOnDisconnection;\n  }\n  static set ReconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this._reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  protected _reconnectOnDisconnection =\n    this.baseConstructor.ReconnectOnDisconnection;\n  get reconnectOnDisconnection() {\n    return this._reconnectOnDisconnection;\n  }\n  set reconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this._reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  abstract sendServerMessage(...messages: ServerMessage[]): void;\n\n  // CONNECTION STATUS\n  #_connectionStatus: ClientConnectionStatus = \"notConnected\";\n  protected get _connectionStatus() {\n    return this.#_connectionStatus;\n  }\n  protected set _connectionStatus(newConnectionStatus) {\n    _console.assertTypeWithError(newConnectionStatus, \"string\");\n    _console.log({ newConnectionStatus });\n    this.#_connectionStatus = newConnectionStatus;\n\n    this.dispatchEvent(\"connectionStatus\", {\n      connectionStatus: this.connectionStatus,\n    });\n    this.dispatchEvent(this.connectionStatus, {});\n\n    switch (newConnectionStatus) {\n      case \"connected\":\n      case \"notConnected\":\n        this.dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n        if (this.isConnected) {\n          // this._sendRequiredMessages();\n        } else {\n          this.#reset();\n        }\n        break;\n    }\n  }\n  get connectionStatus() {\n    return this._connectionStatus;\n  }\n\n  static #RequiredMessageTypes: ServerMessage[] = [\n    \"isScanningAvailable\",\n    \"discoveredDevices\",\n    \"connectedDevices\",\n  ];\n  get #requiredMessageTypes(): ServerMessage[] {\n    return BaseClient.#RequiredMessageTypes;\n  }\n  protected _sendRequiredMessages() {\n    _console.log(\"sending required messages\", this.#receivedMessageTypes);\n    this.sendServerMessage(...this.#requiredMessageTypes);\n  }\n\n  #receivedMessageTypes: ServerMessage[] = [];\n  #checkIfFullyConnected() {\n    if (this.connectionStatus != \"connecting\") {\n      return;\n    }\n    _console.log(\"checking if fully connected...\");\n\n    if (!this.#receivedMessageTypes.includes(\"isScanningAvailable\")) {\n      _console.log(\"not fully connected - didn't receive isScanningAvailable\");\n      return;\n    }\n\n    if (this.isScanningAvailable) {\n      if (!this.#receivedMessageTypes.includes(\"isScanning\")) {\n        _console.log(\"not fully connected - didn't receive isScanning\");\n        return;\n      }\n    }\n\n    _console.log(\"fully connected\");\n    this._connectionStatus = \"connected\";\n  }\n\n  protected parseMessage(dataView: DataView) {\n    _console.log(\"parseMessage\", { dataView });\n    parseMessage(\n      dataView,\n      ServerMessageTypes,\n      this.#parseMessageCallback.bind(this),\n      null,\n      true\n    );\n    this.#checkIfFullyConnected();\n  }\n\n  #parseMessageCallback(messageType: ServerMessageType, dataView: DataView) {\n    let byteOffset = 0;\n\n    _console.log({ messageType }, dataView);\n\n    switch (messageType) {\n      case \"isScanningAvailable\":\n        {\n          const isScanningAvailable = Boolean(dataView.getUint8(byteOffset++));\n          _console.log({ isScanningAvailable });\n          this.#isScanningAvailable = isScanningAvailable;\n        }\n        break;\n      case \"isScanning\":\n        {\n          const isScanning = Boolean(dataView.getUint8(byteOffset++));\n          _console.log({ isScanning });\n          this.#isScanning = isScanning;\n        }\n        break;\n      case \"discoveredDevice\":\n        {\n          const { string: discoveredDeviceString } = parseStringFromDataView(\n            dataView,\n            byteOffset\n          );\n          _console.log({ discoveredDeviceString });\n\n          const discoveredDevice: DiscoveredDevice = JSON.parse(\n            discoveredDeviceString\n          );\n          _console.log({ discoveredDevice });\n\n          this.onDiscoveredDevice(discoveredDevice);\n        }\n        break;\n      case \"expiredDiscoveredDevice\":\n        {\n          const { string: bluetoothId } = parseStringFromDataView(\n            dataView,\n            byteOffset\n          );\n          this.#onExpiredDiscoveredDevice(bluetoothId);\n        }\n        break;\n      case \"connectedDevices\":\n        {\n          if (dataView.byteLength == 0) {\n            break;\n          }\n          const { string: connectedBluetoothDeviceIdStrings } =\n            parseStringFromDataView(dataView, byteOffset);\n          _console.log({ connectedBluetoothDeviceIdStrings });\n          const connectedBluetoothDeviceIds = JSON.parse(\n            connectedBluetoothDeviceIdStrings\n          ).connectedDevices;\n          _console.log({ connectedBluetoothDeviceIds });\n          this.onConnectedBluetoothDeviceIds(connectedBluetoothDeviceIds);\n        }\n        break;\n      case \"deviceMessage\":\n        {\n          const { string: bluetoothId, byteOffset: _byteOffset } =\n            parseStringFromDataView(dataView, byteOffset);\n          byteOffset = _byteOffset;\n          const device = this.#devices[bluetoothId];\n          _console.assertWithError(\n            device,\n            `no device found for id ${bluetoothId}`\n          );\n          const connectionManager =\n            device.connectionManager! as ClientConnectionManager;\n          const _dataView = sliceDataView(dataView, byteOffset);\n          connectionManager.onClientMessage(_dataView);\n        }\n        break;\n      default:\n        _console.error(`uncaught messageType \"${messageType}\"`);\n        break;\n    }\n\n    if (this.connectionStatus == \"connecting\") {\n      this.#receivedMessageTypes.push(messageType);\n    }\n  }\n\n  // SCANNING\n  #_isScanningAvailable = false;\n  get #isScanningAvailable() {\n    return this.#_isScanningAvailable;\n  }\n  set #isScanningAvailable(newIsAvailable) {\n    _console.assertTypeWithError(newIsAvailable, \"boolean\");\n    this.#_isScanningAvailable = newIsAvailable;\n    this.dispatchEvent(\"isScanningAvailable\", {\n      isScanningAvailable: this.isScanningAvailable,\n    });\n    if (this.isScanningAvailable) {\n      this.#requestIsScanning();\n    }\n  }\n  get isScanningAvailable() {\n    return this.#isScanningAvailable;\n  }\n  #assertIsScanningAvailable() {\n    this.assertConnection();\n    _console.assertWithError(\n      this.isScanningAvailable,\n      \"scanning is not available\"\n    );\n  }\n  protected requestIsScanningAvailable() {\n    this.sendServerMessage(\"isScanningAvailable\");\n  }\n\n  #_isScanning = false;\n  get #isScanning() {\n    return this.#_isScanning;\n  }\n  set #isScanning(newIsScanning) {\n    _console.assertTypeWithError(newIsScanning, \"boolean\");\n    this.#_isScanning = newIsScanning;\n    this.dispatchEvent(\"isScanning\", { isScanning: this.isScanning });\n  }\n  get isScanning() {\n    return this.#isScanning;\n  }\n  #requestIsScanning() {\n    this.sendServerMessage(\"isScanning\");\n  }\n\n  #assertIsScanning() {\n    _console.assertWithError(this.isScanning, \"is not scanning\");\n  }\n  #assertIsNotScanning() {\n    _console.assertWithError(!this.isScanning, \"is already scanning\");\n  }\n\n  startScan() {\n    this.#assertIsNotScanning();\n    this.sendServerMessage(\"startScan\");\n  }\n  stopScan() {\n    this.#assertIsScanning();\n    this.sendServerMessage(\"stopScan\");\n  }\n  toggleScan() {\n    this.#assertIsScanningAvailable();\n\n    if (this.isScanning) {\n      this.stopScan();\n    } else {\n      this.startScan();\n    }\n  }\n\n  // PERIPHERALS\n  #discoveredDevices: DiscoveredDevicesMap = {};\n  get discoveredDevices(): Readonly<DiscoveredDevicesMap> {\n    return this.#discoveredDevices;\n  }\n\n  protected onDiscoveredDevice(discoveredDevice: DiscoveredDevice) {\n    _console.log({ discoveredDevice });\n    this.#discoveredDevices[discoveredDevice.bluetoothId] = discoveredDevice;\n    this.dispatchEvent(\"discoveredDevice\", { discoveredDevice });\n  }\n  requestDiscoveredDevices() {\n    this.sendServerMessage({ type: \"discoveredDevices\" });\n  }\n  #onExpiredDiscoveredDevice(bluetoothId: string) {\n    _console.log({ expiredBluetoothDeviceId: bluetoothId });\n    const discoveredDevice = this.#discoveredDevices[bluetoothId];\n    if (!discoveredDevice) {\n      _console.warn(`no discoveredDevice found with id \"${bluetoothId}\"`);\n      return;\n    }\n    _console.log({ expiredDiscoveredDevice: discoveredDevice });\n    delete this.#discoveredDevices[bluetoothId];\n    this.dispatchEvent(\"expiredDiscoveredDevice\", { discoveredDevice });\n  }\n\n  // DEVICE CONNECTION\n  connectToDevice(bluetoothId: string, connectionType?: ClientConnectionType) {\n    return this.requestConnectionToDevice(bluetoothId, connectionType);\n  }\n  protected requestConnectionToDevice(\n    bluetoothId: string,\n    connectionType?: ClientConnectionType\n  ) {\n    this.assertConnection();\n    _console.assertTypeWithError(bluetoothId, \"string\");\n    const device = this.#getOrCreateDevice(bluetoothId);\n    if (connectionType) {\n      device.connect({ type: \"client\", subType: connectionType });\n    } else {\n      device.connect();\n    }\n    return device;\n  }\n  protected sendConnectToDeviceMessage(\n    bluetoothId: string,\n    connectionType?: ClientConnectionType\n  ) {\n    if (connectionType) {\n      this.sendServerMessage({\n        type: \"connectToDevice\",\n        data: concatenateArrayBuffers(\n          stringToArrayBuffer(bluetoothId),\n          ConnectionTypes.indexOf(connectionType)\n        ),\n      });\n    } else {\n      this.sendServerMessage({ type: \"connectToDevice\", data: bluetoothId });\n    }\n  }\n\n  // DEVICE CONNECTION\n  createDevice(bluetoothId: string) {\n    const device = new Device();\n    const discoveredDevice = this.#discoveredDevices[bluetoothId];\n    const clientConnectionManager = new ClientConnectionManager();\n    clientConnectionManager.discoveredDevice = Object.assign(\n      {},\n      discoveredDevice\n    );\n    clientConnectionManager.client = this;\n    clientConnectionManager.bluetoothId = bluetoothId;\n    clientConnectionManager.sendClientMessage = this.sendDeviceMessage.bind(\n      this,\n      bluetoothId\n    );\n    clientConnectionManager.sendRequiredDeviceInformationMessage =\n      this.sendRequiredDeviceInformationMessage.bind(this, bluetoothId);\n    clientConnectionManager.sendClientConnectMessage =\n      this.sendConnectToDeviceMessage.bind(this, bluetoothId);\n    clientConnectionManager.sendClientDisconnectMessage =\n      this.sendDisconnectFromDeviceMessage.bind(this, bluetoothId);\n    device.connectionManager = clientConnectionManager;\n    return device;\n  }\n\n  #getOrCreateDevice(bluetoothId: string) {\n    let device = this.#devices[bluetoothId];\n    if (!device) {\n      device = this.createDevice(bluetoothId);\n      this.#devices[bluetoothId] = device;\n    }\n    return device;\n  }\n  protected onConnectedBluetoothDeviceIds(bluetoothIds: string[]) {\n    _console.log({ bluetoothIds });\n    bluetoothIds.forEach((bluetoothId) => {\n      const device = this.#getOrCreateDevice(bluetoothId);\n      const connectionManager =\n        device.connectionManager! as ClientConnectionManager;\n      connectionManager.isConnected = true;\n      DeviceManager._CheckDeviceAvailability(device);\n    });\n  }\n\n  disconnectFromDevice(bluetoothId: string) {\n    this.requestDisconnectionFromDevice(bluetoothId);\n  }\n  protected requestDisconnectionFromDevice(bluetoothId: string) {\n    this.assertConnection();\n    _console.assertTypeWithError(bluetoothId, \"string\");\n    const device = this.devices[bluetoothId];\n    _console.assertWithError(device, `no device found with id ${bluetoothId}`);\n    device.disconnect();\n    return device;\n  }\n  protected sendDisconnectFromDeviceMessage(bluetoothId: string) {\n    this.sendServerMessage({ type: \"disconnectFromDevice\", data: bluetoothId });\n  }\n\n  protected sendDeviceMessage(\n    bluetoothId: string,\n    ...messages: ClientDeviceMessage[]\n  ) {\n    this.sendServerMessage({\n      type: \"deviceMessage\",\n      data: [bluetoothId, createClientDeviceMessage(...messages)],\n    });\n  }\n\n  protected sendRequiredDeviceInformationMessage(bluetoothId: string) {\n    this.sendServerMessage({\n      type: \"requiredDeviceInformation\",\n      data: [bluetoothId],\n    });\n  }\n}\n\nexport default BaseClient;\n","import { createConsole } from \"../../utils/Console.ts\";\nimport {\n  createServerMessage,\n  MessageLike,\n  ServerMessage,\n} from \"../ServerUtils.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../../utils/EventUtils.ts\";\nimport ClientConnectionManager from \"../../connection/ClientConnectionManager.ts\";\nimport BaseClient, { ServerURL } from \"../BaseClient.ts\";\nimport type * as ws from \"ws\";\nimport Timer from \"../../utils/Timer.ts\";\nimport {\n  createWebSocketMessage,\n  WebSocketMessageType,\n  WebSocketMessageTypes,\n  webSocketPingTimeout,\n  webSocketReconnectTimeout,\n  WebSocketMessage,\n} from \"./WebSocketUtils.ts\";\nimport { parseMessage } from \"../../utils/ParseUtils.ts\";\nimport { isInLensStudio, isInBrowser } from \"../../utils/environment.ts\";\n\nconst _console = createConsole(\"WebSocketClient\", { log: false });\n\nclass WebSocketClient extends BaseClient {\n  // WEBSOCKET\n  #webSocket?: WebSocket;\n  get webSocket() {\n    return this.#webSocket;\n  }\n  set webSocket(newWebSocket) {\n    if (this.#webSocket == newWebSocket) {\n      _console.log(\"redundant webSocket assignment\");\n      return;\n    }\n\n    _console.log(\"assigning webSocket\", newWebSocket);\n\n    if (this.#webSocket) {\n      removeEventListeners(this.#webSocket, this.#boundWebSocketEventListeners);\n    }\n\n    addEventListeners(newWebSocket, this.#boundWebSocketEventListeners);\n    this.#webSocket = newWebSocket;\n\n    _console.log(\"assigned webSocket\");\n  }\n  get readyState() {\n    return this.webSocket?.readyState;\n  }\n  get isConnected() {\n    return this.readyState == WebSocket.OPEN;\n  }\n  get isDisconnected() {\n    return this.readyState == WebSocket.CLOSED;\n  }\n\n  connect(url: string | URL = `wss://${location.host}`) {\n    if (this.webSocket) {\n      this.assertDisconnection();\n    }\n    this._connectionStatus = \"connecting\";\n\n    if (isInLensStudio) {\n      if (globalThis.internetModule) {\n        // FILL\n        /*\n        let socket = globalThis.internetModule.createWebSocket(url);\n        socket.binaryType = \"blob\";\n\n        socket.onopen = (event) => {\n          socket.send(\"Message 1\");\n\n          // Try sending a binary message\n          // (the bytes below spell 'Message 2')\n          const message = [77, 101, 115, 115, 97, 103, 101, 32, 50];\n          const bytes = new Uint8Array(message);\n          socket.send(bytes);\n        };\n\n        // Listen for messages\n        socket.onmessage = async (event) => {\n          if (event.data instanceof Blob) {\n            // Binary frame, can be retrieved as either Uint8Array or string\n            let bytes = await event.data.bytes();\n            let text = await event.data.text();\n\n            print(\"Received binary message, printing as text: \" + text);\n          } else {\n            // Text frame\n            let text = event.data;\n            print(\"Received text message: \" + text);\n          }\n        };\n\n        socket.onclose = (event) => {\n          if (event.wasClean) {\n            print(\"Socket closed cleanly\");\n          } else {\n            print(\"Socket closed with error, code: \" + event.code);\n          }\n        };\n\n        socket.onerror = (event) => {\n          print(\"Socket error\");\n        };\n        */\n      }\n    } else {\n      this.webSocket = new WebSocket(url);\n    }\n  }\n\n  disconnect() {\n    this.assertConnection();\n    if (this.reconnectOnDisconnection) {\n      this.reconnectOnDisconnection = false;\n      this.webSocket!.addEventListener(\n        \"close\",\n        () => {\n          this.reconnectOnDisconnection = true;\n        },\n        { once: true }\n      );\n    }\n    this._connectionStatus = \"disconnecting\";\n    this.webSocket!.close();\n  }\n\n  reconnect() {\n    this.assertDisconnection();\n    this.connect(this.webSocket!.url);\n  }\n\n  toggleConnection(url?: ServerURL) {\n    if (this.isConnected) {\n      this.disconnect();\n    } else if (url && this.webSocket?.url == url) {\n      this.reconnect();\n    } else {\n      this.connect(url);\n    }\n  }\n\n  // WEBSOCKET MESSAGING\n  sendMessage(message: MessageLike) {\n    this.assertConnection();\n    this.#webSocket!.send(message);\n    this.#pingTimer.restart();\n  }\n\n  sendServerMessage(...messages: ServerMessage[]) {\n    this.sendMessage(\n      createWebSocketMessage({\n        type: \"serverMessage\",\n        data: createServerMessage(...messages),\n      })\n    );\n  }\n\n  #sendWebSocketMessage(...messages: WebSocketMessage[]) {\n    this.sendMessage(createWebSocketMessage(...messages));\n  }\n\n  // WEBSOCKET EVENTS\n  #boundWebSocketEventListeners: { [eventType: string]: Function } = {\n    open: this.#onWebSocketOpen.bind(this),\n    message: this.#onWebSocketMessage.bind(this),\n    close: this.#onWebSocketClose.bind(this),\n    error: this.#onWebSocketError.bind(this),\n  };\n\n  #onWebSocketOpen(event: ws.Event) {\n    _console.log(\"webSocket.open\", event);\n    this.#pingTimer.start();\n    //this._connectionStatus = \"connected\";\n    this._sendRequiredMessages();\n  }\n  async #onWebSocketMessage(event: ws.MessageEvent) {\n    _console.log(\"webSocket.message\", event);\n    //this.#pingTimer.restart();\n    //@ts-expect-error\n    const arrayBuffer = await event.data.arrayBuffer();\n    const dataView = new DataView(arrayBuffer);\n    this.#parseWebSocketMessage(dataView);\n  }\n  #onWebSocketClose(event: ws.CloseEvent) {\n    _console.log(\"webSocket.close\", event);\n\n    this._connectionStatus = \"notConnected\";\n\n    Object.entries(this.devices).forEach(([id, device]) => {\n      const connectionManager =\n        device.connectionManager! as ClientConnectionManager;\n      connectionManager.isConnected = false;\n    });\n\n    this.#pingTimer.stop();\n    if (this.reconnectOnDisconnection) {\n      setTimeout(() => {\n        this.reconnect();\n      }, webSocketReconnectTimeout);\n    }\n  }\n  #onWebSocketError(event: ws.ErrorEvent) {\n    _console.error(\"webSocket.error\", event);\n  }\n\n  // PARSING\n  #parseWebSocketMessage(dataView: DataView) {\n    parseMessage(\n      dataView,\n      WebSocketMessageTypes,\n      this.#onServerMessage.bind(this),\n      null,\n      true\n    );\n  }\n\n  #onServerMessage(messageType: WebSocketMessageType, dataView: DataView) {\n    switch (messageType) {\n      case \"ping\":\n        this.#pong();\n        break;\n      case \"pong\":\n        break;\n      case \"serverMessage\":\n        this.parseMessage(dataView);\n        break;\n      default:\n        _console.error(`uncaught messageType \"${messageType}\"`);\n        break;\n    }\n  }\n\n  // PING\n  #pingTimer = new Timer(this.#ping.bind(this), webSocketPingTimeout);\n  #ping() {\n    this.#sendWebSocketMessage(\"ping\");\n  }\n  #pong() {\n    this.#sendWebSocketMessage(\"pong\");\n  }\n}\n\nexport default WebSocketClient;\n","export {\n  setAllConsoleLevelFlags,\n  setConsoleLevelFlagsForType,\n} from \"./utils/Console.ts\";\nexport * as Environment from \"./utils/environment.ts\";\nexport { Vector2, Vector3, Quaternion, Euler } from \"./utils/MathUtils.ts\";\n\nexport {\n  default as Device,\n  DeviceEvent,\n  DeviceEventMap,\n  DeviceEventListenerMap,\n  BoundDeviceEventListeners,\n} from \"./Device.ts\";\nexport {\n  default as DeviceManager,\n  DeviceManagerEvent,\n  DeviceManagerEventMap,\n  DeviceManagerEventListenerMap,\n  BoundDeviceManagerEventListeners,\n} from \"./DeviceManager.ts\";\n\nexport { DeviceInformation } from \"./DeviceInformationManager.ts\";\nexport {\n  DeviceType,\n  DeviceTypes,\n  MinNameLength,\n  MaxNameLength,\n  Sides,\n  Side,\n} from \"./InformationManager.ts\";\nexport {\n  MinWifiSSIDLength,\n  MaxWifiSSIDLength,\n  MinWifiPasswordLength,\n  MaxWifiPasswordLength,\n} from \"./WifiManager.ts\";\nexport {\n  SensorType,\n  SensorTypes,\n  ContinuousSensorType,\n  ContinuousSensorTypes,\n} from \"./sensor/SensorDataManager.ts\";\nexport {\n  MaxSensorRate,\n  SensorRateStep,\n  SensorConfiguration,\n} from \"./sensor/SensorConfigurationManager.ts\";\n\nexport {\n  DefaultNumberOfPressureSensors,\n  PressureData,\n} from \"./sensor/PressureSensorDataManager.ts\";\nexport { CenterOfPressure } from \"./utils/CenterOfPressureHelper.ts\";\nexport {\n  VibrationConfiguration,\n  VibrationLocation,\n  VibrationLocations,\n  VibrationType,\n  VibrationTypes,\n  MaxNumberOfVibrationWaveformEffectSegments,\n  MaxVibrationWaveformSegmentDuration,\n  MaxVibrationWaveformEffectSegmentDelay,\n  MaxVibrationWaveformEffectSegmentLoopCount,\n  MaxNumberOfVibrationWaveformSegments,\n  MaxVibrationWaveformEffectSequenceLoopCount,\n} from \"./vibration/VibrationManager.ts\";\nexport {\n  VibrationWaveformEffect,\n  VibrationWaveformEffects,\n} from \"./vibration/VibrationWaveformEffects.ts\";\n\nexport {\n  FileType,\n  FileTypes,\n  FileTransferDirection,\n  FileTransferDirections,\n} from \"./FileTransferManager.ts\";\nexport {\n  TfliteSensorType,\n  TfliteSensorTypes,\n  TfliteTask,\n  TfliteTasks,\n  TfliteFileConfiguration as TfliteFileConfiguration,\n} from \"./TfliteManager.ts\";\n\nexport {\n  CameraConfiguration,\n  CameraCommand,\n  CameraCommands,\n  CameraConfigurationType,\n  CameraConfigurationTypes,\n} from \"./CameraManager.ts\";\n\nexport {\n  MicrophoneConfiguration,\n  MicrophoneCommand,\n  MicrophoneCommands,\n  MicrophoneConfigurationType,\n  MicrophoneConfigurationTypes,\n  MicrophoneConfigurationValues,\n} from \"./MicrophoneManager.ts\";\n\nexport {\n  DisplayBrightness,\n  DisplayBrightnesses,\n  DisplaySize,\n  DisplayBitmap,\n  DisplayBitmapColorPair,\n  DisplayPixelDepths,\n  DefaultNumberOfDisplayColors,\n} from \"./DisplayManager.ts\";\n\nexport {\n  DisplaySegmentCap,\n  DisplaySegmentCaps,\n} from \"./utils/DisplayContextState.ts\";\n\nexport {\n  maxDisplayBitmapScale,\n  DisplayColorRGB,\n} from \"./utils/DisplayUtils.ts\";\n\n/** BROWSER_START */\nexport {\n  default as DisplayCanvasHelper,\n  DisplayCanvasHelperEvent,\n  DisplayCanvasHelperEventMap,\n  DisplayCanvasHelperEventListenerMap,\n} from \"./utils/DisplayCanvasHelper.ts\";\n/** BROWSER_END */\n\n/** BROWSER_START */\nexport { resizeAndQuantizeImage } from \"./utils/BitmapUtils.ts\";\n/** BROWSER_END */\n\nexport { rgbToHex, hexToRGB } from \"./utils/ColorUtils.ts\";\n\nexport {\n  default as DevicePair,\n  DevicePairEvent,\n  DevicePairEventMap,\n  DevicePairEventListenerMap,\n  BoundDevicePairEventListeners,\n  DevicePairType,\n  DevicePairTypes,\n} from \"./devicePair/DevicePair.ts\";\n\nimport { addEventListeners, removeEventListeners } from \"./utils/EventUtils.ts\";\nexport const EventUtils = {\n  addEventListeners,\n  removeEventListeners,\n};\n\nimport { throttle, debounce } from \"./utils/ThrottleUtils.ts\";\nexport const ThrottleUtils = {\n  throttle,\n  debounce,\n};\n\nexport { DiscoveredDevice } from \"./scanner/BaseScanner.ts\";\n/** NODE_START */\nexport { default as Scanner } from \"./scanner/Scanner.ts\";\nexport { default as WebSocketServer } from \"./server/websocket/WebSocketServer.ts\";\nexport { default as UDPServer } from \"./server/udp/UDPServer.ts\";\n/** NODE_END */\n/** BROWSER_START */\nexport { default as WebSocketClient } from \"./server/websocket/WebSocketClient.ts\";\n/** BROWSER_END */\n/** LS_START */\nexport { default as WebSocketClient } from \"./server/websocket/WebSocketClient.ts\";\n/** LS_END */\n\nexport { default as RangeHelper } from \"./utils/RangeHelper.ts\";\n"],"names":["createWebSocketMessage"],"mappings":"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AEA;;AAGA;;AAEA;;AAIA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;;;AAKA;;AAEA;AACA;;AAEA;AAEA;;AAEA;AAGA;AACA;;AAIA;AACA;;AAGA;AACA;;;AAKA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAMA;AACA;AAGA;;;AAIA;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAKA;AACA;AACA;AACA;;;AAKA;AACA;AACA;AAEA;AACA;;;AAOA;;AAGA;AACA;AACA;AACA;;AAMA;;AAEA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;;;AAOA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;;;;;;AAUA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;;AAGA;;AAGA;AACA;;AAIA;AACA;AACA;;;;AAMA;;;;AAOA;AAEA;AACA;;AAGA;AACA;;AAEA;AACA;;AAEA;AAEA;;AAGA;AAEA;;;AAGA;AACA;AAEA;;;AAIA;AACA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAIA;;AAEA;;AAGA;AACA;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AAWA;AACA;;;AAGA;;;;;AAQA;;;;;AAMA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;AAUA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AAIA;;;;;AAKA;AAEA;AACA;AACA;;AAGA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;;;;AAMA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;;;AAIA;AACA;AACA;;;AAMA;;AAEA;AACA;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;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A;AACL;AACA;AACA;AACA;AACA;;AAWF;AAYE;;;AAGA;AACE;;AAEF;AACE;;AAGF;AACE;;AAIF;AACE;;AAWF;;AAIA;AA0FA;AACA;;AAoFA;AAsBA;AAxME;;AAIF;;;;AAIE;AACA;AACE;;;AAKF;AACA;AACA;AAEA;AACE;;;AAEA;;AAGF;AACE;;;AAIJ;AACE;;AAGF;AACE;;;;;;;;;;AA4BA;;AAGF;;AAEE;AACA;;AAEF;AACE;;AAEF;;AAEE;;AAEA;AACA;;AAEF;;AAEE;AACA;AACA;;;;AAKA;;AAKF;;;;;;;AAYI;;;AAIF;AACE;;;;AAIA;;;AAGF;AAEA;;;;;AAME;;AAEF;AACA;AAEA;AACE;;AAMI;;;;;;AAMF;AACE;;AAIE;;;AAKF;AACA;AACF;;;AAIA;AACA;AACA;;;;AAGF;AACA;AACA;;AAGF;AAEA;;;AAQA;;AAGF;AACE;;;;AAyBA;AACA;;;;AAMA;AACA;AACA;;AAEH;;AAnQG;AACF;AA8BE;AAIF;;AAmDA;;AAWA;;AA0IE;AACF;AAKE;AACE;AACA;;AAEJ;;AC/WI;AACJ;AACF;;ACPA;AAqBgB;AACd;AACA;AACA;AACA;AACE;AACF;AACF;AAEgB;AACd;AACA;AACA;AACA;AACE;AACF;AACF;;ACjCA;AAQA;AACE;AACF;AAiCA;AACE;;;AAMF;AAEA;AAGE;AACF;AAEA;AACE;AACF;AA6BA;AACE;AACE;AACE;AACA;AACE;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACF;AACF;AACD;AACE;AACA;AACE;AACE;AACD;AACF;AACF;AACD;AACE;AACA;;;AAGC;AACF;AACD;AACE;AACA;AACE;AACD;AACF;AACF;AACF;AAEM;AACA;AACL;AACA;AACA;;AAE6B;AAEzB;;;AAOJ;;;AAGE;;;;;;;AAOF;AACF;AAEO;AACA;AAKP;AACE;;;;AAMA;;;AAGI;AACA;;AAEF;AAEF;AACF;AAIM;;AAKJ;AACA;;;;;AAQI;;;;;;;AAOF;AACA;AACF;AACA;AACF;AAEM;AAGJ;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAKA;AACA;AACA;AACE;;;;AAMF;AACA;AACA;AACE;;;;AAMF;AACE;;;;AAMF;AACE;;;AAIJ;AACF;;AClRA;AAIA;AAAA;;;;AACE;AAEE;;;AASA;AACE;;;;;;AAMM;;;;AAQR;;;;AAKA;AACA;;;;;AAKH;;;ACpBD;AAWA;AASA;AACE;AACF;AAGA;AAAA;;;;;;;;;;;;;AACE;AACE;;AAGF;;;AAcA;AACE;;AAEF;AACE;;AAIF;;;;AAIE;AACE;;;AAGF;;;;AAOE;;AAEF;;AAGF;AACE;;AAEF;AACE;;AAOF;AACE;AAEA;AACE;AACE;;AAED;AAED;AACA;AAEA;;;AAIA;AAEA;AAEA;;;AAEA;AACA;AACA;AACA;;;AA+FJ;AACE;AACA;AACA;AACA;;AAuCF;AAIE;;;;AAQA;;AAGA;AACE;AACA;;;AAEA;AACA;;AAEF;;AAGE;AACA;AACA;AACE;;;;AAUN;AACE;;AAEF;AACE;AACA;AACE;;;AAEA;AACA;;AAGF;AACE;AACA;AACA;;;AAEA;AACA;;;;;AAMF;;AAEH;;AAtMG;AAEA;;;AAKA;AACA;AACE;AACA;;;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACE;AAGA;;AAIA;;AAOA;;AAEA;AAIA;;AAGA;AACE;AAGA;;AAEF;AACE;AACA;AACA;AACE;;;;;AAKV;AAEE;;;AAOA;;AAGI;AAIA;;AAGA;AACE;AAGA;;AAEJ;AAGF;AACF;AASE;AAEA;AACA;AACF;AAGE;AAEA;AACA;AAKA;AAGA;;;AAUA;AACE;;;AAEA;;AAEJ;AAoCE;AACA;AACF;;AC3RF;AACA;AACA;AAEO;AACP;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEO;AACP;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEO;AACP;AACA;AACA;;ACzYA;AAEO;AAEP;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;ACnbA;AAEO;AAGA;AACL;;;;;;AAQK;AAyBP;AAGE;;AAkDA;;;;AAjDE;;;AAKF;AACE;;AAKF;AACE;;AAEF;AACE;;;AAIA;;AAGE;AACE;;;AAGF;AACE;;;;AAKJ;;AAIA;AAEA;;AAEA;;AAIA;AAEA;;AAIF;;;AAkBA;;;AAUA;;AAGE;AACA;AAEA;;AAGF;AACE;AACA;;AAEE;;;;AAIA;;;;AAIA;;;;AAMF;;AAGA;;AAGF;AACE;;AAGA;AACA;AAEA;AAEA;AACA;;AAGF;AACE;AACA;;AAEE;;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;;AAEA;;AAKE;;;AAKJ;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAIF;AACE;;AAEF;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAOF;AACE;;AAYF;AACE;AACA;;AAEF;;;AAGA;;AAKE;AACA;;AAEF;AACE;;AAEF;AACE;AACA;;AAEF;AACE;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAKF;;;;AAIE;AACE;;;AAGF;AACA;;;AAMF;;;AAMA;AACE;;AAEF;AACE;;;;;AAKF;AACE;;;;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAGF;;;;AAOE;AACA;;AAEE;;;AAGD;;AAGH;AACE;;;;AAOA;AACA;;AAEE;;AAED;;AAKH;;;AAGA;AACE;;AAKF;AACE;;AAEE;;AAEF;;AAEF;AACE;;AAEE;;AAEF;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;;AAEF;AACE;;AAEF;AACE;;AAGF;AACE;;AAKF;;;AAGA;AACE;;AAMF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;;AAEF;AACE;;AAEF;AACE;;AAOF;AACE;AACA;;;AAGA;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;AAMF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAKF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;;;;AAzzCF;AAUE;AACF;;AA6CA;;AAqFA;AAGE;;;AAII;;AAEF;AACF;AACF;;;;;AAUE;;;;;;;;;AAeA;;;AAKA;;;AAKA;;;AAKA;AACF;AAEE;;AAGI;AACD;AAEH;AACF;;AAOA;AAsFE;AAEA;AACE;;AAGE;AACA;AACE;;AAEF;;;;AAGF;AACE;AACA;AACA;;;AAIJ;;AAGE;AACE;;;AAIJ;AACF;AAGE;;AAEC;;;AAGC;;AAEJ;;AAII;AACA;AAEF;AACE;AACE;AACE;;;AAGJ;AACE;;AAEF;AACE;;;AAGN;AAGE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACF;AAEE;AACA;AACF;;;AAQI;;;AAGE;;AAGF;AACE;;;AASO;;;AAOA;;;AAOA;;;AAOA;;;AAOA;;;AASA;;;AASA;;;AAOA;;;AAKA;;;AAOA;;;AAOA;;;;AAQL;;;;AAKN;;;;AAOA;AACF;;AAGI;;AAEF;AAEE;;;AAIF;AACF;AAgBE;AACA;AACE;;;AAGF;;AAEA;AACF;;AA8PA;AAGE;;AAEF;;AAkJA;;AAoDA;AA8BE;AACF;;AA6DA;AAj1BO;AAsXA;;;AC15BT;AAEO;;;;;;;;;;;AA8EP;AACE;;AAOA;;;AAoFA;AACA;AAqDA;;;;;;;AA2EA;AAgCA;AAoBA;;AA4DA;AASA;AAomBA;AAm/BA;;AAwGA;;AAKE;AACA;AACA;AACA;AACA;;AA5hEA;;AAEA;;AAQF;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAKF;;;;AAIE;AAIA;AACE;;;AAGF;;;AAIE;AACD;AACD;;AAGF;;;AAIA;AACE;;AAEF;AACE;;AAEF;AACE;;AAkFF;;;;AAIE;;AAEA;;AAKF;;;;AAIE;AACE;;;;;;;AAaF;;AAEE;;AAEF;;;AAGA;;AAEE;AACA;;;;AAoCJ;;;;AAIE;;;AAIA;;AAGA;AACA;AACA;AAIA;;AAEC;;AAaH;;;AAoBA;;;AAqBA;AACE;;AAmBF;AACE;;AAGA;AAEA;AAEA;AAEA;;;;AAGE;AACA;;;;AAKJ;;;;AAIE;;;AAKF;;;AAIA;AACE;AAEA;AACA;AAEA;AAEA;AACA;AAEA;;;;AAGE;AACA;;;;AAKJ;AAKE;AACA;AACE;;;;;AAIF;;;;;;AAOA;;AAGA;AACE;;AAGF;AACA;AACA;;AAGF;AAKE;;;;;;AAQA;AACE;;AAOF;AACA;AACA;;AAEF;;AAEE;;;AAGA;AACA;;;;AAOA;;;;;AAOA;;;;AAKF;AACE;AACA;;AAEC;AACD;;;AAGA;;;AAGA;;AAEF;AACE;AACA;;AAEC;AACD;;;AAGA;;;AAGA;;AAKF;AACE;AACA;;AAEC;AACD;;;AAGA;;;AAGA;;AAEF;AAKE;AACA;AACA;AAEA;;AAEC;AACD;;;AAIA;AACE;;AAGF;;;AAGA;AACE;AACD;AACD;;;AAGA;;;AAGA;;AAEF;;AAKE;;AAEC;AACD;;;AAGA;AACA;;;AAMA;;AAEF;;AAKE;;AAEC;AACD;;;AAGA;AACA;;;AAGA;;AAEF;;AAKE;AACE;AACA;AACD;AACD;;;AAGA;AACA;;;AAGA;;AAEF;AAIE;;AAEC;AACD;;;AAGA;AACA;;;AAMA;;AAEF;AAIE;;AAEC;AACD;;;AAGA;AACA;;;AAMA;;AAGF;AACE;AACE;AACA;AACD;AACD;;;AAGA;AACA;;;AAGA;;AAEF;AAKE;;AAEA;AACA;AACA;;AAEC;AACD;;;;AAIA;AACE;;AAEF;;AAEF;;;AAGA;;;AAGA;;;AAGA;;;;AAIE;AACE;AACA;AACA;AACA;AACD;AACD;;;AAGA;;;AAGA;;AAGF;AAKE;AACA;AACA;AACA;;AAEC;AACD;;;;AAIA;AACE;;AAMF;;AAEF;;;AAGA;;;AAMA;;;AAMA;;;;AAOE;AACE;AACA;AACA;AACA;AACD;AACD;;;AAGA;;;AAGA;;AAGF;AACE;;AAEF;AACE;;AAEF;AAKE;;AAEA;AACA;;AAEC;AACD;;;AAIA;AACE;;AAMF;;AAGF;AAIE;;;AAQE;AACA;AACA;AACF;AAEA;;AAEC;AACD;;;AAIA;;;AAMA;;AAGF;AAKE;;AAMF;AAKE;;AAOF;;AAUE;;;AAGE;AACE;AACA;;AAEF;AACE;;AAEF;AACE;;;;AAIJ;;;AAIA;AACE;;AAOF;;AAGF;;;AAGA;;;AAGA;;;;;;;;AAwBE;AACE;;;;;;AAsMF;AACE;;;AAgDJ;;;AAmBE;AACE;;;;;;AAmEF;AACE;;;;;;AA8EF;AACE;;;;AAmFF;AACE;;;;;AAaF;AACE;;;;;AAiSA;;;;;AAOF;AACE;;;AAwDJ;AACE;AACA;;AAEA;AAGA;;;;AAkDF;AASE;AACA;;AAGA;AAWA;;;;AAgFF;AAUE;AACA;;AAGA;AAYA;;;;;AAoGA;AACA;;;AAKA;AACE;;;AAYJ;;;AAaA;AAIE;AACE;;;AAGF;;AAEA;;;AAGA;AACA;;AAaF;;;AAmBD;;AAjkEG;AACF;AAoDE;;;AAGA;AACA;;;AAIA;;;AAKA;AACA;AACA;;;AAKF;AAME;;;AAGA;AACA;AAEA;AACA;AACA;AACE;;;AAGJ;AAEE;;AAOA;AAEA;AAEA;AACE;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAIJ;AAGE;AACA;AACA;AACA;AACF;AAqDE;AACA;AACA;AAEF;AAEE;AACF;AAEE;AACA;;AAGF;AAGE;AACA;AACA;AACA;AACF;AA4BE;AAMF;AASE;;;AAGA;AACE;;;AAGA;;AAEJ;AAYE;;;AAGA;AACE;;;AAGA;;AAEJ;AAQE;AACE;;AAED;AACH;AAKE;;;AAGA;;AAEF;AAiKE;AACF;AAuZE;AACA;AACA;AACA;AACA;AACF;AAgBE;;AAEF;AAEE;;AAEF;AAEE;AACA;AACA;AACF;;;AAOE;AACA;;;AAKA;;;AAGE;;;AAIF;AACE;AACA;AACD;AAED;AACA;;;;;;;;;;;AAaF;AAGE;AACF;;AASE;AACE;AACA;AACA;AACA;;AAEF;AACF;AAKE;;AAEA;;AAEF;AAUE;;AAEA;;AAOF;AAIE;AACE;;AAGF;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACF;AAEE;AACA;AACF;;AAGA;;AAMA;AAYE;AACA;AACA;AACF;AAQE;AAEA;AACA;AAOA;AACE;;AAEF;;AAGA;;AAIA;AACA;AACA;AACA;AACE;;AAEF;AACF;AA+BE;AAEA;AACA;AAOA;AACE;;AAEF;;AAGA;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACE;;AAEF;AACF;AAqCE;AACA;AAOF;AAOE;AAEA;AACA;AAMA;AACE;;;AAIF;;AAIA;AACA;AACA;AACA;AACE;;AAEF;AACF;AA2BE;AACA;AACA;AAOF;AAQE;AAEA;AACA;AAOA;AACE;;AAGF;;AAGA;;AAIA;;AAEA;AACA;AACE;;AAEF;AACF;;AAoCE;;AAGA;AACA;AACE;AACA;AACA;AACA;;AAEF;AACF;AAQE;AAEA;AACA;AAOA;AACE;;;AAKF;;AAIA;;AAEA;AACE;;;AAGA;;;;;;;AAMF;AAEA;AACA;AACE;;AAEF;AACF;;AAwCE;AACA;;AAGA;AAIA;AAIA;AAIA;AAKA;AAEA;AACE;AACA;;;;AAIF;AACA;AACF;;AAeE;;;;AAIA;;;AAIA;AAEA;;;;;AAOA;AACE;AACA;;AAGF;AACF;;AAeE;;;;AAIA;;;AAIA;;AAIA;AAGA;AACE;AACA;AACA;AACA;;AAEF;AACF;AAQE;;;;AAIA;AACA;;AAEA;AAOA;AACA;AACA;;AAQA;AACF;AASE;AAEA;AAEA;AACA;AAOA;AACE;;;AAKF;;;;;AAOA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;AAGA;;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACE;AACA;AACA;AACA;AACA;AACE;;;AAGJ;AACE;AACA;AACA;AACA;AACA;AACE;;;AAKJ;;;;;AAKA;AACA;AAGA;AACE;;;AAOA;;;;;;;AAUA;AAEE;AAEA;;AAGG;;;;AAKL;;AAGF;AACF;AA2BE;;;AAKE;;AAGE;AACA;AACA;AACA;AAEA;AAOA;AACE;;;AAGN;;AAGE;;AAGE;AACA;AACA;AACA;AAEA;;AASJ;AACF;AAqBE;AAEA;AACA;AAMA;AACE;;;AAIF;;AAKA;;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACE;AACA;AACA;;AAGF;AACF;AA+CE;AAEA;AACA;AAOA;AACE;;AAGF;;AAGA;;AAKA;;AAEA;AACA;;AAYA;AACA;AAGA;AACE;;AAWA;;AAGF;AACF;AAiDE;;AAKA;AACA;AAIA;AACA;AAOA;AACE;;AAEF;;AAGA;;;;AAOA;AAIA;AAEA;AACA;;;;AAIE;AAEA;;;;AAKA;AACF;;AAKA;AAEA;AACF;AAGE;AAMF;;;AAIA;;AAsCA;AAqBE;;;AAGA;AACA;AACF;;;AC3rEF;AACE;AACD;AAoBD;AAOE;;AANA;;;;;;AAWE;AACA;;AAGF;AACE;AACA;;AAEA;AACA;AACE;;;AAEA;;;AAuEL;;AAlEG;AACF;AAGE;AACE;AACA;;;AAIF;;AAEE;AAEF;AACA;;AAMA;AACE;AACA;;;;AAiBM;;;;AAIA;;;;AAIA;AACA;;AAEF;;AAEJ;AAEA;;;;AASF;AACF;;;ACrHF;AAEO;AAGA;AA4BP;AAAA;AAME;AAEA;;AANA;AACE;;;AAOA;;AAGF;;;;AAMI;;AAEF;AAEA;;AAEE;;;AAGA;AACE;;;;AAKF;AAEA;AAEA;;;AAEA;;;AAGL;;;;AClDD;AAWA;AACE;AAGF;AACA;AAIO;AAQA;AACL;AACA;AACA;;;AAqCF;AACE;;;AAeA;;;;;;;;;AAdE;;;AAKF;AACE;;AAIF;;;AAQA;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAKF;;;AAKA;;;AAIA;AACE;;AAEF;AACE;;AAEF;;;AAgBA;;AAEI;;;AAKF;AAEA;AAEA;AACE;;;;AAKA;;AAEF;;AAGE;AACE;;AAEF;AACE;;;AAIJ;;AAIA;AACA;;;;AAIC;AAED;;;AAmFA;AACE;AACA;;;;;;AAcF;AACA;;AAIF;;;AASE;AACA;;AAKF;;;AAIA;;;;;AApNE;AACF;AAuCE;AACE;;AAEA;;;AAGJ;AA+CE;AACA;AACE;;AAKF;AACF;AAEE;AACA;AACE;;AAKF;AACF;;AAII;AACE;;AAGF;AACA;;AAGE;AACE;;AAEF;AACE;;;AAIJ;AACF;;AAEE;;AAEF;AACF;;;AAWI;;;AAGD;AACH;AAGE;AACF;AAGE;;;;;;;;AAQA;AACF;AAeE;AACE;;AAEJ;AAqBO;AAIA;AAIP;;AAEI;AACA;AACE;;AAEF;AACE;;AAEJ;AACF;;AClWI;;;;;AAUF;;AAGA;;;;;;AAME;;;;;AAIE;AACE;;;AAGE;;;;;;AAMV;AACF;AAEM;;;AAQF;;;;AAMA;;;AAGI;;;;AAKF;;AAEJ;AACF;;;AC9CA;AAUqE;AACnE;;;AAIF;AAAA;;;;AA+BE;;AA9BA;AACE;;AAEF;AACE;;AAKF;AAEE;;AAOF;;;;AAIE;AACA;AACE;;;AAGF;;AAIF;;;;AAIE;AACA;AACE;;;AAGF;AAEA;AAEA;AACE;;;AAIJ;AACE;;AAGF;AACE;AACA;;AAEF;AACE;;;AAIF;AACE;;AAEF;AACE;;;;AAUA;;;;AAKA;AACA;;;;;AAWF;AACE;AACA;;;AA+BH;;;AAnCC;;;;AAoBI;AACE;AACA;AACA;;AAGF;AACE;;AAGF;AACE;;;AAGN;;;AC3HF;AAEO;;;;;;AAQA;AACL;;;;;;;;AAsCF;AAAA;;AAoBE;AAKA;AAyCU;AAaV;AA2CA;AA0HA;AA4BA;AA0CA;;AAzTA;;;AAoBA;;;AAQA;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;;;;;;;AAmBF;;;;AAIE;AACA;;AAKF;;;;AAIE;AACA;;AAOF;;;;AAIE;AACA;AACA;AAEA;;AAEC;;;AAIC;AACA;AACE;AACA;;AAGE;;;;;AAKR;;;;;;;AAwCU;;AAER;AAOA;;AAwGF;;;;AAWE;;AAYF;;;;AAeE;AACA;;;AAGA;AACA;;;AAGA;AAEA;;;;;;;AASF;;;AAIU;AACR;;;;;;;;;;;;AA4BA;;;AAGE;;;;;AAIF;;;;;AAQI;AACA;AAID;;;AAED;;;AAKJ;AACE;;AAEA;;AAKA;AACA;AACA;AAIA;;AAEA;;AAEA;;AAEA;AACA;;AAWQ;AACR;AACA;;AAEE;AAEA;AACA;AACF;;AAGF;AACE;;AAEQ;;AAER;;;;AAIA;;AAEQ;AACR;;AAGQ;;AAKN;;AAED;;AAGO;;AAEN;;AAED;;;;AAzbD;AACA;AACA;;AAEE;AAEA;;AAGF;AAEF;;AAmGA;AAQE;;;AAGA;;AAGE;;;AAIF;;AAEI;;;;AAKJ;AACA;AACF;;;;AAoBI;;AAEI;AACA;AACA;;;AAGJ;;AAEI;AACA;AACA;;;AAGJ;;AAEI;AAIA;;AAKA;AAEA;;;AAGJ;;AAEI;AAIA;;;AAGJ;;AAEI;;;AAGA;AAEA;;AAIA;AACA;;;AAGJ;;AAEI;;;;AAQA;;AAGA;;;AAGJ;AACE;;;AAIJ;AACE;;AAEJ;;AAMA;AAEE;AACA;AACA;;AAEC;AACD;AACE;;AAEJ;;;AAUA;;AAQA;AAEE;AACA;AACA;AACF;AAKE;AACF;;AAIA;;AAGA;;;;AAsCI;;;;AAIF;;AAEF;;;AAiEI;AACA;;AAEF;AACF;AA7VO;AAoDA;;;;AAIN;;;AC1KH;AAEA;AAAA;;;;;;;;;;AAoNE;;AAjNA;;;;AAIE;AACE;;;AAIF;AAEA;;;AAIA;AACA;AAEA;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAGF;AACE;;;AAGA;;;;;;;;AAsDA;AACE;;AAII;AACF;;AAIJ;AACA;;;;;;AAQF;AACE;;;;;;;AAKE;;;AAKJ;;AAEE;AACA;;;AAIA;AAEI;AACA;AACD;;AAuFN;AAnFuB;;AAEtB;AAWE;AACA;;AAGF;AAEE;;AAIA;AACA;AACF;AAEE;AAEA;AAEA;AACE;AAEA;AACF;AAEA;AACA;;;;;AAKF;AAEE;AACF;AAIE;AAOF;;AAII;AACE;;AAEF;;AAEA;AACE;;AAEF;AACE;;;AAGN;AAKE;AACF;AAEE;AACF;;AChGW;;;;AAMA;;;;;","x_google_ignoreList":[0,8,34]}