{"version":3,"file":"brilliantsole.module.js","sources":["../node_modules/tslib/tslib.es6.js","../brilliantsole/utils/environment.ts","../brilliantsole/utils/Console.ts","../brilliantsole/utils/EventDispatcher.ts","../brilliantsole/utils/Timer.ts","../brilliantsole/utils/checksum.ts","../brilliantsole/utils/Text.ts","../brilliantsole/utils/ArrayBufferUtils.ts","../node_modules/auto-bind/index.js","../brilliantsole/FileTransferManager.ts","../brilliantsole/utils/MathUtils.ts","../brilliantsole/utils/RangeHelper.ts","../brilliantsole/utils/CenterOfPressureHelper.ts","../brilliantsole/utils/ArrayUtils.ts","../brilliantsole/sensor/PressureSensorDataManager.ts","../brilliantsole/sensor/MotionSensorDataManager.ts","../brilliantsole/sensor/BarometerSensorDataManager.ts","../brilliantsole/utils/ParseUtils.ts","../brilliantsole/CameraManager.ts","../brilliantsole/utils/AudioUtils.ts","../brilliantsole/MicrophoneManager.ts","../brilliantsole/sensor/SensorDataManager.ts","../brilliantsole/sensor/SensorConfigurationManager.ts","../brilliantsole/TfliteManager.ts","../brilliantsole/DeviceInformationManager.ts","../brilliantsole/InformationManager.ts","../brilliantsole/vibration/VibrationWaveformEffects.ts","../brilliantsole/vibration/VibrationManager.ts","../brilliantsole/WifiManager.ts","../brilliantsole/utils/ColorUtils.ts","../brilliantsole/utils/DisplayContextState.ts","../brilliantsole/utils/ObjectUtils.ts","../brilliantsole/utils/DisplayContextStateHelper.ts","../brilliantsole/utils/DisplayUtils.ts","../node_modules/rgbquant/src/rgbquant.js","../brilliantsole/utils/DisplayBitmapUtils.ts","../brilliantsole/utils/DisplayContextCommand.ts","../brilliantsole/utils/DisplayManagerInterface.ts","../node_modules/opentype.js/dist/opentype.module.js","../brilliantsole/utils/DisplaySpriteSheetUtils.ts","../brilliantsole/DisplayManager.ts","../brilliantsole/connection/BaseConnectionManager.ts","../brilliantsole/utils/stringUtils.ts","../brilliantsole/utils/EventUtils.ts","../brilliantsole/connection/bluetooth/bluetoothUUIDs.ts","../brilliantsole/connection/bluetooth/BluetoothConnectionManager.ts","../brilliantsole/connection/bluetooth/WebBluetoothConnectionManager.ts","../brilliantsole/utils/cbor.js","../brilliantsole/utils/mcumgr.js","../brilliantsole/FirmwareManager.ts","../brilliantsole/DeviceManager.ts","../brilliantsole/server/ServerUtils.ts","../brilliantsole/server/websocket/WebSocketUtils.ts","../brilliantsole/connection/websocket/WebSocketConnectionManager.ts","../brilliantsole/Device.ts","../brilliantsole/utils/DisplayCanvasHelper.ts","../brilliantsole/devicePair/DevicePairPressureSensorDataManager.ts","../brilliantsole/devicePair/DevicePairSensorDataManager.ts","../brilliantsole/devicePair/DevicePair.ts","../brilliantsole/utils/ThrottleUtils.ts","../brilliantsole/connection/ClientConnectionManager.ts","../brilliantsole/server/BaseClient.ts","../brilliantsole/server/websocket/WebSocketClient.ts","../brilliantsole/BS.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","type ENVIRONMENT_FLAG = \"__BRILLIANTSOLE__DEV__\" | \"__BRILLIANTSOLE__PROD__\";\nconst __BRILLIANTSOLE__ENVIRONMENT__: ENVIRONMENT_FLAG =\n  \"__BRILLIANTSOLE__DEV__\";\n\n//@ts-expect-error\nconst isInProduction =\n  __BRILLIANTSOLE__ENVIRONMENT__ == \"__BRILLIANTSOLE__PROD__\";\nconst isInDev = __BRILLIANTSOLE__ENVIRONMENT__ == \"__BRILLIANTSOLE__DEV__\";\n\n// https://github.com/flexdinesh/browser-or-node/blob/master/src/index.ts\nconst isInBrowser =\n  typeof window !== \"undefined\" && typeof window?.document !== \"undefined\";\nconst isInNode =\n  typeof process !== \"undefined\" && process?.versions?.node != null;\n\nconst userAgent = (isInBrowser && navigator.userAgent) || \"\";\n\nlet isBluetoothSupported = false;\nif (isInBrowser) {\n  isBluetoothSupported = Boolean(navigator.bluetooth);\n} else if (isInNode) {\n  isBluetoothSupported = true;\n}\n\nconst isInBluefy = isInBrowser && /Bluefy/i.test(userAgent);\nconst isInWebBLE = isInBrowser && /WebBLE/i.test(userAgent);\n\nconst isAndroid = isInBrowser && /Android/i.test(userAgent);\nconst isSafari =\n  isInBrowser && /Safari/i.test(userAgent) && !/Chrome/i.test(userAgent);\n\nconst isIOS = isInBrowser && /iPad|iPhone|iPod/i.test(userAgent);\nconst isMac = isInBrowser && /Macintosh/i.test(userAgent);\n\n// @ts-expect-error\nconst isInLensStudio =\n  !isInBrowser &&\n  !isInNode &&\n  typeof global !== \"undefined\" &&\n  typeof Studio !== \"undefined\";\n\nexport {\n  isInDev,\n  isInProduction,\n  isInBrowser,\n  isInNode,\n  isAndroid,\n  isInBluefy,\n  isInWebBLE,\n  isSafari,\n  isInLensStudio,\n  isIOS,\n  isMac,\n  isBluetoothSupported,\n};\n","import { isInDev, isInLensStudio, isInNode } from \"./environment.ts\";\n\ndeclare var Studio: any | undefined;\n\nexport type LogFunction = (...data: any[]) => void;\nexport type AssertLogFunction = (condition: boolean, ...data: any[]) => void;\n\nexport interface ConsoleLevelFlags {\n  log?: boolean;\n  warn?: boolean;\n  error?: boolean;\n  assert?: boolean;\n  table?: boolean;\n}\n\ninterface ConsoleLike {\n  log?: LogFunction;\n  warn?: LogFunction;\n  error?: LogFunction;\n  assert?: AssertLogFunction;\n  table?: LogFunction;\n}\n\nvar __console: ConsoleLike;\nif (isInLensStudio) {\n  const log = function (...args: any[]) {\n    Studio.log(args.map((value) => new String(value)).join(\",\"));\n  };\n  __console = {};\n  __console.log = log;\n  __console.warn = log.bind(__console, \"WARNING\");\n  __console.error = log.bind(__console, \"ERROR\");\n} else {\n  __console = console;\n}\n\nfunction getCallerFunctionPath(): string {\n  const stack = new Error().stack;\n  if (!stack) return \"\";\n\n  const lines = stack.split(\"\\n\");\n  const callerLine = lines[3] || lines[2];\n\n  const match = callerLine.match(/at (.*?) \\(/) || callerLine.match(/at (.*)/);\n  if (!match) return \"\";\n\n  const fullFn = match[1].trim();\n  return `[${fullFn}]`;\n}\n\nfunction wrapWithLocation(fn: LogFunction): LogFunction {\n  return (...args: any[]) => {\n    if (isInNode) {\n      const functionPath = getCallerFunctionPath();\n      fn(functionPath, ...args);\n    } else {\n      fn(...args);\n    }\n  };\n}\n\n// console.assert not supported in WebBLE\nif (!__console.assert) {\n  const assert: AssertLogFunction = (condition, ...data) => {\n    if (!condition) {\n      __console.warn!(...data);\n    }\n  };\n  __console.assert = assert;\n}\n\n// console.table not supported in WebBLE\nif (!__console.table) {\n  const table: LogFunction = (...data) => {\n    __console.log!(...data);\n  };\n  __console.table = table;\n}\n\nfunction emptyFunction() {}\n\nconst log: LogFunction = isInNode\n  ? wrapWithLocation(__console.log!.bind(__console))\n  : __console.log!.bind(__console);\nconst warn: LogFunction = isInNode\n  ? wrapWithLocation(__console.warn!.bind(__console))\n  : __console.warn!.bind(__console);\nconst error: LogFunction = isInNode\n  ? wrapWithLocation(__console.error!.bind(__console))\n  : __console.error!.bind(__console);\nconst table: LogFunction = isInNode\n  ? wrapWithLocation(__console.table!.bind(__console))\n  : __console.table!.bind(__console);\nconst assert: AssertLogFunction = __console.assert.bind(__console);\n\nclass Console {\n  static #consoles: { [type: string]: Console } = {};\n\n  constructor(type: string) {\n    if (Console.#consoles[type]) {\n      throw new Error(`\"${type}\" console already exists`);\n    }\n    Console.#consoles[type] = this;\n  }\n\n  #levelFlags: ConsoleLevelFlags = {\n    log: isInDev,\n    warn: isInDev,\n    assert: true,\n    error: true,\n    table: true,\n  };\n\n  setLevelFlags(levelFlags: ConsoleLevelFlags) {\n    Object.assign(this.#levelFlags, levelFlags);\n  }\n\n  /** @throws {Error} if no console with type \"type\" is found */\n  static setLevelFlagsForType(type: string, levelFlags: ConsoleLevelFlags) {\n    if (!this.#consoles[type]) {\n      throw new Error(`no console found with type \"${type}\"`);\n    }\n    this.#consoles[type].setLevelFlags(levelFlags);\n  }\n\n  static setAllLevelFlags(levelFlags: ConsoleLevelFlags) {\n    for (const type in this.#consoles) {\n      this.#consoles[type].setLevelFlags(levelFlags);\n    }\n  }\n\n  static create(type: string, levelFlags?: ConsoleLevelFlags): Console {\n    const console = this.#consoles[type] || new Console(type);\n    if (isInDev && levelFlags) {\n      console.setLevelFlags(levelFlags);\n    }\n    return console;\n  }\n\n  get log() {\n    return this.#levelFlags.log ? log : emptyFunction;\n  }\n\n  get warn() {\n    return this.#levelFlags.warn ? warn : emptyFunction;\n  }\n\n  get error() {\n    return this.#levelFlags.error ? error : emptyFunction;\n  }\n\n  get assert() {\n    return this.#levelFlags.assert ? assert : emptyFunction;\n  }\n\n  get table() {\n    return this.#levelFlags.table ? table : emptyFunction;\n  }\n\n  /** @throws {Error} if condition is not met */\n  assertWithError(condition: any, message: string) {\n    if (!Boolean(condition)) {\n      throw new Error(message);\n    }\n  }\n\n  /** @throws {Error} if value's type doesn't match */\n  assertTypeWithError(value: any, type: string) {\n    this.assertWithError(\n      typeof value == type,\n      `value ${value} of type \"${typeof value}\" not of type \"${type}\"`\n    );\n  }\n\n  /** @throws {Error} if value's type doesn't match */\n  assertEnumWithError(value: string, enumeration: readonly string[]) {\n    this.assertWithError(\n      enumeration.includes(value),\n      `invalid enum \"${value}\"`\n    );\n  }\n\n  /** @throws {Error} if value is not within some range */\n  assertRangeWithError(name: string, value: number, min: number, max: number) {\n    this.assertWithError(\n      value >= min && value <= max,\n      `${name} ${value} must be within ${min}-${max}`\n    );\n  }\n}\n\nexport function createConsole(\n  type: string,\n  levelFlags?: ConsoleLevelFlags\n): Console {\n  return Console.create(type, levelFlags);\n}\n\n/** @throws {Error} if no console with type is found */\nexport function setConsoleLevelFlagsForType(\n  type: string,\n  levelFlags: ConsoleLevelFlags\n) {\n  Console.setLevelFlagsForType(type, levelFlags);\n}\n\nexport function setAllConsoleLevelFlags(levelFlags: ConsoleLevelFlags) {\n  Console.setAllLevelFlags(levelFlags);\n}\n","import { createConsole } from \"./Console.ts\";\nimport { deepEqual } from \"./ObjectUtils.ts\";\n\nconst _console = createConsole(\"EventDispatcher\", { log: false });\n\nexport type EventMap<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [T in keyof EventMessages]: {\n    type: T;\n    target: Target;\n    message: EventMessages[T];\n  };\n};\nexport type EventListenerMap<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [T in keyof EventMessages]: (event: {\n    type: T;\n    target: Target;\n    message: EventMessages[T];\n  }) => void;\n};\n\nexport type Event<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = EventMap<Target, EventType, EventMessages>[keyof EventMessages];\n\ntype SpecificEvent<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>,\n  SpecificEventType extends EventType\n> = {\n  type: SpecificEventType;\n  target: Target;\n  message: EventMessages[SpecificEventType];\n};\n\nexport type BoundEventListeners<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [SpecificEventType in keyof EventMessages]?: (\n    // @ts-expect-error\n    event: SpecificEvent<Target, EventType, EventMessages, SpecificEventType>\n  ) => void;\n};\n\nclass EventDispatcher<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> {\n  private listeners: {\n    [T in EventType]?: {\n      listener: (event: {\n        type: T;\n        target: Target;\n        message: EventMessages[T];\n      }) => void;\n      once?: boolean;\n      shouldRemove?: boolean;\n    }[];\n  } = {};\n\n  constructor(\n    private target: Target,\n    private validEventTypes: readonly EventType[]\n  ) {\n    this.addEventListener = this.addEventListener.bind(this);\n    this.removeEventListener = this.removeEventListener.bind(this);\n    this.removeEventListeners = this.removeEventListeners.bind(this);\n    this.removeAllEventListeners = this.removeAllEventListeners.bind(this);\n    this.dispatchEvent = this.dispatchEvent.bind(this);\n    this.waitForEvent = this.waitForEvent.bind(this);\n  }\n\n  private isValidEventType(type: any): type is EventType {\n    return this.validEventTypes.includes(type);\n  }\n\n  private updateEventListeners(type: EventType) {\n    if (!this.listeners[type]) return;\n    this.listeners[type] = this.listeners[type]!.filter((listenerObj) => {\n      if (listenerObj.shouldRemove) {\n        _console.log(`removing \"${type}\" eventListener`, listenerObj);\n      }\n      return !listenerObj.shouldRemove;\n    });\n  }\n\n  addEventListener<T extends EventType>(\n    type: T,\n    listener: (event: {\n      type: T;\n      target: Target;\n      message: EventMessages[T];\n    }) => void,\n    options: { once?: boolean } = { once: false }\n  ): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n      _console.log(`creating \"${type}\" listeners array`, this.listeners[type]!);\n    }\n    const alreadyAdded = this.listeners[type].find((listenerObject) => {\n      return (\n        listenerObject.listener == listener &&\n        listenerObject.once == options.once\n      );\n    });\n    if (alreadyAdded) {\n      _console.log(\"already added listener\");\n      return;\n    }\n    _console.log(`adding \"${type}\" listener`, listener, options);\n    this.listeners[type]!.push({ listener, once: options.once });\n\n    _console.log(\n      `currently have ${this.listeners[type]!.length} \"${type}\" listeners`\n    );\n  }\n\n  removeEventListener<T extends EventType>(\n    type: T,\n    listener: (event: {\n      type: T;\n      target: Target;\n      message: EventMessages[T];\n    }) => void\n  ): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    _console.log(`removing \"${type}\" listener...`, listener);\n    this.listeners[type]!.forEach((listenerObj) => {\n      const isListenerToRemove = listenerObj.listener === listener;\n      if (isListenerToRemove) {\n        _console.log(`flagging \"${type}\" listener`, listener);\n        listenerObj.shouldRemove = true;\n      }\n    });\n\n    this.updateEventListeners(type);\n  }\n\n  removeEventListeners<T extends EventType>(type: T): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    _console.log(`removing \"${type}\" listeners...`);\n    this.listeners[type] = [];\n  }\n\n  removeAllEventListeners(): void {\n    _console.log(`removing listeners...`);\n    this.listeners = {};\n  }\n\n  dispatchEvent<T extends EventType>(type: T, message: EventMessages[T]): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    this.listeners[type]!.forEach((listenerObj) => {\n      if (listenerObj.shouldRemove) {\n        return;\n      }\n\n      _console.log(`dispatching \"${type}\" listener`, listenerObj);\n      try {\n        listenerObj.listener({ type, target: this.target, message });\n      } catch (error) {\n        console.error(error);\n      }\n\n      if (listenerObj.once) {\n        _console.log(`flagging \"${type}\" listener`, listenerObj);\n        listenerObj.shouldRemove = true;\n      }\n    });\n    this.updateEventListeners(type);\n  }\n\n  waitForEvent<T extends EventType>(\n    type: T\n  ): Promise<{ type: T; target: Target; message: EventMessages[T] }> {\n    return new Promise((resolve) => {\n      const onceListener = (event: {\n        type: T;\n        target: Target;\n        message: EventMessages[T];\n      }) => {\n        resolve(event);\n      };\n\n      this.addEventListener(type, onceListener, { once: true });\n    });\n  }\n}\n\nexport default EventDispatcher;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"Timer\", { log: false });\n\nexport async function wait(delay: number) {\n  _console.log(`waiting for ${delay}ms`);\n  return new Promise((resolve: Function) => {\n    setTimeout(() => resolve(), delay);\n  });\n}\n\nclass Timer {\n  #callback!: Function;\n  get callback() {\n    return this.#callback;\n  }\n  set callback(newCallback) {\n    _console.assertTypeWithError(newCallback, \"function\");\n    _console.log({ newCallback });\n    this.#callback = newCallback;\n    if (this.isRunning) {\n      this.restart();\n    }\n  }\n\n  #interval!: number;\n  get interval() {\n    return this.#interval;\n  }\n  set interval(newInterval) {\n    _console.assertTypeWithError(newInterval, \"number\");\n    _console.assertWithError(newInterval > 0, \"interval must be above 0\");\n    _console.log({ newInterval });\n    this.#interval = newInterval;\n    if (this.isRunning) {\n      this.restart();\n    }\n  }\n\n  constructor(callback: Function, interval: number) {\n    this.interval = interval;\n    this.callback = callback;\n  }\n\n  #intervalId: number | undefined;\n  get isRunning() {\n    return this.#intervalId != undefined;\n  }\n\n  start(immediately = false) {\n    if (this.isRunning) {\n      _console.log(\"interval already running\");\n      return;\n    }\n    _console.log(`starting interval every ${this.#interval}ms`);\n    this.#intervalId = setInterval(this.#callback, this.#interval);\n    if (immediately) {\n      this.#callback();\n    }\n  }\n  stop() {\n    if (!this.isRunning) {\n      _console.log(\"interval already not running\");\n      return;\n    }\n    _console.log(\"stopping interval\");\n    clearInterval(this.#intervalId);\n    this.#intervalId = undefined;\n  }\n  restart(startImmediately = false) {\n    this.stop();\n    this.start(startImmediately);\n  }\n}\nexport default Timer;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"checksum\", { log: false });\n\n// https://github.com/googlecreativelab/tiny-motion-trainer/blob/5fceb49f018ae0c403bf9f0ccc437309c2acb507/frontend/src/tf4micro-motion-kit/modules/bleFileTransfer#L195\n\n// See http://home.thep.lu.se/~bjorn/crc/ for more information on simple CRC32 calculations.\nexport function crc32ForByte(r: number) {\n  for (let j = 0; j < 8; ++j) {\n    r = (r & 1 ? 0 : 0xedb88320) ^ (r >>> 1);\n  }\n  return r ^ 0xff000000;\n}\n\nconst tableSize = 256;\nconst crc32Table = new Uint32Array(tableSize);\nfor (let i = 0; i < tableSize; ++i) {\n  crc32Table[i] = crc32ForByte(i);\n}\n\nexport function crc32(dataIterable: ArrayBuffer | number[]) {\n  let dataBytes = new Uint8Array(dataIterable);\n  let crc = 0;\n  for (let i = 0; i < dataBytes.byteLength; ++i) {\n    const crcLowByte = crc & 0x000000ff;\n    const dataByte = dataBytes[i];\n    const tableIndex = crcLowByte ^ dataByte;\n    // The last >>> is to convert this into an unsigned 32-bit integer.\n    crc = (crc32Table[tableIndex] ^ (crc >>> 8)) >>> 0;\n  }\n  return crc;\n}\n\n// This is a small test function for the CRC32 implementation, not normally called but left in\n// for debugging purposes. We know the expected CRC32 of [97, 98, 99, 100, 101] is 2240272485,\n// or 0x8587d865, so if anything else is output we know there's an error in the implementation.\nexport function testCrc32() {\n  const testArray = [97, 98, 99, 100, 101];\n  const testArrayCrc32 = crc32(testArray);\n  _console.log(\"CRC32 for [97, 98, 99, 100, 101] is 0x\" + testArrayCrc32.toString(16) + \" (\" + testArrayCrc32 + \")\");\n}\n","var _TextEncoder;\nif (typeof TextEncoder == \"undefined\") {\n  _TextEncoder = class {\n    encode(string: string) {\n      const encoding = Array.from(string).map((char) => char.charCodeAt(0));\n      return Uint8Array.from(encoding);\n    }\n  };\n} else {\n  _TextEncoder = TextEncoder;\n}\n\nvar _TextDecoder;\nif (typeof TextDecoder == \"undefined\") {\n  _TextDecoder = class {\n    decode(data: ArrayBuffer) {\n      const byteArray = Array.from(new Uint8Array(data));\n      return byteArray\n        .map((value) => {\n          return String.fromCharCode(value);\n        })\n        .join(\"\");\n    }\n  };\n} else {\n  _TextDecoder = TextDecoder;\n}\n\nexport const textEncoder = new _TextEncoder();\nexport const textDecoder = new _TextDecoder();\n","import { createConsole } from \"./Console.ts\";\nimport { textEncoder } from \"./Text.ts\";\n\nconst _console = createConsole(\"ArrayBufferUtils\", { log: false });\n\nexport function concatenateArrayBuffers(...arrayBuffers: any[]): ArrayBuffer {\n  arrayBuffers = arrayBuffers.filter(\n    (arrayBuffer) => arrayBuffer != undefined || arrayBuffer != null\n  );\n  arrayBuffers = arrayBuffers.map((arrayBuffer) => {\n    if (typeof arrayBuffer == \"number\") {\n      const number = arrayBuffer;\n      return Uint8Array.from([Math.floor(number)]);\n    } else if (typeof arrayBuffer == \"boolean\") {\n      const boolean = arrayBuffer;\n      return Uint8Array.from([boolean ? 1 : 0]);\n    } else if (typeof arrayBuffer == \"string\") {\n      const string = arrayBuffer;\n      return stringToArrayBuffer(string);\n    } else if (arrayBuffer instanceof Array) {\n      const array = arrayBuffer;\n      return concatenateArrayBuffers(...array);\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      return arrayBuffer;\n    } else if (\n      \"buffer\" in arrayBuffer &&\n      arrayBuffer.buffer instanceof ArrayBuffer\n    ) {\n      const bufferContainer = arrayBuffer;\n      return bufferContainer.buffer;\n    } else if (arrayBuffer instanceof DataView) {\n      const dataView = arrayBuffer;\n      return dataView.buffer;\n    } else if (typeof arrayBuffer == \"object\") {\n      const object = arrayBuffer;\n      return objectToArrayBuffer(object);\n    } else {\n      return arrayBuffer;\n    }\n  });\n  arrayBuffers = arrayBuffers.filter(\n    (arrayBuffer) => arrayBuffer && \"byteLength\" in arrayBuffer\n  );\n  const length = arrayBuffers.reduce(\n    (length, arrayBuffer) => length + arrayBuffer.byteLength,\n    0\n  );\n  const uint8Array = new Uint8Array(length);\n  let byteOffset = 0;\n  arrayBuffers.forEach((arrayBuffer) => {\n    uint8Array.set(new Uint8Array(arrayBuffer), byteOffset);\n    byteOffset += arrayBuffer.byteLength;\n  });\n  return uint8Array.buffer;\n}\n\nexport function dataToArrayBuffer(data: Buffer) {\n  return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n}\n\nexport function stringToArrayBuffer(string: string) {\n  const encoding = textEncoder.encode(string);\n  return concatenateArrayBuffers(encoding.byteLength, encoding);\n}\n\nexport function objectToArrayBuffer(object: object) {\n  return stringToArrayBuffer(JSON.stringify(object));\n}\n\nexport function sliceDataView(\n  dataView: DataView,\n  begin: number,\n  length?: number\n) {\n  let end;\n  if (length != undefined) {\n    end = dataView.byteOffset + begin + length;\n  }\n  _console.log({ dataView, begin, end, length });\n  return new DataView(dataView.buffer.slice(dataView.byteOffset + begin, end));\n}\n\nexport type FileLike = number[] | ArrayBuffer | DataView | URL | string | File;\n\nexport async function getFileBuffer(file: FileLike) {\n  let fileBuffer;\n  if (file instanceof Array) {\n    fileBuffer = Uint8Array.from(file);\n  } else if (file instanceof DataView) {\n    fileBuffer = file.buffer;\n  } else if (typeof file == \"string\" || file instanceof URL) {\n    const response = await fetch(file);\n    fileBuffer = await response.arrayBuffer();\n  } else if (file instanceof File) {\n    fileBuffer = await file.arrayBuffer();\n  } else if (file instanceof ArrayBuffer) {\n    fileBuffer = file;\n  } else {\n    throw { error: \"invalid file type\", file };\n  }\n  return fileBuffer;\n}\n\nexport function UInt8ByteBuffer(value: number) {\n  return Uint8Array.from([value]).buffer;\n}\n","// Gets all non-builtin properties up the prototype chain.\nconst getAllProperties = object => {\n\tconst properties = new Set();\n\n\tdo {\n\t\tfor (const key of Reflect.ownKeys(object)) {\n\t\t\tproperties.add([object, key]);\n\t\t}\n\t} while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);\n\n\treturn properties;\n};\n\nexport default function autoBind(self, {include, exclude} = {}) {\n\tconst filter = key => {\n\t\tconst match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\n\t\tif (include) {\n\t\t\treturn include.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\tif (exclude) {\n\t\t\treturn !exclude.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tfor (const [object, key] of getAllProperties(self.constructor.prototype)) {\n\t\tif (key === 'constructor' || !filter(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(object, key);\n\t\tif (descriptor && typeof descriptor.value === 'function') {\n\t\t\tself[key] = self[key].bind(self);\n\t\t}\n\t}\n\n\treturn self;\n}\n","import { createConsole } from \"./utils/Console.ts\";\nimport { crc32 } from \"./utils/checksum.ts\";\nimport { getFileBuffer, UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { FileLike } from \"./utils/ArrayBufferUtils.ts\";\nimport Device, { SendMessageCallback } from \"./Device.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"FileTransferManager\", { log: true });\n\nexport const FileTransferMessageTypes = [\n  \"getFileTypes\",\n  \"maxFileLength\",\n  \"getFileType\",\n  \"setFileType\",\n  \"getFileLength\",\n  \"setFileLength\",\n  \"getFileChecksum\",\n  \"setFileChecksum\",\n  \"setFileTransferCommand\",\n  \"fileTransferStatus\",\n  \"getFileBlock\",\n  \"setFileBlock\",\n  \"fileBytesTransferred\",\n] as const;\nexport type FileTransferMessageType = (typeof FileTransferMessageTypes)[number];\n\nexport const FileTypes = [\n  \"tflite\",\n  \"wifiServerCert\",\n  \"wifiServerKey\",\n  \"spriteSheet\",\n] as const;\nexport type FileType = (typeof FileTypes)[number];\n\nexport const FileTransferStatuses = [\"idle\", \"sending\", \"receiving\"] as const;\nexport type FileTransferStatus = (typeof FileTransferStatuses)[number];\n\nexport const FileTransferCommands = [\n  \"startSend\",\n  \"startReceive\",\n  \"cancel\",\n] as const;\nexport type FileTransferCommand = (typeof FileTransferCommands)[number];\n\nexport const FileTransferDirections = [\"sending\", \"receiving\"] as const;\nexport type FileTransferDirection = (typeof FileTransferDirections)[number];\n\nexport const FileTransferEventTypes = [\n  ...FileTransferMessageTypes,\n  \"fileTransferProgress\",\n  \"fileTransferComplete\",\n  \"fileReceived\",\n] as const;\nexport type FileTransferEventType = (typeof FileTransferEventTypes)[number];\n\nexport const RequiredFileTransferMessageTypes: FileTransferMessageType[] = [\n  \"maxFileLength\",\n  \"getFileLength\",\n  \"getFileChecksum\",\n  \"getFileType\",\n  \"fileTransferStatus\",\n];\n\nexport interface FileConfiguration {\n  file: FileLike;\n  type: FileType;\n}\n\nexport interface FileTransferEventMessages {\n  getFileTypes: { fileTypes: FileType[] };\n  maxFileLength: { maxFileLength: number };\n  getFileType: { fileType: FileType };\n  getFileLength: { fileLength: number };\n  getFileChecksum: { fileChecksum: number };\n  fileTransferStatus: {\n    fileType: FileType;\n    fileTransferStatus: FileTransferStatus;\n  };\n  getFileBlock: { fileTransferBlock: DataView };\n  fileTransferProgress: { fileType: FileType; progress: number };\n  fileTransferComplete: {\n    fileType: FileType;\n    direction: FileTransferDirection;\n  };\n  fileReceived: { fileType: FileType; file: File | Blob };\n}\n\nexport type FileTransferEventDispatcher = EventDispatcher<\n  Device,\n  FileTransferEventType,\n  FileTransferEventMessages\n>;\nexport type SendFileTransferMessageCallback =\n  SendMessageCallback<FileTransferMessageType>;\n\nexport type SendFileCallback = (\n  type: FileType,\n  file: FileLike,\n  override?: boolean\n) => Promise<boolean>;\n\nclass FileTransferManager {\n  constructor() {\n    autoBind(this);\n  }\n  sendMessage!: SendFileTransferMessageCallback;\n\n  eventDispatcher!: FileTransferEventDispatcher;\n  get addEventListener() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  #assertValidType(type: FileType) {\n    _console.assertEnumWithError(type, FileTypes);\n  }\n  #isValidType(type: FileType) {\n    return FileTypes.includes(type);\n  }\n  #assertValidTypeEnum(typeEnum: number) {\n    _console.assertWithError(\n      typeEnum in FileTypes,\n      `invalid typeEnum ${typeEnum}`\n    );\n  }\n\n  #assertValidStatusEnum(statusEnum: number) {\n    _console.assertWithError(\n      statusEnum in FileTransferStatuses,\n      `invalid statusEnum ${statusEnum}`\n    );\n  }\n  #assertValidCommand(command: FileTransferCommand) {\n    _console.assertEnumWithError(command, FileTransferCommands);\n  }\n\n  #fileTypes: FileType[] = [];\n  get fileTypes() {\n    return this.#fileTypes;\n  }\n  #parseFileTypes(dataView: DataView) {\n    const fileTypes = Array.from(new Uint8Array(dataView.buffer))\n      .map((index) => FileTypes[index])\n      .filter(Boolean);\n    this.#fileTypes = fileTypes;\n    _console.log(\"fileTypes\", fileTypes);\n    this.#dispatchEvent(\"getFileTypes\", {\n      fileTypes: this.#fileTypes,\n    });\n  }\n\n  static #MaxLength = 0; // kB\n  static get MaxLength() {\n    return this.#MaxLength;\n  }\n  #maxLength = FileTransferManager.MaxLength;\n  /** kB */\n  get maxLength() {\n    return this.#maxLength;\n  }\n  #parseMaxLength(dataView: DataView) {\n    _console.log(\"parseFileMaxLength\", dataView);\n    const maxLength = dataView.getUint32(0, true);\n    _console.log(`maxLength: ${maxLength / 1024}kB`);\n    this.#updateMaxLength(maxLength);\n  }\n  #updateMaxLength(maxLength: number) {\n    _console.log({ maxLength });\n    this.#maxLength = maxLength;\n    this.#dispatchEvent(\"maxFileLength\", { maxFileLength: maxLength });\n  }\n  #assertValidLength(length: number) {\n    _console.assertWithError(\n      length <= this.maxLength,\n      `file length ${length}kB too large - must be ${this.maxLength}kB or less`\n    );\n  }\n\n  #type: FileType | undefined;\n  get type() {\n    return this.#type;\n  }\n  #parseType(dataView: DataView) {\n    _console.log(\"parseFileType\", dataView);\n    const typeEnum = dataView.getUint8(0);\n    this.#assertValidTypeEnum(typeEnum);\n    const type = FileTypes[typeEnum];\n    this.#updateType(type);\n  }\n  #updateType(type: FileType) {\n    _console.log({ fileTransferType: type });\n    this.#type = type;\n    this.#dispatchEvent(\"getFileType\", { fileType: type });\n  }\n  async #setType(newType: FileType, sendImmediately?: boolean) {\n    this.#assertValidType(newType);\n    if (this.type == newType) {\n      _console.log(`redundant type assignment ${newType}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getFileType\");\n\n    const typeEnum = FileTypes.indexOf(newType);\n\n    this.sendMessage(\n      [{ type: \"setFileType\", data: UInt8ByteBuffer(typeEnum) }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #length = 0;\n  get length() {\n    return this.#length;\n  }\n  #parseLength(dataView: DataView) {\n    _console.log(\"parseFileLength\", dataView);\n    const length = dataView.getUint32(0, true);\n\n    this.#updateLength(length);\n  }\n  #updateLength(length: number) {\n    _console.log(`length: ${length / 1024}kB`);\n    this.#length = length;\n    this.#dispatchEvent(\"getFileLength\", { fileLength: length });\n  }\n  async #setLength(newLength: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newLength, \"number\");\n    this.#assertValidLength(newLength);\n    if (this.length == newLength) {\n      _console.log(`redundant length assignment ${newLength}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getFileLength\");\n\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setUint32(0, newLength, true);\n    this.sendMessage(\n      [{ type: \"setFileLength\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #checksum = 0;\n  get checksum() {\n    return this.#checksum;\n  }\n  #parseChecksum(dataView: DataView) {\n    _console.log(\"checksum\", dataView);\n    const checksum = dataView.getUint32(0, true);\n    this.#updateChecksum(checksum);\n  }\n  #updateChecksum(checksum: number) {\n    _console.log({ checksum });\n    this.#checksum = checksum;\n    this.#dispatchEvent(\"getFileChecksum\", { fileChecksum: checksum });\n  }\n  async #setChecksum(newChecksum: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newChecksum, \"number\");\n    if (this.checksum == newChecksum) {\n      _console.log(`redundant checksum assignment ${newChecksum}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getFileChecksum\");\n\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setUint32(0, newChecksum, true);\n    this.sendMessage(\n      [{ type: \"setFileChecksum\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  async #setCommand(command: FileTransferCommand, sendImmediately?: boolean) {\n    this.#assertValidCommand(command);\n\n    const promise = this.waitForEvent(\"fileTransferStatus\");\n    _console.log(`setting command ${command}`);\n    const commandEnum = FileTransferCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"setFileTransferCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #status: FileTransferStatus = \"idle\";\n  get status() {\n    return this.#status;\n  }\n  #parseStatus(dataView: DataView) {\n    _console.log(\"parseFileStatus\", dataView);\n    const statusEnum = dataView.getUint8(0);\n    this.#assertValidStatusEnum(statusEnum);\n    const status = FileTransferStatuses[statusEnum];\n    this.#updateStatus(status);\n  }\n  #updateStatus(status: FileTransferStatus) {\n    _console.log({ status });\n    this.#status = status;\n    this.#receivedBlocks.length = 0;\n    this.#isCancelling = false;\n    this.#buffer = undefined;\n    this.#bytesTransferred = 0;\n    this.#dispatchEvent(\"fileTransferStatus\", {\n      fileTransferStatus: status,\n      fileType: this.type!,\n    });\n  }\n  #assertIsIdle() {\n    _console.assertWithError(this.#status == \"idle\", \"status is not idle\");\n  }\n  #assertIsNotIdle() {\n    _console.assertWithError(this.#status != \"idle\", \"status is idle\");\n  }\n\n  // BLOCK\n\n  #receivedBlocks: ArrayBuffer[] = [];\n\n  async #parseBlock(dataView: DataView) {\n    _console.log(\"parseFileBlock\", dataView);\n    this.#receivedBlocks.push(dataView.buffer);\n\n    const bytesReceived = this.#receivedBlocks.reduce(\n      (sum, arrayBuffer) => (sum += arrayBuffer.byteLength),\n      0\n    );\n    const progress = bytesReceived / this.#length;\n\n    _console.log(\n      `received ${bytesReceived} of ${this.#length} bytes (${progress * 100}%)`\n    );\n\n    this.#dispatchEvent(\"fileTransferProgress\", {\n      progress,\n      fileType: this.type!,\n    });\n\n    if (bytesReceived != this.#length) {\n      const dataView = new DataView(new ArrayBuffer(4));\n      dataView.setUint32(0, bytesReceived, true);\n\n      if (this.isServerSide) {\n        return;\n      }\n      await this.sendMessage([\n        { type: \"fileBytesTransferred\", data: dataView.buffer },\n      ]);\n      return;\n    }\n\n    _console.log(\"file transfer complete\");\n\n    let fileName = new Date().toLocaleString();\n    switch (this.type) {\n      case \"tflite\":\n        fileName += \".tflite\";\n        break;\n      case \"wifiServerCert\":\n        fileName += \"_server.crt\";\n        break;\n      case \"wifiServerKey\":\n        fileName += \"_server.key\";\n        break;\n    }\n\n    let file: File | Blob;\n    if (typeof File !== \"undefined\") {\n      file = new File(this.#receivedBlocks, fileName);\n    } else {\n      file = new Blob(this.#receivedBlocks);\n    }\n\n    const arrayBuffer = await file.arrayBuffer();\n    const checksum = crc32(arrayBuffer);\n    _console.log({ checksum });\n\n    if (checksum != this.#checksum) {\n      _console.error(\n        `wrong checksum - expected ${this.#checksum}, got ${checksum}`\n      );\n      return;\n    }\n\n    _console.log(\"received file\", file);\n\n    this.#dispatchEvent(\"getFileBlock\", { fileTransferBlock: dataView });\n    this.#dispatchEvent(\"fileTransferComplete\", {\n      direction: \"receiving\",\n      fileType: this.type!,\n    });\n    this.#dispatchEvent(\"fileReceived\", { file, fileType: this.type! });\n  }\n\n  parseMessage(messageType: FileTransferMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getFileTypes\":\n        this.#parseFileTypes(dataView);\n        break;\n      case \"maxFileLength\":\n        this.#parseMaxLength(dataView);\n        break;\n      case \"getFileType\":\n      case \"setFileType\":\n        this.#parseType(dataView);\n        break;\n      case \"getFileLength\":\n      case \"setFileLength\":\n        this.#parseLength(dataView);\n        break;\n      case \"getFileChecksum\":\n      case \"setFileChecksum\":\n        this.#parseChecksum(dataView);\n        break;\n      case \"fileTransferStatus\":\n        this.#parseStatus(dataView);\n        break;\n      case \"getFileBlock\":\n        this.#parseBlock(dataView);\n        break;\n      case \"fileBytesTransferred\":\n        this.#parseBytesTransferred(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  async send(type: FileType, file: FileLike, override?: boolean) {\n    if (true) {\n      this.#assertIsIdle();\n      this.#assertValidType(type);\n    } else {\n      if (this.status != \"idle\") {\n        _console.warn(`cannot send file - status is ${this.status}`);\n        return false;\n      }\n      if (!this.#isValidType(type)) {\n        _console.warn(`invalid fileType ${type}`);\n        return false;\n      }\n    }\n\n    const fileBuffer = await getFileBuffer(file);\n    const fileLength = fileBuffer.byteLength;\n    const checksum = crc32(fileBuffer);\n    this.#assertValidLength(fileLength);\n\n    if (!override) {\n      if (type != this.type) {\n        _console.log(\"different fileTypes - sending\");\n      } else if (fileLength != this.length) {\n        _console.log(\"different fileLengths - sending\");\n      } else if (checksum != this.checksum) {\n        _console.log(\"different fileChecksums - sending\");\n      } else {\n        _console.log(\"already sent file\");\n        return false;\n      }\n    }\n\n    const promises: Promise<any>[] = [];\n\n    promises.push(this.#setType(type, false));\n    promises.push(this.#setLength(fileLength, false));\n    promises.push(this.#setChecksum(checksum, false));\n    promises.push(this.#setCommand(\"startSend\", false));\n\n    this.sendMessage();\n\n    await Promise.all(promises);\n\n    if (this.#buffer) {\n      return false;\n    }\n    if (this.#length != fileLength) {\n      return false;\n    }\n    if (this.#checksum != checksum) {\n      return false;\n    }\n\n    await this.#send(fileBuffer);\n\n    return true;\n  }\n\n  #buffer?: ArrayBuffer;\n  #bytesTransferred = 0;\n  async #send(buffer: ArrayBuffer) {\n    this.#buffer = buffer;\n    return this.#sendBlock();\n  }\n\n  mtu!: number;\n  async #sendBlock(): Promise<void> {\n    if (this.status != \"sending\") {\n      return;\n    }\n    if (this.#isCancelling) {\n      _console.error(\"not sending block - busy cancelling\");\n      return;\n    }\n    if (!this.#buffer) {\n      if (!this.isServerSide) {\n        _console.error(\"no buffer defined\");\n      }\n      return;\n    }\n\n    const buffer = this.#buffer;\n    let offset = this.#bytesTransferred;\n\n    const slicedBuffer = buffer.slice(offset, offset + (this.mtu - 3 - 3));\n    _console.log(\"slicedBuffer\", slicedBuffer);\n    const bytesLeft = buffer.byteLength - offset;\n\n    const progress = 1 - bytesLeft / buffer.byteLength;\n    _console.log(\n      `sending bytes ${offset}-${offset + slicedBuffer.byteLength} of ${\n        buffer.byteLength\n      } bytes (${progress * 100}%)`\n    );\n    this.#dispatchEvent(\"fileTransferProgress\", {\n      progress,\n      fileType: this.type!,\n    });\n    if (slicedBuffer.byteLength == 0) {\n      _console.log(\"finished sending buffer\");\n      this.#dispatchEvent(\"fileTransferComplete\", {\n        direction: \"sending\",\n        fileType: this.type!,\n      });\n    } else {\n      await this.sendMessage([{ type: \"setFileBlock\", data: slicedBuffer }]);\n      this.#bytesTransferred = offset + slicedBuffer.byteLength;\n      //return this.#sendBlock(buffer, offset + slicedBuffer.byteLength);\n    }\n  }\n\n  async #parseBytesTransferred(dataView: DataView) {\n    _console.log(\"parseBytesTransferred\", dataView);\n    const bytesTransferred = dataView.getUint32(0, true);\n    _console.log({ bytesTransferred });\n    if (this.status != \"sending\") {\n      _console.error(`not currently sending file`);\n      return;\n    }\n    if (!this.isServerSide && this.#bytesTransferred != bytesTransferred) {\n      _console.error(\n        `bytesTransferred are not equal - got ${bytesTransferred}, expected ${\n          this.#bytesTransferred\n        }`\n      );\n      this.cancel();\n      return;\n    }\n    this.#sendBlock();\n  }\n\n  async receive(type: FileType) {\n    this.#assertIsIdle();\n\n    this.#assertValidType(type);\n\n    await this.#setType(type);\n    await this.#setCommand(\"startReceive\");\n  }\n\n  #isCancelling = false;\n  async cancel() {\n    this.#assertIsNotIdle();\n    _console.log(\"cancelling file transfer...\");\n    this.#isCancelling = true;\n    await this.#setCommand(\"cancel\");\n  }\n\n  // SERVER SIDE\n  #isServerSide = false;\n  get isServerSide() {\n    return this.#isServerSide;\n  }\n  set isServerSide(newIsServerSide) {\n    if (this.#isServerSide == newIsServerSide) {\n      _console.log(\"redundant isServerSide assignment\");\n      return;\n    }\n    _console.log({ newIsServerSide });\n    this.#isServerSide = newIsServerSide;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required fileTransfer information\");\n    const messages = RequiredFileTransferMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  clear() {\n    this.#status = \"idle\";\n  }\n}\n\nexport default FileTransferManager;\n","import { PressureSensorPosition } from \"../sensor/PressureSensorDataManager.ts\";\nimport { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"MathUtils\", { log: false });\n\nexport function getInterpolation(\n  value: number,\n  min: number,\n  max: number,\n  span: number\n) {\n  if (span == undefined) {\n    span = max - min;\n  }\n  return (value - min) / span;\n}\n\nexport const Uint16Max = 2 ** 16;\nexport const Int16Max = 2 ** 15;\nexport const Int16Min = -(2 ** 15) - 1;\n\nfunction removeLower2Bytes(number: number) {\n  const lower2Bytes = number % Uint16Max;\n  return number - lower2Bytes;\n}\n\nconst timestampThreshold = 60_000;\n\nexport function parseTimestamp(dataView: DataView, byteOffset: number) {\n  const now = Date.now();\n  const nowWithoutLower2Bytes = removeLower2Bytes(now);\n  const lower2Bytes = dataView.getUint16(byteOffset, true);\n  let timestamp = nowWithoutLower2Bytes + lower2Bytes;\n  if (Math.abs(now - timestamp) > timestampThreshold) {\n    _console.log(\"correcting timestamp delta\");\n    timestamp += Uint16Max * Math.sign(now - timestamp);\n  }\n  return timestamp;\n}\n\nexport interface Vector2 {\n  x: number;\n  y: number;\n}\n\nexport function getVector2Length(vector: Vector2) {\n  const { x, y } = vector;\n  return Math.sqrt(x ** 2 + y ** 2);\n}\n\nexport function getVector2Angle(vector: Vector2) {\n  const { x, y } = vector;\n  return Math.atan2(y, x);\n}\n\nexport function multiplyVector2ByScalar(\n  vector: Vector2,\n  scalar: number\n): Vector2 {\n  let { x, y } = vector;\n  x *= scalar;\n  y *= scalar;\n  return { x, y };\n}\nexport function normalizedVector2(vector: Vector2): Vector2 {\n  return multiplyVector2ByScalar(vector, 1 / getVector2Length(vector));\n}\n\nexport interface Vector3 extends Vector2 {\n  z: number;\n}\n\nexport interface Quaternion {\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\nexport interface Euler {\n  heading: number;\n  pitch: number;\n  roll: number;\n}\n\nexport function computeVoronoiWeights(\n  points: PressureSensorPosition[],\n  sampleCount = 100000\n) {\n  const n = points.length;\n  const counts = new Array(n).fill(0);\n\n  for (let i = 0; i < sampleCount; i++) {\n    const x = Math.random();\n    const y = Math.random();\n\n    // Find the closest input point\n    let minDist = Infinity;\n    let closestIndex = -1;\n\n    for (let j = 0; j < n; j++) {\n      const { x: px, y: py } = points[j];\n      const dist = (px - x) ** 2 + (py - y) ** 2; // Squared Euclidean distance\n      if (dist < minDist) {\n        minDist = dist;\n        closestIndex = j;\n      }\n    }\n\n    // Increment count for the closest point\n    counts[closestIndex]++;\n  }\n\n  // Convert counts to weights (sum to 1)\n  return counts.map((c) => c / sampleCount);\n}\n\nexport function getVector3Length(vector: Vector3) {\n  const { x, y, z } = vector;\n  return Math.sqrt(x ** 2 + y ** 2 + z ** 2);\n}\n\nexport function clamp(value: number, min: number = 0, max: number = 1) {\n  return Math.min(Math.max(value, min), max);\n}\n\nexport function degToRad(deg: number) {\n  return deg * (Math.PI / 180);\n}\n\nexport function radToDeg(rad: number) {\n  return rad * (180 / Math.PI);\n}\n\nexport const twoPi = Math.PI * 2;\nexport function normalizeRadians(rad: number): number {\n  return ((rad % twoPi) + twoPi) % twoPi;\n}\n","import { getInterpolation } from \"./MathUtils.ts\";\n\ninterface Range {\n  min: number;\n  max: number;\n  span: number;\n}\n\nconst initialRange: Range = { min: Infinity, max: -Infinity, span: 0 };\n\nclass RangeHelper {\n  #range: Range = Object.assign({}, initialRange);\n  get min() {\n    return this.#range.min;\n  }\n  get max() {\n    return this.#range.max;\n  }\n\n  set min(newMin) {\n    this.#range.min = newMin;\n    this.#range.max = Math.max(newMin, this.#range.max);\n    this.#updateSpan();\n  }\n  set max(newMax) {\n    this.#range.max = newMax;\n    this.#range.min = Math.min(newMax, this.#range.min);\n    this.#updateSpan();\n  }\n\n  #updateSpan() {\n    this.#range.span = this.#range.max - this.#range.min;\n  }\n\n  reset() {\n    Object.assign(this.#range, initialRange);\n  }\n\n  update(value: number) {\n    this.#range.min = Math.min(value, this.#range.min);\n    this.#range.max = Math.max(value, this.#range.max);\n    this.#updateSpan();\n  }\n\n  getNormalization(value: number, weightByRange: boolean) {\n    let normalization = getInterpolation(value, this.#range.min, this.#range.max, this.#range.span);\n    if (weightByRange) {\n      normalization *= this.#range.span;\n    }\n    return normalization || 0;\n  }\n\n  updateAndGetNormalization(value: number, weightByRange: boolean) {\n    this.update(value);\n    return this.getNormalization(value, weightByRange);\n  }\n}\n\nexport default RangeHelper;\n","import RangeHelper from \"./RangeHelper.ts\";\n\nimport { Vector2 } from \"./MathUtils.ts\";\n\nexport type CenterOfPressure = Vector2;\n\nexport interface CenterOfPressureRange {\n  x: RangeHelper;\n  y: RangeHelper;\n}\n\nclass CenterOfPressureHelper {\n  #range: CenterOfPressureRange = {\n    x: new RangeHelper(),\n    y: new RangeHelper(),\n  };\n  reset() {\n    this.#range.x.reset();\n    this.#range.y.reset();\n  }\n\n  update(centerOfPressure: CenterOfPressure) {\n    this.#range.x.update(centerOfPressure.x);\n    this.#range.y.update(centerOfPressure.y);\n  }\n  getNormalization(centerOfPressure: CenterOfPressure, weightByRange: boolean): CenterOfPressure {\n    return {\n      x: this.#range.x.getNormalization(centerOfPressure.x, weightByRange),\n      y: this.#range.y.getNormalization(centerOfPressure.y, weightByRange),\n    };\n  }\n\n  updateAndGetNormalization(centerOfPressure: CenterOfPressure, weightByRange: boolean) {\n    this.update(centerOfPressure);\n    return this.getNormalization(centerOfPressure, weightByRange);\n  }\n}\n\nexport default CenterOfPressureHelper;\n","export function createArray(arrayLength: number, objectOrCallback: ((index: number) => any) | object) {\n  return new Array(arrayLength).fill(1).map((_, index) => {\n    if (typeof objectOrCallback == \"function\") {\n      const callback = objectOrCallback;\n      return callback(index);\n    } else {\n      const object = objectOrCallback;\n      return Object.assign({}, object);\n    }\n  });\n}\n\nexport function arrayWithoutDuplicates(array: any[]) {\n  return array.filter((value, index) => array.indexOf(value) == index);\n}\n","import { createConsole } from \"../utils/Console.ts\";\nimport CenterOfPressureHelper from \"../utils/CenterOfPressureHelper.ts\";\nimport RangeHelper from \"../utils/RangeHelper.ts\";\nimport { createArray } from \"../utils/ArrayUtils.ts\";\n\nconst _console = createConsole(\"PressureDataManager\", { log: false });\n\nexport const PressureSensorTypes = [\"pressure\"] as const;\nexport type PressureSensorType = (typeof PressureSensorTypes)[number];\n\nexport const ContinuousPressureSensorTypes = PressureSensorTypes;\nexport type ContinuousPressureSensorType =\n  (typeof ContinuousPressureSensorTypes)[number];\n\nimport { computeVoronoiWeights, Vector2 } from \"../utils/MathUtils.ts\";\nexport type PressureSensorPosition = Vector2;\n\nimport { CenterOfPressure } from \"../utils/CenterOfPressureHelper.ts\";\n\nexport interface PressureSensorValue {\n  position: PressureSensorPosition;\n  rawValue: number;\n  scaledValue: number;\n  normalizedValue: number;\n  weightedValue: number;\n}\n\nexport interface PressureData {\n  sensors: PressureSensorValue[];\n  scaledSum: number;\n  normalizedSum: number;\n  center?: CenterOfPressure;\n  normalizedCenter?: CenterOfPressure;\n}\n\nexport interface PressureDataEventMessages {\n  pressure: { pressure: PressureData };\n}\n\nexport const DefaultNumberOfPressureSensors = 8;\n\nclass PressureSensorDataManager {\n  #positions: PressureSensorPosition[] = [];\n  get positions() {\n    return this.#positions;\n  }\n\n  get numberOfSensors() {\n    return this.positions.length;\n  }\n\n  parsePositions(dataView: DataView) {\n    const positions: PressureSensorPosition[] = [];\n\n    for (\n      let pressureSensorIndex = 0, byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      pressureSensorIndex++, byteOffset += 2\n    ) {\n      positions.push({\n        x: dataView.getUint8(byteOffset) / 2 ** 8,\n        y: dataView.getUint8(byteOffset + 1) / 2 ** 8,\n      });\n    }\n\n    _console.log({ positions });\n\n    this.#positions = positions;\n\n    this.#sensorRangeHelpers = createArray(\n      this.numberOfSensors,\n      () => new RangeHelper()\n    );\n\n    this.resetRange();\n  }\n\n  #sensorRangeHelpers!: RangeHelper[];\n  #normalizedSumRangeHelper = new RangeHelper();\n\n  #centerOfPressureHelper = new CenterOfPressureHelper();\n\n  resetRange() {\n    this.#sensorRangeHelpers?.forEach((rangeHelper) => rangeHelper.reset());\n    this.#centerOfPressureHelper.reset();\n    this.#normalizedSumRangeHelper.reset();\n  }\n\n  parseData(dataView: DataView, scalar: number) {\n    const pressure: PressureData = {\n      sensors: [],\n      scaledSum: 0,\n      normalizedSum: 0,\n    };\n    for (\n      let index = 0, byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      index++, byteOffset += 2\n    ) {\n      const rawValue = dataView.getUint16(byteOffset, true);\n      let scaledValue = (rawValue * scalar) / this.numberOfSensors;\n      const rangeHelper = this.#sensorRangeHelpers[index];\n      const normalizedValue = rangeHelper.updateAndGetNormalization(\n        scaledValue,\n        false\n      );\n      //scaledValue -= rangeHelper.min;\n\n      const position = this.positions[index];\n      pressure.sensors[index] = {\n        rawValue,\n        scaledValue,\n        normalizedValue,\n        position,\n        weightedValue: 0,\n      };\n\n      pressure.scaledSum += scaledValue;\n      //pressure.normalizedSum += normalizedValue;\n    }\n    pressure.normalizedSum =\n      this.#normalizedSumRangeHelper.updateAndGetNormalization(\n        pressure.scaledSum,\n        false\n      );\n\n    if (pressure.scaledSum > 0) {\n      pressure.center = { x: 0, y: 0 };\n      pressure.sensors.forEach((sensor) => {\n        sensor.weightedValue = sensor.scaledValue / pressure.scaledSum;\n        pressure.center!.x += sensor.position.x * sensor.weightedValue;\n        pressure.center!.y += sensor.position.y * sensor.weightedValue;\n      });\n      pressure.normalizedCenter =\n        this.#centerOfPressureHelper.updateAndGetNormalization(\n          pressure.center,\n          false\n        );\n    }\n\n    _console.log({ pressure });\n    return pressure;\n  }\n}\n\nexport default PressureSensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\n\nconst _console = createConsole(\"MotionSensorDataManager\", { log: false });\n\nexport const MotionSensorTypes = [\n  \"acceleration\",\n  \"gravity\",\n  \"linearAcceleration\",\n  \"gyroscope\",\n  \"magnetometer\",\n  \"gameRotation\",\n  \"rotation\",\n  \"orientation\",\n  \"activity\",\n  \"stepCounter\",\n  \"stepDetector\",\n  \"deviceOrientation\",\n  \"tapDetector\",\n] as const;\nexport type MotionSensorType = (typeof MotionSensorTypes)[number];\n\nexport const ContinuousMotionTypes = [\n  \"acceleration\",\n  \"gravity\",\n  \"linearAcceleration\",\n  \"gyroscope\",\n  \"magnetometer\",\n  \"gameRotation\",\n  \"rotation\",\n  \"orientation\",\n] as const;\nexport type ContinuousMotionType = (typeof ContinuousMotionTypes)[number];\n\nimport { Vector3, Quaternion, Euler } from \"../utils/MathUtils.ts\";\nimport { ValueOf } from \"../utils/TypeScriptUtils.ts\";\n\nexport const Vector2Size = 2 * 2;\nexport const Vector3Size = 3 * 2;\nexport const QuaternionSize = 4 * 2;\n\nexport const ActivityTypes = [\n  \"still\",\n  \"walking\",\n  \"running\",\n  \"bicycle\",\n  \"vehicle\",\n  \"tilting\",\n] as const;\nexport type ActivityType = (typeof ActivityTypes)[number];\n\nexport interface Activity {\n  still: boolean;\n  walking: boolean;\n  running: boolean;\n  bicycle: boolean;\n  vehicle: boolean;\n  tilting: boolean;\n}\n\nexport const DeviceOrientations = [\n  \"portraitUpright\",\n  \"landscapeLeft\",\n  \"portraitUpsideDown\",\n  \"landscapeRight\",\n  \"unknown\",\n] as const;\nexport type DeviceOrientation = (typeof DeviceOrientations)[number];\n\nexport interface MotionSensorDataEventMessages {\n  acceleration: { acceleration: Vector3 };\n  gravity: { gravity: Vector3 };\n  linearAcceleration: { linearAcceleration: Vector3 };\n  gyroscope: { gyroscope: Vector3 };\n  magnetometer: { magnetometer: Vector3 };\n  gameRotation: { gameRotation: Quaternion };\n  rotation: { rotation: Quaternion };\n  orientation: { orientation: Euler };\n  stepDetector: { stepDetector: Object };\n  stepCounter: { stepCounter: number };\n  activity: { activity: Activity };\n  deviceOrientation: { deviceOrientation: DeviceOrientation };\n  tapDetector: { tapDetector: Object };\n}\n\nexport type MotionSensorDataEventMessage =\n  ValueOf<MotionSensorDataEventMessages>;\n\nclass MotionSensorDataManager {\n  parseVector3(dataView: DataView, scalar: number): Vector3 {\n    let [x, y, z] = [\n      dataView.getInt16(0, true),\n      dataView.getInt16(2, true),\n      dataView.getInt16(4, true),\n    ].map((value) => value * scalar);\n\n    const vector: Vector3 = { x, y, z };\n\n    _console.log({ vector });\n    return vector;\n  }\n\n  parseQuaternion(dataView: DataView, scalar: number): Quaternion {\n    let [x, y, z, w] = [\n      dataView.getInt16(0, true),\n      dataView.getInt16(2, true),\n      dataView.getInt16(4, true),\n      dataView.getInt16(6, true),\n    ].map((value) => value * scalar);\n\n    const quaternion: Quaternion = { x, y, z, w };\n\n    _console.log({ quaternion });\n    return quaternion;\n  }\n\n  parseEuler(dataView: DataView, scalar: number): Euler {\n    let [heading, pitch, roll] = [\n      dataView.getInt16(0, true),\n      dataView.getInt16(2, true),\n      dataView.getInt16(4, true),\n    ].map((value) => value * scalar);\n\n    pitch *= -1;\n    heading *= -1;\n    if (heading < 0) {\n      heading += 360;\n    }\n\n    const euler: Euler = { heading, pitch, roll };\n\n    _console.log({ euler });\n    return euler;\n  }\n\n  parseStepCounter(dataView: DataView) {\n    _console.log(\"parseStepCounter\", dataView);\n    const stepCount = dataView.getUint32(0, true);\n    _console.log({ stepCount });\n    return stepCount;\n  }\n\n  parseActivity(dataView: DataView) {\n    _console.log(\"parseActivity\", dataView);\n    const activity: Partial<Activity> = {};\n\n    const activityBitfield = dataView.getUint8(0);\n    _console.log(\"activityBitfield\", activityBitfield.toString(2));\n    ActivityTypes.forEach((activityType, index) => {\n      activity[activityType] = Boolean(activityBitfield & (1 << index));\n    });\n\n    _console.log(\"activity\", activity);\n\n    return activity as Activity;\n  }\n\n  parseDeviceOrientation(dataView: DataView) {\n    _console.log(\"parseDeviceOrientation\", dataView);\n    const index = dataView.getUint8(0);\n    const deviceOrientation = DeviceOrientations[index];\n    _console.assertWithError(deviceOrientation, \"undefined deviceOrientation\");\n    _console.log({ deviceOrientation });\n    return deviceOrientation;\n  }\n}\n\nexport default MotionSensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\n\nexport const BarometerSensorTypes = [\"barometer\"] as const;\nexport type BarometerSensorType = (typeof BarometerSensorTypes)[number];\n\nexport const ContinuousBarometerSensorTypes = BarometerSensorTypes;\nexport type ContinuousBarometerSensorType = (typeof ContinuousBarometerSensorTypes)[number];\n\nexport interface BarometerSensorDataEventMessages {\n  barometer: {\n    barometer: number;\n    //altitude: number;\n  };\n}\n\nconst _console = createConsole(\"BarometerSensorDataManager\", { log: false });\n\nclass BarometerSensorDataManager {\n  #calculcateAltitude(pressure: number) {\n    const P0 = 101325; // Standard atmospheric pressure at sea level in Pascals\n    const T0 = 288.15; // Standard temperature at sea level in Kelvin\n    const L = 0.0065; // Temperature lapse rate in K/m\n    const R = 8.3144598; // Universal gas constant in J/(mol·K)\n    const g = 9.80665; // Acceleration due to gravity in m/s²\n    const M = 0.0289644; // Molar mass of Earth's air in kg/mol\n\n    const exponent = (R * L) / (g * M);\n    const h = (T0 / L) * (1 - Math.pow(pressure / P0, exponent));\n\n    return h;\n  }\n\n  parseData(dataView: DataView, scalar: number) {\n    const pressure = dataView.getUint32(0, true) * scalar;\n    const altitude = this.#calculcateAltitude(pressure);\n    _console.log({ pressure, altitude });\n    return { pressure };\n  }\n}\n\nexport default BarometerSensorDataManager;\n","import { sliceDataView } from \"./ArrayBufferUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { textDecoder } from \"./Text.ts\";\n\nconst _console = createConsole(\"ParseUtils\", { log: false });\n\nexport function parseStringFromDataView(\n  dataView: DataView,\n  byteOffset: number = 0\n) {\n  const stringLength = dataView.getUint8(byteOffset++);\n  const string = textDecoder.decode(\n    dataView.buffer.slice(\n      dataView.byteOffset + byteOffset,\n      dataView.byteOffset + byteOffset + stringLength\n    )\n  );\n  byteOffset += stringLength;\n  return { string, byteOffset };\n}\n\nexport function parseMessage<MessageType extends string>(\n  dataView: DataView,\n  messageTypes: readonly MessageType[],\n  callback: (\n    messageType: MessageType,\n    dataView: DataView,\n    context?: any\n  ) => void,\n  context?: any,\n  parseMessageLengthAsUint16: boolean = false\n) {\n  let byteOffset = 0;\n  while (byteOffset < dataView.byteLength) {\n    const messageTypeEnum = dataView.getUint8(byteOffset++);\n    _console.assertWithError(\n      messageTypeEnum in messageTypes,\n      `invalid messageTypeEnum ${messageTypeEnum}`\n    );\n    const messageType = messageTypes[messageTypeEnum];\n\n    let messageLength: number;\n    if (parseMessageLengthAsUint16) {\n      messageLength = dataView.getUint16(byteOffset, true);\n      byteOffset += 2;\n    } else {\n      messageLength = dataView.getUint8(byteOffset++);\n    }\n\n    _console.log({\n      messageTypeEnum,\n      messageType,\n      messageLength,\n      dataView,\n      byteOffset,\n    });\n\n    const _dataView = sliceDataView(dataView, byteOffset, messageLength);\n    _console.log({ _dataView });\n\n    callback(messageType, _dataView, context);\n\n    byteOffset += messageLength;\n  }\n}\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInNode } from \"./utils/environment.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\nimport { parseMessage } from \"./utils/ParseUtils.ts\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./utils/ArrayBufferUtils.ts\";\n\nconst _console = createConsole(\"CameraManager\", { log: false });\n\nexport const CameraSensorTypes = [\"camera\"] as const;\nexport type CameraSensorType = (typeof CameraSensorTypes)[number];\n\nexport const CameraCommands = [\n  \"focus\",\n  \"takePicture\",\n  \"stop\",\n  \"sleep\",\n  \"wake\",\n] as const;\nexport type CameraCommand = (typeof CameraCommands)[number];\n\nexport const CameraStatuses = [\n  \"idle\",\n  \"focusing\",\n  \"takingPicture\",\n  \"asleep\",\n] as const;\nexport type CameraStatus = (typeof CameraStatuses)[number];\n\nexport const CameraDataTypes = [\n  \"headerSize\",\n  \"header\",\n  \"imageSize\",\n  \"image\",\n  \"footerSize\",\n  \"footer\",\n] as const;\nexport type CameraDataType = (typeof CameraDataTypes)[number];\n\nexport const CameraConfigurationTypes = [\n  \"resolution\",\n  \"qualityFactor\",\n  \"shutter\",\n  \"gain\",\n  \"redGain\",\n  \"greenGain\",\n  \"blueGain\",\n] as const;\nexport type CameraConfigurationType = (typeof CameraConfigurationTypes)[number];\n\nexport const CameraMessageTypes = [\n  \"cameraStatus\",\n  \"cameraCommand\",\n  \"getCameraConfiguration\",\n  \"setCameraConfiguration\",\n  \"cameraData\",\n] as const;\nexport type CameraMessageType = (typeof CameraMessageTypes)[number];\n\nexport type CameraConfiguration = {\n  [cameraConfigurationType in CameraConfigurationType]?: number;\n};\nexport type CameraConfigurationRanges = {\n  [cameraConfigurationType in CameraConfigurationType]: {\n    min: number;\n    max: number;\n  };\n};\n\nexport const RequiredCameraMessageTypes: CameraMessageType[] = [\n  \"getCameraConfiguration\",\n  \"cameraStatus\",\n] as const;\n\nexport const CameraEventTypes = [\n  ...CameraMessageTypes,\n  \"cameraImageProgress\",\n  \"cameraImage\",\n] as const;\nexport type CameraEventType = (typeof CameraEventTypes)[number];\n\nexport interface CameraEventMessages {\n  cameraStatus: {\n    cameraStatus: CameraStatus;\n    previousCameraStatus: CameraStatus;\n  };\n  getCameraConfiguration: { cameraConfiguration: CameraConfiguration };\n  cameraImageProgress: { progress: number; type: CameraDataType };\n  cameraImage: { blob: Blob; url: string };\n}\n\nexport type CameraEventDispatcher = EventDispatcher<\n  Device,\n  CameraEventType,\n  CameraEventMessages\n>;\nexport type SendCameraMessageCallback = SendMessageCallback<CameraMessageType>;\n\nclass CameraManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendCameraMessageCallback;\n\n  eventDispatcher!: CameraEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required camera information\");\n    const messages = RequiredCameraMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // CAMERA STATUS\n  #cameraStatus!: CameraStatus;\n  get cameraStatus() {\n    return this.#cameraStatus;\n  }\n  #parseCameraStatus(dataView: DataView) {\n    const cameraStatusIndex = dataView.getUint8(0);\n    const newCameraStatus = CameraStatuses[cameraStatusIndex];\n    this.#updateCameraStatus(newCameraStatus);\n  }\n  #updateCameraStatus(newCameraStatus: CameraStatus) {\n    _console.assertEnumWithError(newCameraStatus, CameraStatuses);\n    if (newCameraStatus == this.#cameraStatus) {\n      _console.log(`redundant cameraStatus ${newCameraStatus}`);\n      return;\n    }\n    const previousCameraStatus = this.#cameraStatus;\n    this.#cameraStatus = newCameraStatus;\n    _console.log(`updated cameraStatus to \"${this.cameraStatus}\"`);\n    this.#dispatchEvent(\"cameraStatus\", {\n      cameraStatus: this.cameraStatus,\n      previousCameraStatus,\n    });\n\n    if (\n      this.#cameraStatus != \"takingPicture\" &&\n      this.#imageProgress > 0 &&\n      !this.#didBuildImage\n    ) {\n      this.#buildImage();\n    }\n  }\n\n  // CAMERA COMMAND\n  async #sendCameraCommand(command: CameraCommand, sendImmediately?: boolean) {\n    _console.assertEnumWithError(command, CameraCommands);\n    _console.log(`sending camera command \"${command}\"`);\n\n    const promise = this.waitForEvent(\"cameraStatus\");\n    _console.log(`setting command \"${command}\"`);\n    const commandEnum = CameraCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"cameraCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  #assertIsAsleep() {\n    _console.assertWithError(\n      this.#cameraStatus == \"asleep\",\n      `camera is not asleep - currently ${this.#cameraStatus}`\n    );\n  }\n  #assertIsAwake() {\n    _console.assertWithError(\n      this.#cameraStatus != \"asleep\",\n      `camera is not awake - currently ${this.#cameraStatus}`\n    );\n  }\n  async focus() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"focus\");\n  }\n  async takePicture() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"takePicture\");\n  }\n  async stop() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"stop\");\n  }\n  async sleep() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"sleep\");\n  }\n  async wake() {\n    this.#assertIsAsleep();\n    await this.#sendCameraCommand(\"wake\");\n  }\n\n  // CAMERA DATA\n  #parseCameraData(dataView: DataView) {\n    _console.log(\"parsing camera data\", dataView);\n    parseMessage(\n      dataView,\n      CameraDataTypes,\n      this.#onCameraData.bind(this),\n      null,\n      true\n    );\n  }\n  #onCameraData(cameraDataType: CameraDataType, dataView: DataView) {\n    _console.log({ cameraDataType, dataView });\n    switch (cameraDataType) {\n      case \"headerSize\":\n        this.#headerSize = dataView.getUint16(0, true);\n        _console.log({ headerSize: this.#headerSize });\n        this.#headerData = undefined;\n        this.#headerProgress == 0;\n        break;\n      case \"header\":\n        this.#headerData = concatenateArrayBuffers(this.#headerData, dataView);\n        _console.log({ headerData: this.#headerData });\n        this.#headerProgress = this.#headerData?.byteLength / this.#headerSize;\n        _console.log({ headerProgress: this.#headerProgress });\n        this.#dispatchEvent(\"cameraImageProgress\", {\n          progress: this.#headerProgress,\n          type: \"header\",\n        });\n        if (this.#headerProgress == 1) {\n          _console.log(\"finished getting header data\");\n        }\n        break;\n      case \"imageSize\":\n        this.#imageSize = dataView.getUint16(0, true);\n        _console.log({ imageSize: this.#imageSize });\n        this.#imageData = undefined;\n        this.#imageProgress == 0;\n        this.#didBuildImage = false;\n        break;\n      case \"image\":\n        this.#imageData = concatenateArrayBuffers(this.#imageData, dataView);\n        _console.log({ imageData: this.#imageData });\n        this.#imageProgress = this.#imageData?.byteLength / this.#imageSize;\n        _console.log({ imageProgress: this.#imageProgress });\n        this.#dispatchEvent(\"cameraImageProgress\", {\n          progress: this.#imageProgress,\n          type: \"image\",\n        });\n        if (this.#imageProgress == 1) {\n          _console.log(\"finished getting image data\");\n          if (this.#headerProgress == 1) {\n            this.#buildImage();\n          }\n        }\n        break;\n      case \"footerSize\":\n        this.#footerSize = dataView.getUint16(0, true);\n        _console.log({ footerSize: this.#footerSize });\n        this.#footerData = undefined;\n        this.#footerProgress == 0;\n        break;\n      case \"footer\":\n        this.#footerData = concatenateArrayBuffers(this.#footerData, dataView);\n        _console.log({ footerData: this.#footerData });\n        this.#footerProgress = this.#footerData?.byteLength / this.#footerSize;\n        _console.log({ footerProgress: this.#footerProgress });\n        this.#dispatchEvent(\"cameraImageProgress\", {\n          progress: this.#footerProgress,\n          type: \"footer\",\n        });\n        if (this.#footerProgress == 1) {\n          _console.log(\"finished getting footer data\");\n          if (this.#imageProgress == 1) {\n            this.#buildImage();\n          }\n        }\n        break;\n    }\n  }\n\n  #headerSize: number = 0;\n  #headerData?: ArrayBuffer;\n  #headerProgress: number = 0;\n\n  #imageSize: number = 0;\n  #imageData?: ArrayBuffer;\n  #imageProgress: number = 0;\n\n  #footerSize: number = 0;\n  #footerData?: ArrayBuffer;\n  #footerProgress: number = 0;\n\n  #didBuildImage: boolean = false;\n  #buildImage() {\n    _console.log(\"building image...\");\n    const imageData = concatenateArrayBuffers(\n      this.#headerData,\n      this.#imageData,\n      this.#footerData\n    );\n    _console.log({ imageData });\n\n    let blob = new Blob([imageData], { type: \"image/jpeg\" });\n    _console.log(\"created blob\", blob);\n\n    const url = URL.createObjectURL(blob);\n    _console.log(\"created url\", url);\n\n    this.#dispatchEvent(\"cameraImage\", { url, blob });\n\n    this.#didBuildImage = true;\n  }\n\n  // CONFIG\n  #cameraConfiguration: CameraConfiguration = {};\n  get cameraConfiguration() {\n    return this.#cameraConfiguration;\n  }\n  #availableCameraConfigurationTypes!: CameraConfigurationType[];\n  get availableCameraConfigurationTypes() {\n    return this.#availableCameraConfigurationTypes;\n  }\n\n  #cameraConfigurationRanges: CameraConfigurationRanges = {\n    resolution: { min: 100, max: 720 },\n    qualityFactor: { min: 15, max: 60 },\n    shutter: { min: 4, max: 16383 },\n    gain: { min: 1, max: 248 },\n    redGain: { min: 0, max: 1023 },\n    greenGain: { min: 0, max: 1023 },\n    blueGain: { min: 0, max: 1023 },\n  };\n  get cameraConfigurationRanges() {\n    return this.#cameraConfigurationRanges;\n  }\n\n  #parseCameraConfiguration(dataView: DataView) {\n    const parsedCameraConfiguration: CameraConfiguration = {};\n\n    let byteOffset = 0;\n    while (byteOffset < dataView.byteLength) {\n      const cameraConfigurationTypeIndex = dataView.getUint8(byteOffset++);\n      const cameraConfigurationType =\n        CameraConfigurationTypes[cameraConfigurationTypeIndex];\n      _console.assertWithError(\n        cameraConfigurationType,\n        `invalid cameraConfigurationTypeIndex ${cameraConfigurationTypeIndex}`\n      );\n      parsedCameraConfiguration[cameraConfigurationType] = dataView.getUint16(\n        byteOffset,\n        true\n      );\n      byteOffset += 2;\n    }\n\n    _console.log({ parsedCameraConfiguration });\n    this.#availableCameraConfigurationTypes = Object.keys(\n      parsedCameraConfiguration\n    ) as CameraConfigurationType[];\n    this.#cameraConfiguration = parsedCameraConfiguration;\n    this.#dispatchEvent(\"getCameraConfiguration\", {\n      cameraConfiguration: this.#cameraConfiguration,\n    });\n  }\n\n  #isCameraConfigurationRedundant(cameraConfiguration: CameraConfiguration) {\n    let cameraConfigurationTypes = Object.keys(\n      cameraConfiguration\n    ) as CameraConfigurationType[];\n    return cameraConfigurationTypes.every((cameraConfigurationType) => {\n      return (\n        this.cameraConfiguration[cameraConfigurationType] ==\n        cameraConfiguration[cameraConfigurationType]\n      );\n    });\n  }\n  async setCameraConfiguration(newCameraConfiguration: CameraConfiguration) {\n    _console.log({ newCameraConfiguration });\n    if (this.#isCameraConfigurationRedundant(newCameraConfiguration)) {\n      _console.log(\"redundant camera configuration\");\n      return;\n    }\n    const setCameraConfigurationData = this.#createData(newCameraConfiguration);\n    _console.log({ setCameraConfigurationData });\n\n    const promise = this.waitForEvent(\"getCameraConfiguration\");\n    this.sendMessage([\n      {\n        type: \"setCameraConfiguration\",\n        data: setCameraConfigurationData.buffer,\n      },\n    ]);\n    await promise;\n  }\n\n  #assertAvailableCameraConfigurationType(\n    cameraConfigurationType: CameraConfigurationType\n  ) {\n    _console.assertWithError(\n      this.#availableCameraConfigurationTypes,\n      \"must get initial cameraConfiguration\"\n    );\n    const isCameraConfigurationTypeAvailable =\n      this.#availableCameraConfigurationTypes?.includes(\n        cameraConfigurationType\n      );\n    _console.assertWithError(\n      isCameraConfigurationTypeAvailable,\n      `unavailable camera configuration type \"${cameraConfigurationType}\"`\n    );\n    return isCameraConfigurationTypeAvailable;\n  }\n\n  static AssertValidCameraConfigurationType(\n    cameraConfigurationType: CameraConfigurationType\n  ) {\n    _console.assertEnumWithError(\n      cameraConfigurationType,\n      CameraConfigurationTypes\n    );\n  }\n  static AssertValidCameraConfigurationTypeEnum(\n    cameraConfigurationTypeEnum: number\n  ) {\n    _console.assertTypeWithError(cameraConfigurationTypeEnum, \"number\");\n    _console.assertWithError(\n      cameraConfigurationTypeEnum in CameraConfigurationTypes,\n      `invalid cameraConfigurationTypeEnum ${cameraConfigurationTypeEnum}`\n    );\n  }\n\n  #createData(cameraConfiguration: CameraConfiguration) {\n    let cameraConfigurationTypes = Object.keys(\n      cameraConfiguration\n    ) as CameraConfigurationType[];\n    cameraConfigurationTypes = cameraConfigurationTypes.filter(\n      (cameraConfigurationType) =>\n        this.#assertAvailableCameraConfigurationType(cameraConfigurationType)\n    );\n\n    const dataView = new DataView(\n      new ArrayBuffer(cameraConfigurationTypes.length * 3)\n    );\n    cameraConfigurationTypes.forEach((cameraConfigurationType, index) => {\n      CameraManager.AssertValidCameraConfigurationType(cameraConfigurationType);\n      const cameraConfigurationTypeEnum = CameraConfigurationTypes.indexOf(\n        cameraConfigurationType\n      );\n      dataView.setUint8(index * 3, cameraConfigurationTypeEnum);\n\n      const value = cameraConfiguration[cameraConfigurationType]!;\n      //this.#assertValidCameraConfigurationValue(cameraConfigurationType, value);\n      dataView.setUint16(index * 3 + 1, value, true);\n    });\n    _console.log({ sensorConfigurationData: dataView });\n    return dataView;\n  }\n\n  // MESSAGE\n  parseMessage(messageType: CameraMessageType, dataView: DataView) {\n    _console.log({ messageType, dataView });\n\n    switch (messageType) {\n      case \"cameraStatus\":\n        this.#parseCameraStatus(dataView);\n        break;\n      case \"getCameraConfiguration\":\n      case \"setCameraConfiguration\":\n        this.#parseCameraConfiguration(dataView);\n        break;\n      case \"cameraData\":\n        this.#parseCameraData(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    // @ts-ignore\n    this.#cameraStatus = undefined;\n    this.#headerProgress = 0;\n    this.#imageProgress = 0;\n    this.#footerProgress = 0;\n  }\n}\n\nexport default CameraManager;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"AudioUtils\", { log: false });\n\nexport function float32ArrayToWav(\n  audioData: Float32Array,\n  sampleRate: number,\n  numChannels: number\n): Blob {\n  const wavBuffer = encodeWAV(audioData, sampleRate, numChannels);\n  return new Blob([wavBuffer], { type: \"audio/wav\" });\n}\n\nfunction encodeWAV(\n  interleaved: Float32Array,\n  sampleRate: number,\n  numChannels: number\n): ArrayBuffer {\n  const buffer = new ArrayBuffer(44 + interleaved.length * 2); // 44 bytes for WAV header\n  const view = new DataView(buffer);\n\n  // RIFF identifier\n  writeString(view, 0, \"RIFF\");\n  // File length minus RIFF identifier length and file description length\n  view.setUint32(4, 36 + interleaved.length * 2, true);\n  // RIFF type\n  writeString(view, 8, \"WAVE\");\n  // Format chunk identifier\n  writeString(view, 12, \"fmt \");\n  // Format chunk length\n  view.setUint32(16, 16, true);\n  // Sample format (raw)\n  view.setUint16(20, 1, true);\n  // Channel count\n  view.setUint16(22, numChannels, true);\n  // Sample rate\n  view.setUint32(24, sampleRate, true);\n  // Byte rate (sample rate * block align)\n  view.setUint32(28, sampleRate * numChannels * 2, true);\n  // Block align (channel count * bytes per sample)\n  view.setUint16(32, numChannels * 2, true);\n  // Bits per sample\n  view.setUint16(34, 16, true);\n  // Data chunk identifier\n  writeString(view, 36, \"data\");\n  // Data chunk length\n  view.setUint32(40, interleaved.length * 2, true);\n\n  // Write interleaved audio data\n  for (let i = 0; i < interleaved.length; i++) {\n    view.setInt16(44 + i * 2, interleaved[i] * 0x7fff, true); // Convert float [-1, 1] to int16\n  }\n\n  return buffer;\n}\n\nexport function writeString(\n  view: DataView,\n  offset: number,\n  string: string\n): void {\n  for (let i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./utils/ArrayBufferUtils.ts\";\nimport { float32ArrayToWav } from \"./utils/AudioUtils.ts\";\n\nconst _console = createConsole(\"MicrophoneManager\", { log: false });\n\nexport const MicrophoneSensorTypes = [\"microphone\"] as const;\nexport type MicrophoneSensorType = (typeof MicrophoneSensorTypes)[number];\n\nexport const MicrophoneCommands = [\"start\", \"stop\", \"vad\"] as const;\nexport type MicrophoneCommand = (typeof MicrophoneCommands)[number];\n\nexport const MicrophoneStatuses = [\"idle\", \"streaming\", \"vad\"] as const;\nexport type MicrophoneStatus = (typeof MicrophoneStatuses)[number];\n\nexport const MicrophoneConfigurationTypes = [\"sampleRate\", \"bitDepth\"] as const;\nexport type MicrophoneConfigurationType =\n  (typeof MicrophoneConfigurationTypes)[number];\n\nexport const MicrophoneSampleRates = [\"8000\", \"16000\"] as const;\nexport type MicrophoneSampleRate = (typeof MicrophoneSampleRates)[number];\n\nexport const MicrophoneBitDepths = [\"8\", \"16\"] as const;\nexport type MicrophoneBitDepth = (typeof MicrophoneBitDepths)[number];\n\nexport const MicrophoneMessageTypes = [\n  \"microphoneStatus\",\n  \"microphoneCommand\",\n  \"getMicrophoneConfiguration\",\n  \"setMicrophoneConfiguration\",\n  \"microphoneData\",\n] as const;\nexport type MicrophoneMessageType = (typeof MicrophoneMessageTypes)[number];\n\nexport type MicrophoneConfiguration = {\n  sampleRate?: MicrophoneSampleRate;\n  bitDepth?: MicrophoneBitDepth;\n};\n\nexport const MicrophoneConfigurationValues = {\n  sampleRate: MicrophoneSampleRates,\n  bitDepth: MicrophoneBitDepths,\n};\n\nexport const RequiredMicrophoneMessageTypes: MicrophoneMessageType[] = [\n  \"getMicrophoneConfiguration\",\n  \"microphoneStatus\",\n] as const;\n\nexport const MicrophoneEventTypes = [\n  ...MicrophoneMessageTypes,\n  \"isRecordingMicrophone\",\n  \"microphoneRecording\",\n] as const;\nexport type MicrophoneEventType = (typeof MicrophoneEventTypes)[number];\n\nexport interface MicrophoneEventMessages {\n  microphoneStatus: {\n    microphoneStatus: MicrophoneStatus;\n    previousMicrophoneStatus: MicrophoneStatus;\n  };\n  getMicrophoneConfiguration: {\n    microphoneConfiguration: MicrophoneConfiguration;\n  };\n  microphoneData: {\n    samples: Float32Array;\n    sampleRate: MicrophoneSampleRate;\n    bitDepth: MicrophoneBitDepth;\n  };\n  isRecordingMicrophone: {\n    isRecordingMicrophone: boolean;\n  };\n  microphoneRecording: {\n    samples: Float32Array;\n    sampleRate: MicrophoneSampleRate;\n    bitDepth: MicrophoneBitDepth;\n    blob: Blob;\n    url: string;\n  };\n}\n\nexport type MicrophoneEventDispatcher = EventDispatcher<\n  Device,\n  MicrophoneEventType,\n  MicrophoneEventMessages\n>;\nexport type SendMicrophoneMessageCallback =\n  SendMessageCallback<MicrophoneMessageType>;\n\nclass MicrophoneManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendMicrophoneMessageCallback;\n\n  eventDispatcher!: MicrophoneEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required microphone information\");\n    const messages = RequiredMicrophoneMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // MICROPHONE STATUS\n  #microphoneStatus!: MicrophoneStatus;\n  get microphoneStatus() {\n    return this.#microphoneStatus;\n  }\n  #parseMicrophoneStatus(dataView: DataView) {\n    const microphoneStatusIndex = dataView.getUint8(0);\n    const newMicrophoneStatus = MicrophoneStatuses[microphoneStatusIndex];\n    this.#updateMicrophoneStatus(newMicrophoneStatus);\n  }\n  #updateMicrophoneStatus(newMicrophoneStatus: MicrophoneStatus) {\n    _console.assertEnumWithError(newMicrophoneStatus, MicrophoneStatuses);\n    if (newMicrophoneStatus == this.#microphoneStatus) {\n      _console.log(`redundant microphoneStatus ${newMicrophoneStatus}`);\n      return;\n    }\n    const previousMicrophoneStatus = this.#microphoneStatus;\n    this.#microphoneStatus = newMicrophoneStatus;\n    _console.log(`updated microphoneStatus to \"${this.microphoneStatus}\"`);\n    this.#dispatchEvent(\"microphoneStatus\", {\n      microphoneStatus: this.microphoneStatus,\n      previousMicrophoneStatus,\n    });\n  }\n\n  // MICROPHONE COMMAND\n  async #sendMicrophoneCommand(\n    command: MicrophoneCommand,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(command, MicrophoneCommands);\n    _console.log(`sending microphone command \"${command}\"`);\n\n    const promise = this.waitForEvent(\"microphoneStatus\");\n    _console.log(`setting command \"${command}\"`);\n    const commandEnum = MicrophoneCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"microphoneCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  #assertIsIdle() {\n    _console.assertWithError(\n      this.#microphoneStatus == \"idle\",\n      `microphone is not idle - currently ${this.#microphoneStatus}`\n    );\n  }\n  #assertIsNotIdle() {\n    _console.assertWithError(\n      this.#microphoneStatus != \"idle\",\n      `microphone is idle`\n    );\n  }\n  #assertIsStreaming() {\n    _console.assertWithError(\n      this.#microphoneStatus == \"streaming\",\n      `microphone is not recording - currently ${this.#microphoneStatus}`\n    );\n  }\n\n  async start() {\n    await this.#sendMicrophoneCommand(\"start\");\n  }\n  async stop() {\n    this.#assertIsNotIdle();\n    await this.#sendMicrophoneCommand(\"stop\");\n  }\n  async vad() {\n    await this.#sendMicrophoneCommand(\"vad\");\n  }\n  async toggle() {\n    switch (this.microphoneStatus) {\n      case \"idle\":\n        this.start();\n        break;\n      case \"streaming\":\n        this.stop();\n        break;\n    }\n  }\n\n  // MICROPHONE DATA\n  #assertValidBitDepth() {\n    _console.assertEnumWithError(this.bitDepth!, MicrophoneBitDepths);\n  }\n  #fadeDuration = 0.001;\n  #playbackTime = 0;\n  #parseMicrophoneData(dataView: DataView) {\n    this.#assertValidBitDepth();\n\n    _console.log(\"parsing microphone data\", dataView);\n\n    const numberOfSamples = dataView.byteLength / this.#bytesPerSample!;\n    const samples = new Float32Array(numberOfSamples);\n\n    for (let i = 0; i < numberOfSamples; i++) {\n      let sample;\n      switch (this.bitDepth) {\n        case \"16\":\n          sample = dataView.getInt16(i * 2, true);\n          samples[i] = sample / 2 ** 15; // Normalize to [-1, 1]\n          break;\n        case \"8\":\n          sample = dataView.getInt8(i);\n          samples[i] = sample / 2 ** 7; // Normalize to [-1, 1]\n          break;\n      }\n    }\n\n    _console.log(\"samples\", samples);\n\n    if (this.#isRecording && this.#microphoneRecordingData) {\n      this.#microphoneRecordingData!.push(samples);\n    }\n\n    if (this.#audioContext) {\n      if (this.#gainNode) {\n        const audioBuffer = this.#audioContext.createBuffer(\n          1,\n          samples.length,\n          Number(this.sampleRate!)\n        );\n        audioBuffer.getChannelData(0).set(samples);\n\n        const bufferSource = this.#audioContext.createBufferSource();\n        bufferSource.buffer = audioBuffer;\n\n        const channelData = audioBuffer.getChannelData(0);\n        const sampleRate = Number(this.sampleRate!);\n\n        for (let i = 0; i < this.#fadeDuration * sampleRate; i++) {\n          channelData[i] *= i / (this.#fadeDuration * sampleRate);\n        }\n\n        for (\n          let i = channelData.length - 1;\n          i >= channelData.length - this.#fadeDuration * sampleRate;\n          i--\n        ) {\n          channelData[i] *=\n            (channelData.length - i) / (this.#fadeDuration * sampleRate);\n        }\n\n        bufferSource.connect(this.#gainNode!);\n\n        if (this.#playbackTime < this.#audioContext.currentTime) {\n          this.#playbackTime = this.#audioContext.currentTime;\n        }\n        bufferSource.start(this.#playbackTime);\n        this.#playbackTime += audioBuffer.duration;\n      }\n    }\n\n    this.#dispatchEvent(\"microphoneData\", {\n      samples,\n      sampleRate: this.sampleRate!,\n      bitDepth: this.bitDepth!,\n    });\n  }\n  get #bytesPerSample() {\n    switch (this.bitDepth) {\n      case \"8\":\n        return 1;\n      case \"16\":\n        return 2;\n    }\n  }\n\n  // CONFIG\n  #microphoneConfiguration: MicrophoneConfiguration = {};\n  get microphoneConfiguration() {\n    return this.#microphoneConfiguration;\n  }\n  #availableMicrophoneConfigurationTypes!: MicrophoneConfigurationType[];\n  get availableMicrophoneConfigurationTypes() {\n    return this.#availableMicrophoneConfigurationTypes;\n  }\n\n  get bitDepth() {\n    return this.#microphoneConfiguration.bitDepth;\n  }\n  get sampleRate() {\n    return this.#microphoneConfiguration.sampleRate;\n  }\n\n  #parseMicrophoneConfiguration(dataView: DataView) {\n    const parsedMicrophoneConfiguration: MicrophoneConfiguration = {};\n\n    let byteOffset = 0;\n    while (byteOffset < dataView.byteLength) {\n      const microphoneConfigurationTypeIndex = dataView.getUint8(byteOffset++);\n      const microphoneConfigurationType =\n        MicrophoneConfigurationTypes[microphoneConfigurationTypeIndex];\n      _console.assertWithError(\n        microphoneConfigurationType,\n        `invalid microphoneConfigurationTypeIndex ${microphoneConfigurationTypeIndex}`\n      );\n      let rawValue = dataView.getUint8(byteOffset++);\n      const values = MicrophoneConfigurationValues[microphoneConfigurationType];\n      const value = values[rawValue];\n      _console.assertEnumWithError(value, values);\n      _console.log({ microphoneConfigurationType, value });\n      // @ts-expect-error\n      parsedMicrophoneConfiguration[microphoneConfigurationType] = value;\n    }\n\n    _console.log({ parsedMicrophoneConfiguration });\n    this.#availableMicrophoneConfigurationTypes = Object.keys(\n      parsedMicrophoneConfiguration\n    ) as MicrophoneConfigurationType[];\n    this.#microphoneConfiguration = parsedMicrophoneConfiguration;\n    this.#dispatchEvent(\"getMicrophoneConfiguration\", {\n      microphoneConfiguration: this.#microphoneConfiguration,\n    });\n  }\n\n  #isMicrophoneConfigurationRedundant(\n    microphoneConfiguration: MicrophoneConfiguration\n  ) {\n    let microphoneConfigurationTypes = Object.keys(\n      microphoneConfiguration\n    ) as MicrophoneConfigurationType[];\n    return microphoneConfigurationTypes.every((microphoneConfigurationType) => {\n      return (\n        this.microphoneConfiguration[microphoneConfigurationType] ==\n        microphoneConfiguration[microphoneConfigurationType]\n      );\n    });\n  }\n  async setMicrophoneConfiguration(\n    newMicrophoneConfiguration: MicrophoneConfiguration\n  ) {\n    _console.log({ newMicrophoneConfiguration });\n    if (this.#isMicrophoneConfigurationRedundant(newMicrophoneConfiguration)) {\n      _console.log(\"redundant microphone configuration\");\n      return;\n    }\n    const setMicrophoneConfigurationData = this.#createData(\n      newMicrophoneConfiguration\n    );\n    _console.log({ setMicrophoneConfigurationData });\n\n    const promise = this.waitForEvent(\"getMicrophoneConfiguration\");\n    this.sendMessage([\n      {\n        type: \"setMicrophoneConfiguration\",\n        data: setMicrophoneConfigurationData.buffer,\n      },\n    ]);\n    await promise;\n  }\n\n  #assertAvailableMicrophoneConfigurationType(\n    microphoneConfigurationType: MicrophoneConfigurationType\n  ) {\n    _console.assertWithError(\n      this.#availableMicrophoneConfigurationTypes,\n      \"must get initial microphoneConfiguration\"\n    );\n    const isMicrophoneConfigurationTypeAvailable =\n      this.#availableMicrophoneConfigurationTypes?.includes(\n        microphoneConfigurationType\n      );\n    _console.assertWithError(\n      isMicrophoneConfigurationTypeAvailable,\n      `unavailable microphone configuration type \"${microphoneConfigurationType}\"`\n    );\n    return isMicrophoneConfigurationTypeAvailable;\n  }\n\n  static AssertValidMicrophoneConfigurationType(\n    microphoneConfigurationType: MicrophoneConfigurationType\n  ) {\n    _console.assertEnumWithError(\n      microphoneConfigurationType,\n      MicrophoneConfigurationTypes\n    );\n  }\n  static AssertValidMicrophoneConfigurationTypeEnum(\n    microphoneConfigurationTypeEnum: number\n  ) {\n    _console.assertTypeWithError(microphoneConfigurationTypeEnum, \"number\");\n    _console.assertWithError(\n      microphoneConfigurationTypeEnum in MicrophoneConfigurationTypes,\n      `invalid microphoneConfigurationTypeEnum ${microphoneConfigurationTypeEnum}`\n    );\n  }\n\n  #createData(microphoneConfiguration: MicrophoneConfiguration) {\n    let microphoneConfigurationTypes = Object.keys(\n      microphoneConfiguration\n    ) as MicrophoneConfigurationType[];\n    microphoneConfigurationTypes = microphoneConfigurationTypes.filter(\n      (microphoneConfigurationType) =>\n        this.#assertAvailableMicrophoneConfigurationType(\n          microphoneConfigurationType\n        )\n    );\n\n    const dataView = new DataView(\n      new ArrayBuffer(microphoneConfigurationTypes.length * 2)\n    );\n    microphoneConfigurationTypes.forEach(\n      (microphoneConfigurationType, index) => {\n        MicrophoneManager.AssertValidMicrophoneConfigurationType(\n          microphoneConfigurationType\n        );\n        const microphoneConfigurationTypeEnum =\n          MicrophoneConfigurationTypes.indexOf(microphoneConfigurationType);\n        dataView.setUint8(index * 2, microphoneConfigurationTypeEnum);\n\n        let value = microphoneConfiguration[microphoneConfigurationType]!;\n        if (typeof value == \"number\") {\n          // @ts-ignore\n          value = value.toString();\n        }\n        const values =\n          MicrophoneConfigurationValues[microphoneConfigurationType];\n        _console.assertEnumWithError(value, values);\n        // @ts-expect-error\n        const rawValue = values.indexOf(value);\n        dataView.setUint8(index * 2 + 1, rawValue);\n      }\n    );\n    _console.log({ sensorConfigurationData: dataView });\n    return dataView;\n  }\n\n  // MESSAGE\n  parseMessage(messageType: MicrophoneMessageType, dataView: DataView) {\n    _console.log({ messageType, dataView });\n\n    switch (messageType) {\n      case \"microphoneStatus\":\n        this.#parseMicrophoneStatus(dataView);\n        break;\n      case \"getMicrophoneConfiguration\":\n      case \"setMicrophoneConfiguration\":\n        this.#parseMicrophoneConfiguration(dataView);\n        break;\n      case \"microphoneData\":\n        this.#parseMicrophoneData(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  #audioContext?: AudioContext;\n  get audioContext() {\n    return this.#audioContext;\n  }\n  set audioContext(newAudioContext) {\n    if (this.#audioContext == newAudioContext) {\n      _console.log(\"redundant audioContext assignment\", this.#audioContext);\n      return;\n    }\n\n    this.#audioContext = newAudioContext;\n\n    _console.log(\"assigned new audioContext\", this.#audioContext);\n    if (this.#audioContext) {\n      this.#playbackTime = this.#audioContext.currentTime;\n    } else {\n      if (this.#mediaStreamDestination) {\n        this.#mediaStreamDestination.disconnect();\n        this.#mediaStreamDestination = undefined;\n      }\n      if (this.#gainNode) {\n        this.#gainNode.disconnect();\n        this.#gainNode = undefined;\n      }\n    }\n  }\n\n  #gainNode?: GainNode;\n  get gainNode() {\n    _console.assertWithError(\n      this.#audioContext,\n      \"audioContext assignment required for gainNode\"\n    );\n    if (!this.#gainNode) {\n      _console.log(\"creating gainNode...\");\n      this.#gainNode = this.#audioContext!.createGain();\n      _console.log(\"created gainNode\", this.#gainNode);\n    }\n    return this.#gainNode;\n  }\n\n  #mediaStreamDestination?: MediaStreamAudioDestinationNode;\n  get mediaStreamDestination() {\n    _console.assertWithError(\n      this.#audioContext,\n      \"audioContext assignment required for mediaStreamDestination\"\n    );\n    if (!this.#mediaStreamDestination) {\n      _console.log(\"creating mediaStreamDestination...\");\n      this.#mediaStreamDestination =\n        this.#audioContext!.createMediaStreamDestination();\n      this.gainNode?.connect(this.#mediaStreamDestination);\n      _console.log(\n        \"created mediaStreamDestination\",\n        this.#mediaStreamDestination\n      );\n    }\n    return this.#mediaStreamDestination;\n  }\n\n  #isRecording = false;\n  get isRecording() {\n    return this.#isRecording;\n  }\n  #microphoneRecordingData?: Float32Array[];\n  startRecording() {\n    if (this.isRecording) {\n      _console.log(\"already recording\");\n      return;\n    }\n    this.#microphoneRecordingData = [];\n    this.#isRecording = true;\n    this.#dispatchEvent(\"isRecordingMicrophone\", {\n      isRecordingMicrophone: this.isRecording,\n    });\n  }\n  stopRecording() {\n    if (!this.isRecording) {\n      _console.log(\"already not recording\");\n      return;\n    }\n    this.#isRecording = false;\n    if (\n      this.#microphoneRecordingData &&\n      this.#microphoneRecordingData.length > 0\n    ) {\n      _console.log(\n        \"parsing microphone data...\",\n        this.#microphoneRecordingData.length\n      );\n      const arrayBuffer = concatenateArrayBuffers(\n        ...this.#microphoneRecordingData\n      );\n      const samples = new Float32Array(arrayBuffer);\n\n      const blob = float32ArrayToWav(samples, Number(this.sampleRate)!, 1);\n      const url = URL.createObjectURL(blob);\n      this.#dispatchEvent(\"microphoneRecording\", {\n        samples,\n        sampleRate: this.sampleRate!,\n        bitDepth: this.bitDepth!,\n        blob,\n        url,\n      });\n    }\n    this.#microphoneRecordingData = undefined;\n    this.#dispatchEvent(\"isRecordingMicrophone\", {\n      isRecordingMicrophone: this.isRecording,\n    });\n  }\n  toggleRecording() {\n    if (this.#isRecording) {\n      this.stopRecording();\n    } else {\n      this.startRecording();\n    }\n  }\n\n  clear() {\n    // @ts-ignore\n    this.#microphoneStatus = undefined;\n    this.#microphoneConfiguration = {};\n    if (this.isRecording) {\n      this.stopRecording();\n    }\n  }\n}\n\nexport default MicrophoneManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport { parseTimestamp } from \"../utils/MathUtils.ts\";\nimport PressureSensorDataManager, {\n  PressureDataEventMessages,\n} from \"./PressureSensorDataManager.ts\";\nimport MotionSensorDataManager, {\n  MotionSensorDataEventMessages,\n} from \"./MotionSensorDataManager.ts\";\nimport BarometerSensorDataManager, {\n  BarometerSensorDataEventMessages,\n} from \"./BarometerSensorDataManager.ts\";\nimport { parseMessage } from \"../utils/ParseUtils.ts\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\nimport {\n  MotionSensorTypes,\n  ContinuousMotionTypes,\n} from \"./MotionSensorDataManager.ts\";\nimport {\n  PressureSensorTypes,\n  ContinuousPressureSensorTypes,\n} from \"./PressureSensorDataManager.ts\";\nimport {\n  BarometerSensorTypes,\n  ContinuousBarometerSensorTypes,\n} from \"./BarometerSensorDataManager.ts\";\nimport Device from \"../Device.ts\";\nimport {\n  AddKeysAsPropertyToInterface,\n  ExtendInterfaceValues,\n  ValueOf,\n} from \"../utils/TypeScriptUtils.ts\";\nimport { CameraSensorTypes } from \"../CameraManager.ts\";\nimport { MicrophoneSensorTypes } from \"../MicrophoneManager.ts\";\n\nconst _console = createConsole(\"SensorDataManager\", { log: false });\n\nexport const SensorTypes = [\n  ...PressureSensorTypes,\n  ...MotionSensorTypes,\n  ...BarometerSensorTypes,\n  ...CameraSensorTypes,\n  ...MicrophoneSensorTypes,\n] as const;\nexport type SensorType = (typeof SensorTypes)[number];\n\nexport const ContinuousSensorTypes = [\n  ...ContinuousPressureSensorTypes,\n  ...ContinuousMotionTypes,\n  ...ContinuousBarometerSensorTypes,\n] as const;\nexport type ContinuousSensorType = (typeof ContinuousSensorTypes)[number];\n\nexport const SensorDataMessageTypes = [\n  \"getPressurePositions\",\n  \"getSensorScalars\",\n  \"sensorData\",\n] as const;\nexport type SensorDataMessageType = (typeof SensorDataMessageTypes)[number];\n\nexport const RequiredPressureMessageTypes: SensorDataMessageType[] = [\n  \"getPressurePositions\",\n] as const;\n\nexport const SensorDataEventTypes = [\n  ...SensorDataMessageTypes,\n  ...SensorTypes,\n] as const;\nexport type SensorDataEventType = (typeof SensorDataEventTypes)[number];\n\ninterface BaseSensorDataEventMessage {\n  timestamp: number;\n}\n\ntype BaseSensorDataEventMessages = BarometerSensorDataEventMessages &\n  MotionSensorDataEventMessages &\n  PressureDataEventMessages;\ntype _SensorDataEventMessages = ExtendInterfaceValues<\n  AddKeysAsPropertyToInterface<BaseSensorDataEventMessages, \"sensorType\">,\n  BaseSensorDataEventMessage\n>;\nexport type SensorDataEventMessage = ValueOf<_SensorDataEventMessages>;\ninterface AnySensorDataEventMessages {\n  sensorData: SensorDataEventMessage;\n}\nexport type SensorDataEventMessages = _SensorDataEventMessages &\n  AnySensorDataEventMessages;\n\nexport type SensorDataEventDispatcher = EventDispatcher<\n  Device,\n  SensorDataEventType,\n  SensorDataEventMessages\n>;\n\nclass SensorDataManager {\n  pressureSensorDataManager = new PressureSensorDataManager();\n  motionSensorDataManager = new MotionSensorDataManager();\n  barometerSensorDataManager = new BarometerSensorDataManager();\n\n  #scalars: Map<SensorType, number> = new Map();\n\n  static AssertValidSensorType(sensorType: SensorType) {\n    _console.assertEnumWithError(sensorType, SensorTypes);\n  }\n  static AssertValidSensorTypeEnum(sensorTypeEnum: number) {\n    _console.assertTypeWithError(sensorTypeEnum, \"number\");\n    _console.assertWithError(\n      sensorTypeEnum in SensorTypes,\n      `invalid sensorTypeEnum ${sensorTypeEnum}`\n    );\n  }\n\n  eventDispatcher!: SensorDataEventDispatcher;\n  get dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  parseMessage(messageType: SensorDataMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getSensorScalars\":\n        this.parseScalars(dataView);\n        break;\n      case \"getPressurePositions\":\n        this.pressureSensorDataManager.parsePositions(dataView);\n        break;\n      case \"sensorData\":\n        this.parseData(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  parseScalars(dataView: DataView) {\n    for (\n      let byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      byteOffset += 5\n    ) {\n      const sensorTypeIndex = dataView.getUint8(byteOffset);\n      const sensorType = SensorTypes[sensorTypeIndex];\n      if (!sensorType) {\n        _console.warn(`unknown sensorType index ${sensorTypeIndex}`);\n        continue;\n      }\n      const sensorScalar = dataView.getFloat32(byteOffset + 1, true);\n      _console.log({ sensorType, sensorScalar });\n      this.#scalars.set(sensorType, sensorScalar);\n    }\n  }\n\n  private parseData(dataView: DataView) {\n    _console.log(\"sensorData\", Array.from(new Uint8Array(dataView.buffer)));\n\n    let byteOffset = 0;\n    const timestamp = parseTimestamp(dataView, byteOffset);\n    byteOffset += 2;\n\n    const _dataView = new DataView(dataView.buffer, byteOffset);\n\n    parseMessage(_dataView, SensorTypes, this.parseDataCallback.bind(this), {\n      timestamp,\n    });\n  }\n\n  private parseDataCallback(\n    sensorType: SensorType,\n    dataView: DataView,\n    { timestamp }: { timestamp: number }\n  ) {\n    const scalar = this.#scalars.get(sensorType) || 1;\n\n    let sensorData = null;\n    switch (sensorType) {\n      case \"pressure\":\n        sensorData = this.pressureSensorDataManager.parseData(dataView, scalar);\n        break;\n      case \"acceleration\":\n      case \"gravity\":\n      case \"linearAcceleration\":\n      case \"gyroscope\":\n      case \"magnetometer\":\n        sensorData = this.motionSensorDataManager.parseVector3(\n          dataView,\n          scalar\n        );\n        break;\n      case \"gameRotation\":\n      case \"rotation\":\n        sensorData = this.motionSensorDataManager.parseQuaternion(\n          dataView,\n          scalar\n        );\n        break;\n      case \"orientation\":\n        sensorData = this.motionSensorDataManager.parseEuler(dataView, scalar);\n        break;\n      case \"stepCounter\":\n        sensorData = this.motionSensorDataManager.parseStepCounter(dataView);\n        break;\n      case \"stepDetector\":\n        sensorData = {};\n        break;\n      case \"activity\":\n        sensorData = this.motionSensorDataManager.parseActivity(dataView);\n        break;\n      case \"deviceOrientation\":\n        sensorData =\n          this.motionSensorDataManager.parseDeviceOrientation(dataView);\n        break;\n      case \"tapDetector\":\n        sensorData = {};\n        break;\n      case \"barometer\":\n        sensorData = this.barometerSensorDataManager.parseData(\n          dataView,\n          scalar\n        );\n        break;\n      case \"camera\":\n        // we parse camera data using CameraManager\n        return;\n      case \"microphone\":\n        // we parse microphone data using MicrophoneManager\n        return;\n      default:\n        _console.error(`uncaught sensorType \"${sensorType}\"`);\n    }\n\n    _console.assertWithError(\n      sensorData != null,\n      `no sensorData defined for sensorType \"${sensorType}\"`\n    );\n\n    _console.log({ sensorType, sensorData });\n    // @ts-expect-error\n    this.dispatchEvent(sensorType, {\n      sensorType,\n      [sensorType]: sensorData,\n      timestamp,\n    });\n    // @ts-expect-error\n    this.dispatchEvent(\"sensorData\", {\n      sensorType,\n      [sensorType]: sensorData,\n      timestamp,\n    });\n  }\n}\n\nexport default SensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport SensorDataManager, {\n  SensorTypes,\n  SensorType,\n} from \"./SensorDataManager.ts\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\nimport Device, { SendMessageCallback } from \"../Device.ts\";\nimport autoBind from \"../../node_modules/auto-bind/index.js\";\n\nconst _console = createConsole(\"SensorConfigurationManager\", { log: false });\n\nexport type SensorConfiguration = { [sensorType in SensorType]?: number };\n\nexport const MaxSensorRate = 2 ** 16 - 1;\nexport const SensorRateStep = 5;\n\nexport const SensorConfigurationMessageTypes = [\n  \"getSensorConfiguration\",\n  \"setSensorConfiguration\",\n] as const;\nexport type SensorConfigurationMessageType =\n  (typeof SensorConfigurationMessageTypes)[number];\n\nexport const SensorConfigurationEventTypes = SensorConfigurationMessageTypes;\nexport type SensorConfigurationEventType =\n  (typeof SensorConfigurationEventTypes)[number];\n\nexport interface SensorConfigurationEventMessages {\n  getSensorConfiguration: { sensorConfiguration: SensorConfiguration };\n}\n\nexport type SensorConfigurationEventDispatcher = EventDispatcher<\n  Device,\n  SensorConfigurationEventType,\n  SensorConfigurationEventMessages\n>;\n\nexport type SendSensorConfigurationMessageCallback =\n  SendMessageCallback<SensorConfigurationMessageType>;\n\nclass SensorConfigurationManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendSensorConfigurationMessageCallback;\n\n  eventDispatcher!: SensorConfigurationEventDispatcher;\n  get addEventListener() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  #availableSensorTypes!: SensorType[];\n  #assertAvailableSensorType(sensorType: SensorType) {\n    _console.assertWithError(\n      this.#availableSensorTypes,\n      \"must get initial sensorConfiguration\"\n    );\n    const isSensorTypeAvailable =\n      this.#availableSensorTypes?.includes(sensorType);\n    _console.log(\n      isSensorTypeAvailable,\n      `unavailable sensor type \"${sensorType}\"`\n    );\n    return isSensorTypeAvailable;\n  }\n\n  #configuration: SensorConfiguration = {};\n  get configuration() {\n    return this.#configuration;\n  }\n\n  #updateConfiguration(updatedConfiguration: SensorConfiguration) {\n    this.#configuration = updatedConfiguration;\n    _console.log({ updatedConfiguration: this.#configuration });\n    this.#dispatchEvent(\"getSensorConfiguration\", {\n      sensorConfiguration: this.configuration,\n    });\n  }\n\n  #isRedundant(sensorConfiguration: SensorConfiguration) {\n    let sensorTypes = Object.keys(sensorConfiguration) as SensorType[];\n    return sensorTypes.every((sensorType) => {\n      return this.configuration[sensorType] == sensorConfiguration[sensorType];\n    });\n  }\n\n  async setConfiguration(\n    newSensorConfiguration: SensorConfiguration,\n    clearRest?: boolean,\n    sendImmediately?: boolean\n  ) {\n    if (clearRest) {\n      newSensorConfiguration = Object.assign(\n        structuredClone(this.zeroSensorConfiguration),\n        newSensorConfiguration\n      );\n    }\n    _console.log({ newSensorConfiguration });\n    if (this.#isRedundant(newSensorConfiguration)) {\n      _console.log(\"redundant sensor configuration\");\n      return;\n    }\n    const setSensorConfigurationData = this.#createData(newSensorConfiguration);\n    _console.log({ setSensorConfigurationData });\n\n    const promise = this.waitForEvent(\"getSensorConfiguration\");\n    this.sendMessage(\n      [\n        {\n          type: \"setSensorConfiguration\",\n          data: setSensorConfigurationData.buffer,\n        },\n      ],\n      sendImmediately\n    );\n    await promise;\n  }\n\n  #parse(dataView: DataView) {\n    const parsedSensorConfiguration: SensorConfiguration = {};\n    for (\n      let byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      byteOffset += 3\n    ) {\n      const sensorTypeIndex = dataView.getUint8(byteOffset);\n      const sensorType = SensorTypes[sensorTypeIndex];\n\n      const sensorRate = dataView.getUint16(byteOffset + 1, true);\n      _console.log({ sensorType, sensorRate });\n\n      if (!sensorType) {\n        _console.warn(`unknown sensorType index ${sensorTypeIndex}`);\n        continue;\n      }\n      parsedSensorConfiguration[sensorType] = sensorRate;\n    }\n    _console.log({ parsedSensorConfiguration });\n    this.#availableSensorTypes = Object.keys(\n      parsedSensorConfiguration\n    ) as SensorType[];\n    return parsedSensorConfiguration;\n  }\n\n  static #AssertValidSensorRate(sensorRate: number) {\n    _console.assertTypeWithError(sensorRate, \"number\");\n    _console.assertWithError(\n      sensorRate >= 0,\n      `sensorRate must be 0 or greater (got ${sensorRate})`\n    );\n    _console.assertWithError(\n      sensorRate < MaxSensorRate,\n      `sensorRate must be 0 or greater (got ${sensorRate})`\n    );\n    _console.assertWithError(\n      sensorRate % SensorRateStep == 0,\n      `sensorRate must be multiple of ${SensorRateStep}`\n    );\n  }\n\n  #assertValidSensorRate(sensorRate: number) {\n    SensorConfigurationManager.#AssertValidSensorRate(sensorRate);\n  }\n\n  #createData(sensorConfiguration: SensorConfiguration) {\n    let sensorTypes = Object.keys(sensorConfiguration) as SensorType[];\n    sensorTypes = sensorTypes.filter((sensorType) =>\n      this.#assertAvailableSensorType(sensorType)\n    );\n\n    const dataView = new DataView(new ArrayBuffer(sensorTypes.length * 3));\n    sensorTypes.forEach((sensorType, index) => {\n      SensorDataManager.AssertValidSensorType(sensorType);\n      const sensorTypeEnum = SensorTypes.indexOf(sensorType);\n      dataView.setUint8(index * 3, sensorTypeEnum);\n\n      const sensorRate = sensorConfiguration[sensorType]!;\n      this.#assertValidSensorRate(sensorRate);\n      dataView.setUint16(index * 3 + 1, sensorRate, true);\n    });\n    _console.log({ sensorConfigurationData: dataView });\n    return dataView;\n  }\n\n  // ZERO\n  static #ZeroSensorConfiguration: SensorConfiguration = {};\n  static get ZeroSensorConfiguration() {\n    return this.#ZeroSensorConfiguration;\n  }\n  static {\n    SensorTypes.forEach((sensorType) => {\n      this.#ZeroSensorConfiguration[sensorType] = 0;\n    });\n  }\n  get zeroSensorConfiguration() {\n    const zeroSensorConfiguration: SensorConfiguration = {};\n    this.#availableSensorTypes.forEach((sensorType) => {\n      zeroSensorConfiguration[sensorType] = 0;\n    });\n    return zeroSensorConfiguration;\n  }\n  async clearSensorConfiguration() {\n    return this.setConfiguration(this.zeroSensorConfiguration);\n  }\n\n  // MESSAGE\n  parseMessage(\n    messageType: SensorConfigurationMessageType,\n    dataView: DataView\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getSensorConfiguration\":\n      case \"setSensorConfiguration\":\n        const newSensorConfiguration = this.#parse(dataView);\n        this.#updateConfiguration(newSensorConfiguration);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default SensorConfigurationManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport SensorDataManager, { SensorTypes } from \"./sensor/SensorDataManager.ts\";\nimport { arrayWithoutDuplicates } from \"./utils/ArrayUtils.ts\";\nimport { SensorRateStep } from \"./sensor/SensorConfigurationManager.ts\";\nimport { parseTimestamp } from \"./utils/MathUtils.ts\";\nimport { SensorType } from \"./sensor/SensorDataManager.ts\";\nimport Device, { SendMessageCallback } from \"./Device.ts\";\nimport autoBind from \"auto-bind\";\nimport { FileConfiguration as BaseFileConfiguration } from \"./FileTransferManager.ts\";\nimport { UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\n\nconst _console = createConsole(\"TfliteManager\", { log: false });\n\nexport const TfliteMessageTypes = [\n  \"getTfliteName\",\n  \"setTfliteName\",\n  \"getTfliteTask\",\n  \"setTfliteTask\",\n  \"getTfliteSampleRate\",\n  \"setTfliteSampleRate\",\n  \"getTfliteSensorTypes\",\n  \"setTfliteSensorTypes\",\n  \"tfliteIsReady\",\n  \"getTfliteCaptureDelay\",\n  \"setTfliteCaptureDelay\",\n  \"getTfliteThreshold\",\n  \"setTfliteThreshold\",\n  \"getTfliteInferencingEnabled\",\n  \"setTfliteInferencingEnabled\",\n  \"tfliteInference\",\n] as const;\nexport type TfliteMessageType = (typeof TfliteMessageTypes)[number];\n\nexport const TfliteEventTypes = TfliteMessageTypes;\nexport type TfliteEventType = (typeof TfliteEventTypes)[number];\n\nexport const RequiredTfliteMessageTypes: TfliteMessageType[] = [\n  \"getTfliteName\",\n  \"getTfliteTask\",\n  \"getTfliteSampleRate\",\n  \"getTfliteSensorTypes\",\n  \"tfliteIsReady\",\n  \"getTfliteCaptureDelay\",\n  \"getTfliteThreshold\",\n  \"getTfliteInferencingEnabled\",\n];\n\nexport const TfliteTasks = [\"classification\", \"regression\"] as const;\nexport type TfliteTask = (typeof TfliteTasks)[number];\n\nexport interface TfliteEventMessages {\n  getTfliteName: { tfliteName: string };\n  getTfliteTask: { tfliteTask: TfliteTask };\n  getTfliteSampleRate: { tfliteSampleRate: number };\n  getTfliteSensorTypes: { tfliteSensorTypes: SensorType[] };\n  tfliteIsReady: { tfliteIsReady: boolean };\n  getTfliteCaptureDelay: { tfliteCaptureDelay: number };\n  getTfliteThreshold: { tfliteThreshold: number };\n  getTfliteInferencingEnabled: { tfliteInferencingEnabled: boolean };\n  tfliteInference: { tfliteInference: TfliteInference };\n}\n\nexport interface TfliteInference {\n  timestamp: number;\n  values: number[];\n  maxValue?: number;\n  maxIndex?: number;\n  maxClass?: string;\n  classValues?: { [key: string]: number };\n}\n\nexport type TfliteEventDispatcher = EventDispatcher<\n  Device,\n  TfliteEventType,\n  TfliteEventMessages\n>;\nexport type SendTfliteMessageCallback = SendMessageCallback<TfliteMessageType>;\n\nexport const TfliteSensorTypes = [\n  \"pressure\",\n  \"linearAcceleration\",\n  \"gyroscope\",\n  \"magnetometer\",\n] as const satisfies readonly SensorType[];\nexport type TfliteSensorType = (typeof TfliteSensorTypes)[number];\n\nexport interface TfliteFileConfiguration extends BaseFileConfiguration {\n  type: \"tflite\";\n  name: string;\n  sensorTypes: TfliteSensorType[];\n  task: TfliteTask;\n  sampleRate: number;\n  captureDelay?: number;\n  threshold?: number;\n  classes?: string[];\n}\n\nclass TfliteManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendTfliteMessageCallback;\n\n  #assertValidTask(task: TfliteTask) {\n    _console.assertEnumWithError(task, TfliteTasks);\n  }\n  #assertValidTaskEnum(taskEnum: number) {\n    _console.assertWithError(\n      taskEnum in TfliteTasks,\n      `invalid taskEnum ${taskEnum}`\n    );\n  }\n\n  eventDispatcher!: TfliteEventDispatcher;\n  get addEventListenter() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  // PROPERTIES\n\n  #name!: string;\n  get name() {\n    return this.#name;\n  }\n  #parseName(dataView: DataView) {\n    _console.log(\"parseName\", dataView);\n    const name = textDecoder.decode(dataView.buffer);\n    this.#updateName(name);\n  }\n  #updateName(name: string) {\n    _console.log({ name });\n    this.#name = name;\n    this.#dispatchEvent(\"getTfliteName\", { tfliteName: name });\n  }\n  async setName(newName: string, sendImmediately?: boolean) {\n    _console.assertTypeWithError(newName, \"string\");\n    if (this.name == newName) {\n      _console.log(`redundant name assignment ${newName}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteName\");\n\n    const setNameData = textEncoder.encode(newName);\n    this.sendMessage(\n      [{ type: \"setTfliteName\", data: setNameData.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #task!: TfliteTask;\n  get task() {\n    return this.#task;\n  }\n  #parseTask(dataView: DataView) {\n    _console.log(\"parseTask\", dataView);\n    const taskEnum = dataView.getUint8(0);\n    this.#assertValidTaskEnum(taskEnum);\n    const task = TfliteTasks[taskEnum];\n    this.#updateTask(task);\n  }\n  #updateTask(task: TfliteTask) {\n    _console.log({ task });\n    this.#task = task;\n    this.#dispatchEvent(\"getTfliteTask\", { tfliteTask: task });\n  }\n  async setTask(newTask: TfliteTask, sendImmediately?: boolean) {\n    this.#assertValidTask(newTask);\n    if (this.task == newTask) {\n      _console.log(`redundant task assignment ${newTask}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteTask\");\n\n    const taskEnum = TfliteTasks.indexOf(newTask);\n    this.sendMessage(\n      [{ type: \"setTfliteTask\", data: UInt8ByteBuffer(taskEnum) }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #sampleRate!: number;\n  get sampleRate() {\n    return this.#sampleRate;\n  }\n  #parseSampleRate(dataView: DataView) {\n    _console.log(\"parseSampleRate\", dataView);\n    const sampleRate = dataView.getUint16(0, true);\n    this.#updateSampleRate(sampleRate);\n  }\n  #updateSampleRate(sampleRate: number) {\n    _console.log({ sampleRate });\n    this.#sampleRate = sampleRate;\n    this.#dispatchEvent(\"getTfliteSampleRate\", {\n      tfliteSampleRate: sampleRate,\n    });\n  }\n  async setSampleRate(newSampleRate: number, sendImmediately?: boolean) {\n    _console.assertTypeWithError(newSampleRate, \"number\");\n    newSampleRate -= newSampleRate % SensorRateStep;\n    _console.assertWithError(\n      newSampleRate >= SensorRateStep,\n      `sampleRate must be multiple of ${SensorRateStep} greater than 0 (got ${newSampleRate})`\n    );\n    if (this.#sampleRate == newSampleRate) {\n      _console.log(`redundant sampleRate assignment ${newSampleRate}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteSampleRate\");\n\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, newSampleRate, true);\n    this.sendMessage(\n      [{ type: \"setTfliteSampleRate\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  static AssertValidSensorType(sensorType: SensorType) {\n    SensorDataManager.AssertValidSensorType(sensorType);\n    const tfliteSensorType = sensorType as TfliteSensorType;\n    _console.assertWithError(\n      TfliteSensorTypes.includes(tfliteSensorType),\n      `invalid tflite sensorType \"${sensorType}\"`\n    );\n  }\n\n  #sensorTypes: TfliteSensorType[] = [];\n  get sensorTypes() {\n    return this.#sensorTypes.slice();\n  }\n  #parseSensorTypes(dataView: DataView) {\n    _console.log(\"parseSensorTypes\", dataView);\n    const sensorTypes: TfliteSensorType[] = [];\n    for (let index = 0; index < dataView.byteLength; index++) {\n      const sensorTypeEnum = dataView.getUint8(index);\n      const sensorType = SensorTypes[sensorTypeEnum] as TfliteSensorType;\n      if (sensorType) {\n        if (TfliteSensorTypes.includes(sensorType)) {\n          sensorTypes.push(sensorType);\n        } else {\n          _console.error(`invalid tfliteSensorType ${sensorType}`);\n        }\n      } else {\n        _console.error(`invalid sensorTypeEnum ${sensorTypeEnum}`);\n      }\n    }\n    this.#updateSensorTypes(sensorTypes);\n  }\n  #updateSensorTypes(sensorTypes: TfliteSensorType[]) {\n    _console.log({ sensorTypes });\n    this.#sensorTypes = sensorTypes;\n    this.#dispatchEvent(\"getTfliteSensorTypes\", {\n      tfliteSensorTypes: sensorTypes,\n    });\n  }\n  async setSensorTypes(\n    newSensorTypes: SensorType[],\n    sendImmediately?: boolean\n  ) {\n    newSensorTypes.forEach((sensorType) => {\n      TfliteManager.AssertValidSensorType(sensorType);\n    });\n\n    const promise = this.waitForEvent(\"getTfliteSensorTypes\");\n\n    newSensorTypes = arrayWithoutDuplicates(newSensorTypes);\n    const newSensorTypeEnums = newSensorTypes\n      .map((sensorType) => SensorTypes.indexOf(sensorType))\n      .sort();\n    _console.log(newSensorTypes, newSensorTypeEnums);\n    this.sendMessage(\n      [\n        {\n          type: \"setTfliteSensorTypes\",\n          data: Uint8Array.from(newSensorTypeEnums).buffer,\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #isReady!: boolean;\n  get isReady() {\n    return this.#isReady;\n  }\n  #parseIsReady(dataView: DataView) {\n    _console.log(\"parseIsReady\", dataView);\n    const isReady = Boolean(dataView.getUint8(0));\n    this.#updateIsReady(isReady);\n  }\n  #updateIsReady(isReady: boolean) {\n    _console.log({ isReady });\n    this.#isReady = isReady;\n    this.#dispatchEvent(\"tfliteIsReady\", { tfliteIsReady: isReady });\n  }\n  #assertIsReady() {\n    _console.assertWithError(this.isReady, `tflite is not ready`);\n  }\n\n  #captureDelay!: number;\n  get captureDelay() {\n    return this.#captureDelay;\n  }\n  #parseCaptureDelay(dataView: DataView) {\n    _console.log(\"parseCaptureDelay\", dataView);\n    const captureDelay = dataView.getUint16(0, true);\n    this.#updateCaptueDelay(captureDelay);\n  }\n  #updateCaptueDelay(captureDelay: number) {\n    _console.log({ captureDelay });\n    this.#captureDelay = captureDelay;\n    this.#dispatchEvent(\"getTfliteCaptureDelay\", {\n      tfliteCaptureDelay: captureDelay,\n    });\n  }\n  async setCaptureDelay(newCaptureDelay: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newCaptureDelay, \"number\");\n    if (this.#captureDelay == newCaptureDelay) {\n      _console.log(`redundant captureDelay assignment ${newCaptureDelay}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteCaptureDelay\");\n\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, newCaptureDelay, true);\n    this.sendMessage(\n      [{ type: \"setTfliteCaptureDelay\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #threshold!: number;\n  get threshold() {\n    return this.#threshold;\n  }\n  #parseThreshold(dataView: DataView) {\n    _console.log(\"parseThreshold\", dataView);\n    const threshold = dataView.getFloat32(0, true);\n    this.#updateThreshold(threshold);\n  }\n  #updateThreshold(threshold: number) {\n    _console.log({ threshold });\n    this.#threshold = threshold;\n    this.#dispatchEvent(\"getTfliteThreshold\", { tfliteThreshold: threshold });\n  }\n  async setThreshold(newThreshold: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newThreshold, \"number\");\n    _console.assertWithError(\n      newThreshold >= 0,\n      `threshold must be positive (got ${newThreshold})`\n    );\n    if (this.#threshold == newThreshold) {\n      _console.log(`redundant threshold assignment ${newThreshold}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteThreshold\");\n\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setFloat32(0, newThreshold, true);\n    this.sendMessage(\n      [{ type: \"setTfliteThreshold\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #inferencingEnabled!: boolean;\n  get inferencingEnabled() {\n    return this.#inferencingEnabled;\n  }\n  #parseInferencingEnabled(dataView: DataView) {\n    _console.log(\"parseInferencingEnabled\", dataView);\n    const inferencingEnabled = Boolean(dataView.getUint8(0));\n    this.#updateInferencingEnabled(inferencingEnabled);\n  }\n  #updateInferencingEnabled(inferencingEnabled: boolean) {\n    _console.log({ inferencingEnabled });\n    this.#inferencingEnabled = inferencingEnabled;\n    this.#dispatchEvent(\"getTfliteInferencingEnabled\", {\n      tfliteInferencingEnabled: inferencingEnabled,\n    });\n  }\n  async setInferencingEnabled(\n    newInferencingEnabled: boolean,\n    sendImmediately: boolean = true\n  ) {\n    _console.assertTypeWithError(newInferencingEnabled, \"boolean\");\n    if (!newInferencingEnabled && !this.isReady) {\n      return;\n    }\n    this.#assertIsReady();\n    if (this.#inferencingEnabled == newInferencingEnabled) {\n      _console.log(\n        `redundant inferencingEnabled assignment ${newInferencingEnabled}`\n      );\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteInferencingEnabled\");\n\n    this.sendMessage(\n      [\n        {\n          type: \"setTfliteInferencingEnabled\",\n\n          data: UInt8ByteBuffer(Number(newInferencingEnabled)),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  async toggleInferencingEnabled() {\n    return this.setInferencingEnabled(!this.inferencingEnabled);\n  }\n\n  async enableInferencing() {\n    if (this.inferencingEnabled) {\n      return;\n    }\n    this.setInferencingEnabled(true);\n  }\n  async disableInferencing() {\n    if (!this.inferencingEnabled) {\n      return;\n    }\n    this.setInferencingEnabled(false);\n  }\n\n  #parseInference(dataView: DataView) {\n    _console.log(\"parseInference\", dataView);\n\n    const timestamp = parseTimestamp(dataView, 0);\n    _console.log({ timestamp });\n\n    const values: number[] = [];\n    for (\n      let index = 0, byteOffset = 2;\n      byteOffset < dataView.byteLength;\n      index++, byteOffset += 4\n    ) {\n      const value = dataView.getFloat32(byteOffset, true);\n      values.push(value);\n    }\n    _console.log(\"values\", values);\n\n    const inference: TfliteInference = {\n      timestamp,\n      values,\n    };\n\n    if (this.task == \"classification\") {\n      let maxValue = 0;\n      let maxIndex = 0;\n      values.forEach((value, index) => {\n        if (value > maxValue) {\n          maxValue = value;\n          maxIndex = index;\n        }\n      });\n      _console.log({ maxIndex, maxValue });\n      inference.maxIndex = maxIndex;\n      inference.maxValue = maxValue;\n      if (this.#configuration?.classes) {\n        const { classes } = this.#configuration;\n        inference.maxClass = classes[maxIndex];\n        inference.classValues = {};\n        values.forEach((value, index) => {\n          const key = classes[index];\n          inference.classValues![key] = value;\n        });\n      }\n    }\n\n    this.#dispatchEvent(\"tfliteInference\", { tfliteInference: inference });\n  }\n\n  parseMessage(messageType: TfliteMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getTfliteName\":\n      case \"setTfliteName\":\n        this.#parseName(dataView);\n        break;\n      case \"getTfliteTask\":\n      case \"setTfliteTask\":\n        this.#parseTask(dataView);\n        break;\n      case \"getTfliteSampleRate\":\n      case \"setTfliteSampleRate\":\n        this.#parseSampleRate(dataView);\n        break;\n      case \"getTfliteSensorTypes\":\n      case \"setTfliteSensorTypes\":\n        this.#parseSensorTypes(dataView);\n        break;\n      case \"tfliteIsReady\":\n        this.#parseIsReady(dataView);\n        break;\n      case \"getTfliteCaptureDelay\":\n      case \"setTfliteCaptureDelay\":\n        this.#parseCaptureDelay(dataView);\n        break;\n      case \"getTfliteThreshold\":\n      case \"setTfliteThreshold\":\n        this.#parseThreshold(dataView);\n        break;\n      case \"getTfliteInferencingEnabled\":\n      case \"setTfliteInferencingEnabled\":\n        this.#parseInferencingEnabled(dataView);\n        break;\n      case \"tfliteInference\":\n        this.#parseInference(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  #configuration?: TfliteFileConfiguration;\n  get configuration() {\n    return this.#configuration;\n  }\n  sendConfiguration(\n    configuration: TfliteFileConfiguration,\n    sendImmediately?: boolean\n  ) {\n    if (configuration == this.#configuration) {\n      _console.log(\"redundant tflite configuration assignment\");\n      return;\n    }\n    this.#configuration = configuration;\n    _console.log(\"assigned new tflite configuration\", this.configuration);\n    if (!this.configuration) {\n      return;\n    }\n    const { name, task, captureDelay, sampleRate, threshold, sensorTypes } =\n      this.configuration;\n    this.setName(name, false);\n    this.setTask(task, false);\n    if (captureDelay != undefined) {\n      this.setCaptureDelay(captureDelay, false);\n    }\n    this.setSampleRate(sampleRate, false);\n    if (threshold != undefined) {\n      this.setThreshold(threshold, false);\n    }\n    this.setSensorTypes(sensorTypes, sendImmediately);\n  }\n\n  clear() {\n    this.#configuration = undefined;\n    this.#inferencingEnabled = false;\n    this.#sensorTypes = [];\n    this.#sampleRate = 0;\n    this.#isReady = false;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required tflite information\");\n    const messages = RequiredTfliteMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n}\n\nexport default TfliteManager;\n","import Device from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder } from \"./utils/Text.ts\";\n\nconst _console = createConsole(\"DeviceInformationManager\", { log: false });\n\nexport interface PnpId {\n  source: \"Bluetooth\" | \"USB\";\n  vendorId: number;\n  productId: number;\n  productVersion: number;\n}\n\nexport interface DeviceInformation {\n  manufacturerName: string;\n  modelNumber: string;\n  softwareRevision: string;\n  hardwareRevision: string;\n  firmwareRevision: string;\n  pnpId: PnpId;\n  serialNumber: string;\n}\n\nexport const DeviceInformationTypes = [\n  \"manufacturerName\",\n  \"modelNumber\",\n  \"hardwareRevision\",\n  \"firmwareRevision\",\n  \"softwareRevision\",\n  \"pnpId\",\n  \"serialNumber\",\n] as const;\nexport type DeviceInformationType = (typeof DeviceInformationTypes)[number];\n\nexport const DeviceInformationEventTypes = [\n  ...DeviceInformationTypes,\n  \"deviceInformation\",\n] as const;\nexport type DeviceInformationEventType =\n  (typeof DeviceInformationEventTypes)[number];\n\nexport interface DeviceInformationEventMessages {\n  manufacturerName: { manufacturerName: string };\n  modelNumber: { modelNumber: string };\n  softwareRevision: { softwareRevision: string };\n  hardwareRevision: { hardwareRevision: string };\n  firmwareRevision: { firmwareRevision: string };\n  pnpId: { pnpId: PnpId };\n  serialNumber: { serialNumber: string };\n  deviceInformation: { deviceInformation: DeviceInformation };\n}\n\nexport type DeviceInformationEventDispatcher = EventDispatcher<\n  Device,\n  DeviceInformationEventType,\n  DeviceInformationEventMessages\n>;\n\nclass DeviceInformationManager {\n  eventDispatcher!: DeviceInformationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  #information: Partial<DeviceInformation> = {};\n  get information() {\n    return this.#information as DeviceInformation;\n  }\n  clear() {\n    this.#information = {};\n  }\n  get #isComplete() {\n    return DeviceInformationTypes.filter((key) => key != \"serialNumber\").every(\n      (key) => key in this.#information\n    );\n  }\n\n  #update(partialDeviceInformation: Partial<DeviceInformation>) {\n    _console.log({ partialDeviceInformation });\n    const deviceInformationNames = Object.keys(\n      partialDeviceInformation\n    ) as (keyof DeviceInformation)[];\n    deviceInformationNames.forEach((deviceInformationName) => {\n      // @ts-expect-error\n      this.#dispatchEvent(deviceInformationName, {\n        [deviceInformationName]:\n          partialDeviceInformation[deviceInformationName],\n      });\n    });\n\n    Object.assign(this.#information, partialDeviceInformation);\n    _console.log({ deviceInformation: this.#information });\n    if (this.#isComplete) {\n      _console.log(\"completed deviceInformation\");\n      this.#dispatchEvent(\"deviceInformation\", {\n        deviceInformation: this.information,\n      });\n    }\n  }\n\n  parseMessage(messageType: DeviceInformationType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"manufacturerName\":\n        const manufacturerName = textDecoder.decode(dataView.buffer);\n        _console.log({ manufacturerName });\n        this.#update({ manufacturerName });\n        break;\n      case \"modelNumber\":\n        const modelNumber = textDecoder.decode(dataView.buffer);\n        _console.log({ modelNumber });\n        this.#update({ modelNumber });\n        break;\n      case \"softwareRevision\":\n        const softwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ softwareRevision });\n        this.#update({ softwareRevision });\n        break;\n      case \"hardwareRevision\":\n        const hardwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ hardwareRevision });\n        this.#update({ hardwareRevision });\n        break;\n      case \"firmwareRevision\":\n        const firmwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ firmwareRevision });\n        this.#update({ firmwareRevision });\n        break;\n      case \"pnpId\":\n        const pnpId: PnpId = {\n          source: dataView.getUint8(0) === 1 ? \"Bluetooth\" : \"USB\",\n          productId: dataView.getUint16(3, true),\n          productVersion: dataView.getUint16(5, true),\n          vendorId: 0,\n        };\n        if (pnpId.source == \"Bluetooth\") {\n          pnpId.vendorId = dataView.getUint16(1, true);\n        } else {\n          // no need to implement\n        }\n        _console.log({ pnpId });\n        this.#update({ pnpId });\n        break;\n      case \"serialNumber\":\n        const serialNumber = textDecoder.decode(dataView.buffer);\n        _console.log({ serialNumber });\n        // will only be used for node\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default DeviceInformationManager;\n","import { ConnectionType } from \"./connection/BaseConnectionManager.ts\";\nimport Device, { SendMessageCallback } from \"./Device.ts\";\nimport { UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { Uint16Max } from \"./utils/MathUtils.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"InformationManager\", { log: false });\n\nexport const DeviceTypes = [\n  \"leftInsole\",\n  \"rightInsole\",\n  \"leftGlove\",\n  \"rightGlove\",\n  \"glasses\",\n  \"generic\",\n] as const;\nexport type DeviceType = (typeof DeviceTypes)[number];\n\nexport const Sides = [\"left\", \"right\"] as const;\nexport type Side = (typeof Sides)[number];\n\nexport const MinNameLength = 2;\nexport const MaxNameLength = 30;\n\nexport const InformationMessageTypes = [\n  \"isCharging\",\n  \"getBatteryCurrent\",\n  \"getMtu\",\n  \"getId\",\n  \"getName\",\n  \"setName\",\n  \"getType\",\n  \"setType\",\n  \"getCurrentTime\",\n  \"setCurrentTime\",\n] as const;\nexport type InformationMessageType = (typeof InformationMessageTypes)[number];\n\nexport const InformationEventTypes = InformationMessageTypes;\nexport type InformationEventType = (typeof InformationEventTypes)[number];\n\nexport interface InformationEventMessages {\n  isCharging: { isCharging: boolean };\n  getBatteryCurrent: { batteryCurrent: number };\n  getMtu: { mtu: number };\n  getId: { id: string };\n  getName: { name: string };\n  getType: { type: DeviceType };\n  getCurrentTime: { currentTime: number };\n}\n\nexport type InformationEventDispatcher = EventDispatcher<\n  Device,\n  InformationEventType,\n  InformationEventMessages\n>;\nexport type SendInformationMessageCallback =\n  SendMessageCallback<InformationMessageType>;\n\nclass InformationManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendInformationMessageCallback;\n\n  eventDispatcher!: InformationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  // PROPERTIES\n\n  #isCharging = false;\n  get isCharging() {\n    return this.#isCharging;\n  }\n  #updateIsCharging(updatedIsCharging: boolean) {\n    _console.assertTypeWithError(updatedIsCharging, \"boolean\");\n    this.#isCharging = updatedIsCharging;\n    _console.log({ isCharging: this.#isCharging });\n    this.#dispatchEvent(\"isCharging\", { isCharging: this.#isCharging });\n  }\n\n  #batteryCurrent!: number;\n  get batteryCurrent() {\n    return this.#batteryCurrent;\n  }\n  async getBatteryCurrent() {\n    _console.log(\"getting battery current...\");\n    const promise = this.waitForEvent(\"getBatteryCurrent\");\n    this.sendMessage([{ type: \"getBatteryCurrent\" }]);\n    await promise;\n  }\n  #updateBatteryCurrent(updatedBatteryCurrent: number) {\n    _console.assertTypeWithError(updatedBatteryCurrent, \"number\");\n    this.#batteryCurrent = updatedBatteryCurrent;\n    _console.log({ batteryCurrent: this.#batteryCurrent });\n    this.#dispatchEvent(\"getBatteryCurrent\", {\n      batteryCurrent: this.#batteryCurrent,\n    });\n  }\n\n  #id!: string;\n  get id() {\n    return this.#id;\n  }\n  #updateId(updatedId: string) {\n    _console.assertTypeWithError(updatedId, \"string\");\n    this.#id = updatedId;\n    _console.log({ id: this.#id });\n    this.#dispatchEvent(\"getId\", { id: this.#id });\n  }\n\n  #name = \"\";\n  get name() {\n    return this.#name;\n  }\n\n  updateName(updatedName: string) {\n    _console.assertTypeWithError(updatedName, \"string\");\n    this.#name = updatedName;\n    _console.log({ updatedName: this.#name });\n    this.#dispatchEvent(\"getName\", { name: this.#name });\n  }\n  async setName(newName: string) {\n    _console.assertTypeWithError(newName, \"string\");\n    _console.assertRangeWithError(\n      \"newName\",\n      newName.length,\n      MinNameLength,\n      MaxNameLength\n    );\n    const setNameData = textEncoder.encode(newName);\n    _console.log({ setNameData });\n\n    const promise = this.waitForEvent(\"getName\");\n    this.sendMessage([{ type: \"setName\", data: setNameData.buffer }]);\n    await promise;\n  }\n\n  // TYPE\n  #type!: DeviceType;\n  get type() {\n    return this.#type;\n  }\n  get typeEnum() {\n    return DeviceTypes.indexOf(this.type);\n  }\n  #assertValidDeviceType(type: DeviceType) {\n    _console.assertEnumWithError(type, DeviceTypes);\n  }\n  #assertValidDeviceTypeEnum(typeEnum: number) {\n    _console.assertTypeWithError(typeEnum, \"number\");\n    _console.assertWithError(\n      typeEnum in DeviceTypes,\n      `invalid typeEnum ${typeEnum}`\n    );\n  }\n  updateType(updatedType: DeviceType) {\n    this.#assertValidDeviceType(updatedType);\n    // if (updatedType == this.type) {\n    //   _console.log(\"redundant type assignment\");\n    //   return;\n    // }\n    this.#type = updatedType;\n    _console.log({ updatedType: this.#type });\n\n    this.#dispatchEvent(\"getType\", { type: this.#type });\n  }\n  async #setTypeEnum(newTypeEnum: number) {\n    this.#assertValidDeviceTypeEnum(newTypeEnum);\n\n    const setTypeData = UInt8ByteBuffer(newTypeEnum);\n    _console.log({ setTypeData });\n    const promise = this.waitForEvent(\"getType\");\n    this.sendMessage([{ type: \"setType\", data: setTypeData }]);\n    await promise;\n  }\n  async setType(newType: DeviceType) {\n    this.#assertValidDeviceType(newType);\n    const newTypeEnum = DeviceTypes.indexOf(newType);\n    this.#setTypeEnum(newTypeEnum);\n  }\n\n  get isInsole() {\n    switch (this.type) {\n      case \"leftInsole\":\n      case \"rightInsole\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  get isGlove() {\n    switch (this.type) {\n      case \"leftGlove\":\n      case \"rightGlove\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  get side(): Side {\n    switch (this.type) {\n      case \"leftInsole\":\n      case \"leftGlove\":\n        return \"left\";\n      case \"rightInsole\":\n      case \"rightGlove\":\n        return \"right\";\n      default:\n        return \"left\";\n    }\n  }\n\n  #mtu = 0;\n  get mtu() {\n    return this.#mtu;\n  }\n  #updateMtu(newMtu: number) {\n    _console.assertTypeWithError(newMtu, \"number\");\n    if (this.#mtu == newMtu) {\n      _console.log(\"redundant mtu assignment\", newMtu);\n      return;\n    }\n    this.#mtu = newMtu;\n\n    this.#dispatchEvent(\"getMtu\", { mtu: this.#mtu });\n  }\n\n  #isCurrentTimeSet = false;\n  get isCurrentTimeSet() {\n    return this.#isCurrentTimeSet;\n  }\n\n  #onCurrentTime(currentTime: number) {\n    _console.log({ currentTime });\n    this.#isCurrentTimeSet =\n      currentTime != 0 || Math.abs(Date.now() - currentTime) < Uint16Max;\n    if (!this.#isCurrentTimeSet) {\n      this.#setCurrentTime(false);\n    }\n  }\n  async #setCurrentTime(sendImmediately?: boolean) {\n    _console.log(\"setting current time...\");\n    const dataView = new DataView(new ArrayBuffer(8));\n    dataView.setBigUint64(0, BigInt(Date.now()), true);\n    const promise = this.waitForEvent(\"getCurrentTime\");\n    this.sendMessage(\n      [{ type: \"setCurrentTime\", data: dataView.buffer }],\n      sendImmediately\n    );\n    await promise;\n  }\n\n  // MESSAGE\n  parseMessage(messageType: InformationMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"isCharging\":\n        const isCharging = Boolean(dataView.getUint8(0));\n        _console.log({ isCharging });\n        this.#updateIsCharging(isCharging);\n        break;\n      case \"getBatteryCurrent\":\n        const batteryCurrent = dataView.getFloat32(0, true);\n        _console.log({ batteryCurrent });\n        this.#updateBatteryCurrent(batteryCurrent);\n        break;\n      case \"getId\":\n        const id = textDecoder.decode(dataView.buffer);\n        _console.log({ id });\n        this.#updateId(id);\n        break;\n      case \"getName\":\n      case \"setName\":\n        const name = textDecoder.decode(dataView.buffer);\n        _console.log({ name });\n        this.updateName(name);\n        break;\n      case \"getType\":\n      case \"setType\":\n        const typeEnum = dataView.getUint8(0);\n        const type = DeviceTypes[typeEnum];\n        _console.log({ typeEnum, type });\n        this.updateType(type);\n        break;\n      case \"getMtu\":\n        let mtu = dataView.getUint16(0, true);\n        if (\n          this.connectionType != \"webSocket\" &&\n          this.connectionType != \"udp\"\n        ) {\n          mtu = Math.min(mtu, 512);\n        }\n        _console.log({ mtu });\n        this.#updateMtu(mtu);\n        break;\n      case \"getCurrentTime\":\n      case \"setCurrentTime\":\n        const currentTime = Number(dataView.getBigUint64(0, true));\n        this.#onCurrentTime(currentTime);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    this.#isCurrentTimeSet = false;\n  }\n\n  connectionType?: ConnectionType;\n}\n\nexport default InformationManager;\n","export const VibrationWaveformEffects = [\n  \"none\",\n  \"strongClick100\",\n  \"strongClick60\",\n  \"strongClick30\",\n  \"sharpClick100\",\n  \"sharpClick60\",\n  \"sharpClick30\",\n  \"softBump100\",\n  \"softBump60\",\n  \"softBump30\",\n  \"doubleClick100\",\n  \"doubleClick60\",\n  \"tripleClick100\",\n  \"softFuzz60\",\n  \"strongBuzz100\",\n  \"alert750ms\",\n  \"alert1000ms\",\n  \"strongClick1_100\",\n  \"strongClick2_80\",\n  \"strongClick3_60\",\n  \"strongClick4_30\",\n  \"mediumClick100\",\n  \"mediumClick80\",\n  \"mediumClick60\",\n  \"sharpTick100\",\n  \"sharpTick80\",\n  \"sharpTick60\",\n  \"shortDoubleClickStrong100\",\n  \"shortDoubleClickStrong80\",\n  \"shortDoubleClickStrong60\",\n  \"shortDoubleClickStrong30\",\n  \"shortDoubleClickMedium100\",\n  \"shortDoubleClickMedium80\",\n  \"shortDoubleClickMedium60\",\n  \"shortDoubleSharpTick100\",\n  \"shortDoubleSharpTick80\",\n  \"shortDoubleSharpTick60\",\n  \"longDoubleSharpClickStrong100\",\n  \"longDoubleSharpClickStrong80\",\n  \"longDoubleSharpClickStrong60\",\n  \"longDoubleSharpClickStrong30\",\n  \"longDoubleSharpClickMedium100\",\n  \"longDoubleSharpClickMedium80\",\n  \"longDoubleSharpClickMedium60\",\n  \"longDoubleSharpTick100\",\n  \"longDoubleSharpTick80\",\n  \"longDoubleSharpTick60\",\n  \"buzz100\",\n  \"buzz80\",\n  \"buzz60\",\n  \"buzz40\",\n  \"buzz20\",\n  \"pulsingStrong100\",\n  \"pulsingStrong60\",\n  \"pulsingMedium100\",\n  \"pulsingMedium60\",\n  \"pulsingSharp100\",\n  \"pulsingSharp60\",\n  \"transitionClick100\",\n  \"transitionClick80\",\n  \"transitionClick60\",\n  \"transitionClick40\",\n  \"transitionClick20\",\n  \"transitionClick10\",\n  \"transitionHum100\",\n  \"transitionHum80\",\n  \"transitionHum60\",\n  \"transitionHum40\",\n  \"transitionHum20\",\n  \"transitionHum10\",\n  \"transitionRampDownLongSmooth2_100\",\n  \"transitionRampDownLongSmooth1_100\",\n  \"transitionRampDownMediumSmooth1_100\",\n  \"transitionRampDownMediumSmooth2_100\",\n  \"transitionRampDownShortSmooth1_100\",\n  \"transitionRampDownShortSmooth2_100\",\n  \"transitionRampDownLongSharp1_100\",\n  \"transitionRampDownLongSharp2_100\",\n  \"transitionRampDownMediumSharp1_100\",\n  \"transitionRampDownMediumSharp2_100\",\n  \"transitionRampDownShortSharp1_100\",\n  \"transitionRampDownShortSharp2_100\",\n  \"transitionRampUpLongSmooth1_100\",\n  \"transitionRampUpLongSmooth2_100\",\n  \"transitionRampUpMediumSmooth1_100\",\n  \"transitionRampUpMediumSmooth2_100\",\n  \"transitionRampUpShortSmooth1_100\",\n  \"transitionRampUpShortSmooth2_100\",\n  \"transitionRampUpLongSharp1_100\",\n  \"transitionRampUpLongSharp2_100\",\n  \"transitionRampUpMediumSharp1_100\",\n  \"transitionRampUpMediumSharp2_100\",\n  \"transitionRampUpShortSharp1_100\",\n  \"transitionRampUpShortSharp2_100\",\n  \"transitionRampDownLongSmooth1_50\",\n  \"transitionRampDownLongSmooth2_50\",\n  \"transitionRampDownMediumSmooth1_50\",\n  \"transitionRampDownMediumSmooth2_50\",\n  \"transitionRampDownShortSmooth1_50\",\n  \"transitionRampDownShortSmooth2_50\",\n  \"transitionRampDownLongSharp1_50\",\n  \"transitionRampDownLongSharp2_50\",\n  \"transitionRampDownMediumSharp1_50\",\n  \"transitionRampDownMediumSharp2_50\",\n  \"transitionRampDownShortSharp1_50\",\n  \"transitionRampDownShortSharp2_50\",\n  \"transitionRampUpLongSmooth1_50\",\n  \"transitionRampUpLongSmooth2_50\",\n  \"transitionRampUpMediumSmooth1_50\",\n  \"transitionRampUpMediumSmooth2_50\",\n  \"transitionRampUpShortSmooth1_50\",\n  \"transitionRampUpShortSmooth2_50\",\n  \"transitionRampUpLongSharp1_50\",\n  \"transitionRampUpLongSharp2_50\",\n  \"transitionRampUpMediumSharp1_50\",\n  \"transitionRampUpMediumSharp2_50\",\n  \"transitionRampUpShortSharp1_50\",\n  \"transitionRampUpShortSharp2_50\",\n  \"longBuzz100\",\n  \"smoothHum50\",\n  \"smoothHum40\",\n  \"smoothHum30\",\n  \"smoothHum20\",\n  \"smoothHum10\",\n] as const;\n\nexport type VibrationWaveformEffect = (typeof VibrationWaveformEffects)[number];\n","import { createConsole } from \"../utils/Console.ts\";\nimport {\n  VibrationWaveformEffect,\n  VibrationWaveformEffects,\n} from \"./VibrationWaveformEffects.ts\";\nimport { concatenateArrayBuffers } from \"../utils/ArrayBufferUtils.ts\";\nimport Device, { SendMessageCallback } from \"../Device.ts\";\nimport autoBind from \"auto-bind\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\n\nconst _console = createConsole(\"VibrationManager\", { log: false });\n\nexport const VibrationLocations = [\"front\", \"rear\"] as const;\nexport type VibrationLocation = (typeof VibrationLocations)[number];\n\nexport const VibrationTypes = [\"waveformEffect\", \"waveform\"] as const;\nexport type VibrationType = (typeof VibrationTypes)[number];\n\nexport interface VibrationWaveformEffectSegment {\n  effect?: VibrationWaveformEffect;\n  delay?: number;\n  loopCount?: number;\n}\n\nexport interface VibrationWaveformSegment {\n  duration: number;\n  amplitude: number;\n}\n\nexport const VibrationMessageTypes = [\n  \"getVibrationLocations\",\n  \"triggerVibration\",\n] as const;\nexport type VibrationMessageType = (typeof VibrationMessageTypes)[number];\n\nexport const VibrationEventTypes = VibrationMessageTypes;\nexport type VibrationEventType = (typeof VibrationEventTypes)[number];\n\nexport interface VibrationEventMessages {\n  getVibrationLocations: { vibrationLocations: VibrationLocation[] };\n}\n\nexport const MaxNumberOfVibrationWaveformEffectSegments = 8;\nexport const MaxVibrationWaveformSegmentDuration = 2550;\nexport const MaxVibrationWaveformEffectSegmentDelay = 1270;\nexport const MaxVibrationWaveformEffectSegmentLoopCount = 3;\nexport const MaxNumberOfVibrationWaveformSegments = 20;\nexport const MaxVibrationWaveformEffectSequenceLoopCount = 6;\n\ninterface BaseVibrationConfiguration {\n  type: VibrationType;\n  locations?: VibrationLocation[];\n}\n\nexport interface VibrationWaveformEffectConfiguration\n  extends BaseVibrationConfiguration {\n  type: \"waveformEffect\";\n  segments: VibrationWaveformEffectSegment[];\n  loopCount?: number;\n}\n\nexport interface VibrationWaveformConfiguration\n  extends BaseVibrationConfiguration {\n  type: \"waveform\";\n  segments: VibrationWaveformSegment[];\n}\n\nexport type VibrationConfiguration =\n  | VibrationWaveformEffectConfiguration\n  | VibrationWaveformConfiguration;\n\nexport type SendVibrationMessageCallback =\n  SendMessageCallback<VibrationMessageType>;\n\nexport type VibrationEventDispatcher = EventDispatcher<\n  Device,\n  VibrationEventType,\n  VibrationEventMessages\n>;\n\nclass VibrationManager {\n  constructor() {\n    autoBind(this);\n  }\n  sendMessage!: SendVibrationMessageCallback;\n\n  eventDispatcher!: VibrationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  #verifyLocation(location: VibrationLocation) {\n    _console.assertTypeWithError(location, \"string\");\n    _console.assertWithError(\n      VibrationLocations.includes(location),\n      `invalid location \"${location}\"`\n    );\n  }\n  #verifyLocations(locations: VibrationLocation[]) {\n    this.#assertNonEmptyArray(locations);\n    locations.forEach((location) => {\n      this.#verifyLocation(location);\n    });\n  }\n  #createLocationsBitmask(locations: VibrationLocation[]) {\n    this.#verifyLocations(locations);\n\n    let locationsBitmask = 0;\n    locations.forEach((location) => {\n      const locationIndex = VibrationLocations.indexOf(location);\n      locationsBitmask |= 1 << locationIndex;\n    });\n    _console.log({ locationsBitmask });\n    _console.assertWithError(\n      locationsBitmask > 0,\n      `locationsBitmask must not be zero`\n    );\n    return locationsBitmask;\n  }\n\n  #assertNonEmptyArray(array: any[]) {\n    _console.assertWithError(Array.isArray(array), \"passed non-array\");\n    _console.assertWithError(array.length > 0, \"passed empty array\");\n  }\n\n  #verifyWaveformEffect(waveformEffect: VibrationWaveformEffect) {\n    _console.assertWithError(\n      VibrationWaveformEffects.includes(waveformEffect),\n      `invalid waveformEffect \"${waveformEffect}\"`\n    );\n  }\n\n  #verifyWaveformEffectSegment(\n    waveformEffectSegment: VibrationWaveformEffectSegment\n  ) {\n    if (waveformEffectSegment.effect != undefined) {\n      const waveformEffect = waveformEffectSegment.effect;\n      this.#verifyWaveformEffect(waveformEffect);\n    } else if (waveformEffectSegment.delay != undefined) {\n      const { delay } = waveformEffectSegment;\n      _console.assertWithError(\n        delay >= 0,\n        `delay must be 0ms or greater (got ${delay})`\n      );\n      _console.assertWithError(\n        delay <= MaxVibrationWaveformEffectSegmentDelay,\n        `delay must be ${MaxVibrationWaveformEffectSegmentDelay}ms or less (got ${delay})`\n      );\n    } else {\n      throw Error(\"no effect or delay found in waveformEffectSegment\");\n    }\n\n    if (waveformEffectSegment.loopCount != undefined) {\n      const { loopCount } = waveformEffectSegment;\n      this.#verifyWaveformEffectSegmentLoopCount(loopCount);\n    }\n  }\n\n  #verifyWaveformEffectSegmentLoopCount(\n    waveformEffectSegmentLoopCount: number\n  ) {\n    _console.assertTypeWithError(waveformEffectSegmentLoopCount, \"number\");\n    _console.assertWithError(\n      waveformEffectSegmentLoopCount >= 0,\n      `waveformEffectSegmentLoopCount must be 0 or greater (got ${waveformEffectSegmentLoopCount})`\n    );\n    _console.assertWithError(\n      waveformEffectSegmentLoopCount <=\n        MaxVibrationWaveformEffectSegmentLoopCount,\n      `waveformEffectSegmentLoopCount must be ${MaxVibrationWaveformEffectSegmentLoopCount} or fewer (got ${waveformEffectSegmentLoopCount})`\n    );\n  }\n\n  #verifyWaveformEffectSegments(\n    waveformEffectSegments: VibrationWaveformEffectSegment[]\n  ) {\n    this.#assertNonEmptyArray(waveformEffectSegments);\n    _console.assertWithError(\n      waveformEffectSegments.length <=\n        MaxNumberOfVibrationWaveformEffectSegments,\n      `must have ${MaxNumberOfVibrationWaveformEffectSegments} waveformEffectSegments or fewer (got ${waveformEffectSegments.length})`\n    );\n    waveformEffectSegments.forEach((waveformEffectSegment) => {\n      this.#verifyWaveformEffectSegment(waveformEffectSegment);\n    });\n  }\n\n  #verifyWaveformEffectSequenceLoopCount(\n    waveformEffectSequenceLoopCount: number\n  ) {\n    _console.assertTypeWithError(waveformEffectSequenceLoopCount, \"number\");\n    _console.assertWithError(\n      waveformEffectSequenceLoopCount >= 0,\n      `waveformEffectSequenceLoopCount must be 0 or greater (got ${waveformEffectSequenceLoopCount})`\n    );\n    _console.assertWithError(\n      waveformEffectSequenceLoopCount <=\n        MaxVibrationWaveformEffectSequenceLoopCount,\n      `waveformEffectSequenceLoopCount must be ${MaxVibrationWaveformEffectSequenceLoopCount} or fewer (got ${waveformEffectSequenceLoopCount})`\n    );\n  }\n\n  #verifyWaveformSegment(waveformSegment: VibrationWaveformSegment) {\n    _console.assertTypeWithError(waveformSegment.amplitude, \"number\");\n    _console.assertWithError(\n      waveformSegment.amplitude >= 0,\n      `amplitude must be 0 or greater (got ${waveformSegment.amplitude})`\n    );\n    _console.assertWithError(\n      waveformSegment.amplitude <= 1,\n      `amplitude must be 1 or less (got ${waveformSegment.amplitude})`\n    );\n\n    _console.assertTypeWithError(waveformSegment.duration, \"number\");\n    _console.assertWithError(\n      waveformSegment.duration > 0,\n      `duration must be greater than 0ms (got ${waveformSegment.duration}ms)`\n    );\n    _console.assertWithError(\n      waveformSegment.duration <= MaxVibrationWaveformSegmentDuration,\n      `duration must be ${MaxVibrationWaveformSegmentDuration}ms or less (got ${waveformSegment.duration}ms)`\n    );\n  }\n\n  #verifyWaveformSegments(waveformSegments: VibrationWaveformSegment[]) {\n    this.#assertNonEmptyArray(waveformSegments);\n    _console.assertWithError(\n      waveformSegments.length <= MaxNumberOfVibrationWaveformSegments,\n      `must have ${MaxNumberOfVibrationWaveformSegments} waveformSegments or fewer (got ${waveformSegments.length})`\n    );\n    waveformSegments.forEach((waveformSegment) => {\n      this.#verifyWaveformSegment(waveformSegment);\n    });\n  }\n\n  #createWaveformEffectsData(\n    locations: VibrationLocation[],\n    waveformEffectSegments: VibrationWaveformEffectSegment[],\n    waveformEffectSequenceLoopCount: number = 0\n  ) {\n    this.#verifyWaveformEffectSegments(waveformEffectSegments);\n    this.#verifyWaveformEffectSequenceLoopCount(\n      waveformEffectSequenceLoopCount\n    );\n\n    let dataArray = [];\n    let byteOffset = 0;\n\n    const hasAtLeast1WaveformEffectWithANonzeroLoopCount =\n      waveformEffectSegments.some((waveformEffectSegment) => {\n        const { loopCount } = waveformEffectSegment;\n        return loopCount != undefined && loopCount > 0;\n      });\n\n    const includeAllWaveformEffectSegments =\n      hasAtLeast1WaveformEffectWithANonzeroLoopCount ||\n      waveformEffectSequenceLoopCount != 0;\n\n    for (\n      let index = 0;\n      index < waveformEffectSegments.length ||\n      (includeAllWaveformEffectSegments &&\n        index < MaxNumberOfVibrationWaveformEffectSegments);\n      index++\n    ) {\n      const waveformEffectSegment = waveformEffectSegments[index] || {\n        effect: \"none\",\n      };\n      if (waveformEffectSegment.effect != undefined) {\n        const waveformEffect = waveformEffectSegment.effect;\n        dataArray[byteOffset++] =\n          VibrationWaveformEffects.indexOf(waveformEffect);\n      } else if (waveformEffectSegment.delay != undefined) {\n        const { delay } = waveformEffectSegment;\n        dataArray[byteOffset++] = (1 << 7) | Math.floor(delay / 10); // set most significant bit to 1\n      } else {\n        throw Error(\"invalid waveformEffectSegment\");\n      }\n    }\n\n    const includeAllWaveformEffectSegmentLoopCounts =\n      waveformEffectSequenceLoopCount != 0;\n    for (\n      let index = 0;\n      index < waveformEffectSegments.length ||\n      (includeAllWaveformEffectSegmentLoopCounts &&\n        index < MaxNumberOfVibrationWaveformEffectSegments);\n      index++\n    ) {\n      const waveformEffectSegmentLoopCount =\n        waveformEffectSegments[index]?.loopCount || 0;\n      if (index == 0 || index == 4) {\n        dataArray[byteOffset] = 0;\n      }\n      const bitOffset = 2 * (index % 4);\n      dataArray[byteOffset] |= waveformEffectSegmentLoopCount << bitOffset;\n      if (index == 3 || index == 7) {\n        byteOffset++;\n      }\n    }\n\n    if (waveformEffectSequenceLoopCount != 0) {\n      dataArray[byteOffset++] = waveformEffectSequenceLoopCount;\n    }\n    const dataView = new DataView(Uint8Array.from(dataArray).buffer);\n    _console.log({ dataArray, dataView });\n    return this.#createData(locations, \"waveformEffect\", dataView);\n  }\n  #createWaveformData(\n    locations: VibrationLocation[],\n    waveformSegments: VibrationWaveformSegment[]\n  ) {\n    this.#verifyWaveformSegments(waveformSegments);\n    const dataView = new DataView(new ArrayBuffer(waveformSegments.length * 2));\n    waveformSegments.forEach((waveformSegment, index) => {\n      dataView.setUint8(index * 2, Math.floor(waveformSegment.amplitude * 127));\n      dataView.setUint8(\n        index * 2 + 1,\n        Math.floor(waveformSegment.duration / 10)\n      );\n    });\n    _console.log({ dataView });\n    return this.#createData(locations, \"waveform\", dataView);\n  }\n\n  #verifyVibrationType(vibrationType: VibrationType) {\n    _console.assertTypeWithError(vibrationType, \"string\");\n    _console.assertWithError(\n      VibrationTypes.includes(vibrationType),\n      `invalid vibrationType \"${vibrationType}\"`\n    );\n  }\n\n  #createData(\n    locations: VibrationLocation[],\n    vibrationType: VibrationType,\n    dataView: DataView\n  ) {\n    _console.assertWithError(dataView?.byteLength > 0, \"no data received\");\n    const locationsBitmask = this.#createLocationsBitmask(locations);\n    this.#verifyVibrationType(vibrationType);\n    const vibrationTypeIndex = VibrationTypes.indexOf(vibrationType);\n    _console.log({ locationsBitmask, vibrationTypeIndex, dataView });\n    const data = concatenateArrayBuffers(\n      locationsBitmask,\n      vibrationTypeIndex,\n      dataView.byteLength,\n      dataView\n    );\n    _console.log({ data });\n    return data;\n  }\n\n  async triggerVibration(\n    vibrationConfigurations: VibrationConfiguration[],\n    sendImmediately: boolean = true\n  ) {\n    let triggerVibrationData!: ArrayBuffer;\n    vibrationConfigurations.forEach((vibrationConfiguration) => {\n      const { type } = vibrationConfiguration;\n\n      let { locations } = vibrationConfiguration;\n      locations = locations || this.vibrationLocations.slice();\n      locations = locations.filter((location) =>\n        this.vibrationLocations.includes(location)\n      );\n\n      let arrayBuffer: ArrayBuffer;\n\n      switch (type) {\n        case \"waveformEffect\":\n          {\n            const { segments, loopCount } = vibrationConfiguration;\n            arrayBuffer = this.#createWaveformEffectsData(\n              locations,\n              segments,\n              loopCount\n            );\n          }\n          break;\n        case \"waveform\":\n          {\n            const { segments } = vibrationConfiguration;\n            arrayBuffer = this.#createWaveformData(locations, segments);\n          }\n          break;\n        default:\n          throw Error(`invalid vibration type \"${type}\"`);\n      }\n      _console.log({ type, arrayBuffer });\n      triggerVibrationData = concatenateArrayBuffers(\n        triggerVibrationData,\n        arrayBuffer\n      );\n    });\n    await this.sendMessage(\n      [{ type: \"triggerVibration\", data: triggerVibrationData }],\n      sendImmediately\n    );\n  }\n\n  #vibrationLocations: VibrationLocation[] = [];\n  get vibrationLocations() {\n    return this.#vibrationLocations;\n  }\n  #onVibrationLocations(vibrationLocations: VibrationLocation[]) {\n    this.#vibrationLocations = vibrationLocations;\n    _console.log(\"vibrationLocations\", vibrationLocations);\n    this.#dispatchEvent(\"getVibrationLocations\", {\n      vibrationLocations: this.#vibrationLocations,\n    });\n  }\n\n  // MESSAGE\n  parseMessage(messageType: VibrationMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getVibrationLocations\":\n        const vibrationLocations = Array.from(new Uint8Array(dataView.buffer))\n          .map((index) => VibrationLocations[index])\n          .filter(Boolean);\n        this.#onVibrationLocations(vibrationLocations);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default VibrationManager;\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport { UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInNode } from \"./utils/environment.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"WifiManager\", { log: false });\n\nexport const MinWifiSSIDLength = 1;\nexport const MaxWifiSSIDLength = 32;\n\nexport const MinWifiPasswordLength = 8;\nexport const MaxWifiPasswordLength = 64;\n\nexport const WifiMessageTypes = [\n  \"isWifiAvailable\",\n  \"getWifiSSID\",\n  \"setWifiSSID\",\n  \"getWifiPassword\",\n  \"setWifiPassword\",\n  \"getWifiConnectionEnabled\",\n  \"setWifiConnectionEnabled\",\n  \"isWifiConnected\",\n  \"ipAddress\",\n  \"isWifiSecure\",\n] as const;\nexport type WifiMessageType = (typeof WifiMessageTypes)[number];\n\nexport const RequiredWifiMessageTypes: WifiMessageType[] = [\n  \"getWifiSSID\",\n  \"getWifiPassword\",\n  \"getWifiConnectionEnabled\",\n  \"isWifiConnected\",\n  \"ipAddress\",\n  \"isWifiSecure\",\n] as const;\n\nexport const WifiEventTypes = WifiMessageTypes;\nexport type WifiEventType = (typeof WifiEventTypes)[number];\n\nexport interface WifiEventMessages {\n  isWifiAvailable: { isWifiAvailable: boolean };\n  getWifiSSID: { wifiSSID: string };\n  getWifiPassword: { wifiPassword: string };\n  getEnableWifiConnection: { wifiConnectionEnabled: boolean };\n  isWifiConnected: { isWifiConnected: boolean };\n  ipAddress: { ipAddress?: string };\n}\n\nexport type WifiEventDispatcher = EventDispatcher<\n  Device,\n  WifiEventType,\n  WifiEventMessages\n>;\nexport type SendWifiMessageCallback = SendMessageCallback<WifiMessageType>;\n\nclass WifiManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendWifiMessageCallback;\n\n  eventDispatcher!: WifiEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required wifi information\");\n    const messages = RequiredWifiMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // PROPERTIES\n\n  #isWifiAvailable = false;\n  get isWifiAvailable() {\n    return this.#isWifiAvailable;\n  }\n  #updateIsWifiAvailable(updatedIsWifiAvailable: boolean) {\n    _console.assertTypeWithError(updatedIsWifiAvailable, \"boolean\");\n    this.#isWifiAvailable = updatedIsWifiAvailable;\n    _console.log({ isWifiAvailable: this.#isWifiAvailable });\n    this.#dispatchEvent(\"isWifiAvailable\", {\n      isWifiAvailable: this.#isWifiAvailable,\n    });\n  }\n\n  #assertWifiIsAvailable() {\n    _console.assertWithError(this.#isWifiAvailable, \"wifi is not available\");\n  }\n\n  // WIFI SSID\n  #wifiSSID = \"\";\n  get wifiSSID() {\n    return this.#wifiSSID;\n  }\n\n  #updateWifiSSID(updatedWifiSSID: string) {\n    _console.assertTypeWithError(updatedWifiSSID, \"string\");\n    this.#wifiSSID = updatedWifiSSID;\n    _console.log({ wifiSSID: this.#wifiSSID });\n    this.#dispatchEvent(\"getWifiSSID\", { wifiSSID: this.#wifiSSID });\n  }\n  async setWifiSSID(newWifiSSID: string) {\n    this.#assertWifiIsAvailable();\n    if (this.#wifiConnectionEnabled) {\n      _console.error(\"cannot change ssid while wifi connection is enabled\");\n      return;\n    }\n    _console.assertTypeWithError(newWifiSSID, \"string\");\n    _console.assertRangeWithError(\n      \"wifiSSID\",\n      newWifiSSID.length,\n      MinWifiSSIDLength,\n      MaxWifiSSIDLength\n    );\n\n    const setWifiSSIDData = textEncoder.encode(newWifiSSID);\n    _console.log({ setWifiSSIDData });\n\n    const promise = this.waitForEvent(\"getWifiSSID\");\n    this.sendMessage([{ type: \"setWifiSSID\", data: setWifiSSIDData.buffer }]);\n    await promise;\n  }\n\n  // WIFI PASSWORD\n  #wifiPassword = \"\";\n  get wifiPassword() {\n    return this.#wifiPassword;\n  }\n\n  #updateWifiPassword(updatedWifiPassword: string) {\n    _console.assertTypeWithError(updatedWifiPassword, \"string\");\n    this.#wifiPassword = updatedWifiPassword;\n    _console.log({ wifiPassword: this.#wifiPassword });\n    this.#dispatchEvent(\"getWifiPassword\", {\n      wifiPassword: this.#wifiPassword,\n    });\n  }\n  async setWifiPassword(newWifiPassword: string) {\n    this.#assertWifiIsAvailable();\n    if (this.#wifiConnectionEnabled) {\n      _console.error(\"cannot change password while wifi connection is enabled\");\n      return;\n    }\n    _console.assertTypeWithError(newWifiPassword, \"string\");\n    if (newWifiPassword.length > 0) {\n      _console.assertRangeWithError(\n        \"wifiPassword\",\n        newWifiPassword.length,\n        MinWifiPasswordLength,\n        MaxWifiPasswordLength\n      );\n    }\n\n    const setWifiPasswordData = textEncoder.encode(newWifiPassword);\n    _console.log({ setWifiPasswordData });\n\n    const promise = this.waitForEvent(\"getWifiPassword\");\n    this.sendMessage([\n      { type: \"setWifiPassword\", data: setWifiPasswordData.buffer },\n    ]);\n    await promise;\n  }\n\n  // ENABLE WIFI CONNECTION\n  #wifiConnectionEnabled!: boolean;\n  get wifiConnectionEnabled() {\n    return this.#wifiConnectionEnabled;\n  }\n  #updateWifiConnectionEnabled(wifiConnectionEnabled: boolean) {\n    _console.log({ wifiConnectionEnabled });\n    this.#wifiConnectionEnabled = wifiConnectionEnabled;\n    this.#dispatchEvent(\"getWifiConnectionEnabled\", {\n      wifiConnectionEnabled: wifiConnectionEnabled,\n    });\n  }\n  async setWifiConnectionEnabled(\n    newWifiConnectionEnabled: boolean,\n    sendImmediately: boolean = true\n  ) {\n    this.#assertWifiIsAvailable();\n    _console.assertTypeWithError(newWifiConnectionEnabled, \"boolean\");\n    if (this.#wifiConnectionEnabled == newWifiConnectionEnabled) {\n      _console.log(\n        `redundant wifiConnectionEnabled assignment ${newWifiConnectionEnabled}`\n      );\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getWifiConnectionEnabled\");\n\n    this.sendMessage(\n      [\n        {\n          type: \"setWifiConnectionEnabled\",\n\n          data: UInt8ByteBuffer(Number(newWifiConnectionEnabled)),\n        },\n      ],\n      sendImmediately\n    );\n    await promise;\n  }\n  async toggleWifiConnection() {\n    return this.setWifiConnectionEnabled(!this.wifiConnectionEnabled);\n  }\n  async enableWifiConnection() {\n    return this.setWifiConnectionEnabled(true);\n  }\n  async disableWifiConnection() {\n    return this.setWifiConnectionEnabled(false);\n  }\n\n  // IS WIFI CONNECTED\n  #isWifiConnected = false;\n  get isWifiConnected() {\n    return this.#isWifiConnected;\n  }\n  #updateIsWifiConnected(updatedIsWifiConnected: boolean) {\n    _console.assertTypeWithError(updatedIsWifiConnected, \"boolean\");\n    this.#isWifiConnected = updatedIsWifiConnected;\n    _console.log({ isWifiConnected: this.#isWifiConnected });\n    this.#dispatchEvent(\"isWifiConnected\", {\n      isWifiConnected: this.#isWifiConnected,\n    });\n  }\n\n  // IP ADDRESS\n  #ipAddress?: string;\n  get ipAddress() {\n    return this.#ipAddress;\n  }\n\n  #updateIpAddress(updatedIpAddress?: string) {\n    this.#ipAddress = updatedIpAddress;\n    _console.log({ ipAddress: this.#ipAddress });\n    this.#dispatchEvent(\"ipAddress\", {\n      ipAddress: this.#ipAddress,\n    });\n  }\n\n  // IS WIFI SECURE\n  #isWifiSecure = false;\n  get isWifiSecure() {\n    return this.#isWifiSecure;\n  }\n  #updateIsWifiSecure(updatedIsWifiSecure: boolean) {\n    _console.assertTypeWithError(updatedIsWifiSecure, \"boolean\");\n    this.#isWifiSecure = updatedIsWifiSecure;\n    _console.log({ isWifiSecure: this.#isWifiSecure });\n    this.#dispatchEvent(\"isWifiSecure\", {\n      isWifiSecure: this.#isWifiSecure,\n    });\n  }\n\n  // MESSAGE\n  parseMessage(messageType: WifiMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"isWifiAvailable\":\n        const isWifiAvailable = Boolean(dataView.getUint8(0));\n        _console.log({ isWifiAvailable });\n        this.#updateIsWifiAvailable(isWifiAvailable);\n        break;\n      case \"getWifiSSID\":\n      case \"setWifiSSID\":\n        const ssid = textDecoder.decode(dataView.buffer);\n        _console.log({ ssid });\n        this.#updateWifiSSID(ssid);\n        break;\n      case \"getWifiPassword\":\n      case \"setWifiPassword\":\n        const password = textDecoder.decode(dataView.buffer);\n        _console.log({ password });\n        this.#updateWifiPassword(password);\n        break;\n      case \"getWifiConnectionEnabled\":\n      case \"setWifiConnectionEnabled\":\n        const enableWifiConnection = Boolean(dataView.getUint8(0));\n        _console.log({ enableWifiConnection });\n        this.#updateWifiConnectionEnabled(enableWifiConnection);\n        break;\n      case \"isWifiConnected\":\n        const isWifiConnected = Boolean(dataView.getUint8(0));\n        _console.log({ isWifiConnected });\n        this.#updateIsWifiConnected(isWifiConnected);\n        break;\n      case \"ipAddress\":\n        let ipAddress: string | undefined = undefined;\n        if (dataView.byteLength == 4) {\n          ipAddress = new Uint8Array(dataView.buffer.slice(0, 4)).join(\".\");\n        }\n        _console.log({ ipAddress });\n        this.#updateIpAddress(ipAddress);\n        break;\n      case \"isWifiSecure\":\n        const isWifiSecure = Boolean(dataView.getUint8(0));\n        _console.log({ isWifiSecure });\n        this.#updateIsWifiSecure(isWifiSecure);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    this.#wifiSSID = \"\";\n    this.#wifiPassword = \"\";\n    this.#ipAddress = \"\";\n    this.#isWifiConnected = false;\n    this.#isWifiAvailable = false;\n  }\n}\n\nexport default WifiManager;\n","import { createConsole } from \"./Console.ts\";\nimport { DisplayColorRGB } from \"./DisplayUtils.ts\";\n\nconst _console = createConsole(\"ColorUtils\", { log: false });\n\nexport function hexToRGB(hex: string): DisplayColorRGB {\n  hex = hex.replace(/^#/, \"\");\n\n  if (hex.length == 3) {\n    hex = hex\n      .split(\"\")\n      .map((char) => char + char)\n      .join(\"\");\n  }\n\n  _console.assertWithError(\n    hex.length == 6,\n    `hex length must be 6 (got ${hex.length})`\n  );\n\n  const r = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n\n  return { r, g, b };\n}\n\nconst blackColor: DisplayColorRGB = { r: 0, g: 0, b: 0 };\nexport function colorNameToRGB(colorName: string): DisplayColorRGB {\n  const temp = document.createElement(\"div\");\n  temp.style.color = colorName;\n  document.body.appendChild(temp);\n\n  const computedColor = getComputedStyle(temp).color;\n  document.body.removeChild(temp);\n\n  // Match \"rgb(r, g, b)\" or \"rgba(r, g, b, a)\"\n  const match = computedColor.match(/^rgba?\\((\\d+), (\\d+), (\\d+)/);\n  if (!match) return blackColor;\n\n  return {\n    r: parseInt(match[1], 10),\n    g: parseInt(match[2], 10),\n    b: parseInt(match[3], 10),\n  };\n}\n\nexport function stringToRGB(string: string): DisplayColorRGB {\n  if (string.startsWith(\"#\")) {\n    return hexToRGB(string);\n  } else {\n    return colorNameToRGB(string);\n  }\n}\n\nexport function rgbToHex({ r, g, b }: DisplayColorRGB): string {\n  const toHex = (value: number) =>\n    value.toString(16).padStart(2, \"0\").toLowerCase();\n\n  _console.assertWithError(\n    [r, g, b].every((v) => v >= 0 && v <= 255),\n    `RGB values must be between 0 and 255 (got r=${r}, g=${g}, b=${b})`\n  );\n\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n}\n","export const DisplaySegmentCaps = [\"flat\", \"round\"] as const;\nexport type DisplaySegmentCap = (typeof DisplaySegmentCaps)[number];\n\nexport type DisplayContextState = {\n  fillColorIndex: number;\n  lineColorIndex: number;\n  lineWidth: number;\n\n  rotation: number;\n\n  segmentStartCap: DisplaySegmentCap;\n  segmentEndCap: DisplaySegmentCap;\n\n  segmentStartRadius: number;\n  segmentEndRadius: number;\n\n  cropTop: number;\n  cropRight: number;\n  cropBottom: number;\n  cropLeft: number;\n\n  rotationCropTop: number;\n  rotationCropRight: number;\n  rotationCropBottom: number;\n  rotationCropLeft: number;\n\n  bitmapColorIndices: number[];\n  bitmapScaleX: number;\n  bitmapScaleY: number;\n\n  spriteColorIndices: number[];\n  spriteScaleX: number;\n  spriteScaleY: number;\n\n  spriteSheetName?: string;\n\n  // FILL - sprite spacing, direction, etc\n};\nexport type DisplayContextStateKey = keyof DisplayContextState;\nexport type PartialDisplayContextState = Partial<DisplayContextState>;\n\nexport const DefaultDisplayContextState: DisplayContextState = {\n  fillColorIndex: 1,\n\n  lineColorIndex: 1,\n  lineWidth: 0,\n\n  rotation: 0,\n\n  segmentStartCap: \"flat\",\n  segmentEndCap: \"flat\",\n\n  segmentStartRadius: 1,\n  segmentEndRadius: 1,\n\n  cropTop: 0,\n  cropRight: 0,\n  cropBottom: 0,\n  cropLeft: 0,\n\n  rotationCropTop: 0,\n  rotationCropRight: 0,\n  rotationCropBottom: 0,\n  rotationCropLeft: 0,\n\n  bitmapColorIndices: new Array(0).fill(0),\n  bitmapScaleX: 1,\n  bitmapScaleY: 1,\n\n  spriteColorIndices: new Array(0).fill(0),\n  spriteScaleX: 1,\n  spriteScaleY: 1,\n\n  spriteSheetName: undefined,\n};\n","export function deepEqual(obj1: any, obj2: any): boolean {\n  if (obj1 === obj2) {\n    return true;\n  }\n\n  if (\n    typeof obj1 !== \"object\" ||\n    obj1 === null ||\n    typeof obj2 !== \"object\" ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  if (keys1.length !== keys2.length) return false;\n\n  for (let key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { createConsole } from \"./Console.ts\";\nimport {\n  DefaultDisplayContextState,\n  DisplayContextState,\n  DisplayContextStateKey,\n  PartialDisplayContextState,\n} from \"./DisplayContextState.ts\";\nimport { deepEqual } from \"./ObjectUtils.ts\";\n\nconst _console = createConsole(\"DisplayContextStateHelper\", { log: false });\n\nclass DisplayContextStateHelper {\n  #state: DisplayContextState = Object.assign({}, DefaultDisplayContextState);\n  get state() {\n    return this.#state;\n  }\n\n  diff(other: PartialDisplayContextState) {\n    let differences: DisplayContextStateKey[] = [];\n    const keys = Object.keys(other) as DisplayContextStateKey[];\n    keys.forEach((key) => {\n      const value = other[key]!;\n\n      if (!deepEqual(this.#state[key], value)) {\n        differences.push(key);\n      }\n    });\n    _console.log(\"diff\", other, differences);\n    return differences;\n  }\n  update(newState: PartialDisplayContextState) {\n    let differences = this.diff(newState);\n    if (differences.length == 0) {\n      _console.log(\"redundant contextState\", newState);\n    }\n    differences.forEach((key) => {\n      const value = newState[key]!;\n      // @ts-expect-error\n      this.#state[key] = value;\n    });\n    return differences;\n  }\n  reset() {\n    Object.assign(this.#state, DefaultDisplayContextState);\n  }\n}\n\nexport default DisplayContextStateHelper;\n","import {\n  DisplayBrightness,\n  DisplayBrightnesses,\n  DisplayPixelDepth,\n  DisplayPixelDepths,\n} from \"../DisplayManager.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { DisplayContextCommandType } from \"./DisplayContextCommand.ts\";\nimport {\n  DisplayContextStateKey,\n  DisplaySegmentCap,\n  DisplaySegmentCaps,\n} from \"./DisplayContextState.ts\";\nimport { Int16Max, Uint16Max } from \"./MathUtils.ts\";\n\nconst _console = createConsole(\"DisplayUtils\", { log: false });\n\nexport function formatRotation(\n  rotation: number,\n  isRadians?: boolean,\n  isSigned?: boolean\n) {\n  if (isRadians) {\n    const rotationRad = rotation;\n    _console.log({ rotationRad });\n    rotation %= 2 * Math.PI;\n    rotation /= 2 * Math.PI;\n  } else {\n    const rotationDeg = rotation;\n    _console.log({ rotationDeg });\n    rotation %= 360;\n    rotation /= 360;\n  }\n  if (isSigned) {\n    rotation *= Int16Max;\n  } else {\n    rotation *= Uint16Max;\n  }\n  rotation = Math.floor(rotation);\n  _console.log({ formattedRotation: rotation });\n  return rotation;\n}\n\nexport function roundToStep(value: number, step: number) {\n  const roundedValue = Math.round(value / step) * step;\n  _console.log(value, step, roundedValue);\n  return roundedValue;\n}\n\nexport const minDisplayScale = -50;\nexport const maxDisplayScale = 50;\nexport const displayScaleStep = 0.002;\nexport function formatScale(bitmapScale: number) {\n  bitmapScale /= displayScaleStep;\n  _console.log({ formattedBitmapScale: bitmapScale });\n  return bitmapScale;\n}\nexport function roundScale(bitmapScale: number) {\n  return roundToStep(bitmapScale, displayScaleStep);\n}\n\nexport function assertValidSegmentCap(segmentCap: DisplaySegmentCap) {\n  _console.assertEnumWithError(segmentCap, DisplaySegmentCaps);\n}\n\nexport function assertValidDisplayBrightness(\n  displayBrightness: DisplayBrightness\n) {\n  _console.assertEnumWithError(displayBrightness, DisplayBrightnesses);\n}\n\nexport function assertValidColorValue(name: string, value: number) {\n  _console.assertRangeWithError(name, value, 0, 255);\n}\nexport function assertValidColor(color: DisplayColorRGB) {\n  assertValidColorValue(\"red\", color.r);\n  assertValidColorValue(\"green\", color.g);\n  assertValidColorValue(\"blue\", color.b);\n}\n\nexport function assertValidOpacity(value: number) {\n  _console.assertRangeWithError(\"opacity\", value, 0, 1);\n}\n\nexport const DisplayCropDirections = [\n  \"top\",\n  \"right\",\n  \"bottom\",\n  \"left\",\n] as const;\nexport type DisplayCropDirection = (typeof DisplayCropDirections)[number];\n\nexport const DisplayContextCropStateKeys = [\n  \"cropTop\",\n  \"cropRight\",\n  \"cropBottom\",\n  \"cropLeft\",\n] as const satisfies readonly DisplayContextStateKey[];\nexport type DisplayContextCropStateKey =\n  (typeof DisplayContextCropStateKeys)[number];\n\nexport const DisplayCropDirectionToStateKey: Record<\n  DisplayCropDirection,\n  DisplayContextCropStateKey\n> = {\n  top: \"cropTop\",\n  right: \"cropRight\",\n  bottom: \"cropBottom\",\n  left: \"cropLeft\",\n};\n\nexport const DisplayContextCropCommandTypes = [\n  \"setCropTop\",\n  \"setCropRight\",\n  \"setCropBottom\",\n  \"setCropLeft\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type DisplayContextCropCommandType =\n  (typeof DisplayContextCropCommandTypes)[number];\n\nexport const DisplayCropDirectionToCommandType: Record<\n  DisplayCropDirection,\n  DisplayContextCropCommandType\n> = {\n  top: \"setCropTop\",\n  right: \"setCropRight\",\n  bottom: \"setCropBottom\",\n  left: \"setCropLeft\",\n};\n\nexport const DisplayContextRotationCropStateKeys = [\n  \"rotationCropTop\",\n  \"rotationCropRight\",\n  \"rotationCropBottom\",\n  \"rotationCropLeft\",\n] as const satisfies readonly DisplayContextStateKey[];\nexport type DisplayContextRotationCropStateKey =\n  (typeof DisplayContextRotationCropStateKeys)[number];\n\nexport const DisplayRotationCropDirectionToStateKey: Record<\n  DisplayCropDirection,\n  DisplayContextRotationCropStateKey\n> = {\n  top: \"rotationCropTop\",\n  right: \"rotationCropRight\",\n  bottom: \"rotationCropBottom\",\n  left: \"rotationCropLeft\",\n};\n\nexport const DisplayContextRotationCropCommandTypes = [\n  \"setRotationCropTop\",\n  \"setRotationCropRight\",\n  \"setRotationCropBottom\",\n  \"setRotationCropLeft\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type DisplayContextRotationCropCommandType =\n  (typeof DisplayContextRotationCropCommandTypes)[number];\n\nexport const DisplayRotationCropDirectionToCommandType: Record<\n  DisplayCropDirection,\n  DisplayContextRotationCropCommandType\n> = {\n  top: \"setRotationCropTop\",\n  right: \"setRotationCropRight\",\n  bottom: \"setRotationCropBottom\",\n  left: \"setRotationCropLeft\",\n};\n\nexport function pixelDepthToNumberOfColors(pixelDepth: DisplayPixelDepth) {\n  return 2 ** Number(pixelDepth);\n}\nexport function pixelDepthToPixelsPerByte(pixelDepth: DisplayPixelDepth) {\n  return 8 / Number(pixelDepth);\n}\nexport function pixelDepthToPixelBitWidth(pixelDepth: DisplayPixelDepth) {\n  return Number(pixelDepth);\n}\nexport function numberOfColorsToPixelDepth(numberOfColors: number) {\n  return DisplayPixelDepths.find(\n    (pixelDepth) => numberOfColors <= pixelDepthToNumberOfColors(pixelDepth)\n  );\n}\n\nexport const DisplayScaleDirections = [\"x\", \"y\", \"all\"] as const;\nexport type DisplayScaleDirection = (typeof DisplayScaleDirections)[number];\n\nexport const DisplayBitmapScaleDirectionToCommandType: Record<\n  DisplayScaleDirection,\n  DisplayContextCommandType\n> = {\n  x: \"setBitmapScaleX\",\n  y: \"setBitmapScaleY\",\n  all: \"setBitmapScale\",\n};\n\nexport const DisplaySpriteScaleDirectionToCommandType: Record<\n  DisplayScaleDirection,\n  DisplayContextCommandType\n> = {\n  x: \"setSpriteScaleX\",\n  y: \"setSpriteScaleY\",\n  all: \"setSpriteScale\",\n};\n\nexport type DisplayColorRGB = {\n  r: number;\n  g: number;\n  b: number;\n};\nexport type DisplayColorYCbCr = {\n  y: number;\n  cb: number;\n  cr: number;\n};\n","/*\n* Copyright (c) 2015, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* RgbQuant.js - an image quantization lib\n*/\n\n(function(){\n\tfunction RgbQuant(opts) {\n\t\topts = opts || {};\n\n\t\t// 1 = by global population, 2 = subregion population threshold\n\t\tthis.method = opts.method || 2;\n\t\t// desired final palette size\n\t\tthis.colors = opts.colors || 256;\n\t\t// # of highest-frequency colors to start with for palette reduction\n\t\tthis.initColors = opts.initColors || 4096;\n\t\t// color-distance threshold for initial reduction pass\n\t\tthis.initDist = opts.initDist || 0.01;\n\t\t// subsequent passes threshold\n\t\tthis.distIncr = opts.distIncr || 0.005;\n\t\t// palette grouping\n\t\tthis.hueGroups = opts.hueGroups || 10;\n\t\tthis.satGroups = opts.satGroups || 10;\n\t\tthis.lumGroups = opts.lumGroups || 10;\n\t\t// if > 0, enables hues stats and min-color retention per group\n\t\tthis.minHueCols = opts.minHueCols || 0;\n\t\t// HueStats instance\n\t\tthis.hueStats = this.minHueCols ? new HueStats(this.hueGroups, this.minHueCols) : null;\n\n\t\t// subregion partitioning box size\n\t\tthis.boxSize = opts.boxSize || [64,64];\n\t\t// number of same pixels required within box for histogram inclusion\n\t\tthis.boxPxls = opts.boxPxls || 2;\n\t\t// palette locked indicator\n\t\tthis.palLocked = false;\n\t\t// palette sort order\n//\t\tthis.sortPal = ['hue-','lum-','sat-'];\n\n\t\t// dithering/error diffusion kernel name\n\t\tthis.dithKern = opts.dithKern || null;\n\t\t// dither serpentine pattern\n\t\tthis.dithSerp = opts.dithSerp || false;\n\t\t// minimum color difference (0-1) needed to dither\n\t\tthis.dithDelta = opts.dithDelta || 0;\n\n\t\t// accumulated histogram\n\t\tthis.histogram = {};\n\t\t// palette - rgb triplets\n\t\tthis.idxrgb = opts.palette ? opts.palette.slice(0) : [];\n\t\t// palette - int32 vals\n\t\tthis.idxi32 = [];\n\t\t// reverse lookup {i32:idx}\n\t\tthis.i32idx = {};\n\t\t// {i32:rgb}\n\t\tthis.i32rgb = {};\n\t\t// enable color caching (also incurs overhead of cache misses and cache building)\n\t\tthis.useCache = opts.useCache !== false;\n\t\t// min color occurance count needed to qualify for caching\n\t\tthis.cacheFreq = opts.cacheFreq || 10;\n\t\t// allows pre-defined palettes to be re-indexed (enabling palette compacting and sorting)\n\t\tthis.reIndex = opts.reIndex || this.idxrgb.length == 0;\n\t\t// selection of color-distance equation\n\t\tthis.colorDist = opts.colorDist == \"manhattan\" ? distManhattan : distEuclidean;\n\n\t\t// if pre-defined palette, build lookups\n\t\tif (this.idxrgb.length > 0) {\n\t\t\tvar self = this;\n\t\t\tthis.idxrgb.forEach(function(rgb, i) {\n\t\t\t\tvar i32 = (\n\t\t\t\t\t(255    << 24) |\t// alpha\n\t\t\t\t\t(rgb[2] << 16) |\t// blue\n\t\t\t\t\t(rgb[1] <<  8) |\t// green\n\t\t\t\t\t rgb[0]\t\t\t\t// red\n\t\t\t\t) >>> 0;\n\n\t\t\t\tself.idxi32[i]\t\t= i32;\n\t\t\t\tself.i32idx[i32]\t= i;\n\t\t\t\tself.i32rgb[i32]\t= rgb;\n\t\t\t});\n\t\t}\n\t}\n\n\t// gathers histogram info\n\tRgbQuant.prototype.sample = function sample(img, width) {\n\t\tif (this.palLocked)\n\t\t\tthrow \"Cannot sample additional images, palette already assembled.\";\n\n\t\tvar data = getImageData(img, width);\n\n\t\tswitch (this.method) {\n\t\t\tcase 1: this.colorStats1D(data.buf32); break;\n\t\t\tcase 2: this.colorStats2D(data.buf32, data.width); break;\n\t\t}\n\t};\n\n\t// image quantizer\n\t// todo: memoize colors here also\n\t// @retType: 1 - Uint8Array (default), 2 - Indexed array, 3 - Match @img type (unimplemented, todo)\n\tRgbQuant.prototype.reduce = function reduce(img, retType, dithKern, dithSerp) {\n\t\tif (!this.palLocked)\n\t\t\tthis.buildPal();\n\n\t\tdithKern = dithKern || this.dithKern;\n\t\tdithSerp = typeof dithSerp != \"undefined\" ? dithSerp : this.dithSerp;\n\n\t\tretType = retType || 1;\n\n\t\t// reduce w/dither\n\t\tif (dithKern)\n\t\t\tvar out32 = this.dither(img, dithKern, dithSerp);\n\t\telse {\n\t\t\tvar data = getImageData(img),\n\t\t\t\tbuf32 = data.buf32,\n\t\t\t\tlen = buf32.length,\n\t\t\t\tout32 = new Uint32Array(len);\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar i32 = buf32[i];\n\t\t\t\tout32[i] = this.nearestColor(i32);\n\t\t\t}\n\t\t}\n\n\t\tif (retType == 1)\n\t\t\treturn new Uint8Array(out32.buffer);\n\n\t\tif (retType == 2) {\n\t\t\tvar out = [],\n\t\t\t\tlen = out32.length;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar i32 = out32[i];\n\t\t\t\tout[i] = this.i32idx[i32];\n\t\t\t}\n\n\t\t\treturn out;\n\t\t}\n\t};\n\n\t// adapted from http://jsbin.com/iXofIji/2/edit by PAEz\n\tRgbQuant.prototype.dither = function(img, kernel, serpentine) {\n\t\t// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\n\t\tvar kernels = {\n\t\t\tFloydSteinberg: [\n\t\t\t\t[7 / 16, 1, 0],\n\t\t\t\t[3 / 16, -1, 1],\n\t\t\t\t[5 / 16, 0, 1],\n\t\t\t\t[1 / 16, 1, 1]\n\t\t\t],\n\t\t\tFalseFloydSteinberg: [\n\t\t\t\t[3 / 8, 1, 0],\n\t\t\t\t[3 / 8, 0, 1],\n\t\t\t\t[2 / 8, 1, 1]\n\t\t\t],\n\t\t\tStucki: [\n\t\t\t\t[8 / 42, 1, 0],\n\t\t\t\t[4 / 42, 2, 0],\n\t\t\t\t[2 / 42, -2, 1],\n\t\t\t\t[4 / 42, -1, 1],\n\t\t\t\t[8 / 42, 0, 1],\n\t\t\t\t[4 / 42, 1, 1],\n\t\t\t\t[2 / 42, 2, 1],\n\t\t\t\t[1 / 42, -2, 2],\n\t\t\t\t[2 / 42, -1, 2],\n\t\t\t\t[4 / 42, 0, 2],\n\t\t\t\t[2 / 42, 1, 2],\n\t\t\t\t[1 / 42, 2, 2]\n\t\t\t],\n\t\t\tAtkinson: [\n\t\t\t\t[1 / 8, 1, 0],\n\t\t\t\t[1 / 8, 2, 0],\n\t\t\t\t[1 / 8, -1, 1],\n\t\t\t\t[1 / 8, 0, 1],\n\t\t\t\t[1 / 8, 1, 1],\n\t\t\t\t[1 / 8, 0, 2]\n\t\t\t],\n\t\t\tJarvis: [\t\t\t// Jarvis, Judice, and Ninke / JJN?\n\t\t\t\t[7 / 48, 1, 0],\n\t\t\t\t[5 / 48, 2, 0],\n\t\t\t\t[3 / 48, -2, 1],\n\t\t\t\t[5 / 48, -1, 1],\n\t\t\t\t[7 / 48, 0, 1],\n\t\t\t\t[5 / 48, 1, 1],\n\t\t\t\t[3 / 48, 2, 1],\n\t\t\t\t[1 / 48, -2, 2],\n\t\t\t\t[3 / 48, -1, 2],\n\t\t\t\t[5 / 48, 0, 2],\n\t\t\t\t[3 / 48, 1, 2],\n\t\t\t\t[1 / 48, 2, 2]\n\t\t\t],\n\t\t\tBurkes: [\n\t\t\t\t[8 / 32, 1, 0],\n\t\t\t\t[4 / 32, 2, 0],\n\t\t\t\t[2 / 32, -2, 1],\n\t\t\t\t[4 / 32, -1, 1],\n\t\t\t\t[8 / 32, 0, 1],\n\t\t\t\t[4 / 32, 1, 1],\n\t\t\t\t[2 / 32, 2, 1],\n\t\t\t],\n\t\t\tSierra: [\n\t\t\t\t[5 / 32, 1, 0],\n\t\t\t\t[3 / 32, 2, 0],\n\t\t\t\t[2 / 32, -2, 1],\n\t\t\t\t[4 / 32, -1, 1],\n\t\t\t\t[5 / 32, 0, 1],\n\t\t\t\t[4 / 32, 1, 1],\n\t\t\t\t[2 / 32, 2, 1],\n\t\t\t\t[2 / 32, -1, 2],\n\t\t\t\t[3 / 32, 0, 2],\n\t\t\t\t[2 / 32, 1, 2],\n\t\t\t],\n\t\t\tTwoSierra: [\n\t\t\t\t[4 / 16, 1, 0],\n\t\t\t\t[3 / 16, 2, 0],\n\t\t\t\t[1 / 16, -2, 1],\n\t\t\t\t[2 / 16, -1, 1],\n\t\t\t\t[3 / 16, 0, 1],\n\t\t\t\t[2 / 16, 1, 1],\n\t\t\t\t[1 / 16, 2, 1],\n\t\t\t],\n\t\t\tSierraLite: [\n\t\t\t\t[2 / 4, 1, 0],\n\t\t\t\t[1 / 4, -1, 1],\n\t\t\t\t[1 / 4, 0, 1],\n\t\t\t],\n\t\t};\n\n\t\tif (!kernel || !kernels[kernel]) {\n\t\t\tthrow 'Unknown dithering kernel: ' + kernel;\n\t\t}\n\n\t\tvar ds = kernels[kernel];\n\n\t\tvar data = getImageData(img),\n//\t\t\tbuf8 = data.buf8,\n\t\t\tbuf32 = data.buf32,\n\t\t\twidth = data.width,\n\t\t\theight = data.height,\n\t\t\tlen = buf32.length;\n\n\t\tvar dir = serpentine ? -1 : 1;\n\n\t\tfor (var y = 0; y < height; y++) {\n\t\t\tif (serpentine)\n\t\t\t\tdir = dir * -1;\n\n\t\t\tvar lni = y * width;\n\n\t\t\tfor (var x = (dir == 1 ? 0 : width - 1), xend = (dir == 1 ? width : 0); x !== xend; x += dir) {\n\t\t\t\t// Image pixel\n\t\t\t\tvar idx = lni + x,\n\t\t\t\t\ti32 = buf32[idx],\n\t\t\t\t\tr1 = (i32 & 0xff),\n\t\t\t\t\tg1 = (i32 & 0xff00) >> 8,\n\t\t\t\t\tb1 = (i32 & 0xff0000) >> 16;\n\n\t\t\t\t// Reduced pixel\n\t\t\t\tvar i32x = this.nearestColor(i32),\n\t\t\t\t\tr2 = (i32x & 0xff),\n\t\t\t\t\tg2 = (i32x & 0xff00) >> 8,\n\t\t\t\t\tb2 = (i32x & 0xff0000) >> 16;\n\n\t\t\t\tbuf32[idx] =\n\t\t\t\t\t(255 << 24)\t|\t// alpha\n\t\t\t\t\t(b2  << 16)\t|\t// blue\n\t\t\t\t\t(g2  <<  8)\t|\t// green\n\t\t\t\t\t r2;\n\n\t\t\t\t// dithering strength\n\t\t\t\tif (this.dithDelta) {\n\t\t\t\t\tvar dist = this.colorDist([r1, g1, b1], [r2, g2, b2]);\n\t\t\t\t\tif (dist < this.dithDelta)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Component distance\n\t\t\t\tvar er = r1 - r2,\n\t\t\t\t\teg = g1 - g2,\n\t\t\t\t\teb = b1 - b2;\n\n\t\t\t\tfor (var i = (dir == 1 ? 0 : ds.length - 1), end = (dir == 1 ? ds.length : 0); i !== end; i += dir) {\n\t\t\t\t\tvar x1 = ds[i][1] * dir,\n\t\t\t\t\t\ty1 = ds[i][2];\n\n\t\t\t\t\tvar lni2 = y1 * width;\n\n\t\t\t\t\tif (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n\t\t\t\t\t\tvar d = ds[i][0];\n\t\t\t\t\t\tvar idx2 = idx + (lni2 + x1);\n\n\t\t\t\t\t\tvar r3 = (buf32[idx2] & 0xff),\n\t\t\t\t\t\t\tg3 = (buf32[idx2] & 0xff00) >> 8,\n\t\t\t\t\t\t\tb3 = (buf32[idx2] & 0xff0000) >> 16;\n\n\t\t\t\t\t\tvar r4 = Math.max(0, Math.min(255, r3 + er * d)),\n\t\t\t\t\t\t\tg4 = Math.max(0, Math.min(255, g3 + eg * d)),\n\t\t\t\t\t\t\tb4 = Math.max(0, Math.min(255, b3 + eb * d));\n\n\t\t\t\t\t\tbuf32[idx2] =\n\t\t\t\t\t\t\t(255 << 24)\t|\t// alpha\n\t\t\t\t\t\t\t(b4  << 16)\t|\t// blue\n\t\t\t\t\t\t\t(g4  <<  8)\t|\t// green\n\t\t\t\t\t\t\t r4;\t\t\t// red\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn buf32;\n\t};\n\n\t// reduces histogram to palette, remaps & memoizes reduced colors\n\tRgbQuant.prototype.buildPal = function buildPal(noSort) {\n\t\tif (this.palLocked || this.idxrgb.length > 0 && this.idxrgb.length <= this.colors) return;\n\n\t\tvar histG  = this.histogram,\n\t\t\tsorted = sortedHashKeys(histG, true);\n\n\t\tif (sorted.length == 0)\n\t\t\tthrow \"Nothing has been sampled, palette cannot be built.\";\n\n\t\tswitch (this.method) {\n\t\t\tcase 1:\n\t\t\t\tvar cols = this.initColors,\n\t\t\t\t\tlast = sorted[cols - 1],\n\t\t\t\t\tfreq = histG[last];\n\n\t\t\t\tvar idxi32 = sorted.slice(0, cols);\n\n\t\t\t\t// add any cut off colors with same freq as last\n\t\t\t\tvar pos = cols, len = sorted.length;\n\t\t\t\twhile (pos < len && histG[sorted[pos]] == freq)\n\t\t\t\t\tidxi32.push(sorted[pos++]);\n\n\t\t\t\t// inject min huegroup colors\n\t\t\t\tif (this.hueStats)\n\t\t\t\t\tthis.hueStats.inject(idxi32);\n\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tvar idxi32 = sorted;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// int32-ify values\n\t\tidxi32 = idxi32.map(function(v){return +v;});\n\n\t\tthis.reducePal(idxi32);\n\n\t\tif (!noSort && this.reIndex)\n\t\t\tthis.sortPal();\n\n\t\t// build cache of top histogram colors\n\t\tif (this.useCache)\n\t\t\tthis.cacheHistogram(idxi32);\n\n\t\tthis.palLocked = true;\n\t};\n\n\tRgbQuant.prototype.palette = function palette(tuples, noSort) {\n\t\tthis.buildPal(noSort);\n\t\treturn tuples ? this.idxrgb : new Uint8Array((new Uint32Array(this.idxi32)).buffer);\n\t};\n\n\tRgbQuant.prototype.prunePal = function prunePal(keep) {\n\t\tvar i32;\n\n\t\tfor (var j = 0; j < this.idxrgb.length; j++) {\n\t\t\tif (!keep[j]) {\n\t\t\t\ti32 = this.idxi32[j];\n\t\t\t\tthis.idxrgb[j] = null;\n\t\t\t\tthis.idxi32[j] = null;\n\t\t\t\tdelete this.i32idx[i32];\n\t\t\t}\n\t\t}\n\n\t\t// compact\n\t\tif (this.reIndex) {\n\t\t\tvar idxrgb = [],\n\t\t\t\tidxi32 = [],\n\t\t\t\ti32idx = {};\n\n\t\t\tfor (var j = 0, i = 0; j < this.idxrgb.length; j++) {\n\t\t\t\tif (this.idxrgb[j]) {\n\t\t\t\t\ti32 = this.idxi32[j];\n\t\t\t\t\tidxrgb[i] = this.idxrgb[j];\n\t\t\t\t\ti32idx[i32] = i;\n\t\t\t\t\tidxi32[i] = i32;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.idxrgb = idxrgb;\n\t\t\tthis.idxi32 = idxi32;\n\t\t\tthis.i32idx = i32idx;\n\t\t}\n\t};\n\n\t// reduces similar colors from an importance-sorted Uint32 rgba array\n\tRgbQuant.prototype.reducePal = function reducePal(idxi32) {\n\t\t// if pre-defined palette's length exceeds target\n\t\tif (this.idxrgb.length > this.colors) {\n\t\t\t// quantize histogram to existing palette\n\t\t\tvar len = idxi32.length, keep = {}, uniques = 0, idx, pruned = false;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\t// palette length reached, unset all remaining colors (sparse palette)\n\t\t\t\tif (uniques == this.colors && !pruned) {\n\t\t\t\t\tthis.prunePal(keep);\n\t\t\t\t\tpruned = true;\n\t\t\t\t}\n\n\t\t\t\tidx = this.nearestIndex(idxi32[i]);\n\n\t\t\t\tif (uniques < this.colors && !keep[idx]) {\n\t\t\t\t\tkeep[idx] = true;\n\t\t\t\t\tuniques++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pruned) {\n\t\t\t\tthis.prunePal(keep);\n\t\t\t\tpruned = true;\n\t\t\t}\n\t\t}\n\t\t// reduce histogram to create initial palette\n\t\telse {\n\t\t\t// build full rgb palette\n\t\t\tvar idxrgb = idxi32.map(function(i32) {\n\t\t\t\treturn [\n\t\t\t\t\t(i32 & 0xff),\n\t\t\t\t\t(i32 & 0xff00) >> 8,\n\t\t\t\t\t(i32 & 0xff0000) >> 16,\n\t\t\t\t];\n\t\t\t});\n\n\t\t\tvar len = idxrgb.length,\n\t\t\t\tpalLen = len,\n\t\t\t\tthold = this.initDist;\n\n\t\t\t// palette already at or below desired length\n\t\t\tif (palLen > this.colors) {\n\t\t\t\twhile (palLen > this.colors) {\n\t\t\t\t\tvar memDist = [];\n\n\t\t\t\t\t// iterate palette\n\t\t\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\t\t\tvar pxi = idxrgb[i], i32i = idxi32[i];\n\t\t\t\t\t\tif (!pxi) continue;\n\n\t\t\t\t\t\tfor (var j = i + 1; j < len; j++) {\n\t\t\t\t\t\t\tvar pxj = idxrgb[j], i32j = idxi32[j];\n\t\t\t\t\t\t\tif (!pxj) continue;\n\n\t\t\t\t\t\t\tvar dist = this.colorDist(pxi, pxj);\n\n\t\t\t\t\t\t\tif (dist < thold) {\n\t\t\t\t\t\t\t\t// store index,rgb,dist\n\t\t\t\t\t\t\t\tmemDist.push([j, pxj, i32j, dist]);\n\n\t\t\t\t\t\t\t\t// kill squashed value\n\t\t\t\t\t\t\t\tdelete(idxrgb[j]);\n\t\t\t\t\t\t\t\tpalLen--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// palette reduction pass\n\t\t\t\t\t// console.log(\"palette length: \" + palLen);\n\n\t\t\t\t\t// if palette is still much larger than target, increment by larger initDist\n\t\t\t\t\tthold += (palLen > this.colors * 3) ? this.initDist : this.distIncr;\n\t\t\t\t}\n\n\t\t\t\t// if palette is over-reduced, re-add removed colors with largest distances from last round\n\t\t\t\tif (palLen < this.colors) {\n\t\t\t\t\t// sort descending\n\t\t\t\t\tsort.call(memDist, function(a,b) {\n\t\t\t\t\t\treturn b[3] - a[3];\n\t\t\t\t\t});\n\n\t\t\t\t\tvar k = 0;\n\t\t\t\t\twhile (palLen < this.colors) {\n\t\t\t\t\t\t// re-inject rgb into final palette\n\t\t\t\t\t\tidxrgb[memDist[k][0]] = memDist[k][1];\n\n\t\t\t\t\t\tpalLen++;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar len = idxrgb.length;\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tif (!idxrgb[i]) continue;\n\n\t\t\t\tthis.idxrgb.push(idxrgb[i]);\n\t\t\t\tthis.idxi32.push(idxi32[i]);\n\n\t\t\t\tthis.i32idx[idxi32[i]] = this.idxi32.length - 1;\n\t\t\t\tthis.i32rgb[idxi32[i]] = idxrgb[i];\n\t\t\t}\n\t\t}\n\t};\n\n\t// global top-population\n\tRgbQuant.prototype.colorStats1D = function colorStats1D(buf32) {\n\t\tvar histG = this.histogram,\n\t\t\tnum = 0, col,\n\t\t\tlen = buf32.length;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tcol = buf32[i];\n\n\t\t\t// skip transparent\n\t\t\tif ((col & 0xff000000) >> 24 == 0) continue;\n\n\t\t\t// collect hue stats\n\t\t\tif (this.hueStats)\n\t\t\t\tthis.hueStats.check(col);\n\n\t\t\tif (col in histG)\n\t\t\t\thistG[col]++;\n\t\t\telse\n\t\t\t\thistG[col] = 1;\n\t\t}\n\t};\n\n\t// population threshold within subregions\n\t// FIXME: this can over-reduce (few/no colors same?), need a way to keep\n\t// important colors that dont ever reach local thresholds (gradients?)\n\tRgbQuant.prototype.colorStats2D = function colorStats2D(buf32, width) {\n\t\tvar boxW = this.boxSize[0],\n\t\t\tboxH = this.boxSize[1],\n\t\t\tarea = boxW * boxH,\n\t\t\tboxes = makeBoxes(width, buf32.length / width, boxW, boxH),\n\t\t\thistG = this.histogram,\n\t\t\tself = this;\n\n\t\tboxes.forEach(function(box) {\n\t\t\tvar effc = Math.max(Math.round((box.w * box.h) / area) * self.boxPxls, 2),\n\t\t\t\thistL = {}, col;\n\n\t\t\titerBox(box, width, function(i) {\n\t\t\t\tcol = buf32[i];\n\n\t\t\t\t// skip transparent\n\t\t\t\tif ((col & 0xff000000) >> 24 == 0) return;\n\n\t\t\t\t// collect hue stats\n\t\t\t\tif (self.hueStats)\n\t\t\t\t\tself.hueStats.check(col);\n\n\t\t\t\tif (col in histG)\n\t\t\t\t\thistG[col]++;\n\t\t\t\telse if (col in histL) {\n\t\t\t\t\tif (++histL[col] >= effc)\n\t\t\t\t\t\thistG[col] = histL[col];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thistL[col] = 1;\n\t\t\t});\n\t\t});\n\n\t\tif (this.hueStats)\n\t\t\tthis.hueStats.inject(histG);\n\t};\n\n\t// TODO: group very low lum and very high lum colors\n\t// TODO: pass custom sort order\n\tRgbQuant.prototype.sortPal = function sortPal() {\n\t\tvar self = this;\n\n\t\tthis.idxi32.sort(function(a,b) {\n\t\t\tvar idxA = self.i32idx[a],\n\t\t\t\tidxB = self.i32idx[b],\n\t\t\t\trgbA = self.idxrgb[idxA],\n\t\t\t\trgbB = self.idxrgb[idxB];\n\n\t\t\tvar hslA = rgb2hsl(rgbA[0],rgbA[1],rgbA[2]),\n\t\t\t\thslB = rgb2hsl(rgbB[0],rgbB[1],rgbB[2]);\n\n\t\t\t// sort all grays + whites together\n\t\t\tvar hueA = (rgbA[0] == rgbA[1] && rgbA[1] == rgbA[2]) ? -1 : hueGroup(hslA.h, self.hueGroups);\n\t\t\tvar hueB = (rgbB[0] == rgbB[1] && rgbB[1] == rgbB[2]) ? -1 : hueGroup(hslB.h, self.hueGroups);\n\n\t\t\tvar hueDiff = hueB - hueA;\n\t\t\tif (hueDiff) return -hueDiff;\n\n\t\t\tvar lumDiff = lumGroup(+hslB.l.toFixed(2)) - lumGroup(+hslA.l.toFixed(2));\n\t\t\tif (lumDiff) return -lumDiff;\n\n\t\t\tvar satDiff = satGroup(+hslB.s.toFixed(2)) - satGroup(+hslA.s.toFixed(2));\n\t\t\tif (satDiff) return -satDiff;\n\t\t});\n\n\t\t// sync idxrgb & i32idx\n\t\tthis.idxi32.forEach(function(i32, i) {\n\t\t\tself.idxrgb[i] = self.i32rgb[i32];\n\t\t\tself.i32idx[i32] = i;\n\t\t});\n\t};\n\n\t// TOTRY: use HUSL - http://boronine.com/husl/\n\tRgbQuant.prototype.nearestColor = function nearestColor(i32) {\n\t\tvar idx = this.nearestIndex(i32);\n\t\treturn idx === null ? 0 : this.idxi32[idx];\n\t};\n\n\t// TOTRY: use HUSL - http://boronine.com/husl/\n\tRgbQuant.prototype.nearestIndex = function nearestIndex(i32) {\n\t\t// alpha 0 returns null index\n\t\tif ((i32 & 0xff000000) >> 24 == 0)\n\t\t\treturn null;\n\n\t\tif (this.useCache && (\"\"+i32) in this.i32idx)\n\t\t\treturn this.i32idx[i32];\n\n\t\tvar min = 1000,\n\t\t\tidx,\n\t\t\trgb = [\n\t\t\t\t(i32 & 0xff),\n\t\t\t\t(i32 & 0xff00) >> 8,\n\t\t\t\t(i32 & 0xff0000) >> 16,\n\t\t\t],\n\t\t\tlen = this.idxrgb.length;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tif (!this.idxrgb[i]) continue;\t\t// sparse palettes\n\n\t\t\tvar dist = this.colorDist(rgb, this.idxrgb[i]);\n\n\t\t\tif (dist < min) {\n\t\t\t\tmin = dist;\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t}\n\n\t\treturn idx;\n\t};\n\n\tRgbQuant.prototype.cacheHistogram = function cacheHistogram(idxi32) {\n\t\tfor (var i = 0, i32 = idxi32[i]; i < idxi32.length && this.histogram[i32] >= this.cacheFreq; i32 = idxi32[i++])\n\t\t\tthis.i32idx[i32] = this.nearestIndex(i32);\n\t};\n\n\tfunction HueStats(numGroups, minCols) {\n\t\tthis.numGroups = numGroups;\n\t\tthis.minCols = minCols;\n\t\tthis.stats = {};\n\n\t\tfor (var i = -1; i < numGroups; i++)\n\t\t\tthis.stats[i] = {num: 0, cols: []};\n\n\t\tthis.groupsFull = 0;\n\t}\n\n\tHueStats.prototype.check = function checkHue(i32) {\n\t\tif (this.groupsFull == this.numGroups + 1)\n\t\t\tthis.check = function() {return;};\n\n\t\tvar r = (i32 & 0xff),\n\t\t\tg = (i32 & 0xff00) >> 8,\n\t\t\tb = (i32 & 0xff0000) >> 16,\n\t\t\thg = (r == g && g == b) ? -1 : hueGroup(rgb2hsl(r,g,b).h, this.numGroups),\n\t\t\tgr = this.stats[hg],\n\t\t\tmin = this.minCols;\n\n\t\tgr.num++;\n\n\t\tif (gr.num > min)\n\t\t\treturn;\n\t\tif (gr.num == min)\n\t\t\tthis.groupsFull++;\n\n\t\tif (gr.num <= min)\n\t\t\tthis.stats[hg].cols.push(i32);\n\t};\n\n\tHueStats.prototype.inject = function injectHues(histG) {\n\t\tfor (var i = -1; i < this.numGroups; i++) {\n\t\t\tif (this.stats[i].num <= this.minCols) {\n\t\t\t\tswitch (typeOf(histG)) {\n\t\t\t\t\tcase \"Array\":\n\t\t\t\t\t\tthis.stats[i].cols.forEach(function(col){\n\t\t\t\t\t\t\tif (histG.indexOf(col) == -1)\n\t\t\t\t\t\t\t\thistG.push(col);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"Object\":\n\t\t\t\t\t\tthis.stats[i].cols.forEach(function(col){\n\t\t\t\t\t\t\tif (!histG[col])\n\t\t\t\t\t\t\t\thistG[col] = 1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\thistG[col]++;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Rec. 709 (sRGB) luma coef\n\tvar Pr = .2126,\n\t\tPg = .7152,\n\t\tPb = .0722;\n\n\t// http://alienryderflex.com/hsp.html\n\tfunction rgb2lum(r,g,b) {\n\t\treturn Math.sqrt(\n\t\t\tPr * r*r +\n\t\t\tPg * g*g +\n\t\t\tPb * b*b\n\t\t);\n\t}\n\n\tvar rd = 255,\n\t\tgd = 255,\n\t\tbd = 255;\n\n\tvar euclMax = Math.sqrt(Pr*rd*rd + Pg*gd*gd + Pb*bd*bd);\n\t// perceptual Euclidean color distance\n\tfunction distEuclidean(rgb0, rgb1) {\n\t\tvar rd = rgb1[0]-rgb0[0],\n\t\t\tgd = rgb1[1]-rgb0[1],\n\t\t\tbd = rgb1[2]-rgb0[2];\n\n\t\treturn Math.sqrt(Pr*rd*rd + Pg*gd*gd + Pb*bd*bd) / euclMax;\n\t}\n\n\tvar manhMax = Pr*rd + Pg*gd + Pb*bd;\n\t// perceptual Manhattan color distance\n\tfunction distManhattan(rgb0, rgb1) {\n\t\tvar rd = Math.abs(rgb1[0]-rgb0[0]),\n\t\t\tgd = Math.abs(rgb1[1]-rgb0[1]),\n\t\t\tbd = Math.abs(rgb1[2]-rgb0[2]);\n\n\t\treturn (Pr*rd + Pg*gd + Pb*bd) / manhMax;\n\t}\n\n\t// http://rgb2hsl.nichabi.com/javascript-function.php\n\tfunction rgb2hsl(r, g, b) {\n\t\tvar max, min, h, s, l, d;\n\t\tr /= 255;\n\t\tg /= 255;\n\t\tb /= 255;\n\t\tmax = Math.max(r, g, b);\n\t\tmin = Math.min(r, g, b);\n\t\tl = (max + min) / 2;\n\t\tif (max == min) {\n\t\t\th = s = 0;\n\t\t} else {\n\t\t\td = max - min;\n\t\t\ts = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\t\t\tswitch (max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g:\th = (b - r) / d + 2; break;\n\t\t\t\tcase b:\th = (r - g) / d + 4; break\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n//\t\th = Math.floor(h * 360)\n//\t\ts = Math.floor(s * 100)\n//\t\tl = Math.floor(l * 100)\n\t\treturn {\n\t\t\th: h,\n\t\t\ts: s,\n\t\t\tl: rgb2lum(r,g,b),\n\t\t};\n\t}\n\n\tfunction hueGroup(hue, segs) {\n\t\tvar seg = 1/segs,\n\t\t\thaf = seg/2;\n\n\t\tif (hue >= 1 - haf || hue <= haf)\n\t\t\treturn 0;\n\n\t\tfor (var i = 1; i < segs; i++) {\n\t\t\tvar mid = i*seg;\n\t\t\tif (hue >= mid - haf && hue <= mid + haf)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\tfunction satGroup(sat) {\n\t\treturn sat;\n\t}\n\n\tfunction lumGroup(lum) {\n\t\treturn lum;\n\t}\n\n\tfunction typeOf(val) {\n\t\treturn Object.prototype.toString.call(val).slice(8,-1);\n\t}\n\n\tvar sort = isArrSortStable() ? Array.prototype.sort : stableSort;\n\n\t// must be used via stableSort.call(arr, fn)\n\tfunction stableSort(fn) {\n\t\tvar type = typeOf(this[0]);\n\n\t\tif (type == \"Number\" || type == \"String\") {\n\t\t\tvar ord = {}, len = this.length, val;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tval = this[i];\n\t\t\t\tif (ord[val] || ord[val] === 0) continue;\n\t\t\t\tord[val] = i;\n\t\t\t}\n\n\t\t\treturn this.sort(function(a,b) {\n\t\t\t\treturn fn(a,b) || ord[a] - ord[b];\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tvar ord = this.map(function(v){return v});\n\n\t\t\treturn this.sort(function(a,b) {\n\t\t\t\treturn fn(a,b) || ord.indexOf(a) - ord.indexOf(b);\n\t\t\t});\n\t\t}\n\t}\n\n\t// test if js engine's Array#sort implementation is stable\n\tfunction isArrSortStable() {\n\t\tvar str = \"abcdefghijklmnopqrstuvwxyz\";\n\n\t\treturn \"xyzvwtursopqmnklhijfgdeabc\" == str.split(\"\").sort(function(a,b) {\n\t\t\treturn ~~(str.indexOf(b)/2.3) - ~~(str.indexOf(a)/2.3);\n\t\t}).join(\"\");\n\t}\n\n\t// returns uniform pixel data from various img\n\t// TODO?: if array is passed, createimagedata, createlement canvas? take a pxlen?\n\tfunction getImageData(img, width) {\n\t\tvar can, ctx, imgd, buf8, buf32, height;\n\n\t\tswitch (typeOf(img)) {\n\t\t\tcase \"HTMLImageElement\":\n\t\t\t\tcan = document.createElement(\"canvas\");\n\t\t\t\tcan.width = img.naturalWidth;\n\t\t\t\tcan.height = img.naturalHeight;\n\t\t\t\tctx = can.getContext(\"2d\");\n\t\t\t\tctx.drawImage(img,0,0);\n\t\t\tcase \"Canvas\":\n\t\t\tcase \"HTMLCanvasElement\":\n\t\t\t\tcan = can || img;\n\t\t\t\tctx = ctx || can.getContext(\"2d\");\n\t\t\tcase \"CanvasRenderingContext2D\":\n\t\t\t\tctx = ctx || img;\n\t\t\t\tcan = can || ctx.canvas;\n\t\t\t\timgd = ctx.getImageData(0, 0, can.width, can.height);\n\t\t\tcase \"ImageData\":\n\t\t\t\timgd = imgd || img;\n\t\t\t\twidth = imgd.width;\n\t\t\t\tif (typeOf(imgd.data) == \"CanvasPixelArray\")\n\t\t\t\t\tbuf8 = new Uint8Array(imgd.data);\n\t\t\t\telse\n\t\t\t\t\tbuf8 = imgd.data;\n\t\t\tcase \"Array\":\n\t\t\tcase \"CanvasPixelArray\":\n\t\t\t\tbuf8 = buf8 || new Uint8Array(img);\n\t\t\tcase \"Uint8Array\":\n\t\t\tcase \"Uint8ClampedArray\":\n\t\t\t\tbuf8 = buf8 || img;\n\t\t\t\tbuf32 = new Uint32Array(buf8.buffer);\n\t\t\tcase \"Uint32Array\":\n\t\t\t\tbuf32 = buf32 || img;\n\t\t\t\tbuf8 = buf8 || new Uint8Array(buf32.buffer);\n\t\t\t\twidth = width || buf32.length;\n\t\t\t\theight = buf32.length / width;\n\t\t}\n\n\t\treturn {\n\t\t\tcan: can,\n\t\t\tctx: ctx,\n\t\t\timgd: imgd,\n\t\t\tbuf8: buf8,\n\t\t\tbuf32: buf32,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t};\n\t}\n\n\t// partitions a rect of wid x hgt into\n\t// array of bboxes of w0 x h0 (or less)\n\tfunction makeBoxes(wid, hgt, w0, h0) {\n\t\tvar wnum = ~~(wid/w0), wrem = wid%w0,\n\t\t\thnum = ~~(hgt/h0), hrem = hgt%h0,\n\t\t\txend = wid-wrem, yend = hgt-hrem;\n\n\t\tvar bxs = [];\n\t\tfor (var y = 0; y < hgt; y += h0)\n\t\t\tfor (var x = 0; x < wid; x += w0)\n\t\t\t\tbxs.push({x:x, y:y, w:(x==xend?wrem:w0), h:(y==yend?hrem:h0)});\n\n\t\treturn bxs;\n\t}\n\n\t// iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\n\tfunction iterBox(bbox, wid, fn) {\n\t\tvar b = bbox,\n\t\t\ti0 = b.y * wid + b.x,\n\t\t\ti1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1),\n\t\t\tcnt = 0, incr = wid - b.w + 1, i = i0;\n\n\t\tdo {\n\t\t\tfn.call(this, i);\n\t\t\ti += (++cnt % b.w == 0) ? incr : 1;\n\t\t} while (i <= i1);\n\t}\n\n\t// returns array of hash keys sorted by their values\n\tfunction sortedHashKeys(obj, desc) {\n\t\tvar keys = [];\n\n\t\tfor (var key in obj)\n\t\t\tkeys.push(key);\n\n\t\treturn sort.call(keys, function(a,b) {\n\t\t\treturn desc ? obj[b] - obj[a] : obj[a] - obj[b];\n\t\t});\n\t}\n\n\t// expose\n\tthis.RgbQuant = RgbQuant;\n\n\t// expose to commonJS\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = RgbQuant;\n\t}\n\n}).call(this);","// @ts-expect-error\nimport RGBQuant from \"rgbquant\";\nimport { createConsole } from \"./Console.ts\";\nimport { hexToRGB, rgbToHex } from \"./ColorUtils.ts\";\nimport { getVector3Length, Vector3 } from \"./MathUtils.ts\";\nimport {\n  DisplayColorRGB,\n  numberOfColorsToPixelDepth,\n  pixelDepthToPixelBitWidth,\n  pixelDepthToPixelsPerByte,\n} from \"./DisplayUtils.ts\";\nimport { DisplayBitmap } from \"../DisplayManager.ts\";\nimport {\n  DisplaySprite,\n  DisplaySpriteSheet,\n} from \"./DisplaySpriteSheetUtils.ts\";\n\nconst _console = createConsole(\"DisplayBitmapUtils\", { log: false });\n\nexport const drawBitmapHeaderLength = 2 + 2 + 2 + 2 + 1 + 2; // x, y, width, numberOfPixels, numberOfColors, dataLength\n\nexport function getBitmapData(bitmap: DisplayBitmap) {\n  const pixelDataLength = getBitmapNumberOfBytes(bitmap);\n  const dataView = new DataView(new ArrayBuffer(pixelDataLength));\n  const pixelDepth = numberOfColorsToPixelDepth(bitmap.numberOfColors)!;\n  const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);\n  bitmap.pixels.forEach((bitmapColorIndex, pixelIndex) => {\n    const byteIndex = Math.floor(pixelIndex / pixelsPerByte);\n    const byteSlot = pixelIndex % pixelsPerByte;\n    const pixelBitWidth = pixelDepthToPixelBitWidth(pixelDepth);\n    const bitOffset = pixelBitWidth * byteSlot;\n    const shift = 8 - pixelBitWidth - bitOffset;\n    let value = dataView.getUint8(byteIndex);\n    value |= bitmapColorIndex << shift;\n    dataView.setUint8(byteIndex, value);\n  });\n  _console.log(\"getBitmapData\", bitmap, dataView);\n  return dataView;\n}\n\nexport async function quantizeCanvas(\n  canvas: HTMLCanvasElement,\n  ctx: CanvasRenderingContext2D,\n  numberOfColors: number,\n  colors?: string[]\n) {\n  _console.assertWithError(\n    numberOfColors > 1,\n    \"numberOfColors must be greater than 1\"\n  );\n\n  _console.log({ numberOfColors });\n\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n\n  // turn any non-opaque pixel to black\n  for (let i = 0; i < data.length; i += 4) {\n    const alpha = data[i + 3];\n\n    if (alpha < 255) {\n      data[i] = 0;\n      data[i + 1] = 0;\n      data[i + 2] = 0;\n      data[i + 3] = 255;\n    }\n  }\n\n  ctx.putImageData(imageData, 0, 0);\n\n  const isSmall = canvas.width * canvas.height < 4;\n\n  const quantOptions = {\n    method: isSmall ? 1 : 2,\n    colors: numberOfColors,\n    dithKern: null, // Disable dithering\n    useCache: false, // Disable color caching to force exact matches\n    reIndex: true, // Ensure strict re-indexing to the palette\n    //orDist: \"manhattan\",\n  };\n  _console.log(\"quantOptions\", quantOptions);\n\n  if (colors) {\n    // @ts-ignore\n    quantOptions.palette = colors.map((color) => {\n      const rgb = hexToRGB(color);\n      if (rgb) {\n        const { r, g, b } = rgb;\n        return [r, g, b];\n      } else {\n        _console.error(`invalid rgb hex \"${color}\"`);\n      }\n    });\n  }\n  _console.log(\"quantizeImage options\", quantOptions);\n  const quantizer = new RGBQuant(quantOptions);\n  quantizer.sample(imageData);\n\n  const quantizedPixels = quantizer.reduce(imageData.data);\n  const quantizedImageData = new ImageData(\n    new Uint8ClampedArray(quantizedPixels.buffer),\n    canvas.width,\n    canvas.height\n  );\n  ctx.putImageData(quantizedImageData, 0, 0);\n\n  const pixels = quantizedImageData.data;\n\n  const quantizedPaletteData: Uint8Array = quantizer.palette();\n  const numberOfQuantizedPaletteColors = quantizedPaletteData.byteLength / 4;\n  _console.log(\"quantized palette data\", quantizedPaletteData);\n  const quantizedPaletteColors: DisplayColorRGB[] = [];\n  let closestColorIndexToBlack = 0;\n  let closestColorDistanceToBlack = Infinity;\n  const vector3: Vector3 = { x: 0, y: 0, z: 0 };\n  for (\n    let colorIndex = 0;\n    colorIndex < numberOfQuantizedPaletteColors;\n    colorIndex++\n  ) {\n    const rgb: DisplayColorRGB = {\n      r: quantizedPaletteData[colorIndex * 4],\n      g: quantizedPaletteData[colorIndex * 4 + 1],\n      b: quantizedPaletteData[colorIndex * 4 + 2],\n    };\n    quantizedPaletteColors.push(rgb);\n    vector3.x = rgb.r;\n    vector3.y = rgb.g;\n    vector3.z = rgb.b;\n\n    const distanceToBlack = getVector3Length(vector3);\n    if (distanceToBlack < closestColorDistanceToBlack) {\n      closestColorDistanceToBlack = distanceToBlack;\n      closestColorIndexToBlack = colorIndex;\n    }\n  }\n  _console.log({ closestColorIndexToBlack, closestColorDistanceToBlack });\n  if (closestColorIndexToBlack != 0) {\n    const [currentBlack, newBlack] = [\n      quantizedPaletteColors[0],\n      quantizedPaletteColors[closestColorIndexToBlack],\n    ];\n    quantizedPaletteColors[0] = newBlack;\n    quantizedPaletteColors[closestColorIndexToBlack] = currentBlack;\n  }\n  _console.log(\"quantizedPaletteColors\", quantizedPaletteColors);\n  const quantizedColors = quantizedPaletteColors.map((rgb, index) => {\n    const hex = rgbToHex(rgb);\n    return hex;\n  });\n  _console.log(\"quantizedColors\", quantizedColors);\n\n  const quantizedColorIndices: number[] = [];\n  for (let i = 0; i < pixels.length; i += 4) {\n    const r = pixels[i];\n    const g = pixels[i + 1];\n    const b = pixels[i + 2];\n    const a = pixels[i + 3];\n\n    const hex = rgbToHex({ r, g, b });\n    quantizedColorIndices.push(quantizedColors.indexOf(hex));\n  }\n  _console.log(\"quantizedColorIndices\", quantizedColorIndices);\n\n  const promise = new Promise<Blob>((resolve, reject) => {\n    canvas.toBlob((blob) => {\n      if (blob) {\n        resolve(blob);\n      } else {\n        reject();\n      }\n    }, \"image/png\");\n  });\n\n  const blob = await promise;\n  return {\n    blob,\n    colors: quantizedColors,\n    colorIndices: quantizedColorIndices,\n  };\n}\n\nexport async function quantizeImage(\n  image: HTMLImageElement,\n  width: number,\n  height: number,\n  numberOfColors: number\n) {\n  _console.assertWithError(\n    numberOfColors > 1,\n    \"numberOfColors must be greater than 1\"\n  );\n\n  _console.log({ numberOfColors });\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\", { willReadFrequently: true })!;\n\n  let { naturalWidth: imageWidth, naturalHeight: imageHeight } = image;\n  _console.log({ imageWidth, imageHeight });\n\n  canvas.width = width;\n  canvas.height = height;\n\n  ctx.imageSmoothingEnabled = false;\n\n  ctx.drawImage(image, 0, 0, width, height);\n\n  return quantizeCanvas(canvas, ctx, numberOfColors);\n}\n\nexport async function resizeAndQuantizeImage(\n  image: HTMLImageElement,\n  width: number,\n  height: number,\n  colors: string[]\n) {\n  _console.assertWithError(\n    colors.length > 1,\n    \"colors.length must be greater than 1\"\n  );\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\")!;\n\n  let { naturalWidth: imageWidth, naturalHeight: imageHeight } = image;\n  _console.log({ imageWidth, imageHeight });\n\n  canvas.width = width;\n  canvas.height = height;\n\n  ctx.imageSmoothingEnabled = false;\n\n  ctx.drawImage(image, 0, 0, width, height);\n\n  const imageData = ctx.getImageData(0, 0, width, height);\n  const data = imageData.data;\n\n  // turn any non-opaque pixel to black\n  for (let i = 0; i < data.length; i += 4) {\n    const alpha = data[i + 3];\n\n    if (alpha < 255) {\n      data[i] = 0;\n      data[i + 1] = 0;\n      data[i + 2] = 0;\n      data[i + 3] = 255;\n    }\n  }\n\n  ctx.putImageData(imageData, 0, 0);\n\n  const isSmall = canvas.width * canvas.height < 4;\n\n  const quantOptions = {\n    method: isSmall ? 1 : 2,\n    colors: colors.length,\n    dithKern: null, // Disable dithering\n    useCache: false, // Disable color caching to force exact matches\n    reIndex: true, // Ensure strict re-indexing to the palette\n    //orDist: \"manhattan\",\n  };\n\n  _console.log(\"quantOptions\", quantOptions);\n\n  // @ts-ignore\n  quantOptions.palette = colors.map((color) => {\n    const rgb = hexToRGB(color);\n    if (rgb) {\n      const { r, g, b } = rgb;\n      return [r, g, b];\n    } else {\n      _console.error(`invalid rgb hex \"${color}\"`);\n    }\n  });\n  _console.log(\"quantizeImage options\", quantOptions);\n  const quantizer = new RGBQuant(quantOptions);\n  quantizer.sample(imageData);\n\n  const quantizedPixels = quantizer.reduce(imageData.data);\n  const quantizedImageData = new ImageData(\n    new Uint8ClampedArray(quantizedPixels.buffer),\n    width,\n    height\n  );\n  ctx.putImageData(quantizedImageData, 0, 0);\n\n  const pixels = quantizedImageData.data;\n\n  const quantizedColorIndices: number[] = [];\n  for (let i = 0; i < pixels.length; i += 4) {\n    const r = pixels[i];\n    const g = pixels[i + 1];\n    const b = pixels[i + 2];\n    const a = pixels[i + 3];\n\n    const hex = rgbToHex({ r, g, b });\n\n    const colorIndex = colors.findIndex((color) => color == hex);\n    if (colorIndex == -1) {\n      _console.error(`no color found for ${hex}`);\n      quantizedColorIndices.push(0);\n      continue;\n    }\n    quantizedColorIndices.push(colorIndex);\n  }\n  _console.log(\"quantizedColorIndices\", quantizedColorIndices);\n\n  const promise = new Promise<Blob>((resolve, reject) => {\n    canvas.toBlob((blob) => {\n      if (blob) {\n        resolve(blob);\n      } else {\n        reject();\n      }\n    }, \"image/png\");\n  });\n  const blob = await promise;\n  return {\n    blob,\n    colorIndices: quantizedColorIndices,\n  };\n}\n\nexport async function imageToBitmap(\n  image: HTMLImageElement,\n  width: number,\n  height: number,\n  colors: string[],\n  bitmapColorIndices: number[],\n  numberOfColors?: number\n) {\n  if (numberOfColors == undefined) {\n    numberOfColors = colors.length;\n  }\n  const bitmapColors = bitmapColorIndices\n    .map((bitmapColorIndex) => colors[bitmapColorIndex])\n    .slice(0, numberOfColors);\n  const { blob, colorIndices } = await resizeAndQuantizeImage(\n    image,\n    width,\n    height,\n    bitmapColors\n  );\n  const bitmap: DisplayBitmap = {\n    numberOfColors,\n    pixels: colorIndices,\n    width,\n    height,\n  };\n  return { blob, bitmap };\n}\n\nexport function getBitmapNumberOfBytes(bitmap: DisplayBitmap) {\n  const pixelDepth = numberOfColorsToPixelDepth(bitmap.numberOfColors)!;\n  const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);\n  const numberOfPixels = bitmap.pixels.length;\n  const pixelDataLength = Math.ceil(numberOfPixels / pixelsPerByte);\n  _console.log({\n    pixelDepth,\n    pixelsPerByte,\n    numberOfPixels,\n    pixelDataLength,\n  });\n  return pixelDataLength;\n}\nexport function assertValidBitmapPixels(bitmap: DisplayBitmap) {\n  _console.assertRangeWithError(\n    \"bitmap.pixels.length\",\n    bitmap.pixels.length,\n    bitmap.width * (bitmap.height - 1) + 1,\n    bitmap.width * bitmap.height\n  );\n  bitmap.pixels.forEach((pixel, index) => {\n    _console.assertRangeWithError(\n      `bitmap.pixels[${index}]`,\n      pixel,\n      0,\n      bitmap.numberOfColors - 1\n    );\n  });\n}\n\nexport async function imageToSprite(\n  image: HTMLImageElement,\n  spriteName: string,\n  width: number,\n  height: number,\n  numberOfColors: number,\n  paletteName: string,\n  overridePalette: boolean,\n  spriteSheet: DisplaySpriteSheet,\n  paletteOffset: number\n) {\n  let palette = spriteSheet.palettes?.find(\n    (palette) => palette.name == paletteName\n  );\n  if (!palette) {\n    palette = {\n      name: paletteName,\n      numberOfColors,\n      colors: new Array(numberOfColors).fill(\"#000000\"),\n      opacities: new Array(numberOfColors).fill(1),\n    };\n    spriteSheet.palettes?.push(palette);\n  }\n\n  _console.assertWithError(\n    numberOfColors + paletteOffset <= palette.numberOfColors,\n    `invalid numberOfColors ${numberOfColors} + offset ${paletteOffset} (max ${palette.numberOfColors})`\n  );\n\n  const sprite: DisplaySprite = {\n    name: spriteName,\n    width,\n    height,\n    paletteSwaps: [],\n    commands: [],\n  };\n\n  let blob: Blob;\n  let colorIndices: number[];\n  if (overridePalette) {\n    const results = await quantizeImage(\n      image,\n      width,\n      height,\n      palette.numberOfColors\n    );\n    blob = results.blob;\n    colorIndices = results.colorIndices;\n    results.colors.forEach((color, index) => {\n      palette.colors[index + paletteOffset] = color;\n    });\n  } else {\n    const results = await resizeAndQuantizeImage(\n      image,\n      width,\n      height,\n      palette.colors.slice(paletteOffset, numberOfColors)\n    );\n    blob = results.blob;\n    colorIndices = results.colorIndices;\n  }\n\n  sprite.commands.push({\n    type: \"selectBitmapColors\",\n    bitmapColorPairs: new Array(numberOfColors).fill(0).map((_, index) => ({\n      bitmapColorIndex: index,\n      colorIndex: index + paletteOffset,\n    })),\n  });\n  const bitmap: DisplayBitmap = {\n    numberOfColors,\n    pixels: colorIndices,\n    width,\n    height,\n  };\n  sprite.commands.push({ type: \"drawBitmap\", offsetX: 0, offsetY: 0, bitmap });\n\n  const spriteIndex = spriteSheet.sprites.findIndex(\n    (sprite) => sprite.name == spriteName\n  );\n  if (spriteIndex == -1) {\n    spriteSheet.sprites.push(sprite);\n  } else {\n    spriteSheet.sprites[spriteIndex] = sprite;\n  }\n\n  return { sprite, blob };\n}\nexport async function imageToSpriteSheet(\n  image: HTMLImageElement,\n  name: string,\n  width: number,\n  height: number,\n  numberOfColors: number,\n  paletteName: string\n) {\n  const spriteSheet: DisplaySpriteSheet = {\n    name,\n    palettes: [],\n    paletteSwaps: [],\n    sprites: [],\n  };\n\n  await imageToSprite(\n    image,\n    \"image\",\n    width,\n    height,\n    numberOfColors,\n    paletteName,\n    true,\n    spriteSheet,\n    0\n  );\n\n  return spriteSheet;\n}\n","import {\n  DisplayBitmap,\n  DisplayBitmapColorPair,\n  DisplaySpriteColorPair,\n} from \"../DisplayManager.ts\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./ArrayBufferUtils.ts\";\nimport { rgbToHex, stringToRGB } from \"./ColorUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { drawBitmapHeaderLength, getBitmapData } from \"./DisplayBitmapUtils.ts\";\nimport {\n  DisplaySegmentCap,\n  DisplaySegmentCaps,\n} from \"./DisplayContextState.ts\";\nimport { DisplayManagerInterface } from \"./DisplayManagerInterface.ts\";\nimport { DisplaySpriteSheet } from \"./DisplaySpriteSheetUtils.ts\";\nimport {\n  assertValidColor,\n  assertValidOpacity,\n  assertValidSegmentCap,\n  DisplayColorRGB,\n  DisplayCropDirectionToCommandType,\n  displayScaleStep,\n  formatRotation,\n  formatScale,\n  maxDisplayScale,\n  minDisplayScale,\n  roundScale,\n} from \"./DisplayUtils.ts\";\nimport {\n  clamp,\n  degToRad,\n  Int16Max,\n  Int16Min,\n  normalizeRadians,\n  twoPi,\n  Vector2,\n} from \"./MathUtils.ts\";\n\nconst _console = createConsole(\"DisplayContextCommand\", { log: true });\n\nexport const DisplayContextCommandTypes = [\n  \"show\",\n  \"clear\",\n\n  \"setColor\",\n  \"setColorOpacity\",\n  \"setOpacity\",\n\n  \"saveContext\",\n  \"restoreContext\",\n\n  \"selectFillColor\",\n  \"selectLineColor\",\n  \"setLineWidth\",\n  \"setRotation\",\n  \"clearRotation\",\n\n  \"setSegmentStartCap\",\n  \"setSegmentEndCap\",\n  \"setSegmentCap\",\n\n  \"setSegmentStartRadius\",\n  \"setSegmentEndRadius\",\n  \"setSegmentRadius\",\n\n  \"setCropTop\",\n  \"setCropRight\",\n  \"setCropBottom\",\n  \"setCropLeft\",\n  \"clearCrop\",\n\n  \"setRotationCropTop\",\n  \"setRotationCropRight\",\n  \"setRotationCropBottom\",\n  \"setRotationCropLeft\",\n  \"clearRotationCrop\",\n\n  \"selectBitmapColor\",\n  \"selectBitmapColors\",\n  \"setBitmapScaleX\",\n  \"setBitmapScaleY\",\n  \"setBitmapScale\",\n  \"resetBitmapScale\",\n\n  \"selectSpriteColor\",\n  \"selectSpriteColors\",\n  \"resetSpriteColors\",\n  \"setSpriteScaleX\",\n  \"setSpriteScaleY\",\n  \"setSpriteScale\",\n  \"resetSpriteScale\",\n\n  \"clearRect\",\n\n  \"drawRect\",\n  \"drawRoundRect\",\n  \"drawCircle\",\n  \"drawEllipse\",\n  \"drawPolygon\",\n  \"drawSegment\",\n  \"drawSegments\",\n\n  \"drawArc\",\n  \"drawArcEllipse\",\n\n  \"drawBitmap\",\n\n  \"selectSpriteSheet\",\n  \"drawSprite\",\n  //\"drawSprites\",\n] as const;\nexport type DisplayContextCommandType =\n  (typeof DisplayContextCommandTypes)[number];\n\nexport const DisplaySpriteContextCommandTypes = [\n  \"selectFillColor\",\n  \"selectLineColor\",\n  \"setLineWidth\",\n  \"setRotation\",\n  \"clearRotation\",\n\n  \"setSegmentStartCap\",\n  \"setSegmentEndCap\",\n  \"setSegmentCap\",\n\n  \"setSegmentStartRadius\",\n  \"setSegmentEndRadius\",\n  \"setSegmentRadius\",\n\n  \"setCropTop\",\n  \"setCropRight\",\n  \"setCropBottom\",\n  \"setCropLeft\",\n  \"clearCrop\",\n\n  \"setRotationCropTop\",\n  \"setRotationCropRight\",\n  \"setRotationCropBottom\",\n  \"setRotationCropLeft\",\n  \"clearRotationCrop\",\n\n  \"selectBitmapColor\",\n  \"selectBitmapColors\",\n  \"setBitmapScaleX\",\n  \"setBitmapScaleY\",\n  \"setBitmapScale\",\n  \"resetBitmapScale\",\n\n  \"selectSpriteColor\",\n  \"selectSpriteColors\",\n  \"resetSpriteColors\",\n  \"setSpriteScaleX\",\n  \"setSpriteScaleY\",\n  \"setSpriteScale\",\n  \"resetSpriteScale\",\n\n  \"clearRect\",\n\n  \"drawRect\",\n  \"drawRoundRect\",\n  \"drawCircle\",\n  \"drawEllipse\",\n  \"drawPolygon\",\n  \"drawSegment\",\n  \"drawSegments\",\n\n  \"drawArc\",\n  \"drawArcEllipse\",\n\n  \"drawBitmap\",\n  \"drawSprite\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type DisplaySpriteContextCommandType =\n  (typeof DisplaySpriteContextCommandTypes)[number];\n\nexport interface BaseDisplayContextCommand {\n  type: DisplayContextCommandType | \"runDisplayContextCommands\";\n  hide?: boolean;\n}\n\nexport interface SimpleDisplayCommand extends BaseDisplayContextCommand {\n  type:\n    | \"show\"\n    | \"clear\"\n    | \"saveContext\"\n    | \"restoreContext\"\n    | \"clearRotation\"\n    | \"clearCrop\"\n    | \"clearRotationCrop\"\n    | \"resetBitmapScale\"\n    | \"resetSpriteColors\"\n    | \"resetSpriteScale\";\n}\n\nexport interface SetDisplayColorCommand extends BaseDisplayContextCommand {\n  type: \"setColor\";\n  colorIndex: number;\n  color: DisplayColorRGB | string;\n}\nexport interface SetDisplayColorOpacityCommand\n  extends BaseDisplayContextCommand {\n  type: \"setColorOpacity\";\n  colorIndex: number;\n  opacity: number;\n}\nexport interface SetDisplayOpacityCommand extends BaseDisplayContextCommand {\n  type: \"setOpacity\";\n  opacity: number;\n}\n\nexport interface SelectDisplayFillColorCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectFillColor\";\n  fillColorIndex: number;\n}\nexport interface SelectDisplayLineColorCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectLineColor\";\n  lineColorIndex: number;\n}\nexport interface SetDisplayLineWidthCommand extends BaseDisplayContextCommand {\n  type: \"setLineWidth\";\n  lineWidth: number;\n}\nexport interface SetDisplayRotationCommand extends BaseDisplayContextCommand {\n  type: \"setRotation\";\n  rotation: number;\n  isRadians?: boolean;\n}\n\nexport interface SetDisplaySegmentStartCapCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentStartCap\";\n  segmentStartCap: DisplaySegmentCap;\n}\nexport interface SetDisplaySegmentEndCapCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentEndCap\";\n  segmentEndCap: DisplaySegmentCap;\n}\nexport interface SetDisplaySegmentCapCommand extends BaseDisplayContextCommand {\n  type: \"setSegmentCap\";\n  segmentCap: DisplaySegmentCap;\n}\n\nexport interface SetDisplaySegmentStartRadiusCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentStartRadius\";\n  segmentStartRadius: number;\n}\nexport interface SetDisplaySegmentEndRadiusCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentEndRadius\";\n  segmentEndRadius: number;\n}\nexport interface SetDisplaySegmentRadiusCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentRadius\";\n  segmentRadius: number;\n}\n\nexport interface SetDisplayCropTopCommand extends BaseDisplayContextCommand {\n  type: \"setCropTop\";\n  cropTop: number;\n}\nexport interface SetDisplayCropRightCommand extends BaseDisplayContextCommand {\n  type: \"setCropRight\";\n  cropRight: number;\n}\nexport interface SetDisplayCropBottomCommand extends BaseDisplayContextCommand {\n  type: \"setCropBottom\";\n  cropBottom: number;\n}\nexport interface SetDisplayCropLeftCommand extends BaseDisplayContextCommand {\n  type: \"setCropLeft\";\n  cropLeft: number;\n}\n\nexport interface SetDisplayRotationCropTopCommand\n  extends BaseDisplayContextCommand {\n  type: \"setRotationCropTop\";\n  rotationCropTop: number;\n}\nexport interface SetDisplayRotationCropRightCommand\n  extends BaseDisplayContextCommand {\n  type: \"setRotationCropRight\";\n  rotationCropRight: number;\n}\nexport interface SetDisplayRotationCropBottomCommand\n  extends BaseDisplayContextCommand {\n  type: \"setRotationCropBottom\";\n  rotationCropBottom: number;\n}\nexport interface SetDisplayRotationCropLeftCommand\n  extends BaseDisplayContextCommand {\n  type: \"setRotationCropLeft\";\n  rotationCropLeft: number;\n}\n\nexport interface SelectDisplayBitmapColorIndexCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectBitmapColor\";\n  bitmapColorIndex: number;\n  colorIndex: number;\n}\nexport interface SelectDisplayBitmapColorIndicesCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectBitmapColors\";\n  bitmapColorPairs: DisplayBitmapColorPair[];\n}\n\nexport interface SetDisplayBitmapScaleXCommand\n  extends BaseDisplayContextCommand {\n  type: \"setBitmapScaleX\";\n  bitmapScaleX: number;\n}\nexport interface SetDisplayBitmapScaleYCommand\n  extends BaseDisplayContextCommand {\n  type: \"setBitmapScaleY\";\n  bitmapScaleY: number;\n}\nexport interface SetDisplayBitmapScaleCommand\n  extends BaseDisplayContextCommand {\n  type: \"setBitmapScale\";\n  bitmapScale: number;\n}\n\nexport interface SelectDisplaySpriteColorIndexCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectSpriteColor\";\n  spriteColorIndex: number;\n  colorIndex: number;\n}\nexport interface SelectDisplaySpriteColorIndicesCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectSpriteColors\";\n  spriteColorPairs: DisplaySpriteColorPair[];\n}\n\nexport interface SetDisplaySpriteScaleXCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpriteScaleX\";\n  spriteScaleX: number;\n}\nexport interface SetDisplaySpriteScaleYCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpriteScaleY\";\n  spriteScaleY: number;\n}\nexport interface SetDisplaySpriteScaleCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpriteScale\";\n  spriteScale: number;\n}\n\nexport interface BasePositionDisplayContextCommand\n  extends BaseDisplayContextCommand {\n  x: number;\n  y: number;\n}\nexport interface BaseOffsetPositionDisplayContextCommand\n  extends BaseDisplayContextCommand {\n  offsetX: number;\n  offsetY: number;\n}\nexport interface BaseSizeDisplayContextCommand\n  extends BaseDisplayContextCommand {\n  width: number;\n  height: number;\n}\n\nexport interface BaseDisplayRectCommand\n  extends BasePositionDisplayContextCommand,\n    BaseSizeDisplayContextCommand {}\nexport interface BaseDisplayCenterRectCommand\n  extends BaseOffsetPositionDisplayContextCommand,\n    BaseSizeDisplayContextCommand {}\n\nexport interface ClearDisplayRectCommand extends BaseDisplayRectCommand {\n  type: \"clearRect\";\n}\nexport interface DrawDisplayRectCommand extends BaseDisplayCenterRectCommand {\n  type: \"drawRect\";\n}\n\nexport interface DrawDisplayRoundedRectCommand\n  extends BaseOffsetPositionDisplayContextCommand,\n    BaseSizeDisplayContextCommand {\n  type: \"drawRoundRect\";\n  borderRadius: number;\n}\n\nexport interface DrawDisplayCircleCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawCircle\";\n  radius: number;\n}\nexport interface DrawDisplayEllipseCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawEllipse\";\n  radiusX: number;\n  radiusY: number;\n}\n\nexport interface DrawDisplayPolygonCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawPolygon\";\n  radius: number;\n  numberOfSides: number;\n}\nexport interface DrawDisplaySegmentCommand extends BaseDisplayContextCommand {\n  type: \"drawSegment\";\n  startX: number;\n  startY: number;\n  endX: number;\n  endY: number;\n}\nexport interface DrawDisplaySegmentsCommand extends BaseDisplayContextCommand {\n  type: \"drawSegments\";\n  points: Vector2[];\n}\n\nexport interface DrawDisplayArcCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawArc\";\n  radius: number;\n  startAngle: number;\n  angleOffset: number;\n  isRadians?: boolean;\n}\nexport interface DrawDisplayArcEllipseCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawArcEllipse\";\n  radiusX: number;\n  radiusY: number;\n  startAngle: number;\n  angleOffset: number;\n  isRadians?: boolean;\n}\n\nexport interface DrawDisplayBitmapCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawBitmap\";\n  bitmap: DisplayBitmap;\n}\n\nexport interface SelectDisplaySpriteSheetCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectSpriteSheet\";\n  spriteSheetIndex: number;\n}\n\nexport interface DrawDisplaySpriteCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawSprite\";\n  spriteIndex: number;\n  use2Bytes: boolean;\n}\n\nexport type DisplayContextCommand =\n  | SimpleDisplayCommand\n  | SetDisplayColorCommand\n  | SetDisplayColorOpacityCommand\n  | SetDisplayOpacityCommand\n  | SelectDisplayFillColorCommand\n  | SelectDisplayLineColorCommand\n  | SetDisplayLineWidthCommand\n  | SetDisplayRotationCommand\n  | SetDisplaySegmentStartCapCommand\n  | SetDisplaySegmentEndCapCommand\n  | SetDisplaySegmentCapCommand\n  | SetDisplaySegmentStartRadiusCommand\n  | SetDisplaySegmentEndRadiusCommand\n  | SetDisplaySegmentRadiusCommand\n  | SetDisplayCropTopCommand\n  | SetDisplayCropRightCommand\n  | SetDisplayCropBottomCommand\n  | SetDisplayCropLeftCommand\n  | SetDisplayRotationCropTopCommand\n  | SetDisplayRotationCropRightCommand\n  | SetDisplayRotationCropBottomCommand\n  | SetDisplayRotationCropLeftCommand\n  | SelectDisplayBitmapColorIndexCommand\n  | SelectDisplayBitmapColorIndicesCommand\n  | SetDisplayBitmapScaleXCommand\n  | SetDisplayBitmapScaleYCommand\n  | SetDisplayBitmapScaleCommand\n  | SelectDisplaySpriteColorIndexCommand\n  | SelectDisplaySpriteColorIndicesCommand\n  | SetDisplaySpriteScaleXCommand\n  | SetDisplaySpriteScaleYCommand\n  | SetDisplaySpriteScaleCommand\n  | ClearDisplayRectCommand\n  | DrawDisplayRectCommand\n  | DrawDisplayRoundedRectCommand\n  | DrawDisplayCircleCommand\n  | DrawDisplayEllipseCommand\n  | DrawDisplayPolygonCommand\n  | DrawDisplaySegmentCommand\n  | DrawDisplaySegmentsCommand\n  | DrawDisplayArcCommand\n  | DrawDisplayArcEllipseCommand\n  | DrawDisplayBitmapCommand\n  | DrawDisplaySpriteCommand\n  | SelectDisplaySpriteSheetCommand;\n\nexport function serializeContextCommand(\n  displayManager: DisplayManagerInterface,\n  command: DisplayContextCommand\n) {\n  let dataView: DataView | undefined;\n\n  switch (command.type) {\n    case \"show\":\n    case \"clear\":\n    case \"saveContext\":\n    case \"restoreContext\":\n    case \"clearRotation\":\n    case \"clearCrop\":\n    case \"clearRotationCrop\":\n    case \"resetBitmapScale\":\n    case \"resetSpriteColors\":\n    case \"resetSpriteScale\":\n      break;\n    case \"setColor\":\n      {\n        const { color, colorIndex } = command;\n\n        let colorRGB: DisplayColorRGB;\n        if (typeof color == \"string\") {\n          colorRGB = stringToRGB(color);\n        } else {\n          colorRGB = color;\n        }\n        const colorHex = rgbToHex(colorRGB);\n        if (displayManager.colors[colorIndex] == colorHex) {\n          _console.log(`redundant color #${colorIndex} ${colorHex}`);\n          return;\n        }\n\n        _console.log(`setting color #${colorIndex}`, colorRGB);\n        displayManager.assertValidColorIndex(colorIndex);\n        assertValidColor(colorRGB);\n        dataView = new DataView(new ArrayBuffer(4));\n        dataView.setUint8(0, colorIndex);\n        dataView.setUint8(1, colorRGB.r);\n        dataView.setUint8(2, colorRGB.g);\n        dataView.setUint8(3, colorRGB.b);\n      }\n      break;\n    case \"setColorOpacity\":\n      {\n        const { colorIndex, opacity } = command;\n        displayManager.assertValidColorIndex(colorIndex);\n        assertValidOpacity(opacity);\n        if (\n          Math.floor(255 * displayManager.opacities[colorIndex]) ==\n          Math.floor(255 * opacity)\n        ) {\n          _console.log(`redundant opacity #${colorIndex} ${opacity}`);\n          return;\n        }\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint8(0, colorIndex);\n        dataView.setUint8(1, opacity * 255);\n      }\n      break;\n    case \"setOpacity\":\n      {\n        const { opacity } = command;\n        assertValidOpacity(opacity);\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, Math.round(opacity * 255));\n      }\n      break;\n    case \"selectFillColor\":\n      {\n        const { fillColorIndex } = command;\n        displayManager.assertValidColorIndex(fillColorIndex);\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, fillColorIndex);\n      }\n      break;\n    case \"selectLineColor\":\n      {\n        const { lineColorIndex } = command;\n        displayManager.assertValidColorIndex(lineColorIndex);\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, lineColorIndex);\n      }\n      break;\n    case \"setLineWidth\":\n      {\n        const { lineWidth } = command;\n        displayManager.assertValidLineWidth(lineWidth);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, lineWidth, true);\n      }\n      break;\n    case \"setRotation\":\n      {\n        let { rotation, isRadians } = command;\n        rotation = isRadians ? rotation : degToRad(rotation);\n        rotation = normalizeRadians(rotation);\n        isRadians = true;\n        // _console.log({ rotation, isRadians });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, formatRotation(rotation, isRadians), true);\n      }\n      break;\n    case \"setSegmentStartCap\":\n      {\n        const { segmentStartCap } = command;\n        assertValidSegmentCap(segmentStartCap);\n        _console.log({ segmentStartCap });\n        dataView = new DataView(new ArrayBuffer(1));\n        const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentStartCap);\n        dataView.setUint8(0, segmentCapEnum);\n      }\n      break;\n    case \"setSegmentEndCap\":\n      {\n        const { segmentEndCap } = command;\n        assertValidSegmentCap(segmentEndCap);\n        _console.log({ segmentEndCap });\n        dataView = new DataView(new ArrayBuffer(1));\n        const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentEndCap);\n        dataView.setUint8(0, segmentCapEnum);\n      }\n      break;\n    case \"setSegmentCap\":\n      {\n        const { segmentCap } = command;\n        assertValidSegmentCap(segmentCap);\n        _console.log({ segmentCap });\n        dataView = new DataView(new ArrayBuffer(1));\n        const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentCap);\n        dataView.setUint8(0, segmentCapEnum);\n      }\n      break;\n    case \"setSegmentStartRadius\":\n      {\n        const { segmentStartRadius } = command;\n        _console.log({ segmentStartRadius });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, segmentStartRadius, true);\n      }\n      break;\n    case \"setSegmentEndRadius\":\n      {\n        const { segmentEndRadius } = command;\n        _console.log({ segmentEndRadius });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, segmentEndRadius, true);\n      }\n      break;\n    case \"setSegmentRadius\":\n      {\n        const { segmentRadius } = command;\n        _console.log({ segmentRadius });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, segmentRadius, true);\n      }\n      break;\n    case \"setCropTop\":\n      {\n        const { cropTop } = command;\n        _console.log({ cropTop });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, cropTop, true);\n      }\n      break;\n    case \"setCropRight\":\n      {\n        const { cropRight } = command;\n        _console.log({ cropRight });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, cropRight, true);\n      }\n      break;\n    case \"setCropBottom\":\n      {\n        const { cropBottom } = command;\n        _console.log({ cropBottom });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, cropBottom, true);\n      }\n      break;\n    case \"setCropLeft\":\n      {\n        const { cropLeft } = command;\n        _console.log({ cropLeft });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, cropLeft, true);\n      }\n      break;\n    case \"setRotationCropTop\":\n      {\n        const { rotationCropTop } = command;\n        _console.log({ rotationCropTop });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, rotationCropTop, true);\n      }\n      break;\n    case \"setRotationCropRight\":\n      {\n        const { rotationCropRight } = command;\n        _console.log({ rotationCropRight });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, rotationCropRight, true);\n      }\n      break;\n    case \"setRotationCropBottom\":\n      {\n        const { rotationCropBottom } = command;\n        _console.log({ rotationCropBottom });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, rotationCropBottom, true);\n      }\n      break;\n    case \"setRotationCropLeft\":\n      {\n        const { rotationCropLeft } = command;\n        _console.log({ rotationCropLeft });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, rotationCropLeft, true);\n      }\n      break;\n    case \"selectBitmapColor\":\n      {\n        const { bitmapColorIndex, colorIndex } = command;\n        displayManager.assertValidColorIndex(bitmapColorIndex);\n        displayManager.assertValidColorIndex(colorIndex);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint8(0, bitmapColorIndex);\n        dataView.setUint8(1, colorIndex);\n      }\n      break;\n    case \"selectBitmapColors\":\n      {\n        const { bitmapColorPairs } = command;\n\n        _console.assertRangeWithError(\n          \"bitmapColors\",\n          bitmapColorPairs.length,\n          1,\n          displayManager.numberOfColors\n        );\n        const bitmapColorIndices =\n          displayManager.contextState.bitmapColorIndices.slice();\n        bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n          displayManager.assertValidColorIndex(bitmapColorIndex);\n          displayManager.assertValidColorIndex(colorIndex);\n          bitmapColorIndices[bitmapColorIndex] = colorIndex;\n        });\n\n        dataView = new DataView(\n          new ArrayBuffer(bitmapColorPairs.length * 2 + 1)\n        );\n        let offset = 0;\n        dataView.setUint8(offset++, bitmapColorPairs.length);\n        bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n          dataView!.setUint8(offset, bitmapColorIndex);\n          dataView!.setUint8(offset + 1, colorIndex);\n          offset += 2;\n        });\n      }\n      break;\n    case \"setBitmapScaleX\":\n      {\n        let { bitmapScaleX } = command;\n        bitmapScaleX = clamp(bitmapScaleX, minDisplayScale, maxDisplayScale);\n        bitmapScaleX = roundScale(bitmapScaleX);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(bitmapScaleX), true);\n      }\n      break;\n    case \"setBitmapScaleY\":\n      {\n        let { bitmapScaleY } = command;\n        bitmapScaleY = clamp(bitmapScaleY, minDisplayScale, maxDisplayScale);\n        bitmapScaleY = roundScale(bitmapScaleY);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(bitmapScaleY), true);\n      }\n      break;\n    case \"setBitmapScale\":\n      {\n        let { bitmapScale } = command;\n        bitmapScale = clamp(bitmapScale, minDisplayScale, maxDisplayScale);\n        bitmapScale = roundScale(bitmapScale);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(bitmapScale), true);\n      }\n      break;\n    case \"selectSpriteColor\":\n      {\n        const { spriteColorIndex, colorIndex } = command;\n        displayManager.assertValidColorIndex(spriteColorIndex);\n        displayManager.assertValidColorIndex(colorIndex);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint8(0, spriteColorIndex);\n        dataView.setUint8(1, colorIndex);\n      }\n      break;\n    case \"selectSpriteColors\":\n      {\n        const { spriteColorPairs } = command;\n        _console.assertRangeWithError(\n          \"spriteColors\",\n          spriteColorPairs.length,\n          1,\n          displayManager.numberOfColors\n        );\n        const spriteColorIndices =\n          displayManager.contextState.spriteColorIndices.slice();\n        spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {\n          displayManager.assertValidColorIndex(spriteColorIndex);\n          displayManager.assertValidColorIndex(colorIndex);\n          spriteColorIndices[spriteColorIndex] = colorIndex;\n        });\n\n        dataView = new DataView(\n          new ArrayBuffer(spriteColorPairs.length * 2 + 1)\n        );\n        let offset = 0;\n        dataView.setUint8(offset++, spriteColorPairs.length);\n        spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {\n          dataView!.setUint8(offset, spriteColorIndex);\n          dataView!.setUint8(offset + 1, colorIndex);\n          offset += 2;\n        });\n      }\n      break;\n    case \"setSpriteScaleX\":\n      {\n        let { spriteScaleX } = command;\n        spriteScaleX = clamp(spriteScaleX, minDisplayScale, maxDisplayScale);\n        spriteScaleX = roundScale(spriteScaleX);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(spriteScaleX), true);\n      }\n      break;\n    case \"setSpriteScaleY\":\n      {\n        let { spriteScaleY } = command;\n        spriteScaleY = clamp(spriteScaleY, minDisplayScale, maxDisplayScale);\n        spriteScaleY = roundScale(spriteScaleY);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(spriteScaleY), true);\n      }\n      break;\n    case \"setSpriteScale\":\n      {\n        let { spriteScale } = command;\n        spriteScale = clamp(spriteScale, minDisplayScale, maxDisplayScale);\n        spriteScale = roundScale(spriteScale);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(spriteScale), true);\n      }\n      break;\n    case \"clearRect\":\n      {\n        const { x, y, width, height } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4));\n        dataView.setInt16(0, x, true);\n        dataView.setInt16(2, y, true);\n        dataView.setInt16(4, width, true);\n        dataView.setInt16(6, height, true);\n      }\n      break;\n    case \"drawRect\":\n      {\n        const { offsetX, offsetY, width, height } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, width, true);\n        dataView.setUint16(6, height, true);\n      }\n      break;\n    case \"drawRoundRect\":\n      {\n        const { offsetX, offsetY, width, height, borderRadius } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4 + 1));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, width, true);\n        dataView.setUint16(6, height, true);\n        dataView.setUint8(8, borderRadius);\n      }\n      break;\n    case \"drawCircle\":\n      {\n        const { offsetX, offsetY, radius } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 3));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radius, true);\n      }\n      break;\n    case \"drawEllipse\":\n      {\n        const { offsetX, offsetY, radiusX, radiusY } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radiusX, true);\n        dataView.setUint16(6, radiusY, true);\n      }\n      break;\n    case \"drawPolygon\":\n      {\n        const { offsetX, offsetY, radius, numberOfSides } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 3 + 1));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radius, true);\n        dataView.setUint8(6, numberOfSides);\n      }\n      break;\n    case \"drawSegment\":\n      {\n        const { startX, startY, endX, endY } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4));\n        dataView.setInt16(0, startX, true);\n        dataView.setInt16(2, startY, true);\n        dataView.setInt16(4, endX, true);\n        dataView.setInt16(6, endY, true);\n      }\n      break;\n    case \"drawSegments\":\n      {\n        const { points } = command;\n        _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n        const dataViewLength = 1 + points.length * 4;\n        dataView = new DataView(new ArrayBuffer(dataViewLength));\n        let offset = 0;\n        dataView.setUint8(offset++, points.length);\n        points.forEach((segment) => {\n          dataView!.setInt16(offset, segment.x, true);\n          offset += 2;\n          dataView!.setInt16(offset, segment.y, true);\n          offset += 2;\n        });\n      }\n      break;\n    case \"drawArc\":\n      {\n        let { offsetX, offsetY, radius, isRadians, startAngle, angleOffset } =\n          command;\n\n        startAngle = isRadians ? startAngle : degToRad(startAngle);\n        startAngle = normalizeRadians(startAngle);\n\n        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n        angleOffset = clamp(angleOffset, -twoPi, twoPi);\n\n        angleOffset /= twoPi;\n        angleOffset *= (angleOffset > 0 ? Int16Max - 1 : -Int16Min) - 1;\n\n        isRadians = true;\n\n        dataView = new DataView(new ArrayBuffer(2 * 5));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radius, true);\n        dataView.setUint16(6, formatRotation(startAngle, isRadians), true);\n        dataView.setInt16(8, angleOffset, true);\n      }\n      break;\n    case \"drawArcEllipse\":\n      {\n        let {\n          offsetX,\n          offsetY,\n          radiusX,\n          radiusY,\n          isRadians,\n          startAngle,\n          angleOffset,\n        } = command;\n\n        startAngle = isRadians ? startAngle : degToRad(startAngle);\n        startAngle = normalizeRadians(startAngle);\n\n        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n        angleOffset = clamp(angleOffset, -twoPi, twoPi);\n\n        angleOffset /= twoPi;\n        angleOffset *= (angleOffset > 0 ? Int16Max : -Int16Min) - 1;\n\n        isRadians = true;\n\n        dataView = new DataView(new ArrayBuffer(2 * 6));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radiusX, true);\n        dataView.setUint16(6, radiusY, true);\n        dataView.setUint16(8, formatRotation(startAngle, isRadians), true);\n        dataView.setUint16(10, angleOffset, true);\n      }\n      break;\n    case \"drawBitmap\":\n      {\n        const { bitmap, offsetX, offsetY } = command;\n        displayManager.assertValidBitmap(bitmap, false);\n        dataView = new DataView(new ArrayBuffer(drawBitmapHeaderLength));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, bitmap.width, true);\n        dataView.setUint16(6, bitmap.pixels.length, true);\n        dataView.setUint8(8, bitmap.numberOfColors);\n\n        const bitmapData = getBitmapData(bitmap);\n        dataView.setUint16(9, bitmapData.byteLength, true);\n        const buffer = concatenateArrayBuffers(dataView, bitmapData);\n        dataView = new DataView(buffer);\n      }\n      break;\n    case \"selectSpriteSheet\":\n      {\n        const { spriteSheetIndex } = command;\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, spriteSheetIndex);\n      }\n      break;\n    case \"drawSprite\":\n      {\n        const { offsetX, offsetY, spriteIndex, use2Bytes } = command;\n        dataView = new DataView(new ArrayBuffer(1 + 2 * 2));\n        let offset = 0;\n        dataView.setInt16(offset, offsetX, true);\n        offset += 2;\n        dataView.setInt16(offset, offsetY, true);\n        offset += 2;\n        if (use2Bytes) {\n          dataView.setUint16(offset, spriteIndex, true);\n          offset += 2;\n        } else {\n          dataView.setUint8(offset++, spriteIndex!);\n        }\n      }\n      break;\n  }\n\n  return dataView;\n}\nexport function serializeContextCommands(\n  displayManager: DisplayManagerInterface,\n  commands: DisplayContextCommand[]\n) {\n  const serializedContextCommandArray = commands\n    .filter((command) => !command.hide)\n    .map((command) => {\n      const displayContextCommandEnum = DisplayContextCommandTypes.indexOf(\n        command.type\n      );\n      const serializedContextCommand = serializeContextCommand(\n        displayManager,\n        command\n      );\n      return concatenateArrayBuffers(\n        UInt8ByteBuffer(displayContextCommandEnum),\n        serializedContextCommand\n      );\n    });\n  const serializedContextCommands = concatenateArrayBuffers(\n    serializedContextCommandArray\n  );\n  _console.log(\n    \"serializedContextCommands\",\n    commands,\n    serializedContextCommandArray,\n    serializedContextCommands\n  );\n  return serializedContextCommands;\n}\n","import {\n  DisplayBitmapColorPair,\n  DisplayBrightness,\n  DisplaySpriteColorPair,\n  DisplayBitmap,\n} from \"../DisplayManager.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { DisplayContextCommand } from \"./DisplayContextCommand.ts\";\nimport {\n  DisplayContextState,\n  DisplaySegmentCap,\n} from \"./DisplayContextState.ts\";\nimport {\n  DisplaySprite,\n  DisplaySpritePaletteSwap,\n  DisplaySpriteSheet,\n  DisplaySpriteSheetPalette,\n  DisplaySpriteSheetPaletteSwap,\n} from \"./DisplaySpriteSheetUtils.ts\";\nimport {\n  DisplayScaleDirection,\n  DisplayColorRGB,\n  DisplayCropDirection,\n} from \"./DisplayUtils.ts\";\nimport { degToRad, Vector2 } from \"./MathUtils.ts\";\n\nexport type DisplayTransform = {\n  rotation: number;\n  scale: number;\n  offsetX: number;\n  offsetY: number;\n  width: number;\n  height: number;\n};\nexport const defaultDisplayTransform: DisplayTransform = {\n  rotation: 0,\n  scale: 1,\n  offsetX: 0,\n  offsetY: 0,\n  width: 0,\n  height: 0,\n};\n\nconst _console = createConsole(\"DisplayManagerInterface\", { log: true });\n\nexport interface DisplayManagerInterface {\n  get isReady(): boolean;\n\n  get contextState(): DisplayContextState;\n\n  flushContextCommands(): Promise<void>;\n\n  get brightness(): DisplayBrightness;\n  setBrightness(\n    newDisplayBrightness: DisplayBrightness,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  show(sendImmediately?: boolean): Promise<void>;\n  clear(sendImmediately?: boolean): Promise<void>;\n\n  get colors(): string[];\n  get numberOfColors(): number;\n  setColor(\n    colorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  assertValidColorIndex(colorIndex: number): void;\n  assertValidLineWidth(lineWidth: number): void;\n  assertValidNumberOfColors(numberOfColors: number): void;\n  assertValidBitmap(bitmap: DisplayBitmap, checkSize?: boolean): void;\n\n  get opacities(): number[];\n  setColorOpacity(\n    colorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setOpacity(opacity: number, sendImmediately?: boolean): Promise<void>;\n\n  saveContext(sendImmediately?: boolean): Promise<void>;\n  restoreContext(sendImmediately?: boolean): Promise<void>;\n\n  selectFillColor(\n    fillColorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  selectLineColor(\n    lineColorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setLineWidth(lineWidth: number, sendImmediately?: boolean): Promise<void>;\n\n  setRotation(\n    rotation: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  clearRotation(sendImmediately?: boolean): Promise<void>;\n\n  setSegmentStartCap(\n    segmentStartCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentEndCap(\n    segmentEndCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentCap(\n    segmentCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setSegmentStartRadius(\n    segmentStartRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentEndRadius(\n    segmentEndRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentRadius(\n    segmentRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setCropTop(cropTop: number, sendImmediately?: boolean): Promise<void>;\n  setCropRight(cropRight: number, sendImmediately?: boolean): Promise<void>;\n  setCropBottom(cropBottom: number, sendImmediately?: boolean): Promise<void>;\n  setCropLeft(cropLeft: number, sendImmediately?: boolean): Promise<void>;\n  clearCrop(sendImmediately?: boolean): Promise<void>;\n\n  setRotationCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropTop(\n    rotationCropTop: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropRight(\n    rotationCropRight: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropBottom(\n    rotationCropBottom: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropLeft(\n    rotationCropLeft: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  clearRotationCrop(sendImmediately?: boolean): Promise<void>;\n\n  selectBitmapColor(\n    bitmapColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  get bitmapColorIndices(): number[];\n  get bitmapColors(): string[];\n  selectBitmapColors(\n    bitmapColorPairs: DisplayBitmapColorPair[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setBitmapColor(\n    bitmapColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapColorOpacity(\n    bitmapColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setBitmapScaleDirection(\n    direction: DisplayScaleDirection,\n    bitmapScale: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapScaleX(\n    bitmapScaleX: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapScaleY(\n    bitmapScaleY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapScale(bitmapScale: number, sendImmediately?: boolean): Promise<void>;\n  resetBitmapScale(sendImmediately?: boolean): Promise<void>;\n\n  selectSpriteColor(\n    spriteColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  get spriteColorIndices(): number[];\n  get spriteColors(): string[];\n  selectSpriteColors(\n    spriteColorPairs: DisplaySpriteColorPair[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n  resetSpriteColors(sendImmediately?: boolean): Promise<void>;\n\n  setSpriteColor(\n    spriteColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpriteColorOpacity(\n    spriteColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setSpriteScaleX(\n    spriteScaleX: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpriteScaleY(\n    spriteScaleY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpriteScale(spriteScale: number, sendImmediately?: boolean): Promise<void>;\n  resetSpriteScale(sendImmediately?: boolean): Promise<void>;\n\n  clearRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawRoundRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawCircle(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawPolygon(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    numberOfSides: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  drawSegment(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawSegments(points: Vector2[], sendImmediately?: boolean): Promise<void>;\n\n  drawArc(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawArcEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  drawBitmap(\n    offsetX: number,\n    offsetY: number,\n    bitmap: DisplayBitmap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  runContextCommand(\n    command: DisplayContextCommand,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  runContextCommands(\n    commands: DisplayContextCommand[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  imageToBitmap(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors?: number\n  ): Promise<{\n    blob: Blob;\n    bitmap: DisplayBitmap;\n  }>;\n\n  quantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number\n  ): Promise<{\n    blob: Blob;\n    colors: string[];\n    colorIndices: number[];\n  }>;\n\n  resizeAndQuantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    colors: string[]\n  ): Promise<{\n    blob: Blob;\n    colorIndices: number[];\n  }>;\n\n  uploadSpriteSheet(spriteSheet: DisplaySpriteSheet): Promise<void>;\n  uploadSpriteSheets(spriteSheets: DisplaySpriteSheet[]): Promise<void>;\n  selectSpriteSheet(\n    spriteSheetName: string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawSprite(\n    offsetX: number,\n    offsetY: number,\n    spriteName: string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  assertLoadedSpriteSheet(spriteSheetName: string): void;\n  assertSelectedSpriteSheet(spriteSheetName: string): void;\n  assertAnySelectedSpriteSheet(): void;\n  assertSprite(spriteName: string): void;\n  getSprite(spriteName: string): DisplaySprite | undefined;\n  getSpriteSheetPalette(\n    paletteName: string\n  ): DisplaySpriteSheetPalette | undefined;\n  getSpriteSheetPaletteSwap(\n    paletteSwapName: string\n  ): DisplaySpriteSheetPaletteSwap | undefined;\n  getSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string\n  ): DisplaySpritePaletteSwap | undefined;\n\n  get selectedSpriteSheet(): DisplaySpriteSheet | undefined;\n  get selectedSpriteSheetName(): string | undefined;\n\n  spriteSheets: Record<string, DisplaySpriteSheet>;\n  spriteSheetIndices: Record<string, number>;\n\n  assertSpriteSheetPalette(paletteName: string): void;\n  assertSpriteSheetPaletteSwap(paletteSwapName: string): void;\n  assertSpritePaletteSwap(spriteName: string, paletteSwapName: string): void;\n  selectSpriteSheetPalette(\n    paletteName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  selectSpriteSheetPaletteSwap(\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  selectSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  serializeSpriteSheet(spriteSheet: DisplaySpriteSheet): ArrayBuffer;\n\n  fontToSpriteSheet(\n    arrayBuffer: ArrayBuffer,\n    fontSize: number,\n    spriteSheetName?: string\n  ): Promise<DisplaySpriteSheet>;\n}\n\nexport async function runDisplayContextCommand(\n  displayManager: DisplayManagerInterface,\n  command: DisplayContextCommand,\n  sendImmediately?: boolean\n) {\n  if (command.hide) {\n    return;\n  }\n  switch (command.type) {\n    case \"show\":\n      await displayManager.show(sendImmediately);\n      break;\n    case \"clear\":\n      await displayManager.clear(sendImmediately);\n      break;\n    case \"saveContext\":\n      await displayManager.saveContext(sendImmediately);\n      break;\n    case \"restoreContext\":\n      await displayManager.restoreContext(sendImmediately);\n      break;\n    case \"clearRotation\":\n      await displayManager.clearRotation(sendImmediately);\n      break;\n    case \"clearCrop\":\n      await displayManager.clearCrop(sendImmediately);\n      break;\n    case \"clearRotationCrop\":\n      await displayManager.clearRotationCrop(sendImmediately);\n      break;\n    case \"resetBitmapScale\":\n      await displayManager.resetBitmapScale(sendImmediately);\n      break;\n    case \"resetSpriteScale\":\n      await displayManager.resetSpriteScale(sendImmediately);\n      break;\n    case \"setColor\":\n      {\n        const { colorIndex, color } = command;\n        await displayManager.setColor(colorIndex, color, sendImmediately);\n      }\n      break;\n    case \"setColorOpacity\":\n      {\n        const { colorIndex, opacity } = command;\n        await displayManager.setColorOpacity(\n          colorIndex,\n          opacity,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setOpacity\":\n      {\n        const { opacity } = command;\n        await displayManager.setOpacity(opacity, sendImmediately);\n      }\n      break;\n    case \"selectFillColor\":\n      {\n        const { fillColorIndex } = command;\n        await displayManager.selectFillColor(fillColorIndex, sendImmediately);\n      }\n      break;\n    case \"selectLineColor\":\n      {\n        const { lineColorIndex } = command;\n        await displayManager.selectLineColor(lineColorIndex, sendImmediately);\n      }\n      break;\n    case \"setLineWidth\":\n      {\n        const { lineWidth } = command;\n        await displayManager.setLineWidth(lineWidth, sendImmediately);\n      }\n      break;\n    case \"setRotation\":\n      {\n        let { rotation, isRadians } = command;\n        rotation = isRadians ? rotation : degToRad(rotation);\n        rotation;\n        await displayManager.setRotation(rotation, true, sendImmediately);\n      }\n      break;\n    case \"setSegmentStartCap\":\n      {\n        const { segmentStartCap } = command;\n        await displayManager.setSegmentStartCap(\n          segmentStartCap,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSegmentEndCap\":\n      {\n        const { segmentEndCap } = command;\n        await displayManager.setSegmentEndCap(segmentEndCap, sendImmediately);\n      }\n      break;\n    case \"setSegmentCap\":\n      {\n        const { segmentCap } = command;\n        await displayManager.setSegmentCap(segmentCap, sendImmediately);\n      }\n      break;\n    case \"setSegmentStartRadius\":\n      {\n        const { segmentStartRadius } = command;\n        await displayManager.setSegmentStartRadius(\n          segmentStartRadius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSegmentEndRadius\":\n      {\n        const { segmentEndRadius } = command;\n        await displayManager.setSegmentEndRadius(\n          segmentEndRadius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSegmentRadius\":\n      {\n        const { segmentRadius } = command;\n        await displayManager.setSegmentRadius(segmentRadius, sendImmediately);\n      }\n      break;\n    case \"setCropTop\":\n      {\n        const { cropTop } = command;\n        await displayManager.setCropTop(cropTop, sendImmediately);\n      }\n      break;\n    case \"setCropRight\":\n      {\n        const { cropRight } = command;\n        await displayManager.setCropRight(cropRight, sendImmediately);\n      }\n      break;\n    case \"setCropBottom\":\n      {\n        const { cropBottom } = command;\n        await displayManager.setCropBottom(cropBottom, sendImmediately);\n      }\n      break;\n    case \"setCropLeft\":\n      {\n        const { cropLeft } = command;\n        await displayManager.setCropLeft(cropLeft, sendImmediately);\n      }\n      break;\n    case \"setRotationCropTop\":\n      {\n        const { rotationCropTop } = command;\n        await displayManager.setRotationCropTop(\n          rotationCropTop,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setRotationCropRight\":\n      {\n        const { rotationCropRight } = command;\n        await displayManager.setRotationCropRight(\n          rotationCropRight,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setRotationCropBottom\":\n      {\n        const { rotationCropBottom } = command;\n        await displayManager.setRotationCropBottom(\n          rotationCropBottom,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setRotationCropLeft\":\n      {\n        const { rotationCropLeft } = command;\n        await displayManager.setRotationCropLeft(\n          rotationCropLeft,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectBitmapColor\":\n      {\n        const { bitmapColorIndex, colorIndex } = command;\n        await displayManager.selectBitmapColor(\n          bitmapColorIndex,\n          colorIndex,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectBitmapColors\":\n      {\n        const { bitmapColorPairs } = command;\n        await displayManager.selectBitmapColors(\n          bitmapColorPairs,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setBitmapScaleX\":\n      {\n        const { bitmapScaleX } = command;\n        await displayManager.setBitmapScaleX(bitmapScaleX, sendImmediately);\n      }\n      break;\n    case \"setBitmapScaleY\":\n      {\n        const { bitmapScaleY } = command;\n        await displayManager.setBitmapScaleY(bitmapScaleY, sendImmediately);\n      }\n      break;\n    case \"setBitmapScale\":\n      {\n        const { bitmapScale } = command;\n        await displayManager.setBitmapScale(bitmapScale, sendImmediately);\n      }\n      break;\n    case \"selectSpriteColor\":\n      {\n        const { spriteColorIndex, colorIndex } = command;\n        await displayManager.selectSpriteColor(\n          spriteColorIndex,\n          colorIndex,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectSpriteColors\":\n      {\n        const { spriteColorPairs } = command;\n        await displayManager.selectSpriteColors(\n          spriteColorPairs,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSpriteScaleX\":\n      {\n        const { spriteScaleX } = command;\n        await displayManager.setSpriteScaleX(spriteScaleX, sendImmediately);\n      }\n      break;\n    case \"setSpriteScaleY\":\n      {\n        const { spriteScaleY } = command;\n        await displayManager.setSpriteScaleY(spriteScaleY, sendImmediately);\n      }\n      break;\n    case \"setSpriteScale\":\n      {\n        const { spriteScale } = command;\n        await displayManager.setSpriteScale(spriteScale, sendImmediately);\n      }\n      break;\n    case \"clearRect\":\n      {\n        const { x, y, width, height } = command;\n        await displayManager.clearRect(x, y, width, height, sendImmediately);\n      }\n      break;\n    case \"drawRect\":\n      {\n        const { offsetX, offsetY, width, height } = command;\n        await displayManager.drawRect(\n          offsetX,\n          offsetY,\n          width,\n          height,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawRoundRect\":\n      {\n        const { offsetX, offsetY, width, height, borderRadius } = command;\n        await displayManager.drawRoundRect(\n          offsetX,\n          offsetY,\n          width,\n          height,\n          borderRadius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawCircle\":\n      {\n        const { offsetX, offsetY, radius } = command;\n        await displayManager.drawCircle(\n          offsetX,\n          offsetY,\n          radius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawEllipse\":\n      {\n        const { offsetX, offsetY, radiusX, radiusY } = command;\n        await displayManager.drawEllipse(\n          offsetX,\n          offsetY,\n          radiusX,\n          radiusY,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawPolygon\":\n      {\n        const { offsetX, offsetY, radius, numberOfSides } = command;\n        await displayManager.drawPolygon(\n          offsetX,\n          offsetY,\n          radius,\n          numberOfSides,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawSegment\":\n      {\n        const { startX, startY, endX, endY } = command;\n        await displayManager.drawSegment(\n          startX,\n          startY,\n          endX,\n          endY,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawSegments\":\n      {\n        const { points } = command;\n        await displayManager.drawSegments(\n          points.map(({ x, y }) => ({ x: x, y: y })),\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawArc\":\n      {\n        let { offsetX, offsetY, radius, startAngle, angleOffset, isRadians } =\n          command;\n        startAngle = isRadians ? startAngle : degToRad(startAngle);\n        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n\n        await displayManager.drawArc(\n          offsetX,\n          offsetY,\n          radius,\n          startAngle,\n          angleOffset,\n          true,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawArcEllipse\":\n      {\n        let {\n          offsetX,\n          offsetY,\n          radiusX,\n          radiusY,\n          startAngle,\n          angleOffset,\n          isRadians,\n        } = command;\n        startAngle = isRadians ? startAngle : degToRad(startAngle);\n        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n\n        await displayManager.drawArcEllipse(\n          offsetX,\n          offsetY,\n          radiusX,\n          radiusY,\n          startAngle,\n          angleOffset,\n          true,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawBitmap\":\n      {\n        const { offsetX, offsetY, bitmap } = command;\n        await displayManager.drawBitmap(\n          offsetX,\n          offsetY,\n          bitmap,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawSprite\":\n      {\n        const { offsetX, offsetY, spriteIndex } = command;\n        const spriteName =\n          displayManager.selectedSpriteSheet?.sprites[spriteIndex].name!;\n        await displayManager.drawSprite(\n          offsetX,\n          offsetY,\n          spriteName,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectSpriteSheet\":\n      {\n        const { spriteSheetIndex } = command;\n        const spriteSheetName = Object.entries(\n          displayManager.spriteSheetIndices\n        ).find((entry) => entry[1] == spriteSheetIndex)?.[0];\n        await displayManager.selectSpriteSheet(\n          spriteSheetName!,\n          sendImmediately\n        );\n      }\n      break;\n    case \"resetSpriteColors\":\n      await displayManager.resetSpriteColors(sendImmediately);\n      break;\n  }\n}\n\nexport async function runDisplayContextCommands(\n  displayManager: DisplayManagerInterface,\n  commands: DisplayContextCommand[],\n  sendImmediately?: boolean\n) {\n  _console.log(\"runDisplayContextCommands\", commands);\n  commands\n    .filter((command) => !command.hide)\n    .forEach((command) => {\n      runDisplayContextCommand(displayManager, command, false);\n    });\n  if (sendImmediately) {\n    displayManager.flushContextCommands();\n  }\n}\n\nexport function assertLoadedSpriteSheet(\n  displayManager: DisplayManagerInterface,\n  spriteSheetName: string\n) {\n  _console.assertWithError(\n    displayManager.spriteSheets[spriteSheetName],\n    `spriteSheet \"${spriteSheetName}\" not loaded`\n  );\n}\nexport function assertSelectedSpriteSheet(\n  displayManager: DisplayManagerInterface,\n  spriteSheetName: string\n) {\n  displayManager.assertLoadedSpriteSheet(spriteSheetName);\n  _console.assertWithError(\n    displayManager.selectedSpriteSheetName == spriteSheetName,\n    `spriteSheet \"${spriteSheetName}\" not selected`\n  );\n}\nexport function assertAnySelectedSpriteSheet(\n  displayManager: DisplayManagerInterface\n) {\n  _console.assertWithError(\n    displayManager.selectedSpriteSheet,\n    \"no spriteSheet selected\"\n  );\n}\nexport function getSprite(\n  displayManager: DisplayManagerInterface,\n  spriteName: string\n): DisplaySprite | undefined {\n  displayManager.assertAnySelectedSpriteSheet();\n  return displayManager.selectedSpriteSheet!.sprites.find(\n    (sprite) => sprite.name == spriteName\n  );\n}\nexport function assertSprite(\n  displayManager: DisplayManagerInterface,\n  spriteName: string\n) {\n  displayManager.assertAnySelectedSpriteSheet();\n  const sprite = displayManager.getSprite(spriteName);\n  _console.assertWithError(sprite, `no sprite found with name \"${spriteName}\"`);\n}\nexport function getSpriteSheetPalette(\n  displayManager: DisplayManagerInterface,\n  paletteName: string\n): DisplaySpriteSheetPalette | undefined {\n  return displayManager.selectedSpriteSheet?.palettes?.find(\n    (palette) => palette.name == paletteName\n  );\n}\nexport function getSpriteSheetPaletteSwap(\n  displayManager: DisplayManagerInterface,\n  paletteSwapName: string\n): DisplaySpriteSheetPaletteSwap | undefined {\n  return displayManager.selectedSpriteSheet?.paletteSwaps?.find(\n    (paletteSwap) => paletteSwap.name == paletteSwapName\n  );\n}\nexport function getSpritePaletteSwap(\n  displayManager: DisplayManagerInterface,\n  spriteName: string,\n  paletteSwapName: string\n): DisplaySpritePaletteSwap | undefined {\n  return displayManager\n    .getSprite(spriteName)\n    ?.paletteSwaps?.find((paletteSwap) => paletteSwap.name == paletteSwapName);\n}\n\nexport function assertSpriteSheetPalette(\n  displayManagerInterface: DisplayManagerInterface,\n  paletteName: string\n) {\n  const spriteSheetPalette =\n    displayManagerInterface.getSpriteSheetPalette(paletteName);\n  _console.assertWithError(\n    spriteSheetPalette,\n    `no spriteSheetPalette found with name \"${paletteName}\"`\n  );\n}\nexport function assertSpriteSheetPaletteSwap(\n  displayManagerInterface: DisplayManagerInterface,\n  paletteSwapName: string\n) {\n  const spriteSheetPaletteSwap =\n    displayManagerInterface.getSpriteSheetPaletteSwap(paletteSwapName);\n  _console.assertWithError(\n    spriteSheetPaletteSwap,\n    `no paletteSwapName found with name \"${paletteSwapName}\"`\n  );\n}\nexport function assertSpritePaletteSwap(\n  displayManagerInterface: DisplayManagerInterface,\n  spriteName: string,\n  paletteSwapName: string\n) {\n  const spritePaletteSwap = displayManagerInterface.getSpritePaletteSwap(\n    spriteName,\n    paletteSwapName\n  );\n  _console.assertWithError(\n    spritePaletteSwap,\n    `no spritePaletteSwap found for sprite \"${spriteName}\" name \"${paletteSwapName}\"`\n  );\n}\nexport async function selectSpriteSheetPalette(\n  displayManagerInterface: DisplayManagerInterface,\n  paletteName: string,\n  offset?: number,\n  sendImmediately?: boolean\n) {\n  offset = offset || 0;\n\n  displayManagerInterface.assertAnySelectedSpriteSheet();\n  displayManagerInterface.assertSpriteSheetPalette(paletteName);\n  const palette = displayManagerInterface.getSpriteSheetPalette(paletteName)!;\n\n  _console.assertWithError(\n    palette.numberOfColors + offset <= displayManagerInterface.numberOfColors,\n    `invalid offset ${offset} and palette.numberOfColors ${palette.numberOfColors} (max ${displayManagerInterface.numberOfColors})`\n  );\n\n  for (let index = 0; index < palette.numberOfColors; index++) {\n    const color = palette.colors[index];\n    let opacity = palette.opacities?.[index];\n    if (opacity == undefined) {\n      opacity = 1;\n    }\n    displayManagerInterface.setColor(index + offset, color, false);\n    displayManagerInterface.setColorOpacity(index + offset, opacity, false);\n  }\n\n  if (sendImmediately) {\n    displayManagerInterface.flushContextCommands();\n  }\n}\nexport async function selectSpriteSheetPaletteSwap(\n  displayManagerInterface: DisplayManagerInterface,\n  paletteSwapName: string,\n  offset?: number,\n  sendImmediately?: boolean\n) {\n  offset = offset || 0;\n  displayManagerInterface.assertAnySelectedSpriteSheet();\n  displayManagerInterface.assertSpriteSheetPaletteSwap(paletteSwapName);\n\n  const paletteSwap =\n    displayManagerInterface.getSpriteSheetPaletteSwap(paletteSwapName)!;\n\n  const spriteColorPairs: DisplaySpriteColorPair[] = [];\n  for (\n    let spriteColorIndex = 0;\n    spriteColorIndex < paletteSwap.numberOfColors;\n    spriteColorIndex++\n  ) {\n    const colorIndex = paletteSwap.spriteColorIndices[spriteColorIndex];\n    spriteColorPairs.push({\n      spriteColorIndex: spriteColorIndex + offset,\n      colorIndex,\n    });\n  }\n  displayManagerInterface.selectSpriteColors(spriteColorPairs, false);\n\n  if (sendImmediately) {\n    displayManagerInterface.flushContextCommands();\n  }\n}\nexport async function selectSpritePaletteSwap(\n  displayManagerInterface: DisplayManagerInterface,\n  spriteName: string,\n  paletteSwapName: string,\n  offset?: number,\n  sendImmediately?: boolean\n) {\n  offset = offset || 0;\n  displayManagerInterface.assertAnySelectedSpriteSheet();\n\n  const paletteSwap = displayManagerInterface.getSpritePaletteSwap(\n    spriteName,\n    paletteSwapName\n  )!;\n\n  const spriteColorPairs: DisplaySpriteColorPair[] = [];\n  for (\n    let spriteColorIndex = 0;\n    spriteColorIndex < paletteSwap.numberOfColors;\n    spriteColorIndex++\n  ) {\n    const colorIndex = paletteSwap.spriteColorIndices[spriteColorIndex];\n    spriteColorPairs.push({\n      spriteColorIndex: spriteColorIndex + offset,\n      colorIndex,\n    });\n  }\n  displayManagerInterface.selectSpriteColors(spriteColorPairs, false);\n\n  if (sendImmediately) {\n    displayManagerInterface.flushContextCommands();\n  }\n}\n","/**\n * https://opentype.js.org v1.3.4 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens\n */\n\n/*! https://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tvar string = String(this);\n\t\t\tvar size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tvar index = position ? Number(position) : 0;\n\t\t\tif (index != index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tvar first = string.charCodeAt(index);\n\t\t\tvar second;\n\t\t\tif ( // check if it’s the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n\nvar TINF_OK = 0;\nvar TINF_DATA_ERROR = -3;\n\nfunction Tree() {\n  this.table = new Uint16Array(16);   /* table of code length counts */\n  this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n}\n\nfunction Data(source, dest) {\n  this.source = source;\n  this.sourceIndex = 0;\n  this.tag = 0;\n  this.bitcount = 0;\n  \n  this.dest = dest;\n  this.destLen = 0;\n  \n  this.ltree = new Tree();  /* dynamic length/symbol tree */\n  this.dtree = new Tree();  /* dynamic distance tree */\n}\n\n/* --------------------------------------------------- *\n * -- uninitialized global data (static structures) -- *\n * --------------------------------------------------- */\n\nvar sltree = new Tree();\nvar sdtree = new Tree();\n\n/* extra bits and base tables for length codes */\nvar length_bits = new Uint8Array(30);\nvar length_base = new Uint16Array(30);\n\n/* extra bits and base tables for distance codes */\nvar dist_bits = new Uint8Array(30);\nvar dist_base = new Uint16Array(30);\n\n/* special ordering of code length codes */\nvar clcidx = new Uint8Array([\n  16, 17, 18, 0, 8, 7, 9, 6,\n  10, 5, 11, 4, 12, 3, 13, 2,\n  14, 1, 15\n]);\n\n/* used by tinf_decode_trees, avoids allocations every call */\nvar code_tree = new Tree();\nvar lengths = new Uint8Array(288 + 32);\n\n/* ----------------------- *\n * -- utility functions -- *\n * ----------------------- */\n\n/* build extra bits and base tables */\nfunction tinf_build_bits_base(bits, base, delta, first) {\n  var i, sum;\n\n  /* build bits table */\n  for (i = 0; i < delta; ++i) { bits[i] = 0; }\n  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }\n\n  /* build base table */\n  for (sum = first, i = 0; i < 30; ++i) {\n    base[i] = sum;\n    sum += 1 << bits[i];\n  }\n}\n\n/* build the fixed huffman trees */\nfunction tinf_build_fixed_trees(lt, dt) {\n  var i;\n\n  /* build fixed length tree */\n  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }\n\n  lt.table[7] = 24;\n  lt.table[8] = 152;\n  lt.table[9] = 112;\n\n  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }\n  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }\n  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }\n  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }\n\n  /* build fixed distance tree */\n  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }\n\n  dt.table[5] = 32;\n\n  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }\n}\n\n/* given an array of code lengths, build a tree */\nvar offs = new Uint16Array(16);\n\nfunction tinf_build_tree(t, lengths, off, num) {\n  var i, sum;\n\n  /* clear code length count table */\n  for (i = 0; i < 16; ++i) { t.table[i] = 0; }\n\n  /* scan symbol lengths, and sum code length counts */\n  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }\n\n  t.table[0] = 0;\n\n  /* compute offset table for distribution sort */\n  for (sum = 0, i = 0; i < 16; ++i) {\n    offs[i] = sum;\n    sum += t.table[i];\n  }\n\n  /* create code->symbol translation table (symbols sorted by code) */\n  for (i = 0; i < num; ++i) {\n    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }\n  }\n}\n\n/* ---------------------- *\n * -- decode functions -- *\n * ---------------------- */\n\n/* get one bit from source stream */\nfunction tinf_getbit(d) {\n  /* check if tag is empty */\n  if (!d.bitcount--) {\n    /* load next tag */\n    d.tag = d.source[d.sourceIndex++];\n    d.bitcount = 7;\n  }\n\n  /* shift bit out of tag */\n  var bit = d.tag & 1;\n  d.tag >>>= 1;\n\n  return bit;\n}\n\n/* read a num bit value from a stream and add base */\nfunction tinf_read_bits(d, num, base) {\n  if (!num)\n    { return base; }\n\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n\n  var val = d.tag & (0xffff >>> (16 - num));\n  d.tag >>>= num;\n  d.bitcount -= num;\n  return val + base;\n}\n\n/* given a data stream and a tree, decode a symbol */\nfunction tinf_decode_symbol(d, t) {\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n  \n  var sum = 0, cur = 0, len = 0;\n  var tag = d.tag;\n\n  /* get more bits while code value is above sum */\n  do {\n    cur = 2 * cur + (tag & 1);\n    tag >>>= 1;\n    ++len;\n\n    sum += t.table[len];\n    cur -= t.table[len];\n  } while (cur >= 0);\n  \n  d.tag = tag;\n  d.bitcount -= len;\n\n  return t.trans[sum + cur];\n}\n\n/* given a data stream, decode dynamic trees from it */\nfunction tinf_decode_trees(d, lt, dt) {\n  var hlit, hdist, hclen;\n  var i, num, length;\n\n  /* get 5 bits HLIT (257-286) */\n  hlit = tinf_read_bits(d, 5, 257);\n\n  /* get 5 bits HDIST (1-32) */\n  hdist = tinf_read_bits(d, 5, 1);\n\n  /* get 4 bits HCLEN (4-19) */\n  hclen = tinf_read_bits(d, 4, 4);\n\n  for (i = 0; i < 19; ++i) { lengths[i] = 0; }\n\n  /* read code lengths for code length alphabet */\n  for (i = 0; i < hclen; ++i) {\n    /* get 3 bits code length (0-7) */\n    var clen = tinf_read_bits(d, 3, 0);\n    lengths[clcidx[i]] = clen;\n  }\n\n  /* build code length tree */\n  tinf_build_tree(code_tree, lengths, 0, 19);\n\n  /* decode code lengths for the dynamic trees */\n  for (num = 0; num < hlit + hdist;) {\n    var sym = tinf_decode_symbol(d, code_tree);\n\n    switch (sym) {\n      case 16:\n        /* copy previous code length 3-6 times (read 2 bits) */\n        var prev = lengths[num - 1];\n        for (length = tinf_read_bits(d, 2, 3); length; --length) {\n          lengths[num++] = prev;\n        }\n        break;\n      case 17:\n        /* repeat code length 0 for 3-10 times (read 3 bits) */\n        for (length = tinf_read_bits(d, 3, 3); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      case 18:\n        /* repeat code length 0 for 11-138 times (read 7 bits) */\n        for (length = tinf_read_bits(d, 7, 11); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      default:\n        /* values 0-15 represent the actual code lengths */\n        lengths[num++] = sym;\n        break;\n    }\n  }\n\n  /* build dynamic trees */\n  tinf_build_tree(lt, lengths, 0, hlit);\n  tinf_build_tree(dt, lengths, hlit, hdist);\n}\n\n/* ----------------------------- *\n * -- block inflate functions -- *\n * ----------------------------- */\n\n/* given a stream and two trees, inflate a block of data */\nfunction tinf_inflate_block_data(d, lt, dt) {\n  while (1) {\n    var sym = tinf_decode_symbol(d, lt);\n\n    /* check for end of block */\n    if (sym === 256) {\n      return TINF_OK;\n    }\n\n    if (sym < 256) {\n      d.dest[d.destLen++] = sym;\n    } else {\n      var length, dist, offs;\n      var i;\n\n      sym -= 257;\n\n      /* possibly get more bits from length code */\n      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n      dist = tinf_decode_symbol(d, dt);\n\n      /* possibly get more bits from distance code */\n      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n      /* copy match */\n      for (i = offs; i < offs + length; ++i) {\n        d.dest[d.destLen++] = d.dest[i];\n      }\n    }\n  }\n}\n\n/* inflate an uncompressed block of data */\nfunction tinf_inflate_uncompressed_block(d) {\n  var length, invlength;\n  var i;\n  \n  /* unread from bitbuffer */\n  while (d.bitcount > 8) {\n    d.sourceIndex--;\n    d.bitcount -= 8;\n  }\n\n  /* get length */\n  length = d.source[d.sourceIndex + 1];\n  length = 256 * length + d.source[d.sourceIndex];\n\n  /* get one's complement of length */\n  invlength = d.source[d.sourceIndex + 3];\n  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n  /* check length */\n  if (length !== (~invlength & 0x0000ffff))\n    { return TINF_DATA_ERROR; }\n\n  d.sourceIndex += 4;\n\n  /* copy block */\n  for (i = length; i; --i)\n    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }\n\n  /* make sure we start next block on a byte boundary */\n  d.bitcount = 0;\n\n  return TINF_OK;\n}\n\n/* inflate stream from source to dest */\nfunction tinf_uncompress(source, dest) {\n  var d = new Data(source, dest);\n  var bfinal, btype, res;\n\n  do {\n    /* read final block flag */\n    bfinal = tinf_getbit(d);\n\n    /* read block type (2 bits) */\n    btype = tinf_read_bits(d, 2, 0);\n\n    /* decompress block */\n    switch (btype) {\n      case 0:\n        /* decompress uncompressed block */\n        res = tinf_inflate_uncompressed_block(d);\n        break;\n      case 1:\n        /* decompress block with fixed huffman trees */\n        res = tinf_inflate_block_data(d, sltree, sdtree);\n        break;\n      case 2:\n        /* decompress block with dynamic huffman trees */\n        tinf_decode_trees(d, d.ltree, d.dtree);\n        res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n        break;\n      default:\n        res = TINF_DATA_ERROR;\n    }\n\n    if (res !== TINF_OK)\n      { throw new Error('Data error'); }\n\n  } while (!bfinal);\n\n  if (d.destLen < d.dest.length) {\n    if (typeof d.dest.slice === 'function')\n      { return d.dest.slice(0, d.destLen); }\n    else\n      { return d.dest.subarray(0, d.destLen); }\n  }\n  \n  return d.dest;\n}\n\n/* -------------------- *\n * -- initialization -- *\n * -------------------- */\n\n/* build fixed huffman trees */\ntinf_build_fixed_trees(sltree, sdtree);\n\n/* build extra bits and base tables */\ntinf_build_bits_base(length_bits, length_base, 4, 3);\ntinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n/* fix a special case */\nlength_bits[28] = 0;\nlength_base[28] = 258;\n\nvar tinyInflate = tinf_uncompress;\n\n// The Bounding Box object\n\nfunction derive(v0, v1, v2, v3, t) {\n    return Math.pow(1 - t, 3) * v0 +\n        3 * Math.pow(1 - t, 2) * t * v1 +\n        3 * (1 - t) * Math.pow(t, 2) * v2 +\n        Math.pow(t, 3) * v3;\n}\n/**\n * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.\n * It is used to calculate the bounding box of a glyph or text path.\n *\n * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.\n *\n * @exports opentype.BoundingBox\n * @class\n * @constructor\n */\nfunction BoundingBox() {\n    this.x1 = Number.NaN;\n    this.y1 = Number.NaN;\n    this.x2 = Number.NaN;\n    this.y2 = Number.NaN;\n}\n\n/**\n * Returns true if the bounding box is empty, that is, no points have been added to the box yet.\n */\nBoundingBox.prototype.isEmpty = function() {\n    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);\n};\n\n/**\n * Add the point to the bounding box.\n * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.\n * @param {number} x - The X coordinate of the point.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addPoint = function(x, y) {\n    if (typeof x === 'number') {\n        if (isNaN(this.x1) || isNaN(this.x2)) {\n            this.x1 = x;\n            this.x2 = x;\n        }\n        if (x < this.x1) {\n            this.x1 = x;\n        }\n        if (x > this.x2) {\n            this.x2 = x;\n        }\n    }\n    if (typeof y === 'number') {\n        if (isNaN(this.y1) || isNaN(this.y2)) {\n            this.y1 = y;\n            this.y2 = y;\n        }\n        if (y < this.y1) {\n            this.y1 = y;\n        }\n        if (y > this.y2) {\n            this.y2 = y;\n        }\n    }\n};\n\n/**\n * Add a X coordinate to the bounding box.\n * This extends the bounding box to include the X coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} x - The X coordinate of the point.\n */\nBoundingBox.prototype.addX = function(x) {\n    this.addPoint(x, null);\n};\n\n/**\n * Add a Y coordinate to the bounding box.\n * This extends the bounding box to include the Y coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addY = function(y) {\n    this.addPoint(null, y);\n};\n\n/**\n * Add a Bézier curve to the bounding box.\n * This extends the bounding box to include the entire Bézier.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the first control point.\n * @param {number} y1 - The Y coordinate of the first control point.\n * @param {number} x2 - The X coordinate of the second control point.\n * @param {number} y2 - The Y coordinate of the second control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {\n    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // and https://github.com/icons8/svg-path-bounding-box\n\n    var p0 = [x0, y0];\n    var p1 = [x1, y1];\n    var p2 = [x2, y2];\n    var p3 = [x, y];\n\n    this.addPoint(x0, y0);\n    this.addPoint(x, y);\n\n    for (var i = 0; i <= 1; i++) {\n        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n        var c = 3 * p1[i] - 3 * p0[i];\n\n        if (a === 0) {\n            if (b === 0) { continue; }\n            var t = -c / b;\n            if (0 < t && t < 1) {\n                if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n                if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n            }\n            continue;\n        }\n\n        var b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) { continue; }\n        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n        }\n        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n        }\n    }\n};\n\n/**\n * Add a quadratic curve to the bounding box.\n * This extends the bounding box to include the entire quadratic curve.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the control point.\n * @param {number} y1 - The Y coordinate of the control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {\n    var cp1x = x0 + 2 / 3 * (x1 - x0);\n    var cp1y = y0 + 2 / 3 * (y1 - y0);\n    var cp2x = cp1x + 1 / 3 * (x - x0);\n    var cp2y = cp1y + 1 / 3 * (y - y0);\n    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);\n};\n\n// Geometric objects\n\n/**\n * A bézier path containing a set of path commands similar to a SVG path.\n * Paths can be drawn on a context using `draw`.\n * @exports opentype.Path\n * @class\n * @constructor\n */\nfunction Path() {\n    this.commands = [];\n    this.fill = 'black';\n    this.stroke = null;\n    this.strokeWidth = 1;\n}\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.moveTo = function(x, y) {\n    this.commands.push({\n        type: 'M',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.lineTo = function(x, y) {\n    this.commands.push({\n        type: 'L',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws cubic curve\n * @function\n * curveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws cubic curve\n * @function\n * bezierCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n * @see curveTo\n */\nPath.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {\n    this.commands.push({\n        type: 'C',\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws quadratic curve\n * @function\n * quadraticCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws quadratic curve\n * @function\n * quadTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\nPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {\n    this.commands.push({\n        type: 'Q',\n        x1: x1,\n        y1: y1,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Closes the path\n * @function closePath\n * @memberof opentype.Path.prototype\n */\n\n/**\n * Close the path\n * @function close\n * @memberof opentype.Path.prototype\n */\nPath.prototype.close = Path.prototype.closePath = function() {\n    this.commands.push({\n        type: 'Z'\n    });\n};\n\n/**\n * Add the given path or list of commands to the commands of this path.\n * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n */\nPath.prototype.extend = function(pathOrCommands) {\n    if (pathOrCommands.commands) {\n        pathOrCommands = pathOrCommands.commands;\n    } else if (pathOrCommands instanceof BoundingBox) {\n        var box = pathOrCommands;\n        this.moveTo(box.x1, box.y1);\n        this.lineTo(box.x2, box.y1);\n        this.lineTo(box.x2, box.y2);\n        this.lineTo(box.x1, box.y2);\n        this.close();\n        return;\n    }\n\n    Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n\n/**\n * Calculate the bounding box of the path.\n * @returns {opentype.BoundingBox}\n */\nPath.prototype.getBoundingBox = function() {\n    var box = new BoundingBox();\n\n    var startX = 0;\n    var startY = 0;\n    var prevX = 0;\n    var prevY = 0;\n    for (var i = 0; i < this.commands.length; i++) {\n        var cmd = this.commands[i];\n        switch (cmd.type) {\n            case 'M':\n                box.addPoint(cmd.x, cmd.y);\n                startX = prevX = cmd.x;\n                startY = prevY = cmd.y;\n                break;\n            case 'L':\n                box.addPoint(cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Q':\n                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'C':\n                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Z':\n                prevX = startX;\n                prevY = startY;\n                break;\n            default:\n                throw new Error('Unexpected path command ' + cmd.type);\n        }\n    }\n    if (box.isEmpty()) {\n        box.addPoint(0, 0);\n    }\n    return box;\n};\n\n/**\n * Draw the path to a 2D context.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.\n */\nPath.prototype.draw = function(ctx) {\n    ctx.beginPath();\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            ctx.moveTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            ctx.lineTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            ctx.closePath();\n        }\n    }\n\n    if (this.fill) {\n        ctx.fillStyle = this.fill;\n        ctx.fill();\n    }\n\n    if (this.stroke) {\n        ctx.strokeStyle = this.stroke;\n        ctx.lineWidth = this.strokeWidth;\n        ctx.stroke();\n    }\n};\n\n/**\n * Convert the Path to a string of path data instructions\n * See http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toPathData = function(decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n    function floatToString(v) {\n        if (Math.round(v) === v) {\n            return '' + Math.round(v);\n        } else {\n            return v.toFixed(decimalPlaces);\n        }\n    }\n\n    function packValues() {\n        var arguments$1 = arguments;\n\n        var s = '';\n        for (var i = 0; i < arguments.length; i += 1) {\n            var v = arguments$1[i];\n            if (v >= 0 && i > 0) {\n                s += ' ';\n            }\n\n            s += floatToString(v);\n        }\n\n        return s;\n    }\n\n    var d = '';\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            d += 'M' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            d += 'L' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            d += 'Z';\n        }\n    }\n\n    return d;\n};\n\n/**\n * Convert the path to an SVG <path> element, as a string.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toSVG = function(decimalPlaces) {\n    var svg = '<path d=\"';\n    svg += this.toPathData(decimalPlaces);\n    svg += '\"';\n    if (this.fill && this.fill !== 'black') {\n        if (this.fill === null) {\n            svg += ' fill=\"none\"';\n        } else {\n            svg += ' fill=\"' + this.fill + '\"';\n        }\n    }\n\n    if (this.stroke) {\n        svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n    }\n\n    svg += '/>';\n    return svg;\n};\n\n/**\n * Convert the path to a DOM element.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {SVGPathElement}\n */\nPath.prototype.toDOMElement = function(decimalPlaces) {\n    var temporaryPath = this.toPathData(decimalPlaces);\n    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n    newPath.setAttribute('d', temporaryPath);\n\n    return newPath;\n};\n\n// Run-time checking of preconditions.\n\nfunction fail(message) {\n    throw new Error(message);\n}\n\n// Precondition function that checks if the given predicate is true.\n// If not, it will throw an error.\nfunction argument(predicate, message) {\n    if (!predicate) {\n        fail(message);\n    }\n}\nvar check = { fail: fail, argument: argument, assert: argument };\n\n// Data types used in the OpenType font file.\n\nvar LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\nvar LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n/**\n * @exports opentype.decode\n * @class\n */\nvar decode = {};\n/**\n * @exports opentype.encode\n * @class\n */\nvar encode = {};\n/**\n * @exports opentype.sizeOf\n * @class\n */\nvar sizeOf = {};\n\n// Return a function that always returns the same value.\nfunction constant(v) {\n    return function() {\n        return v;\n    };\n}\n\n// OpenType data types //////////////////////////////////////////////////////\n\n/**\n * Convert an 8-bit unsigned integer to a list of 1 byte.\n * @param {number}\n * @returns {Array}\n */\nencode.BYTE = function(v) {\n    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n    return [v];\n};\n/**\n * @constant\n * @type {number}\n */\nsizeOf.BYTE = constant(1);\n\n/**\n * Convert a 8-bit signed integer to a list of 1 byte.\n * @param {string}\n * @returns {Array}\n */\nencode.CHAR = function(v) {\n    return [v.charCodeAt(0)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.CHAR = constant(1);\n\n/**\n * Convert an ASCII string to a list of bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.CHARARRAY = function(v) {\n    if (typeof v === 'undefined') {\n        v = '';\n        console.warn('Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.');\n    }\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        b[i] = v.charCodeAt(i);\n    }\n\n    return b;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARARRAY = function(v) {\n    if (typeof v === 'undefined') {\n        return 0;\n    }\n    return v.length;\n};\n\n/**\n * Convert a 16-bit unsigned integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.USHORT = function(v) {\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.USHORT = constant(2);\n\n/**\n * Convert a 16-bit signed integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.SHORT = function(v) {\n    // Two's complement\n    if (v >= LIMIT16) {\n        v = -(2 * LIMIT16 - v);\n    }\n\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.SHORT = constant(2);\n\n/**\n * Convert a 24-bit unsigned integer to a list of 3 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.UINT24 = function(v) {\n    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.UINT24 = constant(3);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.ULONG = function(v) {\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.ULONG = constant(4);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.LONG = function(v) {\n    // Two's complement\n    if (v >= LIMIT32) {\n        v = -(2 * LIMIT32 - v);\n    }\n\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONG = constant(4);\n\nencode.FIXED = encode.ULONG;\nsizeOf.FIXED = sizeOf.ULONG;\n\nencode.FWORD = encode.SHORT;\nsizeOf.FWORD = sizeOf.SHORT;\n\nencode.UFWORD = encode.USHORT;\nsizeOf.UFWORD = sizeOf.USHORT;\n\n/**\n * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n * @param {number}\n * @returns {Array}\n */\nencode.LONGDATETIME = function(v) {\n    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONGDATETIME = constant(8);\n\n/**\n * Convert a 4-char tag to a list of 4 bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.TAG = function(v) {\n    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n    return [v.charCodeAt(0),\n            v.charCodeAt(1),\n            v.charCodeAt(2),\n            v.charCodeAt(3)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.TAG = constant(4);\n\n// CFF data types ///////////////////////////////////////////////////////////\n\nencode.Card8 = encode.BYTE;\nsizeOf.Card8 = sizeOf.BYTE;\n\nencode.Card16 = encode.USHORT;\nsizeOf.Card16 = sizeOf.USHORT;\n\nencode.OffSize = encode.BYTE;\nsizeOf.OffSize = sizeOf.BYTE;\n\nencode.SID = encode.USHORT;\nsizeOf.SID = sizeOf.USHORT;\n\n// Convert a numeric operand or charstring number to a variable-size list of bytes.\n/**\n * Convert a numeric operand or charstring number to a variable-size list of bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER = function(v) {\n    if (v >= -107 && v <= 107) {\n        return [v + 139];\n    } else if (v >= 108 && v <= 1131) {\n        v = v - 108;\n        return [(v >> 8) + 247, v & 0xFF];\n    } else if (v >= -1131 && v <= -108) {\n        v = -v - 108;\n        return [(v >> 8) + 251, v & 0xFF];\n    } else if (v >= -32768 && v <= 32767) {\n        return encode.NUMBER16(v);\n    } else {\n        return encode.NUMBER32(v);\n    }\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.NUMBER = function(v) {\n    return encode.NUMBER(v).length;\n};\n\n/**\n * Convert a signed number between -32768 and +32767 to a three-byte value.\n * This ensures we always use three bytes, but is not the most compact format.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER16 = function(v) {\n    return [28, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER16 = constant(3);\n\n/**\n * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n * This is useful if you want to be sure you always use four bytes,\n * at the expense of wasting a few bytes for smaller numbers.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER32 = function(v) {\n    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER32 = constant(5);\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.REAL = function(v) {\n    var value = v.toString();\n\n    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n    // This code converts it back to a number without the epsilon.\n    var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n    if (m) {\n        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n        value = (Math.round(v * epsilon) / epsilon).toString();\n    }\n\n    var nibbles = '';\n    for (var i = 0, ii = value.length; i < ii; i += 1) {\n        var c = value[i];\n        if (c === 'e') {\n            nibbles += value[++i] === '-' ? 'c' : 'b';\n        } else if (c === '.') {\n            nibbles += 'a';\n        } else if (c === '-') {\n            nibbles += 'e';\n        } else {\n            nibbles += c;\n        }\n    }\n\n    nibbles += (nibbles.length & 1) ? 'f' : 'ff';\n    var out = [30];\n    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {\n        out.push(parseInt(nibbles.substr(i$1, 2), 16));\n    }\n\n    return out;\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.REAL = function(v) {\n    return encode.REAL(v).length;\n};\n\nencode.NAME = encode.CHARARRAY;\nsizeOf.NAME = sizeOf.CHARARRAY;\n\nencode.STRING = encode.CHARARRAY;\nsizeOf.STRING = sizeOf.CHARARRAY;\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF8 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes;\n    for (var j = 0; j < numChars; j++, offset += 1) {\n        codePoints[j] = data.getUint8(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF16 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes / 2;\n    for (var j = 0; j < numChars; j++, offset += 2) {\n        codePoints[j] = data.getUint16(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * Convert a JavaScript string to UTF16-BE.\n * @param {string}\n * @returns {Array}\n */\nencode.UTF16 = function(v) {\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        var codepoint = v.charCodeAt(i);\n        b[b.length] = (codepoint >> 8) & 0xFF;\n        b[b.length] = codepoint & 0xFF;\n    }\n\n    return b;\n};\n\n/**\n * @param {string}\n * @returns {number}\n */\nsizeOf.UTF16 = function(v) {\n    return v.length * 2;\n};\n\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */\nvar eightBitMacEncodings = {\n    'x-mac-croatian':  // Python: 'mac_croatian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +\n    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',\n    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +\n    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',\n    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +\n    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',\n    'x-mac-greek':  // Python: 'mac_greek'\n    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +\n    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\\u00AD',\n    'x-mac-icelandic':  // Python: 'mac_iceland'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +\n    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',\n    'x-mac-ce':  // Python: 'mac_latin2'\n    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +\n    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',\n    macintosh:  // Python: 'mac_roman'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-romanian':  // Python: 'mac_romanian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-turkish':  // Python: 'mac_turkish'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'\n};\n\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\ndecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n    var table = eightBitMacEncodings[encoding];\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = '';\n    for (var i = 0; i < dataLength; i++) {\n        var c = dataView.getUint8(offset + i);\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c <= 0x7F) {\n            result += String.fromCharCode(c);\n        } else {\n            result += table[c & 0x7F];\n        }\n    }\n\n    return result;\n};\n\n// Helper function for encode.MACSTRING. Returns a dictionary for mapping\n// Unicode character codes to their 8-bit MacOS equivalent. This table\n// is not exactly a super cheap data structure, but we do not care because\n// encoding Macintosh strings is only rarely needed in typical applications.\nvar macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\nvar macEncodingCacheKeys;\nvar getMacEncodingTable = function (encoding) {\n    // Since we use encoding as a cache key for WeakMap, it has to be\n    // a String object and not a literal. And at least on NodeJS 2.10.1,\n    // WeakMap requires that the same String instance is passed for cache hits.\n    if (!macEncodingCacheKeys) {\n        macEncodingCacheKeys = {};\n        for (var e in eightBitMacEncodings) {\n            /*jshint -W053 */  // Suppress \"Do not use String as a constructor.\"\n            macEncodingCacheKeys[e] = new String(e);\n        }\n    }\n\n    var cacheKey = macEncodingCacheKeys[encoding];\n    if (cacheKey === undefined) {\n        return undefined;\n    }\n\n    // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n    // since garbage collection may run at any time, it could also kick in\n    // between the calls to cache.has() and cache.get(). In that case,\n    // we would return 'undefined' even though we do support the encoding.\n    if (macEncodingTableCache) {\n        var cachedTable = macEncodingTableCache.get(cacheKey);\n        if (cachedTable !== undefined) {\n            return cachedTable;\n        }\n    }\n\n    var decodingTable = eightBitMacEncodings[encoding];\n    if (decodingTable === undefined) {\n        return undefined;\n    }\n\n    var encodingTable = {};\n    for (var i = 0; i < decodingTable.length; i++) {\n        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n    }\n\n    if (macEncodingTableCache) {\n        macEncodingTableCache.set(cacheKey, encodingTable);\n    }\n\n    return encodingTable;\n};\n\n/**\n * Encodes an old-style Macintosh string. Returns a byte array upon success.\n * If the requested encoding is unsupported, or if the input string contains\n * a character that cannot be expressed in the encoding, the function returns\n * 'undefined'.\n * @param {string} str\n * @param {string} encoding\n * @returns {Array}\n */\nencode.MACSTRING = function(str, encoding) {\n    var table = getMacEncodingTable(encoding);\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c >= 0x80) {\n            c = table[c];\n            if (c === undefined) {\n                // str contains a Unicode character that cannot be encoded\n                // in the requested encoding.\n                return undefined;\n            }\n        }\n        result[i] = c;\n        // result.push(c);\n    }\n\n    return result;\n};\n\n/**\n * @param {string} str\n * @param {string} encoding\n * @returns {number}\n */\nsizeOf.MACSTRING = function(str, encoding) {\n    var b = encode.MACSTRING(str, encoding);\n    if (b !== undefined) {\n        return b.length;\n    } else {\n        return 0;\n    }\n};\n\n// Helper for encode.VARDELTAS\nfunction isByteEncodable(value) {\n    return value >= -128 && value <= 127;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x80 | (runLength - 1));\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    var pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        var value = deltas[pos];\n        if (!isByteEncodable(value)) {\n            break;\n        }\n\n        // Within a byte-encoded run of deltas, a single zero is best\n        // stored literally as 0x00 value. However, if we have two or\n        // more zeroes in a sequence, it is better to start a new run.\n        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n        // when starting a new run.\n        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(runLength - 1);\n    for (var i = offset; i < pos; ++i) {\n        result.push((deltas[i] + 256) & 0xff);\n    }\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    var pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        var value = deltas[pos];\n\n        // Within a word-encoded run of deltas, it is easiest to start\n        // a new run (with a different encoding) whenever we encounter\n        // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n        // needs 7 bytes when storing the zero inside the current run\n        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n        // new run (40 66 66 80 40 77 77).\n        if (value === 0) {\n            break;\n        }\n\n        // Within a word-encoded run of deltas, a single value in the\n        // range (-128..127) should be encoded within the current run\n        // because it is more compact. For example, the sequence\n        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n        // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n        // a new run (40 66 66 00 02 40 77 77).\n        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x40 | (runLength - 1));\n    for (var i = offset; i < pos; ++i) {\n        var val = deltas[i];\n        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);\n    }\n    return pos;\n}\n\n/**\n * Encode a list of variation adjustment deltas.\n *\n * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.\n * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted\n * when generating instances of variation fonts.\n *\n * @see https://www.microsoft.com/typography/otspec/gvar.htm\n * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n * @param {Array}\n * @return {Array}\n */\nencode.VARDELTAS = function(deltas) {\n    var pos = 0;\n    var result = [];\n    while (pos < deltas.length) {\n        var value = deltas[pos];\n        if (value === 0) {\n            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n        } else if (value >= -128 && value <= 127) {\n            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n        } else {\n            pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n        }\n    }\n    return result;\n};\n\n// Convert a list of values to a CFF INDEX structure.\n// The values should be objects containing name / type / value.\n/**\n * @param {Array} l\n * @returns {Array}\n */\nencode.INDEX = function(l) {\n    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n    //    i, v;\n    // Because we have to know which data type to use to encode the offsets,\n    // we have to go through the values twice: once to encode the data and\n    // calculate the offsets, then again to encode the offsets using the fitting data type.\n    var offset = 1; // First offset is always 1.\n    var offsets = [offset];\n    var data = [];\n    for (var i = 0; i < l.length; i += 1) {\n        var v = encode.OBJECT(l[i]);\n        Array.prototype.push.apply(data, v);\n        offset += v.length;\n        offsets.push(offset);\n    }\n\n    if (data.length === 0) {\n        return [0, 0];\n    }\n\n    var encodedOffsets = [];\n    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;\n    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {\n        var encodedOffset = offsetEncoder(offsets[i$1]);\n        Array.prototype.push.apply(encodedOffsets, encodedOffset);\n    }\n\n    return Array.prototype.concat(encode.Card16(l.length),\n                           encode.OffSize(offSize),\n                           encodedOffsets,\n                           data);\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.INDEX = function(v) {\n    return encode.INDEX(v).length;\n};\n\n/**\n * Convert an object to a CFF DICT structure.\n * The keys should be numeric.\n * The values should be objects containing name / type / value.\n * @param {Object} m\n * @returns {Array}\n */\nencode.DICT = function(m) {\n    var d = [];\n    var keys = Object.keys(m);\n    var length = keys.length;\n\n    for (var i = 0; i < length; i += 1) {\n        // Object.keys() return string keys, but our keys are always numeric.\n        var k = parseInt(keys[i], 0);\n        var v = m[k];\n        // Value comes before the key.\n        d = d.concat(encode.OPERAND(v.value, v.type));\n        d = d.concat(encode.OPERATOR(k));\n    }\n\n    return d;\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.DICT = function(m) {\n    return encode.DICT(m).length;\n};\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.OPERATOR = function(v) {\n    if (v < 1200) {\n        return [v];\n    } else {\n        return [12, v - 1200];\n    }\n};\n\n/**\n * @param {Array} v\n * @param {string}\n * @returns {Array}\n */\nencode.OPERAND = function(v, type) {\n    var d = [];\n    if (Array.isArray(type)) {\n        for (var i = 0; i < type.length; i += 1) {\n            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n            d = d.concat(encode.OPERAND(v[i], type[i]));\n        }\n    } else {\n        if (type === 'SID') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'offset') {\n            // We make it easy for ourselves and always encode offsets as\n            // 4 bytes. This makes offset calculation for the top dict easier.\n            d = d.concat(encode.NUMBER32(v));\n        } else if (type === 'number') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'real') {\n            d = d.concat(encode.REAL(v));\n        } else {\n            throw new Error('Unknown operand type ' + type);\n            // FIXME Add support for booleans\n        }\n    }\n\n    return d;\n};\n\nencode.OP = encode.BYTE;\nsizeOf.OP = sizeOf.BYTE;\n\n// memoize charstring encoding using WeakMap if available\nvar wmm = typeof WeakMap === 'function' && new WeakMap();\n\n/**\n * Convert a list of CharString operations to bytes.\n * @param {Array}\n * @returns {Array}\n */\nencode.CHARSTRING = function(ops) {\n    // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n    if (wmm) {\n        var cachedValue = wmm.get(ops);\n        if (cachedValue !== undefined) {\n            return cachedValue;\n        }\n    }\n\n    var d = [];\n    var length = ops.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var op = ops[i];\n        d = d.concat(encode[op.type](op.value));\n    }\n\n    if (wmm) {\n        wmm.set(ops, d);\n    }\n\n    return d;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARSTRING = function(ops) {\n    return encode.CHARSTRING(ops).length;\n};\n\n// Utility functions ////////////////////////////////////////////////////////\n\n/**\n * Convert an object containing name / type / value to bytes.\n * @param {Object}\n * @returns {Array}\n */\nencode.OBJECT = function(v) {\n    var encodingFunction = encode[v.type];\n    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n    return encodingFunction(v.value);\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.OBJECT = function(v) {\n    var sizeOfFunction = sizeOf[v.type];\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n    return sizeOfFunction(v.value);\n};\n\n/**\n * Convert a table object to bytes.\n * A table contains a list of fields containing the metadata (name, type and default value).\n * The table itself has the field values set as attributes.\n * @param {opentype.Table}\n * @returns {Array}\n */\nencode.TABLE = function(table) {\n    var d = [];\n    var length = table.fields.length;\n    var subtables = [];\n    var subtableOffsets = [];\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var encodingFunction = encode[field.type];\n        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        var bytes = encodingFunction(value);\n\n        if (field.type === 'TABLE') {\n            subtableOffsets.push(d.length);\n            d = d.concat([0, 0]);\n            subtables.push(bytes);\n        } else {\n            d = d.concat(bytes);\n        }\n    }\n\n    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {\n        var o = subtableOffsets[i$1];\n        var offset = d.length;\n        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n        d[o] = offset >> 8;\n        d[o + 1] = offset & 0xff;\n        d = d.concat(subtables[i$1]);\n    }\n\n    return d;\n};\n\n/**\n * @param {opentype.Table}\n * @returns {number}\n */\nsizeOf.TABLE = function(table) {\n    var numBytes = 0;\n    var length = table.fields.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var sizeOfFunction = sizeOf[field.type];\n        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        numBytes += sizeOfFunction(value);\n\n        // Subtables take 2 more bytes for offsets.\n        if (field.type === 'TABLE') {\n            numBytes += 2;\n        }\n    }\n\n    return numBytes;\n};\n\nencode.RECORD = encode.TABLE;\nsizeOf.RECORD = sizeOf.TABLE;\n\n// Merge in a list of bytes.\nencode.LITERAL = function(v) {\n    return v;\n};\n\nsizeOf.LITERAL = function(v) {\n    return v.length;\n};\n\n// Table metadata\n\n/**\n * @exports opentype.Table\n * @class\n * @param {string} tableName\n * @param {Array} fields\n * @param {Object} options\n * @constructor\n */\nfunction Table(tableName, fields, options) {\n    // For coverage tables with coverage format 2, we do not want to add the coverage data directly to the table object,\n    // as this will result in wrong encoding order of the coverage data on serialization to bytes.\n    // The fallback of using the field values directly when not present on the table is handled in types.encode.TABLE() already.\n    if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {\n        for (var i = 0; i < fields.length; i += 1) {\n            var field = fields[i];\n            this[field.name] = field.value;\n        }\n    }\n\n    this.tableName = tableName;\n    this.fields = fields;\n    if (options) {\n        var optionKeys = Object.keys(options);\n        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {\n            var k = optionKeys[i$1];\n            var v = options[k];\n            if (this[k] !== undefined) {\n                this[k] = v;\n            }\n        }\n    }\n}\n\n/**\n * Encodes the table and returns an array of bytes\n * @return {Array}\n */\nTable.prototype.encode = function() {\n    return encode.TABLE(this);\n};\n\n/**\n * Get the size of the table.\n * @return {number}\n */\nTable.prototype.sizeOf = function() {\n    return sizeOf.TABLE(this);\n};\n\n/**\n * @private\n */\nfunction ushortList(itemName, list, count) {\n    if (count === undefined) {\n        count = list.length;\n    }\n    var fields = new Array(list.length + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < list.length; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction tableList(itemName, records, itemCallback) {\n    var count = records.length;\n    var fields = new Array(count + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < count; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction recordList(itemName, records, itemCallback) {\n    var count = records.length;\n    var fields = [];\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < count; i++) {\n        fields = fields.concat(itemCallback(records[i], i));\n    }\n    return fields;\n}\n\n// Common Layout Tables\n\n/**\n * @exports opentype.Coverage\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction Coverage(coverageTable) {\n    if (coverageTable.format === 1) {\n        Table.call(this, 'coverageTable',\n            [{name: 'coverageFormat', type: 'USHORT', value: 1}]\n            .concat(ushortList('glyph', coverageTable.glyphs))\n        );\n    } else if (coverageTable.format === 2) {\n        Table.call(this, 'coverageTable',\n            [{name: 'coverageFormat', type: 'USHORT', value: 2}]\n            .concat(recordList('rangeRecord', coverageTable.ranges, function(RangeRecord) {\n                return [\n                    {name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start},\n                    {name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end},\n                    {name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index} ];\n            }))\n        );\n    } else {\n        check.assert(false, 'Coverage format must be 1 or 2.');\n    }\n}\nCoverage.prototype = Object.create(Table.prototype);\nCoverage.prototype.constructor = Coverage;\n\nfunction ScriptList(scriptListTable) {\n    Table.call(this, 'scriptListTable',\n        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {\n            var script = scriptRecord.script;\n            var defaultLangSys = script.defaultLangSys;\n            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');\n            return [\n                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},\n                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [\n                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [\n                        {name: 'lookupOrder', type: 'USHORT', value: 0},\n                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]\n                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}\n                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {\n                        var langSys = langSysRecord.langSys;\n                        return [\n                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},\n                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [\n                                {name: 'lookupOrder', type: 'USHORT', value: 0},\n                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}\n                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}\n                        ];\n                    })))}\n            ];\n        })\n    );\n}\nScriptList.prototype = Object.create(Table.prototype);\nScriptList.prototype.constructor = ScriptList;\n\n/**\n * @exports opentype.FeatureList\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction FeatureList(featureListTable) {\n    Table.call(this, 'featureListTable',\n        recordList('featureRecord', featureListTable, function(featureRecord, i) {\n            var feature = featureRecord.feature;\n            return [\n                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},\n                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [\n                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}\n            ];\n        })\n    );\n}\nFeatureList.prototype = Object.create(Table.prototype);\nFeatureList.prototype.constructor = FeatureList;\n\n/**\n * @exports opentype.LookupList\n * @class\n * @param {opentype.Table}\n * @param {Object}\n * @constructor\n * @extends opentype.Table\n */\nfunction LookupList(lookupListTable, subtableMakers) {\n    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {\n        var subtableCallback = subtableMakers[lookupTable.lookupType];\n        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');\n        return new Table('lookupTable', [\n            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},\n            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}\n        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));\n    }));\n}\nLookupList.prototype = Object.create(Table.prototype);\nLookupList.prototype.constructor = LookupList;\n\n// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)\n// Don't use offsets inside Records (probable bug), only in Tables.\nvar table = {\n    Table: Table,\n    Record: Table,\n    Coverage: Coverage,\n    ScriptList: ScriptList,\n    FeatureList: FeatureList,\n    LookupList: LookupList,\n    ushortList: ushortList,\n    tableList: tableList,\n    recordList: recordList,\n};\n\n// Parsing utility functions\n\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false);\n}\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n    return dataView.getInt16(offset, false);\n}\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n    return dataView.getUint32(offset, false);\n}\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n    var decimal = dataView.getInt16(offset, false);\n    var fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n}\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n    var tag = '';\n    for (var i = offset; i < offset + 4; i += 1) {\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n\n    return tag;\n}\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n    var v = 0;\n    for (var i = 0; i < offSize; i += 1) {\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n\n    return v;\n}\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n    var bytes = [];\n    for (var i = startOffset; i < endOffset; i += 1) {\n        bytes.push(dataView.getUint8(i));\n    }\n\n    return bytes;\n}\n\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n    var s = '';\n    for (var i = 0; i < bytes.length; i += 1) {\n        s += String.fromCharCode(bytes[i]);\n    }\n\n    return s;\n}\n\nvar typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function() {\n    var v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseChar = function() {\n    var v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function() {\n    var v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseF2Dot14 = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseULong = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\nParser.prototype.parseFixed = function() {\n    var v = getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseString = function(length) {\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    var string = '';\n    this.relativeOffset += length;\n    for (var i = 0; i < length; i++) {\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n\n    return string;\n};\n\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800;\n    this.relativeOffset += 8;\n    return v;\n};\n\nParser.prototype.parseVersion = function(minorBase) {\n    var major = getUShort(this.data, this.offset + this.relativeOffset);\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // Default returns the correct number if minor = 0xN000 where N is 0-9\n    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    if (minorBase === undefined) { minorBase = 0x1000; }\n    return major + minor / minorBase / 10;\n};\n\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n\n///// Parsing lists and records ///////////////////////////////\n\n// Parse a list of 32 bit unsigned integers.\nParser.prototype.parseULongList = function(count) {\n    if (count === undefined) { count = this.parseULong(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint32(offset);\n        offset += 4;\n    }\n\n    this.relativeOffset += count * 4;\n    return offsets;\n};\n\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List =\nParser.prototype.parseUShortList = function(count) {\n    if (count === undefined) { count = this.parseUShort(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getInt16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return list;\n};\n\n// Parses a list of bytes.\nParser.prototype.parseByteList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getUint8(offset++);\n    }\n\n    this.relativeOffset += count;\n    return list;\n};\n\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\nParser.prototype.parseList = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseUShort();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\nParser.prototype.parseList32 = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseULong();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\nParser.prototype.parseRecordList = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseUShort();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\nParser.prototype.parseRecordList32 = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseULong();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function(description) {\n    if (typeof description === 'function') {\n        return description.call(this);\n    } else {\n        var fields = Object.keys(description);\n        var struct = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = description[fieldName];\n            struct[fieldName] = fieldType.call(this);\n        }\n        return struct;\n    }\n};\n\n/**\n * Parse a GPOS valueRecord\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat is optional, if omitted it is read from the stream.\n */\nParser.prototype.parseValueRecord = function(valueFormat) {\n    if (valueFormat === undefined) {\n        valueFormat = this.parseUShort();\n    }\n    if (valueFormat === 0) {\n        // valueFormat2 in kerning pairs is most often 0\n        // in this case return undefined instead of an empty object, to save space\n        return;\n    }\n    var valueRecord = {};\n\n    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }\n    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }\n    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }\n    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }\n\n    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }\n\n    return valueRecord;\n};\n\n/**\n * Parse a list of GPOS valueRecords\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat and valueCount are read from the stream.\n */\nParser.prototype.parseValueRecordList = function() {\n    var valueFormat = this.parseUShort();\n    var valueCount = this.parseUShort();\n    var values = new Array(valueCount);\n    for (var i = 0; i < valueCount; i++) {\n        values[i] = this.parseValueRecord(valueFormat);\n    }\n    return values;\n};\n\nParser.prototype.parsePointer = function(description) {\n    var structOffset = this.parseOffset16();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\nParser.prototype.parsePointer32 = function(description) {\n    var structOffset = this.parseOffset32();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\nParser.prototype.parseListOfLists = function(itemCallback) {\n    var offsets = this.parseOffset16List();\n    var count = offsets.length;\n    var relativeOffset = this.relativeOffset;\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        var start = offsets[i];\n        if (start === 0) {\n            // NULL offset\n            // Add i as owned property to list. Convenient with assert.\n            list[i] = undefined;\n            continue;\n        }\n        this.relativeOffset = start;\n        if (itemCallback) {\n            var subOffsets = this.parseOffset16List();\n            var subList = new Array(subOffsets.length);\n            for (var j = 0; j < subOffsets.length; j++) {\n                this.relativeOffset = start + subOffsets[j];\n                subList[j] = itemCallback.call(this);\n            }\n            list[i] = subList;\n        } else {\n            list[i] = this.parseUShortList();\n        }\n    }\n    this.relativeOffset = relativeOffset;\n    return list;\n};\n\n///// Complex tables parsing //////////////////////////////////\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    var count = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            glyphs: this.parseUShortList(count)\n        };\n    } else if (format === 2) {\n        var ranges = new Array(count);\n        for (var i = 0; i < count; i++) {\n            ranges[i] = {\n                start: this.parseUShort(),\n                end: this.parseUShort(),\n                index: this.parseUShort()\n            };\n        }\n        return {\n            format: 2,\n            ranges: ranges\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n};\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            startGlyph: this.parseUShort(),\n            classes: this.parseUShortList()\n        };\n    } else if (format === 2) {\n        return {\n            format: 2,\n            ranges: this.parseRecordList({\n                start: Parser.uShort,\n                end: Parser.uShort,\n                classId: Parser.uShort\n            })\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n};\n\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\nParser.list = function(count, itemCallback) {\n    return function() {\n        return this.parseList(count, itemCallback);\n    };\n};\n\nParser.list32 = function(count, itemCallback) {\n    return function() {\n        return this.parseList32(count, itemCallback);\n    };\n};\n\nParser.recordList = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList(count, recordDescription);\n    };\n};\n\nParser.recordList32 = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList32(count, recordDescription);\n    };\n};\n\nParser.pointer = function(description) {\n    return function() {\n        return this.parsePointer(description);\n    };\n};\n\nParser.pointer32 = function(description) {\n    return function() {\n        return this.parsePointer32(description);\n    };\n};\n\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\nParser.uLongList = Parser.prototype.parseULongList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nvar langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList\n};\n\nParser.prototype.parseScriptList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n                tag: Parser.tag,\n                langSys: Parser.pointer(langSysTable)\n            })\n        })\n    })) || [];\n};\n\nParser.prototype.parseFeatureList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n        })\n    })) || [];\n};\n\nParser.prototype.parseLookupList = function(lookupTableParsers) {\n    return this.parsePointer(Parser.list(Parser.pointer(function() {\n        var lookupType = this.parseUShort();\n        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n        var lookupFlag = this.parseUShort();\n        var useMarkFilteringSet = lookupFlag & 0x10;\n        return {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n        };\n    }))) || [];\n};\n\nParser.prototype.parseFeatureVariationsList = function() {\n    return this.parsePointer32(function() {\n        var majorVersion = this.parseUShort();\n        var minorVersion = this.parseUShort();\n        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n        var featureVariations = this.parseRecordList32({\n            conditionSetOffset: Parser.offset32,\n            featureTableSubstitutionOffset: Parser.offset32\n        });\n        return featureVariations;\n    }) || [];\n};\n\nvar parse = {\n    getByte: getByte,\n    getCard8: getByte,\n    getUShort: getUShort,\n    getCard16: getUShort,\n    getShort: getShort,\n    getULong: getULong,\n    getFixed: getFixed,\n    getTag: getTag,\n    getOffset: getOffset,\n    getBytes: getBytes,\n    bytesToString: bytesToString,\n    Parser: Parser,\n};\n\n// The `cmap` table stores the mappings from characters to glyphs.\n\nfunction parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort();\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong();\n    cmap.language = p.parseULong();\n\n    var groupCount;\n    cmap.groupCount = groupCount = p.parseULong();\n    cmap.glyphIndexMap = {};\n\n    for (var i = 0; i < groupCount; i += 1) {\n        var startCharCode = p.parseULong();\n        var endCharCode = p.parseULong();\n        var startGlyphId = p.parseULong();\n\n        for (var c = startCharCode; c <= endCharCode; c += 1) {\n            cmap.glyphIndexMap[c] = startGlyphId;\n            startGlyphId++;\n        }\n    }\n}\n\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n\n    // segCount is stored x 2.\n    var segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n    var endCountParser = new parse.Parser(data, start + offset + 14);\n    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for (var i = 0; i < segCount - 1; i += 1) {\n        var glyphIndex = (void 0);\n        var endCount = endCountParser.parseUShort();\n        var startCount = startCountParser.parseUShort();\n        var idDelta = idDeltaParser.parseShort();\n        var idRangeOffset = idRangeOffsetParser.parseUShort();\n        for (var c = startCount; c <= endCount; c += 1) {\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);\n\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;\n                }\n            } else {\n                glyphIndex = (c + idDelta) & 0xFFFF;\n            }\n\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n}\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    var cmap = {};\n    cmap.version = parse.getUShort(data, start);\n    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n    cmap.numTables = parse.getUShort(data, start + 2);\n    var offset = -1;\n    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n        var platformId = parse.getUShort(data, start + 4 + (i * 8));\n        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);\n        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {\n            offset = parse.getULong(data, start + 4 + (i * 8) + 4);\n            break;\n        }\n    }\n\n    if (offset === -1) {\n        // There is no cmap table in the font that we support.\n        throw new Error('No valid cmap sub-tables found.');\n    }\n\n    var p = new parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n\n    if (cmap.format === 12) {\n        parseCmapTableFormat12(cmap, p);\n    } else if (cmap.format === 4) {\n        parseCmapTableFormat4(cmap, p, data, start, offset);\n    } else {\n        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n    }\n\n    return cmap;\n}\n\nfunction addSegment(t, code, glyphIndex) {\n    t.segments.push({\n        end: code,\n        start: code,\n        delta: -(code - glyphIndex),\n        offset: 0,\n        glyphIndex: glyphIndex\n    });\n}\n\nfunction addTerminatorSegment(t) {\n    t.segments.push({\n        end: 0xFFFF,\n        start: 0xFFFF,\n        delta: 1,\n        offset: 0\n    });\n}\n\n// Make cmap table, format 4 by default, 12 if needed only\nfunction makeCmapTable(glyphs) {\n    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)\n    var isPlan0Only = true;\n    var i;\n\n    // Check if we need to add cmap format 12 or if format 4 only is fine\n    for (i = glyphs.length - 1; i > 0; i -= 1) {\n        var g = glyphs.get(i);\n        if (g.unicode > 65535) {\n            console.log('Adding CMAP format 12 (needed!)');\n            isPlan0Only = false;\n            break;\n        }\n    }\n\n    var cmapTable = [\n        {name: 'version', type: 'USHORT', value: 0},\n        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},\n\n        // CMAP 4 header\n        {name: 'platformID', type: 'USHORT', value: 3},\n        {name: 'encodingID', type: 'USHORT', value: 1},\n        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}\n    ];\n\n    if (!isPlan0Only)\n        { cmapTable = cmapTable.concat([\n            // CMAP 12 header\n            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere\n            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},\n            {name: 'cmap12Offset', type: 'ULONG', value: 0}\n        ]); }\n\n    cmapTable = cmapTable.concat([\n        // CMAP 4 Subtable\n        {name: 'format', type: 'USHORT', value: 4},\n        {name: 'cmap4Length', type: 'USHORT', value: 0},\n        {name: 'language', type: 'USHORT', value: 0},\n        {name: 'segCountX2', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n\n    var t = new table.Table('cmap', cmapTable);\n\n    t.segments = [];\n    for (i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        for (var j = 0; j < glyph.unicodes.length; j += 1) {\n            addSegment(t, glyph.unicodes[j], i);\n        }\n\n        t.segments = t.segments.sort(function (a, b) {\n            return a.start - b.start;\n        });\n    }\n\n    addTerminatorSegment(t);\n\n    var segCount = t.segments.length;\n    var segCountToRemove = 0;\n\n    // CMAP 4\n    // Set up parallel segment arrays.\n    var endCounts = [];\n    var startCounts = [];\n    var idDeltas = [];\n    var idRangeOffsets = [];\n    var glyphIds = [];\n\n    // CMAP 12\n    var cmap12Groups = [];\n\n    // Reminder this loop is not following the specification at 100%\n    // The specification -> find suites of characters and make a group\n    // Here we're doing one group for each letter\n    // Doing as the spec can save 8 times (or more) space\n    for (i = 0; i < segCount; i += 1) {\n        var segment = t.segments[i];\n\n        // CMAP 4\n        if (segment.end <= 65535 && segment.start <= 65535) {\n            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});\n            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});\n            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});\n            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});\n            if (segment.glyphId !== undefined) {\n                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});\n            }\n        } else {\n            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12\n            segCountToRemove += 1;\n        }\n\n        // CMAP 12\n        // Skip Terminator Segment\n        if (!isPlan0Only && segment.glyphIndex !== undefined) {\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});\n        }\n    }\n\n    // CMAP 4 Subtable\n    t.segCountX2 = (segCount - segCountToRemove) * 2;\n    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;\n    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n    t.rangeShift = t.segCountX2 - t.searchRange;\n\n    t.fields = t.fields.concat(endCounts);\n    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});\n    t.fields = t.fields.concat(startCounts);\n    t.fields = t.fields.concat(idDeltas);\n    t.fields = t.fields.concat(idRangeOffsets);\n    t.fields = t.fields.concat(glyphIds);\n\n    t.cmap4Length = 14 + // Subtable header\n        endCounts.length * 2 +\n        2 + // reservedPad\n        startCounts.length * 2 +\n        idDeltas.length * 2 +\n        idRangeOffsets.length * 2 +\n        glyphIds.length * 2;\n\n    if (!isPlan0Only) {\n        // CMAP 12 Subtable\n        var cmap12Length = 16 + // Subtable header\n            cmap12Groups.length * 4;\n\n        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;\n        t.fields = t.fields.concat([\n            {name: 'cmap12Format', type: 'USHORT', value: 12},\n            {name: 'cmap12Reserved', type: 'USHORT', value: 0},\n            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},\n            {name: 'cmap12Language', type: 'ULONG', value: 0},\n            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}\n        ]);\n\n        t.fields = t.fields.concat(cmap12Groups);\n    }\n\n    return t;\n}\n\nvar cmap = { parse: parseCmapTable, make: makeCmapTable };\n\n// Glyph encoding\n\nvar cffStandardStrings = [\n    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',\n    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',\n    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',\n    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',\n    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',\n    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',\n    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',\n    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',\n    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',\n    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',\n    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',\n    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',\n    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',\n    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',\n    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',\n    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',\n    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',\n    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',\n    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',\n    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',\n    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',\n    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',\n    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',\n    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',\n    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',\n    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',\n    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];\n\nvar cffStandardEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n    'lslash', 'oslash', 'oe', 'germandbls'];\n\nvar cffExpertEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\n\nvar standardNames = [\n    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\n\n/**\n * This is the encoding used for fonts created from scratch.\n * It loops through all glyphs and finds the appropriate unicode value.\n * Since it's linear time, other encodings will be faster.\n * @exports opentype.DefaultEncoding\n * @class\n * @constructor\n * @param {opentype.Font}\n */\nfunction DefaultEncoding(font) {\n    this.font = font;\n}\n\nDefaultEncoding.prototype.charToGlyphIndex = function(c) {\n    var code = c.codePointAt(0);\n    var glyphs = this.font.glyphs;\n    if (glyphs) {\n        for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n                if (glyph.unicodes[j] === code) {\n                    return i;\n                }\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @exports opentype.CmapEncoding\n * @class\n * @constructor\n * @param {Object} cmap - a object with the cmap encoded data\n */\nfunction CmapEncoding(cmap) {\n    this.cmap = cmap;\n}\n\n/**\n * @param  {string} c - the character\n * @return {number} The glyph index.\n */\nCmapEncoding.prototype.charToGlyphIndex = function(c) {\n    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n};\n\n/**\n * @exports opentype.CffEncoding\n * @class\n * @constructor\n * @param {string} encoding - The encoding\n * @param {Array} charset - The character set.\n */\nfunction CffEncoding(encoding, charset) {\n    this.encoding = encoding;\n    this.charset = charset;\n}\n\n/**\n * @param  {string} s - The character\n * @return {number} The index.\n */\nCffEncoding.prototype.charToGlyphIndex = function(s) {\n    var code = s.codePointAt(0);\n    var charName = this.encoding[code];\n    return this.charset.indexOf(charName);\n};\n\n/**\n * @exports opentype.GlyphNames\n * @class\n * @constructor\n * @param {Object} post\n */\nfunction GlyphNames(post) {\n    switch (post.version) {\n        case 1:\n            this.names = standardNames.slice();\n            break;\n        case 2:\n            this.names = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                if (post.glyphNameIndex[i] < standardNames.length) {\n                    this.names[i] = standardNames[post.glyphNameIndex[i]];\n                } else {\n                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];\n                }\n            }\n\n            break;\n        case 2.5:\n            this.names = new Array(post.numberOfGlyphs);\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];\n            }\n\n            break;\n        case 3:\n            this.names = [];\n            break;\n        default:\n            this.names = [];\n            break;\n    }\n}\n\n/**\n * Gets the index of a glyph by name.\n * @param  {string} name - The glyph name\n * @return {number} The index\n */\nGlyphNames.prototype.nameToGlyphIndex = function(name) {\n    return this.names.indexOf(name);\n};\n\n/**\n * @param  {number} gid\n * @return {string}\n */\nGlyphNames.prototype.glyphIndexToName = function(gid) {\n    return this.names[gid];\n};\n\nfunction addGlyphNamesAll(font) {\n    var glyph;\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        glyph = font.glyphs.get(glyphIndex);\n        glyph.addUnicode(parseInt(c));\n    }\n\n    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {\n        glyph = font.glyphs.get(i$1);\n        if (font.cffEncoding) {\n            if (font.isCIDFont) {\n                glyph.name = 'gid' + i$1;\n            } else {\n                glyph.name = font.cffEncoding.charset[i$1];\n            }\n        } else if (font.glyphNames.names) {\n            glyph.name = font.glyphNames.glyphIndexToName(i$1);\n        }\n    }\n}\n\nfunction addGlyphNamesToUnicodeMap(font) {\n    font._IndexToUnicodeMap = {};\n\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n            font._IndexToUnicodeMap[glyphIndex] = {\n                unicodes: [parseInt(c)]\n            };\n        } else {\n            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));\n        }\n    }\n}\n\n/**\n * @alias opentype.addGlyphNames\n * @param {opentype.Font}\n * @param {Object}\n */\nfunction addGlyphNames(font, opt) {\n    if (opt.lowMemory) {\n        addGlyphNamesToUnicodeMap(font);\n    } else {\n        addGlyphNamesAll(font);\n    }\n}\n\n// Drawing utility functions.\n\n// Draw a line on the given context from point `x1,y1` to point `x2,y2`.\nfunction line(ctx, x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\n\nvar draw = { line: line };\n\n// The Glyph object\n// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\nfunction getPathDefinition(glyph, path) {\n    var _path = path || new Path();\n    return {\n        configurable: true,\n\n        get: function() {\n            if (typeof _path === 'function') {\n                _path = _path();\n            }\n\n            return _path;\n        },\n\n        set: function(p) {\n            _path = p;\n        }\n    };\n}\n/**\n * @typedef GlyphOptions\n * @type Object\n * @property {string} [name] - The glyph name\n * @property {number} [unicode]\n * @property {Array} [unicodes]\n * @property {number} [xMin]\n * @property {number} [yMin]\n * @property {number} [xMax]\n * @property {number} [yMax]\n * @property {number} [advanceWidth]\n */\n\n// A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\n/**\n * @exports opentype.Glyph\n * @class\n * @param {GlyphOptions}\n * @constructor\n */\nfunction Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options);\n}\n\n/**\n * @param  {GlyphOptions}\n */\nGlyph.prototype.bindConstructorValues = function(options) {\n    this.index = options.index || 0;\n\n    // These three values cannot be deferred for memory optimization:\n    this.name = options.name || null;\n    this.unicode = options.unicode || undefined;\n    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];\n\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if ('xMin' in options) {\n        this.xMin = options.xMin;\n    }\n\n    if ('yMin' in options) {\n        this.yMin = options.yMin;\n    }\n\n    if ('xMax' in options) {\n        this.xMax = options.xMax;\n    }\n\n    if ('yMax' in options) {\n        this.yMax = options.yMax;\n    }\n\n    if ('advanceWidth' in options) {\n        this.advanceWidth = options.advanceWidth;\n    }\n\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n};\n\n/**\n * @param {number}\n */\nGlyph.prototype.addUnicode = function(unicode) {\n    if (this.unicodes.length === 0) {\n        this.unicode = unicode;\n    }\n\n    this.unicodes.push(unicode);\n};\n\n/**\n * Calculate the minimum bounding box for this glyph.\n * @return {opentype.BoundingBox}\n */\nGlyph.prototype.getBoundingBox = function() {\n    return this.path.getBoundingBox();\n};\n\n/**\n * Convert the glyph to a Path we can draw on a drawing context.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n * @param  {opentype.Font} if hinting is to be used, the font\n * @return {opentype.Path}\n */\nGlyph.prototype.getPath = function(x, y, fontSize, options, font) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    var commands;\n    var hPoints;\n    if (!options) { options = { }; }\n    var xScale = options.xScale;\n    var yScale = options.yScale;\n\n    if (options.hinting && font && font.hinting) {\n        // in case of hinting, the hinting engine takes care\n        // of scaling the points (not the path) before hinting.\n        hPoints = this.path && font.hinting.exec(this, fontSize);\n        // in case the hinting engine failed hPoints is undefined\n        // and thus reverts to plain rending\n    }\n\n    if (hPoints) {\n        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n        commands = font.hinting.getCommands(hPoints);\n        x = Math.round(x);\n        y = Math.round(y);\n        // TODO in case of hinting xyScaling is not yet supported\n        xScale = yScale = 1;\n    } else {\n        commands = this.path.commands;\n        var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;\n        if (xScale === undefined) { xScale = scale; }\n        if (yScale === undefined) { yScale = scale; }\n    }\n\n    var p = new Path();\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type === 'M') {\n            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'L') {\n            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Q') {\n            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                               x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'C') {\n            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),\n                      x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Z') {\n            p.closePath();\n        }\n    }\n\n    return p;\n};\n\n/**\n * Split the glyph into contours.\n * This function is here for backwards compatibility, and to\n * provide raw access to the TrueType glyph outlines.\n * @return {Array}\n */\nGlyph.prototype.getContours = function() {\n    if (this.points === undefined) {\n        return [];\n    }\n\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < this.points.length; i += 1) {\n        var pt = this.points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n};\n\n/**\n * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n * @return {Object}\n */\nGlyph.prototype.getMetrics = function() {\n    var commands = this.path.commands;\n    var xCoords = [];\n    var yCoords = [];\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type !== 'Z') {\n            xCoords.push(cmd.x);\n            yCoords.push(cmd.y);\n        }\n\n        if (cmd.type === 'Q' || cmd.type === 'C') {\n            xCoords.push(cmd.x1);\n            yCoords.push(cmd.y1);\n        }\n\n        if (cmd.type === 'C') {\n            xCoords.push(cmd.x2);\n            yCoords.push(cmd.y2);\n        }\n    }\n\n    var metrics = {\n        xMin: Math.min.apply(null, xCoords),\n        yMin: Math.min.apply(null, yCoords),\n        xMax: Math.max.apply(null, xCoords),\n        yMax: Math.max.apply(null, yCoords),\n        leftSideBearing: this.leftSideBearing\n    };\n\n    if (!isFinite(metrics.xMin)) {\n        metrics.xMin = 0;\n    }\n\n    if (!isFinite(metrics.xMax)) {\n        metrics.xMax = this.advanceWidth;\n    }\n\n    if (!isFinite(metrics.yMin)) {\n        metrics.yMin = 0;\n    }\n\n    if (!isFinite(metrics.yMax)) {\n        metrics.yMax = 0;\n    }\n\n    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n    return metrics;\n};\n\n/**\n * Draw the glyph on the given context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n */\nGlyph.prototype.draw = function(ctx, x, y, fontSize, options) {\n    this.getPath(x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of the glyph.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawPoints = function(ctx, x, y, fontSize) {\n    function drawCircles(l, x, y, scale) {\n        ctx.beginPath();\n        for (var j = 0; j < l.length; j += 1) {\n            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));\n            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, Math.PI * 2, false);\n        }\n\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    var scale = 1 / this.path.unitsPerEm * fontSize;\n\n    var blueCircles = [];\n    var redCircles = [];\n    var path = this.path;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var cmd = path.commands[i];\n        if (cmd.x !== undefined) {\n            blueCircles.push({x: cmd.x, y: -cmd.y});\n        }\n\n        if (cmd.x1 !== undefined) {\n            redCircles.push({x: cmd.x1, y: -cmd.y1});\n        }\n\n        if (cmd.x2 !== undefined) {\n            redCircles.push({x: cmd.x2, y: -cmd.y2});\n        }\n    }\n\n    ctx.fillStyle = 'blue';\n    drawCircles(blueCircles, x, y, scale);\n    ctx.fillStyle = 'red';\n    drawCircles(redCircles, x, y, scale);\n};\n\n/**\n * Draw lines indicating important font measurements.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {\n    var scale;\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    scale = 1 / this.path.unitsPerEm * fontSize;\n    ctx.lineWidth = 1;\n\n    // Draw the origin\n    ctx.strokeStyle = 'black';\n    draw.line(ctx, x, -10000, x, 10000);\n    draw.line(ctx, -10000, y, 10000, y);\n\n    // This code is here due to memory optimization: by not using\n    // defaults in the constructor, we save a notable amount of memory.\n    var xMin = this.xMin || 0;\n    var yMin = this.yMin || 0;\n    var xMax = this.xMax || 0;\n    var yMax = this.yMax || 0;\n    var advanceWidth = this.advanceWidth || 0;\n\n    // Draw the glyph box\n    ctx.strokeStyle = 'blue';\n    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);\n    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);\n    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));\n    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));\n\n    // Draw the advance width\n    ctx.strokeStyle = 'green';\n    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);\n};\n\n// The GlyphSet object\n\n// Define a property on the glyph that depends on the path being loaded.\nfunction defineDependentProperty(glyph, externalName, internalName) {\n    Object.defineProperty(glyph, externalName, {\n        get: function() {\n            // Request the path property to make sure the path is loaded.\n            glyph.path; // jshint ignore:line\n            return glyph[internalName];\n        },\n        set: function(newValue) {\n            glyph[internalName] = newValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\n\n/**\n * A GlyphSet represents all glyphs available in the font, but modelled using\n * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n * necessary, to keep the memory footprint down.\n * @exports opentype.GlyphSet\n * @class\n * @param {opentype.Font}\n * @param {Array}\n */\nfunction GlyphSet(font, glyphs) {\n    this.font = font;\n    this.glyphs = {};\n    if (Array.isArray(glyphs)) {\n        for (var i = 0; i < glyphs.length; i++) {\n            var glyph = glyphs[i];\n            glyph.path.unitsPerEm = font.unitsPerEm;\n            this.glyphs[i] = glyph;\n        }\n    }\n\n    this.length = (glyphs && glyphs.length) || 0;\n}\n\n/**\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nGlyphSet.prototype.get = function(index) {\n    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n    if (this.glyphs[index] === undefined) {\n        this.font._push(index);\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n\n        var glyph = this.glyphs[index];\n        var unicodeObj = this.font._IndexToUnicodeMap[index];\n\n        if (unicodeObj) {\n            for (var j = 0; j < unicodeObj.unicodes.length; j++)\n                { glyph.addUnicode(unicodeObj.unicodes[j]); }\n        }\n\n        if (this.font.cffEncoding) {\n            if (this.font.isCIDFont) {\n                glyph.name = 'gid' + index;\n            } else {\n                glyph.name = this.font.cffEncoding.charset[index];\n            }\n        } else if (this.font.glyphNames.names) {\n            glyph.name = this.font.glyphNames.glyphIndexToName(index);\n        }\n\n        this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;\n        this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;\n    } else {\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n    }\n\n    return this.glyphs[index];\n};\n\n/**\n * @param  {number} index\n * @param  {Object}\n */\nGlyphSet.prototype.push = function(index, loader) {\n    this.glyphs[index] = loader;\n    this.length++;\n};\n\n/**\n * @alias opentype.glyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nfunction glyphLoader(font, index) {\n    return new Glyph({index: index, font: font});\n}\n\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n * @alias opentype.ttfGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseGlyph\n * @param  {Object} data\n * @param  {number} position\n * @param  {Function} buildPath\n * @return {opentype.Glyph}\n */\nfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function() {\n        var glyph = new Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            parseGlyph(glyph, data, position);\n            var path = buildPath(font.glyphs, glyph);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        defineDependentProperty(glyph, 'xMin', '_xMin');\n        defineDependentProperty(glyph, 'xMax', '_xMax');\n        defineDependentProperty(glyph, 'yMin', '_yMin');\n        defineDependentProperty(glyph, 'yMax', '_yMax');\n\n        return glyph;\n    };\n}\n/**\n * @alias opentype.cffGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseCFFCharstring\n * @param  {string} charstring\n * @return {opentype.Glyph}\n */\nfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function() {\n        var glyph = new Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            var path = parseCFFCharstring(font, glyph, charstring);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        return glyph;\n    };\n}\n\nvar glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };\n\n// The `CFF` table contains the glyph outlines in PostScript format.\n\n// Custom equals function that can also check lists.\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n\n        for (var i = 0; i < a.length; i += 1) {\n            if (!equals(a[i], b[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    var bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n\n    return bias;\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    var offsets = [];\n    var objects = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n\n        objects.push(value);\n    }\n\n    return {objects: objects, startOffset: start, endOffset: endOffset};\n}\n\nfunction parseCFFIndexLowMemory(data, start) {\n    var offsets = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    return {offsets: offsets, startOffset: start, endOffset: endOffset};\n}\nfunction getCffIndexObject(i, offsets, data, start, conversionFn) {\n    var count = parse.getCard16(data, start);\n    var objectOffset = 0;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n    }\n\n    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n    if (conversionFn) {\n        value = conversionFn(value);\n    }\n    return value;\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    var s = '';\n    var eof = 15;\n    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n    while (true) {\n        var b = parser.parseByte();\n        var n1 = b >> 4;\n        var n2 = b & 15;\n\n        if (n1 === eof) {\n            break;\n        }\n\n        s += lookup[n1];\n\n        if (n2 === eof) {\n            break;\n        }\n\n        s += lookup[n2];\n    }\n\n    return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    var b1;\n    var b2;\n    var b3;\n    var b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return b1 << 8 | b2;\n    }\n\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n    }\n\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n\n    throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    var o = {};\n    for (var i = 0; i < entries.length; i += 1) {\n        var key = entries[i][0];\n        var values = entries[i][1];\n        var value = (void 0);\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n\n        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n            throw new Error('Object ' + o + ' already has key ' + key);\n        }\n\n        o[key] = value;\n    }\n\n    return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    var parser = new parse.Parser(data, start);\n    var entries = [];\n    var operands = [];\n    size = size !== undefined ? size : data.length;\n\n    while (parser.relativeOffset < size) {\n        var op = parser.parseByte();\n\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n\n            entries.push([op, operands]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n\n    return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n\n    return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    var newDict = {};\n    var value;\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (var i = 0; i < meta.length; i += 1) {\n        var m = meta[i];\n\n        if (Array.isArray(m.type)) {\n            var values = [];\n            values.length = m.type.length;\n            for (var j = 0; j < m.type.length; j++) {\n                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                if (value === undefined) {\n                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n                }\n                if (m.type[j] === 'SID') {\n                    value = getCFFString(strings, value);\n                }\n                values[j] = value;\n            }\n            newDict[m.name] = values;\n        } else {\n            value = dict[m.op];\n            if (value === undefined) {\n                value = m.value !== undefined ? m.value : null;\n            }\n\n            if (m.type === 'SID') {\n                value = getCFFString(strings, value);\n            }\n            newDict[m.name] = value;\n        }\n    }\n\n    return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    var header = {};\n    header.formatMajor = parse.getCard8(data, start);\n    header.formatMinor = parse.getCard8(data, start + 1);\n    header.size = parse.getCard8(data, start + 2);\n    header.offsetSize = parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\n\nvar TOP_DICT_META = [\n    {name: 'version', op: 0, type: 'SID'},\n    {name: 'notice', op: 1, type: 'SID'},\n    {name: 'copyright', op: 1200, type: 'SID'},\n    {name: 'fullName', op: 2, type: 'SID'},\n    {name: 'familyName', op: 3, type: 'SID'},\n    {name: 'weight', op: 4, type: 'SID'},\n    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},\n    {name: 'italicAngle', op: 1202, type: 'number', value: 0},\n    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},\n    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},\n    {name: 'paintType', op: 1205, type: 'number', value: 0},\n    {name: 'charstringType', op: 1206, type: 'number', value: 2},\n    {\n        name: 'fontMatrix',\n        op: 1207,\n        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n        value: [0.001, 0, 0, 0.001, 0, 0]\n    },\n    {name: 'uniqueId', op: 13, type: 'number'},\n    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},\n    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},\n    {name: 'xuid', op: 14, type: [], value: null},\n    {name: 'charset', op: 15, type: 'offset', value: 0},\n    {name: 'encoding', op: 16, type: 'offset', value: 0},\n    {name: 'charStrings', op: 17, type: 'offset', value: 0},\n    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},\n    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},\n    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},\n    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},\n    {name: 'cidFontType', op: 1233, type: 'number', value: 0},\n    {name: 'cidCount', op: 1234, type: 'number', value: 8720},\n    {name: 'uidBase', op: 1235, type: 'number'},\n    {name: 'fdArray', op: 1236, type: 'offset'},\n    {name: 'fdSelect', op: 1237, type: 'offset'},\n    {name: 'fontName', op: 1238, type: 'SID'}\n];\n\nvar PRIVATE_DICT_META = [\n    {name: 'subrs', op: 19, type: 'offset', value: 0},\n    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},\n    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}\n];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    var dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    var dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n    var topDictArray = [];\n    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n        var topDict = parseCFFTopDict(topDictData, strings);\n        topDict._subrs = [];\n        topDict._subrsBias = 0;\n        topDict._defaultWidthX = 0;\n        topDict._nominalWidthX = 0;\n        var privateSize = topDict.private[0];\n        var privateOffset = topDict.private[1];\n        if (privateSize !== 0 && privateOffset !== 0) {\n            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n            topDict._defaultWidthX = privateDict.defaultWidthX;\n            topDict._nominalWidthX = privateDict.nominalWidthX;\n            if (privateDict.subrs !== 0) {\n                var subrOffset = privateOffset + privateDict.subrs;\n                var subrIndex = parseCFFIndex(data, subrOffset + start);\n                topDict._subrs = subrIndex.objects;\n                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n            }\n            topDict._privateDict = privateDict;\n        }\n        topDictArray.push(topDict);\n    }\n    return topDictArray;\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    var sid;\n    var count;\n    var parser = new parse.Parser(data, start);\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    var charset = ['.notdef'];\n\n    var format = parser.parseCard8();\n    if (format === 0) {\n        for (var i = 0; i < nGlyphs; i += 1) {\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown charset format ' + format);\n    }\n\n    return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    var code;\n    var enc = {};\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        var nCodes = parser.parseCard8();\n        for (var i = 0; i < nCodes; i += 1) {\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        var nRanges = parser.parseCard8();\n        code = 1;\n        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n            var first = parser.parseCard8();\n            var nLeft = parser.parseCard8();\n            for (var j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown encoding format ' + format);\n    }\n\n    return new CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n    var c1x;\n    var c1y;\n    var c2x;\n    var c2y;\n    var p = new Path();\n    var stack = [];\n    var nStems = 0;\n    var haveWidth = false;\n    var open = false;\n    var x = 0;\n    var y = 0;\n    var subrs;\n    var subrsBias;\n    var defaultWidthX;\n    var nominalWidthX;\n    if (font.isCIDFont) {\n        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n        subrs = fdDict._subrs;\n        subrsBias = fdDict._subrsBias;\n        defaultWidthX = fdDict._defaultWidthX;\n        nominalWidthX = fdDict._nominalWidthX;\n    } else {\n        subrs = font.tables.cff.topDict._subrs;\n        subrsBias = font.tables.cff.topDict._subrsBias;\n        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n    }\n    var width = defaultWidthX;\n\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n\n        p.moveTo(x, y);\n        open = true;\n    }\n\n    function parseStems() {\n        var hasWidthArg;\n\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n        }\n\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n\n    function parse(code) {\n        var b1;\n        var b2;\n        var b3;\n        var b4;\n        var codeIndex;\n        var subrCode;\n        var jpx;\n        var jpy;\n        var c3x;\n        var c3y;\n        var c4x;\n        var c4y;\n\n        var i = 0;\n        while (i < code.length) {\n            var v = code[i];\n            i += 1;\n            switch (v) {\n                case 1: // hstem\n                    parseStems();\n                    break;\n                case 3: // vstem\n                    parseStems();\n                    break;\n                case 4: // vmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 5: // rlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 6: // hlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 7: // vlineto\n                    while (stack.length > 0) {\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 8: // rrcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 10: // callsubr\n                    codeIndex = stack.pop() + subrsBias;\n                    subrCode = subrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 11: // return\n                    return;\n                case 12: // flex operators\n                    v = code[i];\n                    i += 1;\n                    switch (v) {\n                        case 35: // flex\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x   + stack.shift();    // dx6\n                            y = c4y   + stack.shift();    // dy6\n                            stack.shift();                // flex depth\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 34: // hflex\n                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y;                      // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = y;                      // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 36: // hflex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 37: // flex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                x = c4x + stack.shift();\n                            } else {\n                                y = c4y + stack.shift();\n                            }\n\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        default:\n                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n                            stack.length = 0;\n                    }\n                    break;\n                case 14: // endchar\n                    if (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    if (open) {\n                        p.closePath();\n                        open = false;\n                    }\n\n                    break;\n                case 18: // hstemhm\n                    parseStems();\n                    break;\n                case 19: // hintmask\n                case 20: // cntrmask\n                    parseStems();\n                    i += (nStems + 7) >> 3;\n                    break;\n                case 21: // rmoveto\n                    if (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 22: // hmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 23: // vstemhm\n                    parseStems();\n                    break;\n                case 24: // rcurveline\n                    while (stack.length > 2) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    break;\n                case 25: // rlinecurve\n                    while (stack.length > 6) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    break;\n                case 26: // vvcurveto\n                    if (stack.length % 2) {\n                        x += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 27: // hhcurveto\n                    if (stack.length % 2) {\n                        y += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 28: // shortint\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                    i += 2;\n                    break;\n                case 29: // callgsubr\n                    codeIndex = stack.pop() + font.gsubrsBias;\n                    subrCode = font.gsubrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 30: // vhcurveto\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 31: // hvcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                default:\n                    if (v < 32) {\n                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n                    } else if (v < 247) {\n                        stack.push(v - 139);\n                    } else if (v < 251) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push((v - 247) * 256 + b1 + 108);\n                    } else if (v < 255) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push(-(v - 251) * 256 - b1 - 108);\n                    } else {\n                        b1 = code[i];\n                        b2 = code[i + 1];\n                        b3 = code[i + 2];\n                        b4 = code[i + 3];\n                        i += 4;\n                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);\n                    }\n            }\n        }\n    }\n\n    parse(code);\n\n    glyph.advanceWidth = width;\n    return p;\n}\n\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    var fdSelect = [];\n    var fdIndex;\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        // Simple list of nGlyphs elements\n        for (var iGid = 0; iGid < nGlyphs; iGid++) {\n            fdIndex = parser.parseCard8();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            fdSelect.push(fdIndex);\n        }\n    } else if (format === 3) {\n        // Ranges\n        var nRanges = parser.parseCard16();\n        var first = parser.parseCard16();\n        if (first !== 0) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n        }\n        var next;\n        for (var iRange = 0; iRange < nRanges; iRange++) {\n            fdIndex = parser.parseCard8();\n            next = parser.parseCard16();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            if (next > nGlyphs) {\n                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n            }\n            for (; first < next; first++) {\n                fdSelect.push(fdIndex);\n            }\n            first = next;\n        }\n        if (next !== nGlyphs) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n        }\n    } else {\n        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n    }\n    return fdSelect;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font, opt) {\n    font.tables.cff = {};\n    var header = parseCFFHeader(data, start);\n    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n    if (topDictArray.length !== 1) {\n        throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n    }\n\n    var topDict = topDictArray[0];\n    font.tables.cff.topDict = topDict;\n\n    if (topDict._privateDict) {\n        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n    }\n\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n        font.isCIDFont = true;\n    }\n\n    if (font.isCIDFont) {\n        var fdArrayOffset = topDict.fdArray;\n        var fdSelectOffset = topDict.fdSelect;\n        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n        }\n        fdArrayOffset += start;\n        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n        topDict._fdArray = fdArray;\n        fdSelectOffset += start;\n        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n    }\n\n    var privateDictOffset = start + topDict.private[1];\n    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n\n    if (privateDict.subrs !== 0) {\n        var subrOffset = privateDictOffset + privateDict.subrs;\n        var subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    var charStringsIndex;\n    if (opt.lowMemory) {\n        charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.offsets.length;\n    } else {\n        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.objects.length;\n    }\n\n    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n    if (topDict.encoding === 0) {\n        // Standard encoding\n        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) {\n        // Expert encoding\n        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n\n    font.glyphs = new glyphset.GlyphSet(font);\n    if (opt.lowMemory) {\n        font._push = function(i) {\n            var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        };\n    } else {\n        for (var i = 0; i < font.nGlyphs; i += 1) {\n            var charString = charStringsIndex.objects[i];\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        }\n    }\n}\n\n// Convert a string to a String ID (SID).\n// The list of strings is modified in place.\nfunction encodeString(s, strings) {\n    var sid;\n\n    // Is the string in the CFF standard strings?\n    var i = cffStandardStrings.indexOf(s);\n    if (i >= 0) {\n        sid = i;\n    }\n\n    // Is the string already in the string index?\n    i = strings.indexOf(s);\n    if (i >= 0) {\n        sid = i + cffStandardStrings.length;\n    } else {\n        sid = cffStandardStrings.length + strings.length;\n        strings.push(s);\n    }\n\n    return sid;\n}\n\nfunction makeHeader() {\n    return new table.Record('Header', [\n        {name: 'major', type: 'Card8', value: 1},\n        {name: 'minor', type: 'Card8', value: 0},\n        {name: 'hdrSize', type: 'Card8', value: 4},\n        {name: 'major', type: 'Card8', value: 1}\n    ]);\n}\n\nfunction makeNameIndex(fontNames) {\n    var t = new table.Record('Name INDEX', [\n        {name: 'names', type: 'INDEX', value: []}\n    ]);\n    t.names = [];\n    for (var i = 0; i < fontNames.length; i += 1) {\n        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});\n    }\n\n    return t;\n}\n\n// Given a dictionary's metadata, create a DICT structure.\nfunction makeDict(meta, attrs, strings) {\n    var m = {};\n    for (var i = 0; i < meta.length; i += 1) {\n        var entry = meta[i];\n        var value = attrs[entry.name];\n        if (value !== undefined && !equals(value, entry.value)) {\n            if (entry.type === 'SID') {\n                value = encodeString(value, strings);\n            }\n\n            m[entry.op] = {name: entry.name, type: entry.type, value: value};\n        }\n    }\n\n    return m;\n}\n\n// The Top DICT houses the global font attributes.\nfunction makeTopDict(attrs, strings) {\n    var t = new table.Record('Top DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(TOP_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeTopDictIndex(topDict) {\n    var t = new table.Record('Top DICT INDEX', [\n        {name: 'topDicts', type: 'INDEX', value: []}\n    ]);\n    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];\n    return t;\n}\n\nfunction makeStringIndex(strings) {\n    var t = new table.Record('String INDEX', [\n        {name: 'strings', type: 'INDEX', value: []}\n    ]);\n    t.strings = [];\n    for (var i = 0; i < strings.length; i += 1) {\n        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});\n    }\n\n    return t;\n}\n\nfunction makeGlobalSubrIndex() {\n    // Currently we don't use subroutines.\n    return new table.Record('Global Subr INDEX', [\n        {name: 'subrs', type: 'INDEX', value: []}\n    ]);\n}\n\nfunction makeCharsets(glyphNames, strings) {\n    var t = new table.Record('Charsets', [\n        {name: 'format', type: 'Card8', value: 0}\n    ]);\n    for (var i = 0; i < glyphNames.length; i += 1) {\n        var glyphName = glyphNames[i];\n        var glyphSID = encodeString(glyphName, strings);\n        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});\n    }\n\n    return t;\n}\n\nfunction glyphToOps(glyph) {\n    var ops = [];\n    var path = glyph.path;\n    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});\n    var x = 0;\n    var y = 0;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var dx = (void 0);\n        var dy = (void 0);\n        var cmd = path.commands[i];\n        if (cmd.type === 'Q') {\n            // CFF only supports bézier curves, so convert the quad to a bézier.\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n\n            // We're going to create a new command so we don't change the original path.\n            // Since all coordinates are relative, we round() them ASAP to avoid propagating errors.\n            cmd = {\n                type: 'C',\n                x: cmd.x,\n                y: cmd.y,\n                x1: Math.round(_13 * x + _23 * cmd.x1),\n                y1: Math.round(_13 * y + _23 * cmd.y1),\n                x2: Math.round(_13 * cmd.x + _23 * cmd.x1),\n                y2: Math.round(_13 * cmd.y + _23 * cmd.y1)\n            };\n        }\n\n        if (cmd.type === 'M') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rmoveto', type: 'OP', value: 21});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'L') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rlineto', type: 'OP', value: 5});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'C') {\n            var dx1 = Math.round(cmd.x1 - x);\n            var dy1 = Math.round(cmd.y1 - y);\n            var dx2 = Math.round(cmd.x2 - cmd.x1);\n            var dy2 = Math.round(cmd.y2 - cmd.y1);\n            dx = Math.round(cmd.x - cmd.x2);\n            dy = Math.round(cmd.y - cmd.y2);\n            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});\n            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});\n            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});\n            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rrcurveto', type: 'OP', value: 8});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        }\n\n        // Contours are closed automatically.\n    }\n\n    ops.push({name: 'endchar', type: 'OP', value: 14});\n    return ops;\n}\n\nfunction makeCharStringsIndex(glyphs) {\n    var t = new table.Record('CharStrings INDEX', [\n        {name: 'charStrings', type: 'INDEX', value: []}\n    ]);\n\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var ops = glyphToOps(glyph);\n        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});\n    }\n\n    return t;\n}\n\nfunction makePrivateDict(attrs, strings) {\n    var t = new table.Record('Private DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeCFFTable(glyphs, options) {\n    var t = new table.Table('CFF ', [\n        {name: 'header', type: 'RECORD'},\n        {name: 'nameIndex', type: 'RECORD'},\n        {name: 'topDictIndex', type: 'RECORD'},\n        {name: 'stringIndex', type: 'RECORD'},\n        {name: 'globalSubrIndex', type: 'RECORD'},\n        {name: 'charsets', type: 'RECORD'},\n        {name: 'charStringsIndex', type: 'RECORD'},\n        {name: 'privateDict', type: 'RECORD'}\n    ]);\n\n    var fontScale = 1 / options.unitsPerEm;\n    // We use non-zero values for the offsets so that the DICT encodes them.\n    // This is important because the size of the Top DICT plays a role in offset calculation,\n    // and the size shouldn't change after we've written correct offsets.\n    var attrs = {\n        version: options.version,\n        fullName: options.fullName,\n        familyName: options.familyName,\n        weight: options.weightName,\n        fontBBox: options.fontBBox || [0, 0, 0, 0],\n        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n        charset: 999,\n        encoding: 0,\n        charStrings: 999,\n        private: [0, 999]\n    };\n\n    var privateAttrs = {};\n\n    var glyphNames = [];\n    var glyph;\n\n    // Skip first glyph (.notdef)\n    for (var i = 1; i < glyphs.length; i += 1) {\n        glyph = glyphs.get(i);\n        glyphNames.push(glyph.name);\n    }\n\n    var strings = [];\n\n    t.header = makeHeader();\n    t.nameIndex = makeNameIndex([options.postScriptName]);\n    var topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n    t.globalSubrIndex = makeGlobalSubrIndex();\n    t.charsets = makeCharsets(glyphNames, strings);\n    t.charStringsIndex = makeCharStringsIndex(glyphs);\n    t.privateDict = makePrivateDict(privateAttrs, strings);\n\n    // Needs to come at the end, to encode all custom strings used in the font.\n    t.stringIndex = makeStringIndex(strings);\n\n    var startOffset = t.header.sizeOf() +\n        t.nameIndex.sizeOf() +\n        t.topDictIndex.sizeOf() +\n        t.stringIndex.sizeOf() +\n        t.globalSubrIndex.sizeOf();\n    attrs.charset = startOffset;\n\n    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n    attrs.encoding = 0;\n    attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n    // Recreate the Top DICT INDEX with the correct offsets.\n    topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n\n    return t;\n}\n\nvar cff = { parse: parseCFFTable, make: makeCFFTable };\n\n// The `head` table contains global information about the font.\n\n// Parse the header `head` table\nfunction parseHeadTable(data, start) {\n    var head = {};\n    var p = new parse.Parser(data, start);\n    head.version = p.parseVersion();\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n    head.checkSumAdjustment = p.parseULong();\n    head.magicNumber = p.parseULong();\n    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');\n    head.flags = p.parseUShort();\n    head.unitsPerEm = p.parseUShort();\n    head.created = p.parseLongDateTime();\n    head.modified = p.parseLongDateTime();\n    head.xMin = p.parseShort();\n    head.yMin = p.parseShort();\n    head.xMax = p.parseShort();\n    head.yMax = p.parseShort();\n    head.macStyle = p.parseUShort();\n    head.lowestRecPPEM = p.parseUShort();\n    head.fontDirectionHint = p.parseShort();\n    head.indexToLocFormat = p.parseShort();\n    head.glyphDataFormat = p.parseShort();\n    return head;\n}\n\nfunction makeHeadTable(options) {\n    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970\n    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;\n    var createdTimestamp = timestamp;\n\n    if (options.createdTimestamp) {\n        createdTimestamp = options.createdTimestamp + 2082844800;\n    }\n\n    return new table.Table('head', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},\n        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},\n        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},\n        {name: 'flags', type: 'USHORT', value: 0},\n        {name: 'unitsPerEm', type: 'USHORT', value: 1000},\n        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},\n        {name: 'modified', type: 'LONGDATETIME', value: timestamp},\n        {name: 'xMin', type: 'SHORT', value: 0},\n        {name: 'yMin', type: 'SHORT', value: 0},\n        {name: 'xMax', type: 'SHORT', value: 0},\n        {name: 'yMax', type: 'SHORT', value: 0},\n        {name: 'macStyle', type: 'USHORT', value: 0},\n        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},\n        {name: 'fontDirectionHint', type: 'SHORT', value: 2},\n        {name: 'indexToLocFormat', type: 'SHORT', value: 0},\n        {name: 'glyphDataFormat', type: 'SHORT', value: 0}\n    ], options);\n}\n\nvar head = { parse: parseHeadTable, make: makeHeadTable };\n\n// The `hhea` table contains information for horizontal layout.\n\n// Parse the horizontal header `hhea` table\nfunction parseHheaTable(data, start) {\n    var hhea = {};\n    var p = new parse.Parser(data, start);\n    hhea.version = p.parseVersion();\n    hhea.ascender = p.parseShort();\n    hhea.descender = p.parseShort();\n    hhea.lineGap = p.parseShort();\n    hhea.advanceWidthMax = p.parseUShort();\n    hhea.minLeftSideBearing = p.parseShort();\n    hhea.minRightSideBearing = p.parseShort();\n    hhea.xMaxExtent = p.parseShort();\n    hhea.caretSlopeRise = p.parseShort();\n    hhea.caretSlopeRun = p.parseShort();\n    hhea.caretOffset = p.parseShort();\n    p.relativeOffset += 8;\n    hhea.metricDataFormat = p.parseShort();\n    hhea.numberOfHMetrics = p.parseUShort();\n    return hhea;\n}\n\nfunction makeHheaTable(options) {\n    return new table.Table('hhea', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'ascender', type: 'FWORD', value: 0},\n        {name: 'descender', type: 'FWORD', value: 0},\n        {name: 'lineGap', type: 'FWORD', value: 0},\n        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},\n        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},\n        {name: 'minRightSideBearing', type: 'FWORD', value: 0},\n        {name: 'xMaxExtent', type: 'FWORD', value: 0},\n        {name: 'caretSlopeRise', type: 'SHORT', value: 1},\n        {name: 'caretSlopeRun', type: 'SHORT', value: 0},\n        {name: 'caretOffset', type: 'SHORT', value: 0},\n        {name: 'reserved1', type: 'SHORT', value: 0},\n        {name: 'reserved2', type: 'SHORT', value: 0},\n        {name: 'reserved3', type: 'SHORT', value: 0},\n        {name: 'reserved4', type: 'SHORT', value: 0},\n        {name: 'metricDataFormat', type: 'SHORT', value: 0},\n        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}\n    ], options);\n}\n\nvar hhea = { parse: parseHheaTable, make: makeHheaTable };\n\n// The `hmtx` table contains the horizontal metrics for all glyphs.\n\nfunction parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        var glyph = glyphs.get(i);\n        glyph.advanceWidth = advanceWidth;\n        glyph.leftSideBearing = leftSideBearing;\n    }\n}\n\nfunction parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n    font._hmtxTableData = {};\n\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        font._hmtxTableData[i] = {\n            advanceWidth: advanceWidth,\n            leftSideBearing: leftSideBearing\n        };\n    }\n}\n\n// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\nfunction parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n    if (opt.lowMemory)\n        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }\n    else\n        { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }\n}\n\nfunction makeHmtxTable(glyphs) {\n    var t = new table.Table('hmtx', []);\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var advanceWidth = glyph.advanceWidth || 0;\n        var leftSideBearing = glyph.leftSideBearing || 0;\n        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});\n        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});\n    }\n\n    return t;\n}\n\nvar hmtx = { parse: parseHmtxTable, make: makeHmtxTable };\n\n// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\nfunction makeLtagTable(tags) {\n    var result = new table.Table('ltag', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'numTags', type: 'ULONG', value: tags.length}\n    ]);\n\n    var stringPool = '';\n    var stringPoolOffset = 12 + tags.length * 4;\n    for (var i = 0; i < tags.length; ++i) {\n        var pos = stringPool.indexOf(tags[i]);\n        if (pos < 0) {\n            pos = stringPool.length;\n            stringPool += tags[i];\n        }\n\n        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n    return result;\n}\n\nfunction parseLtagTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n    // The 'ltag' specification does not define any flags; skip the field.\n    p.skip('uLong', 1);\n    var numTags = p.parseULong();\n\n    var tags = [];\n    for (var i = 0; i < numTags; i++) {\n        var tag = '';\n        var offset = start + p.parseUShort();\n        var length = p.parseUShort();\n        for (var j = offset; j < offset + length; ++j) {\n            tag += String.fromCharCode(data.getInt8(j));\n        }\n\n        tags.push(tag);\n    }\n\n    return tags;\n}\n\nvar ltag = { make: makeLtagTable, parse: parseLtagTable };\n\n// The `maxp` table establishes the memory requirements for the font.\n\n// Parse the maximum profile `maxp` table.\nfunction parseMaxpTable(data, start) {\n    var maxp = {};\n    var p = new parse.Parser(data, start);\n    maxp.version = p.parseVersion();\n    maxp.numGlyphs = p.parseUShort();\n    if (maxp.version === 1.0) {\n        maxp.maxPoints = p.parseUShort();\n        maxp.maxContours = p.parseUShort();\n        maxp.maxCompositePoints = p.parseUShort();\n        maxp.maxCompositeContours = p.parseUShort();\n        maxp.maxZones = p.parseUShort();\n        maxp.maxTwilightPoints = p.parseUShort();\n        maxp.maxStorage = p.parseUShort();\n        maxp.maxFunctionDefs = p.parseUShort();\n        maxp.maxInstructionDefs = p.parseUShort();\n        maxp.maxStackElements = p.parseUShort();\n        maxp.maxSizeOfInstructions = p.parseUShort();\n        maxp.maxComponentElements = p.parseUShort();\n        maxp.maxComponentDepth = p.parseUShort();\n    }\n\n    return maxp;\n}\n\nfunction makeMaxpTable(numGlyphs) {\n    return new table.Table('maxp', [\n        {name: 'version', type: 'FIXED', value: 0x00005000},\n        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}\n    ]);\n}\n\nvar maxp = { parse: parseMaxpTable, make: makeMaxpTable };\n\n// The `name` naming table.\n\n// NameIDs for the name table.\nvar nameTableNames = [\n    'copyright',              // 0\n    'fontFamily',             // 1\n    'fontSubfamily',          // 2\n    'uniqueID',               // 3\n    'fullName',               // 4\n    'version',                // 5\n    'postScriptName',         // 6\n    'trademark',              // 7\n    'manufacturer',           // 8\n    'designer',               // 9\n    'description',            // 10\n    'manufacturerURL',        // 11\n    'designerURL',            // 12\n    'license',                // 13\n    'licenseURL',             // 14\n    'reserved',               // 15\n    'preferredFamily',        // 16\n    'preferredSubfamily',     // 17\n    'compatibleFullName',     // 18\n    'sampleText',             // 19\n    'postScriptFindFontName', // 20\n    'wwsFamily',              // 21\n    'wwsSubfamily'            // 22\n];\n\nvar macLanguages = {\n    0: 'en',\n    1: 'fr',\n    2: 'de',\n    3: 'it',\n    4: 'nl',\n    5: 'sv',\n    6: 'es',\n    7: 'da',\n    8: 'pt',\n    9: 'no',\n    10: 'he',\n    11: 'ja',\n    12: 'ar',\n    13: 'fi',\n    14: 'el',\n    15: 'is',\n    16: 'mt',\n    17: 'tr',\n    18: 'hr',\n    19: 'zh-Hant',\n    20: 'ur',\n    21: 'hi',\n    22: 'th',\n    23: 'ko',\n    24: 'lt',\n    25: 'pl',\n    26: 'hu',\n    27: 'es',\n    28: 'lv',\n    29: 'se',\n    30: 'fo',\n    31: 'fa',\n    32: 'ru',\n    33: 'zh',\n    34: 'nl-BE',\n    35: 'ga',\n    36: 'sq',\n    37: 'ro',\n    38: 'cz',\n    39: 'sk',\n    40: 'si',\n    41: 'yi',\n    42: 'sr',\n    43: 'mk',\n    44: 'bg',\n    45: 'uk',\n    46: 'be',\n    47: 'uz',\n    48: 'kk',\n    49: 'az-Cyrl',\n    50: 'az-Arab',\n    51: 'hy',\n    52: 'ka',\n    53: 'mo',\n    54: 'ky',\n    55: 'tg',\n    56: 'tk',\n    57: 'mn-CN',\n    58: 'mn',\n    59: 'ps',\n    60: 'ks',\n    61: 'ku',\n    62: 'sd',\n    63: 'bo',\n    64: 'ne',\n    65: 'sa',\n    66: 'mr',\n    67: 'bn',\n    68: 'as',\n    69: 'gu',\n    70: 'pa',\n    71: 'or',\n    72: 'ml',\n    73: 'kn',\n    74: 'ta',\n    75: 'te',\n    76: 'si',\n    77: 'my',\n    78: 'km',\n    79: 'lo',\n    80: 'vi',\n    81: 'id',\n    82: 'tl',\n    83: 'ms',\n    84: 'ms-Arab',\n    85: 'am',\n    86: 'ti',\n    87: 'om',\n    88: 'so',\n    89: 'sw',\n    90: 'rw',\n    91: 'rn',\n    92: 'ny',\n    93: 'mg',\n    94: 'eo',\n    128: 'cy',\n    129: 'eu',\n    130: 'ca',\n    131: 'la',\n    132: 'qu',\n    133: 'gn',\n    134: 'ay',\n    135: 'tt',\n    136: 'ug',\n    137: 'dz',\n    138: 'jv',\n    139: 'su',\n    140: 'gl',\n    141: 'af',\n    142: 'br',\n    143: 'iu',\n    144: 'gd',\n    145: 'gv',\n    146: 'ga',\n    147: 'to',\n    148: 'el-polyton',\n    149: 'kl',\n    150: 'az',\n    151: 'nn'\n};\n\n// MacOS language ID → MacOS script ID\n//\n// Note that the script ID is not sufficient to determine what encoding\n// to use in TrueType files. For some languages, MacOS used a modification\n// of a mainstream script. For example, an Icelandic name would be stored\n// with smRoman in the TrueType naming table, but the actual encoding\n// is a special Icelandic version of the normal Macintosh Roman encoding.\n// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal\n// Syllables but MacOS had run out of available script codes, so this was\n// done as a (pretty radical) \"modification\" of Ethiopic.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nvar macLanguageToScript = {\n    0: 0,  // langEnglish → smRoman\n    1: 0,  // langFrench → smRoman\n    2: 0,  // langGerman → smRoman\n    3: 0,  // langItalian → smRoman\n    4: 0,  // langDutch → smRoman\n    5: 0,  // langSwedish → smRoman\n    6: 0,  // langSpanish → smRoman\n    7: 0,  // langDanish → smRoman\n    8: 0,  // langPortuguese → smRoman\n    9: 0,  // langNorwegian → smRoman\n    10: 5,  // langHebrew → smHebrew\n    11: 1,  // langJapanese → smJapanese\n    12: 4,  // langArabic → smArabic\n    13: 0,  // langFinnish → smRoman\n    14: 6,  // langGreek → smGreek\n    15: 0,  // langIcelandic → smRoman (modified)\n    16: 0,  // langMaltese → smRoman\n    17: 0,  // langTurkish → smRoman (modified)\n    18: 0,  // langCroatian → smRoman (modified)\n    19: 2,  // langTradChinese → smTradChinese\n    20: 4,  // langUrdu → smArabic\n    21: 9,  // langHindi → smDevanagari\n    22: 21,  // langThai → smThai\n    23: 3,  // langKorean → smKorean\n    24: 29,  // langLithuanian → smCentralEuroRoman\n    25: 29,  // langPolish → smCentralEuroRoman\n    26: 29,  // langHungarian → smCentralEuroRoman\n    27: 29,  // langEstonian → smCentralEuroRoman\n    28: 29,  // langLatvian → smCentralEuroRoman\n    29: 0,  // langSami → smRoman\n    30: 0,  // langFaroese → smRoman (modified)\n    31: 4,  // langFarsi → smArabic (modified)\n    32: 7,  // langRussian → smCyrillic\n    33: 25,  // langSimpChinese → smSimpChinese\n    34: 0,  // langFlemish → smRoman\n    35: 0,  // langIrishGaelic → smRoman (modified)\n    36: 0,  // langAlbanian → smRoman\n    37: 0,  // langRomanian → smRoman (modified)\n    38: 29,  // langCzech → smCentralEuroRoman\n    39: 29,  // langSlovak → smCentralEuroRoman\n    40: 0,  // langSlovenian → smRoman (modified)\n    41: 5,  // langYiddish → smHebrew\n    42: 7,  // langSerbian → smCyrillic\n    43: 7,  // langMacedonian → smCyrillic\n    44: 7,  // langBulgarian → smCyrillic\n    45: 7,  // langUkrainian → smCyrillic (modified)\n    46: 7,  // langByelorussian → smCyrillic\n    47: 7,  // langUzbek → smCyrillic\n    48: 7,  // langKazakh → smCyrillic\n    49: 7,  // langAzerbaijani → smCyrillic\n    50: 4,  // langAzerbaijanAr → smArabic\n    51: 24,  // langArmenian → smArmenian\n    52: 23,  // langGeorgian → smGeorgian\n    53: 7,  // langMoldavian → smCyrillic\n    54: 7,  // langKirghiz → smCyrillic\n    55: 7,  // langTajiki → smCyrillic\n    56: 7,  // langTurkmen → smCyrillic\n    57: 27,  // langMongolian → smMongolian\n    58: 7,  // langMongolianCyr → smCyrillic\n    59: 4,  // langPashto → smArabic\n    60: 4,  // langKurdish → smArabic\n    61: 4,  // langKashmiri → smArabic\n    62: 4,  // langSindhi → smArabic\n    63: 26,  // langTibetan → smTibetan\n    64: 9,  // langNepali → smDevanagari\n    65: 9,  // langSanskrit → smDevanagari\n    66: 9,  // langMarathi → smDevanagari\n    67: 13,  // langBengali → smBengali\n    68: 13,  // langAssamese → smBengali\n    69: 11,  // langGujarati → smGujarati\n    70: 10,  // langPunjabi → smGurmukhi\n    71: 12,  // langOriya → smOriya\n    72: 17,  // langMalayalam → smMalayalam\n    73: 16,  // langKannada → smKannada\n    74: 14,  // langTamil → smTamil\n    75: 15,  // langTelugu → smTelugu\n    76: 18,  // langSinhalese → smSinhalese\n    77: 19,  // langBurmese → smBurmese\n    78: 20,  // langKhmer → smKhmer\n    79: 22,  // langLao → smLao\n    80: 30,  // langVietnamese → smVietnamese\n    81: 0,  // langIndonesian → smRoman\n    82: 0,  // langTagalog → smRoman\n    83: 0,  // langMalayRoman → smRoman\n    84: 4,  // langMalayArabic → smArabic\n    85: 28,  // langAmharic → smEthiopic\n    86: 28,  // langTigrinya → smEthiopic\n    87: 28,  // langOromo → smEthiopic\n    88: 0,  // langSomali → smRoman\n    89: 0,  // langSwahili → smRoman\n    90: 0,  // langKinyarwanda → smRoman\n    91: 0,  // langRundi → smRoman\n    92: 0,  // langNyanja → smRoman\n    93: 0,  // langMalagasy → smRoman\n    94: 0,  // langEsperanto → smRoman\n    128: 0,  // langWelsh → smRoman (modified)\n    129: 0,  // langBasque → smRoman\n    130: 0,  // langCatalan → smRoman\n    131: 0,  // langLatin → smRoman\n    132: 0,  // langQuechua → smRoman\n    133: 0,  // langGuarani → smRoman\n    134: 0,  // langAymara → smRoman\n    135: 7,  // langTatar → smCyrillic\n    136: 4,  // langUighur → smArabic\n    137: 26,  // langDzongkha → smTibetan\n    138: 0,  // langJavaneseRom → smRoman\n    139: 0,  // langSundaneseRom → smRoman\n    140: 0,  // langGalician → smRoman\n    141: 0,  // langAfrikaans → smRoman\n    142: 0,  // langBreton → smRoman (modified)\n    143: 28,  // langInuktitut → smEthiopic (modified)\n    144: 0,  // langScottishGaelic → smRoman (modified)\n    145: 0,  // langManxGaelic → smRoman (modified)\n    146: 0,  // langIrishGaelicScript → smRoman (modified)\n    147: 0,  // langTongan → smRoman\n    148: 6,  // langGreekAncient → smRoman\n    149: 0,  // langGreenlandic → smRoman\n    150: 0,  // langAzerbaijanRoman → smRoman\n    151: 0   // langNynorsk → smRoman\n};\n\n// While Microsoft indicates a region/country for all its language\n// IDs, we omit the region code if it's equal to the \"most likely\n// region subtag\" according to Unicode CLDR. For scripts, we omit\n// the subtag if it is equal to the Suppress-Script entry in the\n// IANA language subtag registry for IETF BCP 47.\n//\n// For example, Microsoft states that its language code 0x041A is\n// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'\n// and not 'hr-HR' because Croatia is the default country for Croatian,\n// according to Unicode CLDR. As another example, Microsoft states\n// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform\n// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script\n// for the Croatian language, according to IANA.\n//\n// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html\n// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\nvar windowsLanguages = {\n    0x0436: 'af',\n    0x041C: 'sq',\n    0x0484: 'gsw',\n    0x045E: 'am',\n    0x1401: 'ar-DZ',\n    0x3C01: 'ar-BH',\n    0x0C01: 'ar',\n    0x0801: 'ar-IQ',\n    0x2C01: 'ar-JO',\n    0x3401: 'ar-KW',\n    0x3001: 'ar-LB',\n    0x1001: 'ar-LY',\n    0x1801: 'ary',\n    0x2001: 'ar-OM',\n    0x4001: 'ar-QA',\n    0x0401: 'ar-SA',\n    0x2801: 'ar-SY',\n    0x1C01: 'aeb',\n    0x3801: 'ar-AE',\n    0x2401: 'ar-YE',\n    0x042B: 'hy',\n    0x044D: 'as',\n    0x082C: 'az-Cyrl',\n    0x042C: 'az',\n    0x046D: 'ba',\n    0x042D: 'eu',\n    0x0423: 'be',\n    0x0845: 'bn',\n    0x0445: 'bn-IN',\n    0x201A: 'bs-Cyrl',\n    0x141A: 'bs',\n    0x047E: 'br',\n    0x0402: 'bg',\n    0x0403: 'ca',\n    0x0C04: 'zh-HK',\n    0x1404: 'zh-MO',\n    0x0804: 'zh',\n    0x1004: 'zh-SG',\n    0x0404: 'zh-TW',\n    0x0483: 'co',\n    0x041A: 'hr',\n    0x101A: 'hr-BA',\n    0x0405: 'cs',\n    0x0406: 'da',\n    0x048C: 'prs',\n    0x0465: 'dv',\n    0x0813: 'nl-BE',\n    0x0413: 'nl',\n    0x0C09: 'en-AU',\n    0x2809: 'en-BZ',\n    0x1009: 'en-CA',\n    0x2409: 'en-029',\n    0x4009: 'en-IN',\n    0x1809: 'en-IE',\n    0x2009: 'en-JM',\n    0x4409: 'en-MY',\n    0x1409: 'en-NZ',\n    0x3409: 'en-PH',\n    0x4809: 'en-SG',\n    0x1C09: 'en-ZA',\n    0x2C09: 'en-TT',\n    0x0809: 'en-GB',\n    0x0409: 'en',\n    0x3009: 'en-ZW',\n    0x0425: 'et',\n    0x0438: 'fo',\n    0x0464: 'fil',\n    0x040B: 'fi',\n    0x080C: 'fr-BE',\n    0x0C0C: 'fr-CA',\n    0x040C: 'fr',\n    0x140C: 'fr-LU',\n    0x180C: 'fr-MC',\n    0x100C: 'fr-CH',\n    0x0462: 'fy',\n    0x0456: 'gl',\n    0x0437: 'ka',\n    0x0C07: 'de-AT',\n    0x0407: 'de',\n    0x1407: 'de-LI',\n    0x1007: 'de-LU',\n    0x0807: 'de-CH',\n    0x0408: 'el',\n    0x046F: 'kl',\n    0x0447: 'gu',\n    0x0468: 'ha',\n    0x040D: 'he',\n    0x0439: 'hi',\n    0x040E: 'hu',\n    0x040F: 'is',\n    0x0470: 'ig',\n    0x0421: 'id',\n    0x045D: 'iu',\n    0x085D: 'iu-Latn',\n    0x083C: 'ga',\n    0x0434: 'xh',\n    0x0435: 'zu',\n    0x0410: 'it',\n    0x0810: 'it-CH',\n    0x0411: 'ja',\n    0x044B: 'kn',\n    0x043F: 'kk',\n    0x0453: 'km',\n    0x0486: 'quc',\n    0x0487: 'rw',\n    0x0441: 'sw',\n    0x0457: 'kok',\n    0x0412: 'ko',\n    0x0440: 'ky',\n    0x0454: 'lo',\n    0x0426: 'lv',\n    0x0427: 'lt',\n    0x082E: 'dsb',\n    0x046E: 'lb',\n    0x042F: 'mk',\n    0x083E: 'ms-BN',\n    0x043E: 'ms',\n    0x044C: 'ml',\n    0x043A: 'mt',\n    0x0481: 'mi',\n    0x047A: 'arn',\n    0x044E: 'mr',\n    0x047C: 'moh',\n    0x0450: 'mn',\n    0x0850: 'mn-CN',\n    0x0461: 'ne',\n    0x0414: 'nb',\n    0x0814: 'nn',\n    0x0482: 'oc',\n    0x0448: 'or',\n    0x0463: 'ps',\n    0x0415: 'pl',\n    0x0416: 'pt',\n    0x0816: 'pt-PT',\n    0x0446: 'pa',\n    0x046B: 'qu-BO',\n    0x086B: 'qu-EC',\n    0x0C6B: 'qu',\n    0x0418: 'ro',\n    0x0417: 'rm',\n    0x0419: 'ru',\n    0x243B: 'smn',\n    0x103B: 'smj-NO',\n    0x143B: 'smj',\n    0x0C3B: 'se-FI',\n    0x043B: 'se',\n    0x083B: 'se-SE',\n    0x203B: 'sms',\n    0x183B: 'sma-NO',\n    0x1C3B: 'sms',\n    0x044F: 'sa',\n    0x1C1A: 'sr-Cyrl-BA',\n    0x0C1A: 'sr',\n    0x181A: 'sr-Latn-BA',\n    0x081A: 'sr-Latn',\n    0x046C: 'nso',\n    0x0432: 'tn',\n    0x045B: 'si',\n    0x041B: 'sk',\n    0x0424: 'sl',\n    0x2C0A: 'es-AR',\n    0x400A: 'es-BO',\n    0x340A: 'es-CL',\n    0x240A: 'es-CO',\n    0x140A: 'es-CR',\n    0x1C0A: 'es-DO',\n    0x300A: 'es-EC',\n    0x440A: 'es-SV',\n    0x100A: 'es-GT',\n    0x480A: 'es-HN',\n    0x080A: 'es-MX',\n    0x4C0A: 'es-NI',\n    0x180A: 'es-PA',\n    0x3C0A: 'es-PY',\n    0x280A: 'es-PE',\n    0x500A: 'es-PR',\n\n    // Microsoft has defined two different language codes for\n    // “Spanish with modern sorting” and “Spanish with traditional\n    // sorting”. This makes sense for collation APIs, and it would be\n    // possible to express this in BCP 47 language tags via Unicode\n    // extensions (eg., es-u-co-trad is Spanish with traditional\n    // sorting). However, for storing names in fonts, the distinction\n    // does not make sense, so we give “es” in both cases.\n    0x0C0A: 'es',\n    0x040A: 'es',\n\n    0x540A: 'es-US',\n    0x380A: 'es-UY',\n    0x200A: 'es-VE',\n    0x081D: 'sv-FI',\n    0x041D: 'sv',\n    0x045A: 'syr',\n    0x0428: 'tg',\n    0x085F: 'tzm',\n    0x0449: 'ta',\n    0x0444: 'tt',\n    0x044A: 'te',\n    0x041E: 'th',\n    0x0451: 'bo',\n    0x041F: 'tr',\n    0x0442: 'tk',\n    0x0480: 'ug',\n    0x0422: 'uk',\n    0x042E: 'hsb',\n    0x0420: 'ur',\n    0x0843: 'uz-Cyrl',\n    0x0443: 'uz',\n    0x042A: 'vi',\n    0x0452: 'cy',\n    0x0488: 'wo',\n    0x0485: 'sah',\n    0x0478: 'ii',\n    0x046A: 'yo'\n};\n\n// Returns a IETF BCP 47 language code, for example 'zh-Hant'\n// for 'Chinese in the traditional script'.\nfunction getLanguageCode(platformID, languageID, ltag) {\n    switch (platformID) {\n        case 0:  // Unicode\n            if (languageID === 0xFFFF) {\n                return 'und';\n            } else if (ltag) {\n                return ltag[languageID];\n            }\n\n            break;\n\n        case 1:  // Macintosh\n            return macLanguages[languageID];\n\n        case 3:  // Windows\n            return windowsLanguages[languageID];\n    }\n\n    return undefined;\n}\n\nvar utf16 = 'utf-16';\n\n// MacOS script ID → encoding. This table stores the default case,\n// which can be overridden by macLanguageEncodings.\nvar macScriptEncodings = {\n    0: 'macintosh',           // smRoman\n    1: 'x-mac-japanese',      // smJapanese\n    2: 'x-mac-chinesetrad',   // smTradChinese\n    3: 'x-mac-korean',        // smKorean\n    6: 'x-mac-greek',         // smGreek\n    7: 'x-mac-cyrillic',      // smCyrillic\n    9: 'x-mac-devanagai',     // smDevanagari\n    10: 'x-mac-gurmukhi',     // smGurmukhi\n    11: 'x-mac-gujarati',     // smGujarati\n    12: 'x-mac-oriya',        // smOriya\n    13: 'x-mac-bengali',      // smBengali\n    14: 'x-mac-tamil',        // smTamil\n    15: 'x-mac-telugu',       // smTelugu\n    16: 'x-mac-kannada',      // smKannada\n    17: 'x-mac-malayalam',    // smMalayalam\n    18: 'x-mac-sinhalese',    // smSinhalese\n    19: 'x-mac-burmese',      // smBurmese\n    20: 'x-mac-khmer',        // smKhmer\n    21: 'x-mac-thai',         // smThai\n    22: 'x-mac-lao',          // smLao\n    23: 'x-mac-georgian',     // smGeorgian\n    24: 'x-mac-armenian',     // smArmenian\n    25: 'x-mac-chinesesimp',  // smSimpChinese\n    26: 'x-mac-tibetan',      // smTibetan\n    27: 'x-mac-mongolian',    // smMongolian\n    28: 'x-mac-ethiopic',     // smEthiopic\n    29: 'x-mac-ce',           // smCentralEuroRoman\n    30: 'x-mac-vietnamese',   // smVietnamese\n    31: 'x-mac-extarabic'     // smExtArabic\n};\n\n// MacOS language ID → encoding. This table stores the exceptional\n// cases, which override macScriptEncodings. For writing MacOS naming\n// tables, we need to emit a MacOS script ID. Therefore, we cannot\n// merge macScriptEncodings into macLanguageEncodings.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nvar macLanguageEncodings = {\n    15: 'x-mac-icelandic',    // langIcelandic\n    17: 'x-mac-turkish',      // langTurkish\n    18: 'x-mac-croatian',     // langCroatian\n    24: 'x-mac-ce',           // langLithuanian\n    25: 'x-mac-ce',           // langPolish\n    26: 'x-mac-ce',           // langHungarian\n    27: 'x-mac-ce',           // langEstonian\n    28: 'x-mac-ce',           // langLatvian\n    30: 'x-mac-icelandic',    // langFaroese\n    37: 'x-mac-romanian',     // langRomanian\n    38: 'x-mac-ce',           // langCzech\n    39: 'x-mac-ce',           // langSlovak\n    40: 'x-mac-ce',           // langSlovenian\n    143: 'x-mac-inuit',       // langInuktitut\n    146: 'x-mac-gaelic'       // langIrishGaelicScript\n};\n\nfunction getEncoding(platformID, encodingID, languageID) {\n    switch (platformID) {\n        case 0:  // Unicode\n            return utf16;\n\n        case 1:  // Apple Macintosh\n            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];\n\n        case 3:  // Microsoft Windows\n            if (encodingID === 1 || encodingID === 10) {\n                return utf16;\n            }\n\n            break;\n    }\n\n    return undefined;\n}\n\n// Parse the naming `name` table.\n// FIXME: Format 1 additional fields are not supported yet.\n// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].\nfunction parseNameTable(data, start, ltag) {\n    var name = {};\n    var p = new parse.Parser(data, start);\n    var format = p.parseUShort();\n    var count = p.parseUShort();\n    var stringOffset = p.offset + p.parseUShort();\n    for (var i = 0; i < count; i++) {\n        var platformID = p.parseUShort();\n        var encodingID = p.parseUShort();\n        var languageID = p.parseUShort();\n        var nameID = p.parseUShort();\n        var property = nameTableNames[nameID] || nameID;\n        var byteLength = p.parseUShort();\n        var offset = p.parseUShort();\n        var language = getLanguageCode(platformID, languageID, ltag);\n        var encoding = getEncoding(platformID, encodingID, languageID);\n        if (encoding !== undefined && language !== undefined) {\n            var text = (void 0);\n            if (encoding === utf16) {\n                text = decode.UTF16(data, stringOffset + offset, byteLength);\n            } else {\n                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);\n            }\n\n            if (text) {\n                var translations = name[property];\n                if (translations === undefined) {\n                    translations = name[property] = {};\n                }\n\n                translations[language] = text;\n            }\n        }\n    }\n\n    var langTagCount = 0;\n    if (format === 1) {\n        // FIXME: Also handle Microsoft's 'name' table 1.\n        langTagCount = p.parseUShort();\n    }\n\n    return name;\n}\n\n// {23: 'foo'} → {'foo': 23}\n// ['bar', 'baz'] → {'bar': 0, 'baz': 1}\nfunction reverseDict(dict) {\n    var result = {};\n    for (var key in dict) {\n        result[dict[key]] = parseInt(key);\n    }\n\n    return result;\n}\n\nfunction makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n    return new table.Record('NameRecord', [\n        {name: 'platformID', type: 'USHORT', value: platformID},\n        {name: 'encodingID', type: 'USHORT', value: encodingID},\n        {name: 'languageID', type: 'USHORT', value: languageID},\n        {name: 'nameID', type: 'USHORT', value: nameID},\n        {name: 'length', type: 'USHORT', value: length},\n        {name: 'offset', type: 'USHORT', value: offset}\n    ]);\n}\n\n// Finds the position of needle in haystack, or -1 if not there.\n// Like String.indexOf(), but for arrays.\nfunction findSubArray(needle, haystack) {\n    var needleLength = needle.length;\n    var limit = haystack.length - needleLength + 1;\n\n    loop:\n    for (var pos = 0; pos < limit; pos++) {\n        for (; pos < limit; pos++) {\n            for (var k = 0; k < needleLength; k++) {\n                if (haystack[pos + k] !== needle[k]) {\n                    continue loop;\n                }\n            }\n\n            return pos;\n        }\n    }\n\n    return -1;\n}\n\nfunction addStringToPool(s, pool) {\n    var offset = findSubArray(s, pool);\n    if (offset < 0) {\n        offset = pool.length;\n        var i = 0;\n        var len = s.length;\n        for (; i < len; ++i) {\n            pool.push(s[i]);\n        }\n\n    }\n\n    return offset;\n}\n\nfunction makeNameTable(names, ltag) {\n    var nameID;\n    var nameIDs = [];\n\n    var namesWithNumericKeys = {};\n    var nameTableIds = reverseDict(nameTableNames);\n    for (var key in names) {\n        var id = nameTableIds[key];\n        if (id === undefined) {\n            id = key;\n        }\n\n        nameID = parseInt(id);\n\n        if (isNaN(nameID)) {\n            throw new Error('Name table entry \"' + key + '\" does not exist, see nameTableNames for complete list.');\n        }\n\n        namesWithNumericKeys[nameID] = names[key];\n        nameIDs.push(nameID);\n    }\n\n    var macLanguageIds = reverseDict(macLanguages);\n    var windowsLanguageIds = reverseDict(windowsLanguages);\n\n    var nameRecords = [];\n    var stringPool = [];\n\n    for (var i = 0; i < nameIDs.length; i++) {\n        nameID = nameIDs[i];\n        var translations = namesWithNumericKeys[nameID];\n        for (var lang in translations) {\n            var text = translations[lang];\n\n            // For MacOS, we try to emit the name in the form that was introduced\n            // in the initial version of the TrueType spec (in the late 1980s).\n            // However, this can fail for various reasons: the requested BCP 47\n            // language code might not have an old-style Mac equivalent;\n            // we might not have a codec for the needed character encoding;\n            // or the name might contain characters that cannot be expressed\n            // in the old-style Macintosh encoding. In case of failure, we emit\n            // the name in a more modern fashion (Unicode encoding with BCP 47\n            // language tags) that is recognized by MacOS 10.5, released in 2009.\n            // If fonts were only read by operating systems, we could simply\n            // emit all names in the modern form; this would be much easier.\n            // However, there are many applications and libraries that read\n            // 'name' tables directly, and these will usually only recognize\n            // the ancient form (silently skipping the unrecognized names).\n            var macPlatform = 1;  // Macintosh\n            var macLanguage = macLanguageIds[lang];\n            var macScript = macLanguageToScript[macLanguage];\n            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);\n            var macName = encode.MACSTRING(text, macEncoding);\n            if (macName === undefined) {\n                macPlatform = 0;  // Unicode\n                macLanguage = ltag.indexOf(lang);\n                if (macLanguage < 0) {\n                    macLanguage = ltag.length;\n                    ltag.push(lang);\n                }\n\n                macScript = 4;  // Unicode 2.0 and later\n                macName = encode.UTF16(text);\n            }\n\n            var macNameOffset = addStringToPool(macName, stringPool);\n            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,\n                                            nameID, macName.length, macNameOffset));\n\n            var winLanguage = windowsLanguageIds[lang];\n            if (winLanguage !== undefined) {\n                var winName = encode.UTF16(text);\n                var winNameOffset = addStringToPool(winName, stringPool);\n                nameRecords.push(makeNameRecord(3, 1, winLanguage,\n                                                nameID, winName.length, winNameOffset));\n            }\n        }\n    }\n\n    nameRecords.sort(function(a, b) {\n        return ((a.platformID - b.platformID) ||\n                (a.encodingID - b.encodingID) ||\n                (a.languageID - b.languageID) ||\n                (a.nameID - b.nameID));\n    });\n\n    var t = new table.Table('name', [\n        {name: 'format', type: 'USHORT', value: 0},\n        {name: 'count', type: 'USHORT', value: nameRecords.length},\n        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}\n    ]);\n\n    for (var r = 0; r < nameRecords.length; r++) {\n        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});\n    }\n\n    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});\n    return t;\n}\n\nvar _name = { parse: parseNameTable, make: makeNameTable };\n\n// The `OS/2` table contains metrics required in OpenType fonts.\n\nvar unicodeRanges = [\n    {begin: 0x0000, end: 0x007F}, // Basic Latin\n    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement\n    {begin: 0x0100, end: 0x017F}, // Latin Extended-A\n    {begin: 0x0180, end: 0x024F}, // Latin Extended-B\n    {begin: 0x0250, end: 0x02AF}, // IPA Extensions\n    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters\n    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks\n    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic\n    {begin: 0x2C80, end: 0x2CFF}, // Coptic\n    {begin: 0x0400, end: 0x04FF}, // Cyrillic\n    {begin: 0x0530, end: 0x058F}, // Armenian\n    {begin: 0x0590, end: 0x05FF}, // Hebrew\n    {begin: 0xA500, end: 0xA63F}, // Vai\n    {begin: 0x0600, end: 0x06FF}, // Arabic\n    {begin: 0x07C0, end: 0x07FF}, // NKo\n    {begin: 0x0900, end: 0x097F}, // Devanagari\n    {begin: 0x0980, end: 0x09FF}, // Bengali\n    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi\n    {begin: 0x0A80, end: 0x0AFF}, // Gujarati\n    {begin: 0x0B00, end: 0x0B7F}, // Oriya\n    {begin: 0x0B80, end: 0x0BFF}, // Tamil\n    {begin: 0x0C00, end: 0x0C7F}, // Telugu\n    {begin: 0x0C80, end: 0x0CFF}, // Kannada\n    {begin: 0x0D00, end: 0x0D7F}, // Malayalam\n    {begin: 0x0E00, end: 0x0E7F}, // Thai\n    {begin: 0x0E80, end: 0x0EFF}, // Lao\n    {begin: 0x10A0, end: 0x10FF}, // Georgian\n    {begin: 0x1B00, end: 0x1B7F}, // Balinese\n    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo\n    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional\n    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended\n    {begin: 0x2000, end: 0x206F}, // General Punctuation\n    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts\n    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol\n    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols\n    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols\n    {begin: 0x2150, end: 0x218F}, // Number Forms\n    {begin: 0x2190, end: 0x21FF}, // Arrows\n    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators\n    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical\n    {begin: 0x2400, end: 0x243F}, // Control Pictures\n    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition\n    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics\n    {begin: 0x2500, end: 0x257F}, // Box Drawing\n    {begin: 0x2580, end: 0x259F}, // Block Elements\n    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes\n    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols\n    {begin: 0x2700, end: 0x27BF}, // Dingbats\n    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation\n    {begin: 0x3040, end: 0x309F}, // Hiragana\n    {begin: 0x30A0, end: 0x30FF}, // Katakana\n    {begin: 0x3100, end: 0x312F}, // Bopomofo\n    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo\n    {begin: 0xA840, end: 0xA87F}, // Phags-pa\n    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months\n    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility\n    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables\n    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *\n    {begin: 0x10900, end: 0x1091F}, // Phoenicia\n    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs\n    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)\n    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes\n    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms\n    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A\n    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks\n    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms\n    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants\n    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B\n    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms\n    {begin: 0xFFF0, end: 0xFFFF}, // Specials\n    {begin: 0x0F00, end: 0x0FFF}, // Tibetan\n    {begin: 0x0700, end: 0x074F}, // Syriac\n    {begin: 0x0780, end: 0x07BF}, // Thaana\n    {begin: 0x0D80, end: 0x0DFF}, // Sinhala\n    {begin: 0x1000, end: 0x109F}, // Myanmar\n    {begin: 0x1200, end: 0x137F}, // Ethiopic\n    {begin: 0x13A0, end: 0x13FF}, // Cherokee\n    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics\n    {begin: 0x1680, end: 0x169F}, // Ogham\n    {begin: 0x16A0, end: 0x16FF}, // Runic\n    {begin: 0x1780, end: 0x17FF}, // Khmer\n    {begin: 0x1800, end: 0x18AF}, // Mongolian\n    {begin: 0x2800, end: 0x28FF}, // Braille Patterns\n    {begin: 0xA000, end: 0xA48F}, // Yi Syllables\n    {begin: 0x1700, end: 0x171F}, // Tagalog\n    {begin: 0x10300, end: 0x1032F}, // Old Italic\n    {begin: 0x10330, end: 0x1034F}, // Gothic\n    {begin: 0x10400, end: 0x1044F}, // Deseret\n    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols\n    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols\n    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)\n    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors\n    {begin: 0xE0000, end: 0xE007F}, // Tags\n    {begin: 0x1900, end: 0x194F}, // Limbu\n    {begin: 0x1950, end: 0x197F}, // Tai Le\n    {begin: 0x1980, end: 0x19DF}, // New Tai Lue\n    {begin: 0x1A00, end: 0x1A1F}, // Buginese\n    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic\n    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh\n    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols\n    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri\n    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary\n    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers\n    {begin: 0x10380, end: 0x1039F}, // Ugaritic\n    {begin: 0x103A0, end: 0x103DF}, // Old Persian\n    {begin: 0x10450, end: 0x1047F}, // Shavian\n    {begin: 0x10480, end: 0x104AF}, // Osmanya\n    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary\n    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi\n    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols\n    {begin: 0x12000, end: 0x123FF}, // Cuneiform\n    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals\n    {begin: 0x1B80, end: 0x1BBF}, // Sundanese\n    {begin: 0x1C00, end: 0x1C4F}, // Lepcha\n    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki\n    {begin: 0xA880, end: 0xA8DF}, // Saurashtra\n    {begin: 0xA900, end: 0xA92F}, // Kayah Li\n    {begin: 0xA930, end: 0xA95F}, // Rejang\n    {begin: 0xAA00, end: 0xAA5F}, // Cham\n    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols\n    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc\n    {begin: 0x102A0, end: 0x102DF}, // Carian\n    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles\n];\n\nfunction getUnicodeRange(unicode) {\n    for (var i = 0; i < unicodeRanges.length; i += 1) {\n        var range = unicodeRanges[i];\n        if (unicode >= range.begin && unicode < range.end) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n// Parse the OS/2 and Windows metrics `OS/2` table\nfunction parseOS2Table(data, start) {\n    var os2 = {};\n    var p = new parse.Parser(data, start);\n    os2.version = p.parseUShort();\n    os2.xAvgCharWidth = p.parseShort();\n    os2.usWeightClass = p.parseUShort();\n    os2.usWidthClass = p.parseUShort();\n    os2.fsType = p.parseUShort();\n    os2.ySubscriptXSize = p.parseShort();\n    os2.ySubscriptYSize = p.parseShort();\n    os2.ySubscriptXOffset = p.parseShort();\n    os2.ySubscriptYOffset = p.parseShort();\n    os2.ySuperscriptXSize = p.parseShort();\n    os2.ySuperscriptYSize = p.parseShort();\n    os2.ySuperscriptXOffset = p.parseShort();\n    os2.ySuperscriptYOffset = p.parseShort();\n    os2.yStrikeoutSize = p.parseShort();\n    os2.yStrikeoutPosition = p.parseShort();\n    os2.sFamilyClass = p.parseShort();\n    os2.panose = [];\n    for (var i = 0; i < 10; i++) {\n        os2.panose[i] = p.parseByte();\n    }\n\n    os2.ulUnicodeRange1 = p.parseULong();\n    os2.ulUnicodeRange2 = p.parseULong();\n    os2.ulUnicodeRange3 = p.parseULong();\n    os2.ulUnicodeRange4 = p.parseULong();\n    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n    os2.fsSelection = p.parseUShort();\n    os2.usFirstCharIndex = p.parseUShort();\n    os2.usLastCharIndex = p.parseUShort();\n    os2.sTypoAscender = p.parseShort();\n    os2.sTypoDescender = p.parseShort();\n    os2.sTypoLineGap = p.parseShort();\n    os2.usWinAscent = p.parseUShort();\n    os2.usWinDescent = p.parseUShort();\n    if (os2.version >= 1) {\n        os2.ulCodePageRange1 = p.parseULong();\n        os2.ulCodePageRange2 = p.parseULong();\n    }\n\n    if (os2.version >= 2) {\n        os2.sxHeight = p.parseShort();\n        os2.sCapHeight = p.parseShort();\n        os2.usDefaultChar = p.parseUShort();\n        os2.usBreakChar = p.parseUShort();\n        os2.usMaxContent = p.parseUShort();\n    }\n\n    return os2;\n}\n\nfunction makeOS2Table(options) {\n    return new table.Table('OS/2', [\n        {name: 'version', type: 'USHORT', value: 0x0003},\n        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},\n        {name: 'usWeightClass', type: 'USHORT', value: 0},\n        {name: 'usWidthClass', type: 'USHORT', value: 0},\n        {name: 'fsType', type: 'USHORT', value: 0},\n        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},\n        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},\n        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},\n        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},\n        {name: 'sFamilyClass', type: 'SHORT', value: 0},\n        {name: 'bFamilyType', type: 'BYTE', value: 0},\n        {name: 'bSerifStyle', type: 'BYTE', value: 0},\n        {name: 'bWeight', type: 'BYTE', value: 0},\n        {name: 'bProportion', type: 'BYTE', value: 0},\n        {name: 'bContrast', type: 'BYTE', value: 0},\n        {name: 'bStrokeVariation', type: 'BYTE', value: 0},\n        {name: 'bArmStyle', type: 'BYTE', value: 0},\n        {name: 'bLetterform', type: 'BYTE', value: 0},\n        {name: 'bMidline', type: 'BYTE', value: 0},\n        {name: 'bXHeight', type: 'BYTE', value: 0},\n        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},\n        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},\n        {name: 'fsSelection', type: 'USHORT', value: 0},\n        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},\n        {name: 'usLastCharIndex', type: 'USHORT', value: 0},\n        {name: 'sTypoAscender', type: 'SHORT', value: 0},\n        {name: 'sTypoDescender', type: 'SHORT', value: 0},\n        {name: 'sTypoLineGap', type: 'SHORT', value: 0},\n        {name: 'usWinAscent', type: 'USHORT', value: 0},\n        {name: 'usWinDescent', type: 'USHORT', value: 0},\n        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},\n        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},\n        {name: 'sxHeight', type: 'SHORT', value: 0},\n        {name: 'sCapHeight', type: 'SHORT', value: 0},\n        {name: 'usDefaultChar', type: 'USHORT', value: 0},\n        {name: 'usBreakChar', type: 'USHORT', value: 0},\n        {name: 'usMaxContext', type: 'USHORT', value: 0}\n    ], options);\n}\n\nvar os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };\n\n// The `post` table stores additional PostScript information, such as glyph names.\n\n// Parse the PostScript `post` table\nfunction parsePostTable(data, start) {\n    var post = {};\n    var p = new parse.Parser(data, start);\n    post.version = p.parseVersion();\n    post.italicAngle = p.parseFixed();\n    post.underlinePosition = p.parseShort();\n    post.underlineThickness = p.parseShort();\n    post.isFixedPitch = p.parseULong();\n    post.minMemType42 = p.parseULong();\n    post.maxMemType42 = p.parseULong();\n    post.minMemType1 = p.parseULong();\n    post.maxMemType1 = p.parseULong();\n    switch (post.version) {\n        case 1:\n            post.names = standardNames.slice();\n            break;\n        case 2:\n            post.numberOfGlyphs = p.parseUShort();\n            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                post.glyphNameIndex[i] = p.parseUShort();\n            }\n\n            post.names = [];\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                if (post.glyphNameIndex[i$1] >= standardNames.length) {\n                    var nameLength = p.parseChar();\n                    post.names.push(p.parseString(nameLength));\n                }\n            }\n\n            break;\n        case 2.5:\n            post.numberOfGlyphs = p.parseUShort();\n            post.offset = new Array(post.numberOfGlyphs);\n            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {\n                post.offset[i$2] = p.parseChar();\n            }\n\n            break;\n    }\n    return post;\n}\n\nfunction makePostTable() {\n    return new table.Table('post', [\n        {name: 'version', type: 'FIXED', value: 0x00030000},\n        {name: 'italicAngle', type: 'FIXED', value: 0},\n        {name: 'underlinePosition', type: 'FWORD', value: 0},\n        {name: 'underlineThickness', type: 'FWORD', value: 0},\n        {name: 'isFixedPitch', type: 'ULONG', value: 0},\n        {name: 'minMemType42', type: 'ULONG', value: 0},\n        {name: 'maxMemType42', type: 'ULONG', value: 0},\n        {name: 'minMemType1', type: 'ULONG', value: 0},\n        {name: 'maxMemType1', type: 'ULONG', value: 0}\n    ]);\n}\n\nvar post = { parse: parsePostTable, make: makePostTable };\n\n// The `GSUB` table contains ligatures, among other things.\n\nvar subtableParsers = new Array(9);         // subtableParsers[0] is unused\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\nsubtableParsers[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            deltaGlyphId: this.parseUShort()\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            substitute: this.parseOffset16List()\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\nsubtableParsers[2] = function parseLookup2() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        sequences: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\nsubtableParsers[3] = function parseLookup3() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        alternateSets: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\nsubtableParsers[4] = function parseLookup4() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        ligatureSets: this.parseListOfLists(function() {\n            return {\n                ligGlyph: this.parseUShort(),\n                components: this.parseUShortList(this.parseUShort() - 1)\n            };\n        })\n    };\n};\n\nvar lookupRecordDesc = {\n    sequenceIndex: Parser.uShort,\n    lookupListIndex: Parser.uShort\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\nsubtableParsers[5] = function parseLookup5() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n\n    if (substFormat === 1) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            ruleSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    input: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            classDef: this.parsePointer(Parser.classDef),\n            classSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    classes: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        var glyphCount = this.parseUShort();\n        var substCount = this.parseUShort();\n        return {\n            substFormat: substFormat,\n            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\nsubtableParsers[6] = function parseLookup6() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            chainRuleSets: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            backtrackClassDef: this.parsePointer(Parser.classDef),\n            inputClassDef: this.parsePointer(Parser.classDef),\n            lookaheadClassDef: this.parsePointer(Parser.classDef),\n            chainClassSet: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        return {\n            substFormat: 3,\n            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\nsubtableParsers[7] = function parseLookup7() {\n    // Extension Substitution subtable\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');\n    var extensionLookupType = this.parseUShort();\n    var extensionParser = new Parser(this.data, this.offset + this.parseULong());\n    return {\n        substFormat: 1,\n        lookupType: extensionLookupType,\n        extension: subtableParsers[extensionLookupType].call(extensionParser)\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\nsubtableParsers[8] = function parseLookup8() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        substitutes: this.parseUShortList()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/gsub.htm\nfunction parseGsubTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n\n}\n\n// GSUB Writing //////////////////////////////////////////////\nvar subtableMakers = new Array(9);\n\nsubtableMakers[1] = function makeLookup1(subtable) {\n    if (subtable.substFormat === 1) {\n        return new table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 1},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},\n            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}\n        ]);\n    } else {\n        return new table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 2},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n        ].concat(table.ushortList('substitute', subtable.substitute)));\n    }\n};\n\nsubtableMakers[2] = function makeLookup2(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('seqSet', subtable.sequences, function(sequenceSet) {\n        return new table.Table('sequenceSetTable', table.ushortList('sequence', sequenceSet));\n    })));\n};\n\nsubtableMakers[3] = function makeLookup3(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {\n        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));\n    })));\n};\n\nsubtableMakers[4] = function makeLookup4(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {\n        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {\n            return new table.Table('ligatureTable',\n                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]\n                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))\n            );\n        }));\n    })));\n};\n\nsubtableMakers[6] = function makeLookup6(subtable) {\n    if (subtable.substFormat === 1) {\n        var returnTable = new table.Table('chainContextTable', [\n            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n        ].concat(table.tableList('chainRuleSet', subtable.chainRuleSets, function(chainRuleSet) {\n            return new table.Table('chainRuleSetTable', table.tableList('chainRule', chainRuleSet, function(chainRule) {\n                var tableData = table.ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)\n                    .concat(table.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))\n                    .concat(table.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))\n                    .concat(table.ushortList('substitution', [], chainRule.lookupRecords.length));\n\n                chainRule.lookupRecords.forEach(function (record, i) {\n                    tableData = tableData\n                        .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n                        .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n                });\n                return new table.Table('chainRuleTable', tableData);\n            }));\n        })));\n        return returnTable;\n    } else if (subtable.substFormat === 2) {\n        check.assert(false, 'lookup type 6 format 2 is not yet supported.');\n    } else if (subtable.substFormat === 3) {\n        var tableData = [\n            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat} ];\n\n        tableData.push({name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length});\n        subtable.backtrackCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'backtrackCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n        tableData.push({name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length});\n        subtable.inputCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'inputCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n        tableData.push({name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length});\n        subtable.lookaheadCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n\n        tableData.push({name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length});\n        subtable.lookupRecords.forEach(function (record, i) {\n            tableData = tableData\n                .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n                .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n        });\n\n        var returnTable$1 = new table.Table('chainContextTable', tableData);\n\n        return returnTable$1;\n    }\n\n    check.assert(false, 'lookup type 6 format must be 1, 2 or 3.');\n};\n\nfunction makeGsubTable(gsub) {\n    return new table.Table('GSUB', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},\n        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},\n        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}\n    ]);\n}\n\nvar gsub = { parse: parseGsubTable, make: makeGsubTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\n// Parse the metadata `meta` table.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\nfunction parseMetaTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported META table version.');\n    p.parseULong(); // flags - currently unused and set to 0\n    p.parseULong(); // tableOffset\n    var numDataMaps = p.parseULong();\n\n    var tags = {};\n    for (var i = 0; i < numDataMaps; i++) {\n        var tag = p.parseTag();\n        var dataOffset = p.parseULong();\n        var dataLength = p.parseULong();\n        var text = decode.UTF8(data, start + dataOffset, dataLength);\n\n        tags[tag] = text;\n    }\n    return tags;\n}\n\nfunction makeMetaTable(tags) {\n    var numTags = Object.keys(tags).length;\n    var stringPool = '';\n    var stringPoolOffset = 16 + numTags * 12;\n\n    var result = new table.Table('meta', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'offset', type: 'ULONG', value: stringPoolOffset},\n        {name: 'numTags', type: 'ULONG', value: numTags}\n    ]);\n\n    for (var tag in tags) {\n        var pos = stringPool.length;\n        stringPool += tags[tag];\n\n        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});\n        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n\n    return result;\n}\n\nvar meta = { parse: parseMetaTable, make: makeMetaTable };\n\n// The `sfnt` wrapper provides organization for the tables in the font.\n\nfunction log2(v) {\n    return Math.log(v) / Math.log(2) | 0;\n}\n\nfunction computeCheckSum(bytes) {\n    while (bytes.length % 4 !== 0) {\n        bytes.push(0);\n    }\n\n    var sum = 0;\n    for (var i = 0; i < bytes.length; i += 4) {\n        sum += (bytes[i] << 24) +\n            (bytes[i + 1] << 16) +\n            (bytes[i + 2] << 8) +\n            (bytes[i + 3]);\n    }\n\n    sum %= Math.pow(2, 32);\n    return sum;\n}\n\nfunction makeTableRecord(tag, checkSum, offset, length) {\n    return new table.Record('Table Record', [\n        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},\n        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},\n        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},\n        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}\n    ]);\n}\n\nfunction makeSfntTable(tables) {\n    var sfnt = new table.Table('sfnt', [\n        {name: 'version', type: 'TAG', value: 'OTTO'},\n        {name: 'numTables', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n    sfnt.tables = tables;\n    sfnt.numTables = tables.length;\n    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n    sfnt.searchRange = 16 * highestPowerOf2;\n    sfnt.entrySelector = log2(highestPowerOf2);\n    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n\n    var recordFields = [];\n    var tableFields = [];\n\n    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);\n    while (offset % 4 !== 0) {\n        offset += 1;\n        tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n    }\n\n    for (var i = 0; i < tables.length; i += 1) {\n        var t = tables[i];\n        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n        var tableLength = t.sizeOf();\n        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});\n        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});\n        offset += tableLength;\n        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n        while (offset % 4 !== 0) {\n            offset += 1;\n            tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n        }\n    }\n\n    // Table records need to be sorted alphabetically.\n    recordFields.sort(function(r1, r2) {\n        if (r1.value.tag > r2.value.tag) {\n            return 1;\n        } else {\n            return -1;\n        }\n    });\n\n    sfnt.fields = sfnt.fields.concat(recordFields);\n    sfnt.fields = sfnt.fields.concat(tableFields);\n    return sfnt;\n}\n\n// Get the metrics for a character. If the string has more than one character\n// this function returns metrics for the first available character.\n// You can provide optional fallback metrics if no characters are available.\nfunction metricsForChar(font, chars, notFoundMetrics) {\n    for (var i = 0; i < chars.length; i += 1) {\n        var glyphIndex = font.charToGlyphIndex(chars[i]);\n        if (glyphIndex > 0) {\n            var glyph = font.glyphs.get(glyphIndex);\n            return glyph.getMetrics();\n        }\n    }\n\n    return notFoundMetrics;\n}\n\nfunction average(vs) {\n    var sum = 0;\n    for (var i = 0; i < vs.length; i += 1) {\n        sum += vs[i];\n    }\n\n    return sum / vs.length;\n}\n\n// Convert the font object to a SFNT data structure.\n// This structure contains all the necessary tables and metadata to create a binary OTF file.\nfunction fontToSfntTable(font) {\n    var xMins = [];\n    var yMins = [];\n    var xMaxs = [];\n    var yMaxs = [];\n    var advanceWidths = [];\n    var leftSideBearings = [];\n    var rightSideBearings = [];\n    var firstCharIndex;\n    var lastCharIndex = 0;\n    var ulUnicodeRange1 = 0;\n    var ulUnicodeRange2 = 0;\n    var ulUnicodeRange3 = 0;\n    var ulUnicodeRange4 = 0;\n\n    for (var i = 0; i < font.glyphs.length; i += 1) {\n        var glyph = font.glyphs.get(i);\n        var unicode = glyph.unicode | 0;\n\n        if (isNaN(glyph.advanceWidth)) {\n            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');\n        }\n\n        if (firstCharIndex > unicode || firstCharIndex === undefined) {\n            // ignore .notdef char\n            if (unicode > 0) {\n                firstCharIndex = unicode;\n            }\n        }\n\n        if (lastCharIndex < unicode) {\n            lastCharIndex = unicode;\n        }\n\n        var position = os2.getUnicodeRange(unicode);\n        if (position < 32) {\n            ulUnicodeRange1 |= 1 << position;\n        } else if (position < 64) {\n            ulUnicodeRange2 |= 1 << position - 32;\n        } else if (position < 96) {\n            ulUnicodeRange3 |= 1 << position - 64;\n        } else if (position < 123) {\n            ulUnicodeRange4 |= 1 << position - 96;\n        } else {\n            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n        }\n        // Skip non-important characters.\n        if (glyph.name === '.notdef') { continue; }\n        var metrics = glyph.getMetrics();\n        xMins.push(metrics.xMin);\n        yMins.push(metrics.yMin);\n        xMaxs.push(metrics.xMax);\n        yMaxs.push(metrics.yMax);\n        leftSideBearings.push(metrics.leftSideBearing);\n        rightSideBearings.push(metrics.rightSideBearing);\n        advanceWidths.push(glyph.advanceWidth);\n    }\n\n    var globals = {\n        xMin: Math.min.apply(null, xMins),\n        yMin: Math.min.apply(null, yMins),\n        xMax: Math.max.apply(null, xMaxs),\n        yMax: Math.max.apply(null, yMaxs),\n        advanceWidthMax: Math.max.apply(null, advanceWidths),\n        advanceWidthAvg: average(advanceWidths),\n        minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n        minRightSideBearing: Math.min.apply(null, rightSideBearings)\n    };\n    globals.ascender = font.ascender;\n    globals.descender = font.descender;\n\n    var headTable = head.make({\n        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n        unitsPerEm: font.unitsPerEm,\n        xMin: globals.xMin,\n        yMin: globals.yMin,\n        xMax: globals.xMax,\n        yMax: globals.yMax,\n        lowestRecPPEM: 3,\n        createdTimestamp: font.createdTimestamp\n    });\n\n    var hheaTable = hhea.make({\n        ascender: globals.ascender,\n        descender: globals.descender,\n        advanceWidthMax: globals.advanceWidthMax,\n        minLeftSideBearing: globals.minLeftSideBearing,\n        minRightSideBearing: globals.minRightSideBearing,\n        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n        numberOfHMetrics: font.glyphs.length\n    });\n\n    var maxpTable = maxp.make(font.glyphs.length);\n\n    var os2Table = os2.make(Object.assign({\n        xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n        usFirstCharIndex: firstCharIndex,\n        usLastCharIndex: lastCharIndex,\n        ulUnicodeRange1: ulUnicodeRange1,\n        ulUnicodeRange2: ulUnicodeRange2,\n        ulUnicodeRange3: ulUnicodeRange3,\n        ulUnicodeRange4: ulUnicodeRange4,\n        // See http://typophile.com/node/13081 for more info on vertical metrics.\n        // We get metrics for typical characters (such as \"x\" for xHeight).\n        // We provide some fallback characters if characters are unavailable: their\n        // ordering was chosen experimentally.\n        sTypoAscender: globals.ascender,\n        sTypoDescender: globals.descender,\n        sTypoLineGap: 0,\n        usWinAscent: globals.yMax,\n        usWinDescent: Math.abs(globals.yMin),\n        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now\n        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,\n        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.\n        usBreakChar: font.hasChar(' ') ? 32 : 0, // Use space as the break character, if available.\n    }, font.tables.os2));\n\n    var hmtxTable = hmtx.make(font.glyphs);\n    var cmapTable = cmap.make(font.glyphs);\n\n    var englishFamilyName = font.getEnglishName('fontFamily');\n    var englishStyleName = font.getEnglishName('fontSubfamily');\n    var englishFullName = englishFamilyName + ' ' + englishStyleName;\n    var postScriptName = font.getEnglishName('postScriptName');\n    if (!postScriptName) {\n        postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName;\n    }\n\n    var names = {};\n    for (var n in font.names) {\n        names[n] = font.names[n];\n    }\n\n    if (!names.uniqueID) {\n        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};\n    }\n\n    if (!names.postScriptName) {\n        names.postScriptName = {en: postScriptName};\n    }\n\n    if (!names.preferredFamily) {\n        names.preferredFamily = font.names.fontFamily;\n    }\n\n    if (!names.preferredSubfamily) {\n        names.preferredSubfamily = font.names.fontSubfamily;\n    }\n\n    var languageTags = [];\n    var nameTable = _name.make(names, languageTags);\n    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);\n\n    var postTable = post.make();\n    var cffTable = cff.make(font.glyphs, {\n        version: font.getEnglishName('version'),\n        fullName: englishFullName,\n        familyName: englishFamilyName,\n        weightName: englishStyleName,\n        postScriptName: postScriptName,\n        unitsPerEm: font.unitsPerEm,\n        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]\n    });\n\n    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;\n\n    // The order does not matter because makeSfntTable() will sort them.\n    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n    if (ltagTable) {\n        tables.push(ltagTable);\n    }\n    // Optional tables\n    if (font.tables.gsub) {\n        tables.push(gsub.make(font.tables.gsub));\n    }\n    if (metaTable) {\n        tables.push(metaTable);\n    }\n\n    var sfntTable = makeSfntTable(tables);\n\n    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n    var bytes = sfntTable.encode();\n    var checkSum = computeCheckSum(bytes);\n    var tableFields = sfntTable.fields;\n    var checkSumAdjusted = false;\n    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {\n        if (tableFields[i$1].name === 'head table') {\n            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n            checkSumAdjusted = true;\n            break;\n        }\n    }\n\n    if (!checkSumAdjusted) {\n        throw new Error('Could not find head table with checkSum to adjust.');\n    }\n\n    return sfntTable;\n}\n\nvar sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };\n\n// The Layout object is the prototype of Substitution objects, and provides\n\nfunction searchTag(arr, tag) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid].tag;\n        if (val === tag) {\n            return imid;\n        } else if (val < tag) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\nfunction binSearch(arr, value) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid];\n        if (val === value) {\n            return imid;\n        } else if (val < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\n// binary search in a list of ranges (coverage, class definition)\nfunction searchRange(ranges, value) {\n    // jshint bitwise: false\n    var range;\n    var imin = 0;\n    var imax = ranges.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        range = ranges[imid];\n        var start = range.start;\n        if (start === value) {\n            return range;\n        } else if (start < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    if (imin > 0) {\n        range = ranges[imin - 1];\n        if (value > range.end) { return 0; }\n        return range;\n    }\n}\n\n/**\n * @exports opentype.Layout\n * @class\n */\nfunction Layout(font, tableName) {\n    this.font = font;\n    this.tableName = tableName;\n}\n\nLayout.prototype = {\n\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */\n    searchTag: searchTag,\n\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */\n    binSearch: binSearch,\n\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */\n    getTable: function(create) {\n        var layout = this.font.tables[this.tableName];\n        if (!layout && create) {\n            layout = this.font.tables[this.tableName] = this.createDefaultTable();\n        }\n        return layout;\n    },\n\n    /**\n     * Returns all scripts in the substitution table.\n     * @instance\n     * @return {Array}\n     */\n    getScriptNames: function() {\n        var layout = this.getTable();\n        if (!layout) { return []; }\n        return layout.scripts.map(function(script) {\n            return script.tag;\n        });\n    },\n\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */\n    getDefaultScriptName: function() {\n        var layout = this.getTable();\n        if (!layout) { return; }\n        var hasLatn = false;\n        for (var i = 0; i < layout.scripts.length; i++) {\n            var name = layout.scripts[i].tag;\n            if (name === 'DFLT') { return name; }\n            if (name === 'latn') { hasLatn = true; }\n        }\n        if (hasLatn) { return 'latn'; }\n    },\n\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */\n    getScriptTable: function(script, create) {\n        var layout = this.getTable(create);\n        if (layout) {\n            script = script || 'DFLT';\n            var scripts = layout.scripts;\n            var pos = searchTag(layout.scripts, script);\n            if (pos >= 0) {\n                return scripts[pos].script;\n            } else if (create) {\n                var scr = {\n                    tag: script,\n                    script: {\n                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},\n                        langSysRecords: []\n                    }\n                };\n                scripts.splice(-1 - pos, 0, scr);\n                return scr.script;\n            }\n        }\n    },\n\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */\n    getLangSysTable: function(script, language, create) {\n        var scriptTable = this.getScriptTable(script, create);\n        if (scriptTable) {\n            if (!language || language === 'dflt' || language === 'DFLT') {\n                return scriptTable.defaultLangSys;\n            }\n            var pos = searchTag(scriptTable.langSysRecords, language);\n            if (pos >= 0) {\n                return scriptTable.langSysRecords[pos].langSys;\n            } else if (create) {\n                var langSysRecord = {\n                    tag: language,\n                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}\n                };\n                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                return langSysRecord.langSys;\n            }\n        }\n    },\n\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */\n    getFeatureTable: function(script, language, feature, create) {\n        var langSysTable = this.getLangSysTable(script, language, create);\n        if (langSysTable) {\n            var featureRecord;\n            var featIndexes = langSysTable.featureIndexes;\n            var allFeatures = this.font.tables[this.tableName].features;\n            // The FeatureIndex array of indices is in arbitrary order,\n            // even if allFeatures is sorted alphabetically by feature tag.\n            for (var i = 0; i < featIndexes.length; i++) {\n                featureRecord = allFeatures[featIndexes[i]];\n                if (featureRecord.tag === feature) {\n                    return featureRecord.feature;\n                }\n            }\n            if (create) {\n                var index = allFeatures.length;\n                // Automatic ordering of features would require to shift feature indexes in the script list.\n                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n                featureRecord = {\n                    tag: feature,\n                    feature: { params: 0, lookupListIndexes: [] }\n                };\n                allFeatures.push(featureRecord);\n                featIndexes.push(index);\n                return featureRecord.feature;\n            }\n        }\n    },\n\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 9\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */\n    getLookupTables: function(script, language, feature, lookupType, create) {\n        var featureTable = this.getFeatureTable(script, language, feature, create);\n        var tables = [];\n        if (featureTable) {\n            var lookupTable;\n            var lookupListIndexes = featureTable.lookupListIndexes;\n            var allLookups = this.font.tables[this.tableName].lookups;\n            // lookupListIndexes are in no particular order, so use naive search.\n            for (var i = 0; i < lookupListIndexes.length; i++) {\n                lookupTable = allLookups[lookupListIndexes[i]];\n                if (lookupTable.lookupType === lookupType) {\n                    tables.push(lookupTable);\n                }\n            }\n            if (tables.length === 0 && create) {\n                lookupTable = {\n                    lookupType: lookupType,\n                    lookupFlag: 0,\n                    subtables: [],\n                    markFilteringSet: undefined\n                };\n                var index = allLookups.length;\n                allLookups.push(lookupTable);\n                lookupListIndexes.push(index);\n                return [lookupTable];\n            }\n        }\n        return tables;\n    },\n\n    /**\n     * Find a glyph in a class definition table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n     * @param {object} classDefTable - an OpenType Layout class definition table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getGlyphClass: function(classDefTable, glyphIndex) {\n        switch (classDefTable.format) {\n            case 1:\n                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {\n                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];\n                }\n                return 0;\n            case 2:\n                var range = searchRange(classDefTable.ranges, glyphIndex);\n                return range ? range.classId : 0;\n        }\n    },\n\n    /**\n     * Find a glyph in a coverage table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n     * @param {object} coverageTable - an OpenType Layout coverage table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getCoverageIndex: function(coverageTable, glyphIndex) {\n        switch (coverageTable.format) {\n            case 1:\n                var index = binSearch(coverageTable.glyphs, glyphIndex);\n                return index >= 0 ? index : -1;\n            case 2:\n                var range = searchRange(coverageTable.ranges, glyphIndex);\n                return range ? range.index + glyphIndex - range.start : -1;\n        }\n    },\n\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */\n    expandCoverage: function(coverageTable) {\n        if (coverageTable.format === 1) {\n            return coverageTable.glyphs;\n        } else {\n            var glyphs = [];\n            var ranges = coverageTable.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                var start = range.start;\n                var end = range.end;\n                for (var j = start; j <= end; j++) {\n                    glyphs.push(j);\n                }\n            }\n            return glyphs;\n        }\n    }\n\n};\n\n// The Position object provides utility methods to manipulate\n\n/**\n * @exports opentype.Position\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Position(font) {\n    Layout.call(this, font, 'gpos');\n}\n\nPosition.prototype = Layout.prototype;\n\n/**\n * Init some data for faster and easier access later.\n */\nPosition.prototype.init = function() {\n    var script = this.getDefaultScriptName();\n    this.defaultKerningTables = this.getKerningTables(script);\n};\n\n/**\n * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n *\n * @param {integer} leftIndex - left glyph index\n * @param {integer} rightIndex - right glyph index\n * @returns {integer}\n */\nPosition.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n    for (var i = 0; i < kerningLookups.length; i++) {\n        var subtables = kerningLookups[i].subtables;\n        for (var j = 0; j < subtables.length; j++) {\n            var subtable = subtables[j];\n            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);\n            if (covIndex < 0) { continue; }\n            switch (subtable.posFormat) {\n                case 1:\n                    // Search Pair Adjustment Positioning Format 1\n                    var pairSet = subtable.pairSets[covIndex];\n                    for (var k = 0; k < pairSet.length; k++) {\n                        var pair = pairSet[k];\n                        if (pair.secondGlyph === rightIndex) {\n                            return pair.value1 && pair.value1.xAdvance || 0;\n                        }\n                    }\n                    break;      // left glyph found, not right glyph - try next subtable\n                case 2:\n                    // Search Pair Adjustment Positioning Format 2\n                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);\n                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);\n                    var pair$1 = subtable.classRecords[class1][class2];\n                    return pair$1.value1 && pair$1.value1.xAdvance || 0;\n            }\n        }\n    }\n    return 0;\n};\n\n/**\n * List all kerning lookup tables.\n *\n * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n * @param {string} [language='dflt']\n * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n */\nPosition.prototype.getKerningTables = function(script, language) {\n    if (this.font.tables.gpos) {\n        return this.getLookupTables(script, language, 'kern', 2);\n    }\n};\n\n// The Substitution object provides utility methods to manipulate\n\n/**\n * @exports opentype.Substitution\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Substitution(font) {\n    Layout.call(this, font, 'gsub');\n}\n\n// Check if 2 arrays of primitives are equal.\nfunction arraysEqual(ar1, ar2) {\n    var n = ar1.length;\n    if (n !== ar2.length) { return false; }\n    for (var i = 0; i < n; i++) {\n        if (ar1[i] !== ar2[i]) { return false; }\n    }\n    return true;\n}\n\n// Find the first subtable of a lookup table in a particular format.\nfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n    var subtables = lookupTable.subtables;\n    for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i];\n        if (subtable.substFormat === format) {\n            return subtable;\n        }\n    }\n    if (defaultSubtable) {\n        subtables.push(defaultSubtable);\n        return defaultSubtable;\n    }\n    return undefined;\n}\n\nSubstitution.prototype = Layout.prototype;\n\n/**\n * Create a default GSUB table.\n * @return {Object} gsub - The GSUB table.\n */\nSubstitution.prototype.createDefaultTable = function() {\n    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n    return {\n        version: 1,\n        scripts: [{\n            tag: 'DFLT',\n            script: {\n                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n                langSysRecords: []\n            }\n        }],\n        features: [],\n        lookups: []\n    };\n};\n\n/**\n * List all single substitutions (lookup type 1) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getSingle = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 1);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n            if (subtable.substFormat === 1) {\n                var delta = subtable.deltaGlyphId;\n                for (j = 0; j < glyphs.length; j++) {\n                    var glyph = glyphs[j];\n                    substitutions.push({ sub: glyph, by: glyph + delta });\n                }\n            } else {\n                var substitute = subtable.substitute;\n                for (j = 0; j < glyphs.length; j++) {\n                    substitutions.push({ sub: glyphs[j], by: substitute[j] });\n                }\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getMultiple = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 2);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n\n            for (j = 0; j < glyphs.length; j++) {\n                var glyph = glyphs[j];\n                var replacements = subtable.sequences[j];\n                substitutions.push({ sub: glyph, by: replacements });\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all alternates (lookup type 3) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n * @return {Array} alternates - The list of alternates\n */\nSubstitution.prototype.getAlternates = function(feature, script, language) {\n    var alternates = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 3);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var alternateSets = subtable.alternateSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n            }\n        }\n    }\n    return alternates;\n};\n\n/**\n * List all ligatures (lookup type 4) for a given script, language, and feature.\n * The result is an array of ligature objects like { sub: [ids], by: id }\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} ligatures - The list of ligatures.\n */\nSubstitution.prototype.getLigatures = function(feature, script, language) {\n    var ligatures = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 4);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var ligatureSets = subtable.ligatureSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                var startGlyph = glyphs[j];\n                var ligSet = ligatureSets[j];\n                for (var k = 0; k < ligSet.length; k++) {\n                    var lig = ligSet[k];\n                    ligatures.push({\n                        sub: [startGlyph].concat(lig.components),\n                        by: lig.ligGlyph\n                    });\n                }\n            }\n        }\n    }\n    return ligatures;\n};\n\n/**\n * Add or modify a single substitution (lookup type 1)\n * Format 2, more flexible, is always used.\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addSingle = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];\n    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1\n        substFormat: 2,\n        coverage: {format: 1, glyphs: []},\n        substitute: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Single: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.substitute.splice(pos, 0, 0);\n    }\n    subtable.substitute[pos] = substitution.by;\n};\n\n/**\n * Add or modify a multiple substitution (lookup type 2)\n * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addMultiple = function(feature, substitution, script, language) {\n    check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: \"by\" must be an array of two or more ids');\n    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 2 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {format: 1, glyphs: []},\n        sequences: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Multiple: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.sequences.splice(pos, 0, 0);\n    }\n    subtable.sequences[pos] = substitution.by;\n};\n\n/**\n * Add or modify an alternate substitution (lookup type 3)\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: [ids] }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addAlternate = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {format: 1, glyphs: []},\n        alternateSets: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Alternate: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.alternateSets.splice(pos, 0, 0);\n    }\n    subtable.alternateSets[pos] = substitution.by;\n};\n\n/**\n * Add a ligature (lookup type 4)\n * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} ligature - { sub: [ids], by: id }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addLigature = function(feature, ligature, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];\n    var subtable = lookupTable.subtables[0];\n    if (!subtable) {\n        subtable = {                // lookup type 4 subtable, format 1, coverage format 1\n            substFormat: 1,\n            coverage: { format: 1, glyphs: [] },\n            ligatureSets: []\n        };\n        lookupTable.subtables[0] = subtable;\n    }\n    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = ligature.sub[0];\n    var ligComponents = ligature.sub.slice(1);\n    var ligatureTable = {\n        ligGlyph: ligature.by,\n        components: ligComponents\n    };\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos >= 0) {\n        // ligatureSet already exists\n        var ligatureSet = subtable.ligatureSets[pos];\n        for (var i = 0; i < ligatureSet.length; i++) {\n            // If ligature already exists, return.\n            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n                return;\n            }\n        }\n        // ligature does not exist: add it.\n        ligatureSet.push(ligatureTable);\n    } else {\n        // Create a new ligatureSet and add coverage for the first glyph.\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n    }\n};\n\n/**\n * List all feature data for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getFeature = function(feature, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.getSingle(feature, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            return this.getSingle(feature, script, language)\n                    .concat(this.getAlternates(feature, script, language));\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.getLigatures(feature, script, language);\n        case 'ccmp':\n            return this.getMultiple(feature, script, language)\n                .concat(this.getLigatures(feature, script, language));\n        case 'stch':\n            return this.getMultiple(feature, script, language);\n    }\n    return undefined;\n};\n\n/**\n * Add a substitution to a feature for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.add = function(feature, sub, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.addSingle(feature, sub, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            if (typeof sub.by === 'number') {\n                return this.addSingle(feature, sub, script, language);\n            }\n            return this.addAlternate(feature, sub, script, language);\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.addLigature(feature, sub, script, language);\n        case 'ccmp':\n            if (sub.by instanceof Array) {\n                return this.addMultiple(feature, sub, script, language);\n            }\n            return this.addLigature(feature, sub, script, language);\n    }\n    return undefined;\n};\n\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\n\nfunction nodeBufferToArrayBuffer(buffer) {\n    var ab = new ArrayBuffer(buffer.length);\n    var view = new Uint8Array(ab);\n    for (var i = 0; i < buffer.length; ++i) {\n        view[i] = buffer[i];\n    }\n\n    return ab;\n}\n\nfunction arrayBufferToNodeBuffer(ab) {\n    var buffer = new Buffer(ab.byteLength);\n    var view = new Uint8Array(ab);\n    for (var i = 0; i < buffer.length; ++i) {\n        buffer[i] = view[i];\n    }\n\n    return buffer;\n}\n\nfunction checkArgument(expression, message) {\n    if (!expression) {\n        throw message;\n    }\n}\n\n// The `glyf` table describes the glyphs in TrueType outline format.\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    var v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n\n    return v;\n}\n\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n    var p = new parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph._xMin = p.parseShort();\n    glyph._yMin = p.parseShort();\n    glyph._xMax = p.parseShort();\n    glyph._yMax = p.parseShort();\n    var flags;\n    var flag;\n\n    if (glyph.numberOfContours > 0) {\n        // This glyph is not a composite.\n        var endPointIndices = glyph.endPointIndices = [];\n        for (var i = 0; i < glyph.numberOfContours; i += 1) {\n            endPointIndices.push(p.parseUShort());\n        }\n\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n            glyph.instructions.push(p.parseByte());\n        }\n\n        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                var repeatCount = p.parseByte();\n                for (var j = 0; j < repeatCount; j += 1) {\n                    flags.push(flag);\n                    i$2 += 1;\n                }\n            }\n        }\n\n        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n        if (endPointIndices.length > 0) {\n            var points = [];\n            var point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n                    flag = flags[i$3];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n                    points.push(point);\n                }\n\n                var px = 0;\n                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n                    flag = flags[i$4];\n                    point = points[i$4];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n\n                var py = 0;\n                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n                    flag = flags[i$5];\n                    point = points[i$5];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        var moreComponents = true;\n        while (moreComponents) {\n            flags = p.parseUShort();\n            var component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseShort();\n                    component.dy = p.parseShort();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n                }\n\n            } else {\n                // The arguments are bytes\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseChar();\n                    component.dy = p.parseChar();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n                }\n            }\n\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n        if (flags & 0x100) {\n            // We have instructions\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n                glyph.instructions.push(p.parseByte());\n            }\n        }\n    }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    var newPoints = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        var newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n\n    return newPoints;\n}\n\nfunction getContours(points) {\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    var p = new Path();\n    if (!points) {\n        return p;\n    }\n\n    var contours = getContours(points);\n\n    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n        var contour = contours[contourIndex];\n\n        var prev = null;\n        var curr = contour[contour.length - 1];\n        var next = contour[0];\n\n        if (curr.onCurve) {\n            p.moveTo(curr.x, curr.y);\n        } else {\n            if (next.onCurve) {\n                p.moveTo(next.x, next.y);\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n                p.moveTo(start.x, start.y);\n            }\n        }\n\n        for (var i = 0; i < contour.length; ++i) {\n            prev = curr;\n            curr = next;\n            next = contour[(i + 1) % contour.length];\n\n            if (curr.onCurve) {\n                // This is a straight line.\n                p.lineTo(curr.x, curr.y);\n            } else {\n                var prev2 = prev;\n                var next2 = next;\n\n                if (!prev.onCurve) {\n                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n                }\n\n                if (!next.onCurve) {\n                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n                }\n\n                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n            }\n        }\n\n        p.closePath();\n    }\n    return p;\n}\n\nfunction buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for (var j = 0; j < glyph.components.length; j += 1) {\n            var component = glyph.components[j];\n            var componentGlyph = glyphs.get(component.glyphIndex);\n            // Force the ttfGlyphLoader to parse the glyph.\n            componentGlyph.getPath();\n            if (componentGlyph.points) {\n                var transformedPoints = (void 0);\n                if (component.matchedPoints === undefined) {\n                    // component positioned by offset\n                    transformedPoints = transformPoints(componentGlyph.points, component);\n                } else {\n                    // component positioned by matched points\n                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n                        throw Error('Matched points out of range in ' + glyph.name);\n                    }\n                    var firstPt = glyph.points[component.matchedPoints[0]];\n                    var secondPt = componentGlyph.points[component.matchedPoints[1]];\n                    var transform = {\n                        xScale: component.xScale, scale01: component.scale01,\n                        scale10: component.scale10, yScale: component.yScale,\n                        dx: 0, dy: 0\n                    };\n                    secondPt = transformPoints([secondPt], transform)[0];\n                    transform.dx = firstPt.x - secondPt.x;\n                    transform.dy = firstPt.y - secondPt.y;\n                    transformedPoints = transformPoints(componentGlyph.points, transform);\n                }\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n\n    return getPath(glyph.points);\n}\n\nfunction parseGlyfTableAll(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    // The last element of the loca table is invalid.\n    for (var i = 0; i < loca.length - 1; i += 1) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n\n    return glyphs;\n}\n\nfunction parseGlyfTableOnLowMemory(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    font._push = function(i) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    };\n\n    return glyphs;\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font, opt) {\n    if (opt.lowMemory)\n        { return parseGlyfTableOnLowMemory(data, start, loca, font); }\n    else\n        { return parseGlyfTableAll(data, start, loca, font); }\n}\n\nvar glyf = { getPath: getPath, parse: parseGlyfTable};\n\n/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n\nvar instructionTable;\nvar exec;\nvar execGlyph;\nvar execComponent;\n\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\nfunction Hinting(font) {\n    // the font this hinting object is for\n    this.font = font;\n\n    this.getCommands = function (hPoints) {\n        return glyf.getPath(hPoints).commands;\n    };\n\n    // cached states\n    this._fpgmState  =\n    this._prepState  =\n        undefined;\n\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0;\n}\n\n/*\n* Not rounding.\n*/\nfunction roundOff(v) {\n    return v;\n}\n\n/*\n* Rounding to grid.\n*/\nfunction roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v));\n}\n\n/*\n* Rounding to double grid.\n*/\nfunction roundToDoubleGrid(v) {\n    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n\n/*\n* Rounding to half grid.\n*/\nfunction roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n\n/*\n* Rounding to up to grid.\n*/\nfunction roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n\n/*\n* Rounding to down to grid.\n*/\nfunction roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v));\n}\n\n/*\n* Super rounding.\n*/\nvar roundSuper = function (v) {\n    var period = this.srPeriod;\n    var phase = this.srPhase;\n    var threshold = this.srThreshold;\n    var sign = 1;\n\n    if (v < 0) {\n        v = -v;\n        sign = -1;\n    }\n\n    v += threshold - phase;\n\n    v = Math.trunc(v / period) * period;\n\n    v += phase;\n\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (v < 0) { return phase * sign; }\n\n    return v * sign;\n};\n\n/*\n* Unit vector of x-axis.\n*/\nvar xUnitVector = {\n    x: 1,\n\n    y: 0,\n\n    axis: 'x',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.xo - rp1.xo;\n            do2 = p.xo - rp2.xo;\n            dm1 = rp1.x - rp1.xo;\n            dm2 = rp2.x - rp2.xo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.x = p.xo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.x = (org ? rp.xo : rp.x) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n    },\n\n    // Slope of vector line.\n    slope: 0,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.xTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.xTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.xTouched = false;\n    }\n};\n\n/*\n* Unit vector of y-axis.\n*/\nvar yUnitVector = {\n    x: 0,\n\n    y: 1,\n\n    axis: 'y',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.yo - rp1.yo;\n            do2 = p.yo - rp2.yo;\n            dm1 = rp1.y - rp1.yo;\n            dm2 = rp2.y - rp2.yo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.y = p.yo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this.\n    normalSlope: 0,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.y = (org ? rp.yo : rp.y) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n    },\n\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.yTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.yTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.yTouched = false;\n    }\n};\n\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\nfunction UnitVector(x, y) {\n    this.x = x;\n    this.y = y;\n    this.axis = undefined;\n    this.slope = y / x;\n    this.normalSlope = -x / y;\n    Object.freeze(this);\n}\n\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\nUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n    return (\n        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n        this.y * yUnitVector.distance(p1, p2, o1, o2)\n    );\n};\n\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\nUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n    var dm1;\n    var dm2;\n    var do1;\n    var do2;\n    var doa1;\n    var doa2;\n    var dt;\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n        return;\n    }\n\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\nUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n    pv = pv || this;\n\n    var rpx = org ? rp.xo : rp.x;\n    var rpy = org ? rp.yo : rp.y;\n    var rpdx = rpx + d * pv.x;\n    var rpdy = rpy + d * pv.y;\n\n    var pvns = pv.normalSlope;\n    var fvs = this.slope;\n\n    var px = p.x;\n    var py = p.y;\n\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n    p.y = fvs * (p.x - px) + py;\n};\n\n/*\n* Touches the point p.\n*/\nUnitVector.prototype.touch = function(p) {\n    p.xTouched = true;\n    p.yTouched = true;\n};\n\n/*\n* Returns a unit vector with x/y coordinates.\n*/\nfunction getUnitVector(x, y) {\n    var d = Math.sqrt(x * x + y * y);\n\n    x /= d;\n    y /= d;\n\n    if (x === 1 && y === 0) { return xUnitVector; }\n    else if (x === 0 && y === 1) { return yUnitVector; }\n    else { return new UnitVector(x, y); }\n}\n\n/*\n* Creates a point in the hinting engine.\n*/\nfunction HPoint(\n    x,\n    y,\n    lastPointOfContour,\n    onCurve\n) {\n    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n    this.lastPointOfContour = lastPointOfContour;\n    this.onCurve = onCurve;\n    this.prevPointOnContour = undefined;\n    this.nextPointOnContour = undefined;\n    this.xTouched = false;\n    this.yTouched = false;\n\n    Object.preventExtensions(this);\n}\n\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.nextTouched = function(v) {\n    var p = this.nextPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }\n\n    return p;\n};\n\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.prevTouched = function(v) {\n    var p = this.prevPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }\n\n    return p;\n};\n\n/*\n* The zero point.\n*/\nvar HPZero = Object.freeze(new HPoint(0, 0));\n\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\nvar defaultState = {\n    cvCutIn: 17 / 16,    // control value cut in\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1,             // loops some instructions\n    minDis: 1,           // minimum distance\n    autoFlip: true\n};\n\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\nfunction State(env, prog) {\n    this.env = env;\n    this.stack = [];\n    this.prog = prog;\n\n    switch (env) {\n        case 'glyf' :\n            this.zp0 = this.zp1 = this.zp2 = 1;\n            this.rp0 = this.rp1 = this.rp2 = 0;\n            /* fall through */\n        case 'prep' :\n            this.fv = this.pv = this.dpv = xUnitVector;\n            this.round = roundToGrid;\n    }\n}\n\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\nHinting.prototype.exec = function(glyph, ppem) {\n    if (typeof ppem !== 'number') {\n        throw new Error('Point size is not a number!');\n    }\n\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) { return; }\n\n    var font = this.font;\n    var prepState = this._prepState;\n\n    if (!prepState || prepState.ppem !== ppem) {\n        var fpgmState = this._fpgmState;\n\n        if (!fpgmState) {\n            // Executes the fpgm state.\n            // This is used by fonts to define functions.\n            State.prototype = defaultState;\n\n            fpgmState =\n            this._fpgmState =\n                new State('fpgm', font.tables.fpgm);\n\n            fpgmState.funcs = [ ];\n            fpgmState.font = font;\n\n            if (exports.DEBUG) {\n                console.log('---EXEC FPGM---');\n                fpgmState.step = -1;\n            }\n\n            try {\n                exec(fpgmState);\n            } catch (e) {\n                console.log('Hinting error in FPGM:' + e);\n                this._errorState = 3;\n                return;\n            }\n        }\n\n        // Executes the prep program for this ppem setting.\n        // This is used by fonts to set cvt values\n        // depending on to be rendered font size.\n\n        State.prototype = fpgmState;\n        prepState =\n        this._prepState =\n            new State('prep', font.tables.prep);\n\n        prepState.ppem = ppem;\n\n        // Creates a copy of the cvt table\n        // and scales it to the current ppem setting.\n        var oCvt = font.tables.cvt;\n        if (oCvt) {\n            var cvt = prepState.cvt = new Array(oCvt.length);\n            var scale = ppem / font.unitsPerEm;\n            for (var c = 0; c < oCvt.length; c++) {\n                cvt[c] = oCvt[c] * scale;\n            }\n        } else {\n            prepState.cvt = [];\n        }\n\n        if (exports.DEBUG) {\n            console.log('---EXEC PREP---');\n            prepState.step = -1;\n        }\n\n        try {\n            exec(prepState);\n        } catch (e) {\n            if (this._errorState < 2) {\n                console.log('Hinting error in PREP:' + e);\n            }\n            this._errorState = 2;\n        }\n    }\n\n    if (this._errorState > 1) { return; }\n\n    try {\n        return execGlyph(glyph, prepState);\n    } catch (e) {\n        if (this._errorState < 1) {\n            console.log('Hinting error:' + e);\n            console.log('Note: further hinting errors are silenced');\n        }\n        this._errorState = 1;\n        return undefined;\n    }\n};\n\n/*\n* Executes the hinting program for a glyph.\n*/\nexecGlyph = function(glyph, prepState) {\n    // original point positions\n    var xScale = prepState.ppem / prepState.font.unitsPerEm;\n    var yScale = xScale;\n    var components = glyph.components;\n    var contours;\n    var gZone;\n    var state;\n\n    State.prototype = prepState;\n    if (!components) {\n        state = new State('glyf', glyph.instructions);\n        if (exports.DEBUG) {\n            console.log('---EXEC GLYPH---');\n            state.step = -1;\n        }\n        execComponent(glyph, state, xScale, yScale);\n        gZone = state.gZone;\n    } else {\n        var font = prepState.font;\n        gZone = [];\n        contours = [];\n        for (var i = 0; i < components.length; i++) {\n            var c = components[i];\n            var cg = font.glyphs.get(c.glyphIndex);\n\n            state = new State('glyf', cg.instructions);\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMP ' + i + '---');\n                state.step = -1;\n            }\n\n            execComponent(cg, state, xScale, yScale);\n            // appends the computed points to the result array\n            // post processes the component points\n            var dx = Math.round(c.dx * xScale);\n            var dy = Math.round(c.dy * yScale);\n            var gz = state.gZone;\n            var cc = state.contours;\n            for (var pi = 0; pi < gz.length; pi++) {\n                var p = gz[pi];\n                p.xTouched = p.yTouched = false;\n                p.xo = p.x = p.x + dx;\n                p.yo = p.y = p.y + dy;\n            }\n\n            var gLen = gZone.length;\n            gZone.push.apply(gZone, gz);\n            for (var j = 0; j < cc.length; j++) {\n                contours.push(cc[j] + gLen);\n            }\n        }\n\n        if (glyph.instructions && !state.inhibitGridFit) {\n            // the composite has instructions on its own\n            state = new State('glyf', glyph.instructions);\n\n            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n            state.contours = contours;\n\n            // note: HPZero cannot be used here, since\n            //       the point might be modified\n            gZone.push(\n                new HPoint(0, 0),\n                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n            );\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMPOSITE---');\n                state.step = -1;\n            }\n\n            exec(state);\n\n            gZone.length -= 2;\n        }\n    }\n\n    return gZone;\n};\n\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself for a non-component glyph.\n*/\nexecComponent = function(glyph, state, xScale, yScale)\n{\n    var points = glyph.points || [];\n    var pLen = points.length;\n    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n    var contours = state.contours = [];\n\n    // Scales the original points and\n    // makes copies for the hinted points.\n    var cp; // current point\n    for (var i = 0; i < pLen; i++) {\n        cp = points[i];\n\n        gZone[i] = new HPoint(\n            cp.x * xScale,\n            cp.y * yScale,\n            cp.lastPointOfContour,\n            cp.onCurve\n        );\n    }\n\n    // Chain links the contours.\n    var sp; // start point\n    var np; // next point\n\n    for (var i$1 = 0; i$1 < pLen; i$1++) {\n        cp = gZone[i$1];\n\n        if (!sp) {\n            sp = cp;\n            contours.push(i$1);\n        }\n\n        if (cp.lastPointOfContour) {\n            cp.nextPointOnContour = sp;\n            sp.prevPointOnContour = cp;\n            sp = undefined;\n        } else {\n            np = gZone[i$1 + 1];\n            cp.nextPointOnContour = np;\n            np.prevPointOnContour = cp;\n        }\n    }\n\n    if (state.inhibitGridFit) { return; }\n\n    if (exports.DEBUG) {\n        console.log('PROCESSING GLYPH', state.stack);\n        for (var i$2 = 0; i$2 < pLen; i$2++) {\n            console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n        }\n    }\n\n    gZone.push(\n        new HPoint(0, 0),\n        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n    );\n\n    exec(state);\n\n    // Removes the extra points.\n    gZone.length -= 2;\n\n    if (exports.DEBUG) {\n        console.log('FINISHED GLYPH', state.stack);\n        for (var i$3 = 0; i$3 < pLen; i$3++) {\n            console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n        }\n    }\n};\n\n/*\n* Executes the program loaded in state.\n*/\nexec = function(state) {\n    var prog = state.prog;\n\n    if (!prog) { return; }\n\n    var pLen = prog.length;\n    var ins;\n\n    for (state.ip = 0; state.ip < pLen; state.ip++) {\n        if (exports.DEBUG) { state.step++; }\n        ins = instructionTable[prog[state.ip]];\n\n        if (!ins) {\n            throw new Error(\n                'unknown instruction: 0x' +\n                Number(prog[state.ip]).toString(16)\n            );\n        }\n\n        ins(state);\n\n        // very extensive debugging for each step\n        /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */\n    }\n};\n\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\nfunction initTZone(state)\n{\n    var tZone = state.tZone = new Array(state.gZone.length);\n\n    // no idea if this is actually correct...\n    for (var i = 0; i < tZone.length; i++)\n    {\n        tZone[i] = new HPoint(0, 0);\n    }\n}\n\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\nfunction skip(state, handleElse)\n{\n    var prog = state.prog;\n    var ip = state.ip;\n    var nesting = 1;\n    var ins;\n\n    do {\n        ins = prog[++ip];\n        if (ins === 0x58) // IF\n            { nesting++; }\n        else if (ins === 0x59) // EIF\n            { nesting--; }\n        else if (ins === 0x40) // NPUSHB\n            { ip += prog[ip + 1] + 1; }\n        else if (ins === 0x41) // NPUSHW\n            { ip += 2 * prog[ip + 1] + 1; }\n        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n            { ip += ins - 0xB0 + 1; }\n        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n            { ip += (ins - 0xB8 + 1) * 2; }\n        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n            { break; }\n    } while (nesting > 0);\n\n    state.ip = ip;\n}\n\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }\n\n    state.fv = state.pv = state.dpv = v;\n}\n\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }\n\n    state.pv = state.dpv = v;\n}\n\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }\n\n    state.fv = v;\n}\n\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.pv = state.dpv = getUnitVector(dx, dy);\n}\n\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.fv = getUnitVector(dx, dy);\n}\n\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.pv = state.dpv = getUnitVector(x, y);\n}\n\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.fv = getUnitVector(x, y);\n}\n\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n    var stack = state.stack;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }\n\n    stack.push(pv.x * 0x4000);\n    stack.push(pv.y * 0x4000);\n}\n\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n    var stack = state.stack;\n    var fv = state.fv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }\n\n    stack.push(fv.x * 0x4000);\n    stack.push(fv.y * 0x4000);\n}\n\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n    state.fv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }\n}\n\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state)\n{\n    var stack = state.stack;\n    var pa0i = stack.pop();\n    var pa1i = stack.pop();\n    var pb0i = stack.pop();\n    var pb1i = stack.pop();\n    var pi = stack.pop();\n    var z0 = state.z0;\n    var z1 = state.z1;\n    var pa0 = z0[pa0i];\n    var pa1 = z0[pa1i];\n    var pb0 = z1[pb0i];\n    var pb1 = z1[pb1i];\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }\n\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n    var x1 = pa0.x;\n    var y1 = pa0.y;\n    var x2 = pa1.x;\n    var y2 = pa1.y;\n    var x3 = pb0.x;\n    var y3 = pb0.y;\n    var x4 = pb1.x;\n    var y4 = pb1.y;\n\n    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    var f1 = x1 * y2 - y1 * x2;\n    var f2 = x3 * y4 - y3 * x4;\n\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n    state.rp0 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }\n}\n\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n    state.rp1 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }\n}\n\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n    state.rp2 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }\n}\n\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }\n\n    state.zp0 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }\n\n    state.zp1 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z1 = state.tZone;\n            break;\n        case 1 :\n            state.z1 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }\n\n    state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }\n\n    state.zp0 = state.zp1 = state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.z1 = state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.z1 = state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n    state.loop = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }\n}\n\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }\n\n    state.round = roundToGrid;\n}\n\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }\n\n    state.round = roundToHalfGrid;\n}\n\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n    var d = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }\n\n    state.minDis = d / 0x40;\n}\n\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n\n    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }\n\n    skip(state, false);\n}\n\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n    var o = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }\n\n    // A jump by 1 would do nothing.\n    state.ip += o - 1;\n}\n\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }\n\n    state.cvCutIn = n / 0x40;\n}\n\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }\n\n    stack.push(stack[stack.length - 1]);\n}\n\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }\n\n    state.stack.pop();\n}\n\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }\n\n    state.stack.length = 0;\n}\n\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n    var stack = state.stack;\n\n    var a = stack.pop();\n    var b = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }\n\n    stack.push(a);\n    stack.push(b);\n}\n\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }\n\n    stack.push(stack.length);\n}\n\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n    var stack = state.stack;\n    var fn = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    for (var i = 0; i < c; i++) {\n        exec(state);\n\n        if (exports.DEBUG) { console.log(\n            ++state.step,\n            i + 1 < c ? 'next loopcall' : 'done loopcall',\n            i\n        ); }\n    }\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n}\n\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n    var fn = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    exec(state);\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n\n    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }\n}\n\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }\n\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k]);\n}\n\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }\n\n    stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    var fn = stack.pop();\n    var ipBegin = ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }\n\n    while (prog[++ip] !== 0x2D){ }\n\n    state.ip = ip;\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n    var pi = state.stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) { d = state.round(d); }\n\n    fv.setRelative(p, HPZero, d, pv);\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n    var z2 = state.z2;\n    var pLen = z2.length - 2;\n    var cp;\n    var pp;\n    var np;\n\n    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }\n\n    for (var i = 0; i < pLen; i++) {\n        cp = z2[i]; // current point\n\n        // if this point has been touched go on\n        if (v.touched(cp)) { continue; }\n\n        pp = cp.prevTouched(v);\n\n        // no point on the contour has been touched?\n        if (pp === cp) { continue; }\n\n        np = cp.nextTouched(v);\n\n        if (pp === np) {\n            // only one point on the contour has been touched\n            // so simply moves the point like that\n\n            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n        }\n\n        v.interpolate(cp, pp, np, v);\n    }\n}\n\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var loop = state.loop;\n    var z2 = state.z2;\n\n    while (loop--)\n    {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        var d = pv.distance(rp, rp, false, true);\n        fv.setRelative(p, p, d, pv);\n        fv.touch(p);\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ?\n                   'loop ' + (state.loop - loop) + ': ' :\n                   ''\n                ) +\n                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n            );\n        }\n    }\n\n    state.loop = 1;\n}\n\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var ci = stack.pop();\n    var sp = state.z2[state.contours[ci]];\n    var p = sp;\n\n    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }\n\n    var d = pv.distance(rp, rp, false, true);\n\n    do {\n        if (p !== rp) { fv.setRelative(p, p, d, pv); }\n        p = p.nextPointOnContour;\n    } while (p !== sp);\n}\n\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }\n\n    var z;\n    switch (e) {\n        case 0 : z = state.tZone; break;\n        case 1 : z = state.gZone; break;\n        default : throw new Error('Invalid zone');\n    }\n\n    var p;\n    var d = pv.distance(rp, rp, false, true);\n    var pLen = z.length - 2;\n    for (var i = 0; i < pLen; i++)\n    {\n        p = z[i];\n        fv.setRelative(p, p, d, pv);\n        //if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n}\n\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n    var stack = state.stack;\n    var loop = state.loop;\n    var fv = state.fv;\n    var d = stack.pop() / 0x40;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'SHPIX[]', pi, d\n            );\n        }\n\n        fv.setRelative(p, p, d);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n    var stack = state.stack;\n    var rp1i = state.rp1;\n    var rp2i = state.rp2;\n    var loop = state.loop;\n    var rp1 = state.z0[rp1i];\n    var rp2 = state.z1[rp2i];\n    var fv = state.fv;\n    var pv = state.dpv;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'IP[]', pi, rp1i, '<->', rp2i\n            );\n        }\n\n        fv.interpolate(p, rp1, rp2, pv);\n\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n    var stack = state.stack;\n    var d = stack.pop() / 64;\n    var pi = stack.pop();\n    var p = state.z1[pi];\n    var rp0 = state.z0[state.rp0];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    fv.setRelative(p, rp0, d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (a) { state.rp0 = pi; }\n}\n\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n    var stack = state.stack;\n    var rp0i = state.rp0;\n    var rp0 = state.z0[rp0i];\n    var loop = state.loop;\n    var fv = state.fv;\n    var pv = state.pv;\n    var z1 = state.z1;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z1[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'ALIGNRP[]', pi\n            );\n        }\n\n        fv.setRelative(p, rp0, 0, pv);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }\n\n    state.round = roundToDoubleGrid;\n}\n\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var pi = stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var cv = state.cvt[n];\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            'MIAP[' + round + ']',\n            n, '(', cv, ')', pi\n        );\n    }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) {\n        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\n        d = state.round(d);\n    }\n\n    fv.setRelative(p, HPZero, d, pv);\n\n    if (state.zp0 === 0) {\n        p.xo = p.x;\n        p.yo = p.y;\n    }\n\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n    var prog = state.prog;\n    var ip = state.ip;\n    var stack = state.stack;\n\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    if (!store) { store = state.store = []; }\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }\n\n    store[l] = v;\n}\n\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RS', l); }\n\n    var v = (store && store[l]) || 0;\n\n    stack.push(v);\n}\n\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n    var stack = state.stack;\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }\n\n    state.cvt[l] = v / 0x40;\n}\n\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n    var stack = state.stack;\n    var cvte = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }\n\n    stack.push(state.cvt[cvte] * 0x40);\n}\n\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n    var stack = state.stack;\n    var pi = stack.pop();\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }\n\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n    var stack = state.stack;\n    var pi2 = stack.pop();\n    var pi1 = stack.pop();\n    var p2 = state.z1[pi2];\n    var p1 = state.z0[pi1];\n    var d = state.dpv.distance(p1, p2, a, a);\n\n    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }\n\n    state.stack.push(Math.round(d * 64));\n}\n\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }\n    state.stack.push(state.ppem);\n}\n\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }\n    state.autoFlip = true;\n}\n\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }\n\n    stack.push(e1 < e2 ? 1 : 0);\n}\n\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }\n\n    stack.push(e1 <= e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }\n\n    stack.push(e1 > e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }\n\n    stack.push(e1 >= e2 ? 1 : 0);\n}\n\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }\n\n    stack.push(e2 === e1 ? 1 : 0);\n}\n\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }\n\n    stack.push(e2 !== e1 ? 1 : 0);\n}\n\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n    var test = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }\n\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n        skip(state, true);\n\n        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }\n    }\n}\n\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n\n    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n}\n\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }\n\n    stack.push(e2 && e1 ? 1 : 0);\n}\n\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }\n\n    stack.push(e2 || e1 ? 1 : 0);\n}\n\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n    var stack = state.stack;\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }\n\n    stack.push(e ? 0 : 1);\n}\n\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var fv = state.fv;\n    var pv = state.pv;\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n    var z0 = state.z0;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var pi = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }\n\n        var p = z0[pi];\n        fv.setRelative(p, p, mag * ds, pv);\n    }\n}\n\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }\n\n    state.deltaBase = n;\n}\n\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }\n\n    state.deltaShift = Math.pow(0.5, n);\n}\n\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }\n\n    stack.push(n1 + n2);\n}\n\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }\n\n    stack.push(n1 - n2);\n}\n\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }\n\n    stack.push(n1 * 64 / n2);\n}\n\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }\n\n    stack.push(n1 * n2 / 64);\n}\n\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }\n\n    stack.push(Math.abs(n));\n}\n\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }\n\n    stack.push(-n);\n}\n\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }\n\n    stack.push(Math.floor(n / 0x40) * 0x40);\n}\n\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }\n\n    stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }\n\n    stack.push(state.round(n / 0x40) * 0x40);\n}\n\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n    var stack = state.stack;\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }\n\n    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var c = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n\n        var delta = mag * ds;\n\n        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }\n\n        state.cvt[c] += delta;\n    }\n}\n\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = 0.5;\n            break;\n        case 0x40:\n            period = 1;\n            break;\n        case 0x80:\n            period = 2;\n            break;\n        default:\n            throw new Error('invalid SROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default: throw new Error('invalid SROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = Math.sqrt(2) / 2;\n            break;\n        case 0x40:\n            period = Math.sqrt(2);\n            break;\n        case 0x80:\n            period = 2 * Math.sqrt(2);\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }\n\n    state.round = roundOff;\n}\n\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }\n\n    state.round = roundUpToGrid;\n}\n\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }\n\n    state.round = roundDownToGrid;\n}\n\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n    var n = state.stack.pop();\n\n    // ignored by opentype.js\n\n    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }\n}\n\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.dpv = getUnitVector(dx, dy);\n}\n\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n    var stack = state.stack;\n    var sel = stack.pop();\n    var r = 0;\n\n    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }\n\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) { r = 35; }\n\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n\n    // opentype.js is always gray scaling\n    if (sel & 0x20) { r |= 0x1000; }\n\n    stack.push(r);\n}\n\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n    var stack = state.stack;\n    var a = stack.pop();\n    var b = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }\n\n    stack.push(b);\n    stack.push(a);\n    stack.push(c);\n}\n\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }\n\n    stack.push(Math.max(e1, e2));\n}\n\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }\n\n    stack.push(Math.min(e1, e2));\n}\n\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n    var n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }\n}\n\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n    var s = state.stack.pop();\n    var v = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }\n\n    switch (s) {\n        case 1 : state.inhibitGridFit = !!v; return;\n        case 2 : state.ignoreCvt = !!v; return;\n        default: throw new Error('invalid INSTCTRL[] selector');\n    }\n}\n\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    var stack = state.stack;\n    var cvte = indirect && stack.pop();\n    var pi = stack.pop();\n    var rp0i = state.rp0;\n    var rp = state.z0[rp0i];\n    var p = state.z1[pi];\n\n    var md = state.minDis;\n    var fv = state.fv;\n    var pv = state.dpv;\n    var od; // original distance\n    var d; // moving distance\n    var sign; // sign of distance\n    var cv;\n\n    d = od = pv.distance(p, rp, true, true);\n    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n    // TODO consider autoFlip\n    d = Math.abs(d);\n\n    if (indirect) {\n        cv = state.cvt[cvte];\n\n        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n    }\n\n    if (keepD && d < md) { d = md; }\n\n    if (ro) { d = state.round(d); }\n\n    fv.setRelative(p, rp, sign * d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            (indirect ? 'MIRP[' : 'MDRP[') +\n            (setRp0 ? 'M' : 'm') +\n            (keepD ? '>' : '_') +\n            (ro ? 'R' : '_') +\n            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n            ']',\n            indirect ?\n                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n                '',\n            pi,\n            '(d =', od, '->', sign * d, ')'\n        );\n    }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (setRp0) { state.rp0 = pi; }\n}\n\n/*\n* The instruction table.\n*/\ninstructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined,   // TODO SSWCI\n    /* 0x1F */ undefined,   // TODO SSW\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined,   // TODO ALIGNPTS\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined,   // TODO UTP\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined,   // TODO SCFS\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined,   // TODO MPS\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined,   // TODO FLIPOFF\n    /* 0x4F */ undefined,   // TODO DEBUG\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined,   // TODO NROUND[ab]\n    /* 0x6D */ undefined,   // TODO NROUND[ab]\n    /* 0x6E */ undefined,   // TODO NROUND[ab]\n    /* 0x6F */ undefined,   // TODO NROUND[ab]\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined,   // TODO JROT[]\n    /* 0x79 */ undefined,   // TODO JROF[]\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n    /* 0x80 */ undefined,   // TODO FLIPPT\n    /* 0x81 */ undefined,   // TODO FLIPRGON\n    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined,   // TODO IDEF\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n];\n\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90°'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90° \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90°   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/\n\n/**\n * Converts a string into a list of tokens.\n */\n\n/**\n * Create a new token\n * @param {string} char a single char\n */\nfunction Token(char) {\n    this.char = char;\n    this.state = {};\n    this.activeState = null;\n}\n\n/**\n * Create a new context range\n * @param {number} startIndex range start index\n * @param {number} endOffset range end index offset\n * @param {string} contextName owner context name\n */\nfunction ContextRange(startIndex, endOffset, contextName) {\n    this.contextName = contextName;\n    this.startIndex = startIndex;\n    this.endOffset = endOffset;\n}\n\n/**\n * Check context start and end\n * @param {string} contextName a unique context name\n * @param {function} checkStart a predicate function the indicates a context's start\n * @param {function} checkEnd a predicate function the indicates a context's end\n */\nfunction ContextChecker(contextName, checkStart, checkEnd) {\n    this.contextName = contextName;\n    this.openRange = null;\n    this.ranges = [];\n    this.checkStart = checkStart;\n    this.checkEnd = checkEnd;\n}\n\n/**\n * @typedef ContextParams\n * @type Object\n * @property {array} context context items\n * @property {number} currentIndex current item index\n */\n\n/**\n * Create a context params\n * @param {array} context a list of items\n * @param {number} currentIndex current item index\n */\nfunction ContextParams(context, currentIndex) {\n    this.context = context;\n    this.index = currentIndex;\n    this.length = context.length;\n    this.current = context[currentIndex];\n    this.backtrack = context.slice(0, currentIndex);\n    this.lookahead = context.slice(currentIndex + 1);\n}\n\n/**\n * Create an event instance\n * @param {string} eventId event unique id\n */\nfunction Event(eventId) {\n    this.eventId = eventId;\n    this.subscribers = [];\n}\n\n/**\n * Initialize a core events and auto subscribe required event handlers\n * @param {any} events an object that enlists core events handlers\n */\nfunction initializeCoreEvents(events) {\n    var this$1 = this;\n\n    var coreEvents = [\n        'start', 'end', 'next', 'newToken', 'contextStart',\n        'contextEnd', 'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'\n    ];\n\n    coreEvents.forEach(function (eventId) {\n        Object.defineProperty(this$1.events, eventId, {\n            value: new Event(eventId)\n        });\n    });\n\n    if (!!events) {\n        coreEvents.forEach(function (eventId) {\n            var event = events[eventId];\n            if (typeof event === 'function') {\n                this$1.events[eventId].subscribe(event);\n            }\n        });\n    }\n    var requiresContextUpdate = [\n        'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD'\n    ];\n    requiresContextUpdate.forEach(function (eventId) {\n        this$1.events[eventId].subscribe(\n            this$1.updateContextsRanges\n        );\n    });\n}\n\n/**\n * Converts a string into a list of tokens\n * @param {any} events tokenizer core events\n */\nfunction Tokenizer(events) {\n    this.tokens = [];\n    this.registeredContexts = {};\n    this.contextCheckers = [];\n    this.events = {};\n    this.registeredModifiers = [];\n\n    initializeCoreEvents.call(this, events);\n}\n\n/**\n * Sets the state of a token, usually called by a state modifier.\n * @param {string} key state item key\n * @param {any} value state item value\n */\nToken.prototype.setState = function(key, value) {\n    this.state[key] = value;\n    this.activeState = { key: key, value: this.state[key] };\n    return this.activeState;\n};\n\nToken.prototype.getState = function (stateId) {\n    return this.state[stateId] || null;\n};\n\n/**\n * Checks if an index exists in the tokens list.\n * @param {number} index token index\n */\nTokenizer.prototype.inboundIndex = function(index) {\n    return index >= 0 && index < this.tokens.length;\n};\n\n/**\n * Compose and apply a list of operations (replace, update, delete)\n * @param {array} RUDs replace, update and delete operations\n * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n */\nTokenizer.prototype.composeRUD = function (RUDs) {\n    var this$1 = this;\n\n    var silent = true;\n    var state = RUDs.map(function (RUD) { return (\n        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))\n    ); });\n    var hasFAILObject = function (obj) { return (\n        typeof obj === 'object' &&\n        obj.hasOwnProperty('FAIL')\n    ); };\n    if (state.every(hasFAILObject)) {\n        return {\n            FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n            report: state.filter(hasFAILObject)\n        };\n    }\n    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);\n};\n\n/**\n * Replace a range of tokens with a list of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {token} tokens a list of tokens to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n    offset = offset !== null ? offset : this.tokens.length;\n    var isTokenType = tokens.every(function (token) { return token instanceof Token; });\n    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n        var replaced = this.tokens.splice.apply(\n            this.tokens, [startIndex, offset].concat(tokens)\n        );\n        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }\n        return [replaced, tokens];\n    } else {\n        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };\n    }\n};\n\n/**\n * Replace a token with another token\n * @param {number} index token index\n * @param {token} token a token to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceToken = function (index, token, silent) {\n    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n        var replaced = this.tokens.splice(index, 1, token);\n        if (!silent) { this.dispatch('replaceToken', [index, token]); }\n        return [replaced[0], token];\n    } else {\n        return { FAIL: 'replaceToken: invalid token or index.' };\n    }\n};\n\n/**\n * Removes a range of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeRange = function(startIndex, offset, silent) {\n    offset = !isNaN(offset) ? offset : this.tokens.length;\n    var tokens = this.tokens.splice(startIndex, offset);\n    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }\n    return tokens;\n};\n\n/**\n * Remove a token at a certain index\n * @param {number} index token index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeToken = function(index, silent) {\n    if (!isNaN(index) && this.inboundIndex(index)) {\n        var token = this.tokens.splice(index, 1);\n        if (!silent) { this.dispatch('removeToken', [token, index]); }\n        return token;\n    } else {\n        return { FAIL: 'removeToken: invalid token index.' };\n    }\n};\n\n/**\n * Insert a list of tokens at a certain index\n * @param {array} tokens a list of tokens to insert\n * @param {number} index insert the list of tokens at index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.insertToken = function (tokens, index, silent) {\n    var tokenType = tokens.every(\n        function (token) { return token instanceof Token; }\n    );\n    if (tokenType) {\n        this.tokens.splice.apply(\n            this.tokens, [index, 0].concat(tokens)\n        );\n        if (!silent) { this.dispatch('insertToken', [tokens, index]); }\n        return tokens;\n    } else {\n        return { FAIL: 'insertToken: invalid token(s).' };\n    }\n};\n\n/**\n * A state modifier that is called on 'newToken' event\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a function to update token state\n */\nTokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {\n    this.events.newToken.subscribe(function(token, contextParams) {\n        var conditionParams = [token, contextParams];\n        var canApplyModifier = (\n            condition === null ||\n            condition.apply(this, conditionParams) === true\n        );\n        var modifierParams = [token, contextParams];\n        if (canApplyModifier) {\n            var newStateValue = modifier.apply(this, modifierParams);\n            token.setState(modifierId, newStateValue);\n        }\n    });\n    this.registeredModifiers.push(modifierId);\n};\n\n/**\n * Subscribe a handler to an event\n * @param {function} eventHandler an event handler function\n */\nEvent.prototype.subscribe = function (eventHandler) {\n    if (typeof eventHandler === 'function') {\n        return ((this.subscribers.push(eventHandler)) - 1);\n    } else {\n        return { FAIL: (\"invalid '\" + (this.eventId) + \"' event handler\")};\n    }\n};\n\n/**\n * Unsubscribe an event handler\n * @param {string} subsId subscription id\n */\nEvent.prototype.unsubscribe = function (subsId) {\n    this.subscribers.splice(subsId, 1);\n};\n\n/**\n * Sets context params current value index\n * @param {number} index context params current value index\n */\nContextParams.prototype.setCurrentIndex = function(index) {\n    this.index = index;\n    this.current = this.context[index];\n    this.backtrack = this.context.slice(0, index);\n    this.lookahead = this.context.slice(index + 1);\n};\n\n/**\n * Get an item at an offset from the current value\n * example (current value is 3):\n *  1    2   [3]   4    5   |   items values\n * -2   -1    0    1    2   |   offset values\n * @param {number} offset an offset from current value index\n */\nContextParams.prototype.get = function (offset) {\n    switch (true) {\n        case (offset === 0):\n            return this.current;\n        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):\n            return this.backtrack.slice(offset)[0];\n        case (offset > 0 && offset <= this.lookahead.length):\n            return this.lookahead[offset - 1];\n        default:\n            return null;\n    }\n};\n\n/**\n * Converts a context range into a string value\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.rangeToText = function (range) {\n    if (range instanceof ContextRange) {\n        return (\n            this.getRangeTokens(range)\n                .map(function (token) { return token.char; }).join('')\n        );\n    }\n};\n\n/**\n * Converts all tokens into a string\n */\nTokenizer.prototype.getText = function () {\n    return this.tokens.map(function (token) { return token.char; }).join('');\n};\n\n/**\n * Get a context by name\n * @param {string} contextName context name to get\n */\nTokenizer.prototype.getContext = function (contextName) {\n    var context = this.registeredContexts[contextName];\n    return !!context ? context : null;\n};\n\n/**\n * Subscribes a new event handler to an event\n * @param {string} eventName event name to subscribe to\n * @param {function} eventHandler a function to be invoked on event\n */\nTokenizer.prototype.on = function(eventName, eventHandler) {\n    var event = this.events[eventName];\n    if (!!event) {\n        return event.subscribe(eventHandler);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Dispatches an event\n * @param {string} eventName event name\n * @param {any} args event handler arguments\n */\nTokenizer.prototype.dispatch = function(eventName, args) {\n    var this$1 = this;\n\n    var event = this.events[eventName];\n    if (event instanceof Event) {\n        event.subscribers.forEach(function (subscriber) {\n            subscriber.apply(this$1, args || []);\n        });\n    }\n};\n\n/**\n * Register a new context checker\n * @param {string} contextName a unique context name\n * @param {function} contextStartCheck a predicate function that returns true on context start\n * @param {function} contextEndCheck  a predicate function that returns true on context end\n * TODO: call tokenize on registration to update context ranges with the new context.\n */\nTokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {\n    if (!!this.getContext(contextName)) { return {\n        FAIL:\n        (\"context name '\" + contextName + \"' is already registered.\")\n    }; }\n    if (typeof contextStartCheck !== 'function') { return {\n        FAIL:\n        \"missing context start check.\"\n    }; }\n    if (typeof contextEndCheck !== 'function') { return {\n        FAIL:\n        \"missing context end check.\"\n    }; }\n    var contextCheckers = new ContextChecker(\n        contextName, contextStartCheck, contextEndCheck\n    );\n    this.registeredContexts[contextName] = contextCheckers;\n    this.contextCheckers.push(contextCheckers);\n    return contextCheckers;\n};\n\n/**\n * Gets a context range tokens\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.getRangeTokens = function(range) {\n    var endIndex = range.startIndex + range.endOffset;\n    return [].concat(\n        this.tokens\n            .slice(range.startIndex, endIndex)\n    );\n};\n\n/**\n * Gets the ranges of a context\n * @param {string} contextName context name\n */\nTokenizer.prototype.getContextRanges = function(contextName) {\n    var context = this.getContext(contextName);\n    if (!!context) {\n        return context.ranges;\n    } else {\n        return { FAIL: (\"context checker '\" + contextName + \"' is not registered.\") };\n    }\n};\n\n/**\n * Resets context ranges to run context update\n */\nTokenizer.prototype.resetContextsRanges = function () {\n    var registeredContexts = this.registeredContexts;\n    for (var contextName in registeredContexts) {\n        if (registeredContexts.hasOwnProperty(contextName)) {\n            var context = registeredContexts[contextName];\n            context.ranges = [];\n        }\n    }\n};\n\n/**\n * Updates context ranges\n */\nTokenizer.prototype.updateContextsRanges = function () {\n    this.resetContextsRanges();\n    var chars = this.tokens.map(function (token) { return token.char; });\n    for (var i = 0; i < chars.length; i++) {\n        var contextParams = new ContextParams(chars, i);\n        this.runContextCheck(contextParams);\n    }\n    this.dispatch('updateContextsRanges', [this.registeredContexts]);\n};\n\n/**\n * Sets the end offset of an open range\n * @param {number} offset range end offset\n * @param {string} contextName context name\n */\nTokenizer.prototype.setEndOffset = function (offset, contextName) {\n    var startIndex = this.getContext(contextName).openRange.startIndex;\n    var range = new ContextRange(startIndex, offset, contextName);\n    var ranges = this.getContext(contextName).ranges;\n    range.rangeId = contextName + \".\" + (ranges.length);\n    ranges.push(range);\n    this.getContext(contextName).openRange = null;\n    return range;\n};\n\n/**\n * Runs a context check on the current context\n * @param {contextParams} contextParams current context params\n */\nTokenizer.prototype.runContextCheck = function(contextParams) {\n    var this$1 = this;\n\n    var index = contextParams.index;\n    this.contextCheckers.forEach(function (contextChecker) {\n        var contextName = contextChecker.contextName;\n        var openRange = this$1.getContext(contextName).openRange;\n        if (!openRange && contextChecker.checkStart(contextParams)) {\n            openRange = new ContextRange(index, null, contextName);\n            this$1.getContext(contextName).openRange = openRange;\n            this$1.dispatch('contextStart', [contextName, index]);\n        }\n        if (!!openRange && contextChecker.checkEnd(contextParams)) {\n            var offset = (index - openRange.startIndex) + 1;\n            var range = this$1.setEndOffset(offset, contextName);\n            this$1.dispatch('contextEnd', [contextName, range]);\n        }\n    });\n};\n\n/**\n * Converts a text into a list of tokens\n * @param {string} text a text to tokenize\n */\nTokenizer.prototype.tokenize = function (text) {\n    this.tokens = [];\n    this.resetContextsRanges();\n    var chars = Array.from(text);\n    this.dispatch('start');\n    for (var i = 0; i < chars.length; i++) {\n        var char = chars[i];\n        var contextParams = new ContextParams(chars, i);\n        this.dispatch('next', [contextParams]);\n        this.runContextCheck(contextParams);\n        var token = new Token(char);\n        this.tokens.push(token);\n        this.dispatch('newToken', [token, contextParams]);\n    }\n    this.dispatch('end', [this.tokens]);\n    return this.tokens;\n};\n\n// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮\n// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊\n// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯\n// jscs:disable maximumLineLength\n/**\n * Check if a char is Arabic\n * @param {string} c a single char\n */\nfunction isArabicChar(c) {\n    return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c);\n}\n\n/**\n * Check if a char is an isolated arabic char\n * @param {string} c a single char\n */\nfunction isIsolatedArabicChar(char) {\n    return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(char);\n}\n\n/**\n * Check if a char is an Arabic Tashkeel char\n * @param {string} c a single char\n */\nfunction isTashkeelArabicChar(char) {\n    return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(char);\n}\n\n/**\n * Check if a char is Latin\n * @param {string} c a single char\n */\nfunction isLatinChar(c) {\n    return /[A-z]/.test(c);\n}\n\n/**\n * Check if a char is whitespace char\n * @param {string} c a single char\n */\nfunction isWhiteSpace(c) {\n    return /\\s/.test(c);\n}\n\n/**\n * Query a feature by some of it's properties to lookup a glyph substitution.\n */\n\n/**\n * Create feature query instance\n * @param {Font} font opentype font instance\n */\nfunction FeatureQuery(font) {\n    this.font = font;\n    this.features = {};\n}\n\n/**\n * @typedef SubstitutionAction\n * @type Object\n * @property {number} id substitution type\n * @property {string} tag feature tag\n * @property {any} substitution substitution value(s)\n */\n\n/**\n * Create a substitution action instance\n * @param {SubstitutionAction} action\n */\nfunction SubstitutionAction(action) {\n    this.id = action.id;\n    this.tag = action.tag;\n    this.substitution = action.substitution;\n}\n\n/**\n * Lookup a coverage table\n * @param {number} glyphIndex glyph index\n * @param {CoverageTable} coverage coverage table\n */\nfunction lookupCoverage(glyphIndex, coverage) {\n    if (!glyphIndex) { return -1; }\n    switch (coverage.format) {\n        case 1:\n            return coverage.glyphs.indexOf(glyphIndex);\n\n        case 2:\n            var ranges = coverage.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (glyphIndex >= range.start && glyphIndex <= range.end) {\n                    var offset = glyphIndex - range.start;\n                    return range.index + offset;\n                }\n            }\n            break;\n        default:\n            return -1; // not found\n    }\n    return -1;\n}\n\n/**\n * Handle a single substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return glyphIndex + subtable.deltaGlyphId;\n}\n\n/**\n * Handle a single substitution - format 2\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat2(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.substitute[substituteIndex];\n}\n\n/**\n * Lookup a list of coverage tables\n * @param {any} coverageList a list of coverage tables\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction lookupCoverageList(coverageList, contextParams) {\n    var lookupList = [];\n    for (var i = 0; i < coverageList.length; i++) {\n        var coverage = coverageList[i];\n        var glyphIndex = contextParams.current;\n        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n        var lookupIndex = lookupCoverage(glyphIndex, coverage);\n        if (lookupIndex !== -1) {\n            lookupList.push(lookupIndex);\n        }\n    }\n    if (lookupList.length !== coverageList.length) { return -1; }\n    return lookupList;\n}\n\n/**\n * Handle chaining context substitution - format 3\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction chainingSubstitutionFormat3(contextParams, subtable) {\n    var lookupsCount = (\n        subtable.inputCoverage.length +\n        subtable.lookaheadCoverage.length +\n        subtable.backtrackCoverage.length\n    );\n    if (contextParams.context.length < lookupsCount) { return []; }\n    // INPUT LOOKUP //\n    var inputLookups = lookupCoverageList(\n        subtable.inputCoverage, contextParams\n    );\n    if (inputLookups === -1) { return []; }\n    // LOOKAHEAD LOOKUP //\n    var lookaheadOffset = subtable.inputCoverage.length - 1;\n    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }\n    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n        lookaheadContext.shift();\n    }\n    var lookaheadParams = new ContextParams(lookaheadContext, 0);\n    var lookaheadLookups = lookupCoverageList(\n        subtable.lookaheadCoverage, lookaheadParams\n    );\n    // BACKTRACK LOOKUP //\n    var backtrackContext = [].concat(contextParams.backtrack);\n    backtrackContext.reverse();\n    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n        backtrackContext.shift();\n    }\n    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }\n    var backtrackParams = new ContextParams(backtrackContext, 0);\n    var backtrackLookups = lookupCoverageList(\n        subtable.backtrackCoverage, backtrackParams\n    );\n    var contextRulesMatch = (\n        inputLookups.length === subtable.inputCoverage.length &&\n        lookaheadLookups.length === subtable.lookaheadCoverage.length &&\n        backtrackLookups.length === subtable.backtrackCoverage.length\n    );\n    var substitutions = [];\n    if (contextRulesMatch) {\n        for (var i = 0; i < subtable.lookupRecords.length; i++) {\n            var lookupRecord = subtable.lookupRecords[i];\n            var lookupListIndex = lookupRecord.lookupListIndex;\n            var lookupTable = this.getLookupByIndex(lookupListIndex);\n            for (var s = 0; s < lookupTable.subtables.length; s++) {\n                var subtable$1 = lookupTable.subtables[s];\n                var lookup = this.getLookupMethod(lookupTable, subtable$1);\n                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);\n                if (substitutionType === '12') {\n                    for (var n = 0; n < inputLookups.length; n++) {\n                        var glyphIndex = contextParams.get(n);\n                        var substitution = lookup(glyphIndex);\n                        if (substitution) { substitutions.push(substitution); }\n                    }\n                }\n            }\n        }\n    }\n    return substitutions;\n}\n\n/**\n * Handle ligature substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction ligatureSubstitutionFormat1(contextParams, subtable) {\n    // COVERAGE LOOKUP //\n    var glyphIndex = contextParams.current;\n    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (ligSetIndex === -1) { return null; }\n    // COMPONENTS LOOKUP\n    // (!) note, components are ordered in the written direction.\n    var ligature;\n    var ligatureSet = subtable.ligatureSets[ligSetIndex];\n    for (var s = 0; s < ligatureSet.length; s++) {\n        ligature = ligatureSet[s];\n        for (var l = 0; l < ligature.components.length; l++) {\n            var lookaheadItem = contextParams.lookahead[l];\n            var component = ligature.components[l];\n            if (lookaheadItem !== component) { break; }\n            if (l === ligature.components.length - 1) { return ligature; }\n        }\n    }\n    return null;\n}\n\n/**\n * Handle decomposition substitution - format 1\n * @param {number} glyphIndex glyph index\n * @param {any} subtable subtable\n */\nfunction decompositionSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.sequences[substituteIndex];\n}\n\n/**\n * Get default script features indexes\n */\nFeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n    var scripts = this.font.tables.gsub.scripts;\n    for (var s = 0; s < scripts.length; s++) {\n        var script = scripts[s];\n        if (script.tag === 'DFLT') { return (\n            script.script.defaultLangSys.featureIndexes\n        ); }\n    }\n    return [];\n};\n\n/**\n * Get feature indexes of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {\n    var tables = this.font.tables;\n    if (!tables.gsub) { return []; }\n    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }\n    var scripts = this.font.tables.gsub.scripts;\n    for (var i = 0; i < scripts.length; i++) {\n        var script = scripts[i];\n        if (script.tag === scriptTag && script.script.defaultLangSys) {\n            return script.script.defaultLangSys.featureIndexes;\n        } else {\n            var langSysRecords = script.langSysRecords;\n            if (!!langSysRecords) {\n                for (var j = 0; j < langSysRecords.length; j++) {\n                    var langSysRecord = langSysRecords[j];\n                    if (langSysRecord.tag === scriptTag) {\n                        var langSys = langSysRecord.langSys;\n                        return langSys.featureIndexes;\n                    }\n                }\n            }\n        }\n    }\n    return this.getDefaultScriptFeaturesIndexes();\n};\n\n/**\n * Map a feature tag to a gsub feature\n * @param {any} features gsub features\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n    var tags = {};\n    for (var i = 0; i < features.length; i++) {\n        var tag = features[i].tag;\n        var feature = features[i].feature;\n        tags[tag] = feature;\n    }\n    this.features[scriptTag].tags = tags;\n};\n\n/**\n * Get features of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n    var features = this.features[scriptTag];\n    if (this.features.hasOwnProperty(scriptTag)) { return features; }\n    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n    if (!featuresIndexes) { return null; }\n    var gsub = this.font.tables.gsub;\n    features = featuresIndexes.map(function (index) { return gsub.features[index]; });\n    this.features[scriptTag] = features;\n    this.mapTagsToFeatures(features, scriptTag);\n    return features;\n};\n\n/**\n * Get substitution type\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {\n    var lookupType = lookupTable.lookupType.toString();\n    var substFormat = subtable.substFormat.toString();\n    return lookupType + substFormat;\n};\n\n/**\n * Get lookup method\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {\n    var this$1 = this;\n\n    var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n    switch (substitutionType) {\n        case '11':\n            return function (glyphIndex) { return singleSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '12':\n            return function (glyphIndex) { return singleSubstitutionFormat2.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '63':\n            return function (contextParams) { return chainingSubstitutionFormat3.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '41':\n            return function (contextParams) { return ligatureSubstitutionFormat1.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '21':\n            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        default:\n            throw new Error(\n                \"lookupType: \" + (lookupTable.lookupType) + \" - \" +\n                \"substFormat: \" + (subtable.substFormat) + \" \" +\n                \"is not yet supported\"\n            );\n    }\n};\n\n/**\n * [ LOOKUP TYPES ]\n * -------------------------------\n * Single                        1;\n * Multiple                      2;\n * Alternate                     3;\n * Ligature                      4;\n * Context                       5;\n * ChainingContext               6;\n * ExtensionSubstitution         7;\n * ReverseChainingContext        8;\n * -------------------------------\n *\n */\n\n/**\n * @typedef FQuery\n * @type Object\n * @param {string} tag feature tag\n * @param {string} script feature script\n * @param {ContextParams} contextParams context params\n */\n\n/**\n * Lookup a feature using a query parameters\n * @param {FQuery} query feature query\n */\nFeatureQuery.prototype.lookupFeature = function (query) {\n    var contextParams = query.contextParams;\n    var currentIndex = contextParams.index;\n    var feature = this.getFeature({\n        tag: query.tag, script: query.script\n    });\n    if (!feature) { return new Error(\n        \"font '\" + (this.font.names.fullName.en) + \"' \" +\n        \"doesn't support feature '\" + (query.tag) + \"' \" +\n        \"for script '\" + (query.script) + \"'.\"\n    ); }\n    var lookups = this.getFeatureLookups(feature);\n    var substitutions = [].concat(contextParams.context);\n    for (var l = 0; l < lookups.length; l++) {\n        var lookupTable = lookups[l];\n        var subtables = this.getLookupSubtables(lookupTable);\n        for (var s = 0; s < subtables.length; s++) {\n            var subtable = subtables[s];\n            var substType = this.getSubstitutionType(lookupTable, subtable);\n            var lookup = this.getLookupMethod(lookupTable, subtable);\n            var substitution = (void 0);\n            switch (substType) {\n                case '11':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 11, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '12':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 12, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '63':\n                    substitution = lookup(contextParams);\n                    if (Array.isArray(substitution) && substitution.length) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 63, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '41':\n                    substitution = lookup(contextParams);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 41, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '21':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 21, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n            }\n            contextParams = new ContextParams(substitutions, currentIndex);\n            if (Array.isArray(substitution) && !substitution.length) { continue; }\n            substitution = null;\n        }\n    }\n    return substitutions.length ? substitutions : null;\n};\n\n/**\n * Checks if a font supports a specific features\n * @param {FQuery} query feature query object\n */\nFeatureQuery.prototype.supports = function (query) {\n    if (!query.script) { return false; }\n    this.getScriptFeatures(query.script);\n    var supportedScript = this.features.hasOwnProperty(query.script);\n    if (!query.tag) { return supportedScript; }\n    var supportedFeature = (\n        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })\n    );\n    return supportedScript && supportedFeature;\n};\n\n/**\n * Get lookup table subtables\n * @param {any} lookupTable lookup table\n */\nFeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n    return lookupTable.subtables || null;\n};\n\n/**\n * Get lookup table by index\n * @param {number} index lookup table index\n */\nFeatureQuery.prototype.getLookupByIndex = function (index) {\n    var lookups = this.font.tables.gsub.lookups;\n    return lookups[index] || null;\n};\n\n/**\n * Get lookup tables for a feature\n * @param {string} feature\n */\nFeatureQuery.prototype.getFeatureLookups = function (feature) {\n    // TODO: memoize\n    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n};\n\n/**\n * Query a feature by it's properties\n * @param {any} query an object that describes the properties of a query\n */\nFeatureQuery.prototype.getFeature = function getFeature(query) {\n    if (!this.font) { return { FAIL: \"No font was found\"}; }\n    if (!this.features.hasOwnProperty(query.script)) {\n        this.getScriptFeatures(query.script);\n    }\n    var scriptFeatures = this.features[query.script];\n    if (!scriptFeatures) { return (\n        { FAIL: (\"No feature for script \" + (query.script))}\n    ); }\n    if (!scriptFeatures.tags[query.tag]) { return null; }\n    return this.features[query.script].tags[query.tag];\n};\n\n/**\n * Arabic word context checkers\n */\n\nfunction arabicWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? arabic first char\n        (prevChar === null && isArabicChar(char)) ||\n        // ? arabic char preceded with a non arabic char\n        (!isArabicChar(prevChar) && isArabicChar(char))\n    );\n}\n\nfunction arabicWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last arabic char\n        (nextChar === null) ||\n        // ? next char is not arabic\n        (!isArabicChar(nextChar))\n    );\n}\n\nvar arabicWordCheck = {\n    startCheck: arabicWordStartCheck,\n    endCheck: arabicWordEndCheck\n};\n\n/**\n * Arabic sentence context checkers\n */\n\nfunction arabicSentenceStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? an arabic char preceded with a non arabic char\n        (isArabicChar(char) || isTashkeelArabicChar(char)) &&\n        !isArabicChar(prevChar)\n    );\n}\n\nfunction arabicSentenceEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    switch (true) {\n        case nextChar === null:\n            return true;\n        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):\n            var nextIsWhitespace = isWhiteSpace(nextChar);\n            if (!nextIsWhitespace) { return true; }\n            if (nextIsWhitespace) {\n                var arabicCharAhead = false;\n                arabicCharAhead = (\n                    contextParams.lookahead.some(\n                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }\n                    )\n                );\n                if (!arabicCharAhead) { return true; }\n            }\n            break;\n        default:\n            return false;\n    }\n}\n\nvar arabicSentenceCheck = {\n    startCheck: arabicSentenceStartCheck,\n    endCheck: arabicSentenceEndCheck\n};\n\n/**\n * Apply single substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat1$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply single substitution format 2\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat2$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply chaining context substitution format 3\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction chainingSubstitutionFormat3$1(action, tokens, index) {\n    action.substitution.forEach(function (subst, offset) {\n        var token = tokens[index + offset];\n        token.setState(action.tag, subst);\n    });\n}\n\n/**\n * Apply ligature substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction ligatureSubstitutionFormat1$1(action, tokens, index) {\n    var token = tokens[index];\n    token.setState(action.tag, action.substitution.ligGlyph);\n    var compsCount = action.substitution.components.length;\n    for (var i = 0; i < compsCount; i++) {\n        token = tokens[index + i + 1];\n        token.setState('deleted', true);\n    }\n}\n\n/**\n * Supported substitutions\n */\nvar SUBSTITUTIONS = {\n    11: singleSubstitutionFormat1$1,\n    12: singleSubstitutionFormat2$1,\n    63: chainingSubstitutionFormat3$1,\n    41: ligatureSubstitutionFormat1$1\n};\n\n/**\n * Apply substitutions to a list of tokens\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction applySubstitution(action, tokens, index) {\n    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n        SUBSTITUTIONS[action.id](action, tokens, index);\n    }\n}\n\n/**\n * Apply Arabic presentation forms to a range of tokens\n */\n\n/**\n * Check if a char can be connected to it's preceding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectPrev(charContextParams) {\n    var backtrack = [].concat(charContextParams.backtrack);\n    for (var i = backtrack.length - 1; i >= 0; i--) {\n        var prevChar = backtrack[i];\n        var isolated = isIsolatedArabicChar(prevChar);\n        var tashkeel = isTashkeelArabicChar(prevChar);\n        if (!isolated && !tashkeel) { return true; }\n        if (isolated) { return false; }\n    }\n    return false;\n}\n\n/**\n * Check if a char can be connected to it's proceeding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectNext(charContextParams) {\n    if (isIsolatedArabicChar(charContextParams.current)) { return false; }\n    for (var i = 0; i < charContextParams.lookahead.length; i++) {\n        var nextChar = charContextParams.lookahead[i];\n        var tashkeel = isTashkeelArabicChar(nextChar);\n        if (!tashkeel) { return true; }\n    }\n    return false;\n}\n\n/**\n * Apply arabic presentation forms to a list of tokens\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicPresentationForms(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tags = this.featuresTags[script];\n    var tokens = this.tokenizer.getRangeTokens(range);\n    if (tokens.length === 1) { return; }\n    var contextParams = new ContextParams(\n        tokens.map(function (token) { return token.getState('glyphIndex'); }\n    ), 0);\n    var charContextParams = new ContextParams(\n        tokens.map(function (token) { return token.char; }\n    ), 0);\n    tokens.forEach(function (token, index) {\n        if (isTashkeelArabicChar(token.char)) { return; }\n        contextParams.setCurrentIndex(index);\n        charContextParams.setCurrentIndex(index);\n        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)\n        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }\n        if (willConnectNext(charContextParams)) { CONNECT |= 2; }\n        var tag;\n        switch (CONNECT) {\n            case 1: (tag = 'fina'); break;\n            case 2: (tag = 'init'); break;\n            case 3: (tag = 'medi'); break;\n        }\n        if (tags.indexOf(tag) === -1) { return; }\n        var substitutions = this$1.query.lookupFeature({\n            tag: tag, script: script, contextParams: contextParams\n        });\n        if (substitutions instanceof Error) { return console.info(substitutions.message); }\n        substitutions.forEach(function (action, index) {\n            if (action instanceof SubstitutionAction) {\n                applySubstitution(action, tokens, index);\n                contextParams.context[index] = action.substitution;\n            }\n        });\n    });\n}\n\n/**\n * Apply Arabic required ligatures feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicRequiredLigatures(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'rlig', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams(tokens);\n        }\n    });\n}\n\n/**\n * Latin word context checkers\n */\n\nfunction latinWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? latin first char\n        (prevChar === null && isLatinChar(char)) ||\n        // ? latin char preceded with a non latin char\n        (!isLatinChar(prevChar) && isLatinChar(char))\n    );\n}\n\nfunction latinWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last latin char\n        (nextChar === null) ||\n        // ? next char is not latin\n        (!isLatinChar(nextChar))\n    );\n}\n\nvar latinWordCheck = {\n    startCheck: latinWordStartCheck,\n    endCheck: latinWordEndCheck\n};\n\n/**\n * Apply Latin ligature feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams$1(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction latinLigature(range) {\n    var this$1 = this;\n\n    var script = 'latn';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams$1(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'liga', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams$1(tokens);\n        }\n    });\n}\n\n/**\n * Infer bidirectional properties for a given text and apply\n * the corresponding layout rules.\n */\n\n/**\n * Create Bidi. features\n * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n */\nfunction Bidi(baseDir) {\n    this.baseDir = baseDir || 'ltr';\n    this.tokenizer = new Tokenizer();\n    this.featuresTags = {};\n}\n\n/**\n * Sets Bidi text\n * @param {string} text a text input\n */\nBidi.prototype.setText = function (text) {\n    this.text = text;\n};\n\n/**\n * Store essential context checks:\n * arabic word check for applying gsub features\n * arabic sentence check for adjusting arabic layout\n */\nBidi.prototype.contextChecks = ({\n    latinWordCheck: latinWordCheck,\n    arabicWordCheck: arabicWordCheck,\n    arabicSentenceCheck: arabicSentenceCheck\n});\n\n/**\n * Register arabic word check\n */\nfunction registerContextChecker(checkId) {\n    var check = this.contextChecks[(checkId + \"Check\")];\n    return this.tokenizer.registerContextChecker(\n        checkId, check.startCheck, check.endCheck\n    );\n}\n\n/**\n * Perform pre tokenization procedure then\n * tokenize text input\n */\nfunction tokenizeText() {\n    registerContextChecker.call(this, 'latinWord');\n    registerContextChecker.call(this, 'arabicWord');\n    registerContextChecker.call(this, 'arabicSentence');\n    return this.tokenizer.tokenize(this.text);\n}\n\n/**\n * Reverse arabic sentence layout\n * TODO: check base dir before applying adjustments - priority low\n */\nfunction reverseArabicSentences() {\n    var this$1 = this;\n\n    var ranges = this.tokenizer.getContextRanges('arabicSentence');\n    ranges.forEach(function (range) {\n        var rangeTokens = this$1.tokenizer.getRangeTokens(range);\n        this$1.tokenizer.replaceRange(\n            range.startIndex,\n            range.endOffset,\n            rangeTokens.reverse()\n        );\n    });\n}\n\n/**\n * Register supported features tags\n * @param {script} script script tag\n * @param {Array} tags features tags list\n */\nBidi.prototype.registerFeatures = function (script, tags) {\n    var this$1 = this;\n\n    var supportedTags = tags.filter(\n        function (tag) { return this$1.query.supports({script: script, tag: tag}); }\n    );\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        this.featuresTags[script] = supportedTags;\n    } else {\n        this.featuresTags[script] =\n        this.featuresTags[script].concat(supportedTags);\n    }\n};\n\n/**\n * Apply GSUB features\n * @param {Array} tagsList a list of features tags\n * @param {string} script a script tag\n * @param {Font} font opentype font instance\n */\nBidi.prototype.applyFeatures = function (font, features) {\n    if (!font) { throw new Error(\n        'No valid font was provided to apply features'\n    ); }\n    if (!this.query) { this.query = new FeatureQuery(font); }\n    for (var f = 0; f < features.length; f++) {\n        var feature = features[f];\n        if (!this.query.supports({script: feature.script})) { continue; }\n        this.registerFeatures(feature.script, feature.tags);\n    }\n};\n\n/**\n * Register a state modifier\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a modifier function to set token state\n */\nBidi.prototype.registerModifier = function (modifierId, condition, modifier) {\n    this.tokenizer.registerModifier(modifierId, condition, modifier);\n};\n\n/**\n * Check if 'glyphIndex' is registered\n */\nfunction checkGlyphIndexStatus() {\n    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {\n        throw new Error(\n            'glyphIndex modifier is required to apply ' +\n            'arabic presentation features.'\n        );\n    }\n}\n\n/**\n * Apply arabic presentation forms features\n */\nfunction applyArabicPresentationForms() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicPresentationForms.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyArabicRequireLigatures() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('rlig') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicRequiredLigatures.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyLatinLigatures() {\n    var this$1 = this;\n\n    var script = 'latn';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('liga') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('latinWord');\n    ranges.forEach(function (range) {\n        latinLigature.call(this$1, range);\n    });\n}\n\n/**\n * Check if a context is registered\n * @param {string} contextId context id\n */\nBidi.prototype.checkContextReady = function (contextId) {\n    return !!this.tokenizer.getContext(contextId);\n};\n\n/**\n * Apply features to registered contexts\n */\nBidi.prototype.applyFeaturesToContexts = function () {\n    if (this.checkContextReady('arabicWord')) {\n        applyArabicPresentationForms.call(this);\n        applyArabicRequireLigatures.call(this);\n    }\n    if (this.checkContextReady('latinWord')) {\n        applyLatinLigatures.call(this);\n    }\n    if (this.checkContextReady('arabicSentence')) {\n        reverseArabicSentences.call(this);\n    }\n};\n\n/**\n * process text input\n * @param {string} text an input text\n */\nBidi.prototype.processText = function(text) {\n    if (!this.text || this.text !== text) {\n        this.setText(text);\n        tokenizeText.call(this);\n        this.applyFeaturesToContexts();\n    }\n};\n\n/**\n * Process a string of text to identify and adjust\n * bidirectional text entities.\n * @param {string} text input text\n */\nBidi.prototype.getBidiText = function (text) {\n    this.processText(text);\n    return this.tokenizer.getText();\n};\n\n/**\n * Get the current state index of each token\n * @param {text} text an input text\n */\nBidi.prototype.getTextGlyphs = function (text) {\n    this.processText(text);\n    var indexes = [];\n    for (var i = 0; i < this.tokenizer.tokens.length; i++) {\n        var token = this.tokenizer.tokens[i];\n        if (token.state.deleted) { continue; }\n        var index = token.activeState.value;\n        indexes.push(Array.isArray(index) ? index[0] : index);\n    }\n    return indexes;\n};\n\n// The Font object\n\n/**\n * @typedef FontOptions\n * @type Object\n * @property {Boolean} empty - whether to create a new empty font\n * @property {string} familyName\n * @property {string} styleName\n * @property {string=} fullName\n * @property {string=} postScriptName\n * @property {string=} designer\n * @property {string=} designerURL\n * @property {string=} manufacturer\n * @property {string=} manufacturerURL\n * @property {string=} license\n * @property {string=} licenseURL\n * @property {string=} version\n * @property {string=} description\n * @property {string=} copyright\n * @property {string=} trademark\n * @property {Number} unitsPerEm\n * @property {Number} ascender\n * @property {Number} descender\n * @property {Number} createdTimestamp\n * @property {string=} weightClass\n * @property {string=} widthClass\n * @property {string=} fsSelection\n */\n\n/**\n * A Font represents a loaded OpenType font file.\n * It contains a set of glyphs and methods to draw text on a drawing context,\n * or to get a path representing the text.\n * @exports opentype.Font\n * @class\n * @param {FontOptions}\n * @constructor\n */\nfunction Font(options) {\n    options = options || {};\n    options.tables = options.tables || {};\n\n    if (!options.empty) {\n        // Check that we've provided the minimum set of names.\n        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');\n        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');\n        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');\n        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');\n        checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.');\n\n        // OS X will complain if the names are empty, so we put a single space everywhere by default.\n        this.names = {\n            fontFamily: {en: options.familyName || ' '},\n            fontSubfamily: {en: options.styleName || ' '},\n            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},\n            // postScriptName may not contain any whitespace\n            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\\s/g, '')},\n            designer: {en: options.designer || ' '},\n            designerURL: {en: options.designerURL || ' '},\n            manufacturer: {en: options.manufacturer || ' '},\n            manufacturerURL: {en: options.manufacturerURL || ' '},\n            license: {en: options.license || ' '},\n            licenseURL: {en: options.licenseURL || ' '},\n            version: {en: options.version || 'Version 0.1'},\n            description: {en: options.description || ' '},\n            copyright: {en: options.copyright || ' '},\n            trademark: {en: options.trademark || ' '}\n        };\n        this.unitsPerEm = options.unitsPerEm || 1000;\n        this.ascender = options.ascender;\n        this.descender = options.descender;\n        this.createdTimestamp = options.createdTimestamp;\n        this.tables = Object.assign(options.tables, {\n            os2: Object.assign({\n                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,\n            }, options.tables.os2)\n        });\n    }\n\n    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n    this.encoding = new DefaultEncoding(this);\n    this.position = new Position(this);\n    this.substitution = new Substitution(this);\n    this.tables = this.tables || {};\n\n    // needed for low memory mode only.\n    this._push = null;\n    this._hmtxTableData = {};\n\n    Object.defineProperty(this, 'hinting', {\n        get: function() {\n            if (this._hinting) { return this._hinting; }\n            if (this.outlinesFormat === 'truetype') {\n                return (this._hinting = new Hinting(this));\n            }\n        }\n    });\n}\n\n/**\n * Check if the font has a glyph for the given character.\n * @param  {string}\n * @return {Boolean}\n */\nFont.prototype.hasChar = function(c) {\n    return this.encoding.charToGlyphIndex(c) !== null;\n};\n\n/**\n * Convert the given character to a single glyph index.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.charToGlyphIndex = function(s) {\n    return this.encoding.charToGlyphIndex(s);\n};\n\n/**\n * Convert the given character to a single Glyph object.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.charToGlyph = function(c) {\n    var glyphIndex = this.charToGlyphIndex(c);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * Update features\n * @param {any} options features options\n */\nFont.prototype.updateFeatures = function (options) {\n    // TODO: update all features options not only 'latn'.\n    return this.defaultRenderOptions.features.map(function (feature) {\n        if (feature.script === 'latn') {\n            return {\n                script: 'latn',\n                tags: feature.tags.filter(function (tag) { return options[tag]; })\n            };\n        } else {\n            return feature;\n        }\n    });\n};\n\n/**\n * Convert the given text to a list of Glyph objects.\n * Note that there is no strict one-to-one mapping between characters and\n * glyphs, so the list of returned glyphs can be larger or smaller than the\n * length of the given string.\n * @param  {string}\n * @param  {GlyphRenderOptions} [options]\n * @return {opentype.Glyph[]}\n */\nFont.prototype.stringToGlyphs = function(s, options) {\n    var this$1 = this;\n\n\n    var bidi = new Bidi();\n\n    // Create and register 'glyphIndex' state modifier\n    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };\n    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);\n\n    // roll-back to default features\n    var features = options ?\n    this.updateFeatures(options.features) :\n    this.defaultRenderOptions.features;\n\n    bidi.applyFeatures(this, features);\n\n    var indexes = bidi.getTextGlyphs(s);\n\n    var length = indexes.length;\n\n    // convert glyph indexes to glyph objects\n    var glyphs = new Array(length);\n    var notdef = this.glyphs.get(0);\n    for (var i = 0; i < length; i += 1) {\n        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n    }\n    return glyphs;\n};\n\n/**\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.nameToGlyphIndex = function(name) {\n    return this.glyphNames.nameToGlyphIndex(name);\n};\n\n/**\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.nameToGlyph = function(name) {\n    var glyphIndex = this.nameToGlyphIndex(name);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * @param  {Number}\n * @return {String}\n */\nFont.prototype.glyphIndexToName = function(gid) {\n    if (!this.glyphNames.glyphIndexToName) {\n        return '';\n    }\n\n    return this.glyphNames.glyphIndexToName(gid);\n};\n\n/**\n * Retrieve the value of the kerning pair between the left glyph (or its index)\n * and the right glyph (or its index). If no kerning pair is found, return 0.\n * The kerning value gets added to the advance width when calculating the spacing\n * between glyphs.\n * For GPOS kerning, this method uses the default script and language, which covers\n * most use cases. To have greater control, use font.position.getKerningValue .\n * @param  {opentype.Glyph} leftGlyph\n * @param  {opentype.Glyph} rightGlyph\n * @return {Number}\n */\nFont.prototype.getKerningValue = function(leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph;\n    rightGlyph = rightGlyph.index || rightGlyph;\n    var gposKerning = this.position.defaultKerningTables;\n    if (gposKerning) {\n        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);\n    }\n    // \"kern\" table\n    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n};\n\n/**\n * @typedef GlyphRenderOptions\n * @type Object\n * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n * @property {string} [language='dflt'] - language system used to determine which features to apply.\n *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n * @property {boolean} [kerning=true] - whether to include kerning values\n * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n */\nFont.prototype.defaultRenderOptions = {\n    kerning: true,\n    features: [\n        /**\n         * these 4 features are required to render Arabic text properly\n         * and shouldn't be turned off when rendering arabic text.\n         */\n        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },\n        { script: 'latn', tags: ['liga', 'rlig'] }\n    ]\n};\n\n/**\n * Helper function that invokes the given callback for each glyph in the given text.\n * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n * @param {string} text - The text to apply.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @param  {Function} callback\n */\nFont.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    options = Object.assign({}, this.defaultRenderOptions, options);\n    var fontScale = 1 / this.unitsPerEm * fontSize;\n    var glyphs = this.stringToGlyphs(text, options);\n    var kerningLookups;\n    if (options.kerning) {\n        var script = options.script || this.position.getDefaultScriptName();\n        kerningLookups = this.position.getKerningTables(script, options.language);\n    }\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs[i];\n        callback.call(this, glyph, x, y, fontSize, options);\n        if (glyph.advanceWidth) {\n            x += glyph.advanceWidth * fontScale;\n        }\n\n        if (options.kerning && i < glyphs.length - 1) {\n            // We should apply position adjustment lookups in a more generic way.\n            // Here we only use the xAdvance value.\n            var kerningValue = kerningLookups ?\n                  this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :\n                  this.getKerningValue(glyph, glyphs[i + 1]);\n            x += kerningValue * fontScale;\n        }\n\n        if (options.letterSpacing) {\n            x += options.letterSpacing * fontSize;\n        } else if (options.tracking) {\n            x += (options.tracking / 1000) * fontSize;\n        }\n    }\n    return x;\n};\n\n/**\n * Create a Path object that represents the given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path}\n */\nFont.prototype.getPath = function(text, x, y, fontSize, options) {\n    var fullPath = new Path();\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        fullPath.extend(glyphPath);\n    });\n    return fullPath;\n};\n\n/**\n * Create an array of Path objects that represent the glyphs of a given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path[]}\n */\nFont.prototype.getPaths = function(text, x, y, fontSize, options) {\n    var glyphPaths = [];\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        glyphPaths.push(glyphPath);\n    });\n\n    return glyphPaths;\n};\n\n/**\n * Returns the advance width of a text.\n *\n * This is something different than Path.getBoundingBox() as for example a\n * suffixed whitespace increases the advanceWidth but not the bounding box\n * or an overhanging letter like a calligraphic 'f' might have a quite larger\n * bounding box than its advance width.\n *\n * This corresponds to canvas2dContext.measureText(text).width\n *\n * @param  {string} text - The text to create.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return advance width\n */\nFont.prototype.getAdvanceWidth = function(text, fontSize, options) {\n    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});\n};\n\n/**\n * Draw the text on the given drawing context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n */\nFont.prototype.draw = function(ctx, text, x, y, fontSize, options) {\n    this.getPath(text, x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of all glyphs in the text.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawPoints(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * Draw lines indicating important font measurements for all glyphs in the text.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawMetrics(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * @param  {string}\n * @return {string}\n */\nFont.prototype.getEnglishName = function(name) {\n    var translations = this.names[name];\n    if (translations) {\n        return translations.en;\n    }\n};\n\n/**\n * Validate\n */\nFont.prototype.validate = function() {\n    var _this = this;\n\n    function assert(predicate, message) {\n    }\n\n    function assertNamePresent(name) {\n        var englishName = _this.getEnglishName(name);\n        assert(englishName && englishName.trim().length > 0);\n    }\n\n    // Identification information\n    assertNamePresent('fontFamily');\n    assertNamePresent('weightName');\n    assertNamePresent('manufacturer');\n    assertNamePresent('copyright');\n    assertNamePresent('version');\n\n    // Dimension information\n    assert(this.unitsPerEm > 0);\n};\n\n/**\n * Convert the font object to a SFNT data structure.\n * This structure contains all the necessary tables and metadata to create a binary OTF file.\n * @return {opentype.Table}\n */\nFont.prototype.toTables = function() {\n    return sfnt.fontToTable(this);\n};\n/**\n * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\n */\nFont.prototype.toBuffer = function() {\n    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');\n    return this.toArrayBuffer();\n};\n/**\n * Converts a `opentype.Font` into an `ArrayBuffer`\n * @return {ArrayBuffer}\n */\nFont.prototype.toArrayBuffer = function() {\n    var sfntTable = this.toTables();\n    var bytes = sfntTable.encode();\n    var buffer = new ArrayBuffer(bytes.length);\n    var intArray = new Uint8Array(buffer);\n    for (var i = 0; i < bytes.length; i++) {\n        intArray[i] = bytes[i];\n    }\n\n    return buffer;\n};\n\n/**\n * Initiate a download of the OpenType font.\n */\nFont.prototype.download = function(fileName) {\n    var familyName = this.getEnglishName('fontFamily');\n    var styleName = this.getEnglishName('fontSubfamily');\n    fileName = fileName || familyName.replace(/\\s/g, '') + '-' + styleName + '.otf';\n    var arrayBuffer = this.toArrayBuffer();\n\n    if (isBrowser()) {\n        window.URL = window.URL || window.webkitURL;\n\n        if (window.URL) {\n            var dataView = new DataView(arrayBuffer);\n            var blob = new Blob([dataView], {type: 'font/opentype'});\n\n            var link = document.createElement('a');\n            link.href = window.URL.createObjectURL(blob);\n            link.download = fileName;\n\n            var event = document.createEvent('MouseEvents');\n            event.initEvent('click', true, false);\n            link.dispatchEvent(event);\n        } else {\n            console.warn('Font file could not be downloaded. Try using a different browser.');\n        }\n    } else {\n        var fs = require('fs');\n        var buffer = arrayBufferToNodeBuffer(arrayBuffer);\n        fs.writeFileSync(fileName, buffer);\n    }\n};\n/**\n * @private\n */\nFont.prototype.fsSelectionValues = {\n    ITALIC:              0x001, //1\n    UNDERSCORE:          0x002, //2\n    NEGATIVE:            0x004, //4\n    OUTLINED:            0x008, //8\n    STRIKEOUT:           0x010, //16\n    BOLD:                0x020, //32\n    REGULAR:             0x040, //64\n    USER_TYPO_METRICS:   0x080, //128\n    WWS:                 0x100, //256\n    OBLIQUE:             0x200  //512\n};\n\n/**\n * @private\n */\nFont.prototype.usWidthClasses = {\n    ULTRA_CONDENSED: 1,\n    EXTRA_CONDENSED: 2,\n    CONDENSED: 3,\n    SEMI_CONDENSED: 4,\n    MEDIUM: 5,\n    SEMI_EXPANDED: 6,\n    EXPANDED: 7,\n    EXTRA_EXPANDED: 8,\n    ULTRA_EXPANDED: 9\n};\n\n/**\n * @private\n */\nFont.prototype.usWeightClasses = {\n    THIN: 100,\n    EXTRA_LIGHT: 200,\n    LIGHT: 300,\n    NORMAL: 400,\n    MEDIUM: 500,\n    SEMI_BOLD: 600,\n    BOLD: 700,\n    EXTRA_BOLD: 800,\n    BLACK:    900\n};\n\n// The `fvar` table stores font variation axes and instances.\n\nfunction addName(name, names) {\n    var nameString = JSON.stringify(name);\n    var nameID = 256;\n    for (var nameKey in names) {\n        var n = parseInt(nameKey);\n        if (!n || n < 256) {\n            continue;\n        }\n\n        if (JSON.stringify(names[nameKey]) === nameString) {\n            return n;\n        }\n\n        if (nameID <= n) {\n            nameID = n + 1;\n        }\n    }\n\n    names[nameID] = name;\n    return nameID;\n}\n\nfunction makeFvarAxis(n, axis, names) {\n    var nameID = addName(axis.name, names);\n    return [\n        {name: 'tag_' + n, type: 'TAG', value: axis.tag},\n        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},\n        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},\n        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},\n        {name: 'flags_' + n, type: 'USHORT', value: 0},\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID}\n    ];\n}\n\nfunction parseFvarAxis(data, start, names) {\n    var axis = {};\n    var p = new parse.Parser(data, start);\n    axis.tag = p.parseTag();\n    axis.minValue = p.parseFixed();\n    axis.defaultValue = p.parseFixed();\n    axis.maxValue = p.parseFixed();\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n    axis.name = names[p.parseUShort()] || {};\n    return axis;\n}\n\nfunction makeFvarInstance(n, inst, axes, names) {\n    var nameID = addName(inst.name, names);\n    var fields = [\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID},\n        {name: 'flags_' + n, type: 'USHORT', value: 0}\n    ];\n\n    for (var i = 0; i < axes.length; ++i) {\n        var axisTag = axes[i].tag;\n        fields.push({\n            name: 'axis_' + n + ' ' + axisTag,\n            type: 'FIXED',\n            value: inst.coordinates[axisTag] << 16\n        });\n    }\n\n    return fields;\n}\n\nfunction parseFvarInstance(data, start, axes, names) {\n    var inst = {};\n    var p = new parse.Parser(data, start);\n    inst.name = names[p.parseUShort()] || {};\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n\n    inst.coordinates = {};\n    for (var i = 0; i < axes.length; ++i) {\n        inst.coordinates[axes[i].tag] = p.parseFixed();\n    }\n\n    return inst;\n}\n\nfunction makeFvarTable(fvar, names) {\n    var result = new table.Table('fvar', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'offsetToData', type: 'USHORT', value: 0},\n        {name: 'countSizePairs', type: 'USHORT', value: 2},\n        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},\n        {name: 'axisSize', type: 'USHORT', value: 20},\n        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},\n        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}\n    ]);\n    result.offsetToData = result.sizeOf();\n\n    for (var i = 0; i < fvar.axes.length; i++) {\n        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));\n    }\n\n    for (var j = 0; j < fvar.instances.length; j++) {\n        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));\n    }\n\n    return result;\n}\n\nfunction parseFvarTable(data, start, names) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');\n    var offsetToData = p.parseOffset16();\n    // Skip countSizePairs.\n    p.skip('uShort', 1);\n    var axisCount = p.parseUShort();\n    var axisSize = p.parseUShort();\n    var instanceCount = p.parseUShort();\n    var instanceSize = p.parseUShort();\n\n    var axes = [];\n    for (var i = 0; i < axisCount; i++) {\n        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));\n    }\n\n    var instances = [];\n    var instanceStart = start + offsetToData + axisCount * axisSize;\n    for (var j = 0; j < instanceCount; j++) {\n        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));\n    }\n\n    return {axes: axes, instances: instances};\n}\n\nvar fvar = { make: makeFvarTable, parse: parseFvarTable };\n\n// The `GDEF` table contains various glyph properties\n\nvar attachList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))\n    };\n};\n\nvar caretValue = function() {\n    var format = this.parseUShort();\n    check.argument(format === 1 || format === 2 || format === 3,\n        'Unsupported CaretValue table version.');\n    if (format === 1) {\n        return { coordinate: this.parseShort() };\n    } else if (format === 2) {\n        return { pointindex: this.parseShort() };\n    } else if (format === 3) {\n        // Device / Variation Index tables unsupported\n        return { coordinate: this.parseShort() };\n    }\n};\n\nvar ligGlyph = function() {\n    return this.parseList(Parser.pointer(caretValue));\n};\n\nvar ligCaretList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))\n    };\n};\n\nvar markGlyphSets = function() {\n    this.parseUShort(); // Version\n    return this.parseList(Parser.pointer(Parser.coverage));\n};\n\nfunction parseGDEFTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,\n        'Unsupported GDEF table version.');\n    var gdef = {\n        version: tableVersion,\n        classDef: p.parsePointer(Parser.classDef),\n        attachList: p.parsePointer(attachList),\n        ligCaretList: p.parsePointer(ligCaretList),\n        markAttachClassDef: p.parsePointer(Parser.classDef)\n    };\n    if (tableVersion >= 1.2) {\n        gdef.markGlyphSets = p.parsePointer(markGlyphSets);\n    }\n    return gdef;\n}\nvar gdef = { parse: parseGDEFTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\nvar subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n// this = Parser instance\nsubtableParsers$1[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var posformat = this.parseUShort();\n    if (posformat === 1) {\n        return {\n            posFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            value: this.parseValueRecord()\n        };\n    } else if (posformat === 2) {\n        return {\n            posFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            values: this.parseValueRecordList()\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');\n};\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\nsubtableParsers$1[2] = function parseLookup2() {\n    var start = this.offset + this.relativeOffset;\n    var posFormat = this.parseUShort();\n    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');\n    var coverage = this.parsePointer(Parser.coverage);\n    var valueFormat1 = this.parseUShort();\n    var valueFormat2 = this.parseUShort();\n    if (posFormat === 1) {\n        // Adjustments for Glyph Pairs\n        return {\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            pairSets: this.parseList(Parser.pointer(Parser.list(function() {\n                return {        // pairValueRecord\n                    secondGlyph: this.parseUShort(),\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            })))\n        };\n    } else if (posFormat === 2) {\n        var classDef1 = this.parsePointer(Parser.classDef);\n        var classDef2 = this.parsePointer(Parser.classDef);\n        var class1Count = this.parseUShort();\n        var class2Count = this.parseUShort();\n        return {\n            // Class Pair Adjustment\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            classDef1: classDef1,\n            classDef2: classDef2,\n            class1Count: class1Count,\n            class2Count: class2Count,\n            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {\n                return {\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            }))\n        };\n    }\n};\n\nsubtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };\nsubtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };\nsubtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };\nsubtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };\nsubtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };\nsubtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };\nsubtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\nfunction parseGposTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);\n\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n\n}\n\n// GPOS Writing //////////////////////////////////////////////\n// NOT SUPPORTED\nvar subtableMakers$1 = new Array(10);\n\nfunction makeGposTable(gpos) {\n    return new table.Table('GPOS', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},\n        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},\n        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}\n    ]);\n}\n\nvar gpos = { parse: parseGposTable, make: makeGposTable };\n\n// The `kern` table contains kerning pairs.\n\nfunction parseWindowsKernTable(p) {\n    var pairs = {};\n    // Skip nTables.\n    p.skip('uShort');\n    var subtableVersion = p.parseUShort();\n    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n    // Skip subtableLength, subtableCoverage\n    p.skip('uShort', 2);\n    var nPairs = p.parseUShort();\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n    for (var i = 0; i < nPairs; i += 1) {\n        var leftIndex = p.parseUShort();\n        var rightIndex = p.parseUShort();\n        var value = p.parseShort();\n        pairs[leftIndex + ',' + rightIndex] = value;\n    }\n    return pairs;\n}\n\nfunction parseMacKernTable(p) {\n    var pairs = {};\n    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n    // Skip the rest.\n    p.skip('uShort');\n    var nTables = p.parseULong();\n    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n    if (nTables > 1) {\n        console.warn('Only the first kern subtable is supported.');\n    }\n    p.skip('uLong');\n    var coverage = p.parseUShort();\n    var subtableVersion = coverage & 0xFF;\n    p.skip('uShort');\n    if (subtableVersion === 0) {\n        var nPairs = p.parseUShort();\n        // Skip searchRange, entrySelector, rangeShift.\n        p.skip('uShort', 3);\n        for (var i = 0; i < nPairs; i += 1) {\n            var leftIndex = p.parseUShort();\n            var rightIndex = p.parseUShort();\n            var value = p.parseShort();\n            pairs[leftIndex + ',' + rightIndex] = value;\n        }\n    }\n    return pairs;\n}\n\n// Parse the `kern` table which contains kerning pairs.\nfunction parseKernTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseUShort();\n    if (tableVersion === 0) {\n        return parseWindowsKernTable(p);\n    } else if (tableVersion === 1) {\n        return parseMacKernTable(p);\n    } else {\n        throw new Error('Unsupported kern table version (' + tableVersion + ').');\n    }\n}\n\nvar kern = { parse: parseKernTable };\n\n// The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n// relative to the beginning of the glyphData table.\n// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n// version where offsets are stored as uLongs. The `head` table specifies which version to use\n// (under indexToLocFormat).\nfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n    var p = new parse.Parser(data, start);\n    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    var glyphOffsets = [];\n    for (var i = 0; i < numGlyphs + 1; i += 1) {\n        var glyphOffset = parseFn.call(p);\n        if (shortVersion) {\n            // The short table version stores the actual offset divided by 2.\n            glyphOffset *= 2;\n        }\n\n        glyphOffsets.push(glyphOffset);\n    }\n\n    return glyphOffsets;\n}\n\nvar loca = { parse: parseLocaTable };\n\n// opentype.js\n\n/**\n * The opentype library.\n * @namespace opentype\n */\n\n// File loaders /////////////////////////////////////////////////////////\n/**\n * Loads a font from a file. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} path - The path of the file\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromFile(path, callback) {\n    var fs = require('fs');\n    fs.readFile(path, function(err, buffer) {\n        if (err) {\n            return callback(err.message);\n        }\n\n        callback(null, nodeBufferToArrayBuffer(buffer));\n    });\n}\n/**\n * Loads a font from a URL. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} url - The URL of the font file.\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromUrl(url, callback) {\n    var request = new XMLHttpRequest();\n    request.open('get', url, true);\n    request.responseType = 'arraybuffer';\n    request.onload = function() {\n        if (request.response) {\n            return callback(null, request.response);\n        } else {\n            return callback('Font could not be loaded: ' + request.statusText);\n        }\n    };\n\n    request.onerror = function () {\n        callback('Font could not be loaded');\n    };\n\n    request.send();\n}\n\n// Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseOpenTypeTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 12;\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var checksum = parse.getULong(data, p + 4);\n        var offset = parse.getULong(data, p + 8);\n        var length = parse.getULong(data, p + 12);\n        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});\n        p += 16;\n    }\n\n    return tableEntries;\n}\n\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseWOFFTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 44; // offset to the first table directory entry.\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var offset = parse.getULong(data, p + 4);\n        var compLength = parse.getULong(data, p + 8);\n        var origLength = parse.getULong(data, p + 12);\n        var compression = (void 0);\n        if (compLength < origLength) {\n            compression = 'WOFF';\n        } else {\n            compression = false;\n        }\n\n        tableEntries.push({tag: tag, offset: offset, compression: compression,\n            compressedLength: compLength, length: origLength});\n        p += 20;\n    }\n\n    return tableEntries;\n}\n\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */\n\n/**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */\nfunction uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === 'WOFF') {\n        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n        var outBuffer = new Uint8Array(tableEntry.length);\n        tinyInflate(inBuffer, outBuffer);\n        if (outBuffer.byteLength !== tableEntry.length) {\n            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\\'t match recorded length');\n        }\n\n        var view = new DataView(outBuffer.buffer, 0);\n        return {data: view, offset: 0};\n    } else {\n        return {data: data, offset: tableEntry.offset};\n    }\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @param  {Object} opt - options for parsing\n * @return {opentype.Font}\n */\nfunction parseBuffer(buffer, opt) {\n    opt = (opt === undefined || opt === null) ?  {} : opt;\n\n    var indexToLocFormat;\n    var ltagTable;\n\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    var font = new Font({empty: true});\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    var data = new DataView(buffer, 0);\n    var numTables;\n    var tableEntries = [];\n    var signature = parse.getTag(data, 0);\n    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n        font.outlinesFormat = 'truetype';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'OTTO') {\n        font.outlinesFormat = 'cff';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'wOFF') {\n        var flavor = parse.getTag(data, 4);\n        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n            font.outlinesFormat = 'truetype';\n        } else if (flavor === 'OTTO') {\n            font.outlinesFormat = 'cff';\n        } else {\n            throw new Error('Unsupported OpenType flavor ' + signature);\n        }\n\n        numTables = parse.getUShort(data, 12);\n        tableEntries = parseWOFFTableEntries(data, numTables);\n    } else {\n        throw new Error('Unsupported OpenType signature ' + signature);\n    }\n\n    var cffTableEntry;\n    var fvarTableEntry;\n    var glyfTableEntry;\n    var gdefTableEntry;\n    var gposTableEntry;\n    var gsubTableEntry;\n    var hmtxTableEntry;\n    var kernTableEntry;\n    var locaTableEntry;\n    var nameTableEntry;\n    var metaTableEntry;\n    var p;\n\n    for (var i = 0; i < numTables; i += 1) {\n        var tableEntry = tableEntries[i];\n        var table = (void 0);\n        switch (tableEntry.tag) {\n            case 'cmap':\n                table = uncompressTable(data, tableEntry);\n                font.tables.cmap = cmap.parse(table.data, table.offset);\n                font.encoding = new CmapEncoding(font.tables.cmap);\n                break;\n            case 'cvt ' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                break;\n            case 'fvar':\n                fvarTableEntry = tableEntry;\n                break;\n            case 'fpgm' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.fpgm = p.parseByteList(tableEntry.length);\n                break;\n            case 'head':\n                table = uncompressTable(data, tableEntry);\n                font.tables.head = head.parse(table.data, table.offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n            case 'hhea':\n                table = uncompressTable(data, tableEntry);\n                font.tables.hhea = hhea.parse(table.data, table.offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n            case 'hmtx':\n                hmtxTableEntry = tableEntry;\n                break;\n            case 'ltag':\n                table = uncompressTable(data, tableEntry);\n                ltagTable = ltag.parse(table.data, table.offset);\n                break;\n            case 'maxp':\n                table = uncompressTable(data, tableEntry);\n                font.tables.maxp = maxp.parse(table.data, table.offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n            case 'name':\n                nameTableEntry = tableEntry;\n                break;\n            case 'OS/2':\n                table = uncompressTable(data, tableEntry);\n                font.tables.os2 = os2.parse(table.data, table.offset);\n                break;\n            case 'post':\n                table = uncompressTable(data, tableEntry);\n                font.tables.post = post.parse(table.data, table.offset);\n                font.glyphNames = new GlyphNames(font.tables.post);\n                break;\n            case 'prep' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.prep = p.parseByteList(tableEntry.length);\n                break;\n            case 'glyf':\n                glyfTableEntry = tableEntry;\n                break;\n            case 'loca':\n                locaTableEntry = tableEntry;\n                break;\n            case 'CFF ':\n                cffTableEntry = tableEntry;\n                break;\n            case 'kern':\n                kernTableEntry = tableEntry;\n                break;\n            case 'GDEF':\n                gdefTableEntry = tableEntry;\n                break;\n            case 'GPOS':\n                gposTableEntry = tableEntry;\n                break;\n            case 'GSUB':\n                gsubTableEntry = tableEntry;\n                break;\n            case 'meta':\n                metaTableEntry = tableEntry;\n                break;\n        }\n    }\n\n    var nameTable = uncompressTable(data, nameTableEntry);\n    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);\n    font.names = font.tables.name;\n\n    if (glyfTableEntry && locaTableEntry) {\n        var shortVersion = indexToLocFormat === 0;\n        var locaTable = uncompressTable(data, locaTableEntry);\n        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n        var glyfTable = uncompressTable(data, glyfTableEntry);\n        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);\n    } else if (cffTableEntry) {\n        var cffTable = uncompressTable(data, cffTableEntry);\n        cff.parse(cffTable.data, cffTable.offset, font, opt);\n    } else {\n        throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n    }\n\n    var hmtxTable = uncompressTable(data, hmtxTableEntry);\n    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);\n    addGlyphNames(font, opt);\n\n    if (kernTableEntry) {\n        var kernTable = uncompressTable(data, kernTableEntry);\n        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n    } else {\n        font.kerningPairs = {};\n    }\n\n    if (gdefTableEntry) {\n        var gdefTable = uncompressTable(data, gdefTableEntry);\n        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);\n    }\n\n    if (gposTableEntry) {\n        var gposTable = uncompressTable(data, gposTableEntry);\n        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n        font.position.init();\n    }\n\n    if (gsubTableEntry) {\n        var gsubTable = uncompressTable(data, gsubTableEntry);\n        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n    }\n\n    if (fvarTableEntry) {\n        var fvarTable = uncompressTable(data, fvarTableEntry);\n        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n    }\n\n    if (metaTableEntry) {\n        var metaTable = uncompressTable(data, metaTableEntry);\n        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n        font.metas = font.tables.meta;\n    }\n\n    return font;\n}\n\n/**\n * Asynchronously load the font from a URL or a filesystem. When done, call the callback\n * with two arguments `(err, font)`. The `err` will be null on success,\n * the `font` is a Font object.\n * We use the node.js callback convention so that\n * opentype.js can integrate with frameworks like async.js.\n * @alias opentype.load\n * @param  {string} url - The URL of the font to load.\n * @param  {Function} callback - The callback.\n */\nfunction load(url, callback, opt) {\n    opt = (opt === undefined || opt === null) ?  {} : opt;\n    var isNode = typeof window === 'undefined';\n    var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;\n\n    return new Promise(function (resolve, reject) {\n        loadFn(url, function(err, arrayBuffer) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                } else {\n                    reject(err);\n                }\n            }\n            var font;\n            try {\n                font = parseBuffer(arrayBuffer, opt);\n            } catch (e) {\n                if (callback) {\n                    return callback(e, null);\n                } else {\n                    reject(e);\n                }\n            }\n            if (callback) {\n                return callback(null, font);\n            } else {\n                resolve(font);\n            }\n        });\n    });\n}\n\n/**\n * Synchronously load the font from a URL or file.\n * When done, returns the font object or throws an error.\n * @alias opentype.loadSync\n * @param  {string} url - The URL of the font to load.\n * @param  {Object} opt - opt.lowMemory\n * @return {opentype.Font}\n */\nfunction loadSync(url, opt) {\n    var fs = require('fs');\n    var buffer = fs.readFileSync(url);\n    return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);\n}\n\nvar opentype = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tFont: Font,\n\tGlyph: Glyph,\n\tPath: Path,\n\tBoundingBox: BoundingBox,\n\t_parse: parse,\n\tparse: parseBuffer,\n\tload: load,\n\tloadSync: loadSync\n});\n\nexport default opentype;\nexport { BoundingBox, Font, Glyph, Path, parse as _parse, load, loadSync, parseBuffer as parse };\n//# sourceMappingURL=opentype.module.js.map\n","import { DisplayBitmap } from \"../DisplayManager.ts\";\nimport { concatenateArrayBuffers } from \"./ArrayBufferUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { imageToBitmap, quantizeCanvas } from \"./DisplayBitmapUtils.ts\";\nimport {\n  BaseOffsetPositionDisplayContextCommand,\n  DisplayContextCommand,\n  DrawDisplayBitmapCommand,\n  serializeContextCommands,\n} from \"./DisplayContextCommand.ts\";\nimport { DisplayManagerInterface } from \"./DisplayManagerInterface.ts\";\nimport opentype, { Glyph } from \"opentype.js\";\n\nconst _console = createConsole(\"DisplaySpriteSheetUtils\", { log: true });\n\nexport type DisplaySpritePaletteSwap = {\n  name: string;\n  numberOfColors: number;\n  spriteColorIndices: number[];\n};\nexport type DisplaySprite = {\n  name: string;\n  width: number;\n  height: number;\n  paletteSwaps?: DisplaySpritePaletteSwap[];\n  commands: DisplayContextCommand[];\n};\nexport type DisplaySpriteSheetPaletteSwap = {\n  name: string;\n  numberOfColors: number;\n  spriteColorIndices: number[];\n};\nexport type DisplaySpriteSheetPalette = {\n  name: string;\n  numberOfColors: number;\n  colors: string[];\n  opacities?: number[];\n};\nexport type DisplaySpriteSheet = {\n  name: string;\n  palettes?: DisplaySpriteSheetPalette[];\n  paletteSwaps?: DisplaySpriteSheetPaletteSwap[];\n  sprites: DisplaySprite[];\n};\n\nexport function serializeSpriteSheet(\n  displayManager: DisplayManagerInterface,\n  spriteSheet: DisplaySpriteSheet\n) {\n  const { name, sprites } = spriteSheet;\n  _console.log(`serializing ${name} spriteSheet`, spriteSheet);\n\n  const numberOfSprites = sprites.length;\n  const numberOfSpritesDataView = new DataView(new ArrayBuffer(2));\n  numberOfSpritesDataView.setUint16(0, numberOfSprites, true);\n\n  const spritePayloads = sprites.map((sprite, index) => {\n    const commandsData = serializeContextCommands(\n      displayManager,\n      sprite.commands\n    );\n    const dataView = new DataView(new ArrayBuffer(3 * 2));\n    dataView.setUint16(0, sprite.width, true);\n    dataView.setUint16(2, sprite.height, true);\n    dataView.setUint16(4, commandsData.byteLength, true);\n    const serializedSprite = concatenateArrayBuffers(dataView, commandsData);\n    _console.log(\"serializedSprite\", sprite, serializedSprite);\n    return serializedSprite;\n  });\n  const spriteOffsetsDataView = new DataView(\n    new ArrayBuffer(sprites.length * 2)\n  );\n  let offset =\n    numberOfSpritesDataView.byteLength + spriteOffsetsDataView.byteLength;\n  spritePayloads.forEach((spritePayload, index) => {\n    //_console.log(\"spritePayloads\", index, offset, spritePayload);\n    spriteOffsetsDataView.setUint16(index * 2, offset, true);\n    offset += spritePayload.byteLength;\n  });\n\n  // [numberOfSprites, ...spriteOffsets, ...[width, height, commands]]\n  const serializedSpriteSheet = concatenateArrayBuffers(\n    numberOfSpritesDataView,\n    spriteOffsetsDataView,\n    spritePayloads\n  );\n  _console.log(\"serializedSpriteSheet\", serializedSpriteSheet);\n  return serializedSpriteSheet;\n}\n\nexport function parseSpriteSheet(dataView: DataView) {\n  // FILL\n}\n\ntype FontToSpriteSheetOptions = {\n  stroke?: boolean;\n  strokeWidth?: number;\n  unicodeOnly?: boolean;\n};\nconst defaultFontToSpriteSheetOptions: FontToSpriteSheetOptions = {\n  stroke: false,\n  strokeWidth: 1,\n  unicodeOnly: true,\n};\nexport async function fontToSpriteSheet(\n  displayManager: DisplayManagerInterface,\n  arrayBuffer: ArrayBuffer,\n  fontSize: number,\n  spriteSheetName?: string,\n  options: FontToSpriteSheetOptions = defaultFontToSpriteSheetOptions\n) {\n  _console.assertTypeWithError(fontSize, \"number\");\n\n  const font = opentype.parse(arrayBuffer);\n  const fontScale = (1 / font.unitsPerEm) * fontSize;\n\n  _console.log(\"font\", font);\n\n  spriteSheetName = spriteSheetName || font.getEnglishName(\"fullName\");\n  const spriteSheet: DisplaySpriteSheet = {\n    name: spriteSheetName,\n    sprites: [],\n  };\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\")!;\n\n  let minSpriteY = Infinity;\n  let maxSpriteY = -Infinity;\n\n  const glyphs: Glyph[] = [];\n  for (let index = 0; index < font.glyphs.length; index++) {\n    const glyph = font.glyphs.get(index);\n    if (options.unicodeOnly) {\n      if (glyph.unicode == undefined) {\n        continue;\n      }\n    }\n\n    const bbox = glyph.getBoundingBox();\n    minSpriteY = Math.min(minSpriteY, bbox.y1 * fontScale);\n    maxSpriteY = Math.max(maxSpriteY, bbox.y2 * fontScale);\n\n    glyphs.push(glyph);\n  }\n\n  const maxSpriteHeight = maxSpriteY - minSpriteY;\n\n  _console.log({ minSpriteY, maxSpriteY, maxSpriteHeight });\n\n  for (let i = 0; i < glyphs.length; i++) {\n    const glyph = glyphs[i];\n\n    let name = glyph.name;\n    if (options.unicodeOnly) {\n      name = String.fromCharCode(glyph.unicode!);\n    }\n    if (typeof name != \"string\") {\n      continue;\n    }\n\n    const bbox = glyph.getBoundingBox();\n    const bitmapWidth = Math.round((bbox.x2 - bbox.x1) * fontScale);\n    const bitmapHeight = Math.round((bbox.y2 - bbox.y1) * fontScale);\n\n    const spriteWidth = Math.round(\n      Math.max(Math.max(bbox.x2, bbox.x2 - bbox.x1), glyph.advanceWidth || 0) *\n        fontScale\n    );\n    const spriteHeight = maxSpriteHeight;\n\n    const commands: DisplayContextCommand[] = [];\n    if (bitmapWidth > 0 && bitmapHeight > 0) {\n      canvas.width = bitmapWidth;\n      canvas.height = bitmapHeight;\n      ctx.imageSmoothingEnabled = false;\n\n      ctx.fillStyle = \"black\";\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      const path = glyph.getPath(\n        -bbox.x1 * fontScale,\n        bbox.y2 * fontScale,\n        fontSize\n      );\n      if (options.stroke) {\n        path.stroke = \"white\";\n        path.strokeWidth = options.strokeWidth || 1;\n      } else {\n        path.fill = \"white\";\n      }\n      path.draw(ctx);\n      const { colorIndices } = await quantizeCanvas(canvas, ctx, 2, [\n        \"#000000\",\n        \"#ffffff\",\n      ]);\n      const bitmap: DisplayBitmap = {\n        width: bitmapWidth,\n        height: bitmapHeight,\n        numberOfColors: 2,\n        pixels: colorIndices,\n      };\n\n      commands.push({\n        type: \"selectBitmapColor\",\n        bitmapColorIndex: 1,\n        colorIndex: 1,\n      });\n      if (false) {\n        // debugging\n        commands.push({\n          type: \"selectFillColor\",\n          fillColorIndex: 2,\n        });\n        commands.push({\n          type: \"drawRect\",\n          offsetX: 0,\n          offsetY: 0,\n          width: spriteWidth,\n          height: spriteHeight,\n        });\n      }\n\n      let bitmapX = bbox.x1 * fontScale;\n      let bitmapY =\n        (spriteHeight - bitmapHeight) / 2 - (bbox.y1 * fontScale - minSpriteY);\n      commands.push({\n        type: \"drawBitmap\",\n        offsetX: bitmapX,\n        offsetY: bitmapY,\n        bitmap,\n      });\n    }\n\n    const sprite: DisplaySprite = {\n      name,\n      commands,\n      width: spriteWidth,\n      height: spriteHeight,\n    };\n\n    spriteSheet.sprites.push(sprite);\n  }\n\n  return spriteSheet;\n}\n\nexport function reduceSpriteSheet(\n  spriteSheet: DisplaySpriteSheet,\n  newSpriteSheetName: string\n) {\n  // FILL - reduce sprites to just those included in spriteNames or spriteStrings (multiple names)\n}\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\nimport {\n  clamp,\n  degToRad,\n  normalizeRadians,\n  Vector2,\n} from \"./utils/MathUtils.ts\";\nimport { rgbToHex, stringToRGB } from \"./utils/ColorUtils.ts\";\nimport DisplayContextStateHelper from \"./utils/DisplayContextStateHelper.ts\";\nimport {\n  assertValidColor,\n  assertValidDisplayBrightness,\n  assertValidSegmentCap,\n  DisplayScaleDirection,\n  DisplayBitmapScaleDirectionToCommandType,\n  DisplayColorRGB,\n  DisplayCropDirection,\n  DisplayCropDirections,\n  DisplayCropDirectionToCommandType,\n  DisplayCropDirectionToStateKey,\n  DisplayRotationCropDirectionToCommandType,\n  DisplayRotationCropDirectionToStateKey,\n  maxDisplayScale,\n  roundScale,\n  DisplaySpriteScaleDirectionToCommandType,\n  minDisplayScale,\n} from \"./utils/DisplayUtils.ts\";\nimport { DisplaySpriteSheet } from \"./BS.ts\";\nimport {\n  assertValidBitmapPixels,\n  drawBitmapHeaderLength,\n  getBitmapNumberOfBytes,\n  imageToBitmap,\n  quantizeImage,\n  resizeAndQuantizeImage,\n} from \"./utils/DisplayBitmapUtils.ts\";\nimport {\n  DisplayContextState,\n  DisplayContextStateKey,\n  DisplaySegmentCap,\n  PartialDisplayContextState,\n} from \"./utils/DisplayContextState.ts\";\nimport {\n  DisplayContextCommand,\n  DisplayContextCommandType,\n  DisplayContextCommandTypes,\n  serializeContextCommand,\n} from \"./utils/DisplayContextCommand.ts\";\nimport {\n  assertAnySelectedSpriteSheet,\n  assertLoadedSpriteSheet,\n  assertSelectedSpriteSheet,\n  assertSprite,\n  assertSpritePaletteSwap,\n  assertSpriteSheetPalette,\n  assertSpriteSheetPaletteSwap,\n  DisplayManagerInterface,\n  getSprite,\n  getSpritePaletteSwap,\n  getSpriteSheetPalette,\n  getSpriteSheetPaletteSwap,\n  runDisplayContextCommand,\n  runDisplayContextCommands,\n  selectSpritePaletteSwap,\n  selectSpriteSheetPalette,\n  selectSpriteSheetPaletteSwap,\n} from \"./utils/DisplayManagerInterface.ts\";\nimport { SendFileCallback } from \"./FileTransferManager.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport {\n  DisplaySprite,\n  DisplaySpritePaletteSwap,\n  DisplaySpriteSheetPalette,\n  DisplaySpriteSheetPaletteSwap,\n  fontToSpriteSheet,\n  serializeSpriteSheet,\n} from \"./utils/DisplaySpriteSheetUtils.ts\";\n\nconst _console = createConsole(\"DisplayManager\", { log: true });\n\nexport const DefaultNumberOfDisplayColors = 16;\n\nexport const DisplayCommands = [\"sleep\", \"wake\"] as const;\nexport type DisplayCommand = (typeof DisplayCommands)[number];\n\nexport const DisplayStatuses = [\"awake\", \"asleep\"] as const;\nexport type DisplayStatus = (typeof DisplayStatuses)[number];\n\nexport const DisplayInformationTypes = [\n  \"type\",\n  \"width\",\n  \"height\",\n  \"pixelDepth\",\n] as const;\nexport type DisplayInformationType = (typeof DisplayInformationTypes)[number];\n\nexport const DisplayTypes = [\n  \"none\",\n  \"generic\",\n  \"monocularLeft\",\n  \"monocularRight\",\n  \"binocular\",\n] as const;\nexport type DisplayType = (typeof DisplayTypes)[number];\n\nexport const DisplayPixelDepths = [\"1\", \"2\", \"4\"] as const;\nexport type DisplayPixelDepth = (typeof DisplayPixelDepths)[number];\n\nexport const DisplayBrightnesses = [\n  \"veryLow\",\n  \"low\",\n  \"medium\",\n  \"high\",\n  \"veryHigh\",\n] as const;\nexport type DisplayBrightness = (typeof DisplayBrightnesses)[number];\n\nexport const DisplayMessageTypes = [\n  \"isDisplayAvailable\",\n  \"displayStatus\",\n  \"displayInformation\",\n  \"displayCommand\",\n  \"getDisplayBrightness\",\n  \"setDisplayBrightness\",\n  \"displayContextCommands\",\n  \"displayReady\",\n  \"getSpriteSheetName\",\n  \"setSpriteSheetName\",\n  \"spriteSheetIndex\",\n] as const;\nexport type DisplayMessageType = (typeof DisplayMessageTypes)[number];\n\nexport type DisplaySize = {\n  width: number;\n  height: number;\n};\nexport type DisplayInformation = {\n  type: DisplayType;\n  width: number;\n  height: number;\n  pixelDepth: DisplayPixelDepth;\n};\n\nexport type DisplayBitmapColorPair = {\n  bitmapColorIndex: number;\n  colorIndex: number;\n};\n\nexport type DisplaySpriteColorPair = {\n  spriteColorIndex: number;\n  colorIndex: number;\n};\n\nexport const DisplayInformationValues = {\n  type: DisplayTypes,\n  pixelDepth: DisplayPixelDepths,\n};\n\nexport const RequiredDisplayMessageTypes: DisplayMessageType[] = [\n  \"isDisplayAvailable\",\n  \"displayInformation\",\n  \"displayStatus\",\n  \"getDisplayBrightness\",\n] as const;\n\nexport const DisplayEventTypes = [\n  ...DisplayMessageTypes,\n  \"displayContextState\",\n  \"displayColor\",\n  \"displayColorOpacity\",\n  \"displayOpacity\",\n  \"displaySpriteSheetUploadStart\",\n  \"displaySpriteSheetUploadProgress\",\n  \"displaySpriteSheetUploadComplete\",\n] as const;\nexport type DisplayEventType = (typeof DisplayEventTypes)[number];\n\nexport interface DisplayEventMessages {\n  isDisplayAvailable: { isDisplayAvailable: boolean };\n  displayStatus: {\n    displayStatus: DisplayStatus;\n    previousDisplayStatus: DisplayStatus;\n  };\n  displayInformation: {\n    displayInformation: DisplayInformation;\n  };\n  getDisplayBrightness: {\n    displayBrightness: DisplayBrightness;\n  };\n  displayContextState: {\n    displayContextState: DisplayContextState;\n    differences: DisplayContextStateKey[];\n  };\n  displayColor: {\n    colorIndex: number;\n    colorRGB: DisplayColorRGB;\n    colorHex: string;\n  };\n  displayColorOpacity: {\n    opacity: number;\n    colorIndex: number;\n  };\n  displayOpacity: {\n    opacity: number;\n  };\n  displayReady: {};\n  getSpriteSheetName: {\n    spriteSheetName: string;\n  };\n\n  displaySpriteSheetUploadStart: {\n    spriteSheetName: string;\n    spriteSheet: DisplaySpriteSheet;\n  };\n  displaySpriteSheetUploadProgress: {\n    spriteSheetName: string;\n    spriteSheet: DisplaySpriteSheet;\n    progress: number;\n  };\n  displaySpriteSheetUploadComplete: {\n    spriteSheetName: string;\n    spriteSheet: DisplaySpriteSheet;\n  };\n}\n\nexport type DisplayEventDispatcher = EventDispatcher<\n  Device,\n  DisplayEventType,\n  DisplayEventMessages\n>;\nexport type SendDisplayMessageCallback =\n  SendMessageCallback<DisplayMessageType>;\n\nexport const MinSpriteSheetNameLength = 1;\nexport const MaxSpriteSheetNameLength = 30;\n\nexport type DisplayBitmap = {\n  width: number;\n  height: number;\n  numberOfColors: number;\n  pixels: number[];\n};\n\nclass DisplayManager implements DisplayManagerInterface {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendDisplayMessageCallback;\n\n  eventDispatcher!: DisplayEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required display information\");\n    const messages = RequiredDisplayMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // IS DISPLAY AVAILABLE\n  #isAvailable = false;\n  get isAvailable() {\n    return this.#isAvailable;\n  }\n\n  #assertDisplayIsAvailable() {\n    _console.assertWithError(this.#isAvailable, \"display is not available\");\n  }\n\n  #parseIsDisplayAvailable(dataView: DataView) {\n    const newIsDisplayAvailable = dataView.getUint8(0) == 1;\n    this.#isAvailable = newIsDisplayAvailable;\n    _console.log({ isDisplayAvailable: this.#isAvailable });\n    this.#dispatchEvent(\"isDisplayAvailable\", {\n      isDisplayAvailable: this.#isAvailable,\n    });\n  }\n\n  // DISPLAY CONTEXT STATE\n  #contextStateHelper = new DisplayContextStateHelper();\n  get contextState() {\n    return this.#contextStateHelper.state;\n  }\n  #onContextStateUpdate(differences: DisplayContextStateKey[]) {\n    this.#dispatchEvent(\"displayContextState\", {\n      displayContextState: structuredClone(this.contextState),\n      differences,\n    });\n  }\n  async setContextState(\n    newState: PartialDisplayContextState,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.diff(newState);\n    if (differences.length == 0) {\n      return;\n    }\n    differences.forEach((difference) => {\n      switch (difference) {\n        case \"fillColorIndex\":\n          this.selectFillColor(newState.fillColorIndex!);\n          break;\n        case \"lineColorIndex\":\n          this.selectLineColor(newState.lineColorIndex!);\n          break;\n        case \"lineWidth\":\n          this.setLineWidth(newState.lineWidth!);\n          break;\n        case \"rotation\":\n          this.setRotation(newState.rotation!, true);\n          break;\n        case \"segmentStartCap\":\n          this.setSegmentStartCap(newState.segmentStartCap!);\n          break;\n        case \"segmentEndCap\":\n          this.setSegmentEndCap(newState.segmentEndCap!);\n          break;\n        case \"segmentStartRadius\":\n          this.setSegmentStartRadius(newState.segmentStartRadius!);\n          break;\n        case \"segmentEndRadius\":\n          this.setSegmentEndRadius(newState.segmentEndRadius!);\n          break;\n        case \"cropTop\":\n          this.setCropTop(newState.cropTop!);\n          break;\n        case \"cropRight\":\n          this.setCropRight(newState.cropRight!);\n          break;\n        case \"cropBottom\":\n          this.setCropBottom(newState.cropBottom!);\n          break;\n        case \"cropLeft\":\n          this.setCropLeft(newState.cropLeft!);\n          break;\n        case \"rotationCropTop\":\n          this.setRotationCropTop(newState.rotationCropTop!);\n          break;\n        case \"rotationCropRight\":\n          this.setRotationCropRight(newState.rotationCropRight!);\n          break;\n        case \"rotationCropBottom\":\n          this.setRotationCropBottom(newState.rotationCropBottom!);\n          break;\n        case \"rotationCropLeft\":\n          this.setRotationCropLeft(newState.rotationCropLeft!);\n          break;\n        case \"bitmapColorIndices\":\n          const bitmapColors: DisplayBitmapColorPair[] = [];\n          newState.bitmapColorIndices!.forEach(\n            (colorIndex, bitmapColorIndex) => {\n              bitmapColors.push({ bitmapColorIndex, colorIndex });\n            }\n          );\n          this.selectBitmapColors(bitmapColors);\n          break;\n        case \"bitmapScaleX\":\n          this.setBitmapScaleX(newState.bitmapScaleX!);\n          break;\n        case \"bitmapScaleY\":\n          this.setBitmapScaleY(newState.bitmapScaleY!);\n          break;\n        case \"spriteColorIndices\":\n          const spriteColors: DisplaySpriteColorPair[] = [];\n          newState.spriteColorIndices!.forEach(\n            (colorIndex, spriteColorIndex) => {\n              spriteColors.push({ spriteColorIndex, colorIndex });\n            }\n          );\n          this.selectSpriteColors(spriteColors);\n          break;\n        case \"spriteScaleX\":\n          this.setSpriteScaleX(newState.spriteScaleX!);\n          break;\n        case \"spriteScaleY\":\n          this.setSpriteScaleY(newState.spriteScaleY!);\n          break;\n      }\n    });\n    if (sendImmediately) {\n      await this.#sendContextCommands();\n    }\n  }\n\n  // DISPLAY STATUS\n  #displayStatus!: DisplayStatus;\n  get displayStatus() {\n    return this.#displayStatus;\n  }\n  get isDisplayAwake() {\n    return this.#displayStatus == \"awake\";\n  }\n  #parseDisplayStatus(dataView: DataView) {\n    const displayStatusIndex = dataView.getUint8(0);\n    const newDisplayStatus = DisplayStatuses[displayStatusIndex];\n    this.#updateDisplayStatus(newDisplayStatus);\n  }\n  #updateDisplayStatus(newDisplayStatus: DisplayStatus) {\n    _console.assertEnumWithError(newDisplayStatus, DisplayStatuses);\n    if (newDisplayStatus == this.#displayStatus) {\n      _console.log(`redundant displayStatus ${newDisplayStatus}`);\n      return;\n    }\n    const previousDisplayStatus = this.#displayStatus;\n    this.#displayStatus = newDisplayStatus;\n    _console.log(`updated displayStatus to \"${this.displayStatus}\"`);\n    this.#dispatchEvent(\"displayStatus\", {\n      displayStatus: this.displayStatus,\n      previousDisplayStatus,\n    });\n  }\n\n  // DISPLAY COMMAND\n  async #sendDisplayCommand(\n    command: DisplayCommand,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(command, DisplayCommands);\n    _console.log(`sending display command \"${command}\"`);\n\n    const promise = this.waitForEvent(\"displayStatus\");\n    _console.log(`setting command \"${command}\"`);\n    const commandEnum = DisplayCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"displayCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  #assertIsAwake() {\n    _console.assertWithError(\n      this.#displayStatus == \"awake\",\n      `display is not awake - currently ${this.#displayStatus}`\n    );\n  }\n  #assertIsNotAwake() {\n    _console.assertWithError(\n      this.#displayStatus != \"awake\",\n      `display is awake`\n    );\n  }\n\n  async wake() {\n    this.#assertIsNotAwake();\n    await this.#sendDisplayCommand(\"wake\");\n  }\n  async sleep() {\n    this.#assertIsAwake();\n    await this.#sendDisplayCommand(\"sleep\");\n  }\n  async toggle() {\n    switch (this.displayStatus) {\n      case \"asleep\":\n        this.wake();\n        break;\n      case \"awake\":\n        this.sleep();\n        break;\n    }\n  }\n\n  get numberOfColors() {\n    return 2 ** Number(this.pixelDepth!);\n  }\n\n  // INFORMATION\n  #displayInformation?: DisplayInformation;\n  get displayInformation() {\n    return this.#displayInformation;\n  }\n\n  get pixelDepth() {\n    return this.#displayInformation?.pixelDepth!;\n  }\n  get width() {\n    return this.#displayInformation?.width!;\n  }\n  get height() {\n    return this.#displayInformation?.width!;\n  }\n  get size() {\n    return {\n      width: this.width!,\n      height: this.height!,\n    };\n  }\n  get type() {\n    return this.#displayInformation?.type!;\n  }\n\n  #parseDisplayInformation(dataView: DataView) {\n    // @ts-expect-error\n    const parsedDisplayInformation: DisplayInformation = {};\n\n    let byteOffset = 0;\n    while (byteOffset < dataView.byteLength) {\n      const displayInformationTypeIndex = dataView.getUint8(byteOffset++);\n      const displayInformationType =\n        DisplayInformationTypes[displayInformationTypeIndex];\n      _console.assertWithError(\n        displayInformationType,\n        `invalid displayInformationTypeIndex ${displayInformationType}`\n      );\n      _console.log({ displayInformationType });\n\n      switch (displayInformationType) {\n        case \"width\":\n        case \"height\":\n          {\n            const value = dataView.getUint16(byteOffset, true);\n            parsedDisplayInformation[displayInformationType] = value;\n            byteOffset += 2;\n          }\n          break;\n        case \"pixelDepth\":\n        case \"type\":\n          {\n            const values = DisplayInformationValues[displayInformationType];\n            let rawValue = dataView.getUint8(byteOffset++);\n            const value = values[rawValue];\n            _console.assertEnumWithError(value, values);\n            // @ts-expect-error\n            parsedDisplayInformation[displayInformationType] = value;\n          }\n          break;\n      }\n    }\n\n    _console.log({ parsedDisplayInformation });\n    const missingDisplayInformationType = DisplayInformationTypes.find(\n      (type) => !(type in parsedDisplayInformation)\n    );\n    _console.assertWithError(\n      !missingDisplayInformationType,\n      `missingDisplayInformationType ${missingDisplayInformationType}`\n    );\n    this.#displayInformation = parsedDisplayInformation;\n    this.#colors = new Array(this.numberOfColors).fill(\"#000000\");\n    this.#opacities = new Array(this.numberOfColors).fill(1);\n    this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.#dispatchEvent(\"displayInformation\", {\n      displayInformation: this.#displayInformation,\n    });\n  }\n\n  // DISPLAY BRIGHTNESS\n  #brightness!: DisplayBrightness;\n  get brightness() {\n    return this.#brightness;\n  }\n\n  #parseDisplayBrightness(dataView: DataView) {\n    const newDisplayBrightnessEnum = dataView.getUint8(0);\n    const newDisplayBrightness = DisplayBrightnesses[newDisplayBrightnessEnum];\n    assertValidDisplayBrightness(newDisplayBrightness);\n\n    this.#brightness = newDisplayBrightness;\n    _console.log({ displayBrightness: this.#brightness });\n    this.#dispatchEvent(\"getDisplayBrightness\", {\n      displayBrightness: this.#brightness,\n    });\n  }\n\n  async setBrightness(\n    newDisplayBrightness: DisplayBrightness,\n    sendImmediately?: boolean\n  ) {\n    this.#assertDisplayIsAvailable();\n    assertValidDisplayBrightness(newDisplayBrightness);\n    if (this.brightness == newDisplayBrightness) {\n      _console.log(`redundant displayBrightness ${newDisplayBrightness}`);\n      return;\n    }\n    const newDisplayBrightnessEnum =\n      DisplayBrightnesses.indexOf(newDisplayBrightness);\n    const newDisplayBrightnessData = UInt8ByteBuffer(newDisplayBrightnessEnum);\n\n    const promise = this.waitForEvent(\"getDisplayBrightness\");\n    this.sendMessage(\n      [{ type: \"setDisplayBrightness\", data: newDisplayBrightnessData }],\n      sendImmediately\n    );\n    await promise;\n  }\n\n  // DISPLAY CONTEXT\n  #assertValidDisplayContextCommand(\n    displayContextCommand: DisplayContextCommandType\n  ) {\n    _console.assertEnumWithError(\n      displayContextCommand,\n      DisplayContextCommandTypes\n    );\n  }\n\n  get #maxCommandDataLength() {\n    return this.mtu - 7;\n  }\n  #displayContextCommandBuffers: ArrayBuffer[] = [];\n  async #sendDisplayContextCommand(\n    displayContextCommand: DisplayContextCommandType,\n    arrayBuffer?: ArrayBuffer,\n    sendImmediately?: boolean\n  ) {\n    this.#assertValidDisplayContextCommand(displayContextCommand);\n    _console.log(\n      \"sendDisplayContextCommand\",\n      { displayContextCommand, sendImmediately },\n      arrayBuffer\n    );\n    const displayContextCommandEnum = DisplayContextCommandTypes.indexOf(\n      displayContextCommand\n    );\n    const _arrayBuffer = concatenateArrayBuffers(\n      UInt8ByteBuffer(displayContextCommandEnum),\n      arrayBuffer\n    );\n    const newLength = this.#displayContextCommandBuffers.reduce(\n      (sum, buffer) => sum + buffer.byteLength,\n      _arrayBuffer.byteLength\n    );\n    if (newLength > this.#maxCommandDataLength) {\n      _console.log(\"displayContextCommandBuffers too full - sending now\");\n      await this.#sendContextCommands();\n    }\n    this.#displayContextCommandBuffers.push(_arrayBuffer);\n    if (sendImmediately) {\n      await this.#sendContextCommands();\n    }\n  }\n  async #sendContextCommands() {\n    if (this.#displayContextCommandBuffers.length == 0) {\n      return;\n    }\n    const data = concatenateArrayBuffers(this.#displayContextCommandBuffers);\n    _console.log(\n      `sending displayContextCommands`,\n      this.#displayContextCommandBuffers.slice(),\n      data\n    );\n    this.#displayContextCommandBuffers.length = 0;\n    await this.sendMessage([{ type: \"displayContextCommands\", data }], true);\n  }\n  async flushContextCommands() {\n    await this.#sendContextCommands();\n  }\n  async show(sendImmediately = true) {\n    _console.log(\"showDisplay\");\n    this.#isReady = false;\n    await this.#sendDisplayContextCommand(\"show\", undefined, sendImmediately);\n  }\n  async clear(sendImmediately = true) {\n    _console.log(\"clearDisplay\");\n    this.#isReady = false;\n    await this.#sendDisplayContextCommand(\"clear\", undefined, sendImmediately);\n  }\n\n  assertValidColorIndex(colorIndex: number) {\n    _console.assertRangeWithError(\n      \"colorIndex\",\n      colorIndex,\n      0,\n      this.numberOfColors\n    );\n  }\n  #colors: string[] = [];\n  get colors() {\n    return this.#colors;\n  }\n  async setColor(\n    colorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    let colorRGB: DisplayColorRGB;\n    if (typeof color == \"string\") {\n      colorRGB = stringToRGB(color);\n    } else {\n      colorRGB = color;\n    }\n    const colorHex = rgbToHex(colorRGB);\n    if (this.colors[colorIndex] == colorHex) {\n      _console.log(`redundant color #${colorIndex} ${colorHex}`);\n      return;\n    }\n\n    _console.log(`setting color #${colorIndex}`, colorRGB);\n    this.assertValidColorIndex(colorIndex);\n    assertValidColor(colorRGB);\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setUint8(0, colorIndex);\n    dataView.setUint8(1, colorRGB.r);\n    dataView.setUint8(2, colorRGB.g);\n    dataView.setUint8(3, colorRGB.b);\n    await this.#sendDisplayContextCommand(\n      \"setColor\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.colors[colorIndex] = colorHex;\n    this.#dispatchEvent(\"displayColor\", {\n      colorIndex,\n      colorRGB,\n      colorHex,\n    });\n  }\n  #opacities: number[] = [];\n  get opacities() {\n    return this.#opacities;\n  }\n  async setColorOpacity(\n    colorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"setColorOpacity\",\n      colorIndex,\n      opacity,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setColorOpacity\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#opacities[colorIndex] = opacity;\n    this.#dispatchEvent(\"displayColorOpacity\", { colorIndex, opacity });\n  }\n  async setOpacity(opacity: number, sendImmediately?: boolean) {\n    const dataView = serializeContextCommand(this, {\n      type: \"setOpacity\",\n      opacity,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setOpacity\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#opacities.fill(opacity);\n    this.#dispatchEvent(\"displayOpacity\", { opacity });\n  }\n\n  async saveContext(sendImmediately?: boolean) {\n    const dataView = serializeContextCommand(this, { type: \"saveContext\" });\n    await this.#sendDisplayContextCommand(\n      \"saveContext\",\n      dataView?.buffer,\n      sendImmediately\n    );\n  }\n  async restoreContext(sendImmediately?: boolean) {\n    const dataView = serializeContextCommand(this, { type: \"restoreContext\" });\n    await this.#sendDisplayContextCommand(\n      \"restoreContext\",\n      dataView?.buffer,\n      sendImmediately\n    );\n  }\n\n  async selectFillColor(fillColorIndex: number, sendImmediately?: boolean) {\n    this.assertValidColorIndex(fillColorIndex);\n    const differences = this.#contextStateHelper.update({\n      fillColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"selectFillColor\",\n      fillColorIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"selectFillColor\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async selectLineColor(lineColorIndex: number, sendImmediately?: boolean) {\n    this.assertValidColorIndex(lineColorIndex);\n    const differences = this.#contextStateHelper.update({\n      lineColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"selectLineColor\",\n      lineColorIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"selectLineColor\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  assertValidLineWidth(lineWidth: number) {\n    _console.assertRangeWithError(\"lineWidth\", lineWidth, 0, this.width);\n  }\n  async setLineWidth(lineWidth: number, sendImmediately?: boolean) {\n    this.assertValidLineWidth(lineWidth);\n    const differences = this.#contextStateHelper.update({\n      lineWidth,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"setLineWidth\",\n      lineWidth,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setLineWidth\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setRotation(\n    rotation: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    rotation = isRadians ? rotation : degToRad(rotation);\n    rotation = normalizeRadians(rotation);\n    isRadians = true;\n    const differences = this.#contextStateHelper.update({\n      rotation,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"setRotation\",\n      rotation,\n      isRadians,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setRotation\",\n      dataView.buffer,\n      sendImmediately\n    );\n\n    this.#onContextStateUpdate(differences);\n  }\n  async clearRotation(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotation: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, { type: \"clearRotation\" });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"clearRotation\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSegmentStartCap(\n    segmentStartCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentStartCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"setSegmentStartCap\",\n      segmentStartCap,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setSegmentStartCap\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndCap(\n    segmentEndCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentEndCap);\n    const differences = this.#contextStateHelper.update({\n      segmentEndCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"setSegmentEndCap\",\n      segmentEndCap,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setSegmentEndCap\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentCap(\n    segmentCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap: segmentCap,\n      segmentEndCap: segmentCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"setSegmentCap\",\n      segmentCap,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setSegmentCap\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSegmentStartRadius(\n    segmentStartRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"setSegmentStartRadius\",\n      segmentStartRadius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setSegmentStartRadius\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndRadius(\n    segmentEndRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentEndRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"setSegmentEndRadius\",\n      segmentEndRadius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setSegmentEndRadius\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentRadius(segmentRadius: number, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius: segmentRadius,\n      segmentEndRadius: segmentRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"setSegmentRadius\",\n      segmentRadius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"setSegmentRadius\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    crop = Math.max(0, crop);\n    const cropCommand = DisplayCropDirectionToCommandType[cropDirection];\n    const cropKey = DisplayCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // @ts-ignore\n    const dataView = serializeContextCommand(this, {\n      type: cropCommand,\n      [cropKey]: crop,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      cropCommand,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setCropTop(cropTop: number, sendImmediately?: boolean) {\n    await this.setCrop(\"top\", cropTop, sendImmediately);\n  }\n  async setCropRight(cropRight: number, sendImmediately?: boolean) {\n    await this.setCrop(\"right\", cropRight, sendImmediately);\n  }\n  async setCropBottom(cropBottom: number, sendImmediately?: boolean) {\n    await this.setCrop(\"bottom\", cropBottom, sendImmediately);\n  }\n  async setCropLeft(cropLeft: number, sendImmediately?: boolean) {\n    await this.setCrop(\"left\", cropLeft, sendImmediately);\n  }\n  async clearCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      cropTop: 0,\n      cropRight: 0,\n      cropBottom: 0,\n      cropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, { type: \"clearCrop\" });\n    await this.#sendDisplayContextCommand(\n      \"clearCrop\",\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setRotationCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    const cropCommand =\n      DisplayRotationCropDirectionToCommandType[cropDirection];\n    const cropKey = DisplayRotationCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // @ts-ignore\n    const dataView = serializeContextCommand(this, {\n      type: cropCommand,\n      [cropKey]: crop,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      cropCommand,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setRotationCropTop(rotationCropTop: number, sendImmediately?: boolean) {\n    await this.setRotationCrop(\"top\", rotationCropTop, sendImmediately);\n  }\n  async setRotationCropRight(\n    rotationCropRight: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"right\", rotationCropRight, sendImmediately);\n  }\n  async setRotationCropBottom(\n    rotationCropBottom: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"bottom\", rotationCropBottom, sendImmediately);\n  }\n  async setRotationCropLeft(\n    rotationCropLeft: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"left\", rotationCropLeft, sendImmediately);\n  }\n  async clearRotationCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotationCropTop: 0,\n      rotationCropRight: 0,\n      rotationCropBottom: 0,\n      rotationCropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"clearRotationCrop\",\n    });\n    await this.#sendDisplayContextCommand(\n      \"clearRotationCrop\",\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async selectBitmapColor(\n    bitmapColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(bitmapColorIndex);\n    this.assertValidColorIndex(colorIndex);\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"selectBitmapColor\",\n      bitmapColorIndex,\n      colorIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"selectBitmapColor\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  get bitmapColorIndices() {\n    return this.contextState.bitmapColorIndices;\n  }\n  get bitmapColors() {\n    return this.bitmapColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  async selectBitmapColors(\n    bitmapColorPairs: DisplayBitmapColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"bitmapColors\",\n      bitmapColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n      this.assertValidColorIndex(bitmapColorIndex);\n      this.assertValidColorIndex(colorIndex);\n      bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    });\n\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"selectBitmapColors\",\n      bitmapColorPairs,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"selectBitmapColors\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setBitmapColor(\n    bitmapColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.bitmapColorIndices[bitmapColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setBitmapColorOpacity(\n    bitmapColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.bitmapColorIndices[bitmapColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n  async setBitmapScaleDirection(\n    direction: DisplayScaleDirection,\n    bitmapScale: number,\n    sendImmediately?: boolean\n  ) {\n    bitmapScale = clamp(bitmapScale, minDisplayScale, maxDisplayScale);\n    bitmapScale = roundScale(bitmapScale);\n    const commandType = DisplayBitmapScaleDirectionToCommandType[direction];\n    _console.log({ [commandType]: bitmapScale });\n    const newState: PartialDisplayContextState = {};\n    let command: DisplayContextCommand;\n    switch (direction) {\n      case \"all\":\n        newState.bitmapScaleX = bitmapScale;\n        newState.bitmapScaleY = bitmapScale;\n        command = { type: \"setBitmapScale\", bitmapScale };\n        break;\n      case \"x\":\n        newState.bitmapScaleX = bitmapScale;\n        command = { type: \"setBitmapScaleX\", bitmapScaleX: bitmapScale };\n        break;\n      case \"y\":\n        newState.bitmapScaleY = bitmapScale;\n        command = { type: \"setBitmapScaleY\", bitmapScaleY: bitmapScale };\n        break;\n    }\n    const differences = this.#contextStateHelper.update(newState);\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, command);\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n\n    this.#onContextStateUpdate(differences);\n  }\n  async setBitmapScaleX(bitmapScaleX: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"x\", bitmapScaleX, sendImmediately);\n  }\n  async setBitmapScaleY(bitmapScaleY: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"y\", bitmapScaleY, sendImmediately);\n  }\n  async setBitmapScale(bitmapScale: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"all\", bitmapScale, sendImmediately);\n  }\n  async resetBitmapScale(sendImmediately?: boolean) {\n    //return this.setBitmapScaleDirection(\"all\", 1, sendImmediately);\n\n    const differences = this.#contextStateHelper.update({\n      bitmapScaleX: 1,\n      bitmapScaleY: 1,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"resetBitmapScale\",\n    });\n    await this.#sendDisplayContextCommand(\n      \"resetBitmapScale\",\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async selectSpriteColor(\n    spriteColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(spriteColorIndex);\n    this.assertValidColorIndex(colorIndex);\n    const spriteColorIndices = this.contextState.spriteColorIndices.slice();\n    spriteColorIndices[spriteColorIndex] = colorIndex;\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"selectSpriteColor\",\n      spriteColorIndex,\n      colorIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"selectSpriteColor\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  get spriteColorIndices() {\n    return this.contextState.spriteColorIndices;\n  }\n  get spriteColors() {\n    return this.spriteColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  async selectSpriteColors(\n    spriteColorPairs: DisplaySpriteColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"spriteColors\",\n      spriteColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const spriteColorIndices = this.contextState.spriteColorIndices.slice();\n    spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {\n      this.assertValidColorIndex(spriteColorIndex);\n      this.assertValidColorIndex(colorIndex);\n      spriteColorIndices[spriteColorIndex] = colorIndex;\n    });\n\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"selectSpriteColors\",\n      spriteColorPairs,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"selectSpriteColors\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpriteColor(\n    spriteColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.spriteColorIndices[spriteColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setSpriteColorOpacity(\n    spriteColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.spriteColorIndices[spriteColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n\n  async resetSpriteColors(sendImmediately?: boolean) {\n    const spriteColorIndices = new Array(this.numberOfColors).fill(0);\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"resetSpriteColors\",\n    });\n    await this.#sendDisplayContextCommand(\n      \"resetSpriteColors\",\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpriteScaleDirection(\n    direction: DisplayScaleDirection,\n    spriteScale: number,\n    sendImmediately?: boolean\n  ) {\n    spriteScale = clamp(spriteScale, minDisplayScale, maxDisplayScale);\n    spriteScale = roundScale(spriteScale);\n    const commandType = DisplaySpriteScaleDirectionToCommandType[direction];\n    _console.log({ [commandType]: spriteScale });\n    const newState: PartialDisplayContextState = {};\n    let command: DisplayContextCommand;\n    switch (direction) {\n      case \"all\":\n        newState.spriteScaleX = spriteScale;\n        newState.spriteScaleY = spriteScale;\n        command = { type: \"setSpriteScale\", spriteScale };\n        break;\n      case \"x\":\n        newState.spriteScaleX = spriteScale;\n        command = { type: \"setSpriteScaleX\", spriteScaleX: spriteScale };\n        break;\n      case \"y\":\n        newState.spriteScaleY = spriteScale;\n        command = { type: \"setSpriteScaleY\", spriteScaleY: spriteScale };\n        break;\n    }\n    const differences = this.#contextStateHelper.update(newState);\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, command);\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpriteScaleX(spriteScaleX: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"x\", spriteScaleX, sendImmediately);\n  }\n  async setSpriteScaleY(spriteScaleY: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"y\", spriteScaleY, sendImmediately);\n  }\n  async setSpriteScale(spriteScale: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"all\", spriteScale, sendImmediately);\n  }\n  async resetSpriteScale(sendImmediately?: boolean) {\n    //return this.setSpriteScaleDirection(\"all\", 1, sendImmediately);\n\n    const differences = this.#contextStateHelper.update({\n      spriteScaleX: 1,\n      spriteScaleY: 1,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"resetSpriteScale\",\n    });\n    await this.#sendDisplayContextCommand(\n      \"resetSpriteScale\",\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async clearRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"clearRect\",\n      x,\n      y,\n      width,\n      height,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"clearRect\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"drawRect\",\n      offsetX,\n      offsetY,\n      width,\n      height,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawRect\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawRoundRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"drawRoundRect\",\n      offsetX,\n      offsetY,\n      width,\n      height,\n      borderRadius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawRoundRect\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawCircle(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"drawCircle\",\n      offsetX,\n      offsetY,\n      radius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawCircle\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"drawEllipse\",\n      offsetX,\n      offsetY,\n      radiusX,\n      radiusY,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawEllipse\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawPolygon(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    numberOfSides: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"drawPolygon\",\n      offsetX,\n      offsetY,\n      radius,\n      numberOfSides,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawPolygon\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawSegment(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"drawSegment\",\n      startX,\n      startY,\n      endX,\n      endY,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawSegment\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawSegments(points: Vector2[], sendImmediately?: boolean) {\n    _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n    const dataViewLength = 1 + points.length * 4;\n    if (dataViewLength > this.#maxCommandDataLength) {\n      const mid = Math.floor(points.length / 2);\n      const firstHalf = points.slice(0, mid + 1);\n      const secondHalf = points.slice(mid);\n      _console.log({ firstHalf, secondHalf });\n      _console.log(\"sending first half\", firstHalf);\n      await this.drawSegments(firstHalf, false);\n      _console.log(\"sending second half\", secondHalf);\n      await this.drawSegments(secondHalf, sendImmediately);\n      return;\n    }\n    const dataView = serializeContextCommand(this, {\n      type: \"drawSegments\",\n      points,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawSegments\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawArc(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"drawArc\",\n      offsetX,\n      offsetY,\n      radius,\n      startAngle,\n      angleOffset,\n      isRadians,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawArc\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawArcEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    const dataView = serializeContextCommand(this, {\n      type: \"drawArcEllipse\",\n      offsetX,\n      offsetY,\n      radiusX,\n      radiusY,\n      startAngle,\n      angleOffset,\n      isRadians,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawArcEllipse\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  assertValidNumberOfColors(numberOfColors: number) {\n    _console.assertRangeWithError(\n      \"numberOfColors\",\n      numberOfColors,\n      2,\n      this.numberOfColors\n    );\n  }\n\n  assertValidBitmap(bitmap: DisplayBitmap, checkSize?: boolean) {\n    this.assertValidNumberOfColors(bitmap.numberOfColors);\n    assertValidBitmapPixels(bitmap);\n    if (checkSize) {\n      this.#assertValidBitmapSize(bitmap);\n    }\n  }\n  #assertValidBitmapSize(bitmap: DisplayBitmap) {\n    const pixelDataLength = getBitmapNumberOfBytes(bitmap);\n    _console.assertRangeWithError(\n      \"bitmap.pixels.length\",\n      pixelDataLength,\n      1,\n      this.#maxCommandDataLength - drawBitmapHeaderLength\n    );\n  }\n  async drawBitmap(\n    offsetX: number,\n    offsetY: number,\n    bitmap: DisplayBitmap,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidBitmap(bitmap, true);\n\n    const dataView = serializeContextCommand(this, {\n      type: \"drawBitmap\",\n      offsetX,\n      offsetY,\n      bitmap,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawBitmap\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async imageToBitmap(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors?: number\n  ) {\n    return imageToBitmap(\n      image,\n      width,\n      height,\n      this.colors,\n      this.bitmapColorIndices,\n      numberOfColors\n    );\n  }\n  async quantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number\n  ) {\n    return quantizeImage(image, width, height, numberOfColors);\n  }\n  async resizeAndQuantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    colors: string[]\n  ): Promise<{ blob: Blob; colorIndices: number[] }> {\n    return resizeAndQuantizeImage(image, width, height, colors);\n  }\n\n  // CONTEXT COMMANDS\n\n  async runContextCommand(\n    command: DisplayContextCommand,\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommand(this, command, sendImmediately);\n  }\n  async runContextCommands(\n    commands: DisplayContextCommand[],\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommands(this, commands, sendImmediately);\n  }\n\n  #isReady = true;\n  get isReady() {\n    return this.isAvailable && this.#isReady;\n  }\n  #parseDisplayReady(dataView: DataView) {\n    this.#isReady = true;\n    this.#dispatchEvent(\"displayReady\", {});\n  }\n\n  // SPRITE SHEET\n  #spriteSheets: Record<string, DisplaySpriteSheet> = {};\n  #spriteSheetIndices: Record<string, number> = {};\n  get spriteSheets() {\n    return this.#spriteSheets;\n  }\n  get spriteSheetIndices() {\n    return this.#spriteSheetIndices;\n  }\n  async #setSpriteSheetName(\n    spriteSheetName: string,\n    sendImmediately?: boolean\n  ) {\n    _console.assertTypeWithError(spriteSheetName, \"string\");\n    _console.assertRangeWithError(\n      \"newName\",\n      spriteSheetName.length,\n      MinSpriteSheetNameLength,\n      MaxSpriteSheetNameLength\n    );\n    const setSpriteSheetNameData = textEncoder.encode(spriteSheetName);\n    _console.log({ setSpriteSheetNameData });\n\n    const promise = this.waitForEvent(\"getSpriteSheetName\");\n    this.sendMessage(\n      [{ type: \"setSpriteSheetName\", data: setSpriteSheetNameData.buffer }],\n      sendImmediately\n    );\n    await promise;\n  }\n  #pendingSpriteSheet?: DisplaySpriteSheet;\n  get pendingSpriteSheet() {\n    return this.#pendingSpriteSheet;\n  }\n  #pendingSpriteSheetName?: string;\n  get pendingSpriteSheetName() {\n    return this.#pendingSpriteSheetName;\n  }\n  #updateSpriteSheetName(updatedSpriteSheetName: string) {\n    _console.assertTypeWithError(updatedSpriteSheetName, \"string\");\n    this.#pendingSpriteSheetName = updatedSpriteSheetName;\n    _console.log({ updatedSpriteSheetName: this.#pendingSpriteSheetName });\n    this.#dispatchEvent(\"getSpriteSheetName\", {\n      spriteSheetName: this.#pendingSpriteSheetName,\n    });\n  }\n  sendFile!: SendFileCallback;\n  serializeSpriteSheet(spriteSheet: DisplaySpriteSheet): ArrayBuffer {\n    return serializeSpriteSheet(this, spriteSheet);\n  }\n  async uploadSpriteSheet(spriteSheet: DisplaySpriteSheet) {\n    spriteSheet = structuredClone(spriteSheet);\n    this.#pendingSpriteSheet = spriteSheet;\n    const buffer = this.serializeSpriteSheet(this.#pendingSpriteSheet);\n    await this.#setSpriteSheetName(this.#pendingSpriteSheet.name);\n    const promise = this.waitForEvent(\"displaySpriteSheetUploadComplete\");\n    this.sendFile(\"spriteSheet\", buffer, true);\n    await promise;\n  }\n  async uploadSpriteSheets(spriteSheets: DisplaySpriteSheet[]) {\n    for (const spriteSheet of spriteSheets) {\n      await this.uploadSpriteSheet(spriteSheet);\n    }\n  }\n  assertLoadedSpriteSheet(spriteSheetName: string) {\n    assertLoadedSpriteSheet(this, spriteSheetName);\n  }\n  assertSelectedSpriteSheet(spriteSheetName: string) {\n    assertSelectedSpriteSheet(this, spriteSheetName);\n  }\n  assertAnySelectedSpriteSheet() {\n    assertAnySelectedSpriteSheet(this);\n  }\n  assertSprite(spriteName: string) {\n    return assertSprite(this, spriteName);\n  }\n  getSprite(spriteName: string): DisplaySprite | undefined {\n    return getSprite(this, spriteName);\n  }\n  getSpriteSheetPalette(\n    paletteName: string\n  ): DisplaySpriteSheetPalette | undefined {\n    return getSpriteSheetPalette(this, paletteName);\n  }\n  getSpriteSheetPaletteSwap(\n    paletteSwapName: string\n  ): DisplaySpriteSheetPaletteSwap | undefined {\n    return getSpriteSheetPaletteSwap(this, paletteSwapName);\n  }\n  getSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string\n  ): DisplaySpritePaletteSwap | undefined {\n    return getSpritePaletteSwap(this, spriteName, paletteSwapName);\n  }\n\n  get selectedSpriteSheet() {\n    if (this.contextState.spriteSheetName) {\n      return this.#spriteSheets[this.contextState.spriteSheetName];\n    }\n  }\n  get selectedSpriteSheetName() {\n    return this.selectedSpriteSheet?.name;\n  }\n  async selectSpriteSheet(spriteSheetName: string, sendImmediately?: boolean) {\n    this.assertLoadedSpriteSheet(spriteSheetName);\n    const differences = this.#contextStateHelper.update({\n      spriteSheetName,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const spriteSheetIndex = this.spriteSheetIndices[spriteSheetName];\n    const dataView = serializeContextCommand(this, {\n      type: \"selectSpriteSheet\",\n      spriteSheetIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"selectSpriteSheet\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async drawSprite(\n    offsetX: number,\n    offsetY: number,\n    spriteName: string,\n    sendImmediately?: boolean\n  ) {\n    _console.assertWithError(\n      this.selectedSpriteSheet,\n      \"no spriteSheet selected\"\n    );\n    let spriteIndex = this.selectedSpriteSheet!.sprites.findIndex(\n      (sprite) => sprite.name == spriteName\n    );\n    _console.assertWithError(\n      spriteIndex != -1,\n      `sprite \"${spriteName}\" not found`\n    );\n    spriteIndex = spriteIndex!;\n    const dataView = serializeContextCommand(this, {\n      type: \"drawSprite\",\n      offsetX,\n      offsetY,\n      spriteIndex,\n      use2Bytes: this.selectedSpriteSheet!.sprites.length > 255,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendDisplayContextCommand(\n      \"drawSprite\",\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  #parseSpriteSheetIndex(dataView: DataView) {\n    const spriteSheetIndex = dataView.getUint8(0);\n    _console.log({\n      pendingSpriteSheet: this.#pendingSpriteSheet,\n      spriteSheetName: this.#pendingSpriteSheetName,\n      spriteSheetIndex,\n    });\n    _console.assertWithError(\n      this.#pendingSpriteSheetName,\n      \"expected spriteSheetName when receiving spriteSheetIndex\"\n    );\n    _console.assertWithError(\n      this.#pendingSpriteSheet,\n      \"expected pendingSpriteSheet when receiving spriteSheetIndex\"\n    );\n    this.#spriteSheets[this.#pendingSpriteSheetName!] =\n      this.#pendingSpriteSheet!;\n    this.#spriteSheetIndices[this.#pendingSpriteSheetName!] = spriteSheetIndex;\n    this.#dispatchEvent(\"displaySpriteSheetUploadComplete\", {\n      spriteSheetName: this.#pendingSpriteSheetName!,\n      spriteSheet: this.#pendingSpriteSheet!,\n    });\n    this.#pendingSpriteSheet = undefined;\n  }\n\n  // MESSAGE\n  parseMessage(messageType: DisplayMessageType, dataView: DataView) {\n    _console.log({ messageType, dataView });\n\n    switch (messageType) {\n      case \"isDisplayAvailable\":\n        this.#parseIsDisplayAvailable(dataView);\n        break;\n      case \"displayStatus\":\n        this.#parseDisplayStatus(dataView);\n        break;\n      case \"displayInformation\":\n        this.#parseDisplayInformation(dataView);\n        break;\n      case \"getDisplayBrightness\":\n      case \"setDisplayBrightness\":\n        this.#parseDisplayBrightness(dataView);\n        break;\n      case \"displayReady\":\n        this.#parseDisplayReady(dataView);\n        break;\n      case \"getSpriteSheetName\":\n      case \"setSpriteSheetName\":\n        const spriteSheetName = textDecoder.decode(dataView.buffer);\n        _console.log({ spriteSheetName });\n        this.#updateSpriteSheetName(spriteSheetName);\n        break;\n      case \"spriteSheetIndex\":\n        this.#parseSpriteSheetIndex(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  // SPRITE SHEET PALETTES\n\n  assertSpriteSheetPalette(paletteName: string) {\n    assertSpriteSheetPalette(this, paletteName);\n  }\n  assertSpriteSheetPaletteSwap(paletteSwapName: string) {\n    assertSpriteSheetPaletteSwap(this, paletteSwapName);\n  }\n  assertSpritePaletteSwap(spriteName: string, paletteSwapName: string) {\n    assertSpritePaletteSwap(this, spriteName, paletteSwapName);\n  }\n  async selectSpriteSheetPalette(\n    paletteName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpriteSheetPalette(this, paletteName, offset, sendImmediately);\n  }\n  async selectSpriteSheetPaletteSwap(\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpriteSheetPaletteSwap(\n      this,\n      paletteSwapName,\n      offset,\n      sendImmediately\n    );\n  }\n  async selectSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpritePaletteSwap(\n      this,\n      spriteName,\n      paletteSwapName,\n      offset,\n      sendImmediately\n    );\n  }\n\n  reset() {\n    _console.log(\"clearing displayManager\");\n    // @ts-ignore\n    this.#displayStatus = undefined;\n    this.#isAvailable = false;\n    this.#displayInformation = undefined;\n    // @ts-ignore\n    this.#brightness = undefined;\n    this.#displayContextCommandBuffers = [];\n    this.#isAvailable = false;\n\n    this.#contextStateHelper.reset();\n    this.#colors.length = 0;\n    this.#opacities.length = 0;\n\n    this.#isReady = true;\n    this.#pendingSpriteSheet = undefined;\n    this.#pendingSpriteSheetName = undefined;\n\n    Object.keys(this.#spriteSheetIndices).forEach(\n      (spriteSheetName) => delete this.#spriteSheetIndices[spriteSheetName]\n    );\n    Object.keys(this.#spriteSheets).forEach(\n      (spriteSheetName) => delete this.#spriteSheets[spriteSheetName]\n    );\n  }\n\n  async fontToSpriteSheet(\n    arrayBuffer: ArrayBuffer,\n    fontSize: number,\n    spriteSheetName?: string\n  ) {\n    // FIX\n    return fontToSpriteSheet(this, arrayBuffer, fontSize, spriteSheetName);\n  }\n\n  // MTU\n  #mtu!: number;\n  get mtu() {\n    return this.#mtu;\n  }\n  set mtu(newMtu: number) {\n    this.#mtu = newMtu;\n  }\n}\n\nexport default DisplayManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport Timer from \"../utils/Timer.ts\";\n\nimport { FileTransferMessageTypes } from \"../FileTransferManager.ts\";\nimport { TfliteMessageTypes } from \"../TfliteManager.ts\";\nimport { concatenateArrayBuffers } from \"../utils/ArrayBufferUtils.ts\";\nimport { parseMessage } from \"../utils/ParseUtils.ts\";\nimport { DeviceInformationTypes } from \"../DeviceInformationManager.ts\";\nimport { InformationMessageTypes } from \"../InformationManager.ts\";\nimport { VibrationMessageTypes } from \"../vibration/VibrationManager.ts\";\nimport { SensorConfigurationMessageTypes } from \"../sensor/SensorConfigurationManager.ts\";\nimport { SensorDataMessageTypes } from \"../sensor/SensorDataManager.ts\";\nimport { WifiMessageTypes } from \"../WifiManager.ts\";\nimport { CameraMessageTypes } from \"../CameraManager.ts\";\nimport { MicrophoneMessageTypes } from \"../MicrophoneManager.ts\";\nimport { DisplayMessageTypes } from \"../DisplayManager.ts\";\n\nconst _console = createConsole(\"BaseConnectionManager\", { log: false });\n\nexport const ConnectionTypes = [\n  \"webBluetooth\",\n  \"noble\",\n  \"client\",\n  \"webSocket\",\n  \"udp\",\n] as const;\nexport type ConnectionType = (typeof ConnectionTypes)[number];\n\nexport const ClientConnectionTypes = [\"noble\", \"webSocket\", \"udp\"] as const;\nexport type ClientConnectionType = (typeof ClientConnectionTypes)[number];\n\ninterface BaseConnectOptions {\n  type: \"client\" | \"webBluetooth\" | \"webSocket\" | \"udp\";\n}\nexport interface WebBluetoothConnectOptions extends BaseConnectOptions {\n  type: \"webBluetooth\";\n}\ninterface BaseWifiConnectOptions extends BaseConnectOptions {\n  ipAddress: string;\n}\nexport interface ClientConnectOptions extends BaseConnectOptions {\n  type: \"client\";\n  subType?: \"noble\" | \"webSocket\" | \"udp\";\n}\nexport interface WebSocketConnectOptions extends BaseWifiConnectOptions {\n  type: \"webSocket\";\n  isWifiSecure?: boolean;\n}\nexport interface UDPConnectOptions extends BaseWifiConnectOptions {\n  type: \"udp\";\n  //sendPort: number;\n  receivePort?: number;\n}\nexport type ConnectOptions =\n  | WebBluetoothConnectOptions\n  | WebSocketConnectOptions\n  | UDPConnectOptions\n  | ClientConnectOptions;\n\nexport const ConnectionStatuses = [\n  \"notConnected\",\n  \"connecting\",\n  \"connected\",\n  \"disconnecting\",\n] as const;\nexport type ConnectionStatus = (typeof ConnectionStatuses)[number];\n\nexport const ConnectionEventTypes = [\n  ...ConnectionStatuses,\n  \"connectionStatus\",\n  \"isConnected\",\n] as const;\nexport type ConnectionEventType = (typeof ConnectionEventTypes)[number];\n\nexport interface ConnectionStatusEventMessages {\n  notConnected: any;\n  connecting: any;\n  connected: any;\n  disconnecting: any;\n  connectionStatus: { connectionStatus: ConnectionStatus };\n  isConnected: { isConnected: boolean };\n}\n\nexport interface TxMessage {\n  type: TxRxMessageType;\n  data?: ArrayBuffer;\n}\n\nexport const TxRxMessageTypes = [\n  ...InformationMessageTypes,\n  ...SensorConfigurationMessageTypes,\n  ...SensorDataMessageTypes,\n  ...VibrationMessageTypes,\n  ...FileTransferMessageTypes,\n  ...TfliteMessageTypes,\n  ...WifiMessageTypes,\n  ...CameraMessageTypes,\n  ...MicrophoneMessageTypes,\n  ...DisplayMessageTypes,\n] as const;\nexport type TxRxMessageType = (typeof TxRxMessageTypes)[number];\n\nexport const SMPMessageTypes = [\"smp\"] as const;\nexport type SMPMessageType = (typeof SMPMessageTypes)[number];\n\nexport const BatteryLevelMessageTypes = [\"batteryLevel\"] as const;\nexport type BatteryLevelMessageType = (typeof BatteryLevelMessageTypes)[number];\n\nexport const MetaConnectionMessageTypes = [\"rx\", \"tx\"] as const;\nexport type MetaConnectionMessageType =\n  (typeof MetaConnectionMessageTypes)[number];\n\nexport const ConnectionMessageTypes = [\n  ...BatteryLevelMessageTypes,\n  ...DeviceInformationTypes,\n  ...MetaConnectionMessageTypes,\n  ...TxRxMessageTypes,\n  ...SMPMessageTypes,\n] as const;\nexport type ConnectionMessageType = (typeof ConnectionMessageTypes)[number];\n\nexport type ConnectionStatusCallback = (status: ConnectionStatus) => void;\nexport type MessageReceivedCallback = (\n  messageType: ConnectionMessageType,\n  dataView: DataView\n) => void;\nexport type MessagesReceivedCallback = () => void;\n\nabstract class BaseConnectionManager {\n  static #AssertValidTxRxMessageType(messageType: TxRxMessageType) {\n    _console.assertEnumWithError(messageType, TxRxMessageTypes);\n  }\n\n  abstract get bluetoothId(): string;\n\n  // CALLBACKS\n  onStatusUpdated?: ConnectionStatusCallback;\n  onMessageReceived?: MessageReceivedCallback;\n  onMessagesReceived?: MessagesReceivedCallback;\n\n  protected get baseConstructor() {\n    return this.constructor as typeof BaseConnectionManager;\n  }\n  static get isSupported() {\n    return false;\n  }\n  get isSupported() {\n    return this.baseConstructor.isSupported;\n  }\n\n  get canUpdateFirmware() {\n    return false;\n  }\n\n  static type: ConnectionType;\n  get type(): ConnectionType {\n    return this.baseConstructor.type;\n  }\n\n  /** @throws {Error} if not supported */\n  #assertIsSupported() {\n    _console.assertWithError(\n      this.isSupported,\n      `${this.constructor.name} is not supported`\n    );\n  }\n\n  constructor() {\n    this.#assertIsSupported();\n  }\n\n  #status: ConnectionStatus = \"notConnected\";\n  get status() {\n    return this.#status;\n  }\n  protected set status(newConnectionStatus) {\n    _console.assertEnumWithError(newConnectionStatus, ConnectionStatuses);\n    if (this.#status == newConnectionStatus) {\n      _console.log(\n        `tried to assign same connection status \"${newConnectionStatus}\"`\n      );\n      return;\n    }\n    _console.log(`new connection status \"${newConnectionStatus}\"`);\n    this.#status = newConnectionStatus;\n    this.onStatusUpdated!(this.status);\n\n    if (this.isConnected) {\n      this.#timer.start();\n    } else {\n      this.#timer.stop();\n    }\n\n    if (this.#status == \"notConnected\") {\n      this.mtu = this.defaultMtu;\n    }\n  }\n\n  get isConnected() {\n    return this.status == \"connected\";\n  }\n\n  get isAvailable() {\n    return false;\n  }\n\n  /** @throws {Error} if connected */\n  protected assertIsNotConnected() {\n    _console.assertWithError(!this.isConnected, \"device is already connected\");\n  }\n  /** @throws {Error} if connecting */\n  #assertIsNotConnecting() {\n    _console.assertWithError(\n      this.status != \"connecting\",\n      \"device is already connecting\"\n    );\n  }\n  /** @throws {Error} if not connected */\n  protected assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"device is not connected\");\n  }\n  /** @throws {Error} if disconnecting */\n  #assertIsNotDisconnecting() {\n    _console.assertWithError(\n      this.status != \"disconnecting\",\n      \"device is already disconnecting\"\n    );\n  }\n  /** @throws {Error} if not connected or is disconnecting */\n  assertIsConnectedAndNotDisconnecting() {\n    this.assertIsConnected();\n    this.#assertIsNotDisconnecting();\n  }\n\n  async connect() {\n    this.assertIsNotConnected();\n    this.#assertIsNotConnecting();\n    this.status = \"connecting\";\n  }\n  get canReconnect() {\n    return false;\n  }\n  async reconnect() {\n    this.assertIsNotConnected();\n    this.#assertIsNotConnecting();\n    _console.assertWithError(this.canReconnect, \"unable to reconnect\");\n    this.status = \"connecting\";\n    _console.log(\"attempting to reconnect...\");\n  }\n  async disconnect() {\n    this.assertIsConnected();\n    this.#assertIsNotDisconnecting();\n    this.status = \"disconnecting\";\n    _console.log(\"disconnecting from device...\");\n  }\n\n  async sendSmpMessage(data: ArrayBuffer) {\n    this.assertIsConnectedAndNotDisconnecting();\n    _console.log(\"sending smp message\", data);\n  }\n\n  #pendingMessages: TxMessage[] = [];\n  #isSendingMessages = false;\n  async sendTxMessages(\n    messages: TxMessage[] | undefined,\n    sendImmediately: boolean = true\n  ) {\n    this.assertIsConnectedAndNotDisconnecting();\n\n    if (messages) {\n      this.#pendingMessages.push(...messages);\n      _console.log(`appended ${messages.length} messages`);\n    }\n\n    if (!sendImmediately) {\n      _console.log(\"not sending immediately - waiting until later\");\n      return;\n    }\n\n    if (this.#isSendingMessages) {\n      _console.log(\"already sending messages - waiting until later\");\n      return;\n    }\n    if (this.#pendingMessages.length == 0) {\n      _console.log(\"no pendingMessages\");\n      return;\n    }\n    this.#isSendingMessages = true;\n\n    _console.log(\"sendTxMessages\", this.#pendingMessages.slice());\n\n    const arrayBuffers = this.#pendingMessages.map((message) => {\n      BaseConnectionManager.#AssertValidTxRxMessageType(message.type);\n      const messageTypeEnum = TxRxMessageTypes.indexOf(message.type);\n      const dataLength = new DataView(new ArrayBuffer(2));\n      dataLength.setUint16(0, message.data?.byteLength || 0, true);\n      return concatenateArrayBuffers(messageTypeEnum, dataLength, message.data);\n    });\n    this.#pendingMessages.length = 0;\n\n    if (this.mtu) {\n      while (arrayBuffers.length > 0) {\n        if (\n          arrayBuffers.every(\n            (arrayBuffer) => arrayBuffer.byteLength > this.mtu! - 3\n          )\n        ) {\n          _console.log(\"every arrayBuffer is too big to send\");\n          break;\n        }\n        _console.log(\"remaining arrayBuffers.length\", arrayBuffers.length);\n        let arrayBufferByteLength = 0;\n        let arrayBufferCount = 0;\n        arrayBuffers.some((arrayBuffer) => {\n          if (arrayBufferByteLength + arrayBuffer.byteLength > this.mtu! - 3) {\n            _console.log(\n              `stopping appending arrayBuffers ( length ${arrayBuffer.byteLength} too much)`\n            );\n            return true;\n          }\n          _console.log(\n            `allowing arrayBuffer with length ${arrayBuffer.byteLength}`\n          );\n          arrayBufferCount++;\n          arrayBufferByteLength += arrayBuffer.byteLength;\n        });\n        const arrayBuffersToSend = arrayBuffers.splice(0, arrayBufferCount);\n        _console.log({ arrayBufferCount, arrayBuffersToSend });\n\n        const arrayBuffer = concatenateArrayBuffers(...arrayBuffersToSend);\n        _console.log(\"sending arrayBuffer (partitioned)\", arrayBuffer);\n        await this.sendTxData(arrayBuffer);\n      }\n    } else {\n      const arrayBuffer = concatenateArrayBuffers(...arrayBuffers);\n      _console.log(\"sending arrayBuffer (all)\", arrayBuffer);\n      await this.sendTxData(arrayBuffer);\n    }\n\n    this.#isSendingMessages = false;\n\n    this.sendTxMessages(undefined, true);\n  }\n\n  protected defaultMtu = 23;\n  //mtu?: number;\n  mtu?: number = this.defaultMtu;\n\n  async sendTxData(data: ArrayBuffer) {\n    _console.log(\"sendTxData\", data);\n  }\n\n  parseRxMessage(dataView: DataView) {\n    parseMessage(\n      dataView,\n      TxRxMessageTypes,\n      this.#onRxMessage.bind(this),\n      null,\n      true\n    );\n    this.onMessagesReceived!();\n  }\n\n  #onRxMessage(messageType: TxRxMessageType, dataView: DataView) {\n    _console.log({ messageType, dataView });\n    this.onMessageReceived!(messageType, dataView);\n  }\n\n  #timer = new Timer(this.#checkConnection.bind(this), 5000);\n  #checkConnection() {\n    //console.log(\"checking connection...\");\n    if (!this.isConnected) {\n      _console.log(\"timer detected disconnection\");\n      this.status = \"notConnected\";\n    }\n  }\n\n  clear() {\n    this.#isSendingMessages = false;\n    this.#pendingMessages.length = 0;\n  }\n\n  remove() {\n    this.clear();\n\n    this.onStatusUpdated = undefined;\n    this.onMessageReceived = undefined;\n    this.onMessagesReceived = undefined;\n  }\n}\n\nexport default BaseConnectionManager;\n","export function spacesToPascalCase(string: string) {\n  return string\n    .replace(/(?:^\\w|\\b\\w)/g, function (match) {\n      return match.toUpperCase();\n    })\n    .replace(/\\s+/g, \"\");\n}\n\nexport function capitalizeFirstCharacter(string: string) {\n  return string[0].toUpperCase() + string.slice(1);\n}\n","import { createConsole } from \"./Console.ts\";\nimport { spacesToPascalCase } from \"./stringUtils.ts\";\n\nconst _console = createConsole(\"EventUtils\", { log: false });\n\ntype BoundEventListeners = { [eventType: string]: EventListener };\nexport type BoundGenericEventListeners = { [eventType: string]: Function };\n\nexport function bindEventListeners(\n  eventTypes: readonly string[],\n  boundEventListeners: BoundGenericEventListeners,\n  target: any\n) {\n  _console.log(\"bindEventListeners\", { eventTypes, boundEventListeners, target });\n  eventTypes.forEach((eventType) => {\n    const _eventType = `_on${spacesToPascalCase(eventType)}`;\n    _console.assertWithError(target[_eventType], `no event \"${_eventType}\" found in target`);\n    _console.log(`binding eventType \"${eventType}\" as ${_eventType} from target`, target);\n    const boundEvent = target[_eventType].bind(target);\n    target[_eventType] = boundEvent;\n    boundEventListeners[eventType] = boundEvent;\n  });\n}\n\nexport function addEventListeners(target: any, boundEventListeners: BoundGenericEventListeners) {\n  let addEventListener = target.addEventListener || target.addListener || target.on || target.AddEventListener;\n  _console.assertWithError(addEventListener, \"no add listener function found for target\");\n  addEventListener = addEventListener.bind(target);\n  Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {\n    addEventListener(eventType, eventListener);\n  });\n}\n\nexport function removeEventListeners(target: any, boundEventListeners: BoundGenericEventListeners) {\n  let removeEventListener = target.removeEventListener || target.removeListener || target.RemoveEventListener;\n  _console.assertWithError(removeEventListener, \"no remove listener function found for target\");\n  removeEventListener = removeEventListener.bind(target);\n  Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {\n    removeEventListener(eventType, eventListener);\n  });\n}\n","import {\n  isInBrowser,\n  isInLensStudio,\n  isInNode,\n} from \"../../utils/environment.ts\";\nimport { createConsole } from \"../../utils/Console.ts\";\n\nconst _console = createConsole(\"bluetoothUUIDs\", { log: false });\n\n/** NODE_START */\nimport * as webbluetooth from \"webbluetooth\";\nvar BluetoothUUID = webbluetooth.BluetoothUUID;\n/** NODE_END */\n\n/** BROWSER_START */\nif (isInBrowser) {\n  var BluetoothUUID = window.BluetoothUUID;\n}\n/** BROWSER_END */\n\n/** LS_START */\n\nvar BluetoothUUID = {\n  getService: (uuid: number | string): string => toUUID(uuid),\n\n  getCharacteristic: (uuid: number | string): string => toUUID(uuid),\n\n  getDescriptor: (uuid: number | string): string => toUUID(uuid),\n\n  getCharacteristicName: (uuid: number | string): string | null => null,\n\n  getServiceName: (uuid: number | string): string | null => null,\n\n  getDescriptorName: (uuid: number | string): string | null => null,\n};\n\nfunction toUUID(uuid: number | string): string {\n  if (typeof uuid === \"number\") {\n    uuid = uuid.toString(16).padStart(4, \"0\");\n  }\n\n  if (/^[0-9a-fA-F]{4,8}$/.test(uuid)) {\n    return `0000${uuid.padStart(8, \"0\")}-0000-1000-8000-00805f9b34fb`;\n  }\n\n  return uuid.toLowerCase();\n}\n\n/** LS_END */\n\nfunction generateBluetoothUUID(value: string): BluetoothServiceUUID {\n  _console.assertTypeWithError(value, \"string\");\n  _console.assertWithError(\n    value.length == 4,\n    \"value must be 4 characters long\"\n  );\n  return `ea6d${value}-a725-4f9b-893d-c3913e33b39f`;\n}\n\nfunction stringToCharacteristicUUID(\n  identifier: string\n): BluetoothCharacteristicUUID {\n  return BluetoothUUID?.getCharacteristic?.(identifier);\n}\n\nfunction stringToServiceUUID(identifier: string): BluetoothServiceUUID {\n  return BluetoothUUID?.getService?.(identifier);\n}\n\nexport type BluetoothServiceName =\n  | \"deviceInformation\"\n  | \"battery\"\n  | \"main\"\n  | \"smp\";\nimport { DeviceInformationType } from \"../../DeviceInformationManager.ts\";\nexport type BluetoothCharacteristicName =\n  | DeviceInformationType\n  | \"batteryLevel\"\n  | \"rx\"\n  | \"tx\"\n  | \"smp\";\n\ninterface BluetoothCharacteristicInformation {\n  uuid: BluetoothCharacteristicUUID;\n}\ninterface BluetoothServiceInformation {\n  uuid: BluetoothServiceUUID;\n  characteristics: {\n    [characteristicName in BluetoothCharacteristicName]?: BluetoothCharacteristicInformation;\n  };\n}\ninterface BluetoothServicesInformation {\n  services: {\n    [serviceName in BluetoothServiceName]: BluetoothServiceInformation;\n  };\n}\nconst bluetoothUUIDs: BluetoothServicesInformation = Object.freeze({\n  services: {\n    deviceInformation: {\n      uuid: stringToServiceUUID(\"device_information\"),\n      characteristics: {\n        manufacturerName: {\n          uuid: stringToCharacteristicUUID(\"manufacturer_name_string\"),\n        },\n        modelNumber: {\n          uuid: stringToCharacteristicUUID(\"model_number_string\"),\n        },\n        hardwareRevision: {\n          uuid: stringToCharacteristicUUID(\"hardware_revision_string\"),\n        },\n        firmwareRevision: {\n          uuid: stringToCharacteristicUUID(\"firmware_revision_string\"),\n        },\n        softwareRevision: {\n          uuid: stringToCharacteristicUUID(\"software_revision_string\"),\n        },\n        pnpId: {\n          uuid: stringToCharacteristicUUID(\"pnp_id\"),\n        },\n        serialNumber: {\n          uuid: stringToCharacteristicUUID(\"serial_number_string\"),\n        },\n      },\n    },\n    battery: {\n      uuid: stringToServiceUUID(\"battery_service\"),\n      characteristics: {\n        batteryLevel: {\n          uuid: stringToCharacteristicUUID(\"battery_level\"),\n        },\n      },\n    },\n    main: {\n      uuid: generateBluetoothUUID(\"0000\"),\n      characteristics: {\n        rx: { uuid: generateBluetoothUUID(\"1000\") },\n        tx: { uuid: generateBluetoothUUID(\"1001\") },\n      },\n    },\n    smp: {\n      uuid: \"8d53dc1d-1db7-4cd3-868b-8a527460aa84\",\n      characteristics: {\n        smp: { uuid: \"da2e7828-fbce-4e01-ae9e-261174997c48\" },\n      },\n    },\n  },\n});\n\nexport const serviceUUIDs = [bluetoothUUIDs.services.main.uuid];\nexport const optionalServiceUUIDs = [\n  bluetoothUUIDs.services.deviceInformation.uuid,\n  bluetoothUUIDs.services.battery.uuid,\n  bluetoothUUIDs.services.smp.uuid,\n];\nexport const allServiceUUIDs = [...serviceUUIDs, ...optionalServiceUUIDs];\n\nexport function getServiceNameFromUUID(\n  serviceUUID: BluetoothServiceUUID\n): BluetoothServiceName | undefined {\n  serviceUUID = serviceUUID.toString().toLowerCase();\n  const serviceNames = Object.keys(\n    bluetoothUUIDs.services\n  ) as BluetoothServiceName[];\n  return serviceNames.find((serviceName) => {\n    const serviceInfo = bluetoothUUIDs.services[serviceName];\n    let serviceInfoUUID = serviceInfo.uuid.toString();\n    if (serviceUUID.length == 4) {\n      serviceInfoUUID = serviceInfoUUID.slice(4, 8);\n    }\n    if (!serviceUUID.includes(\"-\")) {\n      serviceInfoUUID = serviceInfoUUID.replaceAll(\"-\", \"\");\n    }\n    return serviceUUID == serviceInfoUUID;\n  });\n}\n\nexport const characteristicUUIDs: BluetoothCharacteristicUUID[] = [];\nexport const allCharacteristicUUIDs: BluetoothCharacteristicUUID[] = [];\n\nexport const characteristicNames: BluetoothCharacteristicName[] = [];\nexport const allCharacteristicNames: BluetoothCharacteristicName[] = [];\n\nObject.values(bluetoothUUIDs.services).forEach((serviceInfo) => {\n  if (!serviceInfo.characteristics) {\n    return;\n  }\n  const characteristicNames = Object.keys(\n    serviceInfo.characteristics\n  ) as BluetoothCharacteristicName[];\n  characteristicNames.forEach((characteristicName) => {\n    const characteristicInfo = serviceInfo.characteristics[characteristicName]!;\n    if (serviceUUIDs.includes(serviceInfo.uuid)) {\n      characteristicUUIDs.push(characteristicInfo.uuid);\n      characteristicNames.push(characteristicName);\n    }\n    allCharacteristicUUIDs.push(characteristicInfo.uuid);\n    allCharacteristicNames.push(characteristicName);\n  });\n}, []);\n\n//_console.log({ characteristicUUIDs, allCharacteristicUUIDs });\n\nexport function getCharacteristicNameFromUUID(\n  characteristicUUID: BluetoothCharacteristicUUID\n): BluetoothCharacteristicName | undefined {\n  //_console.log({ characteristicUUID });\n  characteristicUUID = characteristicUUID.toString().toLowerCase();\n  var characteristicName: BluetoothCharacteristicName | undefined;\n  Object.values(bluetoothUUIDs.services).some((serviceInfo) => {\n    const characteristicNames = Object.keys(\n      serviceInfo.characteristics\n    ) as BluetoothCharacteristicName[];\n    characteristicName = characteristicNames.find((_characteristicName) => {\n      const characteristicInfo =\n        serviceInfo.characteristics[_characteristicName]!;\n      let characteristicInfoUUID = characteristicInfo.uuid.toString();\n      if (characteristicUUID.length == 4) {\n        characteristicInfoUUID = characteristicInfoUUID.slice(4, 8);\n      }\n      if (!characteristicUUID.includes(\"-\")) {\n        characteristicInfoUUID = characteristicInfoUUID.replaceAll(\"-\", \"\");\n      }\n      return characteristicUUID == characteristicInfoUUID;\n    });\n    return characteristicName;\n  });\n  return characteristicName;\n}\n\nexport function getCharacteristicProperties(\n  characteristicName: BluetoothCharacteristicName\n): BluetoothCharacteristicProperties {\n  const properties = {\n    broadcast: false,\n    read: true,\n    writeWithoutResponse: false,\n    write: false,\n    notify: false,\n    indicate: false,\n    authenticatedSignedWrites: false,\n    reliableWrite: false,\n    writableAuxiliaries: false,\n  };\n\n  // read\n  switch (characteristicName) {\n    case \"rx\":\n    case \"tx\":\n    case \"smp\":\n      properties.read = false;\n      break;\n  }\n\n  // notify\n  switch (characteristicName) {\n    case \"batteryLevel\":\n    case \"rx\":\n    case \"smp\":\n      properties.notify = true;\n      break;\n  }\n\n  // write without response\n  switch (characteristicName) {\n    case \"smp\":\n      properties.writeWithoutResponse = true;\n      break;\n  }\n\n  // write\n  switch (characteristicName) {\n    case \"tx\":\n      properties.write = true;\n      break;\n  }\n\n  return properties;\n}\n\nexport const serviceDataUUID = \"0000\";\n","import { createConsole } from \"../../utils/Console.ts\";\nimport BaseConnectionManager from \"../BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"BluetoothConnectionManager\", { log: false });\n\nimport { BluetoothCharacteristicName } from \"./bluetoothUUIDs.ts\";\n\nabstract class BluetoothConnectionManager extends BaseConnectionManager {\n  get isAvailable() {\n    // no way to tell if the user has turned bluetooth on or off\n    return true;\n  }\n\n  isInRange = true;\n\n  protected onCharacteristicValueChanged(\n    characteristicName: BluetoothCharacteristicName,\n    dataView: DataView\n  ) {\n    if (characteristicName == \"rx\") {\n      this.parseRxMessage(dataView);\n    } else {\n      this.onMessageReceived?.(characteristicName, dataView);\n    }\n  }\n\n  protected async writeCharacteristic(\n    characteristicName: BluetoothCharacteristicName,\n    data: ArrayBuffer\n  ) {\n    _console.log(\"writeCharacteristic\", ...arguments);\n  }\n\n  async sendSmpMessage(data: ArrayBuffer) {\n    super.sendSmpMessage(data);\n    await this.writeCharacteristic(\"smp\", data);\n  }\n\n  async sendTxData(data: ArrayBuffer) {\n    super.sendTxData(data);\n    if (data.byteLength == 0) {\n      return;\n    }\n    await this.writeCharacteristic(\"tx\", data);\n  }\n}\n\nexport default BluetoothConnectionManager;\n","import { createConsole } from \"../../utils/Console.ts\";\nimport {\n  isInNode,\n  isInBrowser,\n  isInBluefy,\n  isInWebBLE,\n} from \"../../utils/environment.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../../utils/EventUtils.ts\";\nimport {\n  serviceUUIDs,\n  optionalServiceUUIDs,\n  getServiceNameFromUUID,\n  getCharacteristicNameFromUUID,\n  getCharacteristicProperties,\n} from \"./bluetoothUUIDs.ts\";\nimport BluetoothConnectionManager from \"./BluetoothConnectionManager.ts\";\nimport {\n  BluetoothCharacteristicName,\n  BluetoothServiceName,\n} from \"./bluetoothUUIDs.ts\";\nimport { ConnectionType } from \"../BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"WebBluetoothConnectionManager\", { log: false });\n\ntype WebBluetoothInterface = webbluetooth.Bluetooth | Bluetooth;\n\ninterface BluetoothService extends BluetoothRemoteGATTService {\n  name?: BluetoothServiceName;\n}\ninterface BluetoothCharacteristic extends BluetoothRemoteGATTCharacteristic {\n  name?: BluetoothCharacteristicName;\n}\n\nvar bluetooth: WebBluetoothInterface | undefined;\n/** NODE_START */\nimport * as webbluetooth from \"webbluetooth\";\nif (isInNode) {\n  bluetooth = webbluetooth.bluetooth;\n}\n/** NODE_END */\n\n/** BROWSER_START */\nif (isInBrowser) {\n  bluetooth = window.navigator.bluetooth;\n}\n/** BROWSER_END */\n\nclass WebBluetoothConnectionManager extends BluetoothConnectionManager {\n  get bluetoothId() {\n    return this.device!.id;\n  }\n\n  get canUpdateFirmware() {\n    return this.#characteristics.has(\"smp\");\n  }\n\n  #boundBluetoothCharacteristicEventListeners: {\n    [eventType: string]: EventListener;\n  } = {\n    characteristicvaluechanged: this.#onCharacteristicvaluechanged.bind(this),\n  };\n  #boundBluetoothDeviceEventListeners: { [eventType: string]: EventListener } =\n    {\n      gattserverdisconnected: this.#onGattserverdisconnected.bind(this),\n    };\n\n  static get isSupported() {\n    return Boolean(bluetooth);\n  }\n  static get type(): ConnectionType {\n    return \"webBluetooth\";\n  }\n\n  #device?: BluetoothDevice;\n  get device() {\n    return this.#device;\n  }\n  set device(newDevice) {\n    if (this.#device == newDevice) {\n      _console.log(\"tried to assign the same BluetoothDevice\");\n      return;\n    }\n    if (this.#device) {\n      removeEventListeners(\n        this.#device,\n        this.#boundBluetoothDeviceEventListeners\n      );\n    }\n    if (newDevice) {\n      addEventListeners(newDevice, this.#boundBluetoothDeviceEventListeners);\n    }\n    this.#device = newDevice;\n  }\n\n  get server(): BluetoothRemoteGATTServer | undefined {\n    return this.#device?.gatt;\n  }\n  get isConnected() {\n    return this.server?.connected || false;\n  }\n\n  #services: Map<BluetoothServiceName, BluetoothService> = new Map();\n  #characteristics: Map<BluetoothCharacteristicName, BluetoothCharacteristic> =\n    new Map();\n\n  async connect() {\n    await super.connect();\n\n    try {\n      const device = await bluetooth!.requestDevice({\n        filters: [{ services: serviceUUIDs }],\n        optionalServices: isInBrowser ? optionalServiceUUIDs : [],\n      });\n\n      _console.log(\"got BluetoothDevice\");\n      this.device = device;\n\n      _console.log(\"connecting to device...\");\n      const server = await this.server!.connect();\n      _console.log(`connected to device? ${server.connected}`);\n\n      await this.#getServicesAndCharacteristics();\n\n      _console.log(\"fully connected\");\n\n      this.status = \"connected\";\n    } catch (error) {\n      _console.error(error);\n      this.status = \"notConnected\";\n      this.server?.disconnect();\n      this.#removeEventListeners();\n    }\n  }\n  async #getServicesAndCharacteristics() {\n    this.#removeEventListeners();\n\n    _console.log(\"getting services...\");\n    const services = await this.server!.getPrimaryServices();\n    _console.log(\"got services\", services.length);\n    //const service = await this.server!.getPrimaryService(\"8d53dc1d-1db7-4cd3-868b-8a527460aa84\");\n\n    _console.log(\"getting characteristics...\");\n    for (const serviceIndex in services) {\n      const service = services[serviceIndex] as BluetoothService;\n      _console.log({ service });\n      const serviceName = getServiceNameFromUUID(service.uuid)!;\n      _console.assertWithError(\n        serviceName,\n        `no name found for service uuid \"${service.uuid}\"`\n      );\n      _console.log(`got \"${serviceName}\" service`);\n      service.name = serviceName;\n      this.#services.set(serviceName, service);\n      _console.log(`getting characteristics for \"${serviceName}\" service`);\n      const characteristics = await service.getCharacteristics();\n      _console.log(`got characteristics for \"${serviceName}\" service`);\n      for (const characteristicIndex in characteristics) {\n        const characteristic = characteristics[\n          characteristicIndex\n        ] as BluetoothCharacteristic;\n        _console.log({ characteristic });\n        const characteristicName = getCharacteristicNameFromUUID(\n          characteristic.uuid\n        )!;\n        _console.assertWithError(\n          Boolean(characteristicName),\n          `no name found for characteristic uuid \"${characteristic.uuid}\" in \"${serviceName}\" service`\n        );\n        _console.log(\n          `got \"${characteristicName}\" characteristic in \"${serviceName}\" service`\n        );\n        characteristic.name = characteristicName;\n        this.#characteristics.set(characteristicName, characteristic);\n        addEventListeners(\n          characteristic,\n          this.#boundBluetoothCharacteristicEventListeners\n        );\n        const characteristicProperties =\n          characteristic.properties ||\n          getCharacteristicProperties(characteristicName);\n        if (characteristicProperties.notify) {\n          _console.log(\n            `starting notifications for \"${characteristicName}\" characteristic`\n          );\n          await characteristic.startNotifications();\n        }\n        if (characteristicProperties.read) {\n          _console.log(`reading \"${characteristicName}\" characteristic...`);\n          await characteristic.readValue();\n          if (isInBluefy || isInWebBLE) {\n            this.#onCharacteristicValueChanged(characteristic);\n          }\n        }\n      }\n    }\n  }\n  async #removeEventListeners() {\n    if (this.device) {\n      removeEventListeners(\n        this.device,\n        this.#boundBluetoothDeviceEventListeners\n      );\n    }\n\n    const promises = Array.from(this.#characteristics.keys()).map(\n      (characteristicName) => {\n        const characteristic = this.#characteristics.get(characteristicName)!;\n        removeEventListeners(\n          characteristic,\n          this.#boundBluetoothCharacteristicEventListeners\n        );\n        const characteristicProperties =\n          characteristic.properties ||\n          getCharacteristicProperties(characteristicName);\n        if (characteristicProperties.notify) {\n          _console.log(\n            `stopping notifications for \"${characteristicName}\" characteristic`\n          );\n          return characteristic.stopNotifications();\n        }\n      }\n    );\n\n    return Promise.allSettled(promises);\n  }\n  async disconnect() {\n    await this.#removeEventListeners();\n    await super.disconnect();\n    this.server?.disconnect();\n    this.status = \"notConnected\";\n  }\n\n  #onCharacteristicvaluechanged(event: Event) {\n    _console.log(\"oncharacteristicvaluechanged\");\n\n    const characteristic = event.target as BluetoothCharacteristic;\n    this.#onCharacteristicValueChanged(characteristic);\n  }\n\n  #onCharacteristicValueChanged(characteristic: BluetoothCharacteristic) {\n    _console.log(\"onCharacteristicValue\");\n\n    const characteristicName = characteristic.name!;\n    _console.assertWithError(\n      Boolean(characteristicName),\n      `no name found for characteristic with uuid \"${characteristic.uuid}\"`\n    );\n\n    _console.log(\n      `oncharacteristicvaluechanged for \"${characteristicName}\" characteristic`\n    );\n    const dataView = characteristic.value!;\n    _console.assertWithError(\n      dataView,\n      `no data found for \"${characteristicName}\" characteristic`\n    );\n    _console.log(\n      `data for \"${characteristicName}\" characteristic`,\n      Array.from(new Uint8Array(dataView.buffer))\n    );\n\n    try {\n      this.onCharacteristicValueChanged(characteristicName, dataView);\n    } catch (error) {\n      _console.error(error);\n    }\n  }\n\n  async writeCharacteristic(\n    characteristicName: BluetoothCharacteristicName,\n    data: ArrayBuffer\n  ) {\n    super.writeCharacteristic(characteristicName, data);\n\n    const characteristic = this.#characteristics.get(characteristicName)!;\n    _console.assertWithError(\n      characteristic,\n      `${characteristicName} characteristic not found`\n    );\n    _console.log(\"writing characteristic\", characteristic, data);\n    const characteristicProperties =\n      characteristic.properties ||\n      getCharacteristicProperties(characteristicName);\n    if (characteristicProperties.writeWithoutResponse) {\n      _console.log(\"writing without response\");\n      await characteristic.writeValueWithoutResponse(data);\n    } else {\n      _console.log(\"writing with response\");\n      await characteristic.writeValueWithResponse(data);\n    }\n    _console.log(\"wrote characteristic\");\n\n    if (characteristicProperties.read && !characteristicProperties.notify) {\n      _console.log(\"reading value after write...\");\n      await characteristic.readValue();\n      if (isInBluefy || isInWebBLE) {\n        this.#onCharacteristicValueChanged(characteristic);\n      }\n    }\n  }\n\n  #onGattserverdisconnected() {\n    _console.log(\"gattserverdisconnected\");\n    this.status = \"notConnected\";\n  }\n\n  get canReconnect() {\n    return Boolean(this.server && !this.server.connected && this.isInRange);\n  }\n  async reconnect() {\n    await super.reconnect();\n    try {\n      await this.server!.connect();\n    } catch (error) {\n      _console.error(error);\n      this.isInRange = false;\n    }\n\n    if (this.isConnected) {\n      _console.log(\"successfully reconnected!\");\n      await this.#getServicesAndCharacteristics();\n      this.status = \"connected\";\n    } else {\n      _console.log(\"unable to reconnect\");\n      this.status = \"notConnected\";\n    }\n  }\n\n  remove() {\n    super.remove();\n    this.device = undefined;\n  }\n}\n\nexport default WebBluetoothConnectionManager;\n","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2016 Patrick Gansterer <paroga@paroga.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst POW_2_24 = 5.960464477539063e-8;\nconst POW_2_32 = 4294967296;\nconst POW_2_53 = 9007199254740992;\n\nexport function encode(value) {\n  let data = new ArrayBuffer(256);\n  let dataView = new DataView(data);\n  let lastLength;\n  let offset = 0;\n\n  function prepareWrite(length) {\n    let newByteLength = data.byteLength;\n    const requiredLength = offset + length;\n    while (newByteLength < requiredLength) {\n      newByteLength <<= 1;\n    }\n    if (newByteLength !== data.byteLength) {\n      const oldDataView = dataView;\n      data = new ArrayBuffer(newByteLength);\n      dataView = new DataView(data);\n      const uint32count = (offset + 3) >> 2;\n      for (let i = 0; i < uint32count; ++i) {\n        dataView.setUint32(i << 2, oldDataView.getUint32(i << 2));\n      }\n    }\n\n    lastLength = length;\n    return dataView;\n  }\n  function commitWrite() {\n    offset += lastLength;\n  }\n  function writeFloat64(value) {\n    commitWrite(prepareWrite(8).setFloat64(offset, value));\n  }\n  function writeUint8(value) {\n    commitWrite(prepareWrite(1).setUint8(offset, value));\n  }\n  function writeUint8Array(value) {\n    const dataView = prepareWrite(value.length);\n    for (let i = 0; i < value.length; ++i) {\n      dataView.setUint8(offset + i, value[i]);\n    }\n    commitWrite();\n  }\n  function writeUint16(value) {\n    commitWrite(prepareWrite(2).setUint16(offset, value));\n  }\n  function writeUint32(value) {\n    commitWrite(prepareWrite(4).setUint32(offset, value));\n  }\n  function writeUint64(value) {\n    const low = value % POW_2_32;\n    const high = (value - low) / POW_2_32;\n    const dataView = prepareWrite(8);\n    dataView.setUint32(offset, high);\n    dataView.setUint32(offset + 4, low);\n    commitWrite();\n  }\n  function writeTypeAndLength(type, length) {\n    if (length < 24) {\n      writeUint8((type << 5) | length);\n    } else if (length < 0x100) {\n      writeUint8((type << 5) | 24);\n      writeUint8(length);\n    } else if (length < 0x10000) {\n      writeUint8((type << 5) | 25);\n      writeUint16(length);\n    } else if (length < 0x100000000) {\n      writeUint8((type << 5) | 26);\n      writeUint32(length);\n    } else {\n      writeUint8((type << 5) | 27);\n      writeUint64(length);\n    }\n  }\n\n  function encodeItem(value) {\n    let i;\n    const utf8data = [];\n    let length;\n\n    if (value === false) {\n      return writeUint8(0xf4);\n    }\n    if (value === true) {\n      return writeUint8(0xf5);\n    }\n    if (value === null) {\n      return writeUint8(0xf6);\n    }\n    if (value === undefined) {\n      return writeUint8(0xf7);\n    }\n\n    switch (typeof value) {\n      case \"number\":\n        if (Math.floor(value) === value) {\n          if (value >= 0 && value <= POW_2_53) {\n            return writeTypeAndLength(0, value);\n          }\n          if (-POW_2_53 <= value && value < 0) {\n            return writeTypeAndLength(1, -(value + 1));\n          }\n        }\n        writeUint8(0xfb);\n        return writeFloat64(value);\n\n      case \"string\":\n        for (i = 0; i < value.length; ++i) {\n          let charCode = value.charCodeAt(i);\n          if (charCode < 0x80) {\n            utf8data.push(charCode);\n          } else if (charCode < 0x800) {\n            utf8data.push(0xc0 | (charCode >> 6));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          } else if (charCode < 0xd800) {\n            utf8data.push(0xe0 | (charCode >> 12));\n            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          } else {\n            charCode = (charCode & 0x3ff) << 10;\n            charCode |= value.charCodeAt(++i) & 0x3ff;\n            charCode += 0x10000;\n\n            utf8data.push(0xf0 | (charCode >> 18));\n            utf8data.push(0x80 | ((charCode >> 12) & 0x3f));\n            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          }\n        }\n\n        writeTypeAndLength(3, utf8data.length);\n        return writeUint8Array(utf8data);\n\n      default:\n        if (Array.isArray(value)) {\n          length = value.length;\n          writeTypeAndLength(4, length);\n          for (i = 0; i < length; ++i) {\n            encodeItem(value[i]);\n          }\n        } else if (value instanceof Uint8Array) {\n          writeTypeAndLength(2, value.length);\n          writeUint8Array(value);\n        } else {\n          const keys = Object.keys(value);\n          length = keys.length;\n          writeTypeAndLength(5, length);\n          for (i = 0; i < length; ++i) {\n            const key = keys[i];\n            encodeItem(key);\n            encodeItem(value[key]);\n          }\n        }\n    }\n  }\n\n  encodeItem(value);\n\n  if (\"slice\" in data) {\n    return data.slice(0, offset);\n  }\n\n  const ret = new ArrayBuffer(offset);\n  const retView = new DataView(ret);\n  for (let i = 0; i < offset; ++i) {\n    retView.setUint8(i, dataView.getUint8(i));\n  }\n  return ret;\n}\n\nexport function decode(data, tagger, simpleValue) {\n  const dataView = new DataView(data);\n  let offset = 0;\n\n  if (typeof tagger !== \"function\") {\n    tagger = function (value) {\n      return value;\n    };\n  }\n  if (typeof simpleValue !== \"function\") {\n    simpleValue = function () {\n      return undefined;\n    };\n  }\n\n  function commitRead(length, value) {\n    offset += length;\n    return value;\n  }\n  function readArrayBuffer(length) {\n    return commitRead(length, new Uint8Array(data, offset, length));\n  }\n  function readFloat16() {\n    const tempArrayBuffer = new ArrayBuffer(4);\n    const tempDataView = new DataView(tempArrayBuffer);\n    const value = readUint16();\n\n    const sign = value & 0x8000;\n    let exponent = value & 0x7c00;\n    const fraction = value & 0x03ff;\n\n    if (exponent === 0x7c00) {\n      exponent = 0xff << 10;\n    } else if (exponent !== 0) {\n      exponent += (127 - 15) << 10;\n    } else if (fraction !== 0) {\n      return (sign ? -1 : 1) * fraction * POW_2_24;\n    }\n\n    tempDataView.setUint32(0, (sign << 16) | (exponent << 13) | (fraction << 13));\n    return tempDataView.getFloat32(0);\n  }\n  function readFloat32() {\n    return commitRead(4, dataView.getFloat32(offset));\n  }\n  function readFloat64() {\n    return commitRead(8, dataView.getFloat64(offset));\n  }\n  function readUint8() {\n    return commitRead(1, dataView.getUint8(offset));\n  }\n  function readUint16() {\n    return commitRead(2, dataView.getUint16(offset));\n  }\n  function readUint32() {\n    return commitRead(4, dataView.getUint32(offset));\n  }\n  function readUint64() {\n    return readUint32() * POW_2_32 + readUint32();\n  }\n  function readBreak() {\n    if (dataView.getUint8(offset) !== 0xff) {\n      return false;\n    }\n    offset += 1;\n    return true;\n  }\n  function readLength(additionalInformation) {\n    if (additionalInformation < 24) {\n      return additionalInformation;\n    }\n    if (additionalInformation === 24) {\n      return readUint8();\n    }\n    if (additionalInformation === 25) {\n      return readUint16();\n    }\n    if (additionalInformation === 26) {\n      return readUint32();\n    }\n    if (additionalInformation === 27) {\n      return readUint64();\n    }\n    if (additionalInformation === 31) {\n      return -1;\n    }\n    throw new Error(\"Invalid length encoding\");\n  }\n  function readIndefiniteStringLength(majorType) {\n    const initialByte = readUint8();\n    if (initialByte === 0xff) {\n      return -1;\n    }\n    const length = readLength(initialByte & 0x1f);\n    if (length < 0 || initialByte >> 5 !== majorType) {\n      throw new Error(\"Invalid indefinite length element\");\n    }\n    return length;\n  }\n\n  function appendUtf16Data(utf16data, length) {\n    for (let i = 0; i < length; ++i) {\n      let value = readUint8();\n      if (value & 0x80) {\n        if (value < 0xe0) {\n          value = ((value & 0x1f) << 6) | (readUint8() & 0x3f);\n          length -= 1;\n        } else if (value < 0xf0) {\n          value = ((value & 0x0f) << 12) | ((readUint8() & 0x3f) << 6) | (readUint8() & 0x3f);\n          length -= 2;\n        } else {\n          value =\n            ((value & 0x0f) << 18) | ((readUint8() & 0x3f) << 12) | ((readUint8() & 0x3f) << 6) | (readUint8() & 0x3f);\n          length -= 3;\n        }\n      }\n\n      if (value < 0x10000) {\n        utf16data.push(value);\n      } else {\n        value -= 0x10000;\n        utf16data.push(0xd800 | (value >> 10));\n        utf16data.push(0xdc00 | (value & 0x3ff));\n      }\n    }\n  }\n\n  function decodeItem() {\n    const initialByte = readUint8();\n    const majorType = initialByte >> 5;\n    const additionalInformation = initialByte & 0x1f;\n    let i;\n    let length;\n\n    if (majorType === 7) {\n      switch (additionalInformation) {\n        case 25:\n          return readFloat16();\n        case 26:\n          return readFloat32();\n        case 27:\n          return readFloat64();\n      }\n    }\n\n    length = readLength(additionalInformation);\n    if (length < 0 && (majorType < 2 || majorType > 6)) {\n      throw new Error(\"Invalid length\");\n    }\n\n    const utf16data = [];\n    let retArray;\n    const retObject = {};\n\n    switch (majorType) {\n      case 0:\n        return length;\n      case 1:\n        return -1 - length;\n      case 2:\n        if (length < 0) {\n          const elements = [];\n          let fullArrayLength = 0;\n          while ((length = readIndefiniteStringLength(majorType)) >= 0) {\n            fullArrayLength += length;\n            elements.push(readArrayBuffer(length));\n          }\n          const fullArray = new Uint8Array(fullArrayLength);\n          let fullArrayOffset = 0;\n          for (i = 0; i < elements.length; ++i) {\n            fullArray.set(elements[i], fullArrayOffset);\n            fullArrayOffset += elements[i].length;\n          }\n          return fullArray;\n        }\n        return readArrayBuffer(length);\n      case 3:\n        if (length < 0) {\n          while ((length = readIndefiniteStringLength(majorType)) >= 0) {\n            appendUtf16Data(utf16data, length);\n          }\n        } else {\n          appendUtf16Data(utf16data, length);\n        }\n        return String.fromCharCode.apply(null, utf16data);\n      case 4:\n        if (length < 0) {\n          retArray = [];\n          while (!readBreak()) {\n            retArray.push(decodeItem());\n          }\n        } else {\n          retArray = new Array(length);\n          for (i = 0; i < length; ++i) {\n            retArray[i] = decodeItem();\n          }\n        }\n        return retArray;\n      case 5:\n        for (i = 0; i < length || (length < 0 && !readBreak()); ++i) {\n          const key = decodeItem();\n          retObject[key] = decodeItem();\n        }\n        return retObject;\n      case 6:\n        return tagger(decodeItem(), length);\n      case 7:\n        switch (length) {\n          case 20:\n            return false;\n          case 21:\n            return true;\n          case 22:\n            return null;\n          case 23:\n            return undefined;\n          default:\n            return simpleValue(length);\n        }\n    }\n  }\n\n  const ret = decodeItem();\n  if (offset !== data.byteLength) {\n    throw new Error(\"Remaining bytes\");\n  }\n  return ret;\n}\n\nexport const CBOR = {\n  encode,\n  decode,\n};\n","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2023 Laird Connectivity\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * @file mcumgr\n * @brief Provides MCU manager operation functions for the Xbit USB Shell.\n * This file is inspired by the MIT licensed mcumgr file originally\n * authored by Andras Barthazi (https://github.com/boogie/mcumgr-web),\n * updated to also support file upload/download over SMP.\n */\n\nimport { CBOR } from \"./cbor.js\";\nimport { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"mcumgr\", { log: false });\n\nexport const constants = {\n  // Opcodes\n  MGMT_OP_READ: 0,\n  MGMT_OP_READ_RSP: 1,\n  MGMT_OP_WRITE: 2,\n  MGMT_OP_WRITE_RSP: 3,\n\n  // Groups\n  MGMT_GROUP_ID_OS: 0,\n  MGMT_GROUP_ID_IMAGE: 1,\n  MGMT_GROUP_ID_STAT: 2,\n  MGMT_GROUP_ID_CONFIG: 3,\n  MGMT_GROUP_ID_LOG: 4,\n  MGMT_GROUP_ID_CRASH: 5,\n  MGMT_GROUP_ID_SPLIT: 6,\n  MGMT_GROUP_ID_RUN: 7,\n  MGMT_GROUP_ID_FS: 8,\n  MGMT_GROUP_ID_SHELL: 9,\n\n  // OS group\n  OS_MGMT_ID_ECHO: 0,\n  OS_MGMT_ID_CONS_ECHO_CTRL: 1,\n  OS_MGMT_ID_TASKSTAT: 2,\n  OS_MGMT_ID_MPSTAT: 3,\n  OS_MGMT_ID_DATETIME_STR: 4,\n  OS_MGMT_ID_RESET: 5,\n\n  // Image group\n  IMG_MGMT_ID_STATE: 0,\n  IMG_MGMT_ID_UPLOAD: 1,\n  IMG_MGMT_ID_FILE: 2,\n  IMG_MGMT_ID_CORELIST: 3,\n  IMG_MGMT_ID_CORELOAD: 4,\n  IMG_MGMT_ID_ERASE: 5,\n\n  // Filesystem group\n  FS_MGMT_ID_FILE: 0,\n};\n\nexport class MCUManager {\n  constructor() {\n    this._mtu = 256;\n    this._messageCallback = null;\n    this._imageUploadProgressCallback = null;\n    this._imageUploadNextCallback = null;\n    this._fileUploadProgressCallback = null;\n    this._fileUploadNextCallback = null;\n    this._uploadIsInProgress = false;\n    this._downloadIsInProgress = false;\n    this._buffer = new Uint8Array();\n    this._seq = 0;\n  }\n\n  onMessage(callback) {\n    this._messageCallback = callback;\n    return this;\n  }\n\n  onImageUploadNext(callback) {\n    this._imageUploadNextCallback = callback;\n    return this;\n  }\n\n  onImageUploadProgress(callback) {\n    this._imageUploadProgressCallback = callback;\n    return this;\n  }\n\n  onImageUploadFinished(callback) {\n    this._imageUploadFinishedCallback = callback;\n    return this;\n  }\n\n  onFileUploadNext(callback) {\n    this._fileUploadNextCallback = callback;\n    return this;\n  }\n\n  onFileUploadProgress(callback) {\n    this._fileUploadProgressCallback = callback;\n    return this;\n  }\n\n  onFileUploadFinished(callback) {\n    this._fileUploadFinishedCallback = callback;\n    return this;\n  }\n\n  onFileDownloadNext(callback) {\n    this._fileDownloadNextCallback = callback;\n    return this;\n  }\n\n  onFileDownloadProgress(callback) {\n    this._fileDownloadProgressCallback = callback;\n    return this;\n  }\n\n  onFileDownloadFinished(callback) {\n    this._fileDownloadFinishedCallback = callback;\n    return this;\n  }\n\n  _getMessage(op, group, id, data) {\n    const _flags = 0;\n    let encodedData = [];\n    if (typeof data !== \"undefined\") {\n      encodedData = [...new Uint8Array(CBOR.encode(data))];\n    }\n    const lengthLo = encodedData.length & 255;\n    const lengthHi = encodedData.length >> 8;\n    const groupLo = group & 255;\n    const groupHi = group >> 8;\n    const message = [op, _flags, lengthHi, lengthLo, groupHi, groupLo, this._seq, id, ...encodedData];\n    this._seq = (this._seq + 1) % 256;\n\n    return message;\n  }\n\n  _notification(buffer) {\n    _console.log(\"mcumgr - message received\");\n    const message = new Uint8Array(buffer);\n    this._buffer = new Uint8Array([...this._buffer, ...message]);\n    const messageLength = this._buffer[2] * 256 + this._buffer[3];\n    if (this._buffer.length < messageLength + 8) return;\n    this._processMessage(this._buffer.slice(0, messageLength + 8));\n    this._buffer = this._buffer.slice(messageLength + 8);\n  }\n\n  _processMessage(message) {\n    const [op, , lengthHi, lengthLo, groupHi, groupLo, , id] = message;\n    const data = CBOR.decode(message.slice(8).buffer);\n    const length = lengthHi * 256 + lengthLo;\n    const group = groupHi * 256 + groupLo;\n\n    _console.log(\"mcumgr - Process Message - Group: \" + group + \", Id: \" + id + \", Off: \" + data.off);\n    if (group === constants.MGMT_GROUP_ID_IMAGE && id === constants.IMG_MGMT_ID_UPLOAD && data.off) {\n      this._uploadOffset = data.off;\n      this._uploadNext();\n      return;\n    }\n    if (\n      op === constants.MGMT_OP_WRITE_RSP &&\n      group === constants.MGMT_GROUP_ID_FS &&\n      id === constants.FS_MGMT_ID_FILE &&\n      data.off\n    ) {\n      this._uploadFileOffset = data.off;\n      this._uploadFileNext();\n      return;\n    }\n    if (op === constants.MGMT_OP_READ_RSP && group === constants.MGMT_GROUP_ID_FS && id === constants.FS_MGMT_ID_FILE) {\n      this._downloadFileOffset += data.data.length;\n      if (data.len != undefined) {\n        this._downloadFileLength = data.len;\n      }\n      _console.log(\"downloaded \" + this._downloadFileOffset + \" bytes of \" + this._downloadFileLength);\n      if (this._downloadFileLength > 0) {\n        this._fileDownloadProgressCallback({\n          percentage: Math.floor((this._downloadFileOffset / this._downloadFileLength) * 100),\n        });\n      }\n      if (this._messageCallback) this._messageCallback({ op, group, id, data, length });\n      this._downloadFileNext();\n      return;\n    }\n\n    if (this._messageCallback) this._messageCallback({ op, group, id, data, length });\n  }\n\n  cmdReset() {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_OS, constants.OS_MGMT_ID_RESET);\n  }\n\n  smpEcho(message) {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_OS, constants.OS_MGMT_ID_ECHO, {\n      d: message,\n    });\n  }\n\n  cmdImageState() {\n    return this._getMessage(constants.MGMT_OP_READ, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE);\n  }\n\n  cmdImageErase() {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_ERASE, {});\n  }\n\n  cmdImageTest(hash) {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE, {\n      hash,\n      confirm: false,\n    });\n  }\n\n  cmdImageConfirm(hash) {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE, {\n      hash,\n      confirm: true,\n    });\n  }\n\n  _hash(image) {\n    return crypto.subtle.digest(\"SHA-256\", image);\n  }\n\n  async _uploadNext() {\n    if (!this._uploadImage) {\n      return;\n    }\n\n    if (this._uploadOffset >= this._uploadImage.byteLength) {\n      this._uploadIsInProgress = false;\n      this._imageUploadFinishedCallback();\n      return;\n    }\n\n    const nmpOverhead = 8;\n    const message = { data: new Uint8Array(), off: this._uploadOffset };\n    if (this._uploadOffset === 0) {\n      message.len = this._uploadImage.byteLength;\n      message.sha = new Uint8Array(await this._hash(this._uploadImage));\n    }\n    this._imageUploadProgressCallback({\n      percentage: Math.floor((this._uploadOffset / this._uploadImage.byteLength) * 100),\n    });\n\n    const length = this._mtu - CBOR.encode(message).byteLength - nmpOverhead - 3 - 5;\n\n    message.data = new Uint8Array(this._uploadImage.slice(this._uploadOffset, this._uploadOffset + length));\n\n    this._uploadOffset += length;\n\n    const packet = this._getMessage(\n      constants.MGMT_OP_WRITE,\n      constants.MGMT_GROUP_ID_IMAGE,\n      constants.IMG_MGMT_ID_UPLOAD,\n      message\n    );\n\n    _console.log(\"mcumgr - _uploadNext: Message Length: \" + packet.length);\n\n    this._imageUploadNextCallback({ packet });\n  }\n  async reset() {\n    this._messageCallback = null;\n    this._imageUploadProgressCallback = null;\n    this._imageUploadNextCallback = null;\n    this._fileUploadProgressCallback = null;\n    this._fileUploadNextCallback = null;\n    this._uploadIsInProgress = false;\n    this._downloadIsInProgress = false;\n    this._buffer = new Uint8Array();\n    this._seq = 0;\n  }\n\n  async cmdUpload(image, slot = 0) {\n    if (this._uploadIsInProgress) {\n      _console.error(\"Upload is already in progress.\");\n      return;\n    }\n    this._uploadIsInProgress = true;\n\n    this._uploadOffset = 0;\n    this._uploadImage = image;\n    this._uploadSlot = slot;\n\n    this._uploadNext();\n  }\n\n  async cmdUploadFile(filebuf, destFilename) {\n    if (this._uploadIsInProgress) {\n      _console.error(\"Upload is already in progress.\");\n      return;\n    }\n    this._uploadIsInProgress = true;\n    this._uploadFileOffset = 0;\n    this._uploadFile = filebuf;\n    this._uploadFilename = destFilename;\n\n    this._uploadFileNext();\n  }\n\n  async _uploadFileNext() {\n    _console.log(\"uploadFileNext - offset: \" + this._uploadFileOffset + \", length: \" + this._uploadFile.byteLength);\n\n    if (this._uploadFileOffset >= this._uploadFile.byteLength) {\n      this._uploadIsInProgress = false;\n      this._fileUploadFinishedCallback();\n      return;\n    }\n\n    const nmpOverhead = 8;\n    const message = { data: new Uint8Array(), off: this._uploadFileOffset };\n    if (this._uploadFileOffset === 0) {\n      message.len = this._uploadFile.byteLength;\n    }\n    message.name = this._uploadFilename;\n    this._fileUploadProgressCallback({\n      percentage: Math.floor((this._uploadFileOffset / this._uploadFile.byteLength) * 100),\n    });\n\n    const length = this._mtu - CBOR.encode(message).byteLength - nmpOverhead;\n\n    message.data = new Uint8Array(this._uploadFile.slice(this._uploadFileOffset, this._uploadFileOffset + length));\n\n    this._uploadFileOffset += length;\n\n    const packet = this._getMessage(\n      constants.MGMT_OP_WRITE,\n      constants.MGMT_GROUP_ID_FS,\n      constants.FS_MGMT_ID_FILE,\n      message\n    );\n\n    _console.log(\"mcumgr - _uploadNext: Message Length: \" + packet.length);\n\n    this._fileUploadNextCallback({ packet });\n  }\n\n  async cmdDownloadFile(filename, destFilename) {\n    if (this._downloadIsInProgress) {\n      _console.error(\"Download is already in progress.\");\n      return;\n    }\n    this._downloadIsInProgress = true;\n    this._downloadFileOffset = 0;\n    this._downloadFileLength = 0;\n    this._downloadRemoteFilename = filename;\n    this._downloadLocalFilename = destFilename;\n\n    this._downloadFileNext();\n  }\n\n  async _downloadFileNext() {\n    if (this._downloadFileLength > 0) {\n      if (this._downloadFileOffset >= this._downloadFileLength) {\n        this._downloadIsInProgress = false;\n        this._fileDownloadFinishedCallback();\n        return;\n      }\n    }\n\n    const message = { off: this._downloadFileOffset };\n    if (this._downloadFileOffset === 0) {\n      message.name = this._downloadRemoteFilename;\n    }\n\n    const packet = this._getMessage(\n      constants.MGMT_OP_READ,\n      constants.MGMT_GROUP_ID_FS,\n      constants.FS_MGMT_ID_FILE,\n      message\n    );\n    _console.log(\"mcumgr - _downloadNext: Message Length: \" + packet.length);\n    this._fileDownloadNextCallback({ packet });\n  }\n\n  async imageInfo(image) {\n    const info = {};\n    const view = new Uint8Array(image);\n\n    // check header length\n    if (view.length < 32) {\n      throw new Error(\"Invalid image (too short file)\");\n    }\n\n    // check MAGIC bytes 0x96f3b83d\n    if (view[0] !== 0x3d || view[1] !== 0xb8 || view[2] !== 0xf3 || view[3] !== 0x96) {\n      throw new Error(\"Invalid image (wrong magic bytes)\");\n    }\n\n    // check load address is 0x00000000\n    if (view[4] !== 0x00 || view[5] !== 0x00 || view[6] !== 0x00 || view[7] !== 0x00) {\n      throw new Error(\"Invalid image (wrong load address)\");\n    }\n\n    const headerSize = view[8] + view[9] * 2 ** 8;\n\n    // check protected TLV area size is 0\n    if (view[10] !== 0x00 || view[11] !== 0x00) {\n      throw new Error(\"Invalid image (wrong protected TLV area size)\");\n    }\n\n    const imageSize = view[12] + view[13] * 2 ** 8 + view[14] * 2 ** 16 + view[15] * 2 ** 24;\n    info.imageSize = imageSize;\n\n    // check image size is correct\n    if (view.length < imageSize + headerSize) {\n      throw new Error(\"Invalid image (wrong image size)\");\n    }\n\n    // check flags is 0x00000000\n    if (view[16] !== 0x00 || view[17] !== 0x00 || view[18] !== 0x00 || view[19] !== 0x00) {\n      throw new Error(\"Invalid image (wrong flags)\");\n    }\n\n    const version = `${view[20]}.${view[21]}.${view[22] + view[23] * 2 ** 8}`;\n    info.version = version;\n\n    info.hash = [...new Uint8Array(await this._hash(image.slice(0, imageSize + 32)))]\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n\n    return info;\n  }\n}\n","import Device, { SendSmpMessageCallback } from \"./Device.ts\";\nimport { getFileBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { MCUManager, constants } from \"./utils/mcumgr.js\";\nimport { FileLike } from \"./utils/ArrayBufferUtils.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"FirmwareManager\", { log: false });\n\nexport const FirmwareMessageTypes = [\"smp\"] as const;\nexport type FirmwareMessageType = (typeof FirmwareMessageTypes)[number];\n\nexport const FirmwareEventTypes = [\n  ...FirmwareMessageTypes,\n  \"firmwareImages\",\n  \"firmwareUploadProgress\",\n  \"firmwareStatus\",\n  \"firmwareUploadComplete\",\n] as const;\nexport type FirmwareEventType = (typeof FirmwareEventTypes)[number];\n\nexport const FirmwareStatuses = [\"idle\", \"uploading\", \"uploaded\", \"pending\", \"testing\", \"erasing\"] as const;\nexport type FirmwareStatus = (typeof FirmwareStatuses)[number];\n\nexport interface FirmwareImage {\n  slot: number;\n  active: boolean;\n  confirmed: boolean;\n  pending: boolean;\n  permanent: boolean;\n  bootable: boolean;\n  version: string;\n  hash?: Uint8Array;\n  empty?: boolean;\n}\n\nexport interface FirmwareEventMessages {\n  smp: { dataView: DataView };\n  firmwareImages: { firmwareImages: FirmwareImage[] };\n  firmwareUploadProgress: { progress: number };\n  firmwareStatus: { firmwareStatus: FirmwareStatus };\n  //firmwareUploadComplete: {};\n}\n\nexport type FirmwareEventDispatcher = EventDispatcher<Device, FirmwareEventType, FirmwareEventMessages>;\n\nclass FirmwareManager {\n  sendMessage!: SendSmpMessageCallback;\n\n  constructor() {\n    this.#assignMcuManagerCallbacks();\n    autoBind(this);\n  }\n\n  eventDispatcher!: FirmwareEventDispatcher;\n  get addEventListenter() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  parseMessage(messageType: FirmwareMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"smp\":\n        this.#mcuManager._notification(Array.from(new Uint8Array(dataView.buffer)));\n        this.#dispatchEvent(\"smp\", { dataView });\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  async uploadFirmware(file: FileLike) {\n    _console.log(\"uploadFirmware\", file);\n\n    const promise = this.waitForEvent(\"firmwareUploadComplete\");\n\n    await this.getImages();\n\n    const arrayBuffer = await getFileBuffer(file);\n    const imageInfo = await this.#mcuManager.imageInfo(arrayBuffer);\n    _console.log({ imageInfo });\n\n    this.#mcuManager.cmdUpload(arrayBuffer, 1);\n\n    this.#updateStatus(\"uploading\");\n\n    await promise;\n  }\n\n  #status: FirmwareStatus = \"idle\";\n  get status() {\n    return this.#status;\n  }\n  #updateStatus(newStatus: FirmwareStatus) {\n    _console.assertEnumWithError(newStatus, FirmwareStatuses);\n    if (this.#status == newStatus) {\n      _console.log(`redundant firmwareStatus assignment \"${newStatus}\"`);\n      return;\n    }\n\n    this.#status = newStatus;\n    _console.log({ firmwareStatus: this.#status });\n    this.#dispatchEvent(\"firmwareStatus\", { firmwareStatus: this.#status });\n  }\n\n  // COMMANDS\n\n  #images!: FirmwareImage[];\n  get images() {\n    return this.#images;\n  }\n  #assertImages() {\n    _console.assertWithError(this.#images, \"didn't get imageState\");\n  }\n  #assertValidImageIndex(imageIndex: number) {\n    _console.assertTypeWithError(imageIndex, \"number\");\n    _console.assertWithError(imageIndex == 0 || imageIndex == 1, \"imageIndex must be 0 or 1\");\n  }\n  async getImages() {\n    const promise = this.waitForEvent(\"firmwareImages\");\n\n    _console.log(\"getting firmware image state...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageState()).buffer);\n\n    await promise;\n  }\n\n  async testImage(imageIndex: number = 1) {\n    this.#assertValidImageIndex(imageIndex);\n    this.#assertImages();\n    if (!this.#images[imageIndex]) {\n      _console.log(`image ${imageIndex} not found`);\n      return;\n    }\n    if (this.#images[imageIndex].pending == true) {\n      _console.log(`image ${imageIndex} is already pending`);\n      return;\n    }\n    if (this.#images[imageIndex].empty) {\n      _console.log(`image ${imageIndex} is empty`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"testing firmware image...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageTest(this.#images[imageIndex].hash)).buffer);\n\n    await promise;\n  }\n\n  async eraseImage() {\n    this.#assertImages();\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"erasing image...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageErase()).buffer);\n\n    this.#updateStatus(\"erasing\");\n\n    await promise;\n    await this.getImages();\n  }\n\n  async confirmImage(imageIndex: number = 0) {\n    this.#assertValidImageIndex(imageIndex);\n    this.#assertImages();\n    if (this.#images[imageIndex].confirmed === true) {\n      _console.log(`image ${imageIndex} is already confirmed`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"confirming image...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageConfirm(this.#images[imageIndex].hash)).buffer);\n\n    await promise;\n  }\n\n  async echo(string: string) {\n    _console.assertTypeWithError(string, \"string\");\n\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"sending echo...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.smpEcho(string)).buffer);\n\n    await promise;\n  }\n\n  async reset() {\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"resetting...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdReset()).buffer);\n\n    await promise;\n  }\n\n  // MTU\n  #mtu!: number;\n  get mtu() {\n    return this.#mtu;\n  }\n  set mtu(newMtu: number) {\n    this.#mtu = newMtu;\n    this.#mcuManager._mtu = newMtu;\n  }\n\n  // MCUManager\n  #mcuManager = new MCUManager();\n\n  #assignMcuManagerCallbacks() {\n    this.#mcuManager.onMessage(this.#onMcuMessage.bind(this));\n\n    this.#mcuManager.onFileDownloadNext(this.#onMcuFileDownloadNext);\n    this.#mcuManager.onFileDownloadProgress(this.#onMcuFileDownloadProgress.bind(this));\n    this.#mcuManager.onFileDownloadFinished(this.#onMcuFileDownloadFinished.bind(this));\n\n    this.#mcuManager.onFileUploadNext(this.#onMcuFileUploadNext.bind(this));\n    this.#mcuManager.onFileUploadProgress(this.#onMcuFileUploadProgress.bind(this));\n    this.#mcuManager.onFileUploadFinished(this.#onMcuFileUploadFinished.bind(this));\n\n    this.#mcuManager.onImageUploadNext(this.#onMcuImageUploadNext.bind(this));\n    this.#mcuManager.onImageUploadProgress(this.#onMcuImageUploadProgress.bind(this));\n    this.#mcuManager.onImageUploadFinished(this.#onMcuImageUploadFinished.bind(this));\n  }\n\n  #onMcuMessage({ op, group, id, data, length }: { op: number; group: number; id: number; data: any; length: number }) {\n    _console.log(\"onMcuMessage\", ...arguments);\n\n    switch (group) {\n      case constants.MGMT_GROUP_ID_OS:\n        switch (id) {\n          case constants.OS_MGMT_ID_ECHO:\n            _console.log(`echo \"${data.r}\"`);\n            break;\n          case constants.OS_MGMT_ID_TASKSTAT:\n            _console.table(data.tasks);\n            break;\n          case constants.OS_MGMT_ID_MPSTAT:\n            _console.log(data);\n            break;\n        }\n        break;\n      case constants.MGMT_GROUP_ID_IMAGE:\n        switch (id) {\n          case constants.IMG_MGMT_ID_STATE:\n            this.#onMcuImageState(data);\n        }\n        break;\n      default:\n        throw Error(`uncaught mcuMessage group ${group}`);\n    }\n  }\n\n  #onMcuFileDownloadNext() {\n    _console.log(\"onMcuFileDownloadNext\", ...arguments);\n  }\n  #onMcuFileDownloadProgress() {\n    _console.log(\"onMcuFileDownloadProgress\", ...arguments);\n  }\n  #onMcuFileDownloadFinished() {\n    _console.log(\"onMcuFileDownloadFinished\", ...arguments);\n  }\n\n  #onMcuFileUploadNext() {\n    _console.log(\"onMcuFileUploadNext\");\n  }\n  #onMcuFileUploadProgress() {\n    _console.log(\"onMcuFileUploadProgress\");\n  }\n  #onMcuFileUploadFinished() {\n    _console.log(\"onMcuFileUploadFinished\");\n  }\n\n  #onMcuImageUploadNext({ packet }: { packet: number[] }) {\n    _console.log(\"onMcuImageUploadNext\");\n    this.sendMessage(Uint8Array.from(packet).buffer);\n  }\n  #onMcuImageUploadProgress({ percentage }: { percentage: number }) {\n    const progress = percentage / 100;\n    _console.log(\"onMcuImageUploadProgress\", ...arguments);\n    this.#dispatchEvent(\"firmwareUploadProgress\", { progress });\n  }\n  async #onMcuImageUploadFinished() {\n    _console.log(\"onMcuImageUploadFinished\", ...arguments);\n\n    await this.getImages();\n\n    this.#dispatchEvent(\"firmwareUploadProgress\", { progress: 100 });\n    this.#dispatchEvent(\"firmwareUploadComplete\", {});\n  }\n\n  #onMcuImageState({ images }: { images?: FirmwareImage[] }) {\n    if (images) {\n      this.#images = images;\n      _console.log(\"images\", this.#images);\n    } else {\n      _console.log(\"no images found\");\n      return;\n    }\n\n    let newStatus: FirmwareStatus = \"idle\";\n\n    if (this.#images.length == 2) {\n      if (!this.#images[1].bootable) {\n        _console.warn('Slot 1 has a invalid image. Click \"Erase Image\" to erase it or upload a different image');\n      } else if (!this.#images[0].confirmed) {\n        _console.log(\n          'Slot 0 has a valid image. Click \"Confirm Image\" to confirm it or wait and the device will swap images back.'\n        );\n        newStatus = \"testing\";\n      } else {\n        if (this.#images[1].pending) {\n          _console.log(\"reset to upload to the new firmware image\");\n          newStatus = \"pending\";\n        } else {\n          _console.log(\"Slot 1 has a valid image. run testImage() to test it or upload a different image.\");\n          newStatus = \"uploaded\";\n        }\n      }\n    }\n\n    if (this.#images.length == 1) {\n      this.#images.push({\n        slot: 1,\n        empty: true,\n        version: \"Empty\",\n        pending: false,\n        confirmed: false,\n        bootable: false,\n        active: false,\n        permanent: false,\n      });\n\n      _console.log(\"Select a firmware upload image to upload to slot 1.\");\n    }\n\n    this.#updateStatus(newStatus);\n    this.#dispatchEvent(\"firmwareImages\", { firmwareImages: this.#images });\n  }\n}\n\nexport default FirmwareManager;\n","import { ConnectionStatus } from \"./connection/BaseConnectionManager.ts\";\nimport WebBluetoothConnectionManager from \"./connection/bluetooth/WebBluetoothConnectionManager.ts\";\nimport Device, { BoundDeviceEventListeners, DeviceEventMap } from \"./Device.ts\";\nimport { DeviceType } from \"./InformationManager.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInBluefy, isInBrowser } from \"./utils/environment.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"./utils/EventDispatcher.ts\";\nimport { addEventListeners } from \"./utils/EventUtils.ts\";\n\nconst _console = createConsole(\"DeviceManager\", { log: false });\n\nexport interface LocalStorageDeviceInformation {\n  type: DeviceType;\n  bluetoothId: string;\n  ipAddress?: string;\n  isWifiSecure?: boolean;\n}\n\nexport interface LocalStorageConfiguration {\n  devices: LocalStorageDeviceInformation[];\n}\n\nexport const DeviceManagerEventTypes = [\n  \"deviceConnected\",\n  \"deviceDisconnected\",\n  \"deviceIsConnected\",\n  \"availableDevices\",\n  \"connectedDevices\",\n] as const;\nexport type DeviceManagerEventType = (typeof DeviceManagerEventTypes)[number];\n\ninterface DeviceManagerEventMessage {\n  device: Device;\n}\nexport interface DeviceManagerEventMessages {\n  deviceConnected: DeviceManagerEventMessage;\n  deviceDisconnected: DeviceManagerEventMessage;\n  deviceIsConnected: DeviceManagerEventMessage;\n  availableDevices: { availableDevices: Device[] };\n  connectedDevices: { connectedDevices: Device[] };\n}\n\nexport type DeviceManagerEventDispatcher = EventDispatcher<\n  DeviceManager,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEventMap = EventMap<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEventListenerMap = EventListenerMap<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEvent = Event<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type BoundDeviceManagerEventListeners = BoundEventListeners<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\n\nclass DeviceManager {\n  static readonly shared = new DeviceManager();\n\n  constructor() {\n    if (DeviceManager.shared && this != DeviceManager.shared) {\n      throw Error(\"DeviceManager is a singleton - use DeviceManager.shared\");\n    }\n\n    if (this.CanUseLocalStorage) {\n      this.UseLocalStorage = true;\n    }\n  }\n\n  // DEVICE LISTENERS\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    getType: this.#onDeviceType.bind(this),\n    isConnected: this.#OnDeviceIsConnected.bind(this),\n  };\n  /** @private */\n  onDevice(device: Device) {\n    addEventListeners(device, this.#boundDeviceEventListeners);\n  }\n\n  #onDeviceType(event: DeviceEventMap[\"getType\"]) {\n    if (this.#UseLocalStorage) {\n      this.#UpdateLocalStorageConfigurationForDevice(event.target);\n    }\n  }\n\n  // CONNECTION STATUS\n  /** @private */\n  OnDeviceConnectionStatusUpdated(\n    device: Device,\n    connectionStatus: ConnectionStatus\n  ) {\n    if (\n      connectionStatus == \"notConnected\" &&\n      !device.canReconnect &&\n      this.#AvailableDevices.includes(device)\n    ) {\n      const deviceIndex = this.#AvailableDevices.indexOf(device);\n      this.AvailableDevices.splice(deviceIndex, 1);\n      this.#DispatchAvailableDevices();\n    }\n  }\n\n  // CONNECTED DEVICES\n\n  #ConnectedDevices: Device[] = [];\n  get ConnectedDevices() {\n    return this.#ConnectedDevices;\n  }\n\n  #UseLocalStorage = false;\n  get UseLocalStorage() {\n    return this.#UseLocalStorage;\n  }\n  set UseLocalStorage(newUseLocalStorage) {\n    this.#AssertLocalStorage();\n    _console.assertTypeWithError(newUseLocalStorage, \"boolean\");\n    this.#UseLocalStorage = newUseLocalStorage;\n    if (this.#UseLocalStorage && !this.#LocalStorageConfiguration) {\n      this.#LoadFromLocalStorage();\n    }\n  }\n\n  #DefaultLocalStorageConfiguration: LocalStorageConfiguration = {\n    devices: [],\n  };\n  #LocalStorageConfiguration?: LocalStorageConfiguration;\n\n  get CanUseLocalStorage() {\n    return isInBrowser && window.localStorage;\n  }\n\n  #AssertLocalStorage() {\n    _console.assertWithError(\n      isInBrowser,\n      \"localStorage is only available in the browser\"\n    );\n    _console.assertWithError(window.localStorage, \"localStorage not found\");\n  }\n  #LocalStorageKey = \"BS.Device\";\n  #SaveToLocalStorage() {\n    this.#AssertLocalStorage();\n    localStorage.setItem(\n      this.#LocalStorageKey,\n      JSON.stringify(this.#LocalStorageConfiguration)\n    );\n  }\n  async #LoadFromLocalStorage() {\n    this.#AssertLocalStorage();\n    let localStorageString = localStorage.getItem(this.#LocalStorageKey);\n    if (typeof localStorageString != \"string\") {\n      _console.log(\"no info found in localStorage\");\n      this.#LocalStorageConfiguration = Object.assign(\n        {},\n        this.#DefaultLocalStorageConfiguration\n      );\n      this.#SaveToLocalStorage();\n      return;\n    }\n    try {\n      const configuration = JSON.parse(localStorageString);\n      _console.log({ configuration });\n      this.#LocalStorageConfiguration = configuration;\n      if (this.CanGetDevices) {\n        await this.GetDevices(); // redundant?\n      }\n    } catch (error) {\n      _console.error(error);\n    }\n  }\n\n  #UpdateLocalStorageConfigurationForDevice(device: Device) {\n    if (device.connectionType != \"webBluetooth\") {\n      _console.log(\"localStorage is only for webBluetooth devices\");\n      return;\n    }\n    this.#AssertLocalStorage();\n    const deviceInformationIndex =\n      this.#LocalStorageConfiguration!.devices.findIndex(\n        (deviceInformation) => {\n          return deviceInformation.bluetoothId == device.bluetoothId;\n        }\n      );\n    if (deviceInformationIndex == -1) {\n      return;\n    }\n    this.#LocalStorageConfiguration!.devices[deviceInformationIndex].type =\n      device.type;\n    this.#SaveToLocalStorage();\n  }\n\n  // AVAILABLE DEVICES\n  #AvailableDevices: Device[] = [];\n  get AvailableDevices() {\n    return this.#AvailableDevices;\n  }\n\n  get CanGetDevices() {\n    return isInBrowser && navigator.bluetooth?.getDevices;\n  }\n  /**\n   * retrieves devices already connected via web bluetooth in other tabs/windows\n   *\n   * _only available on web-bluetooth enabled browsers_\n   */\n  async GetDevices(): Promise<Device[] | undefined> {\n    if (!isInBrowser) {\n      _console.warn(\"GetDevices is only available in the browser\");\n      return;\n    }\n\n    if (!navigator.bluetooth) {\n      _console.warn(\"bluetooth is not available in this browser\");\n      return;\n    }\n\n    if (isInBluefy) {\n      _console.warn(\"bluefy lists too many devices...\");\n      return;\n    }\n\n    if (!navigator.bluetooth.getDevices) {\n      _console.warn(\"bluetooth.getDevices() is not available in this browser\");\n      return;\n    }\n\n    if (!this.CanGetDevices) {\n      _console.log(\"CanGetDevices is false\");\n      return;\n    }\n\n    if (!this.#LocalStorageConfiguration) {\n      this.#LoadFromLocalStorage();\n    }\n\n    const configuration = this.#LocalStorageConfiguration!;\n    if (!configuration.devices || configuration.devices.length == 0) {\n      _console.log(\"no devices found in configuration\");\n      return;\n    }\n\n    const bluetoothDevices = await navigator.bluetooth.getDevices();\n\n    _console.log({ bluetoothDevices });\n\n    bluetoothDevices.forEach((bluetoothDevice) => {\n      if (!bluetoothDevice.gatt) {\n        return;\n      }\n      let deviceInformation = configuration.devices.find(\n        (deviceInformation) =>\n          bluetoothDevice.id == deviceInformation.bluetoothId\n      );\n      if (!deviceInformation) {\n        return;\n      }\n\n      let existingConnectedDevice = this.ConnectedDevices.filter(\n        (device) => device.connectionType == \"webBluetooth\"\n      ).find((device) => device.bluetoothId == bluetoothDevice.id);\n\n      const existingAvailableDevice = this.AvailableDevices.filter(\n        (device) => device.connectionType == \"webBluetooth\"\n      ).find((device) => device.bluetoothId == bluetoothDevice.id);\n      if (existingAvailableDevice) {\n        if (\n          existingConnectedDevice &&\n          existingConnectedDevice?.bluetoothId ==\n            existingAvailableDevice.bluetoothId &&\n          existingConnectedDevice != existingAvailableDevice\n        ) {\n          this.AvailableDevices[\n            this.#AvailableDevices.indexOf(existingAvailableDevice)\n          ] = existingConnectedDevice;\n        }\n        return;\n      }\n\n      if (existingConnectedDevice) {\n        this.AvailableDevices.push(existingConnectedDevice);\n        return;\n      }\n\n      const device = new Device();\n      const connectionManager = new WebBluetoothConnectionManager();\n      connectionManager.device = bluetoothDevice;\n      if (bluetoothDevice.name) {\n        device._informationManager.updateName(bluetoothDevice.name);\n      }\n      device._informationManager.updateType(deviceInformation.type);\n      device.connectionManager = connectionManager;\n      this.AvailableDevices.push(device);\n    });\n    this.#DispatchAvailableDevices();\n    return this.AvailableDevices;\n  }\n\n  // STATIC EVENTLISTENERS\n\n  #EventDispatcher: DeviceManagerEventDispatcher = new EventDispatcher(\n    this as DeviceManager,\n    DeviceManagerEventTypes\n  );\n\n  get AddEventListener() {\n    return this.#EventDispatcher.addEventListener;\n  }\n  get #DispatchEvent() {\n    return this.#EventDispatcher.dispatchEvent;\n  }\n  get RemoveEventListener() {\n    return this.#EventDispatcher.removeEventListener;\n  }\n  get RemoveEventListeners() {\n    return this.#EventDispatcher.removeEventListeners;\n  }\n  get RemoveAllEventListeners() {\n    return this.#EventDispatcher.removeAllEventListeners;\n  }\n\n  #OnDeviceIsConnected(event: DeviceEventMap[\"isConnected\"]) {\n    const { target: device } = event;\n    if (device.isConnected) {\n      if (!this.#ConnectedDevices.includes(device)) {\n        _console.log(\"adding device\", device);\n        this.#ConnectedDevices.push(device);\n        if (this.UseLocalStorage && device.connectionType == \"webBluetooth\") {\n          const deviceInformation: LocalStorageDeviceInformation = {\n            type: device.type,\n            bluetoothId: device.bluetoothId!,\n            ipAddress: device.ipAddress,\n            isWifiSecure: device.isWifiSecure,\n          };\n          const deviceInformationIndex =\n            this.#LocalStorageConfiguration!.devices.findIndex(\n              (_deviceInformation) =>\n                _deviceInformation.bluetoothId == deviceInformation.bluetoothId\n            );\n          if (deviceInformationIndex == -1) {\n            this.#LocalStorageConfiguration!.devices.push(deviceInformation);\n          } else {\n            this.#LocalStorageConfiguration!.devices[deviceInformationIndex] =\n              deviceInformation;\n          }\n          this.#SaveToLocalStorage();\n        }\n        this.#DispatchEvent(\"deviceConnected\", { device });\n        this.#DispatchEvent(\"deviceIsConnected\", { device });\n        this.#DispatchConnectedDevices();\n      } else {\n        _console.log(\"device already included\");\n      }\n    } else {\n      if (this.#ConnectedDevices.includes(device)) {\n        _console.log(\"removing device\", device);\n        this.#ConnectedDevices.splice(\n          this.#ConnectedDevices.indexOf(device),\n          1\n        );\n        this.#DispatchEvent(\"deviceDisconnected\", { device });\n        this.#DispatchEvent(\"deviceIsConnected\", { device });\n        this.#DispatchConnectedDevices();\n      } else {\n        _console.log(\"device already not included\");\n      }\n    }\n    if (this.CanGetDevices) {\n      this.GetDevices();\n    }\n    if (device.isConnected && !this.AvailableDevices.includes(device)) {\n      const existingAvailableDevice = this.AvailableDevices.find(\n        (_device) => _device.bluetoothId == device.bluetoothId\n      );\n      _console.log({ existingAvailableDevice });\n      if (existingAvailableDevice) {\n        this.AvailableDevices[\n          this.AvailableDevices.indexOf(existingAvailableDevice)\n        ] = device;\n      } else {\n        this.AvailableDevices.push(device);\n      }\n      this.#DispatchAvailableDevices();\n    }\n    this._CheckDeviceAvailability(device);\n  }\n\n  _CheckDeviceAvailability(device: Device) {\n    if (\n      !device.isConnected &&\n      !device.isAvailable &&\n      this.#AvailableDevices.includes(device)\n    ) {\n      _console.log(\"removing device from availableDevices...\");\n      this.#AvailableDevices.splice(this.#AvailableDevices.indexOf(device), 1);\n      this.#DispatchAvailableDevices();\n    }\n  }\n\n  #DispatchAvailableDevices() {\n    _console.log({ AvailableDevices: this.AvailableDevices });\n    this.#DispatchEvent(\"availableDevices\", {\n      availableDevices: this.AvailableDevices,\n    });\n  }\n  #DispatchConnectedDevices() {\n    _console.log({ ConnectedDevices: this.ConnectedDevices });\n    this.#DispatchEvent(\"connectedDevices\", {\n      connectedDevices: this.ConnectedDevices,\n    });\n  }\n}\n\nexport default DeviceManager.shared;\n","import { DeviceEventTypes } from \"../Device.ts\";\nimport {\n  ConnectionMessageType,\n  ConnectionMessageTypes,\n} from \"../connection/BaseConnectionManager.ts\";\nimport { concatenateArrayBuffers } from \"../utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"../utils/Console.ts\";\nimport { DeviceEventType } from \"../Device.ts\";\n\nconst _console = createConsole(\"ServerUtils\", { log: false });\n\nexport const ServerMessageTypes = [\n  \"isScanningAvailable\",\n  \"isScanning\",\n  \"startScan\",\n  \"stopScan\",\n  \"discoveredDevice\",\n  \"discoveredDevices\",\n  \"expiredDiscoveredDevice\",\n  \"connectToDevice\",\n  \"disconnectFromDevice\",\n  \"connectedDevices\",\n  \"deviceMessage\",\n  \"requiredDeviceInformation\",\n] as const;\nexport type ServerMessageType = (typeof ServerMessageTypes)[number];\n\nexport const DeviceMessageTypes = [\n  \"connectionStatus\",\n  \"batteryLevel\",\n  \"deviceInformation\",\n  \"rx\",\n  \"smp\",\n] as const;\nexport type DeviceMessageType = (typeof DeviceMessageTypes)[number];\n\n// MESSAGING\n\nexport type MessageLike =\n  | number\n  | number[]\n  | ArrayBufferLike\n  | DataView\n  | boolean\n  | string\n  | any;\n\nexport interface Message<MessageType extends string> {\n  type: MessageType;\n  data?: MessageLike | MessageLike[];\n}\n\nexport function createMessage<MessageType extends string>(\n  enumeration: readonly MessageType[],\n  ...messages: (Message<MessageType> | MessageType)[]\n) {\n  _console.log(\"createMessage\", ...messages);\n\n  const messageBuffers = messages.map((message) => {\n    if (typeof message == \"string\") {\n      message = { type: message };\n    }\n\n    if (message.data != undefined) {\n      if (!Array.isArray(message.data)) {\n        message.data = [message.data];\n      }\n    } else {\n      message.data = [];\n    }\n\n    const messageDataArrayBuffer = concatenateArrayBuffers(...message.data);\n    const messageDataArrayBufferByteLength = messageDataArrayBuffer.byteLength;\n\n    _console.assertEnumWithError(message.type, enumeration);\n    const messageTypeEnum = enumeration.indexOf(message.type);\n\n    const messageDataLengthDataView = new DataView(new ArrayBuffer(2));\n    messageDataLengthDataView.setUint16(\n      0,\n      messageDataArrayBufferByteLength,\n      true\n    );\n\n    return concatenateArrayBuffers(\n      messageTypeEnum,\n      messageDataLengthDataView,\n      messageDataArrayBuffer\n    );\n  });\n  _console.log(\"messageBuffers\", ...messageBuffers);\n  return concatenateArrayBuffers(...messageBuffers);\n}\n\nexport type ServerMessage = ServerMessageType | Message<ServerMessageType>;\nexport function createServerMessage(...messages: ServerMessage[]) {\n  _console.log(\"createServerMessage\", ...messages);\n  return createMessage(ServerMessageTypes, ...messages);\n}\n\nexport type DeviceMessage = DeviceEventType | Message<DeviceEventType>;\nexport function createDeviceMessage(...messages: DeviceMessage[]) {\n  _console.log(\"createDeviceMessage\", ...messages);\n  return createMessage(DeviceEventTypes, ...messages);\n}\n\nexport type ClientDeviceMessage =\n  | ConnectionMessageType\n  | Message<ConnectionMessageType>;\nexport function createClientDeviceMessage(...messages: ClientDeviceMessage[]) {\n  _console.log(\"createClientDeviceMessage\", ...messages);\n  return createMessage(ConnectionMessageTypes, ...messages);\n}\n\n// STATIC MESSAGES\nexport const isScanningAvailableRequestMessage = createServerMessage(\n  \"isScanningAvailable\"\n);\nexport const isScanningRequestMessage = createServerMessage(\"isScanning\");\nexport const startScanRequestMessage = createServerMessage(\"startScan\");\nexport const stopScanRequestMessage = createServerMessage(\"stopScan\");\nexport const discoveredDevicesMessage =\n  createServerMessage(\"discoveredDevices\");\n","import { createConsole } from \"../../utils/Console.ts\";\nimport { createMessage, Message } from \"../ServerUtils.ts\";\n\nconst _console = createConsole(\"WebSocketUtils\", { log: false });\n\nexport const webSocketPingTimeout = 30_000;\nexport const webSocketReconnectTimeout = 3_000;\n\nexport const WebSocketMessageTypes = [\"ping\", \"pong\", \"serverMessage\"] as const;\nexport type WebSocketMessageType = (typeof WebSocketMessageTypes)[number];\n\nexport type WebSocketMessage =\n  | WebSocketMessageType\n  | Message<WebSocketMessageType>;\nexport function createWebSocketMessage(...messages: WebSocketMessage[]) {\n  _console.log(\"createWebSocketMessage\", ...messages);\n  return createMessage(WebSocketMessageTypes, ...messages);\n}\n\n// STATIC MESSAGES\nexport const webSocketPingMessage = createWebSocketMessage(\"ping\");\nexport const webSocketPongMessage = createWebSocketMessage(\"pong\");\n","import { DeviceInformationTypes } from \"../../DeviceInformationManager.ts\";\nimport {\n  createMessage,\n  Message,\n  MessageLike,\n} from \"../../server/ServerUtils.ts\";\nimport { webSocketPingTimeout } from \"../../server/websocket/WebSocketUtils.ts\";\nimport { createConsole } from \"../../utils/Console.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../../utils/EventUtils.ts\";\nimport { parseMessage } from \"../../utils/ParseUtils.ts\";\nimport Timer from \"../../utils/Timer.ts\";\nimport BaseConnectionManager, {\n  ConnectionType,\n} from \"../BaseConnectionManager.ts\";\nimport type * as ws from \"ws\";\n\nconst _console = createConsole(\"WebSocketConnectionManager\", { log: false });\n\nconst WebSocketMessageTypes = [\n  \"ping\",\n  \"pong\",\n  \"batteryLevel\",\n  \"deviceInformation\",\n  \"message\",\n] as const;\ntype WebSocketMessageType = (typeof WebSocketMessageTypes)[number];\n\ntype WebSocketMessage = WebSocketMessageType | Message<WebSocketMessageType>;\nfunction createWebSocketMessage(...messages: WebSocketMessage[]) {\n  _console.log(\"createWebSocketMessage\", ...messages);\n  return createMessage(WebSocketMessageTypes, ...messages);\n}\n\nconst WebSocketDeviceInformationMessageTypes: WebSocketMessageType[] = [\n  \"deviceInformation\",\n  \"batteryLevel\",\n];\n\nclass WebSocketConnectionManager extends BaseConnectionManager {\n  #bluetoothId?: string;\n  get bluetoothId() {\n    return this.#bluetoothId ?? \"\";\n  }\n\n  defaultMtu = 2 ** 10;\n\n  constructor(\n    ipAddress: string,\n    isSecure: boolean = false,\n    bluetoothId?: string\n  ) {\n    super();\n    this.ipAddress = ipAddress;\n    this.isSecure = isSecure;\n    this.mtu = this.defaultMtu;\n    this.#bluetoothId = bluetoothId;\n  }\n\n  get isAvailable() {\n    return true;\n  }\n\n  static get isSupported() {\n    return true;\n  }\n  static get type(): ConnectionType {\n    return \"webSocket\";\n  }\n\n  // WEBSOCKET\n  #webSocket?: WebSocket;\n  get webSocket() {\n    return this.#webSocket;\n  }\n  set webSocket(newWebSocket) {\n    if (this.#webSocket == newWebSocket) {\n      _console.log(\"redundant webSocket assignment\");\n      return;\n    }\n\n    _console.log(\"assigning webSocket\", newWebSocket);\n\n    if (this.#webSocket) {\n      removeEventListeners(this.#webSocket, this.#boundWebSocketEventListeners);\n      if (this.#webSocket.readyState == this.#webSocket.OPEN) {\n        this.#webSocket.close();\n      }\n    }\n\n    if (newWebSocket) {\n      addEventListeners(newWebSocket, this.#boundWebSocketEventListeners);\n    }\n    this.#webSocket = newWebSocket;\n\n    _console.log(\"assigned webSocket\");\n  }\n\n  // IP ADDRESS\n  #ipAddress!: string;\n  get ipAddress() {\n    return this.#ipAddress;\n  }\n  set ipAddress(newIpAddress) {\n    this.assertIsNotConnected();\n    if (this.#ipAddress == newIpAddress) {\n      _console.log(`redundnant ipAddress assignment \"${newIpAddress}\"`);\n      return;\n    }\n    this.#ipAddress = newIpAddress;\n    _console.log(`updated ipAddress to \"${this.ipAddress}\"`);\n  }\n\n  // IS SECURE\n  #isSecure = false;\n  get isSecure() {\n    return this.#isSecure;\n  }\n  set isSecure(newIsSecure) {\n    this.assertIsNotConnected();\n    if (this.#isSecure == newIsSecure) {\n      _console.log(`redundant isSecure assignment ${newIsSecure}`);\n      return;\n    }\n    this.#isSecure = newIsSecure;\n    _console.log(`updated isSecure to \"${this.isSecure}\"`);\n  }\n\n  // URL\n  get url() {\n    return `${this.isSecure ? \"wss\" : \"ws\"}://${this.ipAddress}/ws`;\n  }\n\n  // CONNECTION\n  async connect() {\n    await super.connect();\n    try {\n      this.webSocket = new WebSocket(this.url);\n    } catch (error) {\n      _console.error(\"error connecting to webSocket\", error);\n      this.status = \"notConnected\";\n    }\n  }\n  async disconnect() {\n    await super.disconnect();\n    _console.log(\"closing websocket\");\n    this.#pingTimer.stop();\n    this.#webSocket?.close();\n  }\n\n  get canReconnect() {\n    return Boolean(this.webSocket);\n  }\n  async reconnect() {\n    await super.reconnect();\n    this.webSocket = new WebSocket(this.url);\n  }\n\n  // BASE CONNECTION MANAGER\n  async sendSmpMessage(data: ArrayBuffer) {\n    super.sendSmpMessage(data);\n    _console.error(\"smp not supported on webSockets\");\n  }\n\n  async sendTxData(data: ArrayBuffer) {\n    await super.sendTxData(data);\n    if (data.byteLength == 0) {\n      return;\n    }\n    this.#sendWebSocketMessage({ type: \"message\", data });\n  }\n\n  // WEBSOCKET MESSAGING\n  #sendMessage(message: MessageLike) {\n    this.assertIsConnected();\n    _console.log(\"sending webSocket message\", message);\n    this.#webSocket!.send(message);\n    this.#pingTimer.restart();\n  }\n\n  #sendWebSocketMessage(...messages: WebSocketMessage[]) {\n    this.#sendMessage(createWebSocketMessage(...messages));\n  }\n\n  // WEBSOCKET EVENTS\n  #boundWebSocketEventListeners: { [eventType: string]: Function } = {\n    open: this.#onWebSocketOpen.bind(this),\n    message: this.#onWebSocketMessage.bind(this),\n    close: this.#onWebSocketClose.bind(this),\n    error: this.#onWebSocketError.bind(this),\n  };\n\n  #onWebSocketOpen(event: ws.Event) {\n    _console.log(\"webSocket.open\", event);\n    this.#pingTimer.start();\n    this.status = \"connected\";\n    this.#requestDeviceInformation();\n  }\n  async #onWebSocketMessage(event: ws.MessageEvent) {\n    // this.#pingTimer.restart();\n    //@ts-expect-error\n    const arrayBuffer = await event.data.arrayBuffer();\n    const dataView = new DataView(arrayBuffer);\n    _console.log(`webSocket.message (${dataView.byteLength} bytes)`);\n    this.#parseWebSocketMessage(dataView);\n  }\n  #onWebSocketClose(event: ws.CloseEvent) {\n    _console.log(\"webSocket.close\", event);\n    this.status = \"notConnected\";\n    this.#pingTimer.stop();\n  }\n  #onWebSocketError(event: ws.ErrorEvent) {\n    _console.error(\"webSocket.error\", event);\n  }\n\n  // PARSING\n  #parseWebSocketMessage(dataView: DataView) {\n    parseMessage(\n      dataView,\n      WebSocketMessageTypes,\n      this.#onMessage.bind(this),\n      null,\n      true\n    );\n  }\n\n  #onMessage(messageType: WebSocketMessageType, dataView: DataView) {\n    _console.log(\n      `received \"${messageType}\" message (${dataView.byteLength} bytes)`\n    );\n    switch (messageType) {\n      case \"ping\":\n        this.#pong();\n        break;\n      case \"pong\":\n        break;\n      case \"batteryLevel\":\n        this.onMessageReceived?.(\"batteryLevel\", dataView);\n        break;\n      case \"deviceInformation\":\n        parseMessage(\n          dataView,\n          DeviceInformationTypes,\n          (deviceInformationType, dataView) => {\n            this.onMessageReceived!(deviceInformationType, dataView);\n          }\n        );\n        break;\n      case \"message\":\n        this.parseRxMessage(dataView);\n        break;\n      default:\n        _console.error(`uncaught messageType \"${messageType}\"`);\n        break;\n    }\n  }\n\n  // PING\n  #pingTimer = new Timer(this.#ping.bind(this), webSocketPingTimeout - 1_000);\n  #ping() {\n    _console.log(\"pinging\");\n    this.#sendWebSocketMessage(\"ping\");\n  }\n  #pong() {\n    _console.log(\"ponging\");\n    this.#sendWebSocketMessage(\"pong\");\n  }\n\n  // DEVICE INFORMATION\n  #requestDeviceInformation() {\n    this.#sendWebSocketMessage(...WebSocketDeviceInformationMessageTypes);\n  }\n\n  remove() {\n    super.remove();\n    this.webSocket = undefined;\n  }\n}\n\nexport default WebSocketConnectionManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"./utils/EventDispatcher.ts\";\nimport BaseConnectionManager, {\n  TxMessage,\n  TxRxMessageType,\n  ConnectionStatus,\n  ConnectionMessageType,\n  MetaConnectionMessageTypes,\n  BatteryLevelMessageTypes,\n  ConnectionEventTypes,\n  ConnectionStatusEventMessages,\n  ConnectionTypes,\n  ConnectionType,\n  ConnectOptions,\n} from \"./connection/BaseConnectionManager.ts\";\nimport { isInBrowser, isInNode } from \"./utils/environment.ts\";\nimport WebBluetoothConnectionManager from \"./connection/bluetooth/WebBluetoothConnectionManager.ts\";\nimport SensorConfigurationManager, {\n  SendSensorConfigurationMessageCallback,\n  SensorConfiguration,\n  SensorConfigurationEventDispatcher,\n  SensorConfigurationEventMessages,\n  SensorConfigurationEventTypes,\n  SensorConfigurationMessageType,\n  SensorConfigurationMessageTypes,\n} from \"./sensor/SensorConfigurationManager.ts\";\nimport SensorDataManager, {\n  SensorDataEventMessages,\n  SensorDataEventTypes,\n  SensorDataMessageType,\n  SensorDataMessageTypes,\n  SensorType,\n  ContinuousSensorTypes,\n  SensorDataEventDispatcher,\n  RequiredPressureMessageTypes,\n} from \"./sensor/SensorDataManager.ts\";\nimport VibrationManager, {\n  SendVibrationMessageCallback,\n  VibrationConfiguration,\n  VibrationEventDispatcher,\n  VibrationEventTypes,\n  VibrationMessageType,\n  VibrationMessageTypes,\n} from \"./vibration/VibrationManager.ts\";\nimport FileTransferManager, {\n  FileTransferEventTypes,\n  FileTransferEventMessages,\n  FileTransferEventDispatcher,\n  SendFileTransferMessageCallback,\n  FileTransferMessageTypes,\n  FileTransferMessageType,\n  FileType,\n  FileTypes,\n  RequiredFileTransferMessageTypes,\n  SendFileCallback,\n} from \"./FileTransferManager.ts\";\nimport TfliteManager, {\n  TfliteEventTypes,\n  TfliteEventMessages,\n  TfliteEventDispatcher,\n  SendTfliteMessageCallback,\n  TfliteMessageTypes,\n  TfliteMessageType,\n  TfliteSensorTypes,\n  TfliteFileConfiguration,\n  TfliteSensorType,\n  RequiredTfliteMessageTypes,\n} from \"./TfliteManager.ts\";\nimport FirmwareManager, {\n  FirmwareEventDispatcher,\n  FirmwareEventMessages,\n  FirmwareEventTypes,\n  FirmwareMessageType,\n  FirmwareMessageTypes,\n} from \"./FirmwareManager.ts\";\nimport DeviceInformationManager, {\n  DeviceInformationEventDispatcher,\n  DeviceInformationEventTypes,\n  DeviceInformationType,\n  DeviceInformationTypes,\n  DeviceInformationEventMessages,\n} from \"./DeviceInformationManager.ts\";\nimport InformationManager, {\n  DeviceType,\n  InformationEventDispatcher,\n  InformationEventTypes,\n  InformationMessageType,\n  InformationMessageTypes,\n  InformationEventMessages,\n  SendInformationMessageCallback,\n} from \"./InformationManager.ts\";\nimport { FileLike } from \"./utils/ArrayBufferUtils.ts\";\nimport DeviceManager from \"./DeviceManager.ts\";\nimport CameraManager, {\n  CameraEventDispatcher,\n  CameraEventMessages,\n  CameraEventTypes,\n  CameraMessageType,\n  CameraMessageTypes,\n  RequiredCameraMessageTypes,\n  SendCameraMessageCallback,\n} from \"./CameraManager.ts\";\nimport MicrophoneManager, {\n  MicrophoneEventDispatcher,\n  MicrophoneEventMessages,\n  MicrophoneEventTypes,\n  MicrophoneMessageType,\n  MicrophoneMessageTypes,\n  RequiredMicrophoneMessageTypes,\n  SendMicrophoneMessageCallback,\n} from \"./MicrophoneManager.ts\";\nimport DisplayManager, {\n  DisplayEventDispatcher,\n  DisplayEventMessages,\n  DisplayEventTypes,\n  DisplayMessageType,\n  DisplayMessageTypes,\n  RequiredDisplayMessageTypes,\n  SendDisplayMessageCallback,\n} from \"./DisplayManager.ts\";\nimport WifiManager, {\n  RequiredWifiMessageTypes,\n  SendWifiMessageCallback,\n  WifiEventDispatcher,\n  WifiEventMessages,\n  WifiEventTypes,\n  WifiMessageType,\n  WifiMessageTypes,\n} from \"./WifiManager.ts\";\nimport WebSocketConnectionManager from \"./connection/websocket/WebSocketConnectionManager.ts\";\nimport ClientConnectionManager from \"./connection/ClientConnectionManager.ts\";\n\n/** NODE_START */\nimport UDPConnectionManager from \"./connection/udp/UDPConnectionManager.ts\";\nimport { DisplayManagerInterface } from \"./utils/DisplayManagerInterface.ts\";\n/** NODE_END */\n\nconst _console = createConsole(\"Device\", { log: false });\n\nexport const DeviceEventTypes = [\n  \"connectionMessage\",\n  ...ConnectionEventTypes,\n  ...MetaConnectionMessageTypes,\n  ...BatteryLevelMessageTypes,\n  ...InformationEventTypes,\n  ...DeviceInformationEventTypes,\n  ...SensorConfigurationEventTypes,\n  ...SensorDataEventTypes,\n  ...VibrationEventTypes,\n  ...FileTransferEventTypes,\n  ...TfliteEventTypes,\n  ...WifiEventTypes,\n  ...CameraEventTypes,\n  ...MicrophoneEventTypes,\n  ...DisplayEventTypes,\n  ...FirmwareEventTypes,\n] as const;\nexport type DeviceEventType = (typeof DeviceEventTypes)[number];\n\nexport interface DeviceEventMessages\n  extends ConnectionStatusEventMessages,\n    DeviceInformationEventMessages,\n    InformationEventMessages,\n    SensorDataEventMessages,\n    SensorConfigurationEventMessages,\n    TfliteEventMessages,\n    FileTransferEventMessages,\n    WifiEventMessages,\n    CameraEventMessages,\n    MicrophoneEventMessages,\n    DisplayEventMessages,\n    FirmwareEventMessages {\n  batteryLevel: { batteryLevel: number };\n  connectionMessage: { messageType: ConnectionMessageType; dataView: DataView };\n}\n\nexport type SendMessageCallback<MessageType extends string> = (\n  messages?: { type: MessageType; data?: ArrayBuffer }[],\n  sendImmediately?: boolean\n) => Promise<void>;\n\nexport type SendSmpMessageCallback = (data: ArrayBuffer) => Promise<void>;\n\nexport type DeviceEventDispatcher = EventDispatcher<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\nexport type DeviceEvent = Event<Device, DeviceEventType, DeviceEventMessages>;\nexport type DeviceEventMap = EventMap<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\nexport type DeviceEventListenerMap = EventListenerMap<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\nexport type BoundDeviceEventListeners = BoundEventListeners<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\n\nexport const RequiredInformationConnectionMessages: TxRxMessageType[] = [\n  \"isCharging\",\n  \"getBatteryCurrent\",\n  \"getId\",\n  \"getMtu\",\n\n  \"getName\",\n  \"getType\",\n  \"getCurrentTime\",\n  \"getSensorConfiguration\",\n  \"getSensorScalars\",\n\n  \"getVibrationLocations\",\n\n  \"getFileTypes\",\n\n  \"isWifiAvailable\",\n];\n\nclass Device {\n  get bluetoothId() {\n    return this.#connectionManager?.bluetoothId;\n  }\n\n  get isAvailable() {\n    return this.#connectionManager?.isAvailable;\n  }\n\n  constructor() {\n    this.#deviceInformationManager.eventDispatcher = this\n      .#eventDispatcher as DeviceInformationEventDispatcher;\n\n    this._informationManager.sendMessage = this\n      .sendTxMessages as SendInformationMessageCallback;\n    this._informationManager.eventDispatcher = this\n      .#eventDispatcher as InformationEventDispatcher;\n\n    this.#sensorConfigurationManager.sendMessage = this\n      .sendTxMessages as SendSensorConfigurationMessageCallback;\n    this.#sensorConfigurationManager.eventDispatcher = this\n      .#eventDispatcher as SensorConfigurationEventDispatcher;\n\n    this.#sensorDataManager.eventDispatcher = this\n      .#eventDispatcher as SensorDataEventDispatcher;\n\n    this.#vibrationManager.sendMessage = this\n      .sendTxMessages as SendVibrationMessageCallback;\n    this.#vibrationManager.eventDispatcher = this\n      .#eventDispatcher as VibrationEventDispatcher;\n\n    this.#tfliteManager.sendMessage = this\n      .sendTxMessages as SendTfliteMessageCallback;\n    this.#tfliteManager.eventDispatcher = this\n      .#eventDispatcher as TfliteEventDispatcher;\n\n    this.#fileTransferManager.sendMessage = this\n      .sendTxMessages as SendFileTransferMessageCallback;\n    this.#fileTransferManager.eventDispatcher = this\n      .#eventDispatcher as FileTransferEventDispatcher;\n\n    this.#wifiManager.sendMessage = this\n      .sendTxMessages as SendWifiMessageCallback;\n    this.#wifiManager.eventDispatcher = this\n      .#eventDispatcher as WifiEventDispatcher;\n\n    this.#cameraManager.sendMessage = this\n      .sendTxMessages as SendCameraMessageCallback;\n    this.#cameraManager.eventDispatcher = this\n      .#eventDispatcher as CameraEventDispatcher;\n\n    this.#microphoneManager.sendMessage = this\n      .sendTxMessages as SendMicrophoneMessageCallback;\n    this.#microphoneManager.eventDispatcher = this\n      .#eventDispatcher as MicrophoneEventDispatcher;\n\n    this.#displayManager.sendMessage = this\n      .sendTxMessages as SendDisplayMessageCallback;\n    this.#displayManager.eventDispatcher = this\n      .#eventDispatcher as DisplayEventDispatcher;\n    this.#displayManager.sendFile = this.#fileTransferManager\n      .send as SendFileCallback;\n\n    this.#firmwareManager.sendMessage = this\n      .sendSmpMessage as SendSmpMessageCallback;\n    this.#firmwareManager.eventDispatcher = this\n      .#eventDispatcher as FirmwareEventDispatcher;\n\n    this.addEventListener(\"getMtu\", () => {\n      this.#firmwareManager.mtu = this.mtu;\n      this.#fileTransferManager.mtu = this.mtu;\n      this.connectionManager!.mtu = this.mtu;\n      this.#displayManager.mtu = this.mtu;\n    });\n    this.addEventListener(\"getSensorConfiguration\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.sensorTypes.includes(\"pressure\")) {\n        _console.log(\"requesting required pressure information\");\n        const messages = RequiredPressureMessageTypes.map((messageType) => ({\n          type: messageType,\n        }));\n        this.sendTxMessages(messages, false);\n      } else {\n        _console.log(\"don't need to request pressure infomration\");\n      }\n\n      if (this.sensorTypes.includes(\"camera\")) {\n        _console.log(\"requesting required camera information\");\n        const messages = RequiredCameraMessageTypes.map((messageType) => ({\n          type: messageType,\n        }));\n        this.sendTxMessages(messages, false);\n      } else {\n        _console.log(\"don't need to request camera infomration\");\n      }\n\n      if (this.sensorTypes.includes(\"microphone\")) {\n        _console.log(\"requesting required microphone information\");\n        const messages = RequiredMicrophoneMessageTypes.map((messageType) => ({\n          type: messageType,\n        }));\n        this.sendTxMessages(messages, false);\n      } else {\n        _console.log(\"don't need to request microphone infomration\");\n      }\n    });\n    this.addEventListener(\"getFileTypes\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.fileTypes.length > 0) {\n        this.#fileTransferManager.requestRequiredInformation();\n      }\n      if (this.fileTypes.includes(\"tflite\")) {\n        this.#tfliteManager.requestRequiredInformation();\n      }\n    });\n    this.addEventListener(\"isWifiAvailable\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.connectionType == \"client\" && !isInNode) {\n        return;\n      }\n      if (this.isWifiAvailable) {\n        if (this.connectionType != \"client\") {\n          this.#wifiManager.requestRequiredInformation();\n        }\n      }\n    });\n    this.addEventListener(\"getType\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.type == \"glasses\") {\n        this.#displayManager.requestRequiredInformation();\n      }\n    });\n    this.addEventListener(\"fileTransferProgress\", (event) => {\n      const { fileType, progress } = event.message;\n      switch (fileType) {\n        case \"spriteSheet\":\n          this.#dispatchEvent(\"displaySpriteSheetUploadProgress\", {\n            spriteSheet: this.#displayManager.pendingSpriteSheet!,\n            spriteSheetName: this.#displayManager.pendingSpriteSheetName!,\n            progress,\n          });\n          break;\n        default:\n          break;\n      }\n    });\n    this.addEventListener(\"fileTransferStatus\", (event) => {\n      const { fileType, fileTransferStatus } = event.message;\n      switch (fileType) {\n        case \"spriteSheet\":\n          if (fileTransferStatus == \"sending\") {\n            this.#dispatchEvent(\"displaySpriteSheetUploadStart\", {\n              spriteSheet: this.#displayManager.pendingSpriteSheet!,\n              spriteSheetName: this.#displayManager.pendingSpriteSheetName!,\n            });\n          }\n          break;\n        default:\n          break;\n      }\n    });\n    DeviceManager.onDevice(this);\n    if (isInBrowser) {\n      window.addEventListener(\"beforeunload\", () => {\n        if (this.isConnected && this.clearSensorConfigurationOnLeave) {\n          this.clearSensorConfiguration();\n        }\n      });\n    }\n    if (isInNode) {\n      /** can add more node leave handlers https://gist.github.com/hyrious/30a878f6e6a057f09db87638567cb11a */\n      process.on(\"exit\", () => {\n        if (this.isConnected && this.clearSensorConfigurationOnLeave) {\n          this.clearSensorConfiguration();\n        }\n      });\n    }\n  }\n\n  static #DefaultConnectionManager(): BaseConnectionManager {\n    return new WebBluetoothConnectionManager();\n  }\n\n  #eventDispatcher: DeviceEventDispatcher = new EventDispatcher(\n    this as Device,\n    DeviceEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // CONNECTION MANAGER\n\n  #connectionManager?: BaseConnectionManager;\n  get connectionManager() {\n    return this.#connectionManager;\n  }\n  set connectionManager(newConnectionManager) {\n    if (this.connectionManager == newConnectionManager) {\n      _console.log(\"same connectionManager is already assigned\");\n      return;\n    }\n\n    if (this.connectionManager) {\n      this.connectionManager.remove();\n    }\n    if (newConnectionManager) {\n      newConnectionManager.onStatusUpdated =\n        this.#onConnectionStatusUpdated.bind(this);\n      newConnectionManager.onMessageReceived =\n        this.#onConnectionMessageReceived.bind(this);\n      newConnectionManager.onMessagesReceived =\n        this.#onConnectionMessagesReceived.bind(this);\n    }\n\n    this.#connectionManager = newConnectionManager;\n    _console.log(\"assigned new connectionManager\", this.#connectionManager);\n\n    this._informationManager.connectionType = this.connectionType;\n  }\n  async #sendTxMessages(messages?: TxMessage[], sendImmediately?: boolean) {\n    await this.#connectionManager?.sendTxMessages(messages, sendImmediately);\n  }\n  private sendTxMessages = this.#sendTxMessages.bind(this);\n\n  async connect(options?: ConnectOptions) {\n    _console.log(\"connect options\", options);\n    if (options) {\n      switch (options.type) {\n        case \"webBluetooth\":\n          if (this.connectionType != \"webBluetooth\") {\n            this.connectionManager = new WebBluetoothConnectionManager();\n          }\n          break;\n        case \"webSocket\":\n          {\n            let createConnectionManager = false;\n            if (this.connectionType == \"webSocket\") {\n              const connectionManager = this\n                .connectionManager as WebSocketConnectionManager;\n              if (\n                connectionManager.ipAddress != options.ipAddress ||\n                connectionManager.isSecure != options.isWifiSecure\n              ) {\n                createConnectionManager = true;\n              }\n            } else {\n              createConnectionManager = true;\n            }\n            if (createConnectionManager) {\n              this.connectionManager = new WebSocketConnectionManager(\n                options.ipAddress,\n                options.isWifiSecure,\n                this.bluetoothId\n              );\n            }\n          }\n\n          break;\n        case \"udp\":\n          {\n            let createConnectionManager = false;\n            if (this.connectionType == \"udp\") {\n              const connectionManager = this\n                .connectionManager as UDPConnectionManager;\n              if (connectionManager.ipAddress != options.ipAddress) {\n                createConnectionManager = true;\n              }\n              this.reconnectOnDisconnection = true;\n            } else {\n              createConnectionManager = true;\n            }\n            if (createConnectionManager) {\n              this.connectionManager = new UDPConnectionManager(\n                options.ipAddress,\n                this.bluetoothId\n              );\n            }\n          }\n          break;\n      }\n    }\n    if (!this.connectionManager) {\n      this.connectionManager = Device.#DefaultConnectionManager();\n    }\n    this.#clear();\n\n    if (options?.type == \"client\") {\n      _console.assertWithError(\n        this.connectionType == \"client\",\n        \"expected clientConnectionManager\"\n      );\n      const clientConnectionManager = this\n        .connectionManager as ClientConnectionManager;\n      clientConnectionManager.subType = options.subType;\n      return clientConnectionManager.connect();\n    }\n    _console.log(\"connectionManager type\", this.connectionManager.type);\n    return this.connectionManager.connect();\n  }\n  #isConnected = false;\n  get isConnected() {\n    return this.#isConnected;\n  }\n  /** @throws {Error} if not connected */\n  #assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"notConnected\");\n  }\n\n  #didReceiveMessageTypes(messageTypes: ConnectionMessageType[]) {\n    return messageTypes.every((messageType) => {\n      const hasConnectionMessage =\n        this.latestConnectionMessages.has(messageType);\n      if (!hasConnectionMessage) {\n        _console.log(`didn't receive \"${messageType}\" message`);\n      }\n      return hasConnectionMessage;\n    });\n  }\n  get #hasRequiredInformation() {\n    let hasRequiredInformation = this.#didReceiveMessageTypes(\n      RequiredInformationConnectionMessages\n    );\n    if (hasRequiredInformation && this.sensorTypes.includes(\"pressure\")) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredPressureMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.isWifiAvailable) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredWifiMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.fileTypes.length > 0) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredFileTransferMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.fileTypes.includes(\"tflite\")) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredTfliteMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.hasCamera) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredCameraMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.hasMicrophone) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredMicrophoneMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.isDisplayAvailable) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredDisplayMessageTypes\n      );\n    }\n    return hasRequiredInformation;\n  }\n  #requestRequiredInformation() {\n    _console.log(\"requesting required information\");\n    const messages: TxMessage[] = RequiredInformationConnectionMessages.map(\n      (messageType) => ({\n        type: messageType,\n      })\n    );\n    this.#sendTxMessages(messages);\n  }\n\n  get canReconnect() {\n    return this.connectionManager?.canReconnect;\n  }\n  #assertCanReconnect() {\n    _console.assertWithError(this.canReconnect, \"cannot reconnect to device\");\n  }\n  async reconnect() {\n    this.#assertCanReconnect();\n    this.#clear();\n    return this.connectionManager?.reconnect();\n  }\n\n  static async Connect() {\n    const device = new Device();\n    await device.connect();\n    return device;\n  }\n\n  static #ReconnectOnDisconnection = false;\n  static get ReconnectOnDisconnection() {\n    return this.#ReconnectOnDisconnection;\n  }\n  static set ReconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this.#ReconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  #reconnectOnDisconnection = Device.ReconnectOnDisconnection;\n  get reconnectOnDisconnection() {\n    return this.#reconnectOnDisconnection;\n  }\n  set reconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this.#reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n  #reconnectIntervalId?: NodeJS.Timeout | number;\n\n  get connectionType() {\n    return this.connectionManager?.type;\n  }\n  async disconnect() {\n    this.#assertIsConnected();\n    if (this.reconnectOnDisconnection) {\n      this.reconnectOnDisconnection = false;\n      this.addEventListener(\n        \"isConnected\",\n        () => {\n          this.reconnectOnDisconnection = true;\n        },\n        { once: true }\n      );\n    }\n\n    return this.connectionManager!.disconnect();\n  }\n\n  toggleConnection() {\n    if (this.isConnected) {\n      this.disconnect();\n    } else if (this.canReconnect) {\n      try {\n        this.reconnect();\n      } catch (error) {\n        _console.error(\"error trying to reconnect\", error);\n        this.connect();\n      }\n    } else {\n      this.connect();\n    }\n  }\n\n  get connectionStatus(): ConnectionStatus {\n    switch (this.#connectionManager?.status) {\n      case \"connected\":\n        return this.isConnected ? \"connected\" : \"connecting\";\n      case \"notConnected\":\n      case \"connecting\":\n      case \"disconnecting\":\n        return this.#connectionManager.status;\n      default:\n        return \"notConnected\";\n    }\n  }\n  get isConnectionBusy() {\n    return (\n      this.connectionStatus == \"connecting\" ||\n      this.connectionStatus == \"disconnecting\"\n    );\n  }\n\n  #onConnectionStatusUpdated(connectionStatus: ConnectionStatus) {\n    _console.log({ connectionStatus });\n\n    if (connectionStatus == \"notConnected\") {\n      this.#clearConnection();\n\n      if (this.canReconnect && this.reconnectOnDisconnection) {\n        _console.log(\"starting reconnect interval...\");\n        this.#reconnectIntervalId = setInterval(() => {\n          _console.log(\"attempting reconnect...\");\n          this.reconnect();\n        }, 1000);\n      }\n    } else {\n      if (this.#reconnectIntervalId != undefined) {\n        _console.log(\"clearing reconnect interval\");\n        clearInterval(this.#reconnectIntervalId);\n        this.#reconnectIntervalId = undefined;\n      }\n    }\n\n    this.#checkConnection();\n\n    if (connectionStatus == \"connected\" && !this.#isConnected) {\n      if (this.connectionType != \"client\") {\n        this.#requestRequiredInformation();\n      }\n    }\n\n    DeviceManager.OnDeviceConnectionStatusUpdated(this, connectionStatus);\n  }\n\n  #dispatchConnectionEvents(includeIsConnected: boolean = false) {\n    this.#dispatchEvent(\"connectionStatus\", {\n      connectionStatus: this.connectionStatus,\n    });\n    this.#dispatchEvent(this.connectionStatus, {});\n    if (includeIsConnected) {\n      this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    }\n  }\n  #checkConnection() {\n    this.#isConnected =\n      Boolean(this.connectionManager?.isConnected) &&\n      this.#hasRequiredInformation &&\n      this._informationManager.isCurrentTimeSet;\n\n    switch (this.connectionStatus) {\n      case \"connected\":\n        if (this.#isConnected) {\n          this.#dispatchConnectionEvents(true);\n        }\n        break;\n      case \"notConnected\":\n        this.#dispatchConnectionEvents(true);\n        break;\n      default:\n        this.#dispatchConnectionEvents(false);\n        break;\n    }\n  }\n\n  #clear() {\n    this.#clearConnection();\n    this._informationManager.clear();\n    this.#deviceInformationManager.clear();\n    this.#tfliteManager.clear();\n    this.#fileTransferManager.clear();\n    this.#wifiManager.clear();\n    this.#cameraManager.clear();\n    this.#microphoneManager.clear();\n    this.#displayManager.reset();\n  }\n  #clearConnection() {\n    this.connectionManager?.clear();\n    this.latestConnectionMessages.clear();\n  }\n\n  #onConnectionMessageReceived(\n    messageType: ConnectionMessageType,\n    dataView: DataView\n  ) {\n    _console.log({ messageType, dataView });\n    switch (messageType) {\n      case \"batteryLevel\":\n        const batteryLevel = dataView.getUint8(0);\n        _console.log(\"received battery level\", { batteryLevel });\n        this.#updateBatteryLevel(batteryLevel);\n        break;\n\n      default:\n        if (\n          FileTransferMessageTypes.includes(\n            messageType as FileTransferMessageType\n          )\n        ) {\n          this.#fileTransferManager.parseMessage(\n            messageType as FileTransferMessageType,\n            dataView\n          );\n        } else if (\n          TfliteMessageTypes.includes(messageType as TfliteMessageType)\n        ) {\n          this.#tfliteManager.parseMessage(\n            messageType as TfliteMessageType,\n            dataView\n          );\n        } else if (\n          SensorDataMessageTypes.includes(messageType as SensorDataMessageType)\n        ) {\n          this.#sensorDataManager.parseMessage(\n            messageType as SensorDataMessageType,\n            dataView\n          );\n        } else if (\n          FirmwareMessageTypes.includes(messageType as FirmwareMessageType)\n        ) {\n          this.#firmwareManager.parseMessage(\n            messageType as FirmwareMessageType,\n            dataView\n          );\n        } else if (\n          DeviceInformationTypes.includes(messageType as DeviceInformationType)\n        ) {\n          this.#deviceInformationManager.parseMessage(\n            messageType as DeviceInformationType,\n            dataView\n          );\n        } else if (\n          InformationMessageTypes.includes(\n            messageType as InformationMessageType\n          )\n        ) {\n          this._informationManager.parseMessage(\n            messageType as InformationMessageType,\n            dataView\n          );\n        } else if (\n          SensorConfigurationMessageTypes.includes(\n            messageType as SensorConfigurationMessageType\n          )\n        ) {\n          this.#sensorConfigurationManager.parseMessage(\n            messageType as SensorConfigurationMessageType,\n            dataView\n          );\n        } else if (\n          VibrationMessageTypes.includes(messageType as VibrationMessageType)\n        ) {\n          this.#vibrationManager.parseMessage(\n            messageType as VibrationMessageType,\n            dataView\n          );\n        } else if (WifiMessageTypes.includes(messageType as WifiMessageType)) {\n          this.#wifiManager.parseMessage(\n            messageType as WifiMessageType,\n            dataView\n          );\n        } else if (\n          CameraMessageTypes.includes(messageType as CameraMessageType)\n        ) {\n          this.#cameraManager.parseMessage(\n            messageType as CameraMessageType,\n            dataView\n          );\n        } else if (\n          MicrophoneMessageTypes.includes(messageType as MicrophoneMessageType)\n        ) {\n          this.#microphoneManager.parseMessage(\n            messageType as MicrophoneMessageType,\n            dataView\n          );\n        } else if (\n          DisplayMessageTypes.includes(messageType as DisplayMessageType)\n        ) {\n          this.#displayManager.parseMessage(\n            messageType as DisplayMessageType,\n            dataView\n          );\n        } else {\n          throw Error(`uncaught messageType ${messageType}`);\n        }\n    }\n\n    this.latestConnectionMessages.set(messageType, dataView);\n    if (messageType.startsWith(\"set\")) {\n      this.latestConnectionMessages.set(\n        // @ts-expect-error\n        messageType.replace(\"set\", \"get\"),\n        dataView\n      );\n    }\n    this.#dispatchEvent(\"connectionMessage\", { messageType, dataView });\n  }\n  #onConnectionMessagesReceived() {\n    if (!this.isConnected && this.#hasRequiredInformation) {\n      this.#checkConnection();\n    }\n    if (\n      this.connectionStatus == \"notConnected\" ||\n      this.connectionStatus == \"disconnecting\"\n    ) {\n      return;\n    }\n    this.#sendTxMessages();\n  }\n\n  latestConnectionMessages: Map<ConnectionMessageType, DataView> = new Map();\n\n  // DEVICE INFORMATION\n  #deviceInformationManager = new DeviceInformationManager();\n  get deviceInformation() {\n    return this.#deviceInformationManager.information;\n  }\n\n  // BATTERY LEVEL\n  #batteryLevel = 0;\n  get batteryLevel() {\n    return this.#batteryLevel;\n  }\n  #updateBatteryLevel(updatedBatteryLevel: number) {\n    _console.assertTypeWithError(updatedBatteryLevel, \"number\");\n    if (this.#batteryLevel == updatedBatteryLevel) {\n      _console.log(`duplicate batteryLevel assignment ${updatedBatteryLevel}`);\n      return;\n    }\n    this.#batteryLevel = updatedBatteryLevel;\n    _console.log({ updatedBatteryLevel: this.#batteryLevel });\n    this.#dispatchEvent(\"batteryLevel\", { batteryLevel: this.#batteryLevel });\n  }\n\n  // INFORMATION\n  /** @private */\n  _informationManager = new InformationManager();\n\n  get id() {\n    return this._informationManager.id;\n  }\n\n  get isCharging() {\n    return this._informationManager.isCharging;\n  }\n  get batteryCurrent() {\n    return this._informationManager.batteryCurrent;\n  }\n  get getBatteryCurrent() {\n    return this._informationManager.getBatteryCurrent;\n  }\n\n  get name() {\n    return this._informationManager.name;\n  }\n  get setName() {\n    return this._informationManager.setName;\n  }\n\n  get type() {\n    return this._informationManager.type;\n  }\n  get setType() {\n    return this._informationManager.setType;\n  }\n\n  get isInsole() {\n    return this._informationManager.isInsole;\n  }\n  get isGlove() {\n    return this._informationManager.isGlove;\n  }\n  get side() {\n    return this._informationManager.side;\n  }\n\n  get mtu() {\n    return this._informationManager.mtu;\n  }\n\n  // SENSOR TYPES\n  get sensorTypes() {\n    return Object.keys(this.sensorConfiguration) as SensorType[];\n  }\n  get continuousSensorTypes() {\n    return ContinuousSensorTypes.filter((sensorType) =>\n      this.sensorTypes.includes(sensorType)\n    );\n  }\n\n  // SENSOR CONFIGURATION\n\n  #sensorConfigurationManager = new SensorConfigurationManager();\n\n  get sensorConfiguration() {\n    return this.#sensorConfigurationManager.configuration;\n  }\n\n  get setSensorConfiguration() {\n    return this.#sensorConfigurationManager.setConfiguration;\n  }\n\n  async clearSensorConfiguration() {\n    return this.#sensorConfigurationManager.clearSensorConfiguration();\n  }\n\n  static #ClearSensorConfigurationOnLeave = true;\n  static get ClearSensorConfigurationOnLeave() {\n    return this.#ClearSensorConfigurationOnLeave;\n  }\n  static set ClearSensorConfigurationOnLeave(\n    newClearSensorConfigurationOnLeave\n  ) {\n    _console.assertTypeWithError(newClearSensorConfigurationOnLeave, \"boolean\");\n    this.#ClearSensorConfigurationOnLeave = newClearSensorConfigurationOnLeave;\n  }\n\n  #clearSensorConfigurationOnLeave = Device.ClearSensorConfigurationOnLeave;\n  get clearSensorConfigurationOnLeave() {\n    return this.#clearSensorConfigurationOnLeave;\n  }\n  set clearSensorConfigurationOnLeave(newClearSensorConfigurationOnLeave) {\n    _console.assertTypeWithError(newClearSensorConfigurationOnLeave, \"boolean\");\n    this.#clearSensorConfigurationOnLeave = newClearSensorConfigurationOnLeave;\n  }\n\n  // PRESSURE\n  get numberOfPressureSensors() {\n    return this.#sensorDataManager.pressureSensorDataManager.numberOfSensors;\n  }\n\n  // SENSOR DATA\n  #sensorDataManager = new SensorDataManager();\n  resetPressureRange() {\n    this.#sensorDataManager.pressureSensorDataManager.resetRange();\n  }\n\n  // VIBRATION\n  get vibrationLocations() {\n    return this.#vibrationManager.vibrationLocations;\n  }\n\n  #vibrationManager = new VibrationManager();\n  async triggerVibration(\n    vibrationConfigurations: VibrationConfiguration[],\n    sendImmediately?: boolean\n  ) {\n    this.#vibrationManager.triggerVibration(\n      vibrationConfigurations,\n      sendImmediately\n    );\n  }\n\n  // FILE TRANSFER\n  #fileTransferManager = new FileTransferManager();\n\n  get fileTypes() {\n    return this.#fileTransferManager.fileTypes;\n  }\n  get maxFileLength() {\n    return this.#fileTransferManager.maxLength;\n  }\n  get validFileTypes() {\n    return FileTypes.filter((fileType) => {\n      if (fileType.includes(\"wifi\") && !this.isWifiAvailable) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  async sendFile(fileType: FileType, file: FileLike) {\n    _console.assertWithError(\n      this.validFileTypes.includes(fileType),\n      `invalid fileType ${fileType}`\n    );\n    const promise = this.waitForEvent(\"fileTransferComplete\");\n    this.#fileTransferManager.send(fileType, file);\n    await promise;\n  }\n  async receiveFile(fileType: FileType) {\n    const promise = this.waitForEvent(\"fileTransferComplete\");\n    this.#fileTransferManager.receive(fileType);\n    await promise;\n  }\n\n  get fileTransferStatus() {\n    return this.#fileTransferManager.status;\n  }\n\n  cancelFileTransfer() {\n    this.#fileTransferManager.cancel();\n  }\n\n  // TFLITE\n  #tfliteManager = new TfliteManager();\n\n  get tfliteName() {\n    return this.#tfliteManager.name;\n  }\n  get setTfliteName() {\n    return this.#tfliteManager.setName;\n  }\n\n  async sendTfliteConfiguration(configuration: TfliteFileConfiguration) {\n    configuration.type = \"tflite\";\n    this.#tfliteManager.sendConfiguration(configuration, false);\n    const didSendFile = await this.#fileTransferManager.send(\n      configuration.type,\n      configuration.file\n    );\n    if (!didSendFile) {\n      this.#sendTxMessages();\n    }\n  }\n\n  // TFLITE MODEL CONFIG\n  get tfliteTask() {\n    return this.#tfliteManager.task;\n  }\n  get setTfliteTask() {\n    return this.#tfliteManager.setTask;\n  }\n  get tfliteSampleRate() {\n    return this.#tfliteManager.sampleRate;\n  }\n  get setTfliteSampleRate() {\n    return this.#tfliteManager.setSampleRate;\n  }\n  get tfliteSensorTypes() {\n    return this.#tfliteManager.sensorTypes;\n  }\n  get allowedTfliteSensorTypes() {\n    return this.sensorTypes.filter((sensorType) =>\n      TfliteSensorTypes.includes(sensorType as TfliteSensorType)\n    );\n  }\n  get setTfliteSensorTypes() {\n    return this.#tfliteManager.setSensorTypes;\n  }\n  get tfliteIsReady() {\n    return this.#tfliteManager.isReady;\n  }\n\n  // TFLITE INFERENCING\n\n  get tfliteInferencingEnabled() {\n    return this.#tfliteManager.inferencingEnabled;\n  }\n  get setTfliteInferencingEnabled() {\n    return this.#tfliteManager.setInferencingEnabled;\n  }\n  async enableTfliteInferencing() {\n    return this.setTfliteInferencingEnabled(true);\n  }\n  async disableTfliteInferencing() {\n    return this.setTfliteInferencingEnabled(false);\n  }\n  get toggleTfliteInferencing() {\n    return this.#tfliteManager.toggleInferencingEnabled;\n  }\n\n  // TFLITE INFERENCE CONFIG\n\n  get tfliteCaptureDelay() {\n    return this.#tfliteManager.captureDelay;\n  }\n  get setTfliteCaptureDelay() {\n    return this.#tfliteManager.setCaptureDelay;\n  }\n  get tfliteThreshold() {\n    return this.#tfliteManager.threshold;\n  }\n  get setTfliteThreshold() {\n    return this.#tfliteManager.setThreshold;\n  }\n\n  // FIRMWARE MANAGER\n\n  #firmwareManager = new FirmwareManager();\n\n  get canUpdateFirmware() {\n    return this.#connectionManager?.canUpdateFirmware;\n  }\n  #assertCanUpdateFirmware() {\n    _console.assertWithError(this.canUpdateFirmware, \"can't update firmware\");\n  }\n\n  #sendSmpMessage(data: ArrayBuffer) {\n    this.#assertCanUpdateFirmware();\n    return this.#connectionManager!.sendSmpMessage(data);\n  }\n  private sendSmpMessage = this.#sendSmpMessage.bind(this);\n\n  get uploadFirmware() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.uploadFirmware;\n  }\n  get canReset() {\n    return this.canUpdateFirmware;\n  }\n  async reset() {\n    _console.assertWithError(\n      this.canReset,\n      \"reset is not enabled for this device\"\n    );\n    await this.#firmwareManager.reset();\n    return this.#connectionManager!.disconnect();\n  }\n  get firmwareStatus() {\n    return this.#firmwareManager.status;\n  }\n  get getFirmwareImages() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.getImages;\n  }\n  get firmwareImages() {\n    return this.#firmwareManager.images;\n  }\n  get eraseFirmwareImage() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.eraseImage;\n  }\n  get confirmFirmwareImage() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.confirmImage;\n  }\n  get testFirmwareImage() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.testImage;\n  }\n\n  // SERVER SIDE\n  #isServerSide = false;\n  get isServerSide() {\n    return this.#isServerSide;\n  }\n  set isServerSide(newIsServerSide) {\n    if (this.#isServerSide == newIsServerSide) {\n      _console.log(\"redundant isServerSide assignment\");\n      return;\n    }\n    _console.log({ newIsServerSide });\n    this.#isServerSide = newIsServerSide;\n\n    this.#fileTransferManager.isServerSide = this.isServerSide;\n  }\n\n  // UKATON\n  get isUkaton() {\n    return this.deviceInformation.modelNumber.includes(\"Ukaton\");\n  }\n\n  // WIFI MANAGER\n  #wifiManager = new WifiManager();\n  get isWifiAvailable() {\n    return this.#wifiManager.isWifiAvailable;\n  }\n  get wifiSSID() {\n    return this.#wifiManager.wifiSSID;\n  }\n  async setWifiSSID(newWifiSSID: string) {\n    return this.#wifiManager.setWifiSSID(newWifiSSID);\n  }\n  get wifiPassword() {\n    return this.#wifiManager.wifiPassword;\n  }\n  async setWifiPassword(newWifiPassword: string) {\n    return this.#wifiManager.setWifiPassword(newWifiPassword);\n  }\n  get isWifiConnected() {\n    return this.#wifiManager.isWifiConnected;\n  }\n  get ipAddress() {\n    return this.#wifiManager.ipAddress;\n  }\n  get wifiConnectionEnabled() {\n    return this.#wifiManager.wifiConnectionEnabled;\n  }\n  get enableWifiConnection() {\n    return this.#wifiManager.enableWifiConnection;\n  }\n  get setWifiConnectionEnabled() {\n    return this.#wifiManager.setWifiConnectionEnabled;\n  }\n  get disableWifiConnection() {\n    return this.#wifiManager.disableWifiConnection;\n  }\n  get toggleWifiConnection() {\n    return this.#wifiManager.toggleWifiConnection;\n  }\n  get isWifiSecure() {\n    return this.#wifiManager.isWifiSecure;\n  }\n\n  async reconnectViaWebSockets() {\n    _console.assertWithError(this.isWifiConnected, \"wifi is not connected\");\n    _console.assertWithError(\n      this.connectionType != \"webSocket\",\n      \"already connected via webSockets\"\n    );\n    _console.assertTypeWithError(this.ipAddress, \"string\");\n    _console.log(\"reconnecting via websockets...\");\n    await this.disconnect();\n    await this.connect({\n      type: \"webSocket\",\n      ipAddress: this.ipAddress!,\n      isWifiSecure: this.isWifiSecure,\n    });\n  }\n\n  async reconnectViaUDP() {\n    _console.assertWithError(isInNode, \"udp is only available in node\");\n    _console.assertWithError(this.isWifiConnected, \"wifi is not connected\");\n    _console.assertWithError(\n      this.connectionType != \"udp\",\n      \"already connected via udp\"\n    );\n    _console.assertTypeWithError(this.ipAddress, \"string\");\n    _console.log(\"reconnecting via udp...\");\n    await this.disconnect();\n    await this.connect({\n      type: \"udp\",\n      ipAddress: this.ipAddress!,\n    });\n  }\n\n  // CAMERA MANAGER\n  #cameraManager = new CameraManager();\n  get hasCamera() {\n    return this.sensorTypes.includes(\"camera\");\n  }\n  get cameraStatus() {\n    return this.#cameraManager.cameraStatus;\n  }\n  #assertHasCamera() {\n    _console.assertWithError(this.hasCamera, \"camera not available\");\n  }\n  async takePicture(sensorRate: number = 10) {\n    this.#assertHasCamera();\n    if (this.sensorConfiguration.camera == 0) {\n      this.setSensorConfiguration({ camera: sensorRate }, false, false);\n    }\n    await this.#cameraManager.takePicture();\n  }\n  async focusCamera(sensorRate: number = 10) {\n    this.#assertHasCamera();\n    if (this.sensorConfiguration.camera == 0) {\n      this.setSensorConfiguration({ camera: sensorRate }, false, false);\n    }\n    await this.#cameraManager.focus();\n  }\n  async stopCamera() {\n    this.#assertHasCamera();\n    await this.#cameraManager.stop();\n  }\n  async wakeCamera() {\n    this.#assertHasCamera();\n    await this.#cameraManager.wake();\n  }\n  async sleepCamera() {\n    this.#assertHasCamera();\n    await this.#cameraManager.sleep();\n  }\n\n  get cameraConfiguration() {\n    return this.#cameraManager.cameraConfiguration;\n  }\n  get availableCameraConfigurationTypes() {\n    return this.#cameraManager.availableCameraConfigurationTypes;\n  }\n  get cameraConfigurationRanges() {\n    return this.#cameraManager.cameraConfigurationRanges;\n  }\n\n  get setCameraConfiguration() {\n    return this.#cameraManager.setCameraConfiguration;\n  }\n\n  // MICROPHONE\n  #microphoneManager = new MicrophoneManager();\n  get hasMicrophone() {\n    return this.sensorTypes.includes(\"microphone\");\n  }\n  get microphoneStatus() {\n    return this.#microphoneManager.microphoneStatus;\n  }\n  #assertHasMicrophone() {\n    _console.assertWithError(this.hasMicrophone, \"microphone not available\");\n  }\n\n  async startMicrophone() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.start();\n  }\n  async stopMicrophone() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.stop();\n  }\n  async enableMicrophoneVad() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.vad();\n  }\n  async toggleMicrophone() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.toggle();\n  }\n\n  get microphoneConfiguration() {\n    return this.#microphoneManager.microphoneConfiguration;\n  }\n  get availableMicrophoneConfigurationTypes() {\n    return this.#microphoneManager.availableMicrophoneConfigurationTypes;\n  }\n  get setMicrophoneConfiguration() {\n    return this.#microphoneManager.setMicrophoneConfiguration;\n  }\n\n  #assertWebAudioSupport() {\n    _console.assertWithError(AudioContext, \"WebAudio is not supported\");\n  }\n\n  get audioContext() {\n    this.#assertWebAudioSupport();\n    return this.#microphoneManager.audioContext;\n  }\n  set audioContext(newAudioContext) {\n    this.#assertWebAudioSupport();\n    this.#microphoneManager.audioContext = newAudioContext;\n  }\n  get microphoneMediaStreamDestination() {\n    this.#assertWebAudioSupport();\n    return this.#microphoneManager.mediaStreamDestination;\n  }\n  get microphoneGainNode() {\n    this.#assertWebAudioSupport();\n    return this.#microphoneManager.gainNode;\n  }\n\n  get isRecordingMicrophone() {\n    return this.#microphoneManager.isRecording;\n  }\n  startRecordingMicrophone() {\n    this.#assertWebAudioSupport();\n    this.#microphoneManager.startRecording();\n  }\n  stopRecordingMicrophone() {\n    this.#assertWebAudioSupport();\n    this.#microphoneManager.stopRecording();\n  }\n  toggleMicrophoneRecording() {\n    this.#assertWebAudioSupport();\n    this.#microphoneManager.toggleRecording();\n  }\n\n  // DISPLAY\n  #displayManager = new DisplayManager();\n\n  get isDisplayAvailable() {\n    return this.#displayManager.isAvailable;\n  }\n  get isDisplayReady() {\n    return this.#displayManager.isReady;\n  }\n  get displayContextState() {\n    return this.#displayManager.contextState;\n  }\n  get displayColors() {\n    return this.#displayManager.colors;\n  }\n  get displayBitmapColors() {\n    return this.#displayManager.bitmapColors;\n  }\n  get displayBitmapColorIndices() {\n    return this.#displayManager.bitmapColorIndices;\n  }\n  get displayColorOpacities() {\n    return this.#displayManager.opacities;\n  }\n  #assertDisplayIsAvailable() {\n    _console.assertWithError(this.isDisplayAvailable, \"display not available\");\n  }\n  get displayStatus() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.displayStatus;\n  }\n  get displayBrightness() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.brightness;\n  }\n  get setDisplayBrightness() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBrightness;\n  }\n\n  get displayInformation() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.displayInformation;\n  }\n  get numberOfDisplayColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.numberOfColors;\n  }\n\n  get wakeDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.wake;\n  }\n  get sleepDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.sleep;\n  }\n  get toggleDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.toggle;\n  }\n  get isDisplayAwake() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.isDisplayAwake;\n  }\n\n  get showDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.show;\n  }\n  get clearDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clear;\n  }\n\n  get setDisplayColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setColor;\n  }\n  get setDisplayColorOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setColorOpacity;\n  }\n  get setDisplayOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setOpacity;\n  }\n\n  get saveDisplayContext() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.saveContext;\n  }\n  get restoreDisplayContext() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.restoreContext;\n  }\n\n  get clearDisplayRect() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearRect;\n  }\n\n  get selectDisplayFillColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectFillColor;\n  }\n  get selectDisplayLineColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectLineColor;\n  }\n  get setDisplayLineWidth() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setLineWidth;\n  }\n  get setDisplayRotation() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotation;\n  }\n  get clearDisplayRotation() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearRotation;\n  }\n\n  get setDisplaySegmentStartCap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentStartCap;\n  }\n  get setDisplaySegmentEndCap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentEndCap;\n  }\n  get setDisplaySegmentCap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentCap;\n  }\n\n  get setDisplaySegmentStartRadius() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentStartRadius;\n  }\n  get setDisplaySegmentEndRadius() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentEndRadius;\n  }\n  get setDisplaySegmentRadius() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentRadius;\n  }\n\n  get setDisplayCropTop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropTop;\n  }\n  get setDisplayCropRight() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropRight;\n  }\n  get setDisplayCropBottom() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropBottom;\n  }\n  get setDisplayCropLeft() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropLeft;\n  }\n  get setDisplayCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCrop;\n  }\n  get clearDisplayCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearCrop;\n  }\n\n  get setDisplayRotationCropTop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropTop;\n  }\n  get setDisplayRotationCropRight() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropRight;\n  }\n  get setDisplayRotationCropBottom() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropBottom;\n  }\n  get setDisplayRotationCropLeft() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropLeft;\n  }\n  get setDisplayRotationCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCrop;\n  }\n  get clearDisplayRotationCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearRotationCrop;\n  }\n  get flushDisplayContextCommands() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.flushContextCommands;\n  }\n\n  get drawDisplayRect() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawRect;\n  }\n  get drawDisplayCircle() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawCircle;\n  }\n  get drawDisplayEllipse() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawEllipse;\n  }\n  get drawDisplayRoundRect() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawRoundRect;\n  }\n  get drawDisplayPolygon() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawPolygon;\n  }\n  get drawDisplaySegment() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawSegment;\n  }\n  get drawDisplaySegments() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawSegments;\n  }\n  get drawDisplayArc() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawArc;\n  }\n  get drawDisplayArcEllipse() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawArcEllipse;\n  }\n  get drawDisplayBitmap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawBitmap;\n  }\n  get imageToDisplayBitmap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.imageToBitmap;\n  }\n  get quantizeDisplayImage() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.quantizeImage;\n  }\n  get resizeAndQuantizeDisplayImage() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.resizeAndQuantizeImage;\n  }\n\n  get setDisplayContextState() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setContextState;\n  }\n\n  get selectDisplayBitmapColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectBitmapColor;\n  }\n  get selectDisplayBitmapColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectBitmapColors;\n  }\n  get setDisplayBitmapColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapColor;\n  }\n  get setDisplayBitmapColorOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapColorOpacity;\n  }\n\n  get setDisplayBitmapScaleDirection() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScaleDirection;\n  }\n  get setDisplayBitmapScaleX() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScaleX;\n  }\n  get setDisplayBitmapScaleY() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScaleY;\n  }\n  get setDisplayBitmapScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScale;\n  }\n  get resetDisplayBitmapScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.resetBitmapScale;\n  }\n\n  get selectDisplaySpriteColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectSpriteColor;\n  }\n  get selectDisplaySpriteColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectSpriteColors;\n  }\n  get setDisplaySpriteColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteColor;\n  }\n  get setDisplaySpriteColorOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteColorOpacity;\n  }\n  get resetDisplaySpriteColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.resetSpriteColors;\n  }\n\n  get setDisplaySpriteScaleDirection() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteScaleDirection;\n  }\n  get setDisplaySpriteScaleX() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteScaleX;\n  }\n  get setDisplaySpriteScaleY() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteScaleY;\n  }\n  get setDisplaySpriteScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteScale;\n  }\n  get resetDisplaySpriteScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.resetSpriteScale;\n  }\n\n  get displayManager() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager as DisplayManagerInterface;\n  }\n\n  get uploadDisplaySpriteSheet() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.uploadSpriteSheet;\n  }\n  get uploadDisplaySpriteSheets() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.uploadSpriteSheets;\n  }\n  get selectDisplaySpriteSheet() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectSpriteSheet;\n  }\n  get drawDisplaySprite() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawSprite;\n  }\n\n  get displaySpriteSheets() {\n    return this.#displayManager.spriteSheets;\n  }\n\n  get serializeDisplaySpriteSheet() {\n    return this.#displayManager.serializeSpriteSheet;\n  }\n\n  // FILL - text, etc\n}\n\nexport default Device;\n","import Device, {\n  BoundDeviceEventListeners,\n  DeviceEventMap,\n} from \"../Device.ts\";\nimport {\n  DisplayBitmapColorPair,\n  DisplayBrightness,\n  DisplaySpriteColorPair,\n  DisplayBitmap,\n} from \"../DisplayManager.ts\";\nimport {\n  assertValidBitmapPixels,\n  imageToBitmap,\n  quantizeImage,\n  resizeAndQuantizeImage,\n} from \"./DisplayBitmapUtils.ts\";\nimport { hexToRGB, rgbToHex, stringToRGB } from \"./ColorUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport {\n  DisplayContextState,\n  DisplayContextStateKey,\n  DisplaySegmentCap,\n  PartialDisplayContextState,\n} from \"./DisplayContextState.ts\";\nimport DisplayContextStateHelper from \"./DisplayContextStateHelper.ts\";\nimport {\n  assertAnySelectedSpriteSheet,\n  assertLoadedSpriteSheet,\n  assertSelectedSpriteSheet,\n  assertSprite,\n  assertSpritePaletteSwap,\n  assertSpriteSheetPalette,\n  assertSpriteSheetPaletteSwap,\n  DisplayManagerInterface,\n  DisplayTransform,\n  getSprite,\n  getSpritePaletteSwap,\n  getSpriteSheetPalette,\n  getSpriteSheetPaletteSwap,\n  runDisplayContextCommand,\n  runDisplayContextCommands,\n  selectSpritePaletteSwap,\n  selectSpriteSheetPalette,\n  selectSpriteSheetPaletteSwap,\n} from \"./DisplayManagerInterface.ts\";\nimport {\n  assertValidColor,\n  assertValidOpacity,\n  assertValidSegmentCap,\n  DisplayScaleDirection,\n  displayScaleStep,\n  DisplayColorRGB,\n  DisplayCropDirection,\n  DisplayCropDirections,\n  DisplayCropDirectionToCommandType,\n  DisplayCropDirectionToStateKey,\n  DisplayRotationCropDirectionToCommandType,\n  DisplayRotationCropDirectionToStateKey,\n  maxDisplayScale,\n  roundScale,\n  minDisplayScale,\n} from \"./DisplayUtils.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"./EventDispatcher.ts\";\nimport { addEventListeners, removeEventListeners } from \"./EventUtils.ts\";\nimport {\n  clamp,\n  degToRad,\n  getVector2Angle,\n  getVector2Length,\n  normalizedVector2,\n  normalizeRadians,\n  Vector2,\n} from \"./MathUtils.ts\";\nimport { wait } from \"./Timer.ts\";\nimport { DisplayContextCommand } from \"./DisplayContextCommand.ts\";\nimport {\n  DisplaySprite,\n  DisplaySpritePaletteSwap,\n  DisplaySpriteSheet,\n  DisplaySpriteSheetPalette,\n  DisplaySpriteSheetPaletteSwap,\n  fontToSpriteSheet,\n  serializeSpriteSheet,\n} from \"./DisplaySpriteSheetUtils.ts\";\n\nconst _console = createConsole(\"DisplayCanvasHelper\", { log: true });\n\nexport const DisplayCanvasHelperEventTypes = [\n  \"contextState\",\n  \"numberOfColors\",\n  \"brightness\",\n  \"color\",\n  \"colorOpacity\",\n  \"opacity\",\n  \"resize\",\n  \"update\",\n  \"ready\",\n  \"device\",\n  \"deviceIsConnected\",\n  \"deviceConnected\",\n  \"deviceNotConnected\",\n  \"deviceSpriteSheetUploadStart\",\n  \"deviceSpriteSheetUploadProgress\",\n  \"deviceSpriteSheetUploadComplete\",\n] as const;\nexport type DisplayCanvasHelperEventType =\n  (typeof DisplayCanvasHelperEventTypes)[number];\n\nexport interface DisplayCanvasHelperEventMessages {\n  contextState: {\n    contextState: DisplayContextState;\n    differences: DisplayContextStateKey[];\n  };\n  numberOfColors: {\n    numberOfColors: number;\n  };\n  brightness: {\n    brightness: DisplayBrightness;\n  };\n  color: {\n    colorIndex: number;\n    colorRGB: DisplayColorRGB;\n    colorHex: string;\n  };\n  colorOpacity: {\n    opacity: number;\n    colorIndex: number;\n  };\n  opacity: {\n    opacity: number;\n  };\n  resize: {\n    width: number;\n    height: number;\n  };\n  update: {};\n  ready: {};\n\n  device: {\n    device?: Device;\n  };\n  deviceIsConnected: {\n    device: Device;\n    isConnected: boolean;\n  };\n  deviceConnected: {\n    device: Device;\n  };\n  deviceNotConnected: {\n    device: Device;\n  };\n\n  deviceSpriteSheetUploadStart: {\n    device: Device;\n    spriteSheet: DisplaySpriteSheet;\n    spriteSheetName: string;\n  };\n  deviceSpriteSheetUploadProgress: {\n    device: Device;\n    spriteSheet: DisplaySpriteSheet;\n    spriteSheetName: string;\n    progress: number;\n  };\n  deviceSpriteSheetUploadComplete: {\n    device: Device;\n    spriteSheet: DisplaySpriteSheet;\n    spriteSheetName: string;\n  };\n}\n\nexport type DisplayCanvasHelperEventDispatcher = EventDispatcher<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type DisplayCanvasHelperEvent = Event<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type DisplayCanvasHelperEventMap = EventMap<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type DisplayCanvasHelperEventListenerMap = EventListenerMap<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type BoundDisplayCanvasHelperEventListeners = BoundEventListeners<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\n\nexport type DisplayBoundingBox = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nclass DisplayCanvasHelper implements DisplayManagerInterface {\n  constructor() {\n    this.numberOfColors = 16;\n    this.#bitmapContext = this.#bitmapCanvas.getContext(\"2d\")!;\n    this.#bitmapContext.imageSmoothingEnabled = false;\n  }\n\n  // EVENT DISPATCHER\n  #eventDispatcher: DisplayCanvasHelperEventDispatcher = new EventDispatcher(\n    this as DisplayCanvasHelper,\n    DisplayCanvasHelperEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // CANVAS\n  #canvas?: HTMLCanvasElement;\n  get canvas() {\n    return this.#canvas;\n  }\n  set canvas(newCanvas) {\n    _console.assertWithError(\n      newCanvas?.nodeName == \"CANVAS\",\n      `assigned non-canvas type ${newCanvas?.nodeName}`\n    );\n    if (this.#canvas == newCanvas) {\n      // _console.log(\"redundant canvas assignment\", newCanvas);\n      return;\n    }\n    this.#canvas = newCanvas;\n    // _console.log(\"assigned canvas\", this.canvas);\n\n    this.#context = this.#canvas?.getContext(\"2d\", {\n      willReadFrequently: true,\n    })!;\n    this.#updateCanvas();\n  }\n  #context!: CanvasRenderingContext2D;\n  get context() {\n    return this.#context;\n  }\n\n  get width() {\n    return this.canvas?.width || 0;\n  }\n  get height() {\n    return this.canvas?.height || 0;\n  }\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n\n  #updateCanvas() {\n    if (!this.canvas) {\n      return;\n    }\n    this.canvas!.style.aspectRatio = `${this.aspectRatio}`;\n    if (!this.device?.isConnected) {\n      return;\n    }\n\n    // _console.log(\"updateCanvas\");\n\n    const { width, height } = this.device.displayInformation!;\n    // _console.log({ width, height });\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.canvas.style.aspectRatio = `${width / height}`;\n\n    this.#dispatchEvent(\"resize\", { width: this.width, height: this.height });\n\n    this.clear();\n  }\n\n  // CONTEXT STACK\n  #frontDrawStack: Function[] = [];\n  #rearDrawStack: Function[] = [];\n  #drawFrontDrawStack() {\n    if (!this.context) {\n      return;\n    }\n    this.#context.imageSmoothingEnabled = false;\n\n    this.#save();\n    this.#context.resetTransform();\n    this.#context.clearRect(0, 0, this.width, this.height);\n    this.#restore();\n\n    this.#drawBackground();\n\n    this.#frontDrawStack.forEach((callback) => callback());\n    if (this.#applyTransparency) {\n      this.#applyTransparencyToCanvas();\n    }\n    this.#dispatchEvent(\"update\", {});\n  }\n  #applyTransparencyToCanvas() {\n    const ctx = this.context;\n    const imageData = ctx.getImageData(\n      0,\n      0,\n      this.canvas!.width,\n      this.canvas!.height\n    );\n    const data = imageData.data;\n\n    const alphaBoost = 1.0; // >1 = more opaque, try 1.1–1.5 for subtlety\n\n    for (let i = 0; i < data.length; i += 4) {\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n\n      // Perceived brightness\n      const brightness = 0.299 * r + 0.587 * g + 0.114 * b;\n      const alpha = Math.min(255, brightness * alphaBoost);\n\n      // Unpremultiply for clarity\n      const scale = alpha > 0 ? 255 / alpha : 0;\n      data[i] = Math.min(255, r * scale);\n      data[i + 1] = Math.min(255, g * scale);\n      data[i + 2] = Math.min(255, b * scale);\n      data[i + 3] = alpha;\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n  }\n\n  #drawBackground() {\n    // _console.log(\"drawBackground\");\n    this.#save();\n    this.#context.resetTransform();\n    this.#context.fillStyle = this.#colorIndexToRgbString(0);\n    this.#context.fillRect(0, 0, this.width, this.height);\n    this.#restore();\n  }\n  #applyTransparency = false;\n  get applyTransparency() {\n    return this.#applyTransparency;\n  }\n  set applyTransparency(newValue) {\n    this.#applyTransparency = newValue;\n    // _console.log({ applyTransparency: this.applyTransparency });\n    this.#drawFrontDrawStack();\n  }\n\n  // DEVICE\n  #device?: Device;\n  get device() {\n    return this.#device;\n  }\n  set device(newDevice) {\n    if (this.#device == newDevice) {\n      // _console.log(\"redundant device assignment\", newDevice);\n      return;\n    }\n    if (newDevice) {\n      _console.assertWithError(\n        newDevice.isConnected,\n        \"device must be connected\"\n      );\n      _console.assertWithError(\n        newDevice.isDisplayAvailable,\n        \"display must have a display\"\n      );\n    }\n    if (this.#device) {\n      removeEventListeners(this.device, this.#boundDeviceEventListeners);\n      this.#isReady = true;\n    }\n    this.#device = newDevice;\n    addEventListeners(this.#device, this.#boundDeviceEventListeners);\n    // _console.log(\"assigned device\", this.device);\n    if (this.device) {\n      this.numberOfColors = this.device.numberOfDisplayColors!;\n      this.#updateCanvas();\n      this.#updateDevice();\n      this.#isReady = this.device.isDisplayReady;\n\n      this.#dispatchEvent(\"deviceIsConnected\", {\n        device: this.device,\n        isConnected: this.device!.isConnected,\n      });\n      this.#dispatchEvent(\n        this.device.isConnected ? \"deviceConnected\" : \"deviceNotConnected\",\n        {\n          device: this.device,\n        }\n      );\n    }\n    this.#dispatchEvent(\"device\", {\n      device: this.device,\n    });\n  }\n\n  async flushContextCommands() {\n    if (this.#device?.isConnected) {\n      await this.#device.flushDisplayContextCommands();\n    }\n  }\n\n  // DEVICE EVENTLISTENERS\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    isConnected: this.#onDeviceIsConnected.bind(this),\n    displayReady: this.#onDeviceDisplayReady.bind(this),\n    displaySpriteSheetUploadStart:\n      this.#onDeviceDisplaySpriteSheetUploadStart.bind(this),\n    displaySpriteSheetUploadProgress:\n      this.#onDeviceDisplaySpriteSheetUploadProgress.bind(this),\n    displaySpriteSheetUploadComplete:\n      this.#onDeviceDisplaySpriteSheetUploadComplete.bind(this),\n  };\n  #onDeviceIsConnected(event: DeviceEventMap[\"isConnected\"]) {\n    const { isConnected } = event.message;\n    this.#dispatchEvent(\"deviceIsConnected\", {\n      device: this.device!,\n      isConnected,\n    });\n\n    if (isConnected) {\n      this.#onDeviceConnected();\n    } else {\n      this.#onDeviceNotConnected();\n    }\n  }\n  #onDeviceConnected() {\n    // _console.log(\"device connected\");\n    this.#updateCanvas();\n    this.#updateDevice();\n    this.#dispatchEvent(\"deviceConnected\", { device: this.device! });\n    // FIX - messages flushed properly?\n  }\n  #onDeviceNotConnected() {\n    // _console.log(\"device not connected\");\n    this.#dispatchEvent(\"deviceNotConnected\", { device: this.device! });\n  }\n  async #onDeviceDisplayReady(event: DeviceEventMap[\"displayReady\"]) {\n    // _console.log(\"device display ready\");\n    this.#isReady = true;\n    // await wait(5); // we need to wait for some reason\n    this.#dispatchEvent(\"ready\", {});\n  }\n\n  #onDeviceDisplaySpriteSheetUploadStart(\n    event: DeviceEventMap[\"displaySpriteSheetUploadStart\"]\n  ) {\n    const device = event.target;\n    const { spriteSheet, spriteSheetName } = event.message;\n    this.#dispatchEvent(\"deviceSpriteSheetUploadStart\", {\n      device,\n      spriteSheet,\n      spriteSheetName,\n    });\n  }\n  #onDeviceDisplaySpriteSheetUploadProgress(\n    event: DeviceEventMap[\"displaySpriteSheetUploadProgress\"]\n  ) {\n    const device = event.target;\n    const { spriteSheet, spriteSheetName, progress } = event.message;\n    this.#dispatchEvent(\"deviceSpriteSheetUploadProgress\", {\n      device,\n      spriteSheet,\n      spriteSheetName,\n      progress,\n    });\n  }\n  #onDeviceDisplaySpriteSheetUploadComplete(\n    event: DeviceEventMap[\"displaySpriteSheetUploadComplete\"]\n  ) {\n    const device = event.target;\n    const { spriteSheet, spriteSheetName } = event.message;\n    this.#dispatchEvent(\"deviceSpriteSheetUploadComplete\", {\n      device,\n      spriteSheet,\n      spriteSheetName,\n    });\n  }\n\n  async #updateDevice() {\n    await this.#updateDeviceColors(true);\n    await this.#updateDeviceOpacity(true);\n    await this.#updateDeviceContextState(true);\n    await this.#updateDeviceBrightness(true);\n    await this.#updateDeviceSpriteSheets();\n    await this.#updateDeviceSelectedSpriteSheet(true);\n  }\n\n  // NUMBER OF COLORS\n  #numberOfColors: number = 0;\n  get numberOfColors() {\n    return this.#numberOfColors;\n  }\n  set numberOfColors(newNumberOfColors) {\n    if (this.#numberOfColors == newNumberOfColors) {\n      return;\n    }\n\n    this.#numberOfColors = newNumberOfColors;\n    // _console.log({ numberOfColors: this.numberOfColors });\n\n    this.#colors = new Array(this.numberOfColors).fill(\"#000000\");\n    this.#opacities = new Array(this.numberOfColors).fill(1);\n    this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n\n    this.#dispatchEvent(\"numberOfColors\", {\n      numberOfColors: this.numberOfColors,\n    });\n  }\n\n  // COLORS\n  assertValidColorIndex(colorIndex: number) {\n    _console.assertRangeWithError(\n      \"colorIndex\",\n      colorIndex,\n      0,\n      this.numberOfColors\n    );\n  }\n  #colors: string[] = [];\n  get colors() {\n    return this.#colors;\n  }\n  #resetColors() {\n    this.#colors.length = 0;\n  }\n  async #updateDeviceColors(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    for (const [index, color] of this.colors.entries()) {\n      await this.device?.setDisplayColor(index, color, false);\n    }\n    if (sendImmediately) {\n      await this.#device?.flushDisplayContextCommands();\n    }\n  }\n\n  // OPACITIES\n  #opacities: number[] = [];\n  get opacities() {\n    return this.#opacities;\n  }\n  #resetOpacities() {\n    this.#opacities.length = 0;\n  }\n\n  async #updateDeviceOpacity(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    for (const [index, opacity] of this.#opacities.entries()) {\n      await this.device?.setDisplayColorOpacity(index, opacity, false);\n    }\n    if (sendImmediately) {\n      await this.#device?.flushDisplayContextCommands();\n    }\n  }\n\n  // CONEXT STATE\n  #contextStateHelper = new DisplayContextStateHelper();\n  get contextState() {\n    return this.#contextStateHelper.state;\n  }\n  #onContextStateUpdate(differences: DisplayContextStateKey[]) {\n    this.#dispatchEvent(\"contextState\", {\n      contextState: structuredClone(this.contextState),\n      differences,\n    });\n  }\n  #resetContextState() {\n    this.#contextStateHelper.reset();\n    this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n  }\n  async #updateDeviceContextState(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    // _console.log(\"updateDeviceContextState\");\n    await this.device?.setDisplayContextState(\n      this.contextState,\n      sendImmediately\n    );\n  }\n\n  async show(sendImmediately = true) {\n    // _console.log(\"showDisplay\");\n\n    this.#frontDrawStack = this.#rearDrawStack.slice();\n    this.#rearDrawStack.length = 0;\n\n    this.#drawFrontDrawStack();\n\n    this.#isReady = false;\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.showDisplay(sendImmediately);\n    } else {\n      await wait(this.#interval);\n      this.#isReady = true;\n      this.#dispatchEvent(\"ready\", {});\n    }\n  }\n  #interval = 50;\n  get interval() {\n    return this.#interval;\n  }\n  set interval(newInterval) {\n    this.#interval = newInterval;\n    // _console.log({ interval: this.#interval });\n  }\n\n  #isReady = true;\n  get isReady() {\n    return this.#isReady;\n  }\n\n  async clear(sendImmediately = true) {\n    // _console.log(\"clearDisplay\");\n\n    this.#frontDrawStack.length = 0;\n    this.#rearDrawStack.length = 0;\n\n    this.#isReady = false;\n    this.#save();\n    this.#context.resetTransform();\n    this.#context.clearRect(0, 0, this.width, this.height);\n    this.#restore();\n    this.#drawBackground();\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.clearDisplay(sendImmediately);\n    } else {\n      await wait(this.#interval);\n      this.#isReady = true;\n      this.#dispatchEvent(\"ready\", {});\n    }\n  }\n\n  async setColor(\n    colorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    let colorRGB: DisplayColorRGB;\n    if (typeof color == \"string\") {\n      colorRGB = stringToRGB(color);\n    } else {\n      colorRGB = color;\n    }\n    const colorHex = rgbToHex(colorRGB);\n    if (this.colors[colorIndex] == colorHex) {\n      // _console.log(`redundant color #${colorIndex} ${colorHex}`);\n      return;\n    }\n\n    // _console.log(`setting color #${colorIndex}`, color);\n    this.assertValidColorIndex(colorIndex);\n    assertValidColor(colorRGB);\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplayColor(colorIndex, color, sendImmediately);\n    }\n\n    this.colors[colorIndex] = colorHex;\n    this.#drawFrontDrawStack();\n    this.#dispatchEvent(\"color\", { colorIndex, colorHex, colorRGB });\n  }\n\n  async setColorOpacity(\n    colorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(colorIndex);\n    assertValidOpacity(opacity);\n    if (\n      Math.floor(255 * this.#opacities[colorIndex]) == Math.floor(255 * opacity)\n    ) {\n      // _console.log(`redundant opacity #${colorIndex} ${opacity}`);\n      return;\n    }\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplayColorOpacity(\n        colorIndex,\n        opacity,\n        sendImmediately\n      );\n    }\n\n    this.#opacities[colorIndex] = opacity;\n    this.#drawFrontDrawStack();\n    this.#dispatchEvent(\"colorOpacity\", { colorIndex, opacity });\n  }\n  async setOpacity(opacity: number, sendImmediately?: boolean) {\n    assertValidOpacity(opacity);\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplayOpacity(opacity, sendImmediately);\n    }\n    this.#opacities.fill(opacity);\n    this.#drawFrontDrawStack();\n    this.#dispatchEvent(\"opacity\", { opacity });\n  }\n\n  // CONTEXT COMMANDS\n  async saveContext(sendImmediately?: boolean) {\n    // FILL\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.saveDisplayContext(sendImmediately);\n    }\n    //this.#onDisplayContextStateUpdate(differences);\n  }\n  async restoreContext(sendImmediately?: boolean) {\n    // FILL\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.restoreDisplayContext(sendImmediately);\n    }\n    //this.#onDisplayContextStateUpdate(differences);\n  }\n  async selectFillColor(fillColorIndex: number, sendImmediately?: boolean) {\n    this.assertValidColorIndex(fillColorIndex);\n    const differences = this.#contextStateHelper.update({\n      fillColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.selectDisplayFillColor(fillColorIndex, sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async selectLineColor(lineColorIndex: number, sendImmediately?: boolean) {\n    this.assertValidColorIndex(lineColorIndex);\n    const differences = this.#contextStateHelper.update({\n      lineColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.selectDisplayLineColor(lineColorIndex, sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  assertValidLineWidth(lineWidth: number) {\n    _console.assertRangeWithError(\"lineWidth\", lineWidth, 0, this.width);\n  }\n  async setLineWidth(lineWidth: number, sendImmediately?: boolean) {\n    this.assertValidLineWidth(lineWidth);\n    const differences = this.#contextStateHelper.update({\n      lineWidth,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplayLineWidth(lineWidth, sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setRotation(\n    rotation: number,\n    isRadians: boolean,\n    sendImmediately?: boolean\n  ) {\n    rotation = isRadians ? rotation : degToRad(rotation);\n    rotation = normalizeRadians(rotation);\n    // _console.log({ rotation });\n\n    const differences = this.#contextStateHelper.update({\n      rotation,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplayRotation(rotation, true, sendImmediately);\n    }\n\n    this.#onContextStateUpdate(differences);\n  }\n  async clearRotation(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotation: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.clearDisplayRotation(sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentStartCap(\n    segmentStartCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentStartCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ segmentStartCap });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplaySegmentStartCap(\n        segmentStartCap,\n        sendImmediately\n      );\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndCap(\n    segmentEndCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentEndCap);\n    const differences = this.#contextStateHelper.update({\n      segmentEndCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ segmentEndCap });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplaySegmentEndCap(segmentEndCap, sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentCap(\n    segmentCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap: segmentCap,\n      segmentEndCap: segmentCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ segmentCap });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplaySegmentCap(segmentCap, sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentStartRadius(\n    segmentStartRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ segmentStartRadius });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplaySegmentStartRadius(\n        segmentStartRadius,\n        sendImmediately\n      );\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndRadius(\n    segmentEndRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentEndRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ segmentEndRadius });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplaySegmentEndRadius(\n        segmentEndRadius,\n        sendImmediately\n      );\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  // START\n  async setSegmentRadius(segmentRadius: number, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius: segmentRadius,\n      segmentEndRadius: segmentRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ segmentRadius });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplaySegmentRadius(segmentRadius, sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    crop = Math.max(0, crop);\n    const cropCommand = DisplayCropDirectionToCommandType[cropDirection];\n    const cropKey = DisplayCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ [cropCommand]: crop });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplayCrop(cropDirection, crop, sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setCropTop(cropTop: number, sendImmediately?: boolean) {\n    await this.setCrop(\"top\", cropTop, sendImmediately);\n  }\n  async setCropRight(cropRight: number, sendImmediately?: boolean) {\n    await this.setCrop(\"right\", cropRight, sendImmediately);\n  }\n  async setCropBottom(cropBottom: number, sendImmediately?: boolean) {\n    await this.setCrop(\"bottom\", cropBottom, sendImmediately);\n  }\n  async setCropLeft(cropLeft: number, sendImmediately?: boolean) {\n    await this.setCrop(\"left\", cropLeft, sendImmediately);\n  }\n  async clearCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      cropTop: 0,\n      cropRight: 0,\n      cropBottom: 0,\n      cropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.clearDisplayCrop(sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setRotationCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    const cropCommand =\n      DisplayRotationCropDirectionToCommandType[cropDirection];\n    const cropKey = DisplayRotationCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ [cropCommand]: crop });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplayRotationCrop(\n        cropDirection,\n        crop,\n        sendImmediately\n      );\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setRotationCropTop(rotationCropTop: number, sendImmediately?: boolean) {\n    await this.setRotationCrop(\"top\", rotationCropTop, sendImmediately);\n  }\n  async setRotationCropRight(\n    rotationCropRight: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"right\", rotationCropRight, sendImmediately);\n  }\n  async setRotationCropBottom(\n    rotationCropBottom: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"bottom\", rotationCropBottom, sendImmediately);\n  }\n  async setRotationCropLeft(\n    rotationCropLeft: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"left\", rotationCropLeft, sendImmediately);\n  }\n  async clearRotationCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotationCropTop: 0,\n      rotationCropRight: 0,\n      rotationCropBottom: 0,\n      rotationCropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.clearDisplayRotationCrop(sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  get bitmapColorIndices() {\n    return this.contextState.bitmapColorIndices;\n  }\n  get bitmapColors() {\n    return this.bitmapColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  async selectBitmapColor(\n    bitmapColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(bitmapColorIndex);\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ bitmapColorIndex, colorIndex });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.selectDisplayBitmapColor(\n        bitmapColorIndex,\n        colorIndex,\n        sendImmediately\n      );\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async selectBitmapColors(\n    bitmapColorPairs: DisplayBitmapColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"bitmapColors\",\n      bitmapColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n      this.assertValidColorIndex(bitmapColorIndex);\n      this.assertValidColorIndex(colorIndex);\n      bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    });\n\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.selectDisplayBitmapColors(\n        bitmapColorPairs,\n        sendImmediately\n      );\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setBitmapColor(\n    bitmapColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.bitmapColorIndices[bitmapColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setBitmapColorOpacity(\n    bitmapColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.bitmapColorIndices[bitmapColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n\n  async setBitmapScaleDirection(\n    direction: DisplayScaleDirection,\n    bitmapScale: number,\n    sendImmediately?: boolean\n  ) {\n    bitmapScale = clamp(bitmapScale, minDisplayScale, maxDisplayScale);\n    bitmapScale = roundScale(bitmapScale);\n    //_console.log({ bitmapScale });\n    const newState: PartialDisplayContextState = {};\n    switch (direction) {\n      case \"all\":\n        newState.bitmapScaleX = bitmapScale;\n        newState.bitmapScaleY = bitmapScale;\n        break;\n      case \"x\":\n        newState.bitmapScaleX = bitmapScale;\n        break;\n      case \"y\":\n        newState.bitmapScaleY = bitmapScale;\n        break;\n    }\n    const differences = this.#contextStateHelper.update(newState);\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplayBitmapScaleDirection(\n        direction,\n        bitmapScale,\n        sendImmediately\n      );\n    }\n\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setBitmapScaleX(bitmapScaleX: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"x\", bitmapScaleX, sendImmediately);\n  }\n  async setBitmapScaleY(bitmapScaleY: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"y\", bitmapScaleY, sendImmediately);\n  }\n  async setBitmapScale(bitmapScale: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"all\", bitmapScale, sendImmediately);\n  }\n  async resetBitmapScale(sendImmediately?: boolean) {\n    //return this.setBitmapScaleDirection(\"all\", 1, sendImmediately);\n\n    const differences = this.#contextStateHelper.update({\n      bitmapScaleX: 1,\n      bitmapScaleY: 1,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.resetDisplayBitmapScale(sendImmediately);\n    }\n\n    this.#onContextStateUpdate(differences);\n  }\n\n  get spriteColorIndices() {\n    return this.contextState.spriteColorIndices;\n  }\n  get spriteColors() {\n    return this.spriteColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  get spriteBitmapColorIndices() {\n    return this.bitmapColorIndices.map(\n      (colorIndex) => this.spriteColorIndices[colorIndex]\n    );\n  }\n  get spriteBitmapColors() {\n    return this.spriteBitmapColorIndices.map(\n      (colorIndex) => this.colors[colorIndex]\n    );\n  }\n  async selectSpriteColor(\n    spriteColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(spriteColorIndex);\n    const spriteColorIndices = this.contextState.spriteColorIndices.slice();\n    spriteColorIndices[spriteColorIndex] = colorIndex;\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // _console.log({ spriteColorIndex, colorIndex });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.selectDisplaySpriteColor(\n        spriteColorIndex,\n        colorIndex,\n        sendImmediately\n      );\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async selectSpriteColors(\n    spriteColorPairs: DisplaySpriteColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"spriteColors\",\n      spriteColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const spriteColorIndices = this.contextState.spriteColorIndices.slice();\n    spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {\n      this.assertValidColorIndex(spriteColorIndex);\n      this.assertValidColorIndex(colorIndex);\n      spriteColorIndices[spriteColorIndex] = colorIndex;\n    });\n\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.selectDisplaySpriteColors(\n        spriteColorPairs,\n        sendImmediately\n      );\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpriteColor(\n    spriteColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.spriteColorIndices[spriteColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setSpriteColorOpacity(\n    spriteColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.spriteColorIndices[spriteColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n\n  async resetSpriteColors(sendImmediately?: boolean) {\n    const spriteColorIndices = new Array(this.numberOfColors).fill(0);\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.resetDisplaySpriteColors(sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpriteScaleDirection(\n    direction: DisplayScaleDirection,\n    spriteScale: number,\n    sendImmediately?: boolean\n  ) {\n    spriteScale = clamp(spriteScale, minDisplayScale, maxDisplayScale);\n    spriteScale = roundScale(spriteScale);\n    const newState: PartialDisplayContextState = {};\n    switch (direction) {\n      case \"all\":\n        newState.spriteScaleX = spriteScale;\n        newState.spriteScaleY = spriteScale;\n        break;\n      case \"x\":\n        newState.spriteScaleX = spriteScale;\n        break;\n      case \"y\":\n        newState.spriteScaleY = spriteScale;\n        break;\n    }\n    const differences = this.#contextStateHelper.update(newState);\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplaySpriteScaleDirection(\n        direction,\n        spriteScale,\n        sendImmediately\n      );\n    }\n\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpriteScaleX(spriteScaleX: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"x\", spriteScaleX, sendImmediately);\n  }\n  async setSpriteScaleY(spriteScaleY: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"y\", spriteScaleY, sendImmediately);\n  }\n  async setSpriteScale(spriteScale: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"all\", spriteScale, sendImmediately);\n  }\n  async resetSpriteScale(sendImmediately?: boolean) {\n    //return this.setSpriteScaleDirection(\"all\", 1, sendImmediately);\n\n    const differences = this.#contextStateHelper.update({\n      spriteScaleX: 1,\n      spriteScaleY: 1,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.resetDisplaySpriteScale(sendImmediately);\n    }\n\n    this.#onContextStateUpdate(differences);\n  }\n\n  #clearRectToCanvas(x: number, y: number, width: number, height: number) {\n    this.#save();\n    //this.context.resetTransform();\n    this.context.fillStyle = this.#colorIndexToRgbString(0);\n    this.context.fillRect(x, y, width, height);\n    this.#restore();\n  }\n  async clearRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    this.#rearDrawStack.push(() =>\n      this.#clearRectToCanvas(x, y, width, height)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.clearDisplayRect(x, y, width, height, sendImmediately);\n    }\n  }\n  #save() {\n    //console.trace(\"save\", window.s);\n    const ctx = this.#context;\n    ctx.save();\n  }\n  #restore() {\n    //console.trace(\"restore\");\n    const ctx = this.#context;\n    ctx.restore();\n  }\n  #transformContext(offsetX: number, offsetY: number, rotation: number) {\n    this.#translateContext(offsetX, offsetY);\n    this.#rotateContext(rotation);\n  }\n  #translateContext(offsetX: number, offsetY: number) {\n    const ctx = this.context;\n    ctx.translate(offsetX, offsetY);\n  }\n  #rotateContext(rotation: number) {\n    const ctx = this.context;\n    ctx.rotate(rotation);\n  }\n  #rotateBoundingBox(\n    box: DisplayBoundingBox,\n    rotation: number\n  ): DisplayBoundingBox {\n    const offsetX = box.x + box.width / 2;\n    const offsetY = box.y + box.height / 2;\n    const hw = box.width / 2;\n    const hh = box.height / 2;\n\n    const cos = Math.cos(rotation);\n    const sin = Math.sin(rotation);\n\n    const corners = [\n      { x: -hw, y: -hh },\n      { x: hw, y: -hh },\n      { x: hw, y: hh },\n      { x: -hw, y: hh },\n    ];\n\n    const rotated = corners.map(({ x, y }) => ({\n      x: x * cos - y * sin,\n      y: x * sin + y * cos,\n    }));\n\n    const xs = rotated.map((p) => p.x);\n    const ys = rotated.map((p) => p.y);\n\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n\n    return {\n      x: offsetX + minX,\n      y: offsetY + minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  }\n  #clearBoundingBoxOnDraw = true;\n  #clearBoundingBox(\n    { x, y, width, height }: DisplayBoundingBox,\n    isCentered = true\n  ) {\n    this.#clearRectToCanvas(\n      isCentered ? -width / 2 : x,\n      isCentered ? -height / 2 : y,\n      width,\n      height\n    );\n  }\n  #getBoundingBox(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number\n  ): DisplayBoundingBox {\n    const boundingBox = {\n      x: offsetX - width / 2,\n      y: offsetY - height / 2,\n      width: width,\n      height: height,\n    };\n    return boundingBox;\n  }\n  #getRectBoundingBox(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    { lineWidth }: DisplayContextState\n  ): DisplayBoundingBox {\n    const outerPadding = Math.ceil(lineWidth / 2);\n    const boundingBox = {\n      x: offsetX - width / 2 - outerPadding,\n      y: offsetY - height / 2 - outerPadding,\n      width: width + outerPadding * 2,\n      height: height + outerPadding * 2,\n    };\n    return boundingBox;\n  }\n  #applyClip(\n    { x, y, height, width }: DisplayBoundingBox,\n    { cropTop, cropRight, cropBottom, cropLeft }: DisplayContextState\n  ) {\n    const ctx = this.context;\n    ctx.beginPath();\n    ctx.rect(x + cropLeft, y + cropTop, width - cropRight, height - cropBottom);\n    ctx.clip();\n  }\n  #applyRotationClip(\n    { x, y, height, width }: DisplayBoundingBox,\n    {\n      rotationCropTop,\n      rotationCropRight,\n      rotationCropBottom,\n      rotationCropLeft,\n    }: DisplayContextState\n  ) {\n    const ctx = this.context;\n    ctx.beginPath();\n    ctx.rect(\n      -width / 2 + rotationCropLeft,\n      -height / 2 + rotationCropTop,\n      width - rotationCropLeft - rotationCropRight,\n      height - rotationCropTop - rotationCropBottom\n    );\n    ctx.clip();\n  }\n\n  #hexToRgbWithOpacity(hex: string, opacity: number): DisplayColorRGB {\n    // Expand shorthand hex (#f00 → #ff0000)\n    if (hex.length === 4) {\n      hex = \"#\" + [...hex.slice(1)].map((c) => c + c).join(\"\");\n    }\n\n    const r = parseInt(hex.slice(1, 3), 16);\n    const g = parseInt(hex.slice(3, 5), 16);\n    const b = parseInt(hex.slice(5, 7), 16);\n\n    // Darken color by blending toward black\n    const darken = (c: number) => Math.round(c * opacity);\n\n    const dr = darken(r);\n    const dg = darken(g);\n    const db = darken(b);\n\n    return { r: dr, g: dg, b: db };\n  }\n  #hexToRgbStringWithOpacity(hex: string, opacity: number) {\n    const { r, g, b } = this.#hexToRgbWithOpacity(hex, opacity);\n    return `rgb(${r}, ${g}, ${b})`;\n  }\n  #getColorOpacity(colorIndex: number, includeBrightness = true) {\n    return this.opacities[colorIndex] * this.#brightnessOpacity;\n  }\n  #colorIndexToRgbString(colorIndex: number) {\n    return this.#hexToRgbStringWithOpacity(\n      this.colors[colorIndex],\n      this.#getColorOpacity(colorIndex, true)\n    );\n  }\n  #colorIndexToRgb(colorIndex: number) {\n    return this.#hexToRgbWithOpacity(\n      this.colors[colorIndex],\n      this.#getColorOpacity(colorIndex, true)\n    );\n  }\n  #updateContext({\n    lineWidth,\n    fillColorIndex,\n    lineColorIndex,\n    spriteColorIndices,\n  }: DisplayContextState) {\n    if (this.#useSpriteColorIndices) {\n      fillColorIndex = spriteColorIndices[fillColorIndex];\n      lineColorIndex = spriteColorIndices[lineColorIndex];\n    }\n    this.context.fillStyle = this.#colorIndexToRgbString(fillColorIndex);\n    this.context.strokeStyle = this.#colorIndexToRgbString(lineColorIndex);\n    this.context.lineWidth = lineWidth;\n  }\n  #drawRectToCanvas(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getRectBoundingBox(\n      offsetX,\n      offsetY,\n      width,\n      height,\n      contextState\n    );\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyRotationClip(box, contextState);\n\n    const x = -width / 2;\n    const y = -height / 2;\n    this.context.fillRect(x, y, width, height);\n    if (contextState.lineWidth > 0) {\n      this.context.strokeRect(x, y, width, height);\n    }\n    this.#restore();\n  }\n  async drawRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    //console.log(\"drawRect contextState\", contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawRectToCanvas(offsetX, offsetY, width, height, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplayRect(\n        offsetX,\n        offsetY,\n        width,\n        height,\n        sendImmediately\n      );\n    }\n  }\n  #drawRoundRectToCanvas(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getRectBoundingBox(\n      offsetX,\n      offsetY,\n      width,\n      height,\n      contextState\n    );\n\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyRotationClip(box, contextState);\n\n    const x = -width / 2;\n    const y = -height / 2;\n\n    this.context.beginPath();\n    this.context.roundRect(x, y, width, height, borderRadius);\n    this.context.fill();\n    if (contextState.lineWidth > 0) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawRoundRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawRoundRectToCanvas(\n        offsetX,\n        offsetY,\n        width,\n        height,\n        borderRadius,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplayRoundRect(\n        offsetX,\n        offsetY,\n        width,\n        height,\n        borderRadius,\n        sendImmediately\n      );\n    }\n  }\n  #getCircleBoundingBox(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    contextState: DisplayContextState\n  ): DisplayBoundingBox {\n    const diameter = radius * 2;\n    return this.#getRectBoundingBox(\n      offsetX,\n      offsetY,\n      diameter,\n      diameter,\n      contextState\n    );\n  }\n  #drawCircleToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getCircleBoundingBox(\n      offsetX,\n      offsetY,\n      radius,\n      contextState\n    );\n    this.#applyClip(box, contextState);\n\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyRotationClip(box, contextState);\n\n    this.context.beginPath();\n    this.context.arc(0, 0, radius, 0, 2 * Math.PI);\n    this.context.fill();\n    if (contextState.lineWidth) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawCircle(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawCircleToCanvas(offsetX, offsetY, radius, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplayCircle(\n        offsetX,\n        offsetY,\n        radius,\n        sendImmediately\n      );\n    }\n  }\n  #getEllipseBoundingBox(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    contextState: DisplayContextState\n  ): DisplayBoundingBox {\n    const diameterX = radiusX * 2;\n    const diameterY = radiusY * 2;\n    return this.#getRectBoundingBox(\n      offsetX,\n      offsetY,\n      diameterX,\n      diameterY,\n      contextState\n    );\n  }\n  #drawEllipseToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getEllipseBoundingBox(\n      offsetX,\n      offsetY,\n      radiusX,\n      radiusY,\n      contextState\n    );\n\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyRotationClip(box, contextState);\n\n    this.context.beginPath();\n    this.context.ellipse(0, 0, radiusX, radiusY, 0, 0, 2 * Math.PI);\n    this.context.fill();\n    if (contextState.lineWidth > 0) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawEllipseToCanvas(\n        offsetX,\n        offsetY,\n        radiusX,\n        radiusY,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplayEllipse(\n        offsetX,\n        offsetY,\n        radiusX,\n        radiusY,\n        sendImmediately\n      );\n    }\n  }\n  #getPolygonBoundingBox(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    numberOfSides: number,\n    { lineWidth }: DisplayContextState\n  ): DisplayBoundingBox {\n    let outerPadding = Math.ceil(lineWidth / 2);\n    const shapeFactor = 1 / Math.cos(Math.PI / numberOfSides);\n    outerPadding = Math.ceil(outerPadding * shapeFactor);\n\n    const diameter = radius * 2;\n    const boundingBox = {\n      x: offsetX - radius - outerPadding,\n      y: offsetY - radius - outerPadding,\n      width: diameter + outerPadding * 2,\n      height: diameter + outerPadding * 2,\n    };\n    return boundingBox;\n  }\n  #drawPolygonToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    numberOfSides: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getPolygonBoundingBox(\n      offsetX,\n      offsetY,\n      radius,\n      numberOfSides,\n      contextState\n    );\n    this.#applyClip(box, contextState);\n\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyRotationClip(box, contextState);\n\n    this.context.beginPath();\n    const angleStep = (Math.PI * 2) / numberOfSides;\n    for (let i = 0; i < numberOfSides; i++) {\n      const angle = i * angleStep;\n      const x = radius * Math.cos(angle);\n      const y = radius * Math.sin(angle);\n      if (i === 0) {\n        this.context.moveTo(x, y);\n      } else {\n        this.context.lineTo(x, y);\n      }\n    }\n    this.context.closePath();\n\n    this.context.fill();\n    if (contextState.lineWidth > 0) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawPolygon(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    numberOfSides: number,\n    sendImmediately?: boolean\n  ) {\n    if (numberOfSides < 3) {\n      _console.error(`invalid numberOfSides ${numberOfSides}`);\n      return;\n    }\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawPolygonToCanvas(\n        offsetX,\n        offsetY,\n        radius,\n        numberOfSides,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplayPolygon(\n        offsetX,\n        offsetY,\n        radius,\n        numberOfSides,\n        sendImmediately\n      );\n    }\n  }\n  #getSegmentBoundingBox(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    { lineWidth, segmentStartRadius, segmentEndRadius }: DisplayContextState\n  ): DisplayBoundingBox {\n    const outerPadding = Math.ceil(lineWidth / 2);\n    const segmentStartFullRadius = segmentStartRadius + outerPadding;\n    const segmentEndFullRadius = segmentEndRadius + outerPadding;\n    // _console.log({ segmentStartFullRadius, segmentEndFullRadius });\n\n    const minX = Math.min(\n      startX - segmentStartFullRadius,\n      endX - segmentEndFullRadius\n    );\n    const maxX = Math.max(\n      startX + segmentStartFullRadius,\n      endX + segmentEndFullRadius\n    );\n    const minY = Math.min(\n      startY - segmentStartFullRadius,\n      endY - segmentEndFullRadius\n    );\n    const maxY = Math.max(\n      startY + segmentStartFullRadius,\n      endY + segmentEndFullRadius\n    );\n\n    // _console.log(\"segmentBounds\", { minX, minY, maxX, maxY });\n\n    const boundingBox = {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n    // _console.log(\"getSegmentBoundingBox\", boundingBox);\n    return boundingBox;\n  }\n  #getSegmentMidpoint(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    {\n      lineWidth,\n      segmentStartRadius,\n      segmentEndRadius,\n      segmentEndCap,\n      segmentStartCap,\n    }: DisplayContextState\n  ): Vector2 {\n    const outerPadding = Math.ceil(lineWidth / 2);\n    const vector: Vector2 = {\n      x: endX - startX,\n      y: endY - startY,\n    };\n    const segmentStartLength =\n      segmentStartCap == \"round\"\n        ? segmentStartRadius + outerPadding\n        : outerPadding;\n    const segmentEndLength =\n      segmentEndCap == \"round\" ? segmentEndRadius + outerPadding : outerPadding;\n    const unitVector = normalizedVector2(vector);\n\n    const innerStartX = startX - unitVector.x * segmentStartLength;\n    const innerStartY = startY - unitVector.y * segmentStartLength;\n    const innerEndX = endX + unitVector.x * segmentEndLength;\n    const innerEndY = endY + unitVector.y * segmentEndLength;\n\n    const midpoint: Vector2 = {\n      x: (innerStartX + innerEndX) / 2,\n      y: (innerStartY + innerEndY) / 2,\n    };\n    //_console.log(\"midpoint\", midpoint);\n    return midpoint;\n  }\n  #getOrientedSegmentBoundingBox(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    {\n      lineWidth,\n      segmentStartRadius,\n      segmentEndRadius,\n      segmentEndCap,\n      segmentStartCap,\n    }: DisplayContextState\n  ): DisplayBoundingBox {\n    const outerPadding = Math.ceil(lineWidth / 2);\n    const vector: Vector2 = {\n      x: endX - startX,\n      y: endY - startY,\n    };\n    const segmentStartLength =\n      segmentStartCap == \"round\"\n        ? segmentStartRadius + outerPadding\n        : outerPadding;\n    const segmentEndLength =\n      segmentEndCap == \"round\" ? segmentEndRadius + outerPadding : outerPadding;\n    const length =\n      getVector2Length(vector) + segmentStartLength + segmentEndLength;\n    const width =\n      (Math.max(segmentStartRadius, segmentEndRadius) + outerPadding) * 2;\n\n    const boundingBox = {\n      x: -width / 2,\n      y: -length / 2,\n      width: width,\n      height: length,\n    };\n    return boundingBox;\n  }\n  #applySegmentRotationClip(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    contextState: DisplayContextState\n  ) {\n    const vector: Vector2 = {\n      x: endX - startX,\n      y: endY - startY,\n    };\n    let rotation = getVector2Angle(vector);\n    rotation -= Math.PI / 2;\n    // _console.log({ segmentRotation: rotation });\n    const midpoint: Vector2 = this.#getSegmentMidpoint(\n      startX,\n      startY,\n      endX,\n      endY,\n      contextState\n    );\n    this.context.translate(midpoint.x, midpoint.y);\n    this.context.rotate(rotation);\n    const box = this.#getOrientedSegmentBoundingBox(\n      startX,\n      startY,\n      endX,\n      endY,\n      contextState\n    );\n    this.#applyRotationClip(box, contextState);\n    this.context.rotate(-rotation);\n    this.context.translate(-midpoint.x, -midpoint.y);\n  }\n  #drawSegmentToCanvas(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    contextState: DisplayContextState,\n    clearBoundingBox = true\n  ) {\n    this.#updateContext(contextState);\n\n    // _console.log(\"drawSegmentToCanvas\", { startX, startY, endX, endY });\n\n    this.#save();\n    const box = this.#getSegmentBoundingBox(\n      startX,\n      startY,\n      endX,\n      endY,\n      contextState\n    );\n    if (this.#clearBoundingBoxOnDraw && clearBoundingBox) {\n      this.#clearBoundingBox(box, false);\n    }\n\n    this.#applyClip(box, contextState);\n\n    this.#applySegmentRotationClip(startX, startY, endX, endY, contextState);\n\n    const x0 = startX;\n    const x1 = endX;\n    const y0 = startY;\n    const y1 = endY;\n\n    const r0 = contextState.segmentStartRadius;\n    const r1 = contextState.segmentEndRadius;\n\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const len = Math.sqrt(dx * dx + dy * dy);\n    if (len === 0) {\n      this.#restore();\n      return;\n    }\n\n    const ux = dx / len;\n    const uy = dy / len;\n\n    // Perpendicular vector\n    const px = -uy;\n    const py = ux;\n\n    // Start circle edge points\n    const sx1 = x0 + px * r0;\n    const sy1 = y0 + py * r0;\n    const sx2 = x0 - px * r0;\n    const sy2 = y0 - py * r0;\n\n    // End circle edge points\n    const ex1 = x1 + px * r1;\n    const ey1 = y1 + py * r1;\n    const ex2 = x1 - px * r1;\n    const ey2 = y1 - py * r1;\n\n    if (contextState.segmentStartCap == \"round\") {\n      this.context.beginPath();\n      this.context.arc(x0, y0, r0, 0, Math.PI * 2);\n      this.context.closePath();\n      this.context.fill();\n      if (contextState.lineWidth > 0) {\n        this.context.stroke();\n      }\n    }\n    if (contextState.segmentEndCap == \"round\") {\n      this.context.beginPath();\n      this.context.arc(x1, y1, r1, 0, Math.PI * 2);\n      this.context.closePath();\n      this.context.fill();\n      if (contextState.lineWidth > 0) {\n        this.context.stroke();\n      }\n    }\n\n    // full trapezoid\n    this.context.beginPath();\n    this.context.moveTo(sx1, sy1);\n    this.context.lineTo(ex1, ey1);\n    this.context.lineTo(ex2, ey2);\n    this.context.lineTo(sx2, sy2);\n    this.context.closePath();\n    this.context.fill();\n\n    // Stroke only the side edges\n    if (contextState.lineWidth > 0) {\n      this.context.beginPath();\n\n      // Start edge → end edge\n      this.context.moveTo(sx1, sy1);\n      this.context.lineTo(ex1, ey1);\n\n      // End cap (flat or not)\n      if (contextState.segmentEndCap === \"flat\") {\n        this.context.lineTo(ex2, ey2);\n      } else {\n        this.context.moveTo(ex2, ey2);\n      }\n\n      // Back to start side\n      this.context.lineTo(sx2, sy2);\n\n      // If both ends are flat, close the loop\n      if (\n        contextState.segmentStartCap === \"flat\" &&\n        contextState.segmentEndCap === \"flat\"\n      ) {\n        this.context.closePath();\n      }\n      // If only the start is flat, manually return to start to avoid gaps\n      else if (contextState.segmentStartCap === \"flat\") {\n        this.context.lineTo(sx1, sy1);\n        this.context.lineTo(ex1, ey1);\n      }\n\n      this.context.stroke();\n    }\n\n    this.#restore();\n  }\n  async drawSegment(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    sendImmediately?: boolean\n  ) {\n    if (startX == endX && startY == endY) {\n      _console.error(`cannot draw segment of length 0`);\n      return;\n    }\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawSegmentToCanvas(startX, startY, endX, endY, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplaySegment(\n        startX,\n        startY,\n        endX,\n        endY,\n        sendImmediately\n      );\n    }\n  }\n  #drawSegmentsToCanvas(points: Vector2[], contextState: DisplayContextState) {\n    this.#updateContext(contextState);\n\n    // _console.log(\"drawSegmentsToCanvas\", { segments: points });\n\n    points.forEach((segment, index) => {\n      if (index > 0) {\n        const previousPoint = points[index - 1];\n\n        const startX = previousPoint.x;\n        const startY = previousPoint.y;\n        const endX = segment.x;\n        const endY = segment.y;\n\n        const box = this.#getSegmentBoundingBox(\n          startX,\n          startY,\n          endX,\n          endY,\n          contextState\n        );\n        if (this.#clearBoundingBoxOnDraw) {\n          this.#clearBoundingBox(box);\n        }\n      }\n    });\n\n    points.forEach((segment, index) => {\n      if (index > 0) {\n        const previousPoint = points[index - 1];\n\n        const startX = previousPoint.x;\n        const startY = previousPoint.y;\n        const endX = segment.x;\n        const endY = segment.y;\n\n        this.#drawSegmentToCanvas(\n          startX,\n          startY,\n          endX,\n          endY,\n          contextState,\n          false\n        );\n      }\n    });\n  }\n  async drawSegments(points: Vector2[], sendImmediately?: boolean) {\n    _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n    // _console.log({ points });\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawSegmentsToCanvas(points, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplaySegments(points, sendImmediately);\n    }\n  }\n  #drawArcToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians: boolean,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getCircleBoundingBox(\n      offsetX,\n      offsetY,\n      radius,\n      contextState\n    );\n    this.#applyClip(box, contextState);\n\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyRotationClip(box, contextState);\n\n    // Draw the filled pie slice (includes radial lines)\n    this.context.beginPath();\n    this.context.moveTo(0, 0);\n    const clockwise = angleOffset > 0;\n    const endAngle = startAngle + angleOffset;\n\n    this.context.arc(0, 0, radius, startAngle, endAngle, !clockwise);\n    this.context.closePath();\n    this.context.fill();\n\n    // Stroke only the arc part\n    if (contextState.lineWidth) {\n      this.context.beginPath();\n      this.context.arc(0, 0, radius, startAngle, endAngle, !clockwise);\n      this.context.stroke();\n    }\n\n    this.#restore();\n  }\n  async drawArc(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    startAngle = isRadians ? startAngle : degToRad(startAngle);\n    angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawArcToCanvas(\n        offsetX,\n        offsetY,\n        radius,\n        startAngle,\n        angleOffset,\n        true,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplayArc(\n        offsetX,\n        offsetY,\n        radius,\n        startAngle,\n        angleOffset,\n        true,\n        sendImmediately\n      );\n    }\n  }\n  #drawArcEllipseToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians: boolean,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getEllipseBoundingBox(\n      offsetX,\n      offsetY,\n      radiusX,\n      radiusY,\n      contextState\n    );\n\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyRotationClip(box, contextState);\n\n    // draw elliptical pie slice (includes radial lines)\n    this.context.beginPath();\n    this.context.moveTo(0, 0);\n    const clockwise = angleOffset > 0;\n    const endAngle = startAngle + angleOffset;\n\n    this.context.ellipse(\n      0,\n      0,\n      radiusX,\n      radiusY,\n      0,\n      startAngle,\n      endAngle,\n      !clockwise\n    );\n    this.context.closePath();\n    this.context.fill();\n\n    // Stroke only the elliptical arc\n    if (contextState.lineWidth > 0) {\n      this.context.beginPath();\n      this.context.ellipse(\n        0,\n        0,\n        radiusX,\n        radiusY,\n        0,\n        startAngle,\n        endAngle,\n        !clockwise\n      );\n      this.context.stroke();\n    }\n\n    this.#restore();\n  }\n  async drawArcEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    startAngle = isRadians ? startAngle : degToRad(startAngle);\n    angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawArcEllipseToCanvas(\n        offsetX,\n        offsetY,\n        radiusX,\n        radiusY,\n        startAngle,\n        angleOffset,\n        true,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplayArcEllipse(\n        offsetX,\n        offsetY,\n        radiusX,\n        radiusY,\n        startAngle,\n        angleOffset,\n        true,\n        sendImmediately\n      );\n    }\n  }\n\n  #bitmapCanvas = document.createElement(\"canvas\");\n  #bitmapContext!: CanvasRenderingContext2D;\n  async #drawBitmapToCanvas(\n    offsetX: number,\n    offsetY: number,\n    bitmap: DisplayBitmap,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    //_console.log(\"drawBitmapToCanvas\", { offsetX, offsetY, bitmap }, this.#useSpriteColorIndices);\n    //_console.log(\"drawBitmapToCanvas\", this.bitmapColorIndices);\n\n    const { bitmapScaleX, bitmapScaleY } = contextState;\n    const width = bitmap.width * Math.abs(bitmapScaleX);\n    const height = bitmap.height * Math.abs(bitmapScaleY);\n\n    //_console.log({ bitmapScaleX, bitmapScaleY });\n\n    // _console.log({ width, height });\n\n    this.#save();\n    const box = this.#getRectBoundingBox(\n      offsetX,\n      offsetY,\n      width,\n      height,\n      contextState\n    );\n    const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n    this.#applyClip(rotatedBox, contextState);\n\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box);\n    }\n\n    this.#applyRotationClip(box, contextState);\n\n    this.#bitmapCanvas.width = bitmap.width;\n    this.#bitmapCanvas.height = bitmap.height;\n\n    const bitmapImageData = this.#bitmapContext.createImageData(\n      bitmap.width,\n      bitmap.height\n    );\n    const rawBitmapImageData = bitmapImageData.data;\n\n    const x = -width / 2;\n    const y = -height / 2;\n    bitmap.pixels.forEach((pixel, pixelIndex) => {\n      let colorIndex = contextState.bitmapColorIndices[pixel];\n      if (this.#useSpriteColorIndices) {\n        colorIndex = contextState.spriteColorIndices[colorIndex];\n      }\n      const color = hexToRGB(this.colors[colorIndex]);\n      const opacity = this.#getColorOpacity(colorIndex, true);\n\n      const imageDataOffset = pixelIndex * 4;\n\n      rawBitmapImageData[imageDataOffset + 0] = color.r;\n      rawBitmapImageData[imageDataOffset + 1] = color.g;\n      rawBitmapImageData[imageDataOffset + 2] = color.b;\n      rawBitmapImageData[imageDataOffset + 3] = Math.floor(opacity * 255);\n    });\n\n    // _console.log(\"rawBitmapImageData\", rawBitmapImageData);\n\n    this.#bitmapContext.putImageData(bitmapImageData, 0, 0);\n    this.#context.scale(Math.sign(bitmapScaleX), Math.sign(bitmapScaleY));\n    this.#context.drawImage(this.#bitmapCanvas, x, y, width, height);\n\n    this.#restore();\n  }\n\n  assertValidNumberOfColors(numberOfColors: number) {\n    _console.assertRangeWithError(\n      \"numberOfColors\",\n      numberOfColors,\n      2,\n      this.numberOfColors\n    );\n  }\n  assertValidBitmap(bitmap: DisplayBitmap) {\n    this.assertValidNumberOfColors(bitmap.numberOfColors);\n    assertValidBitmapPixels(bitmap);\n  }\n  async drawBitmap(\n    offsetX: number,\n    offsetY: number,\n    bitmap: DisplayBitmap,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidBitmap(bitmap);\n    // _console.log(\"drawBitmap\", { offsetX, offsetY, bitmap, sendImmediately });\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawBitmapToCanvas(offsetX, offsetY, bitmap, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplayBitmap(\n        offsetX,\n        offsetY,\n        bitmap,\n        sendImmediately\n      );\n    }\n  }\n\n  // SPRITES\n  #spriteSheets: Record<string, DisplaySpriteSheet> = {};\n  #spriteSheetIndices: Record<string, number> = {};\n  get spriteSheets() {\n    return this.#spriteSheets;\n  }\n  get spriteSheetIndices() {\n    return this.#spriteSheetIndices;\n  }\n  async uploadSpriteSheet(spriteSheet: DisplaySpriteSheet) {\n    spriteSheet = structuredClone(spriteSheet);\n    if (!this.#spriteSheets[spriteSheet.name]) {\n      this.#spriteSheetIndices[spriteSheet.name] = Object.keys(\n        this.#spriteSheets\n      ).length;\n    }\n    this.#spriteSheets[spriteSheet.name] = spriteSheet;\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.uploadDisplaySpriteSheet(spriteSheet);\n    }\n  }\n  async uploadSpriteSheets(spriteSheets: DisplaySpriteSheet[]) {\n    for (const spriteSheet of spriteSheets) {\n      await this.uploadSpriteSheet(spriteSheet);\n    }\n  }\n  assertLoadedSpriteSheet(spriteSheetName: string) {\n    assertLoadedSpriteSheet(this, spriteSheetName);\n  }\n  assertSelectedSpriteSheet(spriteSheetName: string) {\n    assertSelectedSpriteSheet(this, spriteSheetName);\n  }\n  assertAnySelectedSpriteSheet() {\n    assertAnySelectedSpriteSheet(this);\n  }\n  assertSprite(spriteName: string) {\n    return assertSprite(this, spriteName);\n  }\n  getSprite(spriteName: string): DisplaySprite | undefined {\n    return getSprite(this, spriteName);\n  }\n  getSpriteSheetPalette(\n    paletteName: string\n  ): DisplaySpriteSheetPalette | undefined {\n    return getSpriteSheetPalette(this, paletteName);\n  }\n  getSpriteSheetPaletteSwap(\n    paletteSwapName: string\n  ): DisplaySpriteSheetPaletteSwap | undefined {\n    return getSpriteSheetPaletteSwap(this, paletteSwapName);\n  }\n  getSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string\n  ): DisplaySpritePaletteSwap | undefined {\n    return getSpritePaletteSwap(this, spriteName, paletteSwapName);\n  }\n  get selectedSpriteSheet() {\n    if (this.contextState.spriteSheetName) {\n      return this.#spriteSheets[this.contextState.spriteSheetName];\n    }\n  }\n  get selectedSpriteSheetName() {\n    return this.selectedSpriteSheet?.name;\n  }\n  async selectSpriteSheet(spriteSheetName: string, sendImmediately?: boolean) {\n    this.assertLoadedSpriteSheet(spriteSheetName);\n    const differences = this.#contextStateHelper.update({\n      spriteSheetName,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      this.device.selectDisplaySpriteSheet(spriteSheetName, sendImmediately);\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  #runSpriteCommand(\n    command: DisplayContextCommand,\n    contextState: DisplayContextState\n  ) {\n    _console.log(\"runSpriteCommand\", command);\n    if (command.type == \"drawSprite\") {\n      const spriteSheet = this.spriteSheets[contextState.spriteSheetName!];\n      const sprite = spriteSheet.sprites[command.spriteIndex];\n      if (sprite) {\n        _console.log(\"drawing sub sprite\", sprite);\n        this.#saveContextForSprite(command.offsetX, command.offsetY, sprite);\n        sprite.commands.forEach((command) => {\n          this.#runSpriteCommand(command, contextState);\n        });\n        this.#restoreContextForSprite();\n      } else {\n        _console.error(\n          `sprite index ${command.spriteIndex} not found in spriteSheet`\n        );\n      }\n    } else {\n      this.runContextCommand(command);\n    }\n  }\n  #drawSpriteToCanvas(\n    offsetX: number,\n    offsetY: number,\n    sprite: DisplaySprite,\n    contextState: DisplayContextState\n  ) {\n    this.#setIgnoreDevice(true);\n    this.#setClearCanvasBoundingBoxOnDraw(false);\n    this.#setUseSpriteColorIndices(true);\n    this.#saveContextForSprite(offsetX, offsetY, sprite);\n\n    sprite.commands.forEach((command) => {\n      this.#runSpriteCommand(command, contextState);\n    });\n\n    this.#setIgnoreDevice(false);\n    this.#restoreContextForSprite();\n    this.#setUseSpriteColorIndices(false);\n    this.#setClearCanvasBoundingBoxOnDraw(true);\n  }\n  async drawSprite(\n    offsetX: number,\n    offsetY: number,\n    spriteName: string,\n    sendImmediately?: boolean\n  ) {\n    _console.assertWithError(\n      this.selectedSpriteSheet,\n      \"no spriteSheet selected\"\n    );\n    let sprite = this.selectedSpriteSheet?.sprites.find(\n      (sprite) => sprite.name == spriteName\n    );\n    _console.assertWithError(sprite, `sprite \"${spriteName}\" not found`);\n\n    const contextState = structuredClone(this.contextState);\n    this.#drawSpriteToCanvas(offsetX, offsetY, sprite!, contextState);\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.drawDisplaySprite(\n        offsetX,\n        offsetY,\n        spriteName,\n        sendImmediately\n      );\n    }\n  }\n\n  // BRIGHTNESS\n  #brightness: DisplayBrightness = \"medium\";\n  get brightness() {\n    return this.#brightness;\n  }\n  #brightnessOpacities: Record<DisplayBrightness, number> = {\n    veryLow: 0.5,\n    low: 0.7,\n    medium: 0.9,\n    high: 0.95,\n    veryHigh: 1,\n  };\n  get #brightnessOpacity() {\n    return this.#brightnessOpacities[this.brightness];\n  }\n  async setBrightness(\n    newBrightness: DisplayBrightness,\n    sendImmediately?: boolean\n  ) {\n    if (this.#brightness == newBrightness) {\n      // _console.log(`redundant brightness ${newBrightness}`);\n      return;\n    }\n    this.#brightness = newBrightness;\n    // _console.log({ brightness: this.brightness });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.device.setDisplayBrightness(newBrightness, sendImmediately);\n    }\n    this.#drawFrontDrawStack();\n    this.#dispatchEvent(\"brightness\", { brightness: this.brightness });\n  }\n  async #resetBrightness() {\n    await this.setBrightness(\"medium\");\n  }\n  async #updateDeviceBrightness(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    // _console.log(\"updateDeviceBrightness\");\n    await this.device?.setDisplayBrightness(this.brightness, sendImmediately);\n  }\n  async #updateDeviceSpriteSheets() {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    _console.log(\"updateDeviceSpriteSheets\");\n    await this.uploadSpriteSheets(Object.values(this.spriteSheets));\n  }\n  async #updateDeviceSelectedSpriteSheet(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    if (!this.selectedSpriteSheetName) {\n      return;\n    }\n    _console.log(\"updateDeviceSelectedSpriteSheet\");\n    await this.device?.selectDisplaySpriteSheet(\n      this.selectedSpriteSheetName,\n      sendImmediately\n    );\n  }\n\n  async runContextCommand(\n    command: DisplayContextCommand,\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommand(this, command, sendImmediately);\n  }\n  async runContextCommands(\n    commands: DisplayContextCommand[],\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommands(this, commands, sendImmediately);\n  }\n\n  get #contextScale() {\n    const transform = this.#context.getTransform();\n    const scaleX = transform.a;\n    const scaleY = transform.d;\n    return { x: scaleX, y: scaleY };\n  }\n  #setCanvasContextTransform(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    contextState: DisplayContextState\n  ) {\n    this.#rearDrawStack.push(() => {\n      // _console.log(\"setContextTransform\", {\n      //   offsetX,\n      //   offsetY,\n      //   width,\n      //   height,\n      //   contextState,\n      // });\n\n      this.#save();\n      this.#context.translate(offsetX, offsetY);\n      const box = this.#getBoundingBox(\n        0,\n        0,\n        width * Math.abs(contextState.spriteScaleX),\n        height * Math.abs(contextState.spriteScaleY)\n      );\n      const rotatedBox = this.#rotateBoundingBox(box, contextState.rotation);\n      //_console.log(\"rotatedBox\", rotatedBox);\n      this.#applyClip(rotatedBox, contextState);\n      this.#context.rotate(contextState.rotation);\n      this.#context.scale(contextState.spriteScaleX, contextState.spriteScaleY);\n      // this.#context.beginPath();\n      // this.#context.rect(\n      //   -width / 2 + crop.left,\n      //   -height / 2 + crop.top,\n      //   width - crop.left - crop.right,\n      //   height - crop.top - crop.bottom\n      // );\n      // this.#context.clip();\n\n      // Now define the clip in transformed space\n      this.#context.beginPath();\n      this.#context.rect(\n        -width / 2 +\n          contextState.rotationCropLeft / Math.abs(contextState.spriteScaleX),\n        -height / 2 +\n          contextState.rotationCropTop / Math.abs(contextState.spriteScaleY),\n        width -\n          contextState.rotationCropLeft / Math.abs(contextState.spriteScaleX) -\n          contextState.rotationCropRight / Math.abs(contextState.spriteScaleX),\n        height -\n          contextState.rotationCropTop / Math.abs(contextState.spriteScaleY) -\n          contextState.rotationCropBottom / Math.abs(contextState.spriteScaleY)\n      );\n      this.#context.clip();\n    });\n  }\n  #resetCanvasContextTransform() {\n    this.#rearDrawStack.push(() => {\n      //_console.log(\"reset transform\");\n      this.#restore();\n    });\n  }\n\n  #setClearCanvasBoundingBoxOnDraw(clearBoundingBoxOnDraw: boolean) {\n    this.#rearDrawStack.push(() => {\n      //_console.log({ clearBoundingBoxOnDraw });\n      this.#clearBoundingBoxOnDraw = clearBoundingBoxOnDraw;\n    });\n  }\n  #ignoreDevice = false;\n  #setIgnoreDevice(ignoreDevice: boolean) {\n    this.#ignoreDevice = ignoreDevice;\n    this.#rearDrawStack.push(() => {\n      //_console.log({ ignoreDevice });\n      this.#ignoreDevice = ignoreDevice;\n    });\n  }\n\n  #useSpriteColorIndices = false;\n  #setUseSpriteColorIndices(useSpriteColorIndices: boolean) {\n    this.#rearDrawStack.push(() => {\n      //_console.log({ useSpriteColorIndices });\n      this.#useSpriteColorIndices = useSpriteColorIndices;\n    });\n  }\n  #spriteContextStack: DisplayContextState[] = [];\n  #spriteStack: DisplaySprite[] = [];\n  #saveContextForSprite(\n    offsetX: number,\n    offsetY: number,\n    sprite: DisplaySprite\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#setCanvasContextTransform(\n      offsetX,\n      offsetY,\n      sprite.width,\n      sprite.height,\n      contextState\n    );\n\n    _console.assertWithError(\n      !this.#spriteStack.includes(sprite),\n      `cyclical sprite ${sprite.name} found in stack`\n    );\n\n    const spriteColorIndices = contextState.spriteColorIndices.slice();\n    this.#spriteContextStack.push(contextState);\n    this.#resetContextState();\n    this.contextState.spriteColorIndices = spriteColorIndices;\n    //_console.log(\"_saveContextForSprite\", this.contextState);\n  }\n  #restoreContextForSprite() {\n    this.#resetCanvasContextTransform();\n\n    const contextState = this.#spriteContextStack.pop();\n    if (!contextState) {\n      _console.warn(\"#spriteContextStack empty\");\n      return;\n    }\n    //_console.log(\"_restoreContextForSprite\", contextState);\n    this.#contextStateHelper.update(contextState);\n  }\n\n  #runPreviewSpriteCommand(\n    command: DisplayContextCommand,\n    spriteSheet: DisplaySpriteSheet\n  ) {\n    _console.log(\"runPreviewSpriteCommand\", command);\n    if (command.type == \"drawSprite\") {\n      const sprite = spriteSheet.sprites[command.spriteIndex];\n      if (sprite) {\n        _console.log(\"drawing sub sprite\", sprite);\n        this.#saveContextForSprite(command.offsetX, command.offsetY, sprite);\n        sprite.commands.forEach((command) => {\n          this.#runPreviewSpriteCommand(command, spriteSheet);\n        });\n        this.#restoreContextForSprite();\n      } else {\n        _console.error(\n          `spriteIndex ${command.spriteIndex} not found in spriteSheet`\n        );\n      }\n    } else {\n      this.runContextCommand(command);\n    }\n  }\n  previewSprite(\n    offsetX: number,\n    offsetY: number,\n    sprite: DisplaySprite,\n    spriteSheet: DisplaySpriteSheet\n  ) {\n    this.#setIgnoreDevice(true);\n    this.#setClearCanvasBoundingBoxOnDraw(false);\n    this.#setUseSpriteColorIndices(true);\n    this.#saveContextForSprite(offsetX, offsetY, sprite);\n\n    sprite.commands.forEach((command) => {\n      this.#runPreviewSpriteCommand(command, spriteSheet);\n    });\n\n    this.#setIgnoreDevice(false);\n    this.#restoreContextForSprite();\n    this.#setUseSpriteColorIndices(false);\n    this.#setClearCanvasBoundingBoxOnDraw(true);\n  }\n\n  // SPRITE SHEET PALETTES\n\n  assertSpriteSheetPalette(paletteName: string) {\n    assertSpriteSheetPalette(this, paletteName);\n  }\n  assertSpriteSheetPaletteSwap(paletteSwapName: string) {\n    assertSpriteSheetPaletteSwap(this, paletteSwapName);\n  }\n  assertSpritePaletteSwap(spriteName: string, paletteSwapName: string) {\n    assertSpritePaletteSwap(this, spriteName, paletteSwapName);\n  }\n  async selectSpriteSheetPalette(\n    paletteName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpriteSheetPalette(this, paletteName, offset, sendImmediately);\n  }\n  async selectSpriteSheetPaletteSwap(\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpriteSheetPaletteSwap(\n      this,\n      paletteSwapName,\n      offset,\n      sendImmediately\n    );\n  }\n  async selectSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpritePaletteSwap(\n      this,\n      spriteName,\n      paletteSwapName,\n      offset,\n      sendImmediately\n    );\n  }\n\n  #reset() {\n    this.#useSpriteColorIndices = false;\n    this.#clearBoundingBoxOnDraw = true;\n    this.#ignoreDevice = false;\n    this.#resetColors();\n    this.#resetOpacities();\n    this.#resetContextState();\n    this.#resetBrightness();\n    Object.keys(this.#spriteSheets).forEach(\n      (spriteSheetName) => delete this.#spriteSheets[spriteSheetName]\n    );\n    Object.keys(this.#spriteSheetIndices).forEach(\n      (spriteSheetName) => delete this.#spriteSheetIndices[spriteSheetName]\n    );\n  }\n\n  async imageToBitmap(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors?: number\n  ) {\n    return imageToBitmap(\n      image,\n      width,\n      height,\n      this.colors,\n      this.bitmapColorIndices,\n      numberOfColors\n    );\n  }\n  async quantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number\n  ) {\n    return quantizeImage(image, width, height, numberOfColors);\n  }\n\n  async resizeAndQuantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    colors: string[]\n  ): Promise<{ blob: Blob; colorIndices: number[] }> {\n    return resizeAndQuantizeImage(image, width, height, colors);\n  }\n\n  serializeSpriteSheet(spriteSheet: DisplaySpriteSheet): ArrayBuffer {\n    return serializeSpriteSheet(this, spriteSheet);\n  }\n\n  async fontToSpriteSheet(\n    arrayBuffer: ArrayBuffer,\n    fontSize: number,\n    spriteSheetName?: string\n  ) {\n    // FIX\n    return fontToSpriteSheet(this, arrayBuffer, fontSize, spriteSheetName);\n  }\n}\nexport default DisplayCanvasHelper;\n","import { createConsole } from \"../utils/Console.ts\";\nimport CenterOfPressureHelper from \"../utils/CenterOfPressureHelper.ts\";\nimport {\n  PressureData,\n  PressureSensorPosition,\n  PressureSensorValue,\n} from \"../sensor/PressureSensorDataManager.ts\";\nimport { CenterOfPressure } from \"../utils/CenterOfPressureHelper.ts\";\nimport { Side, Sides } from \"../InformationManager.ts\";\nimport { DeviceEventMap } from \"../Device.ts\";\nimport { RangeHelper } from \"../BS.ts\";\n\nconst _console = createConsole(\"DevicePairPressureSensorDataManager\", {\n  log: false,\n});\n\nexport type DevicePairRawPressureData = { [side in Side]: PressureData };\n\nexport interface DevicePairPressureData {\n  sensors: { [key in Side]: PressureSensorValue[] };\n  scaledSum: number;\n  normalizedSum: number;\n  center?: CenterOfPressure;\n  normalizedCenter?: CenterOfPressure;\n}\n\nexport interface DevicePairPressureDataEventMessage {\n  pressure: DevicePairPressureData;\n}\n\nexport interface DevicePairPressureDataEventMessages {\n  pressure: DevicePairPressureDataEventMessage;\n}\n\nclass DevicePairPressureSensorDataManager {\n  #rawPressure: Partial<DevicePairRawPressureData> = {};\n\n  #centerOfPressureHelper = new CenterOfPressureHelper();\n\n  #normalizedSumRangeHelper = new RangeHelper();\n\n  constructor() {\n    this.resetPressureRange();\n  }\n\n  resetPressureRange() {\n    this.#centerOfPressureHelper.reset();\n    this.#normalizedSumRangeHelper.reset();\n  }\n\n  onDevicePressureData(event: DeviceEventMap[\"pressure\"]) {\n    const { pressure } = event.message;\n    const { side } = event.target;\n    _console.log({ pressure, side });\n    this.#rawPressure[side] = pressure;\n    if (this.#hasAllPressureData) {\n      return this.#updatePressureData();\n    } else {\n      _console.log(\"doesn't have all pressure data yet...\");\n    }\n  }\n\n  get #hasAllPressureData() {\n    return Sides.every((side) => side in this.#rawPressure);\n  }\n\n  #updatePressureData() {\n    const pressure: DevicePairPressureData = {\n      scaledSum: 0,\n      normalizedSum: 0,\n      sensors: { left: [], right: [] },\n    };\n\n    Sides.forEach((side) => {\n      const sidePressure = this.#rawPressure[side]!;\n      pressure.scaledSum += sidePressure.scaledSum;\n      //pressure.normalizedSum += this.#rawPressure[side]!.normalizedSum;\n    });\n    pressure.normalizedSum +=\n      this.#normalizedSumRangeHelper.updateAndGetNormalization(\n        pressure.scaledSum,\n        false\n      );\n\n    if (pressure.scaledSum > 0) {\n      pressure.center = { x: 0, y: 0 };\n      Sides.forEach((side) => {\n        const sidePressure = this.#rawPressure[side]!;\n\n        if (false) {\n          const sidePressureWeight =\n            sidePressure.scaledSum / pressure.scaledSum;\n          if (sidePressureWeight > 0) {\n            if (sidePressure.normalizedCenter?.y != undefined) {\n              pressure.center!.y +=\n                sidePressure.normalizedCenter!.y * sidePressureWeight;\n            }\n            if (side == \"right\") {\n              pressure.center!.x = sidePressureWeight;\n            }\n          }\n        } else {\n          sidePressure.sensors.forEach((sensor) => {\n            const _sensor: PressureSensorValue = structuredClone(sensor);\n            _sensor.weightedValue = sensor.scaledValue / pressure.scaledSum;\n            let { x, y } = sensor.position;\n            x /= 2;\n            if (side == \"right\") {\n              x += 0.5;\n            }\n            _sensor.position = { x, y };\n            pressure.center!.x += _sensor.position.x * _sensor.weightedValue;\n            pressure.center!.y += _sensor.position.y * _sensor.weightedValue;\n            pressure.sensors[side].push(_sensor);\n          });\n        }\n      });\n\n      pressure.normalizedCenter =\n        this.#centerOfPressureHelper.updateAndGetNormalization(\n          pressure.center,\n          false\n        );\n    }\n\n    _console.log({ devicePairPressure: pressure });\n\n    return pressure;\n  }\n}\n\nexport default DevicePairPressureSensorDataManager;\n","import DevicePairPressureSensorDataManager, {\n  DevicePairPressureDataEventMessages,\n} from \"./DevicePairPressureSensorDataManager.ts\";\nimport { createConsole } from \"../utils/Console.ts\";\nimport { Side } from \"../InformationManager.ts\";\nimport { SensorType } from \"../sensor/SensorDataManager.ts\";\nimport { DeviceEventMap } from \"../Device.ts\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\nimport DevicePair from \"./DevicePair.ts\";\nimport { AddKeysAsPropertyToInterface, ExtendInterfaceValues, ValueOf } from \"../utils/TypeScriptUtils.ts\";\n\nconst _console = createConsole(\"DevicePairSensorDataManager\", { log: false });\n\nexport const DevicePairSensorTypes = [\"pressure\", \"sensorData\"] as const;\nexport type DevicePairSensorType = (typeof DevicePairSensorTypes)[number];\n\nexport const DevicePairSensorDataEventTypes = DevicePairSensorTypes;\nexport type DevicePairSensorDataEventType = (typeof DevicePairSensorDataEventTypes)[number];\n\nexport type DevicePairSensorDataTimestamps = { [side in Side]: number };\n\ninterface BaseDevicePairSensorDataEventMessage {\n  timestamps: DevicePairSensorDataTimestamps;\n}\n\ntype BaseDevicePairSensorDataEventMessages = DevicePairPressureDataEventMessages;\ntype _DevicePairSensorDataEventMessages = ExtendInterfaceValues<\n  AddKeysAsPropertyToInterface<BaseDevicePairSensorDataEventMessages, \"sensorType\">,\n  BaseDevicePairSensorDataEventMessage\n>;\n\nexport type DevicePairSensorDataEventMessage = ValueOf<_DevicePairSensorDataEventMessages>;\ninterface AnyDevicePairSensorDataEventMessages {\n  sensorData: DevicePairSensorDataEventMessage;\n}\nexport type DevicePairSensorDataEventMessages = _DevicePairSensorDataEventMessages &\n  AnyDevicePairSensorDataEventMessages;\n\nexport type DevicePairSensorDataEventDispatcher = EventDispatcher<\n  DevicePair,\n  DevicePairSensorDataEventType,\n  DevicePairSensorDataEventMessages\n>;\n\nclass DevicePairSensorDataManager {\n  eventDispatcher!: DevicePairSensorDataEventDispatcher;\n  get dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  #timestamps: { [sensorType in SensorType]?: Partial<DevicePairSensorDataTimestamps> } = {};\n\n  pressureSensorDataManager = new DevicePairPressureSensorDataManager();\n  resetPressureRange() {\n    this.pressureSensorDataManager.resetPressureRange();\n  }\n\n  onDeviceSensorData(event: DeviceEventMap[\"sensorData\"]) {\n    const { timestamp, sensorType } = event.message;\n\n    _console.log({ sensorType, timestamp, event });\n\n    if (!this.#timestamps[sensorType]) {\n      this.#timestamps[sensorType] = {};\n    }\n    this.#timestamps[sensorType]![event.target.side] = timestamp;\n\n    let value;\n    switch (sensorType) {\n      case \"pressure\":\n        value = this.pressureSensorDataManager.onDevicePressureData(event as unknown as DeviceEventMap[\"pressure\"]);\n        break;\n      default:\n        _console.log(`uncaught sensorType \"${sensorType}\"`);\n        break;\n    }\n\n    if (value) {\n      const timestamps = Object.assign({}, this.#timestamps[sensorType]) as DevicePairSensorDataTimestamps;\n      // @ts-expect-error\n      this.dispatchEvent(sensorType as DevicePairSensorDataEventType, { sensorType, timestamps, [sensorType]: value });\n      // @ts-expect-error\n      this.dispatchEvent(\"sensorData\", { sensorType, timestamps, [sensorType]: value });\n    } else {\n      _console.log(\"no value received\");\n    }\n  }\n}\n\nexport default DevicePairSensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"../utils/EventDispatcher.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../utils/EventUtils.ts\";\nimport Device, {\n  DeviceEvent,\n  DeviceEventType,\n  DeviceEventMessages,\n  DeviceEventTypes,\n  BoundDeviceEventListeners,\n  DeviceEventMap,\n} from \"../Device.ts\";\nimport DevicePairSensorDataManager, {\n  DevicePairSensorDataEventDispatcher,\n} from \"./DevicePairSensorDataManager.ts\";\nimport { capitalizeFirstCharacter } from \"../utils/stringUtils.ts\";\nimport { Side, Sides } from \"../InformationManager.ts\";\nimport { VibrationConfiguration } from \"../vibration/VibrationManager.ts\";\nimport { SensorConfiguration } from \"../sensor/SensorConfigurationManager.ts\";\nimport {\n  DevicePairSensorDataEventMessages,\n  DevicePairSensorDataEventTypes,\n} from \"./DevicePairSensorDataManager.ts\";\nimport {\n  AddPrefixToInterfaceKeys,\n  ExtendInterfaceValues,\n  KeyOf,\n} from \"../utils/TypeScriptUtils.ts\";\nimport DeviceManager from \"../DeviceManager.ts\";\n\nconst _console = createConsole(\"DevicePair\", { log: false });\n\ninterface BaseDevicePairDeviceEventMessage {\n  device: Device;\n  side: Side;\n}\ntype DevicePairDeviceEventMessages = ExtendInterfaceValues<\n  AddPrefixToInterfaceKeys<DeviceEventMessages, \"device\">,\n  BaseDevicePairDeviceEventMessage\n>;\ntype DevicePairDeviceEventType = KeyOf<DevicePairDeviceEventMessages>;\nfunction getDevicePairDeviceEventType(deviceEventType: DeviceEventType) {\n  return `device${capitalizeFirstCharacter(\n    deviceEventType\n  )}` as DevicePairDeviceEventType;\n}\nconst DevicePairDeviceEventTypes = DeviceEventTypes.map((eventType) =>\n  getDevicePairDeviceEventType(eventType)\n) as DevicePairDeviceEventType[];\n\nexport const DevicePairConnectionEventTypes = [\"isConnected\"] as const;\nexport type DevicePairConnectionEventType =\n  (typeof DevicePairConnectionEventTypes)[number];\n\nexport interface DevicePairConnectionEventMessages {\n  isConnected: { isConnected: boolean };\n}\n\nexport const DevicePairEventTypes = [\n  ...DevicePairConnectionEventTypes,\n  ...DevicePairSensorDataEventTypes,\n  ...DevicePairDeviceEventTypes,\n] as const;\nexport type DevicePairEventType = (typeof DevicePairEventTypes)[number];\n\nexport type DevicePairEventMessages = DevicePairConnectionEventMessages &\n  DevicePairSensorDataEventMessages &\n  DevicePairDeviceEventMessages;\n\nexport type DevicePairEventDispatcher = EventDispatcher<\n  DevicePair,\n  DevicePairEventType,\n  DevicePairEventMessages\n>;\nexport type DevicePairEventMap = EventMap<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\nexport type DevicePairEventListenerMap = EventListenerMap<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\nexport type DevicePairEvent = Event<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\nexport type BoundDevicePairEventListeners = BoundEventListeners<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\n\nexport const DevicePairTypes = [\"insoles\", \"gloves\"] as const;\nexport type DevicePairType = (typeof DevicePairTypes)[number];\n\nclass DevicePair {\n  constructor(type: DevicePairType) {\n    this.#type = type;\n    this.#sensorDataManager.eventDispatcher = this\n      .#eventDispatcher as DevicePairSensorDataEventDispatcher;\n  }\n\n  get sides() {\n    return Sides;\n  }\n\n  #type: DevicePairType;\n  get type() {\n    return this.#type;\n  }\n\n  #eventDispatcher: DevicePairEventDispatcher = new EventDispatcher(\n    this as DevicePair,\n    DevicePairEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // SIDES\n  #left?: Device;\n  get left() {\n    return this.#left;\n  }\n\n  #right?: Device;\n  get right() {\n    return this.#right;\n  }\n\n  get isConnected() {\n    return Sides.every((side) => this[side]?.isConnected);\n  }\n  get isPartiallyConnected() {\n    return Sides.some((side) => this[side]?.isConnected);\n  }\n  get isHalfConnected() {\n    return this.isPartiallyConnected && !this.isConnected;\n  }\n  #assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"devicePair must be connected\");\n  }\n\n  #isDeviceCorrectType(device: Device) {\n    switch (this.type) {\n      case \"insoles\":\n        return device.isInsole;\n      case \"gloves\":\n        return device.isGlove;\n    }\n  }\n\n  assignDevice(device: Device) {\n    if (!this.#isDeviceCorrectType(device)) {\n      _console.log(\n        `device is incorrect type ${device.type} for ${this.type} devicePair`\n      );\n      return;\n    }\n    const side = device.side;\n\n    const currentDevice = this[side];\n\n    if (device == currentDevice) {\n      _console.log(\"device already assigned\");\n      return;\n    }\n\n    if (currentDevice) {\n      this.#removeDeviceEventListeners(currentDevice);\n    }\n    this.#addDeviceEventListeners(device);\n\n    switch (side) {\n      case \"left\":\n        this.#left = device;\n        break;\n      case \"right\":\n        this.#right = device;\n        break;\n    }\n\n    _console.log(`assigned ${side} ${this.type} device`, device);\n\n    this.resetPressureRange();\n\n    this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    this.#dispatchEvent(\"deviceIsConnected\", {\n      device,\n      isConnected: device.isConnected,\n      side,\n    });\n\n    return currentDevice;\n  }\n\n  #addDeviceEventListeners(device: Device) {\n    addEventListeners(device, this.#boundDeviceEventListeners);\n    DeviceEventTypes.forEach((deviceEventType) => {\n      device.addEventListener(\n        // @ts-expect-error\n        deviceEventType,\n        this.#redispatchDeviceEvent.bind(this)\n      );\n    });\n  }\n  #removeDeviceEventListeners(device: Device) {\n    removeEventListeners(device, this.#boundDeviceEventListeners);\n    DeviceEventTypes.forEach((deviceEventType) => {\n      device.removeEventListener(\n        // @ts-expect-error\n        deviceEventType,\n        this.#redispatchDeviceEvent.bind(this)\n      );\n    });\n  }\n\n  #removeDevice(device: Device) {\n    const foundDevice = Sides.some((side) => {\n      if (this[side] != device) {\n        return false;\n      }\n\n      _console.log(`removing ${side} ${this.type} device`, device);\n      removeEventListeners(device, this.#boundDeviceEventListeners);\n\n      switch (side) {\n        case \"left\":\n          this.#left = undefined;\n          break;\n        case \"right\":\n          this.#right = undefined;\n          break;\n      }\n\n      return true;\n    });\n    if (foundDevice) {\n      this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    }\n    return foundDevice;\n  }\n\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    isConnected: this.#onDeviceIsConnected.bind(this),\n    sensorData: this.#onDeviceSensorData.bind(this),\n    getType: this.#onDeviceType.bind(this),\n  };\n\n  #redispatchDeviceEvent(deviceEvent: DeviceEvent) {\n    const { type, target: device, message } = deviceEvent;\n    this.#dispatchEvent(getDevicePairDeviceEventType(type), {\n      ...message,\n      device,\n      side: device.side,\n    });\n  }\n\n  #onDeviceIsConnected(deviceEvent: DeviceEventMap[\"isConnected\"]) {\n    this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n  }\n\n  #onDeviceType(deviceEvent: DeviceEventMap[\"getType\"]) {\n    const { target: device } = deviceEvent;\n    if (this[device.side] == device) {\n      return;\n    }\n    const foundDevice = this.#removeDevice(device);\n    if (!foundDevice) {\n      return;\n    }\n    this.assignDevice(device);\n  }\n\n  // SENSOR CONFIGURATION\n  async setSensorConfiguration(sensorConfiguration: SensorConfiguration) {\n    for (let i = 0; i < Sides.length; i++) {\n      const side = Sides[i];\n      if (this[side]?.isConnected) {\n        await this[side].setSensorConfiguration(sensorConfiguration);\n      }\n    }\n  }\n\n  // SENSOR DATA\n  #sensorDataManager = new DevicePairSensorDataManager();\n  #onDeviceSensorData(deviceEvent: DeviceEventMap[\"sensorData\"]) {\n    if (this.isConnected) {\n      this.#sensorDataManager.onDeviceSensorData(deviceEvent);\n    }\n  }\n  resetPressureRange() {\n    Sides.forEach((side) => this[side]?.resetPressureRange());\n    this.#sensorDataManager.resetPressureRange();\n  }\n\n  // VIBRATION\n  async triggerVibration(\n    vibrationConfigurations: VibrationConfiguration[],\n    sendImmediately?: boolean\n  ) {\n    const promises = Sides.map((side) => {\n      return this[side]?.triggerVibration(\n        vibrationConfigurations,\n        sendImmediately\n      );\n    }).filter(Boolean);\n    return Promise.allSettled(promises);\n  }\n\n  // SHARED INSTANCES\n  static #insoles = new DevicePair(\"insoles\");\n  static get insoles() {\n    return this.#insoles;\n  }\n  static #gloves = new DevicePair(\"gloves\");\n  static get gloves() {\n    return this.#gloves;\n  }\n  static {\n    DeviceManager.AddEventListener(\"deviceConnected\", (event) => {\n      const { device } = event.message;\n      if (device.isInsole) {\n        this.#insoles.assignDevice(device);\n      }\n      if (device.isGlove) {\n        this.#gloves.assignDevice(device);\n      }\n    });\n  }\n}\n\nexport default DevicePair;\n","export function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  interval: number,\n  trailing = false\n): (...args: Parameters<T>) => void {\n  let lastTime = 0;\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let lastArgs: Parameters<T> | null = null;\n\n  return function (...args: Parameters<T>) {\n    const now = Date.now();\n    const remaining = interval - (now - lastTime);\n\n    if (remaining <= 0) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      lastTime = now;\n      fn(...args);\n    } else if (trailing) {\n      lastArgs = args;\n      if (!timeout) {\n        timeout = setTimeout(() => {\n          lastTime = Date.now();\n          timeout = null;\n          if (lastArgs) {\n            fn(...lastArgs);\n            lastArgs = null;\n          }\n        }, remaining);\n      }\n    }\n  };\n}\n\nexport function debounce<T extends (...args: any[]) => void>(\n  fn: T,\n  interval: number,\n  callImmediately = false\n): (...args: Parameters<T>) => void {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n\n  return function (...args: Parameters<T>) {\n    const callNow = callImmediately && !timeout;\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (!callImmediately) {\n        fn(...args);\n      }\n    }, interval);\n\n    if (callNow) {\n      fn(...args);\n    }\n  };\n}\n","import { createConsole } from \"../utils/Console.ts\";\nimport { isInBrowser } from \"../utils/environment.ts\";\nimport BaseConnectionManager, {\n  ConnectionType,\n  ConnectionMessageType,\n  ClientConnectionType,\n} from \"./BaseConnectionManager.ts\";\nimport { DeviceEventTypes } from \"../Device.ts\";\nimport { parseMessage } from \"../utils/ParseUtils.ts\";\nimport { DeviceInformationTypes } from \"../DeviceInformationManager.ts\";\nimport { DeviceEventType } from \"../Device.ts\";\nimport { ClientDeviceMessage } from \"../server/ServerUtils.ts\";\nimport BaseClient from \"../server/BaseClient.ts\";\nimport { DiscoveredDevice } from \"../BS.ts\";\n\nconst _console = createConsole(\"ClientConnectionManager\", { log: false });\n\nexport type SendClientMessageCallback = (\n  ...messages: ClientDeviceMessage[]\n) => void;\n\nexport type SendClientConnectMessageCallback = (\n  connectionType?: ClientConnectionType\n) => void;\n\nconst ClientDeviceInformationMessageTypes: ConnectionMessageType[] = [\n  ...DeviceInformationTypes,\n  \"batteryLevel\",\n];\n\nclass ClientConnectionManager extends BaseConnectionManager {\n  static get isSupported() {\n    return isInBrowser;\n  }\n  static get type(): ConnectionType {\n    return \"client\";\n  }\n\n  subType?: ClientConnectionType;\n\n  get canUpdateFirmware() {\n    // FIX - how to know if it has an smp characteristic?\n    return false;\n  }\n\n  client!: BaseClient;\n  discoveredDevice!: DiscoveredDevice;\n\n  #bluetoothId!: string;\n  get bluetoothId() {\n    return this.#bluetoothId!;\n  }\n  set bluetoothId(newBluetoothId) {\n    _console.assertTypeWithError(newBluetoothId, \"string\");\n    if (this.#bluetoothId == newBluetoothId) {\n      _console.log(\"redundant bluetoothId assignment\");\n      return;\n    }\n    this.#bluetoothId = newBluetoothId;\n  }\n\n  #isConnected = false;\n  get isConnected() {\n    return this.#isConnected;\n  }\n  set isConnected(newIsConnected) {\n    _console.assertTypeWithError(newIsConnected, \"boolean\");\n    if (this.#isConnected == newIsConnected) {\n      _console.log(\"redundant newIsConnected assignment\", newIsConnected);\n      return;\n    }\n    this.#isConnected = newIsConnected;\n\n    this.status = this.#isConnected ? \"connected\" : \"notConnected\";\n\n    if (this.isConnected) {\n      this.#requestDeviceInformation();\n    }\n  }\n\n  get isAvailable() {\n    return this.client.isConnected;\n  }\n\n  async connect() {\n    await super.connect();\n    this.sendClientConnectMessage(this.subType);\n  }\n  async disconnect() {\n    await super.disconnect();\n    this.sendClientDisconnectMessage();\n  }\n\n  get canReconnect() {\n    return true;\n  }\n  async reconnect() {\n    await super.reconnect();\n    this.sendClientConnectMessage();\n  }\n\n  sendClientMessage!: SendClientMessageCallback;\n  sendClientConnectMessage!: SendClientConnectMessageCallback;\n  sendClientDisconnectMessage!: Function;\n  sendRequiredDeviceInformationMessage!: Function;\n\n  async sendSmpMessage(data: ArrayBuffer) {\n    super.sendSmpMessage(data);\n    this.sendClientMessage({ type: \"smp\", data });\n  }\n\n  async sendTxData(data: ArrayBuffer) {\n    super.sendTxData(data);\n    if (data.byteLength == 0) {\n      return;\n    }\n    this.sendClientMessage({ type: \"tx\", data });\n  }\n\n  #requestDeviceInformation() {\n    //this.sendClientMessage(...ClientDeviceInformationMessageTypes);\n    this.sendRequiredDeviceInformationMessage();\n  }\n\n  onClientMessage(dataView: DataView) {\n    _console.log({ dataView });\n    parseMessage(\n      dataView,\n      DeviceEventTypes,\n      this.#onClientMessageCallback.bind(this),\n      null,\n      true\n    );\n    this.onMessagesReceived!();\n  }\n\n  #onClientMessageCallback(messageType: DeviceEventType, dataView: DataView) {\n    let byteOffset = 0;\n\n    _console.log({ messageType }, dataView);\n\n    switch (messageType) {\n      case \"isConnected\":\n        const isConnected = Boolean(dataView.getUint8(byteOffset++));\n        _console.log({ isConnected });\n        this.isConnected = isConnected;\n        break;\n\n      case \"rx\":\n        this.parseRxMessage(dataView);\n        break;\n\n      default:\n        this.onMessageReceived!(messageType as ConnectionMessageType, dataView);\n        break;\n    }\n  }\n}\n\nexport default ClientConnectionManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport {\n  ServerMessageTypes,\n  discoveredDevicesMessage,\n  ServerMessage,\n  MessageLike,\n  ClientDeviceMessage,\n  createClientDeviceMessage,\n  ServerMessageType,\n} from \"./ServerUtils.ts\";\nimport { parseMessage, parseStringFromDataView } from \"../utils/ParseUtils.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n} from \"../utils/EventDispatcher.ts\";\nimport Device from \"../Device.ts\";\nimport {\n  concatenateArrayBuffers,\n  sliceDataView,\n  stringToArrayBuffer,\n} from \"../utils/ArrayBufferUtils.ts\";\nimport {\n  DiscoveredDevice,\n  DiscoveredDevicesMap,\n  ScannerEventMessages,\n} from \"../scanner/BaseScanner.ts\";\nimport ClientConnectionManager from \"../connection/ClientConnectionManager.ts\";\nimport { DeviceManager } from \"../BS.ts\";\nimport {\n  ClientConnectionType,\n  ConnectionTypes,\n} from \"../connection/BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"BaseClient\", { log: false });\n\nexport const ClientConnectionStatuses = [\n  \"notConnected\",\n  \"connecting\",\n  \"connected\",\n  \"disconnecting\",\n] as const;\nexport type ClientConnectionStatus = (typeof ClientConnectionStatuses)[number];\n\nexport const ClientEventTypes = [\n  ...ClientConnectionStatuses,\n  \"connectionStatus\",\n  \"isConnected\",\n  \"isScanningAvailable\",\n  \"isScanning\",\n  \"discoveredDevice\",\n  \"expiredDiscoveredDevice\",\n] as const;\nexport type ClientEventType = (typeof ClientEventTypes)[number];\n\ninterface ClientConnectionEventMessages {\n  connectionStatus: { connectionStatus: ClientConnectionStatus };\n  isConnected: { isConnected: boolean };\n}\n\nexport type ClientEventMessages = ClientConnectionEventMessages &\n  ScannerEventMessages;\n\nexport type ClientEventDispatcher = EventDispatcher<\n  BaseClient,\n  ClientEventType,\n  ClientEventMessages\n>;\nexport type ClientEvent = Event<\n  BaseClient,\n  ClientEventType,\n  ClientEventMessages\n>;\nexport type BoundClientEventListeners = BoundEventListeners<\n  BaseClient,\n  ClientEventType,\n  ClientEventMessages\n>;\n\nexport type ServerURL = string | URL;\n\ntype DevicesMap = { [deviceId: string]: Device };\n\nabstract class BaseClient {\n  protected get baseConstructor() {\n    return this.constructor as typeof BaseClient;\n  }\n\n  #reset() {\n    this.#isScanningAvailable = false;\n    this.#isScanning = false;\n    for (const id in this.#devices) {\n      const device = this.#devices[id];\n      const connectionManager =\n        device.connectionManager! as ClientConnectionManager;\n      connectionManager.isConnected = false;\n      //device.removeAllEventListeners();\n    }\n    this.#receivedMessageTypes.length = 0;\n    //this.#devices = {};\n  }\n\n  // DEVICES\n  #devices: DevicesMap = {};\n  get devices(): Readonly<DevicesMap> {\n    return this.#devices;\n  }\n\n  #eventDispatcher: ClientEventDispatcher = new EventDispatcher(\n    this as BaseClient,\n    ClientEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  protected get dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n\n  abstract isConnected: boolean;\n  protected assertConnection() {\n    _console.assertWithError(this.isConnected, \"notConnected\");\n  }\n\n  abstract isDisconnected: boolean;\n  protected assertDisconnection() {\n    _console.assertWithError(this.isDisconnected, \"not disconnected\");\n  }\n\n  abstract connect(): void;\n  abstract disconnect(): void;\n  abstract reconnect(): void;\n  abstract toggleConnection(url?: ServerURL): void;\n\n  static _reconnectOnDisconnection = true;\n  static get ReconnectOnDisconnection() {\n    return this._reconnectOnDisconnection;\n  }\n  static set ReconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this._reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  protected _reconnectOnDisconnection =\n    this.baseConstructor.ReconnectOnDisconnection;\n  get reconnectOnDisconnection() {\n    return this._reconnectOnDisconnection;\n  }\n  set reconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this._reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  abstract sendServerMessage(...messages: ServerMessage[]): void;\n\n  // CONNECTION STATUS\n  #_connectionStatus: ClientConnectionStatus = \"notConnected\";\n  protected get _connectionStatus() {\n    return this.#_connectionStatus;\n  }\n  protected set _connectionStatus(newConnectionStatus) {\n    _console.assertTypeWithError(newConnectionStatus, \"string\");\n    _console.log({ newConnectionStatus });\n    this.#_connectionStatus = newConnectionStatus;\n\n    this.dispatchEvent(\"connectionStatus\", {\n      connectionStatus: this.connectionStatus,\n    });\n    this.dispatchEvent(this.connectionStatus, {});\n\n    switch (newConnectionStatus) {\n      case \"connected\":\n      case \"notConnected\":\n        this.dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n        if (this.isConnected) {\n          // this._sendRequiredMessages();\n        } else {\n          this.#reset();\n        }\n        break;\n    }\n  }\n  get connectionStatus() {\n    return this._connectionStatus;\n  }\n\n  static #RequiredMessageTypes: ServerMessage[] = [\n    \"isScanningAvailable\",\n    \"discoveredDevices\",\n    \"connectedDevices\",\n  ];\n  get #requiredMessageTypes(): ServerMessage[] {\n    return BaseClient.#RequiredMessageTypes;\n  }\n  protected _sendRequiredMessages() {\n    _console.log(\"sending required messages\", this.#receivedMessageTypes);\n    this.sendServerMessage(...this.#requiredMessageTypes);\n  }\n\n  #receivedMessageTypes: ServerMessage[] = [];\n  #checkIfFullyConnected() {\n    if (this.connectionStatus != \"connecting\") {\n      return;\n    }\n    _console.log(\"checking if fully connected...\");\n\n    if (!this.#receivedMessageTypes.includes(\"isScanningAvailable\")) {\n      _console.log(\"not fully connected - didn't receive isScanningAvailable\");\n      return;\n    }\n\n    if (this.isScanningAvailable) {\n      if (!this.#receivedMessageTypes.includes(\"isScanning\")) {\n        _console.log(\"not fully connected - didn't receive isScanning\");\n        return;\n      }\n    }\n\n    _console.log(\"fully connected\");\n    this._connectionStatus = \"connected\";\n  }\n\n  protected parseMessage(dataView: DataView) {\n    _console.log(\"parseMessage\", { dataView });\n    parseMessage(\n      dataView,\n      ServerMessageTypes,\n      this.#parseMessageCallback.bind(this),\n      null,\n      true\n    );\n    this.#checkIfFullyConnected();\n  }\n\n  #parseMessageCallback(messageType: ServerMessageType, dataView: DataView) {\n    let byteOffset = 0;\n\n    _console.log({ messageType }, dataView);\n\n    switch (messageType) {\n      case \"isScanningAvailable\":\n        {\n          const isScanningAvailable = Boolean(dataView.getUint8(byteOffset++));\n          _console.log({ isScanningAvailable });\n          this.#isScanningAvailable = isScanningAvailable;\n        }\n        break;\n      case \"isScanning\":\n        {\n          const isScanning = Boolean(dataView.getUint8(byteOffset++));\n          _console.log({ isScanning });\n          this.#isScanning = isScanning;\n        }\n        break;\n      case \"discoveredDevice\":\n        {\n          const { string: discoveredDeviceString } = parseStringFromDataView(\n            dataView,\n            byteOffset\n          );\n          _console.log({ discoveredDeviceString });\n\n          const discoveredDevice: DiscoveredDevice = JSON.parse(\n            discoveredDeviceString\n          );\n          _console.log({ discoveredDevice });\n\n          this.onDiscoveredDevice(discoveredDevice);\n        }\n        break;\n      case \"expiredDiscoveredDevice\":\n        {\n          const { string: bluetoothId } = parseStringFromDataView(\n            dataView,\n            byteOffset\n          );\n          this.#onExpiredDiscoveredDevice(bluetoothId);\n        }\n        break;\n      case \"connectedDevices\":\n        {\n          if (dataView.byteLength == 0) {\n            break;\n          }\n          const { string: connectedBluetoothDeviceIdStrings } =\n            parseStringFromDataView(dataView, byteOffset);\n          _console.log({ connectedBluetoothDeviceIdStrings });\n          const connectedBluetoothDeviceIds = JSON.parse(\n            connectedBluetoothDeviceIdStrings\n          ).connectedDevices;\n          _console.log({ connectedBluetoothDeviceIds });\n          this.onConnectedBluetoothDeviceIds(connectedBluetoothDeviceIds);\n        }\n        break;\n      case \"deviceMessage\":\n        {\n          const { string: bluetoothId, byteOffset: _byteOffset } =\n            parseStringFromDataView(dataView, byteOffset);\n          byteOffset = _byteOffset;\n          const device = this.#devices[bluetoothId];\n          _console.assertWithError(\n            device,\n            `no device found for id ${bluetoothId}`\n          );\n          const connectionManager =\n            device.connectionManager! as ClientConnectionManager;\n          const _dataView = sliceDataView(dataView, byteOffset);\n          connectionManager.onClientMessage(_dataView);\n        }\n        break;\n      default:\n        _console.error(`uncaught messageType \"${messageType}\"`);\n        break;\n    }\n\n    if (this.connectionStatus == \"connecting\") {\n      this.#receivedMessageTypes.push(messageType);\n    }\n  }\n\n  // SCANNING\n  #_isScanningAvailable = false;\n  get #isScanningAvailable() {\n    return this.#_isScanningAvailable;\n  }\n  set #isScanningAvailable(newIsAvailable) {\n    _console.assertTypeWithError(newIsAvailable, \"boolean\");\n    this.#_isScanningAvailable = newIsAvailable;\n    this.dispatchEvent(\"isScanningAvailable\", {\n      isScanningAvailable: this.isScanningAvailable,\n    });\n    if (this.isScanningAvailable) {\n      this.#requestIsScanning();\n    }\n  }\n  get isScanningAvailable() {\n    return this.#isScanningAvailable;\n  }\n  #assertIsScanningAvailable() {\n    this.assertConnection();\n    _console.assertWithError(\n      this.isScanningAvailable,\n      \"scanning is not available\"\n    );\n  }\n  protected requestIsScanningAvailable() {\n    this.sendServerMessage(\"isScanningAvailable\");\n  }\n\n  #_isScanning = false;\n  get #isScanning() {\n    return this.#_isScanning;\n  }\n  set #isScanning(newIsScanning) {\n    _console.assertTypeWithError(newIsScanning, \"boolean\");\n    this.#_isScanning = newIsScanning;\n    this.dispatchEvent(\"isScanning\", { isScanning: this.isScanning });\n  }\n  get isScanning() {\n    return this.#isScanning;\n  }\n  #requestIsScanning() {\n    this.sendServerMessage(\"isScanning\");\n  }\n\n  #assertIsScanning() {\n    _console.assertWithError(this.isScanning, \"is not scanning\");\n  }\n  #assertIsNotScanning() {\n    _console.assertWithError(!this.isScanning, \"is already scanning\");\n  }\n\n  startScan() {\n    this.#assertIsNotScanning();\n    this.sendServerMessage(\"startScan\");\n  }\n  stopScan() {\n    this.#assertIsScanning();\n    this.sendServerMessage(\"stopScan\");\n  }\n  toggleScan() {\n    this.#assertIsScanningAvailable();\n\n    if (this.isScanning) {\n      this.stopScan();\n    } else {\n      this.startScan();\n    }\n  }\n\n  // PERIPHERALS\n  #discoveredDevices: DiscoveredDevicesMap = {};\n  get discoveredDevices(): Readonly<DiscoveredDevicesMap> {\n    return this.#discoveredDevices;\n  }\n\n  protected onDiscoveredDevice(discoveredDevice: DiscoveredDevice) {\n    _console.log({ discoveredDevice });\n    this.#discoveredDevices[discoveredDevice.bluetoothId] = discoveredDevice;\n    this.dispatchEvent(\"discoveredDevice\", { discoveredDevice });\n  }\n  requestDiscoveredDevices() {\n    this.sendServerMessage({ type: \"discoveredDevices\" });\n  }\n  #onExpiredDiscoveredDevice(bluetoothId: string) {\n    _console.log({ expiredBluetoothDeviceId: bluetoothId });\n    const discoveredDevice = this.#discoveredDevices[bluetoothId];\n    if (!discoveredDevice) {\n      _console.warn(`no discoveredDevice found with id \"${bluetoothId}\"`);\n      return;\n    }\n    _console.log({ expiredDiscoveredDevice: discoveredDevice });\n    delete this.#discoveredDevices[bluetoothId];\n    this.dispatchEvent(\"expiredDiscoveredDevice\", { discoveredDevice });\n  }\n\n  // DEVICE CONNECTION\n  connectToDevice(bluetoothId: string, connectionType?: ClientConnectionType) {\n    return this.requestConnectionToDevice(bluetoothId, connectionType);\n  }\n  protected requestConnectionToDevice(\n    bluetoothId: string,\n    connectionType?: ClientConnectionType\n  ) {\n    this.assertConnection();\n    _console.assertTypeWithError(bluetoothId, \"string\");\n    const device = this.#getOrCreateDevice(bluetoothId);\n    if (connectionType) {\n      device.connect({ type: \"client\", subType: connectionType });\n    } else {\n      device.connect();\n    }\n    return device;\n  }\n  protected sendConnectToDeviceMessage(\n    bluetoothId: string,\n    connectionType?: ClientConnectionType\n  ) {\n    if (connectionType) {\n      this.sendServerMessage({\n        type: \"connectToDevice\",\n        data: concatenateArrayBuffers(\n          stringToArrayBuffer(bluetoothId),\n          ConnectionTypes.indexOf(connectionType)\n        ),\n      });\n    } else {\n      this.sendServerMessage({ type: \"connectToDevice\", data: bluetoothId });\n    }\n  }\n\n  // DEVICE CONNECTION\n  createDevice(bluetoothId: string) {\n    const device = new Device();\n    const discoveredDevice = this.#discoveredDevices[bluetoothId];\n    const clientConnectionManager = new ClientConnectionManager();\n    clientConnectionManager.discoveredDevice = Object.assign(\n      {},\n      discoveredDevice\n    );\n    clientConnectionManager.client = this;\n    clientConnectionManager.bluetoothId = bluetoothId;\n    clientConnectionManager.sendClientMessage = this.sendDeviceMessage.bind(\n      this,\n      bluetoothId\n    );\n    clientConnectionManager.sendRequiredDeviceInformationMessage =\n      this.sendRequiredDeviceInformationMessage.bind(this, bluetoothId);\n    clientConnectionManager.sendClientConnectMessage =\n      this.sendConnectToDeviceMessage.bind(this, bluetoothId);\n    clientConnectionManager.sendClientDisconnectMessage =\n      this.sendDisconnectFromDeviceMessage.bind(this, bluetoothId);\n    device.connectionManager = clientConnectionManager;\n    return device;\n  }\n\n  #getOrCreateDevice(bluetoothId: string) {\n    let device = this.#devices[bluetoothId];\n    if (!device) {\n      device = this.createDevice(bluetoothId);\n      this.#devices[bluetoothId] = device;\n    }\n    return device;\n  }\n  protected onConnectedBluetoothDeviceIds(bluetoothIds: string[]) {\n    _console.log({ bluetoothIds });\n    bluetoothIds.forEach((bluetoothId) => {\n      const device = this.#getOrCreateDevice(bluetoothId);\n      const connectionManager =\n        device.connectionManager! as ClientConnectionManager;\n      connectionManager.isConnected = true;\n      DeviceManager._CheckDeviceAvailability(device);\n    });\n  }\n\n  disconnectFromDevice(bluetoothId: string) {\n    this.requestDisconnectionFromDevice(bluetoothId);\n  }\n  protected requestDisconnectionFromDevice(bluetoothId: string) {\n    this.assertConnection();\n    _console.assertTypeWithError(bluetoothId, \"string\");\n    const device = this.devices[bluetoothId];\n    _console.assertWithError(device, `no device found with id ${bluetoothId}`);\n    device.disconnect();\n    return device;\n  }\n  protected sendDisconnectFromDeviceMessage(bluetoothId: string) {\n    this.sendServerMessage({ type: \"disconnectFromDevice\", data: bluetoothId });\n  }\n\n  protected sendDeviceMessage(\n    bluetoothId: string,\n    ...messages: ClientDeviceMessage[]\n  ) {\n    this.sendServerMessage({\n      type: \"deviceMessage\",\n      data: [bluetoothId, createClientDeviceMessage(...messages)],\n    });\n  }\n\n  protected sendRequiredDeviceInformationMessage(bluetoothId: string) {\n    this.sendServerMessage({\n      type: \"requiredDeviceInformation\",\n      data: [bluetoothId],\n    });\n  }\n}\n\nexport default BaseClient;\n","import { createConsole } from \"../../utils/Console.ts\";\nimport {\n  createServerMessage,\n  MessageLike,\n  ServerMessage,\n} from \"../ServerUtils.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../../utils/EventUtils.ts\";\nimport ClientConnectionManager from \"../../connection/ClientConnectionManager.ts\";\nimport BaseClient, { ServerURL } from \"../BaseClient.ts\";\nimport type * as ws from \"ws\";\nimport Timer from \"../../utils/Timer.ts\";\nimport {\n  createWebSocketMessage,\n  WebSocketMessageType,\n  WebSocketMessageTypes,\n  webSocketPingTimeout,\n  webSocketReconnectTimeout,\n  WebSocketMessage,\n} from \"./WebSocketUtils.ts\";\nimport { parseMessage } from \"../../utils/ParseUtils.ts\";\nimport { isInLensStudio, isInBrowser } from \"../../utils/environment.ts\";\n\nconst _console = createConsole(\"WebSocketClient\", { log: false });\n\nclass WebSocketClient extends BaseClient {\n  // WEBSOCKET\n  #webSocket?: WebSocket;\n  get webSocket() {\n    return this.#webSocket;\n  }\n  set webSocket(newWebSocket) {\n    if (this.#webSocket == newWebSocket) {\n      _console.log(\"redundant webSocket assignment\");\n      return;\n    }\n\n    _console.log(\"assigning webSocket\", newWebSocket);\n\n    if (this.#webSocket) {\n      removeEventListeners(this.#webSocket, this.#boundWebSocketEventListeners);\n    }\n\n    addEventListeners(newWebSocket, this.#boundWebSocketEventListeners);\n    this.#webSocket = newWebSocket;\n\n    _console.log(\"assigned webSocket\");\n  }\n  get readyState() {\n    return this.webSocket?.readyState;\n  }\n  get isConnected() {\n    return this.readyState == WebSocket.OPEN;\n  }\n  get isDisconnected() {\n    return this.readyState == WebSocket.CLOSED;\n  }\n\n  connect(url: string | URL = `wss://${location.host}`) {\n    if (this.webSocket) {\n      this.assertDisconnection();\n    }\n    this._connectionStatus = \"connecting\";\n\n    if (isInLensStudio) {\n      if (globalThis.internetModule) {\n        // FILL\n        /*\n        let socket = globalThis.internetModule.createWebSocket(url);\n        socket.binaryType = \"blob\";\n\n        socket.onopen = (event) => {\n          socket.send(\"Message 1\");\n\n          // Try sending a binary message\n          // (the bytes below spell 'Message 2')\n          const message = [77, 101, 115, 115, 97, 103, 101, 32, 50];\n          const bytes = new Uint8Array(message);\n          socket.send(bytes);\n        };\n\n        // Listen for messages\n        socket.onmessage = async (event) => {\n          if (event.data instanceof Blob) {\n            // Binary frame, can be retrieved as either Uint8Array or string\n            let bytes = await event.data.bytes();\n            let text = await event.data.text();\n\n            print(\"Received binary message, printing as text: \" + text);\n          } else {\n            // Text frame\n            let text = event.data;\n            print(\"Received text message: \" + text);\n          }\n        };\n\n        socket.onclose = (event) => {\n          if (event.wasClean) {\n            print(\"Socket closed cleanly\");\n          } else {\n            print(\"Socket closed with error, code: \" + event.code);\n          }\n        };\n\n        socket.onerror = (event) => {\n          print(\"Socket error\");\n        };\n        */\n      }\n    } else {\n      this.webSocket = new WebSocket(url);\n    }\n  }\n\n  disconnect() {\n    this.assertConnection();\n    if (this.reconnectOnDisconnection) {\n      this.reconnectOnDisconnection = false;\n      this.webSocket!.addEventListener(\n        \"close\",\n        () => {\n          this.reconnectOnDisconnection = true;\n        },\n        { once: true }\n      );\n    }\n    this._connectionStatus = \"disconnecting\";\n    this.webSocket!.close();\n  }\n\n  reconnect() {\n    this.assertDisconnection();\n    this.connect(this.webSocket!.url);\n  }\n\n  toggleConnection(url?: ServerURL) {\n    if (this.isConnected) {\n      this.disconnect();\n    } else if (url && this.webSocket?.url == url) {\n      this.reconnect();\n    } else {\n      this.connect(url);\n    }\n  }\n\n  // WEBSOCKET MESSAGING\n  sendMessage(message: MessageLike) {\n    this.assertConnection();\n    this.#webSocket!.send(message);\n    this.#pingTimer.restart();\n  }\n\n  sendServerMessage(...messages: ServerMessage[]) {\n    this.sendMessage(\n      createWebSocketMessage({\n        type: \"serverMessage\",\n        data: createServerMessage(...messages),\n      })\n    );\n  }\n\n  #sendWebSocketMessage(...messages: WebSocketMessage[]) {\n    this.sendMessage(createWebSocketMessage(...messages));\n  }\n\n  // WEBSOCKET EVENTS\n  #boundWebSocketEventListeners: { [eventType: string]: Function } = {\n    open: this.#onWebSocketOpen.bind(this),\n    message: this.#onWebSocketMessage.bind(this),\n    close: this.#onWebSocketClose.bind(this),\n    error: this.#onWebSocketError.bind(this),\n  };\n\n  #onWebSocketOpen(event: ws.Event) {\n    _console.log(\"webSocket.open\", event);\n    this.#pingTimer.start();\n    //this._connectionStatus = \"connected\";\n    this._sendRequiredMessages();\n  }\n  async #onWebSocketMessage(event: ws.MessageEvent) {\n    _console.log(\"webSocket.message\", event);\n    //this.#pingTimer.restart();\n    //@ts-expect-error\n    const arrayBuffer = await event.data.arrayBuffer();\n    const dataView = new DataView(arrayBuffer);\n    this.#parseWebSocketMessage(dataView);\n  }\n  #onWebSocketClose(event: ws.CloseEvent) {\n    _console.log(\"webSocket.close\", event);\n\n    this._connectionStatus = \"notConnected\";\n\n    Object.entries(this.devices).forEach(([id, device]) => {\n      const connectionManager =\n        device.connectionManager! as ClientConnectionManager;\n      connectionManager.isConnected = false;\n    });\n\n    this.#pingTimer.stop();\n    if (this.reconnectOnDisconnection) {\n      setTimeout(() => {\n        this.reconnect();\n      }, webSocketReconnectTimeout);\n    }\n  }\n  #onWebSocketError(event: ws.ErrorEvent) {\n    _console.error(\"webSocket.error\", event);\n  }\n\n  // PARSING\n  #parseWebSocketMessage(dataView: DataView) {\n    parseMessage(\n      dataView,\n      WebSocketMessageTypes,\n      this.#onServerMessage.bind(this),\n      null,\n      true\n    );\n  }\n\n  #onServerMessage(messageType: WebSocketMessageType, dataView: DataView) {\n    switch (messageType) {\n      case \"ping\":\n        this.#pong();\n        break;\n      case \"pong\":\n        break;\n      case \"serverMessage\":\n        this.parseMessage(dataView);\n        break;\n      default:\n        _console.error(`uncaught messageType \"${messageType}\"`);\n        break;\n    }\n  }\n\n  // PING\n  #pingTimer = new Timer(this.#ping.bind(this), webSocketPingTimeout);\n  #ping() {\n    this.#sendWebSocketMessage(\"ping\");\n  }\n  #pong() {\n    this.#sendWebSocketMessage(\"pong\");\n  }\n}\n\nexport default WebSocketClient;\n","export {\n  setAllConsoleLevelFlags,\n  setConsoleLevelFlagsForType,\n} from \"./utils/Console.ts\";\nexport * as Environment from \"./utils/environment.ts\";\nexport { Vector2, Vector3, Quaternion, Euler } from \"./utils/MathUtils.ts\";\n\nexport {\n  default as Device,\n  DeviceEvent,\n  DeviceEventMap,\n  DeviceEventListenerMap,\n  BoundDeviceEventListeners,\n} from \"./Device.ts\";\nexport {\n  default as DeviceManager,\n  DeviceManagerEvent,\n  DeviceManagerEventMap,\n  DeviceManagerEventListenerMap,\n  BoundDeviceManagerEventListeners,\n} from \"./DeviceManager.ts\";\n\nexport { DeviceInformation } from \"./DeviceInformationManager.ts\";\nexport {\n  DeviceType,\n  DeviceTypes,\n  MinNameLength,\n  MaxNameLength,\n  Sides,\n  Side,\n} from \"./InformationManager.ts\";\nexport {\n  MinWifiSSIDLength,\n  MaxWifiSSIDLength,\n  MinWifiPasswordLength,\n  MaxWifiPasswordLength,\n} from \"./WifiManager.ts\";\nexport {\n  SensorType,\n  SensorTypes,\n  ContinuousSensorType,\n  ContinuousSensorTypes,\n} from \"./sensor/SensorDataManager.ts\";\nexport {\n  MaxSensorRate,\n  SensorRateStep,\n  SensorConfiguration,\n} from \"./sensor/SensorConfigurationManager.ts\";\n\nexport {\n  DefaultNumberOfPressureSensors,\n  PressureData,\n} from \"./sensor/PressureSensorDataManager.ts\";\nexport { CenterOfPressure } from \"./utils/CenterOfPressureHelper.ts\";\nexport {\n  VibrationConfiguration,\n  VibrationLocation,\n  VibrationLocations,\n  VibrationType,\n  VibrationTypes,\n  MaxNumberOfVibrationWaveformEffectSegments,\n  MaxVibrationWaveformSegmentDuration,\n  MaxVibrationWaveformEffectSegmentDelay,\n  MaxVibrationWaveformEffectSegmentLoopCount,\n  MaxNumberOfVibrationWaveformSegments,\n  MaxVibrationWaveformEffectSequenceLoopCount,\n} from \"./vibration/VibrationManager.ts\";\nexport {\n  VibrationWaveformEffect,\n  VibrationWaveformEffects,\n} from \"./vibration/VibrationWaveformEffects.ts\";\n\nexport {\n  FileType,\n  FileTypes,\n  FileTransferDirection,\n  FileTransferDirections,\n} from \"./FileTransferManager.ts\";\nexport {\n  TfliteSensorType,\n  TfliteSensorTypes,\n  TfliteTask,\n  TfliteTasks,\n  TfliteFileConfiguration as TfliteFileConfiguration,\n} from \"./TfliteManager.ts\";\n\nexport {\n  CameraConfiguration,\n  CameraCommand,\n  CameraCommands,\n  CameraConfigurationType,\n  CameraConfigurationTypes,\n} from \"./CameraManager.ts\";\n\nexport {\n  MicrophoneConfiguration,\n  MicrophoneCommand,\n  MicrophoneCommands,\n  MicrophoneConfigurationType,\n  MicrophoneConfigurationTypes,\n  MicrophoneConfigurationValues,\n} from \"./MicrophoneManager.ts\";\n\nexport {\n  DisplayBrightness,\n  DisplayBrightnesses,\n  DisplaySize,\n  DisplayBitmapColorPair,\n  DisplayPixelDepths,\n  DefaultNumberOfDisplayColors,\n  MinSpriteSheetNameLength,\n  MaxSpriteSheetNameLength,\n  DisplayBitmap,\n} from \"./DisplayManager.ts\";\n\nexport {\n  DisplaySegmentCap,\n  DisplaySegmentCaps,\n} from \"./utils/DisplayContextState.ts\";\n\nexport { maxDisplayScale, DisplayColorRGB } from \"./utils/DisplayUtils.ts\";\n\nexport {\n  DisplayContextCommand,\n  DisplayContextCommandType,\n  DisplayContextCommandTypes,\n  DisplaySpriteContextCommandType,\n  DisplaySpriteContextCommandTypes,\n} from \"./utils/DisplayContextCommand.ts\";\n\nexport {\n  DisplaySprite,\n  DisplaySpriteSheet,\n  DisplaySpriteSheetPalette,\n  DisplaySpritePaletteSwap,\n} from \"./utils/DisplaySpriteSheetUtils.ts\";\n\n/** BROWSER_START */\nexport {\n  default as DisplayCanvasHelper,\n  DisplayCanvasHelperEvent,\n  DisplayCanvasHelperEventMap,\n  DisplayCanvasHelperEventListenerMap,\n} from \"./utils/DisplayCanvasHelper.ts\";\n/** BROWSER_END */\n\n/** BROWSER_START */\nexport {\n  resizeAndQuantizeImage,\n  quantizeImage,\n  imageToSprite,\n  imageToSpriteSheet,\n} from \"./utils/DisplayBitmapUtils.ts\";\n/** BROWSER_END */\n\nexport { rgbToHex, hexToRGB } from \"./utils/ColorUtils.ts\";\n\nexport {\n  default as DevicePair,\n  DevicePairEvent,\n  DevicePairEventMap,\n  DevicePairEventListenerMap,\n  BoundDevicePairEventListeners,\n  DevicePairType,\n  DevicePairTypes,\n} from \"./devicePair/DevicePair.ts\";\n\nimport { addEventListeners, removeEventListeners } from \"./utils/EventUtils.ts\";\nexport const EventUtils = {\n  addEventListeners,\n  removeEventListeners,\n};\n\nimport { throttle, debounce } from \"./utils/ThrottleUtils.ts\";\nexport const ThrottleUtils = {\n  throttle,\n  debounce,\n};\n\nexport { DiscoveredDevice } from \"./scanner/BaseScanner.ts\";\n/** NODE_START */\nexport { default as Scanner } from \"./scanner/Scanner.ts\";\nexport { default as WebSocketServer } from \"./server/websocket/WebSocketServer.ts\";\nexport { default as UDPServer } from \"./server/udp/UDPServer.ts\";\n/** NODE_END */\n/** BROWSER_START */\nexport { default as WebSocketClient } from \"./server/websocket/WebSocketClient.ts\";\n/** BROWSER_END */\n/** LS_START */\nexport { default as WebSocketClient } from \"./server/websocket/WebSocketClient.ts\";\n/** LS_END */\n\nexport { default as RangeHelper } from \"./utils/RangeHelper.ts\";\n"],"names":["encode","decode","createWebSocketMessage"],"mappings":";;;;AA8RO;AACP;AACA;AACA;AACA;AAEO;AACP;AACA;AACA;AACA;AACA;AA+BuB;AACvB;AACA;AACA;;AC1UA;AAIA;AAEA;AAGA;AAEA;AAGA;AAEA;AACA;AACE;AACF;;;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AAEE;;;;;;;;;;;;;;;;;;;;;ACdF;AACA;AACE;;AAEA;;AAEA;;;AAGF;;;AAEA;AAEA;AACE;AACA;AAAY;;;AAKZ;AACA;AAAY;;;AAId;AAEA;AACE;;AAEI;AACA;;;AAEA;;AAEJ;AACF;AAGA;;;AAGM;;AAEJ;AACA;AACF;AAGA;AACE;AACE;AACF;AACA;AACF;AAEA;AAEA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;AAEA;AAGE;;AAQE;AACA;AACA;AACA;AACA;;AAXA;AACE;;AAEF;;AAWF;;;AAKA;;AAEI;;;;;AAMF;;;;AAKF;AACE;AACA;AACE;;AAEF;;AAGF;AACE;;AAGF;AACE;;AAGF;AACE;;AAGF;AACE;;AAGF;AACE;;;AAKA;AACE;;;;AAMF;;;AAQA;;AAOF;;;;;AAvFO;AA+FO;;AAKhB;AAGgB;AAId;AACF;AAEM;AACJ;AACF;;AC7MA;AAqDA;;;;;;;;;;;;AA6BU;;;AAIA;AACN;;AACA;AACE;;;AAGA;AACF;;;;AAaE;;;AAIA;AACA;;AAEF;AACE;AAEE;AAEJ;;AAEE;;;;AAIF;AAEA;;;;AAcE;;AAGF;;;;AAIE;;;AAGE;;AAEJ;AAEA;;AAGF;;AAEI;;AAGF;;AAEA;AACA;;;AAIA;AACA;;;;AAKE;;AAGF;;;AAGE;;;;AAKA;AACE;;;AAEA;;AAGF;;AAEE;;AAEJ;AACA;;AAGF;AAGE;AACE;;AAMA;AAEA;AACF;;AAEH;;;ACxND;AAEO;AACL;AACA;;AAEA;AACF;AAEA;AAEE;;;;AAIE;AACA;AACA;AACA;;;;AAMF;;;;AAIE;;AAEA;AACA;AACA;;;;;;;;AAMA;AACA;;AAIF;AACE;;;AAIA;AACE;;;;AAIF;;AAEE;;;;AAIF;AACE;;;AAGF;AACA;AACA;;;;AAIA;;AAEH;;;ACvEgB;AAKX;AACJ;;;;AAIF;AAEA;AACA;AACA;;AAEA;AAEM;AACJ;;AAEA;AACE;AACA;AACA;AAEA;;AAEF;AACF;;AC/BA;AACA;AACE;AACE;;AAEE;;;AAGN;;;AAEA;AAEA;AACA;AACE;AACE;AACE;AACA;AACG;AACC;AACF;;;;AAIR;;;AAEA;AAEO;AACA;;AC1BP;AAEgB;AACd;;AAIE;;AAEE;;AACK;;AAEL;;AACK;;AAEL;;AACK;;AAEL;;AACK;AACL;;;AAGA;;;;AAIK;;;;AAGA;;AAEL;;;AAEA;;AAEJ;AACA;;AAOA;;AAEA;;AAEE;AACF;;AAEF;AAMM;;;AAGN;AAEM;;AAEN;;AAOE;AACA;;;AAGA;AACA;AACF;AAIO;AACL;AACA;AACE;;AACK;AACL;;;AAEA;AACA;;AACK;AACL;;AACK;;;;AAGL;;AAEF;AACF;AAEM;;AAEN;;ACxGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEe;AACf;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AChCA;AAEO;;;;;;;;;;;;;;;AAiBM;;;;;;AAQN;AAGA;;;;;;AAUA;AACL;;;;;AAOK;;;;;;;AA8CP;AACE;;AA0CA;;;AA6EA;AAmCA;AAqDA;AAgCA;;AA6KA;AAiFA;AASA;;;AAhfA;AACE;;AAKF;AACE;;AAEF;AACE;;AA2BF;;;AAeA;;;AAKA;;;AAsBA;;;AAmCA;;;AAmCA;;;AAqDA;;;;AA6GE;;AAGE;AACE;;AAEF;AACE;;AAEF;AACA;AACE;;AAEF;AACA;AACE;;AAEF;AACA;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;;AAIN;;AAEI;AACA;;AAYF;AACA;AACA;AACA;;AAGE;AACE;;AACK;AACL;;AACK;AACL;;;AAEA;AACA;;;;AAMJ;AACA;AACA;AACA;;AAIA;AAEA;AACE;;AAEF;AACE;;AAEF;AACE;;;AAKF;;;AA6EA;AAEA;;;;AAOF;AACE;AACA;AACA;;;AAMF;;;;AAIE;AACE;;;AAGF;AACA;;;AAIA;;AAEE;AACD;AACD;;;AAIA;;;;AAlgBA;AACF;AASE;AACF;;AASA;;AAOA;AAEE;AACF;AAOE;;;AAGA;AACA;AACA;;AAEC;AACH;AAYE;;;AAGA;AACF;AAEE;AACA;AACA;AACF;AAEE;AAIF;AAOE;;AAEA;AACA;AACA;AACF;;AAGE;AACA;AACF;AAEE;AACA;AACE;;;;;;AAaF;AACF;AAOE;;AAGA;AACF;;AAGE;AACA;AACF;AAEE;AACA;AACA;AACE;;;;;;AAQF;AAKA;AACF;AAOE;;AAEA;AACF;AAEE;AACA;AACA;AACF;AAEE;AACA;AACE;;;;;;AAQF;AAKA;AACF;AAGE;;AAGA;;;AAKI;AACE;AACA;AACD;;AAKL;AACF;AAOE;;AAEA;AACA;AACA;AACF;AAEE;AACA;AACA;AACA;AACA;AACA;AACA;AACE;;AAED;AACH;;AAGA;;AAGA;AAOE;;;AAOA;AAEA;AAIA;;;AAGC;AAED;;;AAIE;;;;;AAKC;;;AAIH;;AAGA;AACE;;;AAGA;;;AAGA;;;;AAKF;AACA;;;;;;AAMA;AACA;AACA;AAEA;;;;AAOA;AAEA;AACA;AACE;;AAED;AACD;AACF;AAoGE;AACA;AACF;AAIE;;;AAGA;AACE;;;AAGF;AACE;AACE;;;;AAKJ;AACA;;AAGA;AACA;;;AAQA;;;AAGC;AACD;AACE;AACA;AACE;;AAED;;;AAED;;;AAIJ;AAGE;;AAEA;AACA;AACE;;;;;;;;AAYF;AACF;AAzaO;;AC7JT;AAEM;AAMJ;AACE;;AAEF;AACF;AAEO;AACA;AACA;AAEP;AACE;;AAEF;AAEA;AAEgB;AACd;AACA;;AAEA;;AAEE;;;AAGF;AACF;AAOM;AACJ;AACA;AACF;AAEM;AACJ;;AAEF;AAEgB;AAId;;;AAGA;AACF;AACM;;AAEN;AAmDM;;AAEJ;AACF;AAEM;AACJ;AACF;AAEM;;AAEN;AAMO;AACD;;AAEN;;;ACjIA;AAEA;AAAA;;;;AAEE;AACE;;AAEF;AACE;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAWF;AACE;AACA;AACA;;;;;AAME;;;;;AAMF;;;AAGH;;AAzBG;AACF;;;ACrBF;AAAA;;;;;;;AAMI;AACA;;AAGF;;;;;;AAMI;AACA;;;;AAKF;;;AAGH;;;ACpCe;AACd;AACE;;AAEE;;;;;;AAKJ;AACF;AAEM;;AAEN;;;ACTA;AAEO;AAGA;AA6BA;AAEP;AAAA;AACE;;;;;AACA;;;AAIA;AACE;;AAGF;;;;;AAUM;AACD;;AAGH;AAEA;AAEA;;;;AAcA;AACA;AACA;;;AAIA;AACE;AACA;AACA;;;;;;;;AAiBA;;;;;AAKE;;AAGF;;AAGF;;AAMA;AACE;;;AAGE;AACA;AACF;AACA;;;AAOF;AACA;;AAEH;;;AC7ID;AAEO;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;AAmBA;;;;;;;;AAmBA;;;;;;;AA4BP;;AAEI;AACE;AACA;AACA;;;AAKF;AACA;;;;AAKE;AACA;AACA;AACA;;;AAKF;AACA;;;AAIA;AACE;AACA;AACA;;;;AAKF;;;;AAMA;AACA;;AAGF;AACE;;AAEA;AACA;;AAGF;AACE;;;AAIA;;AAEE;AACF;AAEA;AAEA;;AAGF;AACE;;AAEA;AACA;AACA;AACA;;AAEH;;;AClKM;AAGA;AAUP;AAEA;AAAA;;;;AAgBI;;;;;AAKH;;AAnBG;AACA;AACA;AACA;AACA;AACA;AAEA;;AAGA;AACF;;AC1BF;;;;;AAcE;AACF;AAEgB;;AAYd;;;AAME;AAEA;;;;;;;;;;;;;;AAcC;;AAGD;AAEA;;;AAIJ;;;ACrDA;AAEO;AAGM;;;;;;;AASN;;;;;;AAQA;;;;;;;;AAUM;;;;;;;;;AAWN;;;;;;;AAmBA;;;;AAKA;AACL;;;;AAuBF;AACE;;;AA8LA;;AAEA;AAEA;;AAEA;AAEA;;AAEA;AAEA;AAsBA;;;;;;;;;;;;;AAtNA;AACE;;;AAIA;;AAEE;AACD;AACD;;AAKF;;;AAgEA;AACE;;;AAGF;AACE;;;AAGF;AACE;;;AAGF;AACE;;;AAGF;AACE;;;AAwHF;;;AAIA;;;AAaA;;;;AA6CE;;AAEE;;;;AAIF;;;AAIE;AACE;;AAED;AACF;AACD;;;AAwBA;;;AAQA;;;;;;AAuCE;AACE;;AAEF;AACA;AACE;;AAEF;AACE;;AAEF;AACE;;;;AAMJ;AACA;AACA;AACA;;AAEH;;AAnYG;AACF;;AAoBE;AACA;AACF;AAEE;AACA;AACE;;;AAGF;AACA;;AAEA;;;AAGC;AAED;;AAGE;AAEA;;AAEJ;AAGA;AACE;AACA;;AAGA;;;AAKI;AACE;AACA;AACD;;AAKL;AACF;AAEE;AAIF;AAEE;AAIF;AAwBE;AACA;AAOF;;;AAII;;;AAGE;AACA;;AAEF;;;AAGE;;AAEA;;AAEE;AACD;AACD;AACE;;;AAGJ;;;AAGE;AACA;AACA;;AAEF;;;AAGE;;AAEA;;AAEE;AACD;AACD;AACE;AACA;AACE;;;;AAIN;;;AAGE;AACA;;AAEF;;;AAGE;;AAEA;;AAEE;AACD;AACD;AACE;AACA;AACE;;;;;AAKV;AAgBE;AACA;AAKA;AAEA;AACA;;AAGA;AAEA;AAEA;AACF;;;AA6BE;;AAEE;;AAMA;;;AAOF;;AAIA;AACA;;AAEC;AACH;;AAME;AACE;AAEE;AAEJ;AACF;;;;AAmCE;AACF;;AAwBE;AAKA;;AAIE;;;AAMA;AAEA;AACF;;AAEA;AACF;;ACnde;;;AAQf;AACF;AAEA;AAKE;AACA;AAGA;AAEA;AAEA;AAEA;;;;;AAUA;;;AAMA;AAEA;AAGA;;;AAIA;AACF;;AAOE;AACE;;AAEJ;;;ACtDA;AAEO;AAGM;AAGN;;AAOA;AAGA;AAGA;;;;;;;AAcM;AACX;AACA;;AAGK;;;;AAKA;AACL;;;;AAuCF;AACE;;;AAmHA;AACA;AAmFA;;;;;AA+OA;;;;AA5aA;AACE;;;AAIA;;AAEE;AACD;AACD;;AAKF;;;AAkEA;;;AAGA;AACE;;;AAGF;;;AAGA;AACE;AACE;;;AAGA;;;;;AA+FJ;;;AAIA;;;AAIA;AACE;;AAEF;AACE;;;AAkDA;;AAEE;;;;AAMF;;;AAIE;AACE;;AAED;AACF;AACD;;;AAwBA;;;AAQA;;;;;;AAoDE;AACE;;AAEF;AACA;AACE;;AAEF;AACE;;AAEF;AACE;;;AAKN;;;;AAIE;;;;AAKA;;AAGA;;;;AAGE;AACE;AACA;;AAEF;AACE;AACA;;;;AAMN;;AAKE;AACE;;;;;;AAQJ;;AAKE;AACE;;;;;;;AAaJ;;;;AAKE;AACE;;;AAGF;AACA;AACA;;AAEC;;;AAGD;AACE;;;AAGF;;AAGE;;;AASA;AAEA;;AAEA;;;;;;AAMC;;AAEH;AACA;;AAEC;;;AAGD;;;;;;;;AASA;AACA;AACA;;;;AAIH;;AAhfG;AACF;;AAoBE;AACA;AACF;AAEE;AACA;AACE;;;AAGF;AACA;;AAEA;;;AAGC;AACH;AAGA;AAIE;AACA;;AAGA;;;AAKI;AACE;AACA;AACD;;AAKL;AACF;;AAYA;;AAgCA;AAIE;AAEA;;AAGA;AAEA;AACE;AACA;AACE;;;;AAIA;AACE;;;;;AAMN;;AAGE;;AAGF;AACE;;;;AASE;;;AAKA;AACE;;;;AASE;;AAGJ;;;;AAKA;AACA;;;AAIJ;;;;AAIC;AACH;AAEE;AACE;AACE;AACF;AACE;;AAEN;;;AAuBE;;AAEE;;;AAOA;AACA;AACA;;AAGA;;AAGF;;AAIA;AACA;;AAEC;AACH;;AAQE;AACE;AAEE;AAEJ;AACF;;;;AAuCE;AACF;;AAwBE;AAOA;;AAKI;;;AAOA;AACA;AAEE;;AAEF;AAEA;;;AAIF;;AAGF;AACF;;;AClaF;AAEa;AACX;AACA;AACA;AACA;AACA;;AAIW;AACX;AACA;AACA;;AAIK;;;;;AAOA;;;AAIA;AACL;AACA;;AA4BF;AAAA;AACE;AACA;AACA;;;;AAKE;;;AAGA;;;AAQF;AACE;;;AAIA;;AAGE;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;;AAIN;AACE;;AAME;;AAEE;;;AAGF;;;;;AAMI;AACN;;;;;AAQA;;AAEC;;AAGK;AAKN;;;AAIE;;;AAGA;AACA;AACA;AACA;AACA;;;AAMA;AACA;;;AAMA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;AAEI;;AAEJ;;;AAGA;;;AAMA;;AAGA;;AAGA;AACE;;;;AAUJ;;;;AAIC;AAED;;;;AAIC;;AAEJ;;;;AChPD;;AAKO;AAEA;;;;AAOA;AAiBP;AACE;;;AAgCA;;;AAzBA;AACE;;AAKF;AACE;;AAmBF;;;AAmBA;;AAMI;;AAKF;;AAEE;;;;AAIF;;;AAKI;AACE;;AAED;;AAIL;;AAuEF;;;AAQA;;;AAGI;AACF;AACA;;AAEF;;;;AASE;;AAGE;AACA;;AAEE;;AAEF;AACE;;;;;AA9KJ;AACF;;;;AAiBE;AACF;AAQE;;AAEA;;AAEC;AACH;;AAIE;;AAEA;AACF;;AAoCE;;AAME;AAEA;;;AAIE;;;AAGF;;AAEF;;AAIA;AACF;AAGE;;;AASA;AAIF;AAGE;AACF;;AAIE;AAIA;;AAEE;;;AAIA;AACA;AACA;AACF;;AAEA;AACF;AAGO;AAIP;AACE;AACE;AACF;AACF;;;AC3LF;AAEO;;;;;;;;;;;;;;;;;;AAoBA;AAGA;;;;;;;;;;;AA0CM;;;;;;AAmBb;AACE;;;;;AAmJA;;;;;;;;AAlIA;AACE;;AAKF;AACE;;AAEF;AACE;;AAMF;;;AAaA;AACE;AACA;AACE;;;;;AAOF;AAKA;;AAIF;;;AAeA;AACE;AACA;AACE;;;;;;AAYF;;AAIF;;;AAeA;AACE;AACA;AACA;AAIA;AACE;;;;;;AAQF;AAKA;;;AAIA;;AAEA;;AAOF;AACE;;AA2BF;AAIE;AACE;AACF;;AAIA;;AAEG;AACA;AACH;;AAGI;AACE;;AAED;;AAKL;;AAIF;;;AAkBA;;;AAeA;AACE;AACA;AACE;;;;;;AAQF;AAKA;;AAIF;;;AAaA;AACE;;AAKA;AACE;;;;;;AAQF;AAKA;;AAIF;;;AAeA;AAIE;;;;AAIA;AACA;AACE;;;;;AAUE;AACE;AAEA;AACD;;AAKL;;AAEF;;;AAIA;AACE;;;AAGA;;AAEF;AACE;;;AAGA;;;AAoDA;;AAGE;AACA;AACE;;AAEF;AACA;AACE;;AAEF;AACA;AACE;;AAEF;AACA;AACE;;AAEF;AACE;;AAEF;AACA;AACE;;AAEF;AACA;AACE;;AAEF;AACA;AACE;;AAEF;AACE;;AAEF;AACE;;;AAKN;;;;AAOE;AACE;;;AAGF;;AAEA;;;AAGA;AAEA;AACA;AACA;AACE;;AAEF;AACA;AACE;;AAEF;;;AAIA;AACA;AACA;AACA;AACA;;;AAIA;;AAEE;AACD;AACD;;AAEH;;AAxeG;AACF;;AAMA;AAOE;AACF;AAeE;;AAEA;AACF;AAEE;AACA;AACA;AACF;AAwBE;;AAEA;AACA;AACA;AACF;AAEE;AACA;AACA;AACF;AAwBE;;AAEA;AACF;AAEE;AACA;AACA;AACE;AACD;AACH;AAuCE;;AAEA;;AAEE;;AAEE;AACE;;;AAEA;;;;AAGF;;;AAGJ;AACF;AAEE;AACA;AACA;AACE;AACD;AACH;AAkCE;;AAEA;AACF;AAEE;AACA;AACA;AACF;;AAGA;AAOE;;AAEA;AACF;AAEE;AACA;AACA;AACE;AACD;AACH;AAyBE;;AAEA;AACF;AAEE;AACA;AACA;AACF;AA6BE;;AAEA;AACF;AAEE;AACA;AACA;AACE;AACD;AACH;AAkDE;;AAGA;;;;AASE;;AAEF;AAEA;;;;AAKA;;;;AAII;;;;AAIF;;AAEA;AACA;AACA;AACE;AACA;AACA;;AAEE;AACA;AACF;;;AAIJ;AACF;;;ACnfF;AAmBO;;;;;;;;;AAWA;AACL;;;AAuBF;AAAA;;AAME;;AACA;;;;AAIE;;;AAgCA;;AAGE;;AAEE;;;AAGF;;AAEE;;;AAGF;;AAEE;;;AAGF;;AAEE;;;AAGF;;AAEE;;;AAGF;AACE;AACE;;;AAGA;;AAEF;;;AAKA;;;AAGF;;AAEE;;AAGF;AACE;;;AAGP;;AA5FG;AACF;;AAaA;AAGE;;AAIA;AAEE;AACE;AAED;AACH;;;AAIA;AACE;AACA;;AAEC;;AAEL;;;AC1FF;AAEa;;;;;;;;;AAaN;AACA;AAEA;;;;;;;;;;;;AAcA;AAqBP;AACE;;AAgBA;;;AAyCA;;AAwGA;AAeA;;;AAtKA;AACE;;AAMF;;;AAWA;;;AAGA;AACE;;;AAGA;;AAYF;;;AAWA;;;AAIA;AACE;AACA;;AAEA;;;AAGA;AACA;;AAOA;;AAGA;AACA;;AAKF;;;AAGA;;;AAaA;AACE;AAKA;;AAGA;;;AAYA;;AAEA;;AAGF;AACE;AACE;AACA;AACE;AACF;AACE;;;AAIN;AACE;AACE;AACA;AACE;AACF;AACE;;;AAIN;AACE;AACE;AACA;AACE;AACF;AACA;AACE;AACF;AACE;;;AAKN;;;AAeA;;;;AA0BE;;AAGE;;AAEE;AACA;;AAEF;;AAEE;AACA;;AAEF;;AAEE;AACA;;AAEF;AACA;;AAEE;AACA;;AAEF;AACA;;AAEE;;AAEA;;AAEF;;AAEE;AAEE;;;AAIF;AACA;;AAEF;AACA;AACE;AACA;;AAEF;AACE;;;;AAKJ;;AAIH;;AA5PG;AACF;AAYE;AACA;;AAEA;AACF;AAaE;AACA;;AAEA;;AAEC;AACH;AAOE;AACA;;AAEA;AACF;AAsCE;AACF;AAEE;;AAKF;AAaE;AAEA;AACA;;AAEA;AACA;AACF;AA6CE;AACA;AACE;;;AAGF;AAEA;AACF;AAQE;;AAGA;AACE;;AAEJ;AAEE;;AAEA;;AAEA;AAIA;AACF;;ACtQW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACUb;;;AAmBO;;;;AAMA;AAOA;AACA;AACA;AACA;AACA;AACA;AAiCP;AACE;;AAmUA;;;AA1TA;AACE;;AAyQF;AAIE;AACA;AACE;AAEA;;AAEA;AAIA;;AAGE;;AAEI;AACA;;;AAOJ;;AAEI;;;;AAIJ;AACE;;;AAGJ;AAIF;AACA;;AAOF;;;;AAaE;;AAGE;AACE;;;AAGA;;AAEF;AACE;;;AAGP;;AAvVG;AACF;AAME;AACA;AAIF;AAEE;AACA;AACE;AACF;AACF;AAEE;;AAGA;;AAEE;AACF;AACA;;AAKA;AACF;AAGE;;AAEF;AAGE;AAIF;AAKE;AACE;AACA;;AACK;AACL;;AAKA;;;AAKA;;AAGF;AACE;AACA;;AAEJ;AAKE;;;AAOI;AAGN;AAKE;AACA;;AAKA;AACE;AACF;AACF;AAKE;;;AAOI;AAGN;;AAIE;AAIA;;AAMA;AAIA;AAIF;AAGE;AACA;AAIA;AACE;AACF;AACF;AAOE;AACA;;;;AASI;AACA;AACF;;;;AASA;AACE;AAGF;AACE;;AAEF;AACE;;AAEE;;AACG;AACL;;;;AAGA;;;AAIJ;;AAKE;AACE;;;AAMA;;;AAGF;;AAEE;;;AAIJ;AACE;;AAEF;;AAEA;AACF;AAKE;AACA;;AAEE;;AAKF;AACA;AACA;AACF;AAGE;AACA;AAIF;;;AASE;;;AAGA;AAMA;AACA;AACF;AAuDE;AACA;AACA;;AAEC;AACH;;;ACtZF;AAEO;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;AAcA;;;;;;;;AASA;AAmBP;AACE;;AAwBA;AAkBA;AAkCA;;AAyFA;;AA4BA;;;AAvLA;AACE;;;AAIA;;AAEE;AACD;AACD;;AAMF;;;AAkBA;;;;AAWE;AACA;AACE;;;AAGF;AACA;;AAQA;;AAGA;AACA;;AAKF;;;;AAaE;AACA;AACE;;;AAGF;AACA;AACE;;;AASF;;;;AAKC;AACD;;AAKF;;;AAUA;AAIE;AACA;AACA;AACE;;;;;AAUE;AACE;AAEA;AACD;;AAIL;;AAEF;;;AAGA;AACE;;AAEF;AACE;;AAKF;;;AAcA;;;AAcA;;;;AAcE;;AAGE;;AAEE;AACA;;AAEF;AACA;;AAEE;AACA;;AAEF;AACA;;AAEE;AACA;;AAEF;AACA;;AAEE;AACA;;AAEF;;AAEE;AACA;;AAEF;;AAEE;;;AAGA;AACA;;AAEF;;AAEE;AACA;;AAEF;AACE;;;;AAKJ;AACA;AACA;AACA;AACA;;AAEH;;AAhQG;AACF;AAoBE;AACA;;AAEA;;AAEC;AACH;;AAIA;AASE;AACA;;AAEA;AACF;AA8BE;AACA;;AAEA;;AAEC;AACH;AAiCE;AACA;AACA;AACE;AACD;AACH;AA4CE;AACA;;AAEA;;AAEC;AACH;AASE;;AAEA;;AAEC;AACH;AAQE;AACA;;AAEA;;AAEC;AACH;;ACpQF;AAEM;;AAGJ;AACE;;;;;AAMF;AAKA;AACA;AACA;AAEA;AACF;AAEA;AACM;;AAEJ;AACA;;AAGA;;AAIA;AAAY;;;;;;AAOd;AAEM;AACJ;AACE;;;AAEA;;AAEJ;AAEM;;AAIJ;AAKA;AACF;;;ACxBO;AACL;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAGA;AACA;;AAGA;AACA;AAEA;;;ACzEc;AACd;AACE;;;AAKA;;;AAIA;;;;AAMF;AAAmC;AAEnC;;AAEI;;;AAIJ;AACF;;;ACjBA;AAEA;AAAA;;;AAEE;;;AAIA;;;AAGE;AACE;AAEA;AACE;;AAEJ;;AAEA;;AAEF;;AAEE;AACE;;AAEF;AACE;AAEA;AACF;AACA;;;;;AAKH;;;AC9BD;;;;AASI;AACA;AACA;;;;AAGA;;;;;;;AASF;;AAEA;AACF;AAEgB;AACd;;AAEA;AACF;AAEO;AACA;AACA;AACD;;;AAGJ;AACF;AACM;AACJ;AACF;AAEM;AACJ;AACF;AAEM;AAGJ;AACF;AAEgB;;AAEhB;AACM;AACJ;AACA;AACA;AACF;AAEM;;AAEN;AAEO;;;;;;AAiBA;AAIL;AACA;AACA;AACA;;AAYK;AAIL;AACA;AACA;AACA;;AAYK;AAIL;AACA;AACA;AACA;;AAYK;AAIL;AACA;AACA;AACA;;AAGI;AACJ;AACF;AACM;AACJ;AACF;AACM;AACJ;AACF;AACM;AACJ;AAGF;AAKO;AAIL;AACA;AACA;;AAGK;AAIL;AACA;AACA;;;;;;;;;;;;AClMF;AACA;AACA;;;;;;;;;;;AAsBA;;AAIA;;;;AAYA;AAEA;AAEA;AAEA;AAEA;;;AAMA;AAEA;;;;;;AAQA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;;;AAKA;AACA;AACA;;AAMA;AACA;;AAGA;;AAGA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAGA;AAEA;;AAEA;AAEA;AACA;;AAEA;AAEA;AACA;;AAIA;;AAGA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;;;;;;;;;AAYA;;AAEA;;;;;;AAMA;;AAEA;;;;;;;;;;;;AAYA;;AAEA;;;;;;;;;AASA;;;;;;;;;;;;AAYA;;;;;;;;;AASA;;;;;;;;AASA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;;;;;AAMA;AAGA;;AAEA;;AAEA;AAGA;AACA;AACA;AAEA;;;AAIA;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AAEA;;;;AAOA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;;;AAMA;;;AAKA;;AAGA;;;AAGA;AAGA;AAEA;AAEA;;;AAKA;AAEA;;AAGA;AACA;;;;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;AAQA;AAEA;;AAGA;;AAEA;;AAIA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;;;AAKA;;AAEA;AACA;;AAEA;AAEA;;AAEA;AAGA;AACA;;AAIA;AACA;;AAGA;AACA;;;AAKA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAMA;AACA;AAGA;;;AAIA;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAKA;AACA;AACA;AACA;;;AAKA;AACA;AACA;AAEA;AACA;;;AAOA;;AAGA;AACA;AACA;AACA;;AAMA;;AAEA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;;;AAOA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;;;;;;AAUA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;;AAGA;;AAGA;AACA;;AAIA;AACA;AACA;;;;AAMA;;;;AAOA;AAEA;AACA;;AAGA;AACA;;AAEA;AACA;;AAEA;AAEA;;AAGA;AAEA;;;AAGA;AACA;AAEA;;;AAIA;AACA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAIA;;AAEA;;AAGA;AACA;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AAWA;AACA;;;AAGA;;;;;AAQA;;;;;AAMA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;AAUA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AAIA;;;;;AAKA;AAEA;AACA;AACA;;AAGA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;;;;AAMA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;;;AAIA;AACA;AACA;;;AAMA;;AAEA;AACA;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAEA;;;;;;;;;AASA;;AAKA;AACA;;;AAIA;AACA;AACA;AAEA;AACA;;;;;AAOA;AAEA;AACA;AACA;;AAEA;AAGA;;AAGA;AACA;;;AAIA;AACA;AAGA;;AAIA;AACA;AAEA;;;;;ACr5BA;AAEO;AAED;AACJ;;;AAGA;;;AAGE;AACA;AACA;AACA;;AAEA;AACA;AACF;;AAEA;AACF;AAEO;;AAWL;AAEA;AACA;AAGA;;AAGE;AACE;AACA;AACA;AACA;;;;;AAQJ;;AAEE;;;;;AAMF;;;AAKI;;;AAGE;;;AAEA;;AAEJ;;AAEF;AACA;AACA;;;;AAUA;AAEA;AACA;AACA;;;;AAIA;AACA;AAKE;AACE;;;;AAIF;AACA;AACA;AACA;AAEA;AACA;;;;;;AAMF;AACE;;;;AAIA;AACA;;AAEF;;AAEE;AACA;AACF;AACA;;AAGA;AACE;;;;AAKA;;;AAGF;;AAGE;;;;;AAII;;;AAGN;AAEA;;;AAGE;AACA;;AAEJ;AAEO;;AAWL;;AAGA;;;AAKA;AACA;AAEA;AAEA;;AAGF;AAEO;;;;;;AAiBL;AACA;AAEA;AAEA;AAEA;AACA;AAGA;;AAGE;AACE;AACA;AACA;AACA;;;;;AAQJ;;;;;;;AASA;;AAIE;;;AAGE;;;AAEA;;AAEJ;AACA;AACA;AACA;;AAGA;;AAOA;;AAGA;AACE;;;;AAKA;AAEA;AACA;AACE;AACA;;;AAGF;;AAEF;;AAGE;;;;;AAII;;;AAGN;AACA;;;AAGE;;AAEJ;AAEO;AAQL;AACE;;;;AAIC;AACH;AAMA;;AAEE;;;;AAIF;AACF;AAEM;;AAEJ;AACA;;;;;;;AAOC;AACD;AACF;AACM;AACJ;;AAOE;AAMF;AACF;AAEO;AAWL;;AAIE;AACE;;;;;AAKF;;;AAQF;AACE;;;AAGA;AACA;;AAGF;AACA;;AAEE;AAMA;AACA;;;AAGA;;;;AAQA;AACA;;AAGF;AACE;;AAEE;;AAED;AACF;AACD;;AAEE;;;;;AAMF;AAGA;AACE;;;AAEA;;AAGF;AACF;AACO;AAQL;;AAEE;AACA;AACA;;;AAeF;AACF;;AC1cA;AAEa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwYG;AAId;AAEA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEI;AAEA;AACA;AACE;;;;;AAIF;;;;;;AAOA;;;AAGA;;;;;;AAMJ;;AAEI;AACA;;AAEA;;;;;;AAQA;;;;AAIJ;;AAEI;;;AAGA;;;AAGJ;;AAEI;AACA;;AAEA;;;AAGJ;;AAEI;AACA;;AAEA;;;AAGJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;AACA;;;AAIA;;;AAGJ;;AAEI;;AAEA;;;AAGA;;;AAGJ;;AAEI;;AAEA;;;AAGA;;;AAGJ;;AAEI;;AAEA;;;AAGA;;;AAGJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;;;;;AAKJ;;AAEI;AACA;AACA;;AAEA;AACA;;;AAGJ;;AAEI;AAEA;;;AASE;AACA;AACA;AACF;AAEA;;;;AAME;;;AAGF;;;AAGJ;;AAEI;;AAEA;;AAEA;;;AAGJ;;AAEI;;AAEA;;AAEA;;;AAGJ;;AAEI;;AAEA;;AAEA;;;AAGJ;;AAEI;AACA;AACA;;AAEA;AACA;;;AAGJ;;AAEI;AACA;;;AASE;AACA;AACA;AACF;AAEA;;;;AAME;;;AAGF;;;AAGJ;;AAEI;;AAEA;;AAEA;;;AAGJ;;AAEI;;AAEA;;AAEA;;;AAGJ;;AAEI;;AAEA;;AAEA;;;AAGJ;;;AAGI;;;;;;;AAOJ;;;AAGI;;;;;;;AAOJ;;AAEI;AACA;;;;;AAKA;;;AAGJ;;;AAGI;;;;;;AAMJ;;;AAGI;;;;;;;AAOJ;;;AAGI;;;;AAIA;;;AAGJ;;;AAGI;;;;;;;AAOJ;;AAEI;AACA;;;;;AAKA;;;;;AAKA;;;AAGJ;;AAEI;AAGA;AACA;AAEA;;;AAIA;;AAIA;;;;AAIA;;;;AAIJ;;AAEI;AAUA;AACA;AAEA;;;AAIA;;AAIA;;;;;AAKA;;;;AAIJ;;;AAGI;;;;;AAKA;;AAGA;;;AAGA;;;AAGJ;;AAEI;;AAEA;;;AAGJ;;;AAGI;;;;;;;;;;;;;;;;AAgBN;AACF;AACgB;;;AAMX;;;;AAYD;AACF;;AASA;AACF;;AC7gCA;AA0XO;AAKL;;;AAGA;AACE;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;;AAEI;;;;AAIJ;;AAEI;;;;AAQJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;AACA;;;;AAKJ;;AAEI;;;;AAOJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAOJ;;AAEI;;;;AAOJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAOJ;;AAEI;;;;AAOJ;;AAEI;;;;AAOJ;;AAEI;;;;AAOJ;;AAEI;;;;AAQJ;;AAEI;;;;AAOJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAQJ;;AAEI;;;;AAOJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;AAEI;;;;AAIJ;;;AAGI;;;AAGJ;;;AAGI;;;AASJ;;AAEI;AACA;;;AAUJ;;;AAGI;;;AAQJ;;;AAGI;;;AASJ;;;AAGI;;;AASJ;;;AAGI;;;AASJ;;AAEI;AACA;;;AAMJ;;AAEI;AAEA;AACA;AAEA;;;AAWJ;;AAEI;AASA;AACA;;;;AAcJ;;;AAGI;;;AAQJ;;;AAGI;AAEA;;;AAQJ;;AAEI;AACA;;;;AASJ;AACE;;;AAGN;AAEO;AAKL;;;AAGG;AACC;AACF;;;;AAIJ;AAEgB;AAId;AAIF;AACgB;AAId;AACA;AAIF;AACM;;AAON;AACgB;;AAKd;AAGF;AACgB;;;;AAOhB;AACgB;AAId;AAGF;AACgB;AAId;AAGF;;AAME;;AAEE;AACJ;AAEgB;;;AAUhB;AACgB;;;AAUhB;;;;AAcA;AACO;AAML;;AAGA;;;AAQA;;;AAGE;;;;;;;;;AAUJ;AACO;AAML;;AAEA;;;AAMA;;;;;AASG;;AAEH;;;;AAKF;AACO;AAOL;;;;AASA;;;;;AASG;;AAEH;;;;AAKF;;AC5iCA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAMA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AAOA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAOA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AAGA;AAGA;AAEA;AAGA;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAOA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAEA;AAGA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AAGA;AACA;AAGA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AAcA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAMA;AAKA;AAKA;AAGA;AACA;AACA;AACA;AACA;AASAA;AACA;AACA;AACA;AAKA;AAOAA;AACA;AACA;AAMA;AAOAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAOAA;AACA;AACA;AAMA;AAOAA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AAOAA;AACA;AACA;AAMA;AAOAA;AACA;AACA;AAMA;AAOAA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AAEAA;AACA;AAEAA;AACA;AAEAA;AACA;AAOAA;AACA;AACA;AAMA;AAOAA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAIAA;AACA;AAEAA;AACA;AAEAA;AACA;AAEAA;AACA;AAQAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAQAA;AACA;AACA;AAMA;AASAA;AACA;AACA;AAMA;AAMAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AAEAA;AACA;AAEAA;AACA;AAQAC;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOAD;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaAC;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAWAD;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AASAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AAMAA;AACA;AACA;AACA;AACA;AACA;AACA;AAOAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEAA;AACA;AAGA;AAOAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AASAA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AASAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEAA;AACA;AAGAA;AACA;AACA;AAEA;AACA;AACA;AAYA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAMA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAMA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAGA;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAMA;AACA;AACA;AASA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAyBA;AAGA;AACA;AAKA;AACA;AAGA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAUA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AAQA;AACA;AACA;AAeA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AAWA;AAWA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AA8BA;AACA;AACA;AACA;AAQA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AASA;AACA;AAKA;AACA;AACA;AAKA;AAEA;AACA;AAKA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;AAEA;AACA;AAKA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAYA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AAKA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAYA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAcA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AAEA;AAEA;AACA;AAOA;AACA;AAEA;AAEA;AACA;AAKA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AA2CA;AACA;AAQA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AAIA;AAOA;AAEA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AAEA;AAGA;AAGA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAIA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AAGA;AAEA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AAKA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAGA;AAMA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmPA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAMA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AAMA;AACA;AACA;AAMA;AACA;AACA;AAMA;AACA;AACA;AAMA;AACA;AACA;AAUA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAMA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwCA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AASA;AACA;AACA;AASA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AAGA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAaA;AACA;AACA;AAKA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAiBA;AACA;AACA;AAWA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AAOA;AACA;AACA;AAIA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAgBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AAEA;AACA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAYA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1mcA;AAgCgB;AAId;;AAGA;;;;;AASE;;;;;;AAMA;AACF;AACA;;;;AAQE;AACF;;AAQA;AACA;AACF;AAWA;AACE;AACA;AACA;;AAEK;AAOL;;;AAKA;;AAGA;AACE;AACA;;;;;AAMF;;AAGA;;AAEE;AACE;;;;AAKF;AACA;AACA;AAEA;;AAGF;;AAIA;AACE;AAEA;AACA;;;AAGA;;;AAIA;AACA;AACA;AAEA;AAEI;;;;AAMF;AACA;AACA;AAEA;AACA;;AAOA;AACE;;;;AAGA;;AAEF;AACA;;;AAGC;AACD;AACE;AACA;AACA;AACA;;;AAIA;AACA;AACA;AACD;AAgBD;AACA;;AAGE;AACA;AACA;;AAED;;AAGH;;;AAGE;AACA;;AAGF;;AAGF;AACF;;;AC/JA;AAEO;AAEA;AAGA;AAGA;;;;;;AAQA;;;;;;;AASM;AAGA;;;;;;;AASN;;;;;;;;;;;;;AAoCA;AACL;AACA;;AAGK;;;;;;AAOA;AACL;;;;;;;;;AAmEK;AACA;AASP;AACE;;AAuBA;;;;;AA8VA;AAmEA;AAyCA;AAooCA;AAUA;AACA;;;;;;AAtmDA;AACE;;;AAIA;;AAEE;AACD;AACD;;AAKF;;;AAmBA;AACE;;AAQF;;AAKE;;;AAGA;;AAEI;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;;;AAGA;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;;;;AAKI;AAEF;;AAEF;AACE;;AAEF;AACE;;AAEF;;;;AAKI;AAEF;;AAEF;AACE;;AAEF;AACE;;;AAGN;;AAEE;;;AAMJ;;;AAGA;AACE;;AA2DF;AACE;;;AAGF;AACE;;;AAGF;AACE;AACE;;;AAGA;;;;;AAMJ;;;AAMA;;;AAIA;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;;;;;;AAMA;AACE;;AAiEF;;;AAgBA;AAIE;;AAEA;AACE;;;;AAKF;;AAGA;AAIA;;AA6DF;AACE;;AAEF;AACE;AACA;AACA;;AAEF;AACE;AACA;AACA;;AAGF;AACE;;AAQF;;;AAGA;AAKE;AACA;AACE;;;;;AAIF;;;;;;AAOA;;;AAGA;;;;AAIA;AAKA;AACA;;;;AAIC;;AAGH;;;AAGA;AAKE;AACE;;;AAGD;;;;AAID;AAKA;AACA;;AAEF;AACE;AACE;;AAED;;;;AAID;AAKA;;;;AAKA;AACA;;;AAOA;AACA;;AAOF;AACE;AACA;;AAEC;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAEF;AACE;AACA;;AAEC;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAEF;AACE;;AAEF;AACE;AACA;;AAEC;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAGF;AAKE;AACA;;AAEA;;AAEC;AACD;;;AAGA;AACE;;;AAGD;;;;AAID;AAMA;;;AAGA;AACE;AACD;AACD;;;AAGA;;;;AAIA;AAKA;;AAGF;;AAKE;;AAEC;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAEF;;AAKE;;AAEC;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAEF;;AAKE;AACE;AACA;AACD;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAGF;AAIE;;AAEC;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAEF;AAIE;;AAEC;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAEF;AACE;AACE;AACA;AACD;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAGF;AAKE;;AAEA;AACA;AACA;;AAEC;AACD;;;AAIA;AACE;;AAED;;;;AAID;AAKA;;AAEF;;;AAGA;;;AAGA;;;AAGA;;;;AAIE;AACE;AACA;AACA;AACA;AACD;AACD;;;AAGA;AACA;AAKA;;AAGF;AAKE;AACA;AAEA;AACA;;AAEC;AACD;;;AAIA;AACE;;AAED;;;;AAID;AAKA;;AAEF;;;AAGA;;;AAMA;;;AAMA;;;;AAOE;AACE;AACA;AACA;AACA;AACD;AACD;;;AAGA;AACE;AACD;AACD;AAKA;;AAGF;AAKE;AACA;;AAEA;AACA;;AAEC;AACD;;;AAGA;AACE;;;AAGD;;;;AAID;AAKA;;AAEF;AACE;;AAEF;AACE;;AAEF;AAIE;;;AAQE;AACA;AACA;AACF;AAEA;;AAEC;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAEF;AAKE;;AAMF;AAKE;;AAMF;;AAME;AACA;;;AAGA;;AAEE;AACE;AACA;;;AAGF;AACE;;;AAGF;AACE;;;;;AAKJ;;;;;;;AAOA;AAMA;;AAEF;;;AAGA;;;AAGA;;;;AAME;AACE;AACA;AACD;AACD;;;AAGA;AACE;AACD;AACD;AAKA;;AAGF;AAKE;AACA;;AAEA;AACA;;AAEC;AACD;;;AAGA;AACE;;;AAGD;;;;AAID;AAKA;;AAEF;AACE;;AAEF;AACE;;AAEF;AAIE;;;AAQE;AACA;AACA;AACF;AAEA;;AAEC;AACD;;;AAGA;AACE;;AAED;;;;AAID;AAKA;;AAEF;AAKE;;AAMF;AAKE;;;AAQA;AACA;;AAEC;AACD;;;AAGA;AACE;AACD;AACD;AAKA;;AAGF;;AAME;AACA;;;AAGA;;AAEE;AACE;AACA;;;AAGF;AACE;;;AAGF;AACE;;;;;AAKJ;;;;;;;AAOA;AAMA;;AAEF;;;AAGA;;;AAGA;;;;AAME;AACE;AACA;AACD;AACD;;;AAGA;AACE;AACD;AACD;AAKA;;;AAUA;AACE;;;;;AAKD;;;;AAID;;;AAaA;AACE;;;;;AAKD;;;;AAID;;AAMF;AAQE;AACE;;;;;;AAMD;;;;AAID;;;AAYA;AACE;;;;AAID;;;;AAID;;;AAaA;AACE;;;;;AAKD;;;;AAID;;;AAaA;AACE;;;;;AAKD;;;;AAID;;;AAcA;AACE;;;;;AAKD;;;;AAID;;AAMF;AACE;;AAEA;AACE;AACA;;;AAGA;;AAEA;;;;AAIF;AACE;;AAED;;;;AAID;;AAOF;AASE;AACE;;;;;;;AAOD;;;;AAID;;AAMF;AAUE;AACE;;;;;;;;AAQD;;;;AAID;;AAOF;AACE;;;AASA;;;AAGE;;;;AAkBF;AAEA;AACE;;;;AAID;;;;AAID;;;AAaA;;;;;;;;AA4BF;;;AAMA;;;AAQA;AACE;;AAUF;;;AAGA;;;AAyBA;;;AAIA;;;AAYA;AACE;;;AAGA;AACA;;AAEA;;;AAGA;;;AAGA;AACE;;;AAGJ;AACE;;AAEF;AACE;;;;;AAKF;AACE;;AAEF;AACE;;AAEF;AAGE;;AAEF;AAGE;;;;;AASF;AACE;;;;AAIF;AACE;;AAEF;AACE;AACA;;AAEC;AACD;;;;AAIA;AACE;;AAED;;;;AAID;AAKA;;;;;AAeA;;AAKA;AACE;;;;;AAKD;;;;AAID;;;;;AAqCE;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACA;AACE;;AAEF;AACE;;AAEF;AACA;;AAEE;AACA;;AAEF;AACE;;AAEF;AACE;;;AAMN;AACE;;AAEF;AACE;;;AAGA;;AAEF;;;AAOA;;;;AAkBE;;;AAUA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;AAUF;;;AAWA;;;;AAIE;;AAEH;;AA75DG;AACF;;AAqBA;;AAIE;;AAEA;;AAEC;AACH;AAQE;AACE;;AAED;AACH;;AA0GE;AACA;AACF;AAEE;AACA;AACE;;;AAGF;AACA;;AAEA;;;AAGC;AACH;AAGA;AAIE;AACA;;AAGA;;;AAKI;AACE;AACA;AACD;;AAKL;AACF;AAEE;AAIF;;AAMA;;;AAuDE;;AAEE;;AAMA;;AAGE;AACA;;;AAGI;;;;AAIJ;AACA;;AAEI;;AAEA;AACA;AAEA;;;;;AAMR;AACA;;AAOA;AACA;AACA;AACA;AAGA;AAGA;;AAEC;AACH;;AAUE;;AAGA;;AAEA;;AAEC;AACH;AA4BE;AAIF;AAGE;AACF;AAOE;AACA;;;;AAgBA;AACE;AACA;;AAEF;;AAEE;;AAEJ;;;;;AAME;AAKA;AACA;AACF;AAqnCE;AACA;AAMF;AA6EE;;AAEF;AAeE;AACA;;AAOA;;AAGA;AAIA;AACF;AAUE;AACA;;AAEA;;AAEC;AACH;;;;;;AA2HG;;;AASD;;;AAGA;;;AAGC;AACD;AACF;;;ACjhEF;AAEO;;;;;;;AAwCA;;;;;;AAQA;AACL;;;;AAoBK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIK;AAGA;AAGA;AAIA;AACL;AACA;AACA;AACA;AACA;;AAWF;AAYE;;;AAGA;AACE;;AAEF;AACE;;AAGF;AACE;;AAIF;AACE;;AAWF;;AAIA;AA0FA;AACA;;AAoFA;AAsBA;AAxME;;AAIF;;;;AAIE;AACA;AACE;;;AAKF;AACA;AACA;AAEA;AACE;;;AAEA;;AAGF;AACE;;;AAIJ;AACE;;AAGF;AACE;;;;;;;;;;AA4BA;;AAGF;;AAEE;AACA;;AAEF;AACE;;AAEF;;AAEE;;AAEA;AACA;;AAEF;;AAEE;AACA;AACA;;;;AAKA;;AAKF;;;;;;;AAYI;;;AAIF;AACE;;;;AAIA;;;AAGF;AAEA;;;;;AAME;;AAEF;AACA;AAEA;AACE;;AAMI;;;;;;AAMF;AACE;;AAIE;;;AAKF;AACA;AACF;;;AAIA;AACA;AACA;;;;AAGF;AACA;AACA;;AAGF;AAEA;;;AAQA;;AAGF;AACE;;;;AAyBA;AACA;;;;AAMA;AACA;AACA;;AAEH;;AAnQG;AACF;AA8BE;AAIF;;AAmDA;;AAWA;;AA0IE;AACF;AAKE;AACE;AACA;;AAEJ;;AC/WI;AACJ;AACF;;ACPA;AAqBgB;AACd;AACA;AACA;AACA;AACE;AACF;AACF;AAEgB;AACd;AACA;AACA;AACA;AACE;AACF;AACF;;ACjCA;AAQA;AACE;AACF;AAiCA;AACE;;;AAMF;AAEA;AAGE;AACF;AAEA;AACE;AACF;AA6BA;AACE;AACE;AACE;AACA;AACE;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACF;AACF;AACD;AACE;AACA;AACE;AACE;AACD;AACF;AACF;AACD;AACE;AACA;;;AAGC;AACF;AACD;AACE;AACA;AACE;AACD;AACF;AACF;AACF;AAEM;AACA;AACL;AACA;AACA;;AAE6B;AAEzB;;;AAOJ;;;AAGE;;;;;;;AAOF;AACF;AAEO;AACA;AAKP;AACE;;;;AAMA;;;AAGI;AACA;;AAEF;AAEF;AACF;AAIM;;AAKJ;AACA;;;;;AAQI;;;;;;;AAOF;AACA;AACF;AACA;AACF;AAEM;AAGJ;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAKA;AACA;AACA;AACE;;;;AAMF;AACA;AACA;AACE;;;;AAMF;AACE;;;;AAMF;AACE;;;AAIJ;AACF;;AClRA;AAIA;AAAA;;;;AACE;AAEE;;;AASA;AACE;;;;;;AAMM;;;;AAQR;;;;AAKA;AACA;;;;;AAKH;;;ACpBD;AAWA;AASA;AACE;AACF;AAGA;AAAA;;;;;;;;;;;;;AACE;AACE;;AAGF;;;AAcA;AACE;;AAEF;AACE;;AAIF;;;;AAIE;AACE;;;AAGF;;;;AAOE;;AAEF;;AAGF;AACE;;AAEF;AACE;;AAOF;AACE;AAEA;AACE;AACE;;AAED;AAED;AACA;AAEA;;;AAIA;AAEA;AAEA;;;AAEA;AACA;AACA;AACA;;;AA+FJ;AACE;AACA;AACA;AACA;;AAuCF;AAIE;;;;AAQA;;AAGA;AACE;AACA;;;AAEA;AACA;;AAEF;;AAGE;AACA;AACA;AACE;;;;AAUN;AACE;;AAEF;AACE;AACA;AACE;;;AAEA;AACA;;AAGF;AACE;AACA;AACA;;;AAEA;AACA;;;;;AAMF;;AAEH;;AAtMG;AAEA;;;AAKA;AACA;AACE;AACA;;;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACE;AAGA;;AAIA;;AAOA;;AAEA;AAIA;;AAGA;AACE;AAGA;;AAEF;AACE;AACA;AACA;AACE;;;;;AAKV;AAEE;;;AAOA;;AAGI;AAIA;;AAGA;AACE;AAGA;;AAEJ;AAGF;AACF;AASE;AAEA;AACA;AACF;AAGE;AAEA;AACA;AAKA;AAGA;;;AAUA;AACE;;;AAEA;;AAEJ;AAoCE;AACA;AACF;;AC3RF;AACA;AACA;AAEO;AACP;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEO;AACP;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEO;AACP;AACA;AACA;;ACzYA;AAEO;AAEP;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;ACnbA;AAEO;AAGA;AACL;;;;;;AAQK;AAyBP;AAGE;;AAkDA;;;;AAjDE;;;AAKF;AACE;;AAKF;AACE;;AAEF;AACE;;;AAIA;;AAGE;AACE;;;AAGF;AACE;;;;AAKJ;;AAIA;AAEA;;AAEA;;AAIA;AAEA;;AAIF;;;AAkBA;;;AAUA;;AAGE;AACA;AAEA;;AAGF;AACE;AACA;;AAEE;;;;AAIA;;;;AAIA;;;;AAMF;;AAGA;;AAGF;AACE;;AAGA;AACA;AAEA;AAEA;AACA;;AAGF;AACE;AACA;;AAEE;;;;AAMF;;AAGA;;;AAIA;;AAIA;AACA;AAEA;;AAGF;;AAGE;AACA;AAEA;;AAKF;;;;AAIE;AACA;;AAwIH;;AAtSG;AACF;AA4CE;AACA;AACE;;;AAIF;;AAEA;AACF;;AAUA;AAEE;AACA;AACF;AAiGE;;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACF;;;;;;;;;AAYU;;;AAGA;;;;;;;AAOA;;;AAGN;AACE;;AAEN;;AAIA;;AAGA;;AAGA;AAGE;AACF;AAEE;AACF;AAEE;AACF;AAGE;AACA;AACF;AAEE;;;AAGF;;AAIE;AAEA;;AAEF;;AAII;;;;AAGA;;;;;;AAQE;;;AAEA;;;;;AAME;;;;AAGA;;;;;;AAOJ;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;AAED;;AAGF;AACA;AACF;;;ACnVF;AAaO;;;;;;;AA8CP;AAGE;;;;;;AA6CA;AAKA;;AAcE;;;AAeF;AAqDA;AA2GA;;AA7OI;;AAGF;AACE;;;AAUJ;AACE;;;;;;;;AAsBE;;;AAOJ;;;AAKA;;;;AAIE;AACA;AACA;;AAEE;;;AASJ;AACE;;AAgEF;;;AAIA;AACE;;AAOF;;AAEI;;;AAIF;AACE;;;;AAKA;;;AAIF;AACE;;;AAIF;AACE;;;AAIF;AACE;;AAGF;AACA;AACE;;;;AAMF;AAEA;AACE;;;;;;;AAWA;AAIA;;AAIE;AAEE;AACE;;AAGF;;;;;AAQF;;;AAIF;AACA;AACA;AACA;;;;AAIA;AACA;AACF;AACA;;;AAWF;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAqEF;;;;AAMI;AACA;AACA;;;;;AAzTF;;;AAGF;AAiDE;;AAKF;AAGE;AACA;AAIF;AAEE;;AAEA;AACE;AACA;AAIA;;;AAGF;;AAEE;AACA;AACA;AACE;;;;AAGF;;AAEJ;AAGE;AACE;;;AAGF;AACA;AAGM;AACF;AAEJ;;;;;AAKA;AACF;AAuHE;AACF;AAYE;AACA;;AAEI;AACA;;AAEE;;;;;;;AAWA;;;;AAGE;AACE;;AAEJ;;;;AAIF;;;AAEA;;;;;AAIA;AACA;;;AAMA;;;AAEA;;;AAGJ;;;AAGA;;AAIE;;AAEE;;;AAIA;;AAEF;;AAEF;AACF;;AAgBE;;AAEC;AACH;;AAGE;;AAEC;AACH;AA/VgB;AAkWlB;;ACnaA;AAEO;;;;;;;;;;;;;;;;;AAgDH;AACE;;AAGF;;;;;;AAKE;;;AAIF;;;;;;AAiBF;;AAEA;AACF;AAGgB;;AAEd;AACF;AAWgB;;AAEd;AACF;AAGiD;AAGT;AACD;AACD;AAEpC;;ACvHF;AAEO;AACA;AAEA;AAMS;;AAEd;AACF;AAGoCE;AACAA;;;ACFpC;AAEA;;;;;;;AAUA;;AAEE;AACF;AAEA;;;;AAKA;AAEE;AACE;;AAKF;AAKE;;;AAPF;;;AAqEA;;;;;;;AAgJA;AA7ME;AACA;AACA;AACA;;AAGF;AACE;;AAGF;AACE;;AAEF;AACE;;AAKF;;;;AAIE;AACE;;;AAIF;AAEA;;AAEE;AACE;;;;AAKF;;AAEF;AAEA;;AAKF;;;;;AAKE;AACE;;;AAGF;;;AAMF;;;;;AAKE;AACE;;;AAGF;;;AAKF;AACE;;AAIF;AACE;AACA;;;;AAGE;AACA;;;AAGJ;AACE;AACA;AACA;AACA;;AAGF;AACE;;AAEF;AACE;;;;AAMA;AACA;;;AAIA;AACA;;;AAGA;;;;AA0GA;;AAEH;;;AAtGG;AACA;AACA;AACF;;AAIA;AAWE;AACA;AACA;AACA;AACF;;AAKE;;AAEA;AACF;AAEE;AACA;AACA;AACF;AAEE;AACF;AAIE;AAOF;;;AAOI;AACE;;AAEF;;AAEA;;;AAGA;;AAKM;AACF;;AAGJ;AACE;;AAEF;AACE;;;AAGN;AAKE;AACA;AACF;AAEE;AACA;AACF;;AAKA;;;ACnIF;AAEO;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAkDK;;;;;;;;;;;;;;AAmBP;AACE;AACE;;AAGF;AACE;;AAGF;;AAsLA;;;AAoIA;;;AA+WA;;AASA;AAiBA;;;;;;;;;AAySA;;;;;;AAx+BE;AACG;;AAIH;AACG;;;AAOH;AACG;;AAIH;AACG;;AAIH;AACG;;AAIH;AACG;;AAIH;AACG;;AAIH;AACG;;AAIH;AACG;;AAGH;AACG;AAEH;AACG;;AAIH;;;;;AAKA;AACA;AACE;;;;AAIE;;AAEE;AACD;AACD;;;AAEA;;;AAIA;;AAEE;AACD;AACD;;;AAEA;;;AAIA;;AAEE;AACD;AACD;;;AAEA;;AAEJ;AACA;AACE;;;;AAIE;;;AAGA;;AAEJ;AACA;AACE;;;;;;AAMA;AACE;AACE;;;AAGN;AACA;AACE;;;AAGA;AACE;;AAEJ;;;;AAII;AACE;AACE;AACA;;AAED;;;AAKP;;;;AAII;AACE;AACE;AACE;AACA;AACD;;;;AAMT;AACA;;AAEE;;;;AAIA;;;AAIA;;;;AAIA;;;AAYJ;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAMF;;;;AAIE;AACE;;;AAIF;AACE;;;AAGA;AACE;AACF;AACE;AACF;AACE;;AAGJ;;;;;AAWA;;AAEE;AACE;AACE;AACE;;;AAGJ;;;AAGI;;AAEK;AACH;AAEE;;;;;;;;AAQF;;;;AASN;;;AAGI;;AAEK;;;;AAIH;;;;;;AAKA;;;;;;AASV;;;AAGA;AAEA;;;AAMK;AACH;AACA;;;AAGF;;AAGF;;;AAqEA;AACE;;AAKF;AACE;AACA;AACA;;;AAIA;AACA;AACA;;AAIF;;;;AAIE;AACA;;AAIF;;;;AAIE;AACA;;AAIF;AACE;;AAEF;AACE;AACA;AACE;AACA;AAGI;AACF;;AAKJ;;;AAIA;;;AAEO;AACL;;;;AAGE;;;;;;;;AAQN;AACE;AACE;;AAEA;AACA;AACA;AACE;AACF;AACE;;;AAGN;AACE;AAEE;;AAuNJ;AACE;;AAKF;;;AAkBA;AACE;;AAGF;AACE;;AAEF;AACE;;AAEF;AACE;;AAGF;AACE;;AAEF;AACE;;AAGF;AACE;;AAEF;AACE;;AAGF;AACE;;AAEF;AACE;;AAEF;AACE;;AAGF;AACE;;AAIF;;;AAGA;AACE;;AASF;AACE;;AAGF;AACE;;AAGF;AACE;;AAIF;;;;AAME;AACA;;AAIF;;;;AAIE;AACA;;AAIF;AACE;;;AAMA;;AAIF;AACE;;AAIF;;;AAaA;AACE;;AAEF;AACE;;AAEF;AACE;AACE;AACE;;AAEF;AACF;;AAGF;AACE;;;AAMA;;;;AAIA;AACA;;AAGF;AACE;;;AAIA;;AAMF;AACE;;AAEF;AACE;;;AAIA;;AAEA;;AAKE;;;AAKJ;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAIF;AACE;;AAEF;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAOF;AACE;;AAYF;AACE;AACA;;AAEF;;;AAGA;;AAKE;AACA;;AAEF;AACE;;AAEF;AACE;AACA;;AAEF;AACE;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAKF;;;;AAIE;AACE;;;AAGF;AACA;;;AAMF;;;AAMA;AACE;;AAEF;AACE;;;;;AAKF;AACE;;;;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAGF;;;;AAOE;AACA;;AAEE;;;AAGD;;AAGH;AACE;;;;AAOA;AACA;;AAEE;;AAED;;AAKH;;;AAGA;AACE;;AAKF;AACE;;AAEE;;AAEF;;AAEF;AACE;;AAEE;;AAEF;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;;AAEF;AACE;;AAEF;AACE;;AAGF;AACE;;AAKF;;;AAGA;AACE;;AAMF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;;AAEF;AACE;;AAEF;AACE;;AAOF;AACE;AACA;;;AAGA;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;AAMF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAKF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;;;AAIF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAEF;AACE;AACA;;AAGF;AACE;;AAGF;AACE;;;;;AAt4CF;AAUE;AACF;;AA6CA;;AAqFA;AAGE;;;AAII;;AAEF;AACF;AACF;;;;;AAUE;;;;;;;;;AAeA;;;AAKA;;;AAKA;;;AAKA;AACF;AAEE;;AAGI;AACD;AAEH;AACF;;AAOA;AAsFE;AAEA;AACE;;AAGE;AACA;AACE;;AAEF;;;;AAGF;AACE;AACA;AACA;;;AAIJ;;AAGE;AACE;;;AAIJ;AACF;AAGE;;AAEC;;;AAGC;;AAEJ;;AAII;AACA;AAEF;AACE;AACE;AACE;;;AAGJ;AACE;;AAEF;AACE;;;AAGN;AAGE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACF;AAEE;AACA;AACF;;;AAQI;;;AAGE;;AAGF;AACE;;;AASO;;;AAOA;;;AAOA;;;AAOA;;;AAOA;;;AASA;;;AASA;;;AAOA;;;AAKA;;;AAOA;;;AAOA;;;;AAQL;;;;AAKN;;;;AAOA;AACF;;AAGI;;AAEF;AAEE;;;AAIF;AACF;AAgBE;AACA;AACE;;;AAGF;;AAEA;AACF;;AA8PA;AAGE;;AAEF;;AAkJA;;AAoDA;AA8BE;AACF;;AA6DA;AAl1BO;AAuXA;;;AC75BT;AAEO;;;;;;;;;;;;;;;;;;AAoHP;AACE;;AAOA;;;AAoFA;AACA;AA4DA;;;;;;;;;AAwJA;AAmCA;AAoBA;;AAqEA;AASA;AA4yBA;AAkhCA;;AA8GA;AACA;AAqJA;;AAKE;AACA;AACA;AACA;AACA;;AA2IF;AASA;AAOA;AACA;AA3pFE;;AAEA;;AAQF;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAKF;;;;AAIE;AAIA;;;AAIA;;AAIE;AACD;AACD;;AAGF;;;AAIA;AACE;;AAEF;AACE;;AAEF;AACE;;AAyFF;;;;AAIE;AAEA;;AAKF;;;;AAIE;;;;;;;AAcA;;AAEE;;AAEF;;AAGA;;AAEE;AACA;;AAGA;;AAEE;AACD;AACD;;AAIG;;AAGL;;AAEC;;AAGH;AACE;AACE;;;AA4FJ;;;;AAIE;;;AAIA;AAGA;AACA;AACA;AAGA;AAIA;;AAEC;;AAIH;AACE;;AAQF;;;AAoBA;;;AAqBA;AACE;;AA4BF;;AAIE;AAEA;AAEA;;;;;AAKE;AACA;;;;AAKJ;;;;AAIE;;AAKF;;;AAIA;AAGE;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKE;AACA;;;;AAKJ;AAKE;AACA;AACE;;;;;AAIF;;;;AAOA;;;AAIE;;AAGF;AACA;AACA;;AAGF;AAKE;;;;;;AASE;;AAOF;AACA;AACA;;AAEF;;;;;AAKE;AACA;;;;;;;;;;;;;AAmBF;AACE;AACA;;AAEC;AACD;;;;;;AAMA;;AAEF;AACE;AACA;;AAEC;AACD;;;;;;AAMA;;AAEF;AACE;;AAEF;AACE;AACA;;AAEC;AACD;;;;;;AAMA;;AAEF;AAKE;AACA;AAGA;;AAEC;AACD;;;;AAKE;;AAGF;;;AAGA;AACE;AACD;AACD;;;;;;AAMA;;AAEF;;AAKE;;AAEC;AACD;;;;;;AAUA;;AAEF;;AAKE;;AAEC;AACD;;;;;;AAOA;;AAEF;;AAKE;AACE;AACA;AACD;AACD;;;;;;AAOA;;AAEF;AAIE;;AAEC;AACD;;;;;;AAUA;;AAEF;AAIE;;AAEC;AACD;;;;;;AAUA;;AAGF;AACE;AACE;AACA;AACD;AACD;;;;;;AAOA;;AAEF;AAKE;;AAGA;AACA;;AAEC;AACD;;;;AAKE;;AAEF;;AAEF;;;AAGA;;;AAGA;;;AAGA;;;;AAIE;AACE;AACA;AACA;AACA;AACD;AACD;;;;;;AAMA;;AAGF;AAKE;AAGA;AACA;;AAEC;AACD;;;;AAKE;;AAMF;;AAEF;;;AAGA;;;AAMA;;;AAMA;;;;AAOE;AACE;AACA;AACA;AACA;AACD;AACD;;;;;;AAMA;;AAGF;AACE;;AAEF;AACE;;AAEF;AAKE;;AAEA;AACA;;AAEC;AACD;;;;AAME;;AAMF;;AAGF;AAIE;;;AAQE;AACA;AACA;AACF;AAEA;;AAEC;AACD;;;;;;AAUA;;AAGF;AAKE;;AAMF;AAKE;;AAOF;;AAME;;;AAIE;AACE;AACA;;AAEF;AACE;;AAEF;AACE;;;;AAIJ;;;;AAKE;;AAOF;;AAGF;;;AAGA;;;AAGA;;;;AAME;AACE;AACA;AACD;AACD;;;;;;AAQA;;AAGF;AACE;;AAEF;AACE;;AAEF;AACE;;AAIF;AACE;;AAIF;AAKE;;AAEA;AACA;;AAEC;AACD;;;;AAME;;AAMF;;AAGF;AAIE;;;AAQE;AACA;AACA;AACF;AAEA;;AAEC;AACD;;;;;;AAUA;;AAGF;AAKE;;AAMF;AAKE;;;AAQA;AACA;;AAEC;AACD;;;;;;AAOA;;AAGF;;AAME;;;AAGE;AACE;AACA;;AAEF;AACE;;AAEF;AACE;;;;AAIJ;;;;AAKE;;AAOF;;AAGF;;;AAGA;;;AAGA;;;;AAME;AACE;AACA;AACD;AACD;;;;;;AAQA;;;;;AAqBE;;;;;;;AA2OA;;;AAiDJ;;;;AAoBI;;;;;;;AAoEA;;;;;;;AA+EA;;;;AAkFF;AACE;;;;;;AAcA;;;;;AAqSA;;;;;;AAQA;;;AAwDJ;AACE;;AAGA;;;;;AAqDF;AASE;AACA;;AAGA;;;;;AA2FF;AAUE;AACA;;AAGA;;;;;AAqGF;AACE;;AAOF;AACE;;;;AASA;;;;AAOE;;;AAYJ;;;AAGA;;;;AAIE;;AAEE;;;;;;;;AAUF;AACE;;;AAGJ;AACE;;AAEF;AACE;;;;;AAKF;AACE;;AAEF;AACE;;AAEF;AAGE;;AAEF;AAGE;;;;;AAQF;AACE;;;;AAIF;AACE;;AAEF;AACE;AACA;;AAEC;AACD;;;;;;AAMA;;;;;;;AA8DA;;AAGE;;;AAWJ;;;AAaA;AAIE;;;AAIA;;;;AAKA;AACA;;AAiCF;;;AAMA;;;AA+JA;AAME;AACA;AACA;;;;AAKA;AAEA;AACA;AACA;AACA;;AAKF;AACE;;AAEF;AACE;;;AAGA;;AAEF;;;AAOA;;;;AAkBE;;;AA+BA;;;;;;;;AA2BF;AACE;;AAGF;;;AAQD;;AAz0FG;AACF;AAoDE;;;AAGA;AACA;;;;AASA;AACA;AACA;;;AAKF;AAME;;;AAGA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACE;;;AAGJ;AAEE;;AAOA;AAEA;AAEA;AACE;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAIJ;AAIE;AACA;AACA;AACA;AACA;AACF;AA8EE;AACA;;;AAGC;;AAGC;;;AAEA;;AAEJ;AAGE;AACA;AACA;AAEF;AAGE;AACF;AAGE;;AAGF;AAKE;;AAEA;;;;AAIC;AACH;AAIE;;AAEA;;;;;AAKC;AACH;AAIE;;AAEA;;;;AAIC;AACH;;;;;AAOE;;AAEF;AA8CE;;;AAGA;AACE;;;AAGA;;AAEJ;AAYE;;;AAGA;AACE;;;AAGA;;AAEJ;AAQE;AACE;;AAED;AACH;AAEE;AACA;AAGA;AAGF;AAEE;;;AAIA;AAIF;AAwvBE;AAEA;AACA;AACA;AACF;AAiBE;;AAEF;AAGE;;AAEF;;AAGE;AACF;AAEE;AACA;AACF;AAEE;AACA;AACF;;;AAOE;AACA;;;AAKA;;;AAGE;;;AAIF;AACE;AACA;AACD;AAED;AACA;;;;;;;;;;;AAaF;AAME;AAMF;AAOE;AACE;AACA;AACA;AACA;;AAEF;AACF;;AASE;AACE;AACA;AACA;AACA;;AAEF;AACF;AAKE;;AAEA;;AAEF;AAUE;;AAEA;;AAOF;AAIE;AACE;;AAGF;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACF;AAEE;AACA;AACF;;AAGA;;AAMA;AAaE;AACE;AACA;;AAEF;AACA;AACA;AACF;AAQE;AAEA;AACA;AAOA;;AAGA;AACA;AACE;;;AAKF;AACA;AACA;AACA;AACE;;AAEF;AACF;AA+BE;AAEA;AACA;AAQA;;AAGA;AACA;AACE;;;AAKF;AACA;AAEA;AACA;AACA;AACA;AACE;;AAEF;AACF;AAqCE;AACA;AAOF;AAOE;AAEA;AACA;;AAQA;AACA;AACE;;;AAKF;AACA;AACA;AACA;AACE;;AAEF;AACF;AA2BE;AACA;AACA;AAOF;AAQE;AAEA;AACA;AAQA;;AAGA;AACA;AACE;;;AAKF;;AAEA;AACA;AACE;;AAEF;AACF;;AAoCE;;AAGA;AACA;AACE;AACA;AACA;AACA;;AAEF;AACF;AAQE;AAEA;AACA;;AASA;AACA;AACE;;;AAKF;;AAEA;AACE;;;AAGA;;;;;;;AAMF;AAEA;AACA;AACE;;AAEF;AACF;;AAwCE;AACA;AAGA;AAIA;AAIA;AAIA;AAOA;AACE;AACA;;;;AAKF;AACF;;AAeE;;;;AAIA;;;AAIA;AAEA;;;;;AAOA;AACE;AACA;;AAGF;AACF;;AAeE;;;;AAIA;;;AAIA;;AAIA;AAGA;AACE;AACA;AACA;AACA;;AAEF;AACF;AAQE;;;;AAIA;AACA;AAEA;AAOA;AACA;AACA;;;AASA;AACF;AASE;AAIA;AACA;AAOA;;;;AAMA;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AACE;;;AAIF;AACA;AAGA;;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACE;AACA;AACA;AACA;AACA;AACE;;;AAGJ;AACE;AACA;AACA;AACA;AACA;AACE;;;AAKJ;;;;;AAKA;AACA;AAGA;AACE;;;AAOA;;;;;;;AAUA;AAEE;AAEA;;AAGG;;;;AAKL;;AAGF;AACF;AA2BE;;AAKE;;AAGE;AACA;AACA;AACA;AAEA;AAOA;AACE;;;AAGN;;AAGE;;AAGE;AACA;AACA;AACA;AAEA;;AASJ;AACF;AAqBE;AAEA;AACA;;AAQA;AACA;AACE;;;AAMF;;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACE;AACA;AACA;;AAGF;AACF;AA+CE;AAEA;AACA;AAQA;;AAGA;AACA;AACE;;;AAMF;;AAEA;AACA;;AAYA;AACA;AAGA;AACE;;AAWA;;AAGF;AACF;AAiDE;AAKA;AACA;AACA;AAMA;AACA;AAOA;;AAGA;AACA;AACE;;;;;AAQF;AAIA;AAEA;AACA;;;AAGE;AACE;;;AAGF;AAEA;;;;AAKA;AACF;;AAKA;AACA;AAEA;AACF;AAsHE;AACA;;;;AAII;AACA;;;AAGA;AACA;;;;;;;AAOF;;AAEJ;AAOE;AACA;AACA;;;;AAKA;AAEA;AACA;AACA;AACA;AACF;;AA2CA;AAqBE;;;AAIA;AACF;AAEE;;;AAGA;AACA;AACF;AAEE;;;AAGA;;;AAGA;AACA;AAIF;AA4BE;AASE;;AAEA;AAMA;;;AAIA;AAWA;;AAGI;AAEA;;AAGA;;AAGA;AAEJ;AACF;AACF;AAEE;AAEE;AACF;AACF;AAGE;AAEE;AACF;AACF;AAGE;AACA;AAEE;AACF;AACF;AAIE;AAEE;AACF;AACF;;AASE;AAQA;;AAMA;AACA;AACA;AAEF;AAEE;;;AAIE;;;AAIF;AACF;AAME;AACA;;;AAGI;AACA;;;AAGA;AACA;;;;;;;AAOF;;AAEJ;;;AC75FF;AACE;AACD;AAoBD;AAOE;;AANA;;;;;;AAWE;AACA;;AAGF;AACE;AACA;;AAEA;AACA;AACE;;;AAEA;;;AAuEL;;AAlEG;AACF;AAGE;AACE;AACA;;;AAIF;;AAEE;AAEF;AACA;;AAMA;AACE;AACA;;;;AAiBM;;;;AAIA;;;;AAIA;AACA;;AAEF;;AAEJ;AAEA;;;;AASF;AACF;;;ACrHF;AAEO;AAGA;AA4BP;AAAA;AAME;AAEA;;AANA;AACE;;;AAOA;;AAGF;;;;AAMI;;AAEF;AAEA;;AAEE;;;AAGA;AACE;;;;AAKF;AAEA;AAEA;;;AAEA;;;AAGL;;;;AClDD;AAWA;AACE;AAGF;AACA;AAIO;AAQA;AACL;AACA;AACA;;;AAqCF;AACE;;;AAeA;;;;;;;;;AAdE;;;AAKF;AACE;;AAIF;;;AAQA;AACE;;AAKF;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAKF;;;AAKA;;;AAIA;AACE;;AAEF;AACE;;AAEF;;;AAgBA;;AAEI;;;AAKF;AAEA;AAEA;AACE;;;;AAKA;;AAEF;;AAGE;AACE;;AAEF;AACE;;;AAIJ;;AAIA;AACA;;;;AAIC;AAED;;;AAmFA;AACE;AACA;;;;;;AAcF;AACA;;AAIF;;;AASE;AACA;;AAKF;;;AAIA;;;;;AApNE;AACF;AAuCE;AACE;;AAEA;;;AAGJ;AA+CE;AACA;AACE;;AAKF;AACF;AAEE;AACA;AACE;;AAKF;AACF;;AAII;AACE;;AAGF;AACA;;AAGE;AACE;;AAEF;AACE;;;AAIJ;AACF;;AAEE;;AAEF;AACF;;;AAWI;;;AAGD;AACH;AAGE;AACF;AAGE;;;;;;;;AAQA;AACF;AAeE;AACE;;AAEJ;AAqBO;AAIA;AAIP;;AAEI;AACA;AACE;;AAEF;AACE;;AAEJ;AACF;;AClWI;;;;;AAUF;;AAGA;;;;;;AAME;;;;;AAIE;AACE;;;AAGE;;;;;;AAMV;AACF;AAEM;;;AAQF;;;;AAMA;;;AAGI;;;;AAKF;;AAEJ;AACF;;;AC9CA;AAUqE;AACnE;;;AAIF;AAAA;;;;AA+BE;;AA9BA;AACE;;AAEF;AACE;;AAKF;AAEE;;AAOF;;;;AAIE;AACA;AACE;;;AAGF;;AAIF;;;;AAIE;AACA;AACE;;;AAGF;AAEA;AAEA;AACE;;;AAIJ;AACE;;AAGF;AACE;AACA;;AAEF;AACE;;;AAIF;AACE;;AAEF;AACE;;;;AAUA;;;;AAKA;AACA;;;;;AAWF;AACE;AACA;;;AA+BH;;;AAnCC;;;;AAoBI;AACE;AACA;AACA;;AAGF;AACE;;AAGF;AACE;;;AAGN;;;AC3HF;AAEO;;;;;;AAQA;AACL;;;;;;;;AAsCF;AAAA;;AAoBE;AAKA;AAyCU;AAaV;AA2CA;AA0HA;AA4BA;AA0CA;;AAzTA;;;AAoBA;;;AAQA;AACE;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;;;;;;;AAmBF;;;;AAIE;AACA;;AAKF;;;;AAIE;AACA;;AAOF;;;;AAIE;AACA;AACA;AAEA;;AAEC;;;AAIC;AACA;AACE;AACA;;AAGE;;;;;AAKR;;;;;;;AAwCU;;AAER;AAOA;;AAwGF;;;;AAWE;;AAYF;;;;AAeE;AACA;;;AAGA;AACA;;;AAGA;AAEA;;;;;;;AASF;;;AAIU;AACR;;;;;;;;;;;;AA4BA;;;AAGE;;;;;AAIF;;;;;AAQI;AACA;AAID;;;AAED;;;AAKJ;AACE;;AAEA;;AAKA;AACA;AACA;AAIA;;AAEA;;AAEA;;AAEA;AACA;;AAWQ;AACR;AACA;;AAEE;AAEA;AACA;AACF;;AAGF;AACE;;AAEQ;;AAER;;;;AAIA;;AAEQ;AACR;;AAGQ;;AAKN;;AAED;;AAGO;;AAEN;;AAED;;;;AAzbD;AACA;AACA;;AAEE;AAEA;;AAGF;AAEF;;AAmGA;AAQE;;;AAGA;;AAGE;;;AAIF;;AAEI;;;;AAKJ;AACA;AACF;;;;AAoBI;;AAEI;AACA;AACA;;;AAGJ;;AAEI;AACA;AACA;;;AAGJ;;AAEI;AAIA;;AAKA;AAEA;;;AAGJ;;AAEI;AAIA;;;AAGJ;;AAEI;;;AAGA;AAEA;;AAIA;AACA;;;AAGJ;;AAEI;;;;AAQA;;AAGA;;;AAGJ;AACE;;;AAIJ;AACE;;AAEJ;;AAMA;AAEE;AACA;AACA;;AAEC;AACD;AACE;;AAEJ;;;AAUA;;AAQA;AAEE;AACA;AACA;AACF;AAKE;AACF;;AAIA;;AAGA;;;;AAsCI;;;;AAIF;;AAEF;;;AAiEI;AACA;;AAEF;AACF;AA7VO;AAoDA;;;;AAIN;;;AC1KH;AAEA;AAAA;;;;;;;;;;AAoNE;;AAjNA;;;;AAIE;AACE;;;AAIF;AAEA;;;AAIA;AACA;AAEA;;AAEF;AACE;;AAEF;AACE;;AAEF;AACE;;AAGF;AACE;;;AAGA;;;;;;;;AAsDA;AACE;;AAII;AACF;;AAIJ;AACA;;;;;;AAQF;AACE;;;;;;;AAKE;;;AAKJ;;AAEE;AACA;;;AAIA;AAEI;AACA;AACD;;AAuFN;AAnFuB;;AAEtB;AAWE;AACA;;AAGF;AAEE;;AAIA;AACA;AACF;AAEE;AAEA;AAEA;AACE;AAEA;AACF;AAEA;AACA;;;;;AAKF;AAEE;AACF;AAIE;AAOF;;AAII;AACE;;AAEF;;AAEA;AACE;;AAEF;AACE;;;AAGN;AAKE;AACF;AAEE;AACF;;AC7EW;;;;AAMA;;;;;","x_google_ignoreList":[0,8,34,38]}