/**
 * @copyright Zack Qattan 2024
 * @license MIT
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).BrilliantSole=t()}(this,(function(){"use strict";const e=!1;function t(){}const n=console.log.bind(console),s=console.warn.bind(console),r=console.error.bind(console),i=console.assert.bind(console);class a{static#e={};constructor(e){if(a.#e[e])throw new Error(`"${e}" console already exists`);a.#e[e]=this}#t={log:e,warn:e,error:e};setLevelFlags(e){Object.assign(this.#t,e)}static setLevelFlagsForType(e,t){if(!this.#e[e])throw new Error(`no console found with type "${e}"`);this.#e[e].setLevelFlags(t)}static setAllLevelFlags(e){for(const t in this.#e)this.#e[t].setLevelFlags(e)}static create(e,t){return this.#e[e]||new a(e)}get log(){return this.#t.log?n:t}get warn(){return this.#t.warn?s:t}get error(){return this.#t.error?r:t}get assert(){return this.#t.assert?i:t}assertWithError(e,t){if(!e)throw new Error(t)}}function o(e,t){return a.create(e,t)}const c=o("EventDispatcher",{log:!1});class h{constructor(e){c.assertWithError(Array.isArray(e)||null==e,"eventTypes must be an array"),this.#n=e}#n;#s(e){return!this.#n||this.#n.includes(e)}#r(e){c.assertWithError(this.#s(e),`invalid event type "${e}"`)}#i;addEventListener(e,t,n){if(c.log(`adding "${e}" eventListener`,t),this.#r(e),this.#i||(this.#i={}),n?.once){const n=t;t=function t(s){n.apply(this,arguments),this.removeEventListener(e,t)}}const s=this.#i;s[e]||(s[e]=[]),s[e].includes(t)||s[e].push(t)}hasEventListener(e,t){return c.log(`has "${e}" eventListener?`,t),this.#r(e),this.#i?.[e]?.includes(t)}removeEventListener(e,t){if(c.log(`removing "${e}" eventListener`,t),this.#r(e),this.hasEventListener(e,t)){const n=this.#i[e].indexOf(t);return this.#i[e].splice(n,1),!0}return!1}dispatchEvent(e){if(this.#r(e.type),this.#i?.[e.type]){e.target=this;const t=this.#i[e.type].slice(0);for(let n=0,s=t.length;n<s;n++)t[n].call(this,e)}}}function g(e,t,n){c.log("bindEventListeners",{eventTypes:e,boundEventListeners:t,target:n}),e.forEach((e=>{const s=`_on${r=e,r.replace(/(?:^\w|\b\w)/g,(function(e){return e.toUpperCase()})).replace(/\s+/g,"")}`;var r;c.assertWithError(n[s],`no event "${s}" found in target`,n),c.log(`binding eventType "${e}" as ${s} from target`,n);const i=n[s].bind(n);n[s]=i,t[e]=i}))}function l(e,t){Object.entries(t).forEach((([t,n])=>{e.addEventListener(t,n)}))}function d(e,t){Object.entries(t).forEach((([t,n])=>{e.removeEventListener(t,n)}))}const u=o("ConnectionManager");class v{static#a=["isConnected","connectionStatus","deviceInformation","batteryLevel","data"];static get EventTypes(){return this.#a}get eventTypes(){return v.#a}#o=new h(this.eventTypes);addEventListener(e,t,n){return this.#o.addEventListener(...arguments)}_dispatchEvent(e){this.#o.dispatchEvent(e)}removeEventListener(e,t){return this.#o.removeEventListener(...arguments)}static#c(e){throw new Error(`"${e}" is not implemented by "${this.name}" subclass`)}#h(e){throw new Error(`"${e}" is not implemented by "${this.constructor.name}" subclass`)}static get isSupported(){return!1}get isSupported(){return this.constructor.isSupported}static get type(){this.#c("type")}get type(){return this.constructor.type}#g(){u.assertWithError(this.isSupported,`${this.constructor.name} is not supported`)}#l(){u.assertWithError(this.constructor!=v,`${this.constructor.name} must be subclassed`)}constructor(){this.#l(),this.#g()}#d="not connected";get connectionStatus(){return this.#d}set connectionStatus(e){this.#d!=e?(u.log(`new connection status "${e}"`),this.#d=e,this._dispatchEvent({type:"connectionStatus",message:{connectionStatus:this.connectionStatus}}),"connected"!=this.#d&&"not connected"!=this.#d||this._dispatchEvent({type:"isConnected",message:{isConnected:this.isConnected}})):u.warn("same connection status")}get isConnected(){return"connected"==this.connectionStatus}#u(){u.assertWithError(!this.isConnected,"device is already connected")}#v(){u.assertWithError("connecting"!=this.connectionStatus,"device is already connecting")}#p(){u.assertWithError(this.isConnected,"device is not connected")}#f(){u.assertWithError("disconnecting"!=this.connectionStatus,"device is already disconnecting")}async connect(){this.#u(),this.#v(),this.connectionStatus="connecting"}get canReconnect(){return!1}async reconnect(){this.#u(),this.#v(),u.assert(this.canReconnect,"unable to reconnect"),this.connectionStatus="connecting"}async disconnect(){this.#p(),this.#f(),this.connectionStatus="disconnecting"}async sendCommand(e){this.#p(),this.#f()}}function p(e){return`6e40000${e}-b5a3-f393-e0a9-e50e24dcca9e`}function f(e){return BluetoothUUID.getCharacteristic(e)}function m(e){return BluetoothUUID.getService(e)}const y=Object.freeze({services:{deviceInformation:{uuid:m("device_information"),characteristics:{manufacturerName:{uuid:f("manufacturer_name_string")},modelNumber:{uuid:f("model_number_string")},hardwareRevision:{uuid:f("hardware_revision_string")},firmwareRevision:{uuid:f("firmware_revision_string")},softwareRevision:{uuid:f("software_revision_string")}}},battery:{uuid:m("battery_service"),characteristics:{batteryLevel:{uuid:f("battery_level")}}},data:{uuid:p("1"),characteristics:{command:{uuid:p("2")},data:{uuid:p("3")}}},firmware:{uuid:f(65113),characteristics:{firmware:{uuid:"8ec90003-f315-4f60-9fb8-838830daea50"}}}},get serviceUUIDs(){return[this.services.deviceInformation.uuid,this.services.battery.uuid,this.services.data.uuid,this.services.firmware.uuid]},getServiceNameFromUUID(e){return Object.entries(this.services).find((([t,n])=>e==n.uuid))?.[0]},getCharacteristicNameFromUUID(e){var t;return Object.values(this.services).some((n=>(t=Object.entries(n.characteristics).find((([t,n])=>e==n.uuid))?.[0],t))),t}}),b=y.serviceUUIDs;const E=o("WebBluetoothConnectionManager",{log:!1});class w extends v{constructor(){super(),g(["characteristicvaluechanged"],this.#m,this),g(["gattserverdisconnected"],this.#y,this)}#m={};#y={};static get isSupported(){return"bluetooth"in navigator}static get type(){return"web bluetooth"}static#b=new TextDecoder;get#E(){return w.#b}#w;get device(){return this.#w}set device(e){this.#w!=e?(this.#w&&d(this.#w,this.#y),e&&l(e,this.#y),this.#w=e):E.warn("assigning the same BluetoothDevice")}get server(){return this.#w?.gatt}get isConnected(){return this.server?.connected}#S=new Map;#D=new Map;async connect(){await super.connect();try{const e=await navigator.bluetooth.requestDevice({filters:[{namePrefix:"Brilliant"}],optionalServices:b});E.log("got BluetoothDevice",e),this.device=e,E.log("connecting to device...");const t=await this.device.gatt.connect();E.log(`connected to device? ${t.connected}`),E.log("getting services...");const n=await t.getPrimaryServices();E.log("got services",n),E.log("getting characteristics...");const s=n.map((async e=>{const t=(n=e.uuid,y.getServiceNameFromUUID(n));var n;E.assertWithError(t,`no name found for service uuid "${e.uuid}"`),E.log(`got "${t}" service`),e._name=t,this.#S.set(t,e),E.log("getting characteristics for service",e);const s=await e.getCharacteristics();E.log("got characteristics for service",e,s);const r=s.map((async e=>{const n=(s=e.uuid,y.getCharacteristicNameFromUUID(s));var s;E.assertWithError(n,`no name found for characteristic uuid "${e.uuid}" in "${t}" service`),E.log(`got "${n}" characteristic in "${t}" service`),e._name=n,this.#D.set(n,e),l(e,this.#m),e.properties.read&&await e.readValue(),e.properties.notify&&(E.log(`starting notifications for "${n}" characteristic`,e),await e.startNotifications())}));await Promise.all(r)}));await Promise.all(s),E.log("fully connected"),this.connectionStatus="connected"}catch(e){E.error(e),this.connectionStatus="not connected"}}async disconnect(){await super.disconnect(),E.log("disconnecting from device..."),this.server.disconnect()}_onCharacteristicvaluechanged(e){E.log("oncharacteristicvaluechanged",e);const t=e.target,n=t._name;E.assertWithError(n,`no name found for characteristic with uuid "${t.uuid}"`),E.log(`oncharacteristicvaluechanged for "${n}" characteristic`,e);const s=t.value;switch(E.assertWithError(s,`no data found for "${n}" characteristic`),E.log(`data for "${n}" characteristic`,Array.from(new Uint8Array(s.buffer))),n){case"manufacturerName":const e=this.#E.decode(s);E.log(`manufacturerName: "${e}"`),this._dispatchEvent({type:"deviceInformation",message:{manufacturerName:e}});break;case"modelNumber":const t=this.#E.decode(s);E.log(`modelNumber: "${t}"`),this._dispatchEvent({type:"deviceInformation",message:{modelNumber:t}});break;case"softwareRevision":const r=this.#E.decode(s);E.log(`softwareRevision: "${r}"`),this._dispatchEvent({type:"deviceInformation",message:{softwareRevision:r}});break;case"hardwareRevision":const i=this.#E.decode(s);E.log(`hardwareRevision: "${i}"`),this._dispatchEvent({type:"deviceInformation",message:{hardwareRevision:i}});break;case"firmwareRevision":const a=this.#E.decode(s);E.log(`firmwareRevision: "${a}"`),this._dispatchEvent({type:"deviceInformation",message:{firmwareRevision:a}});break;case"batteryLevel":const o=s.getUint8(0);E.log(`batteryLevel: ${o}`),this._dispatchEvent({type:"batteryLevel",message:{batteryLevel:o}});break;case"data":const c=s;E.log("data",c),this._dispatchEvent({type:"data",message:{data:c}});break;default:throw new Error(`uncaught characteristicName "${n}"`)}}_onGattserverdisconnected(e){E.log("gattserverdisconnected",e),this.connectionStatus="not connected"}async sendCommand(e){await super.sendCommand(...arguments);const t=this.#D.get("command");E.assertWithError(t,"command characteristic not found"),E.log("sending data to command characteristic...",e,t),await t.writeValueWithResponse(e),E.log("successfully sent command")}get canReconnect(){return Boolean(this.server)}async reconnect(){await super.reconnect(),E.log("attempting to reconnect..."),await this.server.connect(),this.isConnected?(E.log("successfully reconnected!"),this.connectionStatus="connected"):(E.log("unable to reconnect"),this.connectionStatus="not connected")}}const S=o("DataManager",{log:!1});class D{static#a=["log","pressure","acceleration","linearAcceleration","quaternion","magneticRotation"];static get EventTypes(){return this.#a}get eventTypes(){return D.#a}#o=new h(this.eventTypes);addEventListener(e,t,n){return this.#o.addEventListener(...arguments)}#L(e){this.#o.dispatchEvent(e)}removeEventListener(e,t){return this.#o.removeEventListener(...arguments)}#T="start";get state(){return this.#T}set state(e){this.#T!=e?(this.#T=e,S.log(`newState "${this.state}"`)):S.warn(`attempted to assign same state "${e}"`)}static#M={0:"padding",1:"sync",2:"log",3:"sensor"};get#$(){return D.#M}static#C={2:"pressure",6:"acceleration",32:"linearAcceleration",38:"quaternion",41:"magneticRotation"};get#I(){return D.#C}#_;static#V={pressure:2,acceleration:6,linearAcceleration:32,quaternion:38,magneticRotation:41};get#B(){return D.#V}static#R={pressure:16,acceleration:6,linearAcceleration:6,quaternion:8};get#F(){return D.#R}static#U={pressure:1,acceleration:2**-12,linearAcceleration:2**-12,quaternion:2**-14};get#A(){return D.#U}static#N={setSensorDataRate:1,setVibrationStrength:2,triggerVibration:3,stopVibration:4};get#W(){return D.#N}static#k={0:0,1:1.5625,2:3.125,3:6.25,4:12.5,5:25,6:50};get#x(){return D.#k}static#j={front:1,back:2,get both(){return this.front|this.back}};get#q(){return D.#j}#O=[];#P=0;#H=[];#Q=0;parseData(e){S.log(`parsing ${e.byteLength} bytes`,e);for(var t=0;t<e.byteLength;){const n=e.getUint8(t++);S.log(`byte at offset #${t-1}: ${n}`);const s=this.#$[n];switch(S.log("messageType?",s),this.#T){case"start":"startSync"==s&&(this.state="sync");break;case"sync":switch(s){case"continueSync":break;case"logHeader":this.#Q=e.getUint16(t),this.#H.length=0,t+=2,S.log(`logBufferFinalLength: ${this.#Q} bytes`),this.state="logging";break;case"sensorHeader":const s=this.#I[n];S.assertWithError(s,`invalid sensorId ${n}`),S.log(`sensor type: "${s}"`),this.#_=s,this.#O.length=0,this.#P=this.#F[this.#_],this.state="sensor";break;default:this.state="start"}break;case"logging":if(this.#H.push(n),S.log(`log buffer length: ${this.#H.length}/${this.#Q} bytes`),this.#H.length==this.#Q){const e=this.#H.slice();S.log("log completed",e),this.#L({type:"log",message:{log:e}}),this.state="start"}break;case"sensor":if(this.#O.push(n),S.log(`sensor buffer length: ${this.#O.length}/${this.#P} bytes`),this.#O.length==this.#P){const e=this.#O.slice();S.log("sensorDataBuffer completed",e);const t=new DataView(Uint8Array.from(e).buffer);S.log("sensorData",t),this.#z(this.#_,e)}break;default:throw`uncaught state "${this.#T}"`}}}#G(e){S.assert(e in this.#B,`invalid sensorType "${e}"`)}#J(e){S.assert(e in this.#x,`invalid sensorDataRate "${e}"`)}#K(e){S.assert(e in this.#q,`invalid vibrationMotor "${e}"`)}createSetSensorDataRateMessage(e,t){this.#G(e),this.#J(t);const n=this.#B[e];return Uint8Array.from([this.#W.setSensorDataRate,n,t])}createSetVibrationStrengthMessage(e,t){this.#K(e);const n=this.#q[e];return Uint8Array.from([this.#W.setVibrationStrength,n,t])}createTriggerVibrationMessage(e,t){this.#K(e);const n=this.#q[e],s=new DataView(new ArrayBuffer(4));return s.setUint8(0,this.#W.triggerVibration),s.setUint8(1,n),s.setUint16(2,t,!0),s}createStopVibrationMessage(e){this.#K(e);const t=this.#q[e];return Uint8Array.from([this.#W.stopVibration,t])}#X=Uint8Array.from([this.#W.stopVibration]);get stopVibrationMessage(){return this.#X}#z(e,t){switch(S.assertWithError(e in this.#A,`no scalar found for sensorType ${e}`),this.#A[e],e){case"pressure":const n=new Uint16Array(t.buffer);S.log("rawPressureValues",n);break;case"acceleration":case"linearAcceleration":const s=new Int16Array(t.buffer);S.log("rawVectorValues",s);break;case"quaternion":const r=new Int16Array(t.buffer);S.log("rawQuaternionValues",r);break;default:throw new Error(`uncaught sensorType "${e}"`)}}}const L=o("BrilliantSole",{log:!0});class T{constructor(){g(v.EventTypes,this.#Y,this),g(D.EventTypes,this.#Z,this),this.connectionManager=new w}static#a=[...v.EventTypes,"connecting","connected","disconnecting","not connected"];get#n(){return T.#a}#o=new h(this.#n);addEventListener(e,t,n){this.#o.addEventListener(...arguments)}#L(e){this.#o.dispatchEvent(e)}removeEventListener(e,t){return this.#o.removeEventListener(...arguments)}#ee;get connectionManager(){return this.#ee}set connectionManager(e){this.connectionManager!=e?(L.log("assigning new connectionManager...",e),this.connectionManager&&d(this.connectionManager,this.#Y),e&&l(e,this.#Y),this.#ee=e):L.warn("same connectionManager is already assigned")}#Y={};async connect(){return this.connectionManager?.connect()}get isConnected(){return this.connectionManager?.isConnected}#p(){L.assertWithError(this.isConnected,"not connected")}get canReconnect(){return this.connectionManager?.canReconnect}async reconnect(){return this.connectionManager?.reconnect()}get connectionType(){return this.connectionManager?.type}async disconnect(){return this.connectionManager.disconnect()}_onIsConnected(e){const t=e.message.isConnected;L.log("isConnected",t),t?this.#L({type:"connected"}):this.#L({type:"not connected"}),this.#L(e)}get connectionStatus(){return this.#ee?.connectionStatus}_onConnectionStatus(e){L.log(`connectionStatus: "${this.connectionStatus}"`),this.#L(e),this.#L({type:this.connectionStatus})}#te={};get deviceInformation(){return this.#te}_onDeviceInformation(e){const t=e.message;L.log("partial deviceInformation",t),Object.assign(this.#te,t),L.log("deviceInformation",this.#te),this.#L({type:"deviceInformation",message:{deviceInformation:this.deviceInformation}})}#ne;get batteryLevel(){return this.#ne}_onBatteryLevel(e){const{batteryLevel:t}=e.message;L.log(`batteryLevel: ${t}%`),this.#ne=t,this.#L(e)}async setSensorDataRate(e,t){this.#p(),L.log(`setting ${e} sensorDataRate to ${t}...`);const n=this.#se.createSetSensorDataRateMessage(e,t);await(this.connectionManager?.sendCommand(n)),L.log("set sensorDataRate")}#se=new D;#Z={};_onData(e){const t=e.message.data,n=Array.from(new Uint8Array(t.buffer));[171,48,32,0].includes(n[0])||L.log("data",Array.from(new Uint8Array(t.buffer))),this.#se.parseData(t)}_onLog(e){const t=e.message.log;L.log("log",t)}_onPressure(e){const t=e.message.pressure;L.log("pressure",t)}_onAcceleration(e){const t=e.message.acceleration;L.log("acceleration",t)}_onLinearAcceleration(e){const t=e.message.linearAcceleration;L.log("linearAcceleration",t)}_onMagneticRotation(e){const t=e.message.magneticRotation;L.log("magneticRotation",t)}_onQuaternion(e){const t=e.message.quaternion;L.log("quaternion",t)}async setVibrationStrength(e,t){this.#p();const n=this.#se.createSetVibrationStrengthMessage(...arguments);L.log(`setting "${e}" vibration strength to ${t}...`,n),await(this.connectionManager?.sendCommand(n)),L.log("set vibration strength")}async triggerVibration(e,t){this.#p();const n=this.#se.createTriggerVibrationMessage(e,t);L.log(`triggering "${e}" vibration for ${t}ms...`,n),await(this.connectionManager?.sendCommand(n)),L.log("triggered vibration")}async stopVibration(e){this.#p();const t=this.#se.createStopVibrationMessage(e);L.log(`stopping "${e}" vibration...`,t),await(this.connectionManager?.sendCommand(t)),L.log("stopped vibration")}}return T.setConsoleLevelFlagsForType=function(e,t){a.setLevelFlagsForType(e,t)},T.setAllConsoleLevelFlags=function(e){a.setAllLevelFlags(e)},T}));
