/**
 * @copyright Zack Qattan 2024
 * @license MIT
 */
const __BRILLIANTSOLE__ENVIRONMENT__ = "__BRILLIANTSOLE__DEV__";
const isInProduction = __BRILLIANTSOLE__ENVIRONMENT__ == "__BRILLIANTSOLE__PROD__";
const isInDev = __BRILLIANTSOLE__ENVIRONMENT__ == "__BRILLIANTSOLE__DEV__";
const isInBrowser = typeof window !== "undefined" && typeof window?.document !== "undefined";
const isInNode = typeof process !== "undefined" && process?.versions?.node != null;
const userAgent = (isInBrowser && navigator.userAgent) || "";
let isBluetoothSupported = false;
if (isInBrowser) {
    isBluetoothSupported = Boolean(navigator.bluetooth);
}
else if (isInNode) {
    isBluetoothSupported = true;
}
const isInBluefy = isInBrowser && /Bluefy/i.test(userAgent);
const isInWebBLE = isInBrowser && /WebBLE/i.test(userAgent);
const isAndroid = isInBrowser && /Android/i.test(userAgent);
const isSafari = isInBrowser && /Safari/i.test(userAgent) && !/Chrome/i.test(userAgent);
const isIOS = isInBrowser && /iPad|iPhone|iPod/i.test(userAgent);
const isMac = isInBrowser && /Macintosh/i.test(userAgent);
const isInLensStudio = !isInBrowser &&
    !isInNode &&
    typeof global !== "undefined" &&
    typeof Studio !== "undefined";

var environment = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isAndroid: isAndroid,
    get isBluetoothSupported () { return isBluetoothSupported; },
    isIOS: isIOS,
    isInBluefy: isInBluefy,
    isInBrowser: isInBrowser,
    isInDev: isInDev,
    isInLensStudio: isInLensStudio,
    isInNode: isInNode,
    isInProduction: isInProduction,
    isInWebBLE: isInWebBLE,
    isMac: isMac,
    isSafari: isSafari
});

var __console;
if (isInLensStudio) {
    const log = function (...args) {
        Studio.log(args.map((value) => new String(value)).join(","));
    };
    __console = {};
    __console.log = log;
    __console.warn = log.bind(__console, "WARNING");
    __console.error = log.bind(__console, "ERROR");
}
else {
    __console = console;
}
function getCallerFunctionPath() {
    const stack = new Error().stack;
    if (!stack)
        return "";
    const lines = stack.split("\n");
    const callerLine = lines[3] || lines[2];
    const match = callerLine.match(/at (.*?) \(/) || callerLine.match(/at (.*)/);
    if (!match)
        return "";
    const fullFn = match[1].trim();
    return `[${fullFn}]`;
}
function wrapWithLocation(fn) {
    return (...args) => {
        if (isInNode) {
            const functionPath = getCallerFunctionPath();
            fn(functionPath, ...args);
        }
        else {
            fn(...args);
        }
    };
}
if (!__console.assert) {
    const assert = (condition, ...data) => {
        if (!condition) {
            __console.warn(...data);
        }
    };
    __console.assert = assert;
}
if (!__console.table) {
    const table = (...data) => {
        __console.log(...data);
    };
    __console.table = table;
}
function emptyFunction() { }
const log = isInNode
    ? wrapWithLocation(__console.log.bind(__console))
    : __console.log.bind(__console);
const warn = isInNode
    ? wrapWithLocation(__console.warn.bind(__console))
    : __console.warn.bind(__console);
const error = isInNode
    ? wrapWithLocation(__console.error.bind(__console))
    : __console.error.bind(__console);
const table$1 = isInNode
    ? wrapWithLocation(__console.table.bind(__console))
    : __console.table.bind(__console);
const assert = __console.assert.bind(__console);
class Console {
    static #consoles = {};
    constructor(type) {
        if (Console.#consoles[type]) {
            throw new Error(`"${type}" console already exists`);
        }
        Console.#consoles[type] = this;
    }
    #levelFlags = {
        log: isInDev,
        warn: isInDev,
        assert: true,
        error: true,
        table: true,
    };
    setLevelFlags(levelFlags) {
        Object.assign(this.#levelFlags, levelFlags);
    }
    static setLevelFlagsForType(type, levelFlags) {
        if (!this.#consoles[type]) {
            throw new Error(`no console found with type "${type}"`);
        }
        this.#consoles[type].setLevelFlags(levelFlags);
    }
    static setAllLevelFlags(levelFlags) {
        for (const type in this.#consoles) {
            this.#consoles[type].setLevelFlags(levelFlags);
        }
    }
    static create(type, levelFlags) {
        const console = this.#consoles[type] || new Console(type);
        if (levelFlags) {
            console.setLevelFlags(levelFlags);
        }
        return console;
    }
    get log() {
        return this.#levelFlags.log ? log : emptyFunction;
    }
    get warn() {
        return this.#levelFlags.warn ? warn : emptyFunction;
    }
    get error() {
        return this.#levelFlags.error ? error : emptyFunction;
    }
    get assert() {
        return this.#levelFlags.assert ? assert : emptyFunction;
    }
    get table() {
        return this.#levelFlags.table ? table$1 : emptyFunction;
    }
    assertWithError(condition, message) {
        if (!Boolean(condition)) {
            throw new Error(message);
        }
    }
    assertTypeWithError(value, type) {
        this.assertWithError(typeof value == type, `value ${value} of type "${typeof value}" not of type "${type}"`);
    }
    assertEnumWithError(value, enumeration) {
        this.assertWithError(enumeration.includes(value), `invalid enum "${value}"`);
    }
    assertRangeWithError(name, value, min, max) {
        this.assertWithError(value >= min && value <= max, `${name} ${value} must be within ${min}-${max}`);
    }
}
function createConsole(type, levelFlags) {
    return Console.create(type, levelFlags);
}
function setConsoleLevelFlagsForType(type, levelFlags) {
    Console.setLevelFlagsForType(type, levelFlags);
}
function setAllConsoleLevelFlags(levelFlags) {
    Console.setAllLevelFlags(levelFlags);
}

const _console$J = createConsole("EventDispatcher", { log: false });
class EventDispatcher {
    target;
    validEventTypes;
    listeners = {};
    constructor(target, validEventTypes) {
        this.target = target;
        this.validEventTypes = validEventTypes;
        this.addEventListener = this.addEventListener.bind(this);
        this.removeEventListener = this.removeEventListener.bind(this);
        this.removeEventListeners = this.removeEventListeners.bind(this);
        this.removeAllEventListeners = this.removeAllEventListeners.bind(this);
        this.dispatchEvent = this.dispatchEvent.bind(this);
        this.waitForEvent = this.waitForEvent.bind(this);
    }
    isValidEventType(type) {
        return this.validEventTypes.includes(type);
    }
    updateEventListeners(type) {
        if (!this.listeners[type])
            return;
        this.listeners[type] = this.listeners[type].filter((listenerObj) => {
            if (listenerObj.shouldRemove) {
                _console$J.log(`removing "${type}" eventListener`, listenerObj);
            }
            return !listenerObj.shouldRemove;
        });
    }
    addEventListener(type, listener, options = { once: false }) {
        if (!this.isValidEventType(type)) {
            throw new Error(`Invalid event type: ${type}`);
        }
        if (!this.listeners[type]) {
            this.listeners[type] = [];
            _console$J.log(`creating "${type}" listeners array`, this.listeners[type]);
        }
        const alreadyAdded = this.listeners[type].find((listenerObject) => {
            return (listenerObject.listener == listener &&
                listenerObject.once == options.once);
        });
        if (alreadyAdded) {
            _console$J.log("already added listener");
            return;
        }
        _console$J.log(`adding "${type}" listener`, listener, options);
        this.listeners[type].push({ listener, once: options.once });
        _console$J.log(`currently have ${this.listeners[type].length} "${type}" listeners`);
    }
    removeEventListener(type, listener) {
        if (!this.isValidEventType(type)) {
            throw new Error(`Invalid event type: ${type}`);
        }
        if (!this.listeners[type])
            return;
        _console$J.log(`removing "${type}" listener...`, listener);
        this.listeners[type].forEach((listenerObj) => {
            const isListenerToRemove = listenerObj.listener === listener;
            if (isListenerToRemove) {
                _console$J.log(`flagging "${type}" listener`, listener);
                listenerObj.shouldRemove = true;
            }
        });
        this.updateEventListeners(type);
    }
    removeEventListeners(type) {
        if (!this.isValidEventType(type)) {
            throw new Error(`Invalid event type: ${type}`);
        }
        if (!this.listeners[type])
            return;
        _console$J.log(`removing "${type}" listeners...`);
        this.listeners[type] = [];
    }
    removeAllEventListeners() {
        _console$J.log(`removing listeners...`);
        this.listeners = {};
    }
    dispatchEvent(type, message) {
        if (!this.isValidEventType(type)) {
            throw new Error(`Invalid event type: ${type}`);
        }
        if (!this.listeners[type])
            return;
        const listenersSnapshot = [...this.listeners[type]];
        listenersSnapshot.forEach((listenerObj) => {
            if (listenerObj.shouldRemove) {
                return;
            }
            _console$J.log(`dispatching "${type}" listener`, listenerObj);
            try {
                listenerObj.listener({ type, target: this.target, message });
            }
            catch (error) {
                console.error(error);
            }
            if (listenerObj.once) {
                _console$J.log(`flagging "${type}" listener`, listenerObj);
                listenerObj.shouldRemove = true;
            }
        });
        this.updateEventListeners(type);
    }
    waitForEvent(type) {
        return new Promise((resolve) => {
            const onceListener = (event) => {
                resolve(event);
            };
            this.addEventListener(type, onceListener, { once: true });
        });
    }
}

const _console$I = createConsole("Timer", { log: false });
async function wait(delay) {
    _console$I.log(`waiting for ${delay}ms`);
    return new Promise((resolve) => {
        setTimeout(() => resolve(), delay);
    });
}
class Timer {
    #callback;
    get callback() {
        return this.#callback;
    }
    set callback(newCallback) {
        _console$I.assertTypeWithError(newCallback, "function");
        _console$I.log({ newCallback });
        this.#callback = newCallback;
        if (this.isRunning) {
            this.restart();
        }
    }
    #interval;
    get interval() {
        return this.#interval;
    }
    set interval(newInterval) {
        _console$I.assertTypeWithError(newInterval, "number");
        _console$I.assertWithError(newInterval > 0, "interval must be above 0");
        _console$I.log({ newInterval });
        this.#interval = newInterval;
        if (this.isRunning) {
            this.restart();
        }
    }
    constructor(callback, interval) {
        this.interval = interval;
        this.callback = callback;
    }
    #intervalId;
    get isRunning() {
        return this.#intervalId != undefined;
    }
    start(immediately = false) {
        if (this.isRunning) {
            _console$I.log("interval already running");
            return;
        }
        _console$I.log(`starting interval every ${this.#interval}ms`);
        this.#intervalId = setInterval(this.#callback, this.#interval);
        if (immediately) {
            this.#callback();
        }
    }
    stop() {
        if (!this.isRunning) {
            _console$I.log("interval already not running");
            return;
        }
        _console$I.log("stopping interval");
        clearInterval(this.#intervalId);
        this.#intervalId = undefined;
    }
    restart(startImmediately = false) {
        this.stop();
        this.start(startImmediately);
    }
}

createConsole("checksum", { log: false });
function crc32ForByte(r) {
    for (let j = 0; j < 8; ++j) {
        r = (r & 1 ? 0 : 0xedb88320) ^ (r >>> 1);
    }
    return r ^ 0xff000000;
}
const tableSize = 256;
const crc32Table = new Uint32Array(tableSize);
for (let i = 0; i < tableSize; ++i) {
    crc32Table[i] = crc32ForByte(i);
}
function crc32(dataIterable) {
    let dataBytes = new Uint8Array(dataIterable);
    let crc = 0;
    for (let i = 0; i < dataBytes.byteLength; ++i) {
        const crcLowByte = crc & 0x000000ff;
        const dataByte = dataBytes[i];
        const tableIndex = crcLowByte ^ dataByte;
        crc = (crc32Table[tableIndex] ^ (crc >>> 8)) >>> 0;
    }
    return crc;
}

var _TextEncoder;
if (typeof TextEncoder == "undefined") {
    _TextEncoder = class {
        encode(string) {
            const encoding = Array.from(string).map((char) => char.charCodeAt(0));
            return Uint8Array.from(encoding);
        }
    };
}
else {
    _TextEncoder = TextEncoder;
}
var _TextDecoder;
if (typeof TextDecoder == "undefined") {
    _TextDecoder = class {
        decode(data) {
            const byteArray = Array.from(new Uint8Array(data));
            return byteArray
                .map((value) => {
                return String.fromCharCode(value);
            })
                .join("");
        }
    };
}
else {
    _TextDecoder = TextDecoder;
}
const textEncoder = new _TextEncoder();
const textDecoder = new _TextDecoder();

const _console$H = createConsole("ArrayBufferUtils", { log: false });
function concatenateArrayBuffers(...arrayBuffers) {
    arrayBuffers = arrayBuffers.filter((arrayBuffer) => arrayBuffer != undefined || arrayBuffer != null);
    arrayBuffers = arrayBuffers.map((arrayBuffer) => {
        if (typeof arrayBuffer == "number") {
            const number = arrayBuffer;
            return Uint8Array.from([Math.floor(number)]);
        }
        else if (typeof arrayBuffer == "boolean") {
            const boolean = arrayBuffer;
            return Uint8Array.from([boolean ? 1 : 0]);
        }
        else if (typeof arrayBuffer == "string") {
            const string = arrayBuffer;
            return stringToArrayBuffer(string);
        }
        else if (arrayBuffer instanceof Array) {
            const array = arrayBuffer;
            return concatenateArrayBuffers(...array);
        }
        else if (arrayBuffer instanceof ArrayBuffer) {
            return arrayBuffer;
        }
        else if ("buffer" in arrayBuffer &&
            arrayBuffer.buffer instanceof ArrayBuffer) {
            const bufferContainer = arrayBuffer;
            return bufferContainer.buffer;
        }
        else if (arrayBuffer instanceof DataView) {
            const dataView = arrayBuffer;
            return dataView.buffer;
        }
        else if (typeof arrayBuffer == "object") {
            const object = arrayBuffer;
            return objectToArrayBuffer(object);
        }
        else {
            return arrayBuffer;
        }
    });
    arrayBuffers = arrayBuffers.filter((arrayBuffer) => arrayBuffer && "byteLength" in arrayBuffer);
    const length = arrayBuffers.reduce((length, arrayBuffer) => length + arrayBuffer.byteLength, 0);
    const uint8Array = new Uint8Array(length);
    let byteOffset = 0;
    arrayBuffers.forEach((arrayBuffer) => {
        uint8Array.set(new Uint8Array(arrayBuffer), byteOffset);
        byteOffset += arrayBuffer.byteLength;
    });
    return uint8Array.buffer;
}
function stringToArrayBuffer(string) {
    const encoding = textEncoder.encode(string);
    return concatenateArrayBuffers(encoding.byteLength, encoding);
}
function objectToArrayBuffer(object) {
    return stringToArrayBuffer(JSON.stringify(object));
}
function sliceDataView(dataView, begin, length) {
    let end;
    if (length != undefined) {
        end = dataView.byteOffset + begin + length;
    }
    _console$H.log({ dataView, begin, end, length });
    return new DataView(dataView.buffer.slice(dataView.byteOffset + begin, end));
}
async function getFileBuffer(file) {
    let fileBuffer;
    if (file instanceof Array) {
        fileBuffer = Uint8Array.from(file);
    }
    else if (file instanceof DataView) {
        fileBuffer = file.buffer;
    }
    else if (typeof file == "string" || file instanceof URL) {
        const response = await fetch(file);
        fileBuffer = await response.arrayBuffer();
    }
    else if (file instanceof File) {
        fileBuffer = await file.arrayBuffer();
    }
    else if (file instanceof ArrayBuffer) {
        fileBuffer = file;
    }
    else {
        throw { error: "invalid file type", file };
    }
    return fileBuffer;
}
function UInt8ByteBuffer(value) {
    return Uint8Array.from([value]).buffer;
}

const getAllProperties = object => {
	const properties = new Set();
	do {
		for (const key of Reflect.ownKeys(object)) {
			properties.add([object, key]);
		}
	} while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);
	return properties;
};
function autoBind(self, {include, exclude} = {}) {
	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		if (include) {
			return include.some(match);
		}
		if (exclude) {
			return !exclude.some(match);
		}
		return true;
	};
	for (const [object, key] of getAllProperties(self.constructor.prototype)) {
		if (key === 'constructor' || !filter(key)) {
			continue;
		}
		const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
		if (descriptor && typeof descriptor.value === 'function') {
			self[key] = self[key].bind(self);
		}
	}
	return self;
}

var _a$5;
const _console$G = createConsole("FileTransferManager", { log: false });
const FileTransferMessageTypes = [
    "getFileTypes",
    "maxFileLength",
    "getFileType",
    "setFileType",
    "getFileLength",
    "setFileLength",
    "getFileChecksum",
    "setFileChecksum",
    "setFileTransferCommand",
    "fileTransferStatus",
    "getFileBlock",
    "setFileBlock",
    "fileBytesTransferred",
];
const FileTypes = [
    "tflite",
    "wifiServerCert",
    "wifiServerKey",
    "spriteSheet",
];
const FileTransferStatuses = ["idle", "sending", "receiving"];
const FileTransferCommands = [
    "startSend",
    "startReceive",
    "cancel",
];
const FileTransferDirections = ["sending", "receiving"];
const FileTransferEventTypes = [
    ...FileTransferMessageTypes,
    "fileTransferProgress",
    "fileTransferComplete",
    "fileReceived",
];
const RequiredFileTransferMessageTypes = [
    "maxFileLength",
    "getFileLength",
    "getFileChecksum",
    "getFileType",
    "fileTransferStatus",
];
class FileTransferManager {
    constructor() {
        autoBind(this);
    }
    sendMessage;
    eventDispatcher;
    get addEventListener() {
        return this.eventDispatcher.addEventListener;
    }
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get removeEventListener() {
        return this.eventDispatcher.removeEventListener;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    #assertValidType(type) {
        _console$G.assertEnumWithError(type, FileTypes);
    }
    #isValidType(type) {
        return FileTypes.includes(type);
    }
    #assertValidTypeEnum(typeEnum) {
        _console$G.assertWithError(typeEnum in FileTypes, `invalid typeEnum ${typeEnum}`);
    }
    #assertValidStatusEnum(statusEnum) {
        _console$G.assertWithError(statusEnum in FileTransferStatuses, `invalid statusEnum ${statusEnum}`);
    }
    #assertValidCommand(command) {
        _console$G.assertEnumWithError(command, FileTransferCommands);
    }
    #fileTypes = [];
    get fileTypes() {
        return this.#fileTypes;
    }
    #parseFileTypes(dataView) {
        const fileTypes = Array.from(new Uint8Array(dataView.buffer))
            .map((index) => FileTypes[index])
            .filter(Boolean);
        this.#fileTypes = fileTypes;
        _console$G.log("fileTypes", fileTypes);
        this.#dispatchEvent("getFileTypes", {
            fileTypes: this.#fileTypes,
        });
    }
    static #MaxLength = 0;
    static get MaxLength() {
        return this.#MaxLength;
    }
    #maxLength = _a$5.MaxLength;
    get maxLength() {
        return this.#maxLength;
    }
    #parseMaxLength(dataView) {
        _console$G.log("parseFileMaxLength", dataView);
        const maxLength = dataView.getUint32(0, true);
        _console$G.log(`maxLength: ${maxLength / 1024}kB`);
        this.#updateMaxLength(maxLength);
    }
    #updateMaxLength(maxLength) {
        _console$G.log({ maxLength });
        this.#maxLength = maxLength;
        this.#dispatchEvent("maxFileLength", { maxFileLength: maxLength });
    }
    #assertValidLength(length) {
        _console$G.assertWithError(length <= this.maxLength, `file length ${length}kB too large - must be ${this.maxLength}kB or less`);
    }
    #type;
    get type() {
        return this.#type;
    }
    #parseType(dataView) {
        _console$G.log("parseFileType", dataView);
        const typeEnum = dataView.getUint8(0);
        this.#assertValidTypeEnum(typeEnum);
        const type = FileTypes[typeEnum];
        this.#updateType(type);
    }
    #updateType(type) {
        _console$G.log({ fileTransferType: type });
        this.#type = type;
        this.#dispatchEvent("getFileType", { fileType: type });
    }
    async #setType(newType, sendImmediately) {
        this.#assertValidType(newType);
        if (this.type == newType) {
            _console$G.log(`redundant type assignment ${newType}`);
            return;
        }
        const promise = this.waitForEvent("getFileType");
        const typeEnum = FileTypes.indexOf(newType);
        this.sendMessage([{ type: "setFileType", data: UInt8ByteBuffer(typeEnum) }], sendImmediately);
        await promise;
    }
    #length = 0;
    get length() {
        return this.#length;
    }
    #parseLength(dataView) {
        _console$G.log("parseFileLength", dataView);
        const length = dataView.getUint32(0, true);
        this.#updateLength(length);
    }
    #updateLength(length) {
        _console$G.log(`length: ${length / 1024}kB`);
        this.#length = length;
        this.#dispatchEvent("getFileLength", { fileLength: length });
    }
    async #setLength(newLength, sendImmediately) {
        _console$G.assertTypeWithError(newLength, "number");
        this.#assertValidLength(newLength);
        if (this.length == newLength) {
            _console$G.log(`redundant length assignment ${newLength}`);
            return;
        }
        const promise = this.waitForEvent("getFileLength");
        const dataView = new DataView(new ArrayBuffer(4));
        dataView.setUint32(0, newLength, true);
        this.sendMessage([{ type: "setFileLength", data: dataView.buffer }], sendImmediately);
        await promise;
    }
    #checksum = 0;
    get checksum() {
        return this.#checksum;
    }
    #parseChecksum(dataView) {
        _console$G.log("checksum", dataView);
        const checksum = dataView.getUint32(0, true);
        this.#updateChecksum(checksum);
    }
    #updateChecksum(checksum) {
        _console$G.log({ checksum });
        this.#checksum = checksum;
        this.#dispatchEvent("getFileChecksum", { fileChecksum: checksum });
    }
    async #setChecksum(newChecksum, sendImmediately) {
        _console$G.assertTypeWithError(newChecksum, "number");
        if (this.checksum == newChecksum) {
            _console$G.log(`redundant checksum assignment ${newChecksum}`);
            return;
        }
        const promise = this.waitForEvent("getFileChecksum");
        const dataView = new DataView(new ArrayBuffer(4));
        dataView.setUint32(0, newChecksum, true);
        this.sendMessage([{ type: "setFileChecksum", data: dataView.buffer }], sendImmediately);
        await promise;
    }
    async #setCommand(command, sendImmediately) {
        this.#assertValidCommand(command);
        const promise = this.waitForEvent("fileTransferStatus");
        _console$G.log(`setting command ${command}`);
        const commandEnum = FileTransferCommands.indexOf(command);
        this.sendMessage([
            {
                type: "setFileTransferCommand",
                data: UInt8ByteBuffer(commandEnum),
            },
        ], sendImmediately);
        await promise;
    }
    #status = "idle";
    get status() {
        return this.#status;
    }
    #parseStatus(dataView) {
        _console$G.log("parseFileStatus", dataView);
        const statusEnum = dataView.getUint8(0);
        this.#assertValidStatusEnum(statusEnum);
        const status = FileTransferStatuses[statusEnum];
        this.#updateStatus(status);
    }
    #updateStatus(status) {
        _console$G.log({ status });
        this.#status = status;
        this.#receivedBlocks.length = 0;
        this.#isCancelling = false;
        this.#buffer = undefined;
        this.#bytesTransferred = 0;
        this.#dispatchEvent("fileTransferStatus", {
            fileTransferStatus: status,
            fileType: this.type,
        });
    }
    #assertIsIdle() {
        _console$G.assertWithError(this.#status == "idle", "status is not idle");
    }
    #assertIsNotIdle() {
        _console$G.assertWithError(this.#status != "idle", "status is idle");
    }
    #receivedBlocks = [];
    async #parseBlock(dataView) {
        _console$G.log("parseFileBlock", dataView);
        this.#receivedBlocks.push(dataView.buffer);
        const bytesReceived = this.#receivedBlocks.reduce((sum, arrayBuffer) => (sum += arrayBuffer.byteLength), 0);
        const progress = bytesReceived / this.#length;
        _console$G.log(`received ${bytesReceived} of ${this.#length} bytes (${progress * 100}%)`);
        this.#dispatchEvent("fileTransferProgress", {
            progress,
            fileType: this.type,
        });
        if (bytesReceived != this.#length) {
            const dataView = new DataView(new ArrayBuffer(4));
            dataView.setUint32(0, bytesReceived, true);
            if (this.isServerSide) {
                return;
            }
            await this.sendMessage([
                { type: "fileBytesTransferred", data: dataView.buffer },
            ]);
            return;
        }
        _console$G.log("file transfer complete");
        let fileName = new Date().toLocaleString();
        switch (this.type) {
            case "tflite":
                fileName += ".tflite";
                break;
            case "wifiServerCert":
                fileName += "_server.crt";
                break;
            case "wifiServerKey":
                fileName += "_server.key";
                break;
        }
        let file;
        if (typeof File !== "undefined") {
            file = new File(this.#receivedBlocks, fileName);
        }
        else {
            file = new Blob(this.#receivedBlocks);
        }
        const arrayBuffer = await file.arrayBuffer();
        const checksum = crc32(arrayBuffer);
        _console$G.log({ checksum });
        if (checksum != this.#checksum) {
            _console$G.error(`wrong checksum - expected ${this.#checksum}, got ${checksum}`);
            return;
        }
        _console$G.log("received file", file);
        this.#dispatchEvent("getFileBlock", { fileTransferBlock: dataView });
        this.#dispatchEvent("fileTransferComplete", {
            direction: "receiving",
            fileType: this.type,
        });
        this.#dispatchEvent("fileReceived", { file, fileType: this.type });
    }
    parseMessage(messageType, dataView) {
        _console$G.log({ messageType });
        switch (messageType) {
            case "getFileTypes":
                this.#parseFileTypes(dataView);
                break;
            case "maxFileLength":
                this.#parseMaxLength(dataView);
                break;
            case "getFileType":
            case "setFileType":
                this.#parseType(dataView);
                break;
            case "getFileLength":
            case "setFileLength":
                this.#parseLength(dataView);
                break;
            case "getFileChecksum":
            case "setFileChecksum":
                this.#parseChecksum(dataView);
                break;
            case "fileTransferStatus":
                this.#parseStatus(dataView);
                break;
            case "getFileBlock":
                this.#parseBlock(dataView);
                break;
            case "fileBytesTransferred":
                this.#parseBytesTransferred(dataView);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
    async send(type, file, override) {
        {
            this.#assertIsIdle();
            this.#assertValidType(type);
        }
        const fileBuffer = await getFileBuffer(file);
        const fileLength = fileBuffer.byteLength;
        const checksum = crc32(fileBuffer);
        this.#assertValidLength(fileLength);
        if (!override) {
            if (type != this.type) {
                _console$G.log("different fileTypes - sending");
            }
            else if (fileLength != this.length) {
                _console$G.log("different fileLengths - sending");
            }
            else if (checksum != this.checksum) {
                _console$G.log("different fileChecksums - sending");
            }
            else {
                _console$G.log("already sent file");
                return false;
            }
        }
        const promises = [];
        promises.push(this.#setType(type, false));
        promises.push(this.#setLength(fileLength, false));
        promises.push(this.#setChecksum(checksum, false));
        promises.push(this.#setCommand("startSend", false));
        this.sendMessage();
        await Promise.all(promises);
        if (this.#buffer) {
            return false;
        }
        if (this.#length != fileLength) {
            return false;
        }
        if (this.#checksum != checksum) {
            return false;
        }
        await this.#send(fileBuffer);
        return true;
    }
    #buffer;
    #bytesTransferred = 0;
    async #send(buffer) {
        this.#buffer = buffer;
        return this.#sendBlock();
    }
    mtu;
    async #sendBlock() {
        if (this.status != "sending") {
            return;
        }
        if (this.#isCancelling) {
            _console$G.error("not sending block - busy cancelling");
            return;
        }
        if (!this.#buffer) {
            if (!this.isServerSide) {
                _console$G.error("no buffer defined");
            }
            return;
        }
        const buffer = this.#buffer;
        let offset = this.#bytesTransferred;
        _console$G.log("sending block", { buffer, offset, mtu: this.mtu });
        const slicedBuffer = buffer.slice(offset, offset + (this.mtu - 3 - 3));
        _console$G.log("slicedBuffer", slicedBuffer);
        const bytesLeft = buffer.byteLength - offset;
        const progress = 1 - bytesLeft / buffer.byteLength;
        _console$G.log(`sending bytes ${offset}-${offset + slicedBuffer.byteLength} of ${buffer.byteLength} bytes (${progress * 100}%)`);
        this.#dispatchEvent("fileTransferProgress", {
            progress,
            fileType: this.type,
        });
        if (slicedBuffer.byteLength == 0) {
            _console$G.log("finished sending buffer");
            this.#dispatchEvent("fileTransferComplete", {
                direction: "sending",
                fileType: this.type,
            });
        }
        else {
            await this.sendMessage([{ type: "setFileBlock", data: slicedBuffer }]);
            this.#bytesTransferred = offset + slicedBuffer.byteLength;
        }
    }
    async #parseBytesTransferred(dataView) {
        _console$G.log("parseBytesTransferred", dataView);
        const bytesTransferred = dataView.getUint32(0, true);
        _console$G.log({ bytesTransferred });
        if (this.status != "sending") {
            _console$G.error(`not currently sending file`);
            return;
        }
        if (!this.isServerSide && this.#bytesTransferred != bytesTransferred) {
            _console$G.error(`bytesTransferred are not equal - got ${bytesTransferred}, expected ${this.#bytesTransferred}`);
            this.cancel();
            return;
        }
        this.#sendBlock();
    }
    async receive(type) {
        this.#assertIsIdle();
        this.#assertValidType(type);
        await this.#setType(type);
        await this.#setCommand("startReceive");
    }
    #isCancelling = false;
    async cancel() {
        this.#assertIsNotIdle();
        _console$G.log("cancelling file transfer...");
        this.#isCancelling = true;
        await this.#setCommand("cancel");
    }
    #isServerSide = false;
    get isServerSide() {
        return this.#isServerSide;
    }
    set isServerSide(newIsServerSide) {
        if (this.#isServerSide == newIsServerSide) {
            _console$G.log("redundant isServerSide assignment");
            return;
        }
        _console$G.log({ newIsServerSide });
        this.#isServerSide = newIsServerSide;
    }
    requestRequiredInformation() {
        _console$G.log("requesting required fileTransfer information");
        const messages = RequiredFileTransferMessageTypes.map((messageType) => ({
            type: messageType,
        }));
        this.sendMessage(messages, false);
    }
    clear() {
        this.#receivedBlocks.length = 0;
        this.#isCancelling = false;
        this.#buffer = undefined;
        this.#bytesTransferred = 0;
        this.#isServerSide = false;
        this.#checksum = 0;
        this.#fileTypes.length = 0;
        this.#type = undefined;
        this.#length = 0;
        this.#checksum = 0;
        this.#status = "idle";
        this.mtu = undefined;
    }
}
_a$5 = FileTransferManager;

const _console$F = createConsole("MathUtils", { log: false });
function getInterpolation(value, min, max, span) {
    if (span == undefined) {
        span = max - min;
    }
    return (value - min) / span;
}
const Uint16Max = 2 ** 16;
const Int16Max = 2 ** 15;
function removeLower2Bytes(number) {
    const lower2Bytes = number % Uint16Max;
    return number - lower2Bytes;
}
const timestampThreshold = 60_000;
function parseTimestamp(dataView, byteOffset) {
    const now = Date.now();
    const nowWithoutLower2Bytes = removeLower2Bytes(now);
    const lower2Bytes = dataView.getUint16(byteOffset, true);
    let timestamp = nowWithoutLower2Bytes + lower2Bytes;
    if (Math.abs(now - timestamp) > timestampThreshold) {
        _console$F.log("correcting timestamp delta");
        timestamp += Uint16Max * Math.sign(now - timestamp);
    }
    return timestamp;
}
function getVector2Distance(a, b) {
    return Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
}
function getVector2DistanceSquared(a, b) {
    return (b.x - a.x) ** 2 + (b.y - a.y) ** 2;
}
function getVector2Midpoint(a, b) {
    return {
        x: (a.x + b.x) / 2,
        y: (a.y + b.y) / 2,
    };
}
function getVector3Length(vector) {
    const { x, y, z } = vector;
    return Math.sqrt(x ** 2 + y ** 2 + z ** 2);
}
function clamp(value, min = 0, max = 1) {
    return Math.min(Math.max(value, min), max);
}
function degToRad(deg) {
    return deg * (Math.PI / 180);
}
const twoPi = Math.PI * 2;
function normalizeRadians(rad) {
    return ((rad % twoPi) + twoPi) % twoPi;
}
function pointInPolygon(pt, polygon) {
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = yi > pt.y !== yj > pt.y &&
            pt.x < ((xj - xi) * (pt.y - yi)) / (yj - yi) + xi;
        if (intersect)
            inside = !inside;
    }
    return inside;
}

const initialRange = { min: Infinity, max: -Infinity, span: 0 };
class RangeHelper {
    #range = structuredClone(initialRange);
    get min() {
        return this.#range.min;
    }
    get max() {
        return this.#range.max;
    }
    get span() {
        return this.#range.span;
    }
    get range() {
        return structuredClone(this.#range);
    }
    set min(newMin) {
        this.#range.min = newMin;
        this.#range.max = Math.max(newMin, this.#range.max);
        this.#updateSpan();
    }
    set max(newMax) {
        this.#range.max = newMax;
        this.#range.min = Math.min(newMax, this.#range.min);
        this.#updateSpan();
    }
    #updateSpan() {
        this.#range.span = this.#range.max - this.#range.min;
    }
    reset() {
        Object.assign(this.#range, initialRange);
    }
    update(value) {
        this.#range.min = Math.min(value, this.#range.min);
        this.#range.max = Math.max(value, this.#range.max);
        this.#updateSpan();
    }
    getNormalization(value, weightByRange) {
        let normalization = getInterpolation(value, this.#range.min, this.#range.max, this.#range.span);
        if (weightByRange) {
            normalization *= this.#range.span;
        }
        return normalization || 0;
    }
    updateAndGetNormalization(value, weightByRange) {
        this.update(value);
        return this.getNormalization(value, weightByRange);
    }
}

class CenterOfPressureHelper {
    #range = {
        x: new RangeHelper(),
        y: new RangeHelper(),
    };
    reset() {
        this.#range.x.reset();
        this.#range.y.reset();
    }
    update(centerOfPressure) {
        this.#range.x.update(centerOfPressure.x);
        this.#range.y.update(centerOfPressure.y);
    }
    getNormalization(centerOfPressure, weightByRange) {
        return {
            x: this.#range.x.getNormalization(centerOfPressure.x, weightByRange),
            y: this.#range.y.getNormalization(centerOfPressure.y, weightByRange),
        };
    }
    updateAndGetNormalization(centerOfPressure, weightByRange) {
        this.update(centerOfPressure);
        return this.getNormalization(centerOfPressure, weightByRange);
    }
}

function createArray(arrayLength, objectOrCallback) {
    return new Array(arrayLength).fill(1).map((_, index) => {
        if (typeof objectOrCallback == "function") {
            const callback = objectOrCallback;
            return callback(index);
        }
        else {
            const object = objectOrCallback;
            return Object.assign({}, object);
        }
    });
}
function arrayWithoutDuplicates(array) {
    return array.filter((value, index) => array.indexOf(value) == index);
}

const _console$E = createConsole("PressureDataManager", { log: false });
const PressureSensorTypes = ["pressure"];
const ContinuousPressureSensorTypes = PressureSensorTypes;
const DefaultNumberOfPressureSensors = 8;
class PressureSensorDataManager {
    #positions = [];
    get positions() {
        return this.#positions;
    }
    get numberOfSensors() {
        return this.positions.length;
    }
    parsePositions(dataView) {
        const positions = [];
        for (let pressureSensorIndex = 0, byteOffset = 0; byteOffset < dataView.byteLength; pressureSensorIndex++, byteOffset += 2) {
            positions.push({
                x: dataView.getUint8(byteOffset) / 2 ** 8,
                y: dataView.getUint8(byteOffset + 1) / 2 ** 8,
            });
        }
        _console$E.log({ positions });
        this.#positions = positions;
        this.#sensorRangeHelpers = createArray(this.numberOfSensors, () => new RangeHelper());
        this.resetRange();
    }
    #sensorRangeHelpers;
    #normalizedSumRangeHelper = new RangeHelper();
    #centerOfPressureHelper = new CenterOfPressureHelper();
    resetRange() {
        this.#sensorRangeHelpers?.forEach((rangeHelper) => rangeHelper.reset());
        this.#centerOfPressureHelper.reset();
        this.#normalizedSumRangeHelper.reset();
    }
    parseData(dataView, scalar) {
        const pressure = {
            sensors: [],
            scaledSum: 0,
            normalizedSum: 0,
        };
        for (let index = 0, byteOffset = 0; byteOffset < dataView.byteLength; index++, byteOffset += 2) {
            const rawValue = dataView.getUint16(byteOffset, true);
            let scaledValue = (rawValue * scalar) / this.numberOfSensors;
            const rangeHelper = this.#sensorRangeHelpers[index];
            const normalizedValue = rangeHelper.updateAndGetNormalization(scaledValue, false);
            const position = this.positions[index];
            pressure.sensors[index] = {
                rawValue,
                scaledValue,
                normalizedValue,
                position,
                weightedValue: 0,
            };
            pressure.scaledSum += scaledValue;
        }
        pressure.normalizedSum =
            this.#normalizedSumRangeHelper.updateAndGetNormalization(pressure.scaledSum, false);
        if (pressure.scaledSum > 0) {
            pressure.center = { x: 0, y: 0 };
            pressure.sensors.forEach((sensor) => {
                sensor.weightedValue = sensor.scaledValue / pressure.scaledSum;
                pressure.center.x += sensor.position.x * sensor.weightedValue;
                pressure.center.y += sensor.position.y * sensor.weightedValue;
            });
            pressure.normalizedCenter =
                this.#centerOfPressureHelper.updateAndGetNormalization(pressure.center, false);
        }
        _console$E.log({ pressure });
        return pressure;
    }
}

const _console$D = createConsole("MotionSensorDataManager", { log: false });
const MotionSensorTypes = [
    "acceleration",
    "gravity",
    "linearAcceleration",
    "gyroscope",
    "magnetometer",
    "gameRotation",
    "rotation",
    "orientation",
    "activity",
    "stepCounter",
    "stepDetector",
    "deviceOrientation",
    "tapDetector",
];
const ContinuousMotionTypes = [
    "acceleration",
    "gravity",
    "linearAcceleration",
    "gyroscope",
    "magnetometer",
    "gameRotation",
    "rotation",
    "orientation",
];
const ActivityTypes = [
    "still",
    "walking",
    "running",
    "bicycle",
    "vehicle",
    "tilting",
];
const DeviceOrientations = [
    "portraitUpright",
    "landscapeLeft",
    "portraitUpsideDown",
    "landscapeRight",
    "unknown",
];
class MotionSensorDataManager {
    parseVector3(dataView, scalar) {
        let [x, y, z] = [
            dataView.getInt16(0, true),
            dataView.getInt16(2, true),
            dataView.getInt16(4, true),
        ].map((value) => value * scalar);
        const vector = { x, y, z };
        _console$D.log({ vector });
        return vector;
    }
    parseQuaternion(dataView, scalar) {
        let [x, y, z, w] = [
            dataView.getInt16(0, true),
            dataView.getInt16(2, true),
            dataView.getInt16(4, true),
            dataView.getInt16(6, true),
        ].map((value) => value * scalar);
        const quaternion = { x, y, z, w };
        _console$D.log({ quaternion });
        return quaternion;
    }
    parseEuler(dataView, scalar) {
        let [heading, pitch, roll] = [
            dataView.getInt16(0, true),
            dataView.getInt16(2, true),
            dataView.getInt16(4, true),
        ].map((value) => value * scalar);
        pitch *= -1;
        heading *= -1;
        if (heading < 0) {
            heading += 360;
        }
        const euler = { heading, pitch, roll };
        _console$D.log({ euler });
        return euler;
    }
    parseStepCounter(dataView) {
        _console$D.log("parseStepCounter", dataView);
        const stepCount = dataView.getUint32(0, true);
        _console$D.log({ stepCount });
        return stepCount;
    }
    parseActivity(dataView) {
        _console$D.log("parseActivity", dataView);
        const activity = {};
        const activityBitfield = dataView.getUint8(0);
        _console$D.log("activityBitfield", activityBitfield.toString(2));
        ActivityTypes.forEach((activityType, index) => {
            activity[activityType] = Boolean(activityBitfield & (1 << index));
        });
        _console$D.log("activity", activity);
        return activity;
    }
    parseDeviceOrientation(dataView) {
        _console$D.log("parseDeviceOrientation", dataView);
        const index = dataView.getUint8(0);
        const deviceOrientation = DeviceOrientations[index];
        _console$D.assertWithError(deviceOrientation, "undefined deviceOrientation");
        _console$D.log({ deviceOrientation });
        return deviceOrientation;
    }
}

const BarometerSensorTypes = ["barometer"];
const ContinuousBarometerSensorTypes = BarometerSensorTypes;
const _console$C = createConsole("BarometerSensorDataManager", { log: false });
class BarometerSensorDataManager {
    #calculcateAltitude(pressure) {
        const P0 = 101325;
        const T0 = 288.15;
        const L = 0.0065;
        const R = 8.3144598;
        const g = 9.80665;
        const M = 0.0289644;
        const exponent = (R * L) / (g * M);
        const h = (T0 / L) * (1 - Math.pow(pressure / P0, exponent));
        return h;
    }
    parseData(dataView, scalar) {
        const pressure = dataView.getUint32(0, true) * scalar;
        const altitude = this.#calculcateAltitude(pressure);
        _console$C.log({ pressure, altitude });
        return { pressure };
    }
}

const _console$B = createConsole("ParseUtils", { log: false });
function parseStringFromDataView(dataView, byteOffset = 0) {
    const stringLength = dataView.getUint8(byteOffset++);
    const string = textDecoder.decode(dataView.buffer.slice(dataView.byteOffset + byteOffset, dataView.byteOffset + byteOffset + stringLength));
    byteOffset += stringLength;
    return { string, byteOffset };
}
function parseMessage(dataView, messageTypes, callback, context, parseMessageLengthAsUint16 = false) {
    let byteOffset = 0;
    while (byteOffset < dataView.byteLength) {
        const messageTypeEnum = dataView.getUint8(byteOffset++);
        _console$B.assertWithError(messageTypeEnum in messageTypes, `invalid messageTypeEnum ${messageTypeEnum}`);
        const messageType = messageTypes[messageTypeEnum];
        let messageLength;
        if (parseMessageLengthAsUint16) {
            messageLength = dataView.getUint16(byteOffset, true);
            byteOffset += 2;
        }
        else {
            messageLength = dataView.getUint8(byteOffset++);
        }
        _console$B.log({
            messageTypeEnum,
            messageType,
            messageLength,
            dataView,
            byteOffset,
        });
        const _dataView = sliceDataView(dataView, byteOffset, messageLength);
        _console$B.log({ _dataView });
        callback(messageType, _dataView, context);
        byteOffset += messageLength;
    }
}

var _a$4;
const _console$A = createConsole("CameraManager", { log: false });
const CameraSensorTypes = ["camera"];
const CameraCommands = [
    "focus",
    "takePicture",
    "stop",
    "sleep",
    "wake",
];
const CameraStatuses = [
    "idle",
    "focusing",
    "takingPicture",
    "asleep",
];
const CameraDataTypes = [
    "headerSize",
    "header",
    "imageSize",
    "image",
    "footerSize",
    "footer",
];
const CameraConfigurationTypes = [
    "resolution",
    "qualityFactor",
    "shutter",
    "gain",
    "redGain",
    "greenGain",
    "blueGain",
];
const CameraMessageTypes = [
    "cameraStatus",
    "cameraCommand",
    "getCameraConfiguration",
    "setCameraConfiguration",
    "cameraData",
];
const RequiredCameraMessageTypes = [
    "getCameraConfiguration",
    "cameraStatus",
];
const CameraEventTypes = [
    ...CameraMessageTypes,
    "cameraImageProgress",
    "cameraImage",
];
class CameraManager {
    constructor() {
        autoBind(this);
    }
    sendMessage;
    eventDispatcher;
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    requestRequiredInformation() {
        _console$A.log("requesting required camera information");
        const messages = RequiredCameraMessageTypes.map((messageType) => ({
            type: messageType,
        }));
        this.sendMessage(messages, false);
    }
    #cameraStatus;
    get cameraStatus() {
        return this.#cameraStatus;
    }
    #parseCameraStatus(dataView) {
        const cameraStatusIndex = dataView.getUint8(0);
        const newCameraStatus = CameraStatuses[cameraStatusIndex];
        this.#updateCameraStatus(newCameraStatus);
    }
    #updateCameraStatus(newCameraStatus) {
        _console$A.assertEnumWithError(newCameraStatus, CameraStatuses);
        if (newCameraStatus == this.#cameraStatus) {
            _console$A.log(`redundant cameraStatus ${newCameraStatus}`);
            return;
        }
        const previousCameraStatus = this.#cameraStatus;
        this.#cameraStatus = newCameraStatus;
        _console$A.log(`updated cameraStatus to "${this.cameraStatus}"`);
        this.#dispatchEvent("cameraStatus", {
            cameraStatus: this.cameraStatus,
            previousCameraStatus,
        });
        if (this.#cameraStatus != "takingPicture" &&
            this.#imageProgress > 0 &&
            !this.#didBuildImage) {
            this.#buildImage();
        }
    }
    async #sendCameraCommand(command, sendImmediately) {
        _console$A.assertEnumWithError(command, CameraCommands);
        _console$A.log(`sending camera command "${command}"`);
        const promise = this.waitForEvent("cameraStatus");
        _console$A.log(`setting command "${command}"`);
        const commandEnum = CameraCommands.indexOf(command);
        this.sendMessage([
            {
                type: "cameraCommand",
                data: UInt8ByteBuffer(commandEnum),
            },
        ], sendImmediately);
        await promise;
    }
    #assertIsAsleep() {
        _console$A.assertWithError(this.#cameraStatus == "asleep", `camera is not asleep - currently ${this.#cameraStatus}`);
    }
    #assertIsAwake() {
        _console$A.assertWithError(this.#cameraStatus != "asleep", `camera is not awake - currently ${this.#cameraStatus}`);
    }
    async focus() {
        this.#assertIsAwake();
        await this.#sendCameraCommand("focus");
    }
    async takePicture() {
        this.#assertIsAwake();
        await this.#sendCameraCommand("takePicture");
    }
    async stop() {
        this.#assertIsAwake();
        await this.#sendCameraCommand("stop");
    }
    async sleep() {
        this.#assertIsAwake();
        await this.#sendCameraCommand("sleep");
    }
    async wake() {
        this.#assertIsAsleep();
        await this.#sendCameraCommand("wake");
    }
    #parseCameraData(dataView) {
        _console$A.log("parsing camera data", dataView);
        parseMessage(dataView, CameraDataTypes, this.#onCameraData.bind(this), null, true);
    }
    #onCameraData(cameraDataType, dataView) {
        _console$A.log({ cameraDataType, dataView });
        switch (cameraDataType) {
            case "headerSize":
                this.#headerSize = dataView.getUint16(0, true);
                _console$A.log({ headerSize: this.#headerSize });
                this.#headerData = undefined;
                this.#headerProgress == 0;
                break;
            case "header":
                this.#headerData = concatenateArrayBuffers(this.#headerData, dataView);
                _console$A.log({ headerData: this.#headerData });
                this.#headerProgress = this.#headerData?.byteLength / this.#headerSize;
                _console$A.log({ headerProgress: this.#headerProgress });
                this.#dispatchEvent("cameraImageProgress", {
                    progress: this.#headerProgress,
                    type: "header",
                });
                if (this.#headerProgress == 1) {
                    _console$A.log("finished getting header data");
                }
                break;
            case "imageSize":
                this.#imageSize = dataView.getUint16(0, true);
                _console$A.log({ imageSize: this.#imageSize });
                this.#imageData = undefined;
                this.#imageProgress == 0;
                this.#didBuildImage = false;
                break;
            case "image":
                this.#imageData = concatenateArrayBuffers(this.#imageData, dataView);
                _console$A.log({ imageData: this.#imageData });
                this.#imageProgress = this.#imageData?.byteLength / this.#imageSize;
                _console$A.log({ imageProgress: this.#imageProgress });
                this.#dispatchEvent("cameraImageProgress", {
                    progress: this.#imageProgress,
                    type: "image",
                });
                if (this.#imageProgress == 1) {
                    _console$A.log("finished getting image data");
                    if (this.#headerProgress == 1 && this.#footerProgress == 1) {
                        this.#buildImage();
                    }
                }
                break;
            case "footerSize":
                this.#footerSize = dataView.getUint16(0, true);
                _console$A.log({ footerSize: this.#footerSize });
                this.#footerData = undefined;
                this.#footerProgress == 0;
                break;
            case "footer":
                this.#footerData = concatenateArrayBuffers(this.#footerData, dataView);
                _console$A.log({ footerData: this.#footerData });
                this.#footerProgress = this.#footerData?.byteLength / this.#footerSize;
                _console$A.log({ footerProgress: this.#footerProgress });
                this.#dispatchEvent("cameraImageProgress", {
                    progress: this.#footerProgress,
                    type: "footer",
                });
                if (this.#footerProgress == 1) {
                    _console$A.log("finished getting footer data");
                    if (this.#imageProgress == 1) {
                        this.#buildImage();
                    }
                }
                break;
        }
    }
    #headerSize = 0;
    #headerData;
    #headerProgress = 0;
    #imageSize = 0;
    #imageData;
    #imageProgress = 0;
    #footerSize = 0;
    #footerData;
    #footerProgress = 0;
    #didBuildImage = false;
    #buildImage() {
        _console$A.log("building image...");
        const imageData = concatenateArrayBuffers(this.#headerData, this.#imageData, this.#footerData);
        _console$A.log({ imageData });
        let blob = new Blob([imageData], { type: "image/jpeg" });
        _console$A.log("created blob", blob);
        const url = URL.createObjectURL(blob);
        _console$A.log("created url", url);
        this.#dispatchEvent("cameraImage", { url, blob });
        this.#didBuildImage = true;
    }
    #cameraConfiguration = {};
    get cameraConfiguration() {
        return this.#cameraConfiguration;
    }
    #availableCameraConfigurationTypes;
    get availableCameraConfigurationTypes() {
        return this.#availableCameraConfigurationTypes;
    }
    #cameraConfigurationRanges = {
        resolution: { min: 100, max: 720 },
        qualityFactor: { min: 15, max: 60 },
        shutter: { min: 4, max: 16383 },
        gain: { min: 1, max: 248 },
        redGain: { min: 0, max: 1023 },
        greenGain: { min: 0, max: 1023 },
        blueGain: { min: 0, max: 1023 },
    };
    get cameraConfigurationRanges() {
        return this.#cameraConfigurationRanges;
    }
    #parseCameraConfiguration(dataView) {
        const parsedCameraConfiguration = {};
        let byteOffset = 0;
        while (byteOffset < dataView.byteLength) {
            const cameraConfigurationTypeIndex = dataView.getUint8(byteOffset++);
            const cameraConfigurationType = CameraConfigurationTypes[cameraConfigurationTypeIndex];
            _console$A.assertWithError(cameraConfigurationType, `invalid cameraConfigurationTypeIndex ${cameraConfigurationTypeIndex}`);
            parsedCameraConfiguration[cameraConfigurationType] = dataView.getUint16(byteOffset, true);
            byteOffset += 2;
        }
        _console$A.log({ parsedCameraConfiguration });
        this.#availableCameraConfigurationTypes = Object.keys(parsedCameraConfiguration);
        this.#cameraConfiguration = parsedCameraConfiguration;
        this.#dispatchEvent("getCameraConfiguration", {
            cameraConfiguration: this.#cameraConfiguration,
        });
    }
    #isCameraConfigurationRedundant(cameraConfiguration) {
        let cameraConfigurationTypes = Object.keys(cameraConfiguration);
        return cameraConfigurationTypes.every((cameraConfigurationType) => {
            return (this.cameraConfiguration[cameraConfigurationType] ==
                cameraConfiguration[cameraConfigurationType]);
        });
    }
    async setCameraConfiguration(newCameraConfiguration) {
        _console$A.log({ newCameraConfiguration });
        if (this.#isCameraConfigurationRedundant(newCameraConfiguration)) {
            _console$A.log("redundant camera configuration");
            return;
        }
        const setCameraConfigurationData = this.#createData(newCameraConfiguration);
        _console$A.log({ setCameraConfigurationData });
        const promise = this.waitForEvent("getCameraConfiguration");
        this.sendMessage([
            {
                type: "setCameraConfiguration",
                data: setCameraConfigurationData.buffer,
            },
        ]);
        await promise;
    }
    #assertAvailableCameraConfigurationType(cameraConfigurationType) {
        _console$A.assertWithError(this.#availableCameraConfigurationTypes, "must get initial cameraConfiguration");
        const isCameraConfigurationTypeAvailable = this.#availableCameraConfigurationTypes?.includes(cameraConfigurationType);
        _console$A.assertWithError(isCameraConfigurationTypeAvailable, `unavailable camera configuration type "${cameraConfigurationType}"`);
        return isCameraConfigurationTypeAvailable;
    }
    static AssertValidCameraConfigurationType(cameraConfigurationType) {
        _console$A.assertEnumWithError(cameraConfigurationType, CameraConfigurationTypes);
    }
    static AssertValidCameraConfigurationTypeEnum(cameraConfigurationTypeEnum) {
        _console$A.assertTypeWithError(cameraConfigurationTypeEnum, "number");
        _console$A.assertWithError(cameraConfigurationTypeEnum in CameraConfigurationTypes, `invalid cameraConfigurationTypeEnum ${cameraConfigurationTypeEnum}`);
    }
    #createData(cameraConfiguration) {
        let cameraConfigurationTypes = Object.keys(cameraConfiguration);
        cameraConfigurationTypes = cameraConfigurationTypes.filter((cameraConfigurationType) => this.#assertAvailableCameraConfigurationType(cameraConfigurationType));
        const dataView = new DataView(new ArrayBuffer(cameraConfigurationTypes.length * 3));
        cameraConfigurationTypes.forEach((cameraConfigurationType, index) => {
            _a$4.AssertValidCameraConfigurationType(cameraConfigurationType);
            const cameraConfigurationTypeEnum = CameraConfigurationTypes.indexOf(cameraConfigurationType);
            dataView.setUint8(index * 3, cameraConfigurationTypeEnum);
            const value = cameraConfiguration[cameraConfigurationType];
            dataView.setUint16(index * 3 + 1, value, true);
        });
        _console$A.log({ sensorConfigurationData: dataView });
        return dataView;
    }
    parseMessage(messageType, dataView) {
        _console$A.log({ messageType, dataView });
        switch (messageType) {
            case "cameraStatus":
                this.#parseCameraStatus(dataView);
                break;
            case "getCameraConfiguration":
            case "setCameraConfiguration":
                this.#parseCameraConfiguration(dataView);
                break;
            case "cameraData":
                this.#parseCameraData(dataView);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
    clear() {
        this.#cameraStatus = undefined;
        this.#headerProgress = 0;
        this.#imageProgress = 0;
        this.#footerProgress = 0;
    }
}
_a$4 = CameraManager;

createConsole("AudioUtils", { log: false });
function float32ArrayToWav(audioData, sampleRate, numChannels) {
    const wavBuffer = encodeWAV(audioData, sampleRate, numChannels);
    return new Blob([wavBuffer], { type: "audio/wav" });
}
function encodeWAV(interleaved, sampleRate, numChannels) {
    const buffer = new ArrayBuffer(44 + interleaved.length * 2);
    const view = new DataView(buffer);
    writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + interleaved.length * 2, true);
    writeString(view, 8, "WAVE");
    writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numChannels * 2, true);
    view.setUint16(32, numChannels * 2, true);
    view.setUint16(34, 16, true);
    writeString(view, 36, "data");
    view.setUint32(40, interleaved.length * 2, true);
    for (let i = 0; i < interleaved.length; i++) {
        view.setInt16(44 + i * 2, interleaved[i] * 0x7fff, true);
    }
    return buffer;
}
function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

var _a$3;
const _console$z = createConsole("MicrophoneManager", { log: false });
const MicrophoneSensorTypes = ["microphone"];
const MicrophoneCommands = ["start", "stop", "vad"];
const MicrophoneStatuses = ["idle", "streaming", "vad"];
const MicrophoneConfigurationTypes = ["sampleRate", "bitDepth"];
const MicrophoneSampleRates = ["8000", "16000"];
const MicrophoneBitDepths = ["8", "16"];
const MicrophoneMessageTypes = [
    "microphoneStatus",
    "microphoneCommand",
    "getMicrophoneConfiguration",
    "setMicrophoneConfiguration",
    "microphoneData",
];
const MicrophoneConfigurationValues = {
    sampleRate: MicrophoneSampleRates,
    bitDepth: MicrophoneBitDepths,
};
const RequiredMicrophoneMessageTypes = [
    "getMicrophoneConfiguration",
    "microphoneStatus",
];
const MicrophoneEventTypes = [
    ...MicrophoneMessageTypes,
    "isRecordingMicrophone",
    "microphoneRecording",
];
class MicrophoneManager {
    constructor() {
        autoBind(this);
    }
    sendMessage;
    eventDispatcher;
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    requestRequiredInformation() {
        _console$z.log("requesting required microphone information");
        const messages = RequiredMicrophoneMessageTypes.map((messageType) => ({
            type: messageType,
        }));
        this.sendMessage(messages, false);
    }
    #microphoneStatus;
    get microphoneStatus() {
        return this.#microphoneStatus;
    }
    #parseMicrophoneStatus(dataView) {
        const microphoneStatusIndex = dataView.getUint8(0);
        const newMicrophoneStatus = MicrophoneStatuses[microphoneStatusIndex];
        this.#updateMicrophoneStatus(newMicrophoneStatus);
    }
    #updateMicrophoneStatus(newMicrophoneStatus) {
        _console$z.assertEnumWithError(newMicrophoneStatus, MicrophoneStatuses);
        if (newMicrophoneStatus == this.#microphoneStatus) {
            _console$z.log(`redundant microphoneStatus ${newMicrophoneStatus}`);
            return;
        }
        const previousMicrophoneStatus = this.#microphoneStatus;
        this.#microphoneStatus = newMicrophoneStatus;
        _console$z.log(`updated microphoneStatus to "${this.microphoneStatus}"`);
        this.#dispatchEvent("microphoneStatus", {
            microphoneStatus: this.microphoneStatus,
            previousMicrophoneStatus,
        });
    }
    async #sendMicrophoneCommand(command, sendImmediately) {
        _console$z.assertEnumWithError(command, MicrophoneCommands);
        _console$z.log(`sending microphone command "${command}"`);
        const promise = this.waitForEvent("microphoneStatus");
        _console$z.log(`setting command "${command}"`);
        const commandEnum = MicrophoneCommands.indexOf(command);
        this.sendMessage([
            {
                type: "microphoneCommand",
                data: UInt8ByteBuffer(commandEnum),
            },
        ], sendImmediately);
        await promise;
    }
    #assertIsIdle() {
        _console$z.assertWithError(this.#microphoneStatus == "idle", `microphone is not idle - currently ${this.#microphoneStatus}`);
    }
    #assertIsNotIdle() {
        _console$z.assertWithError(this.#microphoneStatus != "idle", `microphone is idle`);
    }
    #assertIsStreaming() {
        _console$z.assertWithError(this.#microphoneStatus == "streaming", `microphone is not recording - currently ${this.#microphoneStatus}`);
    }
    async start() {
        await this.#sendMicrophoneCommand("start");
    }
    async stop() {
        if (this.microphoneStatus == "idle") {
            _console$z.log("microphone is already idle");
            return;
        }
        await this.#sendMicrophoneCommand("stop");
    }
    async vad() {
        await this.#sendMicrophoneCommand("vad");
    }
    async toggle() {
        switch (this.microphoneStatus) {
            case "idle":
                this.start();
                break;
            case "streaming":
                this.stop();
                break;
        }
    }
    #assertValidBitDepth() {
        _console$z.assertEnumWithError(this.bitDepth, MicrophoneBitDepths);
    }
    #fadeDuration = 0.001;
    #playbackTime = 0;
    #parseMicrophoneData(dataView) {
        this.#assertValidBitDepth();
        _console$z.log("parsing microphone data", dataView);
        const numberOfSamples = dataView.byteLength / this.#bytesPerSample;
        const samples = new Float32Array(numberOfSamples);
        for (let i = 0; i < numberOfSamples; i++) {
            let sample;
            switch (this.bitDepth) {
                case "16":
                    sample = dataView.getInt16(i * 2, true);
                    samples[i] = sample / 2 ** 15;
                    break;
                case "8":
                    sample = dataView.getInt8(i);
                    samples[i] = sample / 2 ** 7;
                    break;
            }
        }
        _console$z.log("samples", samples);
        if (this.#isRecording && this.#microphoneRecordingData) {
            this.#microphoneRecordingData.push(samples);
        }
        if (this.#audioContext) {
            if (this.#gainNode) {
                const audioBuffer = this.#audioContext.createBuffer(1, samples.length, Number(this.sampleRate));
                audioBuffer.getChannelData(0).set(samples);
                const bufferSource = this.#audioContext.createBufferSource();
                bufferSource.buffer = audioBuffer;
                const channelData = audioBuffer.getChannelData(0);
                const sampleRate = Number(this.sampleRate);
                for (let i = 0; i < this.#fadeDuration * sampleRate; i++) {
                    channelData[i] *= i / (this.#fadeDuration * sampleRate);
                }
                for (let i = channelData.length - 1; i >= channelData.length - this.#fadeDuration * sampleRate; i--) {
                    channelData[i] *=
                        (channelData.length - i) / (this.#fadeDuration * sampleRate);
                }
                bufferSource.connect(this.#gainNode);
                if (this.#playbackTime < this.#audioContext.currentTime) {
                    this.#playbackTime = this.#audioContext.currentTime;
                }
                bufferSource.start(this.#playbackTime);
                this.#playbackTime += audioBuffer.duration;
            }
        }
        this.#dispatchEvent("microphoneData", {
            samples,
            sampleRate: this.sampleRate,
            bitDepth: this.bitDepth,
        });
    }
    get #bytesPerSample() {
        switch (this.bitDepth) {
            case "8":
                return 1;
            case "16":
                return 2;
        }
    }
    #microphoneConfiguration = {};
    get microphoneConfiguration() {
        return this.#microphoneConfiguration;
    }
    #availableMicrophoneConfigurationTypes;
    get availableMicrophoneConfigurationTypes() {
        return this.#availableMicrophoneConfigurationTypes;
    }
    get bitDepth() {
        return this.#microphoneConfiguration.bitDepth;
    }
    get sampleRate() {
        return this.#microphoneConfiguration.sampleRate;
    }
    #parseMicrophoneConfiguration(dataView) {
        const parsedMicrophoneConfiguration = {};
        let byteOffset = 0;
        while (byteOffset < dataView.byteLength) {
            const microphoneConfigurationTypeIndex = dataView.getUint8(byteOffset++);
            const microphoneConfigurationType = MicrophoneConfigurationTypes[microphoneConfigurationTypeIndex];
            _console$z.assertWithError(microphoneConfigurationType, `invalid microphoneConfigurationTypeIndex ${microphoneConfigurationTypeIndex}`);
            let rawValue = dataView.getUint8(byteOffset++);
            const values = MicrophoneConfigurationValues[microphoneConfigurationType];
            const value = values[rawValue];
            _console$z.assertEnumWithError(value, values);
            _console$z.log({ microphoneConfigurationType, value });
            parsedMicrophoneConfiguration[microphoneConfigurationType] = value;
        }
        _console$z.log({ parsedMicrophoneConfiguration });
        this.#availableMicrophoneConfigurationTypes = Object.keys(parsedMicrophoneConfiguration);
        this.#microphoneConfiguration = parsedMicrophoneConfiguration;
        this.#dispatchEvent("getMicrophoneConfiguration", {
            microphoneConfiguration: this.#microphoneConfiguration,
        });
    }
    #isMicrophoneConfigurationRedundant(microphoneConfiguration) {
        let microphoneConfigurationTypes = Object.keys(microphoneConfiguration);
        return microphoneConfigurationTypes.every((microphoneConfigurationType) => {
            return (this.microphoneConfiguration[microphoneConfigurationType] ==
                microphoneConfiguration[microphoneConfigurationType]);
        });
    }
    async setMicrophoneConfiguration(newMicrophoneConfiguration) {
        _console$z.log({ newMicrophoneConfiguration });
        if (this.#isMicrophoneConfigurationRedundant(newMicrophoneConfiguration)) {
            _console$z.log("redundant microphone configuration");
            return;
        }
        const setMicrophoneConfigurationData = this.#createData(newMicrophoneConfiguration);
        _console$z.log({ setMicrophoneConfigurationData });
        const promise = this.waitForEvent("getMicrophoneConfiguration");
        this.sendMessage([
            {
                type: "setMicrophoneConfiguration",
                data: setMicrophoneConfigurationData.buffer,
            },
        ]);
        await promise;
    }
    #assertAvailableMicrophoneConfigurationType(microphoneConfigurationType) {
        _console$z.assertWithError(this.#availableMicrophoneConfigurationTypes, "must get initial microphoneConfiguration");
        const isMicrophoneConfigurationTypeAvailable = this.#availableMicrophoneConfigurationTypes?.includes(microphoneConfigurationType);
        _console$z.assertWithError(isMicrophoneConfigurationTypeAvailable, `unavailable microphone configuration type "${microphoneConfigurationType}"`);
        return isMicrophoneConfigurationTypeAvailable;
    }
    static AssertValidMicrophoneConfigurationType(microphoneConfigurationType) {
        _console$z.assertEnumWithError(microphoneConfigurationType, MicrophoneConfigurationTypes);
    }
    static AssertValidMicrophoneConfigurationTypeEnum(microphoneConfigurationTypeEnum) {
        _console$z.assertTypeWithError(microphoneConfigurationTypeEnum, "number");
        _console$z.assertWithError(microphoneConfigurationTypeEnum in MicrophoneConfigurationTypes, `invalid microphoneConfigurationTypeEnum ${microphoneConfigurationTypeEnum}`);
    }
    #createData(microphoneConfiguration) {
        let microphoneConfigurationTypes = Object.keys(microphoneConfiguration);
        microphoneConfigurationTypes = microphoneConfigurationTypes.filter((microphoneConfigurationType) => this.#assertAvailableMicrophoneConfigurationType(microphoneConfigurationType));
        const dataView = new DataView(new ArrayBuffer(microphoneConfigurationTypes.length * 2));
        microphoneConfigurationTypes.forEach((microphoneConfigurationType, index) => {
            _a$3.AssertValidMicrophoneConfigurationType(microphoneConfigurationType);
            const microphoneConfigurationTypeEnum = MicrophoneConfigurationTypes.indexOf(microphoneConfigurationType);
            dataView.setUint8(index * 2, microphoneConfigurationTypeEnum);
            let value = microphoneConfiguration[microphoneConfigurationType];
            if (typeof value == "number") {
                value = value.toString();
            }
            const values = MicrophoneConfigurationValues[microphoneConfigurationType];
            _console$z.assertEnumWithError(value, values);
            const rawValue = values.indexOf(value);
            dataView.setUint8(index * 2 + 1, rawValue);
        });
        _console$z.log({ sensorConfigurationData: dataView });
        return dataView;
    }
    parseMessage(messageType, dataView) {
        _console$z.log({ messageType, dataView });
        switch (messageType) {
            case "microphoneStatus":
                this.#parseMicrophoneStatus(dataView);
                break;
            case "getMicrophoneConfiguration":
            case "setMicrophoneConfiguration":
                this.#parseMicrophoneConfiguration(dataView);
                break;
            case "microphoneData":
                this.#parseMicrophoneData(dataView);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
    #audioContext;
    get audioContext() {
        return this.#audioContext;
    }
    set audioContext(newAudioContext) {
        if (this.#audioContext == newAudioContext) {
            _console$z.log("redundant audioContext assignment", this.#audioContext);
            return;
        }
        this.#audioContext = newAudioContext;
        _console$z.log("assigned new audioContext", this.#audioContext);
        if (this.#audioContext) {
            this.#playbackTime = this.#audioContext.currentTime;
        }
        else {
            if (this.#mediaStreamDestination) {
                this.#mediaStreamDestination.disconnect();
                this.#mediaStreamDestination = undefined;
            }
            if (this.#gainNode) {
                this.#gainNode.disconnect();
                this.#gainNode = undefined;
            }
        }
    }
    #gainNode;
    get gainNode() {
        _console$z.assertWithError(this.#audioContext, "audioContext assignment required for gainNode");
        if (!this.#gainNode) {
            _console$z.log("creating gainNode...");
            this.#gainNode = this.#audioContext.createGain();
            _console$z.log("created gainNode", this.#gainNode);
        }
        return this.#gainNode;
    }
    #mediaStreamDestination;
    get mediaStreamDestination() {
        _console$z.assertWithError(this.#audioContext, "audioContext assignment required for mediaStreamDestination");
        if (!this.#mediaStreamDestination) {
            _console$z.log("creating mediaStreamDestination...");
            this.#mediaStreamDestination =
                this.#audioContext.createMediaStreamDestination();
            this.gainNode?.connect(this.#mediaStreamDestination);
            _console$z.log("created mediaStreamDestination", this.#mediaStreamDestination);
        }
        return this.#mediaStreamDestination;
    }
    #isRecording = false;
    get isRecording() {
        return this.#isRecording;
    }
    #microphoneRecordingData;
    startRecording() {
        if (this.isRecording) {
            _console$z.log("already recording");
            return;
        }
        this.#microphoneRecordingData = [];
        this.#isRecording = true;
        this.#dispatchEvent("isRecordingMicrophone", {
            isRecordingMicrophone: this.isRecording,
        });
    }
    stopRecording() {
        if (!this.isRecording) {
            _console$z.log("already not recording");
            return;
        }
        this.#isRecording = false;
        if (this.#microphoneRecordingData &&
            this.#microphoneRecordingData.length > 0) {
            _console$z.log("parsing microphone data...", this.#microphoneRecordingData.length);
            const arrayBuffer = concatenateArrayBuffers(...this.#microphoneRecordingData);
            const samples = new Float32Array(arrayBuffer);
            const blob = float32ArrayToWav(samples, Number(this.sampleRate), 1);
            const url = URL.createObjectURL(blob);
            this.#dispatchEvent("microphoneRecording", {
                samples,
                sampleRate: this.sampleRate,
                bitDepth: this.bitDepth,
                blob,
                url,
            });
        }
        this.#microphoneRecordingData = undefined;
        this.#dispatchEvent("isRecordingMicrophone", {
            isRecordingMicrophone: this.isRecording,
        });
    }
    toggleRecording() {
        if (this.#isRecording) {
            this.stopRecording();
        }
        else {
            this.startRecording();
        }
    }
    clear() {
        this.#microphoneStatus = undefined;
        this.#microphoneConfiguration = {};
        if (this.isRecording) {
            this.stopRecording();
        }
    }
}
_a$3 = MicrophoneManager;

const _console$y = createConsole("SensorDataManager", { log: false });
const SensorTypes = [
    ...PressureSensorTypes,
    ...MotionSensorTypes,
    ...BarometerSensorTypes,
    ...CameraSensorTypes,
    ...MicrophoneSensorTypes,
];
const ContinuousSensorTypes = [
    ...ContinuousPressureSensorTypes,
    ...ContinuousMotionTypes,
    ...ContinuousBarometerSensorTypes,
];
const SensorDataMessageTypes = [
    "getPressurePositions",
    "getSensorScalars",
    "sensorData",
];
const RequiredPressureMessageTypes = [
    "getPressurePositions",
];
const SensorDataEventTypes = [
    ...SensorDataMessageTypes,
    ...SensorTypes,
];
class SensorDataManager {
    pressureSensorDataManager = new PressureSensorDataManager();
    motionSensorDataManager = new MotionSensorDataManager();
    barometerSensorDataManager = new BarometerSensorDataManager();
    #scalars = new Map();
    static AssertValidSensorType(sensorType) {
        _console$y.assertEnumWithError(sensorType, SensorTypes);
    }
    static AssertValidSensorTypeEnum(sensorTypeEnum) {
        _console$y.assertTypeWithError(sensorTypeEnum, "number");
        _console$y.assertWithError(sensorTypeEnum in SensorTypes, `invalid sensorTypeEnum ${sensorTypeEnum}`);
    }
    eventDispatcher;
    get dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    parseMessage(messageType, dataView) {
        _console$y.log({ messageType });
        switch (messageType) {
            case "getSensorScalars":
                this.parseScalars(dataView);
                break;
            case "getPressurePositions":
                this.pressureSensorDataManager.parsePositions(dataView);
                break;
            case "sensorData":
                this.parseData(dataView);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
    parseScalars(dataView) {
        for (let byteOffset = 0; byteOffset < dataView.byteLength; byteOffset += 5) {
            const sensorTypeIndex = dataView.getUint8(byteOffset);
            const sensorType = SensorTypes[sensorTypeIndex];
            if (!sensorType) {
                _console$y.warn(`unknown sensorType index ${sensorTypeIndex}`);
                continue;
            }
            const sensorScalar = dataView.getFloat32(byteOffset + 1, true);
            _console$y.log({ sensorType, sensorScalar });
            this.#scalars.set(sensorType, sensorScalar);
        }
    }
    parseData(dataView) {
        _console$y.log("sensorData", Array.from(new Uint8Array(dataView.buffer)));
        let byteOffset = 0;
        const timestamp = parseTimestamp(dataView, byteOffset);
        byteOffset += 2;
        const _dataView = new DataView(dataView.buffer, byteOffset);
        parseMessage(_dataView, SensorTypes, this.parseDataCallback.bind(this), {
            timestamp,
        });
    }
    parseDataCallback(sensorType, dataView, { timestamp }) {
        const scalar = this.#scalars.get(sensorType) || 1;
        let sensorData = null;
        switch (sensorType) {
            case "pressure":
                sensorData = this.pressureSensorDataManager.parseData(dataView, scalar);
                break;
            case "acceleration":
            case "gravity":
            case "linearAcceleration":
            case "gyroscope":
            case "magnetometer":
                sensorData = this.motionSensorDataManager.parseVector3(dataView, scalar);
                break;
            case "gameRotation":
            case "rotation":
                sensorData = this.motionSensorDataManager.parseQuaternion(dataView, scalar);
                break;
            case "orientation":
                sensorData = this.motionSensorDataManager.parseEuler(dataView, scalar);
                break;
            case "stepCounter":
                sensorData = this.motionSensorDataManager.parseStepCounter(dataView);
                break;
            case "stepDetector":
                sensorData = {};
                break;
            case "activity":
                sensorData = this.motionSensorDataManager.parseActivity(dataView);
                break;
            case "deviceOrientation":
                sensorData =
                    this.motionSensorDataManager.parseDeviceOrientation(dataView);
                break;
            case "tapDetector":
                sensorData = {};
                break;
            case "barometer":
                sensorData = this.barometerSensorDataManager.parseData(dataView, scalar);
                break;
            case "camera":
                return;
            case "microphone":
                return;
            default:
                _console$y.error(`uncaught sensorType "${sensorType}"`);
        }
        _console$y.assertWithError(sensorData != null, `no sensorData defined for sensorType "${sensorType}"`);
        _console$y.log({ sensorType, sensorData });
        this.dispatchEvent(sensorType, {
            sensorType,
            [sensorType]: sensorData,
            timestamp,
        });
        this.dispatchEvent("sensorData", {
            sensorType,
            [sensorType]: sensorData,
            timestamp,
        });
    }
}

var _a$2;
const _console$x = createConsole("SensorConfigurationManager", { log: false });
const MaxSensorRate = 2 ** 16 - 1;
const SensorRateStep = 5;
const SensorConfigurationMessageTypes = [
    "getSensorConfiguration",
    "setSensorConfiguration",
];
const SensorConfigurationEventTypes = SensorConfigurationMessageTypes;
class SensorConfigurationManager {
    constructor() {
        autoBind(this);
    }
    sendMessage;
    eventDispatcher;
    get addEventListener() {
        return this.eventDispatcher.addEventListener;
    }
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    #availableSensorTypes;
    #assertAvailableSensorType(sensorType) {
        _console$x.assertWithError(this.#availableSensorTypes, "must get initial sensorConfiguration");
        const isSensorTypeAvailable = this.#availableSensorTypes?.includes(sensorType);
        _console$x.log(isSensorTypeAvailable, `unavailable sensor type "${sensorType}"`);
        return isSensorTypeAvailable;
    }
    #configuration = {};
    get configuration() {
        return this.#configuration;
    }
    #updateConfiguration(updatedConfiguration) {
        this.#configuration = updatedConfiguration;
        _console$x.log({ updatedConfiguration: this.#configuration });
        this.#dispatchEvent("getSensorConfiguration", {
            sensorConfiguration: this.configuration,
        });
    }
    clear() {
        this.#updateConfiguration({});
    }
    #isRedundant(sensorConfiguration) {
        let sensorTypes = Object.keys(sensorConfiguration);
        return sensorTypes.every((sensorType) => {
            return this.configuration[sensorType] == sensorConfiguration[sensorType];
        });
    }
    async setConfiguration(newSensorConfiguration, clearRest, sendImmediately) {
        if (clearRest) {
            newSensorConfiguration = Object.assign(structuredClone(this.zeroSensorConfiguration), newSensorConfiguration);
        }
        _console$x.log({ newSensorConfiguration });
        if (this.#isRedundant(newSensorConfiguration)) {
            _console$x.log("redundant sensor configuration");
            return;
        }
        const setSensorConfigurationData = this.#createData(newSensorConfiguration);
        _console$x.log({ setSensorConfigurationData });
        const promise = this.waitForEvent("getSensorConfiguration");
        this.sendMessage([
            {
                type: "setSensorConfiguration",
                data: setSensorConfigurationData.buffer,
            },
        ], sendImmediately);
        await promise;
    }
    #parse(dataView) {
        const parsedSensorConfiguration = {};
        for (let byteOffset = 0; byteOffset < dataView.byteLength; byteOffset += 3) {
            const sensorTypeIndex = dataView.getUint8(byteOffset);
            const sensorType = SensorTypes[sensorTypeIndex];
            const sensorRate = dataView.getUint16(byteOffset + 1, true);
            _console$x.log({ sensorType, sensorRate });
            if (!sensorType) {
                _console$x.warn(`unknown sensorType index ${sensorTypeIndex}`);
                continue;
            }
            parsedSensorConfiguration[sensorType] = sensorRate;
        }
        _console$x.log({ parsedSensorConfiguration });
        this.#availableSensorTypes = Object.keys(parsedSensorConfiguration);
        return parsedSensorConfiguration;
    }
    static #AssertValidSensorRate(sensorRate) {
        _console$x.assertTypeWithError(sensorRate, "number");
        _console$x.assertWithError(sensorRate >= 0, `sensorRate must be 0 or greater (got ${sensorRate})`);
        _console$x.assertWithError(sensorRate < MaxSensorRate, `sensorRate must be 0 or greater (got ${sensorRate})`);
        _console$x.assertWithError(sensorRate % SensorRateStep == 0, `sensorRate must be multiple of ${SensorRateStep}`);
    }
    #assertValidSensorRate(sensorRate) {
        _a$2.#AssertValidSensorRate(sensorRate);
    }
    #createData(sensorConfiguration) {
        let sensorTypes = Object.keys(sensorConfiguration);
        sensorTypes = sensorTypes.filter((sensorType) => this.#assertAvailableSensorType(sensorType));
        const dataView = new DataView(new ArrayBuffer(sensorTypes.length * 3));
        sensorTypes.forEach((sensorType, index) => {
            SensorDataManager.AssertValidSensorType(sensorType);
            const sensorTypeEnum = SensorTypes.indexOf(sensorType);
            dataView.setUint8(index * 3, sensorTypeEnum);
            const sensorRate = sensorConfiguration[sensorType];
            this.#assertValidSensorRate(sensorRate);
            dataView.setUint16(index * 3 + 1, sensorRate, true);
        });
        _console$x.log({ sensorConfigurationData: dataView });
        return dataView;
    }
    static #ZeroSensorConfiguration = {};
    static get ZeroSensorConfiguration() {
        return this.#ZeroSensorConfiguration;
    }
    static {
        SensorTypes.forEach((sensorType) => {
            this.#ZeroSensorConfiguration[sensorType] = 0;
        });
    }
    get zeroSensorConfiguration() {
        const zeroSensorConfiguration = {};
        this.#availableSensorTypes.forEach((sensorType) => {
            zeroSensorConfiguration[sensorType] = 0;
        });
        return zeroSensorConfiguration;
    }
    async clearSensorConfiguration() {
        return this.setConfiguration(this.zeroSensorConfiguration);
    }
    parseMessage(messageType, dataView) {
        _console$x.log({ messageType });
        switch (messageType) {
            case "getSensorConfiguration":
            case "setSensorConfiguration":
                const newSensorConfiguration = this.#parse(dataView);
                this.#updateConfiguration(newSensorConfiguration);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
}
_a$2 = SensorConfigurationManager;

const _console$w = createConsole("TfliteManager", { log: false });
const TfliteMessageTypes = [
    "getTfliteName",
    "setTfliteName",
    "getTfliteTask",
    "setTfliteTask",
    "getTfliteSampleRate",
    "setTfliteSampleRate",
    "getTfliteSensorTypes",
    "setTfliteSensorTypes",
    "tfliteIsReady",
    "getTfliteCaptureDelay",
    "setTfliteCaptureDelay",
    "getTfliteThreshold",
    "setTfliteThreshold",
    "getTfliteInferencingEnabled",
    "setTfliteInferencingEnabled",
    "tfliteInference",
];
const TfliteEventTypes = TfliteMessageTypes;
const RequiredTfliteMessageTypes = [
    "getTfliteName",
    "getTfliteTask",
    "getTfliteSampleRate",
    "getTfliteSensorTypes",
    "tfliteIsReady",
    "getTfliteCaptureDelay",
    "getTfliteThreshold",
    "getTfliteInferencingEnabled",
];
const TfliteTasks = ["classification", "regression"];
const TfliteSensorTypes = [
    "pressure",
    "linearAcceleration",
    "gyroscope",
    "magnetometer",
];
class TfliteManager {
    constructor() {
        autoBind(this);
    }
    sendMessage;
    #assertValidTask(task) {
        _console$w.assertEnumWithError(task, TfliteTasks);
    }
    #assertValidTaskEnum(taskEnum) {
        _console$w.assertWithError(taskEnum in TfliteTasks, `invalid taskEnum ${taskEnum}`);
    }
    eventDispatcher;
    get addEventListenter() {
        return this.eventDispatcher.addEventListener;
    }
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get removeEventListener() {
        return this.eventDispatcher.removeEventListener;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    #name;
    get name() {
        return this.#name;
    }
    #parseName(dataView) {
        _console$w.log("parseName", dataView);
        const name = textDecoder.decode(dataView.buffer);
        this.#updateName(name);
    }
    #updateName(name) {
        _console$w.log({ name });
        this.#name = name;
        this.#dispatchEvent("getTfliteName", { tfliteName: name });
    }
    async setName(newName, sendImmediately) {
        _console$w.assertTypeWithError(newName, "string");
        if (this.name == newName) {
            _console$w.log(`redundant name assignment ${newName}`);
            return;
        }
        const promise = this.waitForEvent("getTfliteName");
        const setNameData = textEncoder.encode(newName);
        this.sendMessage([{ type: "setTfliteName", data: setNameData.buffer }], sendImmediately);
        await promise;
    }
    #task;
    get task() {
        return this.#task;
    }
    #parseTask(dataView) {
        _console$w.log("parseTask", dataView);
        const taskEnum = dataView.getUint8(0);
        this.#assertValidTaskEnum(taskEnum);
        const task = TfliteTasks[taskEnum];
        this.#updateTask(task);
    }
    #updateTask(task) {
        _console$w.log({ task });
        this.#task = task;
        this.#dispatchEvent("getTfliteTask", { tfliteTask: task });
    }
    async setTask(newTask, sendImmediately) {
        this.#assertValidTask(newTask);
        if (this.task == newTask) {
            _console$w.log(`redundant task assignment ${newTask}`);
            return;
        }
        const promise = this.waitForEvent("getTfliteTask");
        const taskEnum = TfliteTasks.indexOf(newTask);
        this.sendMessage([{ type: "setTfliteTask", data: UInt8ByteBuffer(taskEnum) }], sendImmediately);
        await promise;
    }
    #sampleRate;
    get sampleRate() {
        return this.#sampleRate;
    }
    #parseSampleRate(dataView) {
        _console$w.log("parseSampleRate", dataView);
        const sampleRate = dataView.getUint16(0, true);
        this.#updateSampleRate(sampleRate);
    }
    #updateSampleRate(sampleRate) {
        _console$w.log({ sampleRate });
        this.#sampleRate = sampleRate;
        this.#dispatchEvent("getTfliteSampleRate", {
            tfliteSampleRate: sampleRate,
        });
    }
    async setSampleRate(newSampleRate, sendImmediately) {
        _console$w.assertTypeWithError(newSampleRate, "number");
        newSampleRate -= newSampleRate % SensorRateStep;
        _console$w.assertWithError(newSampleRate >= SensorRateStep, `sampleRate must be multiple of ${SensorRateStep} greater than 0 (got ${newSampleRate})`);
        if (this.#sampleRate == newSampleRate) {
            _console$w.log(`redundant sampleRate assignment ${newSampleRate}`);
            return;
        }
        const promise = this.waitForEvent("getTfliteSampleRate");
        const dataView = new DataView(new ArrayBuffer(2));
        dataView.setUint16(0, newSampleRate, true);
        this.sendMessage([{ type: "setTfliteSampleRate", data: dataView.buffer }], sendImmediately);
        await promise;
    }
    static AssertValidSensorType(sensorType) {
        SensorDataManager.AssertValidSensorType(sensorType);
        const tfliteSensorType = sensorType;
        _console$w.assertWithError(TfliteSensorTypes.includes(tfliteSensorType), `invalid tflite sensorType "${sensorType}"`);
    }
    #sensorTypes = [];
    get sensorTypes() {
        return this.#sensorTypes.slice();
    }
    #parseSensorTypes(dataView) {
        _console$w.log("parseSensorTypes", dataView);
        const sensorTypes = [];
        for (let index = 0; index < dataView.byteLength; index++) {
            const sensorTypeEnum = dataView.getUint8(index);
            const sensorType = SensorTypes[sensorTypeEnum];
            if (sensorType) {
                if (TfliteSensorTypes.includes(sensorType)) {
                    sensorTypes.push(sensorType);
                }
                else {
                    _console$w.error(`invalid tfliteSensorType ${sensorType}`);
                }
            }
            else {
                _console$w.error(`invalid sensorTypeEnum ${sensorTypeEnum}`);
            }
        }
        this.#updateSensorTypes(sensorTypes);
    }
    #updateSensorTypes(sensorTypes) {
        _console$w.log({ sensorTypes });
        this.#sensorTypes = sensorTypes;
        this.#dispatchEvent("getTfliteSensorTypes", {
            tfliteSensorTypes: sensorTypes,
        });
    }
    async setSensorTypes(newSensorTypes, sendImmediately) {
        newSensorTypes.forEach((sensorType) => {
            TfliteManager.AssertValidSensorType(sensorType);
        });
        const promise = this.waitForEvent("getTfliteSensorTypes");
        newSensorTypes = arrayWithoutDuplicates(newSensorTypes);
        const newSensorTypeEnums = newSensorTypes
            .map((sensorType) => SensorTypes.indexOf(sensorType))
            .sort();
        _console$w.log(newSensorTypes, newSensorTypeEnums);
        this.sendMessage([
            {
                type: "setTfliteSensorTypes",
                data: Uint8Array.from(newSensorTypeEnums).buffer,
            },
        ], sendImmediately);
        await promise;
    }
    #isReady;
    get isReady() {
        return this.#isReady;
    }
    #parseIsReady(dataView) {
        _console$w.log("parseIsReady", dataView);
        const isReady = Boolean(dataView.getUint8(0));
        this.#updateIsReady(isReady);
    }
    #updateIsReady(isReady) {
        _console$w.log({ isReady });
        this.#isReady = isReady;
        this.#dispatchEvent("tfliteIsReady", { tfliteIsReady: isReady });
    }
    #assertIsReady() {
        _console$w.assertWithError(this.isReady, `tflite is not ready`);
    }
    #captureDelay;
    get captureDelay() {
        return this.#captureDelay;
    }
    #parseCaptureDelay(dataView) {
        _console$w.log("parseCaptureDelay", dataView);
        const captureDelay = dataView.getUint16(0, true);
        this.#updateCaptueDelay(captureDelay);
    }
    #updateCaptueDelay(captureDelay) {
        _console$w.log({ captureDelay });
        this.#captureDelay = captureDelay;
        this.#dispatchEvent("getTfliteCaptureDelay", {
            tfliteCaptureDelay: captureDelay,
        });
    }
    async setCaptureDelay(newCaptureDelay, sendImmediately) {
        _console$w.assertTypeWithError(newCaptureDelay, "number");
        if (this.#captureDelay == newCaptureDelay) {
            _console$w.log(`redundant captureDelay assignment ${newCaptureDelay}`);
            return;
        }
        const promise = this.waitForEvent("getTfliteCaptureDelay");
        const dataView = new DataView(new ArrayBuffer(2));
        dataView.setUint16(0, newCaptureDelay, true);
        this.sendMessage([{ type: "setTfliteCaptureDelay", data: dataView.buffer }], sendImmediately);
        await promise;
    }
    #threshold;
    get threshold() {
        return this.#threshold;
    }
    #parseThreshold(dataView) {
        _console$w.log("parseThreshold", dataView);
        const threshold = dataView.getFloat32(0, true);
        this.#updateThreshold(threshold);
    }
    #updateThreshold(threshold) {
        _console$w.log({ threshold });
        this.#threshold = threshold;
        this.#dispatchEvent("getTfliteThreshold", { tfliteThreshold: threshold });
    }
    async setThreshold(newThreshold, sendImmediately) {
        _console$w.assertTypeWithError(newThreshold, "number");
        _console$w.assertWithError(newThreshold >= 0, `threshold must be positive (got ${newThreshold})`);
        if (this.#threshold == newThreshold) {
            _console$w.log(`redundant threshold assignment ${newThreshold}`);
            return;
        }
        const promise = this.waitForEvent("getTfliteThreshold");
        const dataView = new DataView(new ArrayBuffer(4));
        dataView.setFloat32(0, newThreshold, true);
        this.sendMessage([{ type: "setTfliteThreshold", data: dataView.buffer }], sendImmediately);
        await promise;
    }
    #inferencingEnabled;
    get inferencingEnabled() {
        return this.#inferencingEnabled;
    }
    #parseInferencingEnabled(dataView) {
        _console$w.log("parseInferencingEnabled", dataView);
        const inferencingEnabled = Boolean(dataView.getUint8(0));
        this.#updateInferencingEnabled(inferencingEnabled);
    }
    #updateInferencingEnabled(inferencingEnabled) {
        _console$w.log({ inferencingEnabled });
        this.#inferencingEnabled = inferencingEnabled;
        this.#dispatchEvent("getTfliteInferencingEnabled", {
            tfliteInferencingEnabled: inferencingEnabled,
        });
    }
    async setInferencingEnabled(newInferencingEnabled, sendImmediately = true) {
        _console$w.assertTypeWithError(newInferencingEnabled, "boolean");
        if (!newInferencingEnabled && !this.isReady) {
            return;
        }
        this.#assertIsReady();
        if (this.#inferencingEnabled == newInferencingEnabled) {
            _console$w.log(`redundant inferencingEnabled assignment ${newInferencingEnabled}`);
            return;
        }
        const promise = this.waitForEvent("getTfliteInferencingEnabled");
        this.sendMessage([
            {
                type: "setTfliteInferencingEnabled",
                data: UInt8ByteBuffer(Number(newInferencingEnabled)),
            },
        ], sendImmediately);
        await promise;
    }
    async toggleInferencingEnabled() {
        return this.setInferencingEnabled(!this.inferencingEnabled);
    }
    async enableInferencing() {
        if (this.inferencingEnabled) {
            return;
        }
        this.setInferencingEnabled(true);
    }
    async disableInferencing() {
        if (!this.inferencingEnabled) {
            return;
        }
        this.setInferencingEnabled(false);
    }
    #parseInference(dataView) {
        _console$w.log("parseInference", dataView);
        const timestamp = parseTimestamp(dataView, 0);
        _console$w.log({ timestamp });
        const values = [];
        for (let index = 0, byteOffset = 2; byteOffset < dataView.byteLength; index++, byteOffset += 4) {
            const value = dataView.getFloat32(byteOffset, true);
            values.push(value);
        }
        _console$w.log("values", values);
        const inference = {
            timestamp,
            values,
        };
        if (this.task == "classification") {
            let maxValue = 0;
            let maxIndex = 0;
            values.forEach((value, index) => {
                if (value > maxValue) {
                    maxValue = value;
                    maxIndex = index;
                }
            });
            _console$w.log({ maxIndex, maxValue });
            inference.maxIndex = maxIndex;
            inference.maxValue = maxValue;
            if (this.#configuration?.classes) {
                const { classes } = this.#configuration;
                inference.maxClass = classes[maxIndex];
                inference.classValues = {};
                values.forEach((value, index) => {
                    const key = classes[index];
                    inference.classValues[key] = value;
                });
            }
        }
        this.#dispatchEvent("tfliteInference", { tfliteInference: inference });
    }
    parseMessage(messageType, dataView) {
        _console$w.log({ messageType });
        switch (messageType) {
            case "getTfliteName":
            case "setTfliteName":
                this.#parseName(dataView);
                break;
            case "getTfliteTask":
            case "setTfliteTask":
                this.#parseTask(dataView);
                break;
            case "getTfliteSampleRate":
            case "setTfliteSampleRate":
                this.#parseSampleRate(dataView);
                break;
            case "getTfliteSensorTypes":
            case "setTfliteSensorTypes":
                this.#parseSensorTypes(dataView);
                break;
            case "tfliteIsReady":
                this.#parseIsReady(dataView);
                break;
            case "getTfliteCaptureDelay":
            case "setTfliteCaptureDelay":
                this.#parseCaptureDelay(dataView);
                break;
            case "getTfliteThreshold":
            case "setTfliteThreshold":
                this.#parseThreshold(dataView);
                break;
            case "getTfliteInferencingEnabled":
            case "setTfliteInferencingEnabled":
                this.#parseInferencingEnabled(dataView);
                break;
            case "tfliteInference":
                this.#parseInference(dataView);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
    #configuration;
    get configuration() {
        return this.#configuration;
    }
    sendConfiguration(configuration, sendImmediately) {
        if (configuration == this.#configuration) {
            _console$w.log("redundant tflite configuration assignment");
            return;
        }
        this.#configuration = configuration;
        _console$w.log("assigned new tflite configuration", this.configuration);
        if (!this.configuration) {
            return;
        }
        const { name, task, captureDelay, sampleRate, threshold, sensorTypes } = this.configuration;
        this.setName(name, false);
        this.setTask(task, false);
        if (captureDelay != undefined) {
            this.setCaptureDelay(captureDelay, false);
        }
        this.setSampleRate(sampleRate, false);
        if (threshold != undefined) {
            this.setThreshold(threshold, false);
        }
        this.setSensorTypes(sensorTypes, sendImmediately);
    }
    clear() {
        this.#configuration = undefined;
        this.#inferencingEnabled = false;
        this.#sensorTypes = [];
        this.#sampleRate = 0;
        this.#isReady = false;
        this.#name = undefined;
        this.#task = undefined;
        this.#sampleRate = undefined;
        this.#sensorTypes.length = 0;
        this.#isReady = undefined;
        this.#captureDelay = undefined;
        this.#threshold = undefined;
        this.#inferencingEnabled = undefined;
        this.#configuration = undefined;
    }
    requestRequiredInformation() {
        _console$w.log("requesting required tflite information");
        const messages = RequiredTfliteMessageTypes.map((messageType) => ({
            type: messageType,
        }));
        this.sendMessage(messages, false);
    }
}

const _console$v = createConsole("DeviceInformationManager", { log: false });
const DeviceInformationTypes = [
    "manufacturerName",
    "modelNumber",
    "hardwareRevision",
    "firmwareRevision",
    "softwareRevision",
    "pnpId",
    "serialNumber",
];
const DeviceInformationEventTypes = [
    ...DeviceInformationTypes,
    "deviceInformation",
];
class DeviceInformationManager {
    eventDispatcher;
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    #information = {};
    get information() {
        return this.#information;
    }
    clear() {
        this.#information = {};
    }
    get #isComplete() {
        return DeviceInformationTypes.filter((key) => key != "serialNumber").every((key) => key in this.#information);
    }
    #update(partialDeviceInformation) {
        _console$v.log({ partialDeviceInformation });
        const deviceInformationNames = Object.keys(partialDeviceInformation);
        deviceInformationNames.forEach((deviceInformationName) => {
            this.#dispatchEvent(deviceInformationName, {
                [deviceInformationName]: partialDeviceInformation[deviceInformationName],
            });
        });
        Object.assign(this.#information, partialDeviceInformation);
        _console$v.log({ deviceInformation: this.#information });
        if (this.#isComplete) {
            _console$v.log("completed deviceInformation");
            this.#dispatchEvent("deviceInformation", {
                deviceInformation: this.information,
            });
        }
    }
    parseMessage(messageType, dataView) {
        _console$v.log({ messageType });
        switch (messageType) {
            case "manufacturerName":
                const manufacturerName = textDecoder.decode(dataView.buffer);
                _console$v.log({ manufacturerName });
                this.#update({ manufacturerName });
                break;
            case "modelNumber":
                const modelNumber = textDecoder.decode(dataView.buffer);
                _console$v.log({ modelNumber });
                this.#update({ modelNumber });
                break;
            case "softwareRevision":
                const softwareRevision = textDecoder.decode(dataView.buffer);
                _console$v.log({ softwareRevision });
                this.#update({ softwareRevision });
                break;
            case "hardwareRevision":
                const hardwareRevision = textDecoder.decode(dataView.buffer);
                _console$v.log({ hardwareRevision });
                this.#update({ hardwareRevision });
                break;
            case "firmwareRevision":
                const firmwareRevision = textDecoder.decode(dataView.buffer);
                _console$v.log({ firmwareRevision });
                this.#update({ firmwareRevision });
                break;
            case "pnpId":
                const pnpId = {
                    source: dataView.getUint8(0) === 1 ? "Bluetooth" : "USB",
                    productId: dataView.getUint16(3, true),
                    productVersion: dataView.getUint16(5, true),
                    vendorId: 0,
                };
                if (pnpId.source == "Bluetooth") {
                    pnpId.vendorId = dataView.getUint16(1, true);
                }
                _console$v.log({ pnpId });
                this.#update({ pnpId });
                break;
            case "serialNumber":
                const serialNumber = textDecoder.decode(dataView.buffer);
                _console$v.log({ serialNumber });
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
}

const _console$u = createConsole("InformationManager", { log: false });
const DeviceTypes = [
    "leftInsole",
    "rightInsole",
    "leftGlove",
    "rightGlove",
    "glasses",
    "generic",
];
const Sides = ["left", "right"];
const MinNameLength = 2;
const MaxNameLength = 30;
const InformationMessageTypes = [
    "isCharging",
    "getBatteryCurrent",
    "getMtu",
    "getId",
    "getName",
    "setName",
    "getType",
    "setType",
    "getCurrentTime",
    "setCurrentTime",
];
const InformationEventTypes = InformationMessageTypes;
class InformationManager {
    constructor() {
        autoBind(this);
    }
    sendMessage;
    eventDispatcher;
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    #isCharging = false;
    get isCharging() {
        return this.#isCharging;
    }
    #updateIsCharging(updatedIsCharging) {
        _console$u.assertTypeWithError(updatedIsCharging, "boolean");
        this.#isCharging = updatedIsCharging;
        _console$u.log({ isCharging: this.#isCharging });
        this.#dispatchEvent("isCharging", { isCharging: this.#isCharging });
    }
    #batteryCurrent;
    get batteryCurrent() {
        return this.#batteryCurrent;
    }
    async getBatteryCurrent() {
        _console$u.log("getting battery current...");
        const promise = this.waitForEvent("getBatteryCurrent");
        this.sendMessage([{ type: "getBatteryCurrent" }]);
        await promise;
    }
    #updateBatteryCurrent(updatedBatteryCurrent) {
        _console$u.assertTypeWithError(updatedBatteryCurrent, "number");
        this.#batteryCurrent = updatedBatteryCurrent;
        _console$u.log({ batteryCurrent: this.#batteryCurrent });
        this.#dispatchEvent("getBatteryCurrent", {
            batteryCurrent: this.#batteryCurrent,
        });
    }
    #id;
    get id() {
        return this.#id;
    }
    #updateId(updatedId) {
        _console$u.assertTypeWithError(updatedId, "string");
        this.#id = updatedId;
        _console$u.log({ id: this.#id });
        this.#dispatchEvent("getId", { id: this.#id });
    }
    #name = "";
    get name() {
        return this.#name;
    }
    updateName(updatedName) {
        _console$u.assertTypeWithError(updatedName, "string");
        this.#name = updatedName;
        _console$u.log({ updatedName: this.#name });
        this.#dispatchEvent("getName", { name: this.#name });
    }
    async setName(newName) {
        _console$u.assertTypeWithError(newName, "string");
        _console$u.assertRangeWithError("newName", newName.length, MinNameLength, MaxNameLength);
        const setNameData = textEncoder.encode(newName);
        _console$u.log({ setNameData });
        const promise = this.waitForEvent("getName");
        this.sendMessage([{ type: "setName", data: setNameData.buffer }]);
        await promise;
    }
    #type;
    get type() {
        return this.#type;
    }
    get typeEnum() {
        return DeviceTypes.indexOf(this.type);
    }
    #assertValidDeviceType(type) {
        _console$u.assertEnumWithError(type, DeviceTypes);
    }
    #assertValidDeviceTypeEnum(typeEnum) {
        _console$u.assertTypeWithError(typeEnum, "number");
        _console$u.assertWithError(typeEnum in DeviceTypes, `invalid typeEnum ${typeEnum}`);
    }
    updateType(updatedType) {
        this.#assertValidDeviceType(updatedType);
        this.#type = updatedType;
        _console$u.log({ updatedType: this.#type });
        this.#dispatchEvent("getType", { type: this.#type });
    }
    async #setTypeEnum(newTypeEnum) {
        this.#assertValidDeviceTypeEnum(newTypeEnum);
        const setTypeData = UInt8ByteBuffer(newTypeEnum);
        _console$u.log({ setTypeData });
        const promise = this.waitForEvent("getType");
        this.sendMessage([{ type: "setType", data: setTypeData }]);
        await promise;
    }
    async setType(newType) {
        this.#assertValidDeviceType(newType);
        const newTypeEnum = DeviceTypes.indexOf(newType);
        this.#setTypeEnum(newTypeEnum);
    }
    get isInsole() {
        switch (this.type) {
            case "leftInsole":
            case "rightInsole":
                return true;
            default:
                return false;
        }
    }
    get isGlove() {
        switch (this.type) {
            case "leftGlove":
            case "rightGlove":
                return true;
            default:
                return false;
        }
    }
    get side() {
        switch (this.type) {
            case "leftInsole":
            case "leftGlove":
                return "left";
            case "rightInsole":
            case "rightGlove":
                return "right";
            default:
                return "left";
        }
    }
    #mtu = 0;
    get mtu() {
        return this.#mtu;
    }
    #updateMtu(newMtu) {
        _console$u.assertTypeWithError(newMtu, "number");
        if (this.#mtu == newMtu) {
            _console$u.log("redundant mtu assignment", newMtu);
            return;
        }
        this.#mtu = newMtu;
        this.#dispatchEvent("getMtu", { mtu: this.#mtu });
    }
    #isCurrentTimeSet = false;
    get isCurrentTimeSet() {
        return this.#isCurrentTimeSet;
    }
    #onCurrentTime(currentTime) {
        _console$u.log({ currentTime });
        this.#isCurrentTimeSet =
            currentTime != 0 || Math.abs(Date.now() - currentTime) < Uint16Max;
        if (!this.#isCurrentTimeSet) {
            this.#setCurrentTime(false);
        }
    }
    async #setCurrentTime(sendImmediately) {
        _console$u.log("setting current time...");
        const dataView = new DataView(new ArrayBuffer(8));
        dataView.setBigUint64(0, BigInt(Date.now()), true);
        const promise = this.waitForEvent("getCurrentTime");
        this.sendMessage([{ type: "setCurrentTime", data: dataView.buffer }], sendImmediately);
        await promise;
    }
    parseMessage(messageType, dataView) {
        _console$u.log({ messageType });
        switch (messageType) {
            case "isCharging":
                const isCharging = Boolean(dataView.getUint8(0));
                _console$u.log({ isCharging });
                this.#updateIsCharging(isCharging);
                break;
            case "getBatteryCurrent":
                const batteryCurrent = dataView.getFloat32(0, true);
                _console$u.log({ batteryCurrent });
                this.#updateBatteryCurrent(batteryCurrent);
                break;
            case "getId":
                const id = textDecoder.decode(dataView.buffer);
                _console$u.log({ id });
                this.#updateId(id);
                break;
            case "getName":
            case "setName":
                const name = textDecoder.decode(dataView.buffer);
                _console$u.log({ name });
                this.updateName(name);
                break;
            case "getType":
            case "setType":
                const typeEnum = dataView.getUint8(0);
                const type = DeviceTypes[typeEnum];
                _console$u.log({ typeEnum, type });
                this.updateType(type);
                break;
            case "getMtu":
                let mtu = dataView.getUint16(0, true);
                if (this.connectionType != "webSocket" &&
                    this.connectionType != "udp") {
                    mtu = Math.min(mtu, 512);
                }
                _console$u.log({ mtu });
                this.#updateMtu(mtu);
                break;
            case "getCurrentTime":
            case "setCurrentTime":
                const currentTime = Number(dataView.getBigUint64(0, true));
                this.#onCurrentTime(currentTime);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
    clear() {
        this.#isCurrentTimeSet = false;
        this.#mtu = 0;
    }
    connectionType;
}

const VibrationWaveformEffects = [
    "none",
    "strongClick100",
    "strongClick60",
    "strongClick30",
    "sharpClick100",
    "sharpClick60",
    "sharpClick30",
    "softBump100",
    "softBump60",
    "softBump30",
    "doubleClick100",
    "doubleClick60",
    "tripleClick100",
    "softFuzz60",
    "strongBuzz100",
    "alert750ms",
    "alert1000ms",
    "strongClick1_100",
    "strongClick2_80",
    "strongClick3_60",
    "strongClick4_30",
    "mediumClick100",
    "mediumClick80",
    "mediumClick60",
    "sharpTick100",
    "sharpTick80",
    "sharpTick60",
    "shortDoubleClickStrong100",
    "shortDoubleClickStrong80",
    "shortDoubleClickStrong60",
    "shortDoubleClickStrong30",
    "shortDoubleClickMedium100",
    "shortDoubleClickMedium80",
    "shortDoubleClickMedium60",
    "shortDoubleSharpTick100",
    "shortDoubleSharpTick80",
    "shortDoubleSharpTick60",
    "longDoubleSharpClickStrong100",
    "longDoubleSharpClickStrong80",
    "longDoubleSharpClickStrong60",
    "longDoubleSharpClickStrong30",
    "longDoubleSharpClickMedium100",
    "longDoubleSharpClickMedium80",
    "longDoubleSharpClickMedium60",
    "longDoubleSharpTick100",
    "longDoubleSharpTick80",
    "longDoubleSharpTick60",
    "buzz100",
    "buzz80",
    "buzz60",
    "buzz40",
    "buzz20",
    "pulsingStrong100",
    "pulsingStrong60",
    "pulsingMedium100",
    "pulsingMedium60",
    "pulsingSharp100",
    "pulsingSharp60",
    "transitionClick100",
    "transitionClick80",
    "transitionClick60",
    "transitionClick40",
    "transitionClick20",
    "transitionClick10",
    "transitionHum100",
    "transitionHum80",
    "transitionHum60",
    "transitionHum40",
    "transitionHum20",
    "transitionHum10",
    "transitionRampDownLongSmooth2_100",
    "transitionRampDownLongSmooth1_100",
    "transitionRampDownMediumSmooth1_100",
    "transitionRampDownMediumSmooth2_100",
    "transitionRampDownShortSmooth1_100",
    "transitionRampDownShortSmooth2_100",
    "transitionRampDownLongSharp1_100",
    "transitionRampDownLongSharp2_100",
    "transitionRampDownMediumSharp1_100",
    "transitionRampDownMediumSharp2_100",
    "transitionRampDownShortSharp1_100",
    "transitionRampDownShortSharp2_100",
    "transitionRampUpLongSmooth1_100",
    "transitionRampUpLongSmooth2_100",
    "transitionRampUpMediumSmooth1_100",
    "transitionRampUpMediumSmooth2_100",
    "transitionRampUpShortSmooth1_100",
    "transitionRampUpShortSmooth2_100",
    "transitionRampUpLongSharp1_100",
    "transitionRampUpLongSharp2_100",
    "transitionRampUpMediumSharp1_100",
    "transitionRampUpMediumSharp2_100",
    "transitionRampUpShortSharp1_100",
    "transitionRampUpShortSharp2_100",
    "transitionRampDownLongSmooth1_50",
    "transitionRampDownLongSmooth2_50",
    "transitionRampDownMediumSmooth1_50",
    "transitionRampDownMediumSmooth2_50",
    "transitionRampDownShortSmooth1_50",
    "transitionRampDownShortSmooth2_50",
    "transitionRampDownLongSharp1_50",
    "transitionRampDownLongSharp2_50",
    "transitionRampDownMediumSharp1_50",
    "transitionRampDownMediumSharp2_50",
    "transitionRampDownShortSharp1_50",
    "transitionRampDownShortSharp2_50",
    "transitionRampUpLongSmooth1_50",
    "transitionRampUpLongSmooth2_50",
    "transitionRampUpMediumSmooth1_50",
    "transitionRampUpMediumSmooth2_50",
    "transitionRampUpShortSmooth1_50",
    "transitionRampUpShortSmooth2_50",
    "transitionRampUpLongSharp1_50",
    "transitionRampUpLongSharp2_50",
    "transitionRampUpMediumSharp1_50",
    "transitionRampUpMediumSharp2_50",
    "transitionRampUpShortSharp1_50",
    "transitionRampUpShortSharp2_50",
    "longBuzz100",
    "smoothHum50",
    "smoothHum40",
    "smoothHum30",
    "smoothHum20",
    "smoothHum10",
];

const _console$t = createConsole("VibrationManager", { log: false });
const VibrationLocations = ["front", "rear"];
const VibrationTypes = ["waveformEffect", "waveform"];
const VibrationMessageTypes = [
    "getVibrationLocations",
    "triggerVibration",
];
const VibrationEventTypes = VibrationMessageTypes;
const MaxNumberOfVibrationWaveformEffectSegments = 8;
const MaxVibrationWaveformSegmentDuration = 2550;
const MaxVibrationWaveformEffectSegmentDelay = 1270;
const MaxVibrationWaveformEffectSegmentLoopCount = 3;
const MaxNumberOfVibrationWaveformSegments = 20;
const MaxVibrationWaveformEffectSequenceLoopCount = 6;
class VibrationManager {
    constructor() {
        autoBind(this);
    }
    sendMessage;
    eventDispatcher;
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    #verifyLocation(location) {
        _console$t.assertTypeWithError(location, "string");
        _console$t.assertWithError(VibrationLocations.includes(location), `invalid location "${location}"`);
    }
    #verifyLocations(locations) {
        this.#assertNonEmptyArray(locations);
        locations.forEach((location) => {
            this.#verifyLocation(location);
        });
    }
    #createLocationsBitmask(locations) {
        this.#verifyLocations(locations);
        let locationsBitmask = 0;
        locations.forEach((location) => {
            const locationIndex = VibrationLocations.indexOf(location);
            locationsBitmask |= 1 << locationIndex;
        });
        _console$t.log({ locationsBitmask });
        _console$t.assertWithError(locationsBitmask > 0, `locationsBitmask must not be zero`);
        return locationsBitmask;
    }
    #assertNonEmptyArray(array) {
        _console$t.assertWithError(Array.isArray(array), "passed non-array");
        _console$t.assertWithError(array.length > 0, "passed empty array");
    }
    #verifyWaveformEffect(waveformEffect) {
        _console$t.assertWithError(VibrationWaveformEffects.includes(waveformEffect), `invalid waveformEffect "${waveformEffect}"`);
    }
    #verifyWaveformEffectSegment(waveformEffectSegment) {
        if (waveformEffectSegment.effect != undefined) {
            const waveformEffect = waveformEffectSegment.effect;
            this.#verifyWaveformEffect(waveformEffect);
        }
        else if (waveformEffectSegment.delay != undefined) {
            const { delay } = waveformEffectSegment;
            _console$t.assertWithError(delay >= 0, `delay must be 0ms or greater (got ${delay})`);
            _console$t.assertWithError(delay <= MaxVibrationWaveformEffectSegmentDelay, `delay must be ${MaxVibrationWaveformEffectSegmentDelay}ms or less (got ${delay})`);
        }
        else {
            throw Error("no effect or delay found in waveformEffectSegment");
        }
        if (waveformEffectSegment.loopCount != undefined) {
            const { loopCount } = waveformEffectSegment;
            this.#verifyWaveformEffectSegmentLoopCount(loopCount);
        }
    }
    #verifyWaveformEffectSegmentLoopCount(waveformEffectSegmentLoopCount) {
        _console$t.assertTypeWithError(waveformEffectSegmentLoopCount, "number");
        _console$t.assertWithError(waveformEffectSegmentLoopCount >= 0, `waveformEffectSegmentLoopCount must be 0 or greater (got ${waveformEffectSegmentLoopCount})`);
        _console$t.assertWithError(waveformEffectSegmentLoopCount <=
            MaxVibrationWaveformEffectSegmentLoopCount, `waveformEffectSegmentLoopCount must be ${MaxVibrationWaveformEffectSegmentLoopCount} or fewer (got ${waveformEffectSegmentLoopCount})`);
    }
    #verifyWaveformEffectSegments(waveformEffectSegments) {
        this.#assertNonEmptyArray(waveformEffectSegments);
        _console$t.assertWithError(waveformEffectSegments.length <=
            MaxNumberOfVibrationWaveformEffectSegments, `must have ${MaxNumberOfVibrationWaveformEffectSegments} waveformEffectSegments or fewer (got ${waveformEffectSegments.length})`);
        waveformEffectSegments.forEach((waveformEffectSegment) => {
            this.#verifyWaveformEffectSegment(waveformEffectSegment);
        });
    }
    #verifyWaveformEffectSequenceLoopCount(waveformEffectSequenceLoopCount) {
        _console$t.assertTypeWithError(waveformEffectSequenceLoopCount, "number");
        _console$t.assertWithError(waveformEffectSequenceLoopCount >= 0, `waveformEffectSequenceLoopCount must be 0 or greater (got ${waveformEffectSequenceLoopCount})`);
        _console$t.assertWithError(waveformEffectSequenceLoopCount <=
            MaxVibrationWaveformEffectSequenceLoopCount, `waveformEffectSequenceLoopCount must be ${MaxVibrationWaveformEffectSequenceLoopCount} or fewer (got ${waveformEffectSequenceLoopCount})`);
    }
    #verifyWaveformSegment(waveformSegment) {
        _console$t.assertTypeWithError(waveformSegment.amplitude, "number");
        _console$t.assertWithError(waveformSegment.amplitude >= 0, `amplitude must be 0 or greater (got ${waveformSegment.amplitude})`);
        _console$t.assertWithError(waveformSegment.amplitude <= 1, `amplitude must be 1 or less (got ${waveformSegment.amplitude})`);
        _console$t.assertTypeWithError(waveformSegment.duration, "number");
        _console$t.assertWithError(waveformSegment.duration > 0, `duration must be greater than 0ms (got ${waveformSegment.duration}ms)`);
        _console$t.assertWithError(waveformSegment.duration <= MaxVibrationWaveformSegmentDuration, `duration must be ${MaxVibrationWaveformSegmentDuration}ms or less (got ${waveformSegment.duration}ms)`);
    }
    #verifyWaveformSegments(waveformSegments) {
        this.#assertNonEmptyArray(waveformSegments);
        _console$t.assertWithError(waveformSegments.length <= MaxNumberOfVibrationWaveformSegments, `must have ${MaxNumberOfVibrationWaveformSegments} waveformSegments or fewer (got ${waveformSegments.length})`);
        waveformSegments.forEach((waveformSegment) => {
            this.#verifyWaveformSegment(waveformSegment);
        });
    }
    #createWaveformEffectsData(locations, waveformEffectSegments, waveformEffectSequenceLoopCount = 0) {
        this.#verifyWaveformEffectSegments(waveformEffectSegments);
        this.#verifyWaveformEffectSequenceLoopCount(waveformEffectSequenceLoopCount);
        let dataArray = [];
        let byteOffset = 0;
        const hasAtLeast1WaveformEffectWithANonzeroLoopCount = waveformEffectSegments.some((waveformEffectSegment) => {
            const { loopCount } = waveformEffectSegment;
            return loopCount != undefined && loopCount > 0;
        });
        const includeAllWaveformEffectSegments = hasAtLeast1WaveformEffectWithANonzeroLoopCount ||
            waveformEffectSequenceLoopCount != 0;
        for (let index = 0; index < waveformEffectSegments.length ||
            (includeAllWaveformEffectSegments &&
                index < MaxNumberOfVibrationWaveformEffectSegments); index++) {
            const waveformEffectSegment = waveformEffectSegments[index] || {
                effect: "none",
            };
            if (waveformEffectSegment.effect != undefined) {
                const waveformEffect = waveformEffectSegment.effect;
                dataArray[byteOffset++] =
                    VibrationWaveformEffects.indexOf(waveformEffect);
            }
            else if (waveformEffectSegment.delay != undefined) {
                const { delay } = waveformEffectSegment;
                dataArray[byteOffset++] = (1 << 7) | Math.floor(delay / 10);
            }
            else {
                throw Error("invalid waveformEffectSegment");
            }
        }
        const includeAllWaveformEffectSegmentLoopCounts = waveformEffectSequenceLoopCount != 0;
        for (let index = 0; index < waveformEffectSegments.length ||
            (includeAllWaveformEffectSegmentLoopCounts &&
                index < MaxNumberOfVibrationWaveformEffectSegments); index++) {
            const waveformEffectSegmentLoopCount = waveformEffectSegments[index]?.loopCount || 0;
            if (index == 0 || index == 4) {
                dataArray[byteOffset] = 0;
            }
            const bitOffset = 2 * (index % 4);
            dataArray[byteOffset] |= waveformEffectSegmentLoopCount << bitOffset;
            if (index == 3 || index == 7) {
                byteOffset++;
            }
        }
        if (waveformEffectSequenceLoopCount != 0) {
            dataArray[byteOffset++] = waveformEffectSequenceLoopCount;
        }
        const dataView = new DataView(Uint8Array.from(dataArray).buffer);
        _console$t.log({ dataArray, dataView });
        return this.#createData(locations, "waveformEffect", dataView);
    }
    #createWaveformData(locations, waveformSegments) {
        this.#verifyWaveformSegments(waveformSegments);
        const dataView = new DataView(new ArrayBuffer(waveformSegments.length * 2));
        waveformSegments.forEach((waveformSegment, index) => {
            dataView.setUint8(index * 2, Math.floor(waveformSegment.amplitude * 127));
            dataView.setUint8(index * 2 + 1, Math.floor(waveformSegment.duration / 10));
        });
        _console$t.log({ dataView });
        return this.#createData(locations, "waveform", dataView);
    }
    #verifyVibrationType(vibrationType) {
        _console$t.assertTypeWithError(vibrationType, "string");
        _console$t.assertWithError(VibrationTypes.includes(vibrationType), `invalid vibrationType "${vibrationType}"`);
    }
    #createData(locations, vibrationType, dataView) {
        _console$t.assertWithError(dataView?.byteLength > 0, "no data received");
        const locationsBitmask = this.#createLocationsBitmask(locations);
        this.#verifyVibrationType(vibrationType);
        const vibrationTypeIndex = VibrationTypes.indexOf(vibrationType);
        _console$t.log({ locationsBitmask, vibrationTypeIndex, dataView });
        const data = concatenateArrayBuffers(locationsBitmask, vibrationTypeIndex, dataView.byteLength, dataView);
        _console$t.log({ data });
        return data;
    }
    async triggerVibration(vibrationConfigurations, sendImmediately = true) {
        let triggerVibrationData;
        vibrationConfigurations.forEach((vibrationConfiguration) => {
            const { type } = vibrationConfiguration;
            let { locations } = vibrationConfiguration;
            locations = locations || this.vibrationLocations.slice();
            locations = locations.filter((location) => this.vibrationLocations.includes(location));
            let arrayBuffer;
            switch (type) {
                case "waveformEffect":
                    {
                        const { segments, loopCount } = vibrationConfiguration;
                        arrayBuffer = this.#createWaveformEffectsData(locations, segments, loopCount);
                    }
                    break;
                case "waveform":
                    {
                        const { segments } = vibrationConfiguration;
                        arrayBuffer = this.#createWaveformData(locations, segments);
                    }
                    break;
                default:
                    throw Error(`invalid vibration type "${type}"`);
            }
            _console$t.log({ type, arrayBuffer });
            triggerVibrationData = concatenateArrayBuffers(triggerVibrationData, arrayBuffer);
        });
        await this.sendMessage([{ type: "triggerVibration", data: triggerVibrationData }], sendImmediately);
    }
    #vibrationLocations = [];
    get vibrationLocations() {
        return this.#vibrationLocations;
    }
    #onVibrationLocations(vibrationLocations) {
        this.#vibrationLocations = vibrationLocations;
        _console$t.log("vibrationLocations", vibrationLocations);
        this.#dispatchEvent("getVibrationLocations", {
            vibrationLocations: this.#vibrationLocations,
        });
    }
    parseMessage(messageType, dataView) {
        _console$t.log({ messageType });
        switch (messageType) {
            case "getVibrationLocations":
                const vibrationLocations = Array.from(new Uint8Array(dataView.buffer))
                    .map((index) => VibrationLocations[index])
                    .filter(Boolean);
                this.#onVibrationLocations(vibrationLocations);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
}

const _console$s = createConsole("WifiManager", { log: false });
const MinWifiSSIDLength = 1;
const MaxWifiSSIDLength = 32;
const MinWifiPasswordLength = 8;
const MaxWifiPasswordLength = 64;
const WifiMessageTypes = [
    "isWifiAvailable",
    "getWifiSSID",
    "setWifiSSID",
    "getWifiPassword",
    "setWifiPassword",
    "getWifiConnectionEnabled",
    "setWifiConnectionEnabled",
    "isWifiConnected",
    "ipAddress",
    "isWifiSecure",
];
const RequiredWifiMessageTypes = [
    "getWifiSSID",
    "getWifiPassword",
    "getWifiConnectionEnabled",
    "isWifiConnected",
    "ipAddress",
    "isWifiSecure",
];
const WifiEventTypes = WifiMessageTypes;
class WifiManager {
    constructor() {
        autoBind(this);
    }
    sendMessage;
    eventDispatcher;
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    requestRequiredInformation() {
        _console$s.log("requesting required wifi information");
        const messages = RequiredWifiMessageTypes.map((messageType) => ({
            type: messageType,
        }));
        this.sendMessage(messages, false);
    }
    #isWifiAvailable = false;
    get isWifiAvailable() {
        return this.#isWifiAvailable;
    }
    #updateIsWifiAvailable(updatedIsWifiAvailable) {
        _console$s.assertTypeWithError(updatedIsWifiAvailable, "boolean");
        this.#isWifiAvailable = updatedIsWifiAvailable;
        _console$s.log({ isWifiAvailable: this.#isWifiAvailable });
        this.#dispatchEvent("isWifiAvailable", {
            isWifiAvailable: this.#isWifiAvailable,
        });
    }
    #assertWifiIsAvailable() {
        _console$s.assertWithError(this.#isWifiAvailable, "wifi is not available");
    }
    #wifiSSID = "";
    get wifiSSID() {
        return this.#wifiSSID;
    }
    #updateWifiSSID(updatedWifiSSID) {
        _console$s.assertTypeWithError(updatedWifiSSID, "string");
        this.#wifiSSID = updatedWifiSSID;
        _console$s.log({ wifiSSID: this.#wifiSSID });
        this.#dispatchEvent("getWifiSSID", { wifiSSID: this.#wifiSSID });
    }
    async setWifiSSID(newWifiSSID) {
        this.#assertWifiIsAvailable();
        if (this.#wifiConnectionEnabled) {
            _console$s.error("cannot change ssid while wifi connection is enabled");
            return;
        }
        _console$s.assertTypeWithError(newWifiSSID, "string");
        _console$s.assertRangeWithError("wifiSSID", newWifiSSID.length, MinWifiSSIDLength, MaxWifiSSIDLength);
        const setWifiSSIDData = textEncoder.encode(newWifiSSID);
        _console$s.log({ setWifiSSIDData });
        const promise = this.waitForEvent("getWifiSSID");
        this.sendMessage([{ type: "setWifiSSID", data: setWifiSSIDData.buffer }]);
        await promise;
    }
    #wifiPassword = "";
    get wifiPassword() {
        return this.#wifiPassword;
    }
    #updateWifiPassword(updatedWifiPassword) {
        _console$s.assertTypeWithError(updatedWifiPassword, "string");
        this.#wifiPassword = updatedWifiPassword;
        _console$s.log({ wifiPassword: this.#wifiPassword });
        this.#dispatchEvent("getWifiPassword", {
            wifiPassword: this.#wifiPassword,
        });
    }
    async setWifiPassword(newWifiPassword) {
        this.#assertWifiIsAvailable();
        if (this.#wifiConnectionEnabled) {
            _console$s.error("cannot change password while wifi connection is enabled");
            return;
        }
        _console$s.assertTypeWithError(newWifiPassword, "string");
        if (newWifiPassword.length > 0) {
            _console$s.assertRangeWithError("wifiPassword", newWifiPassword.length, MinWifiPasswordLength, MaxWifiPasswordLength);
        }
        const setWifiPasswordData = textEncoder.encode(newWifiPassword);
        _console$s.log({ setWifiPasswordData });
        const promise = this.waitForEvent("getWifiPassword");
        this.sendMessage([
            { type: "setWifiPassword", data: setWifiPasswordData.buffer },
        ]);
        await promise;
    }
    #wifiConnectionEnabled;
    get wifiConnectionEnabled() {
        return this.#wifiConnectionEnabled;
    }
    #updateWifiConnectionEnabled(wifiConnectionEnabled) {
        _console$s.log({ wifiConnectionEnabled });
        this.#wifiConnectionEnabled = wifiConnectionEnabled;
        this.#dispatchEvent("getWifiConnectionEnabled", {
            wifiConnectionEnabled: wifiConnectionEnabled,
        });
    }
    async setWifiConnectionEnabled(newWifiConnectionEnabled, sendImmediately = true) {
        this.#assertWifiIsAvailable();
        _console$s.assertTypeWithError(newWifiConnectionEnabled, "boolean");
        if (this.#wifiConnectionEnabled == newWifiConnectionEnabled) {
            _console$s.log(`redundant wifiConnectionEnabled assignment ${newWifiConnectionEnabled}`);
            return;
        }
        const promise = this.waitForEvent("getWifiConnectionEnabled");
        this.sendMessage([
            {
                type: "setWifiConnectionEnabled",
                data: UInt8ByteBuffer(Number(newWifiConnectionEnabled)),
            },
        ], sendImmediately);
        await promise;
    }
    async toggleWifiConnection() {
        return this.setWifiConnectionEnabled(!this.wifiConnectionEnabled);
    }
    async enableWifiConnection() {
        return this.setWifiConnectionEnabled(true);
    }
    async disableWifiConnection() {
        return this.setWifiConnectionEnabled(false);
    }
    #isWifiConnected = false;
    get isWifiConnected() {
        return this.#isWifiConnected;
    }
    #updateIsWifiConnected(updatedIsWifiConnected) {
        _console$s.assertTypeWithError(updatedIsWifiConnected, "boolean");
        this.#isWifiConnected = updatedIsWifiConnected;
        _console$s.log({ isWifiConnected: this.#isWifiConnected });
        this.#dispatchEvent("isWifiConnected", {
            isWifiConnected: this.#isWifiConnected,
        });
    }
    #ipAddress;
    get ipAddress() {
        return this.#ipAddress;
    }
    #updateIpAddress(updatedIpAddress) {
        this.#ipAddress = updatedIpAddress;
        _console$s.log({ ipAddress: this.#ipAddress });
        this.#dispatchEvent("ipAddress", {
            ipAddress: this.#ipAddress,
        });
    }
    #isWifiSecure = false;
    get isWifiSecure() {
        return this.#isWifiSecure;
    }
    #updateIsWifiSecure(updatedIsWifiSecure) {
        _console$s.assertTypeWithError(updatedIsWifiSecure, "boolean");
        this.#isWifiSecure = updatedIsWifiSecure;
        _console$s.log({ isWifiSecure: this.#isWifiSecure });
        this.#dispatchEvent("isWifiSecure", {
            isWifiSecure: this.#isWifiSecure,
        });
    }
    parseMessage(messageType, dataView) {
        _console$s.log({ messageType });
        switch (messageType) {
            case "isWifiAvailable":
                const isWifiAvailable = Boolean(dataView.getUint8(0));
                _console$s.log({ isWifiAvailable });
                this.#updateIsWifiAvailable(isWifiAvailable);
                break;
            case "getWifiSSID":
            case "setWifiSSID":
                const ssid = textDecoder.decode(dataView.buffer);
                _console$s.log({ ssid });
                this.#updateWifiSSID(ssid);
                break;
            case "getWifiPassword":
            case "setWifiPassword":
                const password = textDecoder.decode(dataView.buffer);
                _console$s.log({ password });
                this.#updateWifiPassword(password);
                break;
            case "getWifiConnectionEnabled":
            case "setWifiConnectionEnabled":
                const enableWifiConnection = Boolean(dataView.getUint8(0));
                _console$s.log({ enableWifiConnection });
                this.#updateWifiConnectionEnabled(enableWifiConnection);
                break;
            case "isWifiConnected":
                const isWifiConnected = Boolean(dataView.getUint8(0));
                _console$s.log({ isWifiConnected });
                this.#updateIsWifiConnected(isWifiConnected);
                break;
            case "ipAddress":
                let ipAddress = undefined;
                if (dataView.byteLength == 4) {
                    ipAddress = new Uint8Array(dataView.buffer.slice(0, 4)).join(".");
                }
                _console$s.log({ ipAddress });
                this.#updateIpAddress(ipAddress);
                break;
            case "isWifiSecure":
                const isWifiSecure = Boolean(dataView.getUint8(0));
                _console$s.log({ isWifiSecure });
                this.#updateIsWifiSecure(isWifiSecure);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
    clear() {
        this.#wifiSSID = "";
        this.#wifiPassword = "";
        this.#ipAddress = "";
        this.#isWifiConnected = false;
        this.#isWifiAvailable = false;
    }
}

const _console$r = createConsole("ColorUtils", { log: false });
function hexToRGB(hex) {
    hex = hex.replace(/^#/, "");
    if (hex.length == 3) {
        hex = hex
            .split("")
            .map((char) => char + char)
            .join("");
    }
    _console$r.assertWithError(hex.length == 6, `hex length must be 6 (got ${hex.length})`);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return { r, g, b };
}
const blackColor = { r: 0, g: 0, b: 0 };
function colorNameToRGB(colorName) {
    const temp = document.createElement("div");
    temp.style.color = colorName;
    document.body.appendChild(temp);
    const computedColor = getComputedStyle(temp).color;
    document.body.removeChild(temp);
    const match = computedColor.match(/^rgba?\((\d+), (\d+), (\d+)/);
    if (!match)
        return blackColor;
    return {
        r: parseInt(match[1], 10),
        g: parseInt(match[2], 10),
        b: parseInt(match[3], 10),
    };
}
function stringToRGB(string) {
    if (string.startsWith("#")) {
        return hexToRGB(string);
    }
    else {
        return colorNameToRGB(string);
    }
}
function rgbToHex({ r, g, b }) {
    const toHex = (value) => value.toString(16).padStart(2, "0").toLowerCase();
    _console$r.assertWithError([r, g, b].every((v) => v >= 0 && v <= 255), `RGB values must be between 0 and 255 (got r=${r}, g=${g}, b=${b})`);
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
function colorDistanceSq(a, b) {
    return (a.r - b.r) ** 2 + (a.g - b.g) ** 2 + (a.b - b.b) ** 2;
}
const defaultKMeansOptions = {
    useInputColors: true,
    maxIterations: 20,
};
function kMeansColors(colors, k, options) {
    _console$r.assertTypeWithError(k, "number");
    _console$r.assertWithError(k > 0, `invalid k ${k}`);
    options = { ...defaultKMeansOptions, ...options };
    const maxIter = options.maxIterations;
    const useInputColors = options.useInputColors;
    const colorMap = new Map();
    for (const c of colors) {
        if (!colorMap.has(c)) {
            colorMap.set(c, stringToRGB(c));
        }
    }
    const uniqueColors = Array.from(colorMap.values());
    const uniqueKeys = Array.from(colorMap.keys());
    if (uniqueColors.length <= k) {
        const mapping = {};
        uniqueKeys.forEach((key, idx) => (mapping[key] = idx));
        return { palette: uniqueKeys, mapping };
    }
    let centroids = uniqueColors.slice(0, k);
    for (let iter = 0; iter < maxIter; iter++) {
        const clusters = Array.from({ length: k }, () => []);
        uniqueColors.forEach((p, idx) => {
            let best = 0;
            let bestDist = Infinity;
            centroids.forEach((c, ci) => {
                const d = colorDistanceSq(p, c);
                if (d < bestDist) {
                    bestDist = d;
                    best = ci;
                }
            });
            clusters[best].push(idx);
        });
        centroids = clusters.map((cluster) => {
            if (cluster.length === 0)
                return { ...blackColor };
            if (useInputColors) {
                let bestIdx = cluster[0];
                let bestDist = Infinity;
                cluster.forEach((idx) => {
                    const d = colorDistanceSq(uniqueColors[idx], centroids[0]);
                    if (d < bestDist) {
                        bestDist = d;
                        bestIdx = idx;
                    }
                });
                return uniqueColors[bestIdx];
            }
            else {
                const sum = cluster.reduce((acc, idx) => {
                    const p = uniqueColors[idx];
                    return {
                        r: acc.r + p.r,
                        g: acc.g + p.g,
                        b: acc.b + p.b,
                    };
                }, { ...blackColor });
                return {
                    r: sum.r / cluster.length,
                    g: sum.g / cluster.length,
                    b: sum.b / cluster.length,
                };
            }
        });
    }
    const palette = centroids.map((c) => rgbToHex(c));
    const mapping = {};
    for (const [orig, DisplayColorRGB] of colorMap.entries()) {
        let bestIdx = 0;
        let bestDist = Infinity;
        centroids.forEach((c, ci) => {
            const d = colorDistanceSq(c, DisplayColorRGB);
            if (d < bestDist) {
                bestDist = d;
                bestIdx = ci;
            }
        });
        mapping[orig] = bestIdx;
    }
    return { palette, mapping };
}
function mapToClosestPaletteIndex(colors, palette) {
    const paletteRGB = palette.map(stringToRGB);
    const mapping = {};
    for (const color of colors) {
        const rgb = stringToRGB(color);
        let bestIdx = 0;
        let bestDist = Infinity;
        paletteRGB.forEach((p, idx) => {
            const d = colorDistanceSq(rgb, p);
            if (d < bestDist) {
                bestDist = d;
                bestIdx = idx;
            }
        });
        mapping[color] = bestIdx;
    }
    return mapping;
}

const DisplaySegmentCaps = ["flat", "round"];
const DisplayAlignments = ["start", "center", "end"];
const DisplayAlignmentDirections = ["horizontal", "vertical"];
const DisplayDirections = ["right", "left", "up", "down"];
const DefaultDisplayContextState = {
    backgroundColorIndex: 0,
    fillColorIndex: 1,
    lineColorIndex: 1,
    ignoreFill: false,
    ignoreLine: false,
    fillBackground: false,
    lineWidth: 0,
    rotation: 0,
    horizontalAlignment: "center",
    verticalAlignment: "center",
    segmentStartCap: "flat",
    segmentEndCap: "flat",
    segmentStartRadius: 1,
    segmentEndRadius: 1,
    cropTop: 0,
    cropRight: 0,
    cropBottom: 0,
    cropLeft: 0,
    rotationCropTop: 0,
    rotationCropRight: 0,
    rotationCropBottom: 0,
    rotationCropLeft: 0,
    bitmapColorIndices: new Array(0).fill(0),
    bitmapScaleX: 1,
    bitmapScaleY: 1,
    spriteColorIndices: new Array(0).fill(0),
    spriteScaleX: 1,
    spriteScaleY: 1,
    spriteSheetName: undefined,
    spritesLineHeight: 0,
    spritesDirection: "right",
    spritesLineDirection: "down",
    spritesSpacing: 0,
    spritesLineSpacing: 0,
    spritesAlignment: "end",
    spritesLineAlignment: "start",
};
function isDirectionPositive(direction) {
    switch (direction) {
        case "right":
        case "down":
            return true;
        case "left":
        case "up":
            return false;
    }
}
function isDirectionHorizontal(direction) {
    switch (direction) {
        case "right":
        case "left":
            return true;
        case "down":
        case "up":
            return false;
    }
}

function deepEqual(obj1, obj2) {
    if (obj1 === obj2) {
        return true;
    }
    if (typeof obj1 !== "object" ||
        obj1 === null ||
        typeof obj2 !== "object" ||
        obj2 === null) {
        return false;
    }
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length)
        return false;
    for (let key of keys1) {
        if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
            return false;
        }
    }
    return true;
}
function removeRedundancies(array) {
    return Array.from(new Set(array));
}

const _console$q = createConsole("DisplayContextStateHelper", { log: false });
class DisplayContextStateHelper {
    #state = Object.assign({}, DefaultDisplayContextState);
    get state() {
        return this.#state;
    }
    get isSegmentUniform() {
        return (this.state.segmentStartRadius == this.state.segmentEndRadius &&
            this.state.segmentStartCap == this.state.segmentEndCap);
    }
    diff(other) {
        let differences = [];
        const keys = Object.keys(other);
        keys.forEach((key) => {
            const value = other[key];
            if (!deepEqual(this.#state[key], value)) {
                differences.push(key);
            }
        });
        _console$q.log("diff", other, differences);
        return differences;
    }
    update(newState) {
        let differences = this.diff(newState);
        if (differences.length == 0) {
            _console$q.log("redundant contextState", newState);
        }
        differences.forEach((key) => {
            const value = newState[key];
            this.#state[key] = value;
        });
        return differences;
    }
    reset() {
        Object.assign(this.#state, DefaultDisplayContextState);
    }
}

const _console$p = createConsole("DisplayUtils", { log: false });
function formatRotation(rotation, isRadians, isSigned) {
    if (isRadians) {
        const rotationRad = rotation;
        _console$p.log({ rotationRad });
        rotation %= 2 * Math.PI;
        rotation /= 2 * Math.PI;
    }
    else {
        const rotationDeg = rotation;
        _console$p.log({ rotationDeg });
        rotation %= 360;
        rotation /= 360;
    }
    {
        rotation *= Uint16Max;
    }
    rotation = Math.floor(rotation);
    _console$p.log({ formattedRotation: rotation });
    return rotation;
}
function roundToStep(value, step) {
    const roundedValue = Math.round(value / step) * step;
    return roundedValue;
}
const minDisplayScale = -50;
const maxDisplayScale = 50;
const displayScaleStep = 0.002;
function formatScale(bitmapScale) {
    bitmapScale /= displayScaleStep;
    return bitmapScale;
}
function roundScale(bitmapScale) {
    return roundToStep(bitmapScale, displayScaleStep);
}
function assertValidSegmentCap(segmentCap) {
    _console$p.assertEnumWithError(segmentCap, DisplaySegmentCaps);
}
function assertValidDisplayBrightness(displayBrightness) {
    _console$p.assertEnumWithError(displayBrightness, DisplayBrightnesses);
}
function assertValidColorValue(name, value) {
    _console$p.assertRangeWithError(name, value, 0, 255);
}
function assertValidColor(color) {
    assertValidColorValue("red", color.r);
    assertValidColorValue("green", color.g);
    assertValidColorValue("blue", color.b);
}
function assertValidOpacity(value) {
    _console$p.assertRangeWithError("opacity", value, 0, 1);
}
const DisplayCropDirections = [
    "top",
    "right",
    "bottom",
    "left",
];
const DisplayCropDirectionToStateKey = {
    top: "cropTop",
    right: "cropRight",
    bottom: "cropBottom",
    left: "cropLeft",
};
const DisplayCropDirectionToCommandType = {
    top: "setCropTop",
    right: "setCropRight",
    bottom: "setCropBottom",
    left: "setCropLeft",
};
const DisplayRotationCropDirectionToStateKey = {
    top: "rotationCropTop",
    right: "rotationCropRight",
    bottom: "rotationCropBottom",
    left: "rotationCropLeft",
};
const DisplayRotationCropDirectionToCommandType = {
    top: "setRotationCropTop",
    right: "setRotationCropRight",
    bottom: "setRotationCropBottom",
    left: "setRotationCropLeft",
};
const DisplayAlignmentDirectionToCommandType = {
    horizontal: "setHorizontalAlignment",
    vertical: "setVerticalAlignment",
};
const DisplayAlignmentDirectionToStateKey = {
    horizontal: "horizontalAlignment",
    vertical: "verticalAlignment",
};
function pixelDepthToNumberOfColors(pixelDepth) {
    return 2 ** Number(pixelDepth);
}
function pixelDepthToPixelsPerByte(pixelDepth) {
    return 8 / Number(pixelDepth);
}
function pixelDepthToPixelBitWidth(pixelDepth) {
    return Number(pixelDepth);
}
function numberOfColorsToPixelDepth(numberOfColors) {
    return DisplayPixelDepths.find((pixelDepth) => numberOfColors <= pixelDepthToNumberOfColors(pixelDepth));
}
const DisplayBitmapScaleDirectionToCommandType = {
    x: "setBitmapScaleX",
    y: "setBitmapScaleY",
    all: "setBitmapScale",
};
const DisplaySpriteScaleDirectionToCommandType = {
    x: "setSpriteScaleX",
    y: "setSpriteScaleY",
    all: "setSpriteScale",
};
function assertValidAlignment(alignment) {
    _console$p.assertEnumWithError(alignment, DisplayAlignments);
}
function assertValidDirection(direction) {
    _console$p.assertEnumWithError(direction, DisplayDirections);
}
function assertValidAlignmentDirection(direction) {
    _console$p.assertEnumWithError(direction, DisplayAlignmentDirections);
}
const displayCurveTypeToNumberOfControlPoints = {
    segment: 2,
    quadratic: 3,
    cubic: 4,
};
const displayCurveTolerance = 2.0;
const displayCurveToleranceSquared = displayCurveTolerance ** 2;
const maxNumberOfDisplayCurvePoints = 150;
function assertValidNumberOfControlPoints(curveType, controlPoints, isPath = false) {
    let numberOfControlPoints = displayCurveTypeToNumberOfControlPoints[curveType];
    if (isPath) {
        numberOfControlPoints -= 1;
    }
    _console$p.assertWithError(controlPoints.length == numberOfControlPoints, `invalid number of control points ${controlPoints.length}, expected ${numberOfControlPoints}`);
}
function assertValidPathNumberOfControlPoints(curveType, controlPoints) {
    const numberOfControlPoints = displayCurveTypeToNumberOfControlPoints[curveType];
    _console$p.assertWithError((controlPoints.length - 1) % (numberOfControlPoints - 1) == 0, `invalid number of path control points ${controlPoints.length} for path "${curveType}"`);
}
function assertValidPath(curves) {
    curves.forEach((curve, index) => {
        const { type, controlPoints } = curve;
        assertValidNumberOfControlPoints(type, controlPoints, index > 0);
    });
}
function assertValidWireframe({ points, edges }) {
    _console$p.assertRangeWithError("numberOfPoints", points.length, 2, 255);
    _console$p.assertRangeWithError("numberOfEdges", edges.length, 1, 255);
    edges.forEach((edge, index) => {
        _console$p.assertRangeWithError(`edgeStartIndex.${index}`, edge.startIndex, 0, points.length);
        _console$p.assertRangeWithError(`edgeEndIndex.${index}`, edge.endIndex, 0, points.length);
    });
}
function isWireframePolygon({ points, edges, }) {
    _console$p.log("isWireframePolygon?", points, edges);
    if (points.length != edges.length) {
        return;
    }
    const _edges = edges.slice();
    let pointIndices = [];
    for (let i = 0; i < points.length; i++) {
        if (i == 0) {
            const { startIndex, endIndex } = _edges.shift();
            pointIndices.push(startIndex);
            pointIndices.push(endIndex);
        }
        else {
            const startIndex = pointIndices.at(-1);
            const edge = _edges.find((edge) => edge.startIndex == startIndex || edge.endIndex == startIndex);
            _console$p.log(i, "edge", edge);
            if (edge) {
                _edges.splice(_edges.indexOf(edge), 1);
                const endIndex = edge.startIndex == startIndex ? edge.endIndex : edge.startIndex;
                if (i == points.length - 1) {
                    if (endIndex != pointIndices[0]) {
                        return;
                    }
                }
                else if (pointIndices.includes(endIndex)) {
                    _console$p.log("duplicate endIndex", endIndex);
                    return;
                }
                pointIndices.push(endIndex);
            }
            else {
                _console$p.log("no edge found");
                return;
            }
        }
        _console$p.log("remaining edges", _edges);
    }
    _console$p.log("pointIndices", pointIndices);
    const polygon = pointIndices
        .map((pointIndex) => points[pointIndex])
        .filter((point, index, polygon) => polygon.indexOf(point) == index);
    if (polygon.length == points.length) {
        polygon.push(polygon[0]);
        _console$p.log("polygon", polygon);
        return polygon;
    }
}
function mergeWireframes(a, b) {
    const wireframe = structuredClone(a);
    const pointIndexOffset = a.points.length;
    b.points.forEach((point) => {
        wireframe.points.push(point);
    });
    b.edges.forEach(({ startIndex, endIndex }) => {
        wireframe.edges.push({
            startIndex: startIndex + pointIndexOffset,
            endIndex: endIndex + pointIndexOffset,
        });
    });
    return trimWireframe(wireframe);
}
function intersectWireframes(a, b, ignoreDirection = true) {
    a = trimWireframe(a);
    b = trimWireframe(b);
    const wireframe = { points: [], edges: [] };
    const aPointIndices = [];
    const bPointIndices = [];
    a.points.forEach((point, aPointIndex) => {
        const bPointIndex = b.points.findIndex((_point) => {
            const distance = getVector2Distance(point, _point);
            return distance == 0;
        });
        if (bPointIndex != -1) {
            aPointIndices.push(aPointIndex);
            bPointIndices.push(bPointIndex);
            wireframe.points.push(structuredClone(point));
        }
    });
    a.edges.forEach((aEdge) => {
        if (!aPointIndices.includes(aEdge.startIndex) ||
            !aPointIndices.includes(aEdge.endIndex)) {
            return;
        }
        const startIndex = aPointIndices.indexOf(aEdge.startIndex);
        const endIndex = aPointIndices.indexOf(aEdge.endIndex);
        const bEdge = b.edges.find((bEdge) => {
            if (!bPointIndices.includes(bEdge.startIndex) ||
                !bPointIndices.includes(bEdge.endIndex)) {
                return false;
            }
            const bStartIndex = bPointIndices.indexOf(bEdge.startIndex);
            const bEndIndex = bPointIndices.indexOf(bEdge.endIndex);
            if (ignoreDirection) {
                return ((startIndex == bStartIndex && endIndex == bEndIndex) ||
                    (startIndex == bEndIndex && endIndex == bStartIndex));
            }
            else {
                return startIndex == bStartIndex && endIndex == bEndIndex;
            }
        });
        if (!bEdge) {
            return;
        }
        wireframe.edges.push({
            startIndex,
            endIndex,
        });
    });
    return wireframe;
}
function trimWireframe(wireframe) {
    _console$p.log("trimming wireframe", wireframe);
    const { points, edges } = wireframe;
    const trimmedPoints = [];
    const trimmedEdges = [];
    edges.forEach((edge) => {
        const { startIndex, endIndex } = edge;
        let startPoint = points[startIndex];
        let endPoint = points[endIndex];
        let trimmedStartIndex = trimmedPoints.findIndex(({ x, y }) => startPoint.x == x && startPoint.y == y);
        if (trimmedStartIndex == -1) {
            trimmedPoints.push(startPoint);
            trimmedStartIndex = trimmedPoints.length - 1;
        }
        let trimmedEndIndex = trimmedPoints.findIndex(({ x, y }) => endPoint.x == x && endPoint.y == y);
        if (trimmedEndIndex == -1) {
            trimmedPoints.push(endPoint);
            trimmedEndIndex = trimmedPoints.length - 1;
        }
        const trimmedEdge = {
            startIndex: trimmedStartIndex,
            endIndex: trimmedEndIndex,
        };
        let trimmedEdgeIndex = trimmedEdges.findIndex(({ startIndex, endIndex }) => startIndex == trimmedEdge.startIndex && endIndex == trimmedEdge.endIndex);
        if (trimmedEdgeIndex == -1) {
            trimmedEdges.push(trimmedEdge);
            trimmedEdgeIndex = trimmedEdges.length - 1;
        }
    });
    _console$p.log("trimmedWireframe", trimmedPoints, trimmedEdges);
    return { points: trimmedPoints, edges: trimmedEdges };
}
function getPointDataType(points) {
    const range = new RangeHelper();
    points.forEach(({ x, y }) => {
        range.update(x);
        range.update(y);
    });
    const pointDataType = DisplayPointDataTypes.find((pointDataType) => {
        const { min, max } = displayPointDataTypeToRange[pointDataType];
        return range.min >= min && range.max <= max;
    });
    _console$p.log("pointDataType", pointDataType, points);
    return pointDataType;
}
function serializePoints(points, pointDataType, isPath = false) {
    pointDataType = pointDataType || getPointDataType(points);
    _console$p.assertEnumWithError(pointDataType, DisplayPointDataTypes);
    const pointDataSize = displayPointDataTypeToSize[pointDataType];
    let dataViewLength = points.length * pointDataSize;
    if (!isPath) {
        dataViewLength += 2;
    }
    const dataView = new DataView(new ArrayBuffer(dataViewLength));
    _console$p.log(`serializing ${points.length} ${pointDataType} points (${dataView.byteLength} bytes)...`);
    let offset = 0;
    if (!isPath) {
        dataView.setUint8(offset++, DisplayPointDataTypes.indexOf(pointDataType));
        dataView.setUint8(offset++, points.length);
    }
    points.forEach(({ x, y }) => {
        switch (pointDataType) {
            case "int8":
                dataView.setInt8(offset, x);
                offset += 1;
                dataView.setInt8(offset, y);
                offset += 1;
                break;
            case "int16":
                dataView.setInt16(offset, x, true);
                offset += 2;
                dataView.setInt16(offset, y, true);
                offset += 2;
                break;
            case "float":
                dataView.setFloat32(offset, x, true);
                offset += 4;
                dataView.setFloat32(offset, y, true);
                offset += 4;
                break;
        }
    });
    return dataView;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var rgbquant = {exports: {}};

(function (module) {
	(function(){
		function RgbQuant(opts) {
			opts = opts || {};
			this.method = opts.method || 2;
			this.colors = opts.colors || 256;
			this.initColors = opts.initColors || 4096;
			this.initDist = opts.initDist || 0.01;
			this.distIncr = opts.distIncr || 0.005;
			this.hueGroups = opts.hueGroups || 10;
			this.satGroups = opts.satGroups || 10;
			this.lumGroups = opts.lumGroups || 10;
			this.minHueCols = opts.minHueCols || 0;
			this.hueStats = this.minHueCols ? new HueStats(this.hueGroups, this.minHueCols) : null;
			this.boxSize = opts.boxSize || [64,64];
			this.boxPxls = opts.boxPxls || 2;
			this.palLocked = false;
			this.dithKern = opts.dithKern || null;
			this.dithSerp = opts.dithSerp || false;
			this.dithDelta = opts.dithDelta || 0;
			this.histogram = {};
			this.idxrgb = opts.palette ? opts.palette.slice(0) : [];
			this.idxi32 = [];
			this.i32idx = {};
			this.i32rgb = {};
			this.useCache = opts.useCache !== false;
			this.cacheFreq = opts.cacheFreq || 10;
			this.reIndex = opts.reIndex || this.idxrgb.length == 0;
			this.colorDist = opts.colorDist == "manhattan" ? distManhattan : distEuclidean;
			if (this.idxrgb.length > 0) {
				var self = this;
				this.idxrgb.forEach(function(rgb, i) {
					var i32 = (
						(255    << 24) |
						(rgb[2] << 16) |
						(rgb[1] <<  8) |
						 rgb[0]
					) >>> 0;
					self.idxi32[i]		= i32;
					self.i32idx[i32]	= i;
					self.i32rgb[i32]	= rgb;
				});
			}
		}
		RgbQuant.prototype.sample = function sample(img, width) {
			if (this.palLocked)
				throw "Cannot sample additional images, palette already assembled.";
			var data = getImageData(img, width);
			switch (this.method) {
				case 1: this.colorStats1D(data.buf32); break;
				case 2: this.colorStats2D(data.buf32, data.width); break;
			}
		};
		RgbQuant.prototype.reduce = function reduce(img, retType, dithKern, dithSerp) {
			if (!this.palLocked)
				this.buildPal();
			dithKern = dithKern || this.dithKern;
			dithSerp = typeof dithSerp != "undefined" ? dithSerp : this.dithSerp;
			retType = retType || 1;
			if (dithKern)
				var out32 = this.dither(img, dithKern, dithSerp);
			else {
				var data = getImageData(img),
					buf32 = data.buf32,
					len = buf32.length,
					out32 = new Uint32Array(len);
				for (var i = 0; i < len; i++) {
					var i32 = buf32[i];
					out32[i] = this.nearestColor(i32);
				}
			}
			if (retType == 1)
				return new Uint8Array(out32.buffer);
			if (retType == 2) {
				var out = [],
					len = out32.length;
				for (var i = 0; i < len; i++) {
					var i32 = out32[i];
					out[i] = this.i32idx[i32];
				}
				return out;
			}
		};
		RgbQuant.prototype.dither = function(img, kernel, serpentine) {
			var kernels = {
				FloydSteinberg: [
					[7 / 16, 1, 0],
					[3 / 16, -1, 1],
					[5 / 16, 0, 1],
					[1 / 16, 1, 1]
				],
				FalseFloydSteinberg: [
					[3 / 8, 1, 0],
					[3 / 8, 0, 1],
					[2 / 8, 1, 1]
				],
				Stucki: [
					[8 / 42, 1, 0],
					[4 / 42, 2, 0],
					[2 / 42, -2, 1],
					[4 / 42, -1, 1],
					[8 / 42, 0, 1],
					[4 / 42, 1, 1],
					[2 / 42, 2, 1],
					[1 / 42, -2, 2],
					[2 / 42, -1, 2],
					[4 / 42, 0, 2],
					[2 / 42, 1, 2],
					[1 / 42, 2, 2]
				],
				Atkinson: [
					[1 / 8, 1, 0],
					[1 / 8, 2, 0],
					[1 / 8, -1, 1],
					[1 / 8, 0, 1],
					[1 / 8, 1, 1],
					[1 / 8, 0, 2]
				],
				Jarvis: [
					[7 / 48, 1, 0],
					[5 / 48, 2, 0],
					[3 / 48, -2, 1],
					[5 / 48, -1, 1],
					[7 / 48, 0, 1],
					[5 / 48, 1, 1],
					[3 / 48, 2, 1],
					[1 / 48, -2, 2],
					[3 / 48, -1, 2],
					[5 / 48, 0, 2],
					[3 / 48, 1, 2],
					[1 / 48, 2, 2]
				],
				Burkes: [
					[8 / 32, 1, 0],
					[4 / 32, 2, 0],
					[2 / 32, -2, 1],
					[4 / 32, -1, 1],
					[8 / 32, 0, 1],
					[4 / 32, 1, 1],
					[2 / 32, 2, 1],
				],
				Sierra: [
					[5 / 32, 1, 0],
					[3 / 32, 2, 0],
					[2 / 32, -2, 1],
					[4 / 32, -1, 1],
					[5 / 32, 0, 1],
					[4 / 32, 1, 1],
					[2 / 32, 2, 1],
					[2 / 32, -1, 2],
					[3 / 32, 0, 2],
					[2 / 32, 1, 2],
				],
				TwoSierra: [
					[4 / 16, 1, 0],
					[3 / 16, 2, 0],
					[1 / 16, -2, 1],
					[2 / 16, -1, 1],
					[3 / 16, 0, 1],
					[2 / 16, 1, 1],
					[1 / 16, 2, 1],
				],
				SierraLite: [
					[2 / 4, 1, 0],
					[1 / 4, -1, 1],
					[1 / 4, 0, 1],
				],
			};
			if (!kernel || !kernels[kernel]) {
				throw 'Unknown dithering kernel: ' + kernel;
			}
			var ds = kernels[kernel];
			var data = getImageData(img),
				buf32 = data.buf32,
				width = data.width,
				height = data.height;
				buf32.length;
			var dir = serpentine ? -1 : 1;
			for (var y = 0; y < height; y++) {
				if (serpentine)
					dir = dir * -1;
				var lni = y * width;
				for (var x = (dir == 1 ? 0 : width - 1), xend = (dir == 1 ? width : 0); x !== xend; x += dir) {
					var idx = lni + x,
						i32 = buf32[idx],
						r1 = (i32 & 0xff),
						g1 = (i32 & 0xff00) >> 8,
						b1 = (i32 & 0xff0000) >> 16;
					var i32x = this.nearestColor(i32),
						r2 = (i32x & 0xff),
						g2 = (i32x & 0xff00) >> 8,
						b2 = (i32x & 0xff0000) >> 16;
					buf32[idx] =
						(255 << 24)	|
						(b2  << 16)	|
						(g2  <<  8)	|
						 r2;
					if (this.dithDelta) {
						var dist = this.colorDist([r1, g1, b1], [r2, g2, b2]);
						if (dist < this.dithDelta)
							continue;
					}
					var er = r1 - r2,
						eg = g1 - g2,
						eb = b1 - b2;
					for (var i = (dir == 1 ? 0 : ds.length - 1), end = (dir == 1 ? ds.length : 0); i !== end; i += dir) {
						var x1 = ds[i][1] * dir,
							y1 = ds[i][2];
						var lni2 = y1 * width;
						if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
							var d = ds[i][0];
							var idx2 = idx + (lni2 + x1);
							var r3 = (buf32[idx2] & 0xff),
								g3 = (buf32[idx2] & 0xff00) >> 8,
								b3 = (buf32[idx2] & 0xff0000) >> 16;
							var r4 = Math.max(0, Math.min(255, r3 + er * d)),
								g4 = Math.max(0, Math.min(255, g3 + eg * d)),
								b4 = Math.max(0, Math.min(255, b3 + eb * d));
							buf32[idx2] =
								(255 << 24)	|
								(b4  << 16)	|
								(g4  <<  8)	|
								 r4;
						}
					}
				}
			}
			return buf32;
		};
		RgbQuant.prototype.buildPal = function buildPal(noSort) {
			if (this.palLocked || this.idxrgb.length > 0 && this.idxrgb.length <= this.colors) return;
			var histG  = this.histogram,
				sorted = sortedHashKeys(histG);
			if (sorted.length == 0)
				throw "Nothing has been sampled, palette cannot be built.";
			switch (this.method) {
				case 1:
					var cols = this.initColors,
						last = sorted[cols - 1],
						freq = histG[last];
					var idxi32 = sorted.slice(0, cols);
					var pos = cols, len = sorted.length;
					while (pos < len && histG[sorted[pos]] == freq)
						idxi32.push(sorted[pos++]);
					if (this.hueStats)
						this.hueStats.inject(idxi32);
					break;
				case 2:
					var idxi32 = sorted;
					break;
			}
			idxi32 = idxi32.map(function(v){return +v;});
			this.reducePal(idxi32);
			if (!noSort && this.reIndex)
				this.sortPal();
			if (this.useCache)
				this.cacheHistogram(idxi32);
			this.palLocked = true;
		};
		RgbQuant.prototype.palette = function palette(tuples, noSort) {
			this.buildPal(noSort);
			return tuples ? this.idxrgb : new Uint8Array((new Uint32Array(this.idxi32)).buffer);
		};
		RgbQuant.prototype.prunePal = function prunePal(keep) {
			var i32;
			for (var j = 0; j < this.idxrgb.length; j++) {
				if (!keep[j]) {
					i32 = this.idxi32[j];
					this.idxrgb[j] = null;
					this.idxi32[j] = null;
					delete this.i32idx[i32];
				}
			}
			if (this.reIndex) {
				var idxrgb = [],
					idxi32 = [],
					i32idx = {};
				for (var j = 0, i = 0; j < this.idxrgb.length; j++) {
					if (this.idxrgb[j]) {
						i32 = this.idxi32[j];
						idxrgb[i] = this.idxrgb[j];
						i32idx[i32] = i;
						idxi32[i] = i32;
						i++;
					}
				}
				this.idxrgb = idxrgb;
				this.idxi32 = idxi32;
				this.i32idx = i32idx;
			}
		};
		RgbQuant.prototype.reducePal = function reducePal(idxi32) {
			if (this.idxrgb.length > this.colors) {
				var len = idxi32.length, keep = {}, uniques = 0, idx, pruned = false;
				for (var i = 0; i < len; i++) {
					if (uniques == this.colors && !pruned) {
						this.prunePal(keep);
						pruned = true;
					}
					idx = this.nearestIndex(idxi32[i]);
					if (uniques < this.colors && !keep[idx]) {
						keep[idx] = true;
						uniques++;
					}
				}
				if (!pruned) {
					this.prunePal(keep);
					pruned = true;
				}
			}
			else {
				var idxrgb = idxi32.map(function(i32) {
					return [
						(i32 & 0xff),
						(i32 & 0xff00) >> 8,
						(i32 & 0xff0000) >> 16,
					];
				});
				var len = idxrgb.length,
					palLen = len,
					thold = this.initDist;
				if (palLen > this.colors) {
					while (palLen > this.colors) {
						var memDist = [];
						for (var i = 0; i < len; i++) {
							var pxi = idxrgb[i]; idxi32[i];
							if (!pxi) continue;
							for (var j = i + 1; j < len; j++) {
								var pxj = idxrgb[j], i32j = idxi32[j];
								if (!pxj) continue;
								var dist = this.colorDist(pxi, pxj);
								if (dist < thold) {
									memDist.push([j, pxj, i32j, dist]);
									delete(idxrgb[j]);
									palLen--;
								}
							}
						}
						thold += (palLen > this.colors * 3) ? this.initDist : this.distIncr;
					}
					if (palLen < this.colors) {
						sort.call(memDist, function(a,b) {
							return b[3] - a[3];
						});
						var k = 0;
						while (palLen < this.colors) {
							idxrgb[memDist[k][0]] = memDist[k][1];
							palLen++;
							k++;
						}
					}
				}
				var len = idxrgb.length;
				for (var i = 0; i < len; i++) {
					if (!idxrgb[i]) continue;
					this.idxrgb.push(idxrgb[i]);
					this.idxi32.push(idxi32[i]);
					this.i32idx[idxi32[i]] = this.idxi32.length - 1;
					this.i32rgb[idxi32[i]] = idxrgb[i];
				}
			}
		};
		RgbQuant.prototype.colorStats1D = function colorStats1D(buf32) {
			var histG = this.histogram,
				col,
				len = buf32.length;
			for (var i = 0; i < len; i++) {
				col = buf32[i];
				if ((col & 0xff000000) >> 24 == 0) continue;
				if (this.hueStats)
					this.hueStats.check(col);
				if (col in histG)
					histG[col]++;
				else
					histG[col] = 1;
			}
		};
		RgbQuant.prototype.colorStats2D = function colorStats2D(buf32, width) {
			var boxW = this.boxSize[0],
				boxH = this.boxSize[1],
				area = boxW * boxH,
				boxes = makeBoxes(width, buf32.length / width, boxW, boxH),
				histG = this.histogram,
				self = this;
			boxes.forEach(function(box) {
				var effc = Math.max(Math.round((box.w * box.h) / area) * self.boxPxls, 2),
					histL = {}, col;
				iterBox(box, width, function(i) {
					col = buf32[i];
					if ((col & 0xff000000) >> 24 == 0) return;
					if (self.hueStats)
						self.hueStats.check(col);
					if (col in histG)
						histG[col]++;
					else if (col in histL) {
						if (++histL[col] >= effc)
							histG[col] = histL[col];
					}
					else
						histL[col] = 1;
				});
			});
			if (this.hueStats)
				this.hueStats.inject(histG);
		};
		RgbQuant.prototype.sortPal = function sortPal() {
			var self = this;
			this.idxi32.sort(function(a,b) {
				var idxA = self.i32idx[a],
					idxB = self.i32idx[b],
					rgbA = self.idxrgb[idxA],
					rgbB = self.idxrgb[idxB];
				var hslA = rgb2hsl(rgbA[0],rgbA[1],rgbA[2]),
					hslB = rgb2hsl(rgbB[0],rgbB[1],rgbB[2]);
				var hueA = (rgbA[0] == rgbA[1] && rgbA[1] == rgbA[2]) ? -1 : hueGroup(hslA.h, self.hueGroups);
				var hueB = (rgbB[0] == rgbB[1] && rgbB[1] == rgbB[2]) ? -1 : hueGroup(hslB.h, self.hueGroups);
				var hueDiff = hueB - hueA;
				if (hueDiff) return -hueDiff;
				var lumDiff = lumGroup(+hslB.l.toFixed(2)) - lumGroup(+hslA.l.toFixed(2));
				if (lumDiff) return -lumDiff;
				var satDiff = satGroup(+hslB.s.toFixed(2)) - satGroup(+hslA.s.toFixed(2));
				if (satDiff) return -satDiff;
			});
			this.idxi32.forEach(function(i32, i) {
				self.idxrgb[i] = self.i32rgb[i32];
				self.i32idx[i32] = i;
			});
		};
		RgbQuant.prototype.nearestColor = function nearestColor(i32) {
			var idx = this.nearestIndex(i32);
			return idx === null ? 0 : this.idxi32[idx];
		};
		RgbQuant.prototype.nearestIndex = function nearestIndex(i32) {
			if ((i32 & 0xff000000) >> 24 == 0)
				return null;
			if (this.useCache && (""+i32) in this.i32idx)
				return this.i32idx[i32];
			var min = 1000,
				idx,
				rgb = [
					(i32 & 0xff),
					(i32 & 0xff00) >> 8,
					(i32 & 0xff0000) >> 16,
				],
				len = this.idxrgb.length;
			for (var i = 0; i < len; i++) {
				if (!this.idxrgb[i]) continue;
				var dist = this.colorDist(rgb, this.idxrgb[i]);
				if (dist < min) {
					min = dist;
					idx = i;
				}
			}
			return idx;
		};
		RgbQuant.prototype.cacheHistogram = function cacheHistogram(idxi32) {
			for (var i = 0, i32 = idxi32[i]; i < idxi32.length && this.histogram[i32] >= this.cacheFreq; i32 = idxi32[i++])
				this.i32idx[i32] = this.nearestIndex(i32);
		};
		function HueStats(numGroups, minCols) {
			this.numGroups = numGroups;
			this.minCols = minCols;
			this.stats = {};
			for (var i = -1; i < numGroups; i++)
				this.stats[i] = {num: 0, cols: []};
			this.groupsFull = 0;
		}
		HueStats.prototype.check = function checkHue(i32) {
			if (this.groupsFull == this.numGroups + 1)
				this.check = function() {return;};
			var r = (i32 & 0xff),
				g = (i32 & 0xff00) >> 8,
				b = (i32 & 0xff0000) >> 16,
				hg = (r == g && g == b) ? -1 : hueGroup(rgb2hsl(r,g,b).h, this.numGroups),
				gr = this.stats[hg],
				min = this.minCols;
			gr.num++;
			if (gr.num > min)
				return;
			if (gr.num == min)
				this.groupsFull++;
			if (gr.num <= min)
				this.stats[hg].cols.push(i32);
		};
		HueStats.prototype.inject = function injectHues(histG) {
			for (var i = -1; i < this.numGroups; i++) {
				if (this.stats[i].num <= this.minCols) {
					switch (typeOf(histG)) {
						case "Array":
							this.stats[i].cols.forEach(function(col){
								if (histG.indexOf(col) == -1)
									histG.push(col);
							});
							break;
						case "Object":
							this.stats[i].cols.forEach(function(col){
								if (!histG[col])
									histG[col] = 1;
								else
									histG[col]++;
							});
							break;
					}
				}
			}
		};
		var Pr = .2126,
			Pg = .7152,
			Pb = .0722;
		function rgb2lum(r,g,b) {
			return Math.sqrt(
				Pr * r*r +
				Pg * g*g +
				Pb * b*b
			);
		}
		var rd = 255,
			gd = 255,
			bd = 255;
		var euclMax = Math.sqrt(Pr*rd*rd + Pg*gd*gd + Pb*bd*bd);
		function distEuclidean(rgb0, rgb1) {
			var rd = rgb1[0]-rgb0[0],
				gd = rgb1[1]-rgb0[1],
				bd = rgb1[2]-rgb0[2];
			return Math.sqrt(Pr*rd*rd + Pg*gd*gd + Pb*bd*bd) / euclMax;
		}
		var manhMax = Pr*rd + Pg*gd + Pb*bd;
		function distManhattan(rgb0, rgb1) {
			var rd = Math.abs(rgb1[0]-rgb0[0]),
				gd = Math.abs(rgb1[1]-rgb0[1]),
				bd = Math.abs(rgb1[2]-rgb0[2]);
			return (Pr*rd + Pg*gd + Pb*bd) / manhMax;
		}
		function rgb2hsl(r, g, b) {
			var max, min, h, s, l, d;
			r /= 255;
			g /= 255;
			b /= 255;
			max = Math.max(r, g, b);
			min = Math.min(r, g, b);
			l = (max + min) / 2;
			if (max == min) {
				h = s = 0;
			} else {
				d = max - min;
				s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
				switch (max) {
					case r: h = (g - b) / d + (g < b ? 6 : 0); break;
					case g:	h = (b - r) / d + 2; break;
					case b:	h = (r - g) / d + 4; break
				}
				h /= 6;
			}
			return {
				h: h,
				s: s,
				l: rgb2lum(r,g,b),
			};
		}
		function hueGroup(hue, segs) {
			var seg = 1/segs,
				haf = seg/2;
			if (hue >= 1 - haf || hue <= haf)
				return 0;
			for (var i = 1; i < segs; i++) {
				var mid = i*seg;
				if (hue >= mid - haf && hue <= mid + haf)
					return i;
			}
		}
		function satGroup(sat) {
			return sat;
		}
		function lumGroup(lum) {
			return lum;
		}
		function typeOf(val) {
			return Object.prototype.toString.call(val).slice(8,-1);
		}
		var sort = isArrSortStable() ? Array.prototype.sort : stableSort;
		function stableSort(fn) {
			var type = typeOf(this[0]);
			if (type == "Number" || type == "String") {
				var ord = {}, len = this.length, val;
				for (var i = 0; i < len; i++) {
					val = this[i];
					if (ord[val] || ord[val] === 0) continue;
					ord[val] = i;
				}
				return this.sort(function(a,b) {
					return fn(a,b) || ord[a] - ord[b];
				});
			}
			else {
				var ord = this.map(function(v){return v});
				return this.sort(function(a,b) {
					return fn(a,b) || ord.indexOf(a) - ord.indexOf(b);
				});
			}
		}
		function isArrSortStable() {
			var str = "abcdefghijklmnopqrstuvwxyz";
			return "xyzvwtursopqmnklhijfgdeabc" == str.split("").sort(function(a,b) {
				return ~~(str.indexOf(b)/2.3) - ~~(str.indexOf(a)/2.3);
			}).join("");
		}
		function getImageData(img, width) {
			var can, ctx, imgd, buf8, buf32, height;
			switch (typeOf(img)) {
				case "HTMLImageElement":
					can = document.createElement("canvas");
					can.width = img.naturalWidth;
					can.height = img.naturalHeight;
					ctx = can.getContext("2d");
					ctx.drawImage(img,0,0);
				case "Canvas":
				case "HTMLCanvasElement":
					can = can || img;
					ctx = ctx || can.getContext("2d");
				case "CanvasRenderingContext2D":
					ctx = ctx || img;
					can = can || ctx.canvas;
					imgd = ctx.getImageData(0, 0, can.width, can.height);
				case "ImageData":
					imgd = imgd || img;
					width = imgd.width;
					if (typeOf(imgd.data) == "CanvasPixelArray")
						buf8 = new Uint8Array(imgd.data);
					else
						buf8 = imgd.data;
				case "Array":
				case "CanvasPixelArray":
					buf8 = buf8 || new Uint8Array(img);
				case "Uint8Array":
				case "Uint8ClampedArray":
					buf8 = buf8 || img;
					buf32 = new Uint32Array(buf8.buffer);
				case "Uint32Array":
					buf32 = buf32 || img;
					buf8 = buf8 || new Uint8Array(buf32.buffer);
					width = width || buf32.length;
					height = buf32.length / width;
			}
			return {
				can: can,
				ctx: ctx,
				imgd: imgd,
				buf8: buf8,
				buf32: buf32,
				width: width,
				height: height,
			};
		}
		function makeBoxes(wid, hgt, w0, h0) {
			var wrem = wid%w0,
				hrem = hgt%h0,
				xend = wid-wrem, yend = hgt-hrem;
			var bxs = [];
			for (var y = 0; y < hgt; y += h0)
				for (var x = 0; x < wid; x += w0)
					bxs.push({x:x, y:y, w:(x==xend?wrem:w0), h:(y==yend?hrem:h0)});
			return bxs;
		}
		function iterBox(bbox, wid, fn) {
			var b = bbox,
				i0 = b.y * wid + b.x,
				i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1),
				cnt = 0, incr = wid - b.w + 1, i = i0;
			do {
				fn.call(this, i);
				i += (++cnt % b.w == 0) ? incr : 1;
			} while (i <= i1);
		}
		function sortedHashKeys(obj, desc) {
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return sort.call(keys, function(a,b) {
				return obj[b] - obj[a] ;
			});
		}
		this.RgbQuant = RgbQuant;
		if (module.exports) {
			module.exports = RgbQuant;
		}
	}).call(commonjsGlobal);
} (rgbquant));
var rgbquantExports = rgbquant.exports;
var RGBQuant = getDefaultExportFromCjs(rgbquantExports);

const _console$o = createConsole("DisplayContextCommand", { log: false });
const DisplayContextCommandTypes = [
    "show",
    "clear",
    "setColor",
    "setColorOpacity",
    "setOpacity",
    "saveContext",
    "restoreContext",
    "selectBackgroundColor",
    "selectFillColor",
    "selectLineColor",
    "setIgnoreFill",
    "setIgnoreLine",
    "setFillBackground",
    "setLineWidth",
    "setRotation",
    "clearRotation",
    "setHorizontalAlignment",
    "setVerticalAlignment",
    "resetAlignment",
    "setSegmentStartCap",
    "setSegmentEndCap",
    "setSegmentCap",
    "setSegmentStartRadius",
    "setSegmentEndRadius",
    "setSegmentRadius",
    "setCropTop",
    "setCropRight",
    "setCropBottom",
    "setCropLeft",
    "clearCrop",
    "setRotationCropTop",
    "setRotationCropRight",
    "setRotationCropBottom",
    "setRotationCropLeft",
    "clearRotationCrop",
    "selectBitmapColor",
    "selectBitmapColors",
    "setBitmapScaleX",
    "setBitmapScaleY",
    "setBitmapScale",
    "resetBitmapScale",
    "selectSpriteColor",
    "selectSpriteColors",
    "resetSpriteColors",
    "setSpriteScaleX",
    "setSpriteScaleY",
    "setSpriteScale",
    "resetSpriteScale",
    "setSpritesLineHeight",
    "setSpritesDirection",
    "setSpritesLineDirection",
    "setSpritesSpacing",
    "setSpritesLineSpacing",
    "setSpritesAlignment",
    "setSpritesLineAlignment",
    "clearRect",
    "drawRect",
    "drawRoundRect",
    "drawCircle",
    "drawArc",
    "drawEllipse",
    "drawArcEllipse",
    "drawSegment",
    "drawSegments",
    "drawRegularPolygon",
    "drawPolygon",
    "drawWireframe",
    "drawQuadraticBezierCurve",
    "drawQuadraticBezierCurves",
    "drawCubicBezierCurve",
    "drawCubicBezierCurves",
    "drawPath",
    "drawClosedPath",
    "drawBitmap",
    "selectSpriteSheet",
    "drawSprite",
    "drawSprites",
    "startSprite",
    "endSprite",
];
const DisplaySpriteContextCommandTypes = [
    "selectFillColor",
    "selectLineColor",
    "setIgnoreFill",
    "setIgnoreLine",
    "setLineWidth",
    "setRotation",
    "clearRotation",
    "setVerticalAlignment",
    "setHorizontalAlignment",
    "resetAlignment",
    "setSegmentStartCap",
    "setSegmentEndCap",
    "setSegmentCap",
    "setSegmentStartRadius",
    "setSegmentEndRadius",
    "setSegmentRadius",
    "setCropTop",
    "setCropRight",
    "setCropBottom",
    "setCropLeft",
    "clearCrop",
    "setRotationCropTop",
    "setRotationCropRight",
    "setRotationCropBottom",
    "setRotationCropLeft",
    "clearRotationCrop",
    "selectBitmapColor",
    "selectBitmapColors",
    "setBitmapScaleX",
    "setBitmapScaleY",
    "setBitmapScale",
    "resetBitmapScale",
    "selectSpriteColor",
    "selectSpriteColors",
    "resetSpriteColors",
    "setSpriteScaleX",
    "setSpriteScaleY",
    "setSpriteScale",
    "resetSpriteScale",
    "clearRect",
    "drawRect",
    "drawRoundRect",
    "drawCircle",
    "drawEllipse",
    "drawRegularPolygon",
    "drawPolygon",
    "drawWireframe",
    "drawQuadraticBezierCurve",
    "drawQuadraticBezierCurves",
    "drawCubicBezierCurve",
    "drawCubicBezierCurves",
    "drawPath",
    "drawClosedPath",
    "drawSegment",
    "drawSegments",
    "drawArc",
    "drawArcEllipse",
    "drawBitmap",
    "drawSprite",
];
function serializeContextCommand(displayManager, command) {
    let dataView;
    switch (command.type) {
        case "show":
        case "clear":
        case "saveContext":
        case "restoreContext":
        case "clearRotation":
        case "clearCrop":
        case "clearRotationCrop":
        case "resetBitmapScale":
        case "resetSpriteColors":
        case "resetSpriteScale":
        case "resetAlignment":
        case "endSprite":
            break;
        case "setColor":
            {
                const { color, colorIndex } = command;
                let colorRGB;
                if (typeof color == "string") {
                    colorRGB = stringToRGB(color);
                }
                else {
                    colorRGB = color;
                }
                const colorHex = rgbToHex(colorRGB);
                if (displayManager.colors[colorIndex] == colorHex) {
                    _console$o.log(`redundant color #${colorIndex} ${colorHex}`);
                    return;
                }
                displayManager.assertValidColorIndex(colorIndex);
                assertValidColor(colorRGB);
                dataView = new DataView(new ArrayBuffer(4));
                dataView.setUint8(0, colorIndex);
                dataView.setUint8(1, colorRGB.r);
                dataView.setUint8(2, colorRGB.g);
                dataView.setUint8(3, colorRGB.b);
            }
            break;
        case "setColorOpacity":
            {
                const { colorIndex, opacity } = command;
                displayManager.assertValidColorIndex(colorIndex);
                assertValidOpacity(opacity);
                if (Math.floor(255 * displayManager.opacities[colorIndex]) ==
                    Math.floor(255 * opacity)) {
                    _console$o.log(`redundant opacity #${colorIndex} ${opacity}`);
                    return;
                }
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint8(0, colorIndex);
                dataView.setUint8(1, opacity * 255);
            }
            break;
        case "setOpacity":
            {
                const { opacity } = command;
                assertValidOpacity(opacity);
                dataView = new DataView(new ArrayBuffer(1));
                dataView.setUint8(0, Math.round(opacity * 255));
            }
            break;
        case "selectFillColor":
            {
                const { fillColorIndex } = command;
                displayManager.assertValidColorIndex(fillColorIndex);
                dataView = new DataView(new ArrayBuffer(1));
                dataView.setUint8(0, fillColorIndex);
            }
            break;
        case "selectBackgroundColor":
            {
                const { backgroundColorIndex } = command;
                displayManager.assertValidColorIndex(backgroundColorIndex);
                dataView = new DataView(new ArrayBuffer(1));
                dataView.setUint8(0, backgroundColorIndex);
            }
            break;
        case "selectLineColor":
            {
                const { lineColorIndex } = command;
                displayManager.assertValidColorIndex(lineColorIndex);
                dataView = new DataView(new ArrayBuffer(1));
                dataView.setUint8(0, lineColorIndex);
            }
            break;
        case "setIgnoreFill":
            {
                const { ignoreFill } = command;
                dataView = new DataView(new ArrayBuffer(1));
                dataView.setUint8(0, ignoreFill ? 1 : 0);
            }
            break;
        case "setIgnoreLine":
            {
                const { ignoreLine } = command;
                dataView = new DataView(new ArrayBuffer(1));
                dataView.setUint8(0, ignoreLine ? 1 : 0);
            }
            break;
        case "setFillBackground":
            {
                const { fillBackground } = command;
                dataView = new DataView(new ArrayBuffer(1));
                dataView.setUint8(0, fillBackground ? 1 : 0);
            }
            break;
        case "setLineWidth":
            {
                const { lineWidth } = command;
                displayManager.assertValidLineWidth(lineWidth);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, lineWidth, true);
            }
            break;
        case "setHorizontalAlignment":
            {
                const { horizontalAlignment } = command;
                assertValidAlignment(horizontalAlignment);
                _console$o.log({ horizontalAlignment });
                dataView = new DataView(new ArrayBuffer(1));
                const alignmentEnum = DisplayAlignments.indexOf(horizontalAlignment);
                dataView.setUint8(0, alignmentEnum);
            }
            break;
        case "setVerticalAlignment":
            {
                const { verticalAlignment } = command;
                assertValidAlignment(verticalAlignment);
                _console$o.log({ verticalAlignment });
                dataView = new DataView(new ArrayBuffer(1));
                const alignmentEnum = DisplayAlignments.indexOf(verticalAlignment);
                dataView.setUint8(0, alignmentEnum);
            }
            break;
        case "setRotation":
            {
                let { rotation, isRadians } = command;
                rotation = isRadians ? rotation : degToRad(rotation);
                rotation = normalizeRadians(rotation);
                isRadians = true;
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, formatRotation(rotation, isRadians), true);
            }
            break;
        case "setSegmentStartCap":
            {
                const { segmentStartCap } = command;
                assertValidSegmentCap(segmentStartCap);
                _console$o.log({ segmentStartCap });
                dataView = new DataView(new ArrayBuffer(1));
                const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentStartCap);
                dataView.setUint8(0, segmentCapEnum);
            }
            break;
        case "setSegmentEndCap":
            {
                const { segmentEndCap } = command;
                assertValidSegmentCap(segmentEndCap);
                _console$o.log({ segmentEndCap });
                dataView = new DataView(new ArrayBuffer(1));
                const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentEndCap);
                dataView.setUint8(0, segmentCapEnum);
            }
            break;
        case "setSegmentCap":
            {
                const { segmentCap } = command;
                assertValidSegmentCap(segmentCap);
                _console$o.log({ segmentCap });
                dataView = new DataView(new ArrayBuffer(1));
                const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentCap);
                dataView.setUint8(0, segmentCapEnum);
            }
            break;
        case "setSegmentStartRadius":
            {
                const { segmentStartRadius } = command;
                _console$o.log({ segmentStartRadius });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, segmentStartRadius, true);
            }
            break;
        case "setSegmentEndRadius":
            {
                const { segmentEndRadius } = command;
                _console$o.log({ segmentEndRadius });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, segmentEndRadius, true);
            }
            break;
        case "setSegmentRadius":
            {
                const { segmentRadius } = command;
                _console$o.log({ segmentRadius });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, segmentRadius, true);
            }
            break;
        case "setCropTop":
            {
                const { cropTop } = command;
                _console$o.log({ cropTop });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, cropTop, true);
            }
            break;
        case "setCropRight":
            {
                const { cropRight } = command;
                _console$o.log({ cropRight });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, cropRight, true);
            }
            break;
        case "setCropBottom":
            {
                const { cropBottom } = command;
                _console$o.log({ cropBottom });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, cropBottom, true);
            }
            break;
        case "setCropLeft":
            {
                const { cropLeft } = command;
                _console$o.log({ cropLeft });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, cropLeft, true);
            }
            break;
        case "setRotationCropTop":
            {
                const { rotationCropTop } = command;
                _console$o.log({ rotationCropTop });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, rotationCropTop, true);
            }
            break;
        case "setRotationCropRight":
            {
                const { rotationCropRight } = command;
                _console$o.log({ rotationCropRight });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, rotationCropRight, true);
            }
            break;
        case "setRotationCropBottom":
            {
                const { rotationCropBottom } = command;
                _console$o.log({ rotationCropBottom });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, rotationCropBottom, true);
            }
            break;
        case "setRotationCropLeft":
            {
                const { rotationCropLeft } = command;
                _console$o.log({ rotationCropLeft });
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, rotationCropLeft, true);
            }
            break;
        case "selectBitmapColor":
            {
                const { bitmapColorIndex, colorIndex } = command;
                displayManager.assertValidColorIndex(bitmapColorIndex);
                displayManager.assertValidColorIndex(colorIndex);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint8(0, bitmapColorIndex);
                dataView.setUint8(1, colorIndex);
            }
            break;
        case "selectBitmapColors":
            {
                const { bitmapColorPairs } = command;
                _console$o.assertRangeWithError("bitmapColors", bitmapColorPairs.length, 1, displayManager.numberOfColors);
                const bitmapColorIndices = displayManager.contextState.bitmapColorIndices.slice();
                bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {
                    displayManager.assertValidColorIndex(bitmapColorIndex);
                    displayManager.assertValidColorIndex(colorIndex);
                    bitmapColorIndices[bitmapColorIndex] = colorIndex;
                });
                dataView = new DataView(new ArrayBuffer(bitmapColorPairs.length * 2 + 1));
                let offset = 0;
                dataView.setUint8(offset++, bitmapColorPairs.length);
                bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {
                    dataView.setUint8(offset, bitmapColorIndex);
                    dataView.setUint8(offset + 1, colorIndex);
                    offset += 2;
                });
            }
            break;
        case "setBitmapScaleX":
            {
                let { bitmapScaleX } = command;
                bitmapScaleX = clamp(bitmapScaleX, minDisplayScale, maxDisplayScale);
                bitmapScaleX = roundScale(bitmapScaleX);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setInt16(0, formatScale(bitmapScaleX), true);
            }
            break;
        case "setBitmapScaleY":
            {
                let { bitmapScaleY } = command;
                bitmapScaleY = clamp(bitmapScaleY, minDisplayScale, maxDisplayScale);
                bitmapScaleY = roundScale(bitmapScaleY);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setInt16(0, formatScale(bitmapScaleY), true);
            }
            break;
        case "setBitmapScale":
            {
                let { bitmapScale } = command;
                bitmapScale = clamp(bitmapScale, minDisplayScale, maxDisplayScale);
                bitmapScale = roundScale(bitmapScale);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setInt16(0, formatScale(bitmapScale), true);
            }
            break;
        case "selectSpriteColor":
            {
                const { spriteColorIndex, colorIndex } = command;
                displayManager.assertValidColorIndex(spriteColorIndex);
                displayManager.assertValidColorIndex(colorIndex);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint8(0, spriteColorIndex);
                dataView.setUint8(1, colorIndex);
            }
            break;
        case "selectSpriteColors":
            {
                const { spriteColorPairs } = command;
                _console$o.assertRangeWithError("spriteColors", spriteColorPairs.length, 1, displayManager.numberOfColors);
                const spriteColorIndices = displayManager.contextState.spriteColorIndices.slice();
                spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {
                    displayManager.assertValidColorIndex(spriteColorIndex);
                    displayManager.assertValidColorIndex(colorIndex);
                    spriteColorIndices[spriteColorIndex] = colorIndex;
                });
                dataView = new DataView(new ArrayBuffer(spriteColorPairs.length * 2 + 1));
                let offset = 0;
                dataView.setUint8(offset++, spriteColorPairs.length);
                spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {
                    dataView.setUint8(offset, spriteColorIndex);
                    dataView.setUint8(offset + 1, colorIndex);
                    offset += 2;
                });
            }
            break;
        case "setSpriteScaleX":
            {
                let { spriteScaleX } = command;
                spriteScaleX = clamp(spriteScaleX, minDisplayScale, maxDisplayScale);
                spriteScaleX = roundScale(spriteScaleX);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setInt16(0, formatScale(spriteScaleX), true);
            }
            break;
        case "setSpriteScaleY":
            {
                let { spriteScaleY } = command;
                spriteScaleY = clamp(spriteScaleY, minDisplayScale, maxDisplayScale);
                spriteScaleY = roundScale(spriteScaleY);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setInt16(0, formatScale(spriteScaleY), true);
            }
            break;
        case "setSpriteScale":
            {
                let { spriteScale } = command;
                spriteScale = clamp(spriteScale, minDisplayScale, maxDisplayScale);
                spriteScale = roundScale(spriteScale);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setInt16(0, formatScale(spriteScale), true);
            }
            break;
        case "setSpritesLineHeight":
            {
                const { spritesLineHeight } = command;
                displayManager.assertValidLineWidth(spritesLineHeight);
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setUint16(0, spritesLineHeight, true);
            }
            break;
        case "setSpritesDirection":
            {
                const { spritesDirection } = command;
                assertValidDirection(spritesDirection);
                _console$o.log({ spritesDirection });
                dataView = new DataView(new ArrayBuffer(1));
                const alignmentEnum = DisplayDirections.indexOf(spritesDirection);
                dataView.setUint8(0, alignmentEnum);
            }
            break;
        case "setSpritesLineDirection":
            {
                const { spritesLineDirection } = command;
                assertValidDirection(spritesLineDirection);
                _console$o.log({ spritesLineDirection });
                dataView = new DataView(new ArrayBuffer(1));
                const alignmentEnum = DisplayDirections.indexOf(spritesLineDirection);
                dataView.setUint8(0, alignmentEnum);
            }
            break;
        case "setSpritesSpacing":
            {
                const { spritesSpacing } = command;
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setInt16(0, spritesSpacing, true);
            }
            break;
        case "setSpritesLineSpacing":
            {
                const { spritesLineSpacing } = command;
                dataView = new DataView(new ArrayBuffer(2));
                dataView.setInt16(0, spritesLineSpacing, true);
            }
            break;
        case "setSpritesAlignment":
            {
                const { spritesAlignment } = command;
                assertValidAlignment(spritesAlignment);
                _console$o.log({ spritesAlignment });
                dataView = new DataView(new ArrayBuffer(1));
                const alignmentEnum = DisplayAlignments.indexOf(spritesAlignment);
                dataView.setUint8(0, alignmentEnum);
            }
            break;
        case "setSpritesLineAlignment":
            {
                const { spritesLineAlignment } = command;
                assertValidAlignment(spritesLineAlignment);
                _console$o.log({ spritesLineAlignment });
                dataView = new DataView(new ArrayBuffer(1));
                const alignmentEnum = DisplayAlignments.indexOf(spritesLineAlignment);
                dataView.setUint8(0, alignmentEnum);
            }
            break;
        case "clearRect":
            {
                const { x, y, width, height } = command;
                dataView = new DataView(new ArrayBuffer(2 * 4));
                dataView.setInt16(0, x, true);
                dataView.setInt16(2, y, true);
                dataView.setInt16(4, width, true);
                dataView.setInt16(6, height, true);
            }
            break;
        case "drawRect":
            {
                const { offsetX, offsetY, width, height } = command;
                dataView = new DataView(new ArrayBuffer(2 * 4));
                dataView.setInt16(0, offsetX, true);
                dataView.setInt16(2, offsetY, true);
                dataView.setUint16(4, width, true);
                dataView.setUint16(6, height, true);
            }
            break;
        case "drawRoundRect":
            {
                const { offsetX, offsetY, width, height, borderRadius } = command;
                dataView = new DataView(new ArrayBuffer(2 * 4 + 1));
                dataView.setInt16(0, offsetX, true);
                dataView.setInt16(2, offsetY, true);
                dataView.setUint16(4, width, true);
                dataView.setUint16(6, height, true);
                dataView.setUint8(8, borderRadius);
            }
            break;
        case "drawCircle":
            {
                const { offsetX, offsetY, radius } = command;
                dataView = new DataView(new ArrayBuffer(2 * 3));
                dataView.setInt16(0, offsetX, true);
                dataView.setInt16(2, offsetY, true);
                dataView.setUint16(4, radius, true);
            }
            break;
        case "drawEllipse":
            {
                const { offsetX, offsetY, radiusX, radiusY } = command;
                dataView = new DataView(new ArrayBuffer(2 * 4));
                dataView.setInt16(0, offsetX, true);
                dataView.setInt16(2, offsetY, true);
                dataView.setUint16(4, radiusX, true);
                dataView.setUint16(6, radiusY, true);
            }
            break;
        case "drawRegularPolygon":
            {
                const { offsetX, offsetY, radius, numberOfSides } = command;
                dataView = new DataView(new ArrayBuffer(2 * 3 + 1));
                dataView.setInt16(0, offsetX, true);
                dataView.setInt16(2, offsetY, true);
                dataView.setUint16(4, radius, true);
                dataView.setUint8(6, numberOfSides);
            }
            break;
        case "drawPolygon":
            {
                const { points } = command;
                _console$o.assertRangeWithError("numberOfPoints", points.length, 2, 255);
                dataView = serializePoints(points);
            }
            break;
        case "drawWireframe":
            {
                const { wireframe } = command;
                const { points, edges } = wireframe;
                if (wireframe.points.length == 0) {
                    return;
                }
                assertValidWireframe(wireframe);
                const pointsDataView = serializePoints(points);
                const edgesDataView = new DataView(new ArrayBuffer(1 + 2 * edges.length));
                let edgesDataOffset = 0;
                edgesDataView.setUint8(edgesDataOffset++, edges.length);
                edges.forEach((edge) => {
                    edgesDataView.setUint8(edgesDataOffset++, edge.startIndex);
                    edgesDataView.setUint8(edgesDataOffset++, edge.endIndex);
                });
                dataView = new DataView(concatenateArrayBuffers(pointsDataView, edgesDataView));
            }
            break;
        case "drawQuadraticBezierCurve":
        case "drawCubicBezierCurve":
            {
                const { controlPoints } = command;
                const curveType = command.type == "drawCubicBezierCurve" ? "cubic" : "quadratic";
                assertValidNumberOfControlPoints(curveType, controlPoints);
                dataView = new DataView(new ArrayBuffer(4 * controlPoints.length));
                let offset = 0;
                controlPoints.forEach((controlPoint) => {
                    dataView.setInt16(offset, controlPoint.x, true);
                    offset += 2;
                    dataView.setInt16(offset, controlPoint.y, true);
                    offset += 2;
                });
            }
            break;
        case "drawQuadraticBezierCurves":
        case "drawCubicBezierCurves":
            {
                const { controlPoints } = command;
                const curveType = command.type == "drawCubicBezierCurves" ? "cubic" : "quadratic";
                assertValidPathNumberOfControlPoints(curveType, controlPoints);
                dataView = serializePoints(controlPoints);
            }
            break;
        case "drawPath":
        case "drawClosedPath":
            {
                const { curves } = command;
                assertValidPath(curves);
                const typesDataView = new DataView(new ArrayBuffer(Math.ceil(curves.length / displayCurveTypesPerByte)));
                const controlPointsDataViews = [];
                const allControlPoints = [];
                curves.forEach((curve) => {
                    allControlPoints.push(...curve.controlPoints);
                });
                const pointDataType = getPointDataType(allControlPoints);
                const numberOfControlPoints = allControlPoints.length;
                _console$o.log({ numberOfControlPoints });
                curves.forEach((curve, index) => {
                    const { type, controlPoints } = curve;
                    const typeByteIndex = Math.floor(index / displayCurveTypesPerByte);
                    const typeBitShift = (index % displayCurveTypesPerByte) * displayCurveTypeBitWidth;
                    let typeValue = typesDataView.getUint8(typeByteIndex) || 0;
                    typeValue |= DisplayBezierCurveTypes.indexOf(type) << typeBitShift;
                    typesDataView.setUint8(typeByteIndex, typeValue);
                    const controlPointsDataView = serializePoints(controlPoints, pointDataType, true);
                    controlPointsDataViews.push(controlPointsDataView);
                });
                const controlPointsBuffer = concatenateArrayBuffers(...controlPointsDataViews);
                const headerDataView = new DataView(new ArrayBuffer(3));
                headerDataView.setUint8(0, DisplayPointDataTypes.indexOf(pointDataType));
                headerDataView.setUint8(1, curves.length);
                headerDataView.setUint8(2, numberOfControlPoints);
                dataView = new DataView(concatenateArrayBuffers(headerDataView, typesDataView, controlPointsBuffer));
            }
            break;
        case "drawSegment":
            {
                const { startX, startY, endX, endY } = command;
                dataView = new DataView(new ArrayBuffer(2 * 4));
                dataView.setInt16(0, startX, true);
                dataView.setInt16(2, startY, true);
                dataView.setInt16(4, endX, true);
                dataView.setInt16(6, endY, true);
            }
            break;
        case "drawSegments":
            {
                const { points } = command;
                _console$o.assertRangeWithError("numberOfPoints", points.length, 2, 255);
                dataView = serializePoints(points);
            }
            break;
        case "drawArc":
            {
                let { offsetX, offsetY, radius, isRadians, startAngle, angleOffset } = command;
                startAngle = isRadians ? startAngle : degToRad(startAngle);
                startAngle = normalizeRadians(startAngle);
                angleOffset = isRadians ? angleOffset : degToRad(angleOffset);
                angleOffset = clamp(angleOffset, -twoPi, twoPi);
                angleOffset /= twoPi;
                angleOffset *= (angleOffset > 0 ? Int16Max - 1 : 32769) - 1;
                isRadians = true;
                dataView = new DataView(new ArrayBuffer(2 * 5));
                dataView.setInt16(0, offsetX, true);
                dataView.setInt16(2, offsetY, true);
                dataView.setUint16(4, radius, true);
                dataView.setUint16(6, formatRotation(startAngle, isRadians), true);
                dataView.setInt16(8, angleOffset, true);
            }
            break;
        case "drawArcEllipse":
            {
                let { offsetX, offsetY, radiusX, radiusY, isRadians, startAngle, angleOffset, } = command;
                startAngle = isRadians ? startAngle : degToRad(startAngle);
                startAngle = normalizeRadians(startAngle);
                angleOffset = isRadians ? angleOffset : degToRad(angleOffset);
                angleOffset = clamp(angleOffset, -twoPi, twoPi);
                angleOffset /= twoPi;
                angleOffset *= (angleOffset > 0 ? Int16Max : 32769) - 1;
                isRadians = true;
                dataView = new DataView(new ArrayBuffer(2 * 6));
                dataView.setInt16(0, offsetX, true);
                dataView.setInt16(2, offsetY, true);
                dataView.setUint16(4, radiusX, true);
                dataView.setUint16(6, radiusY, true);
                dataView.setUint16(8, formatRotation(startAngle, isRadians), true);
                dataView.setUint16(10, angleOffset, true);
            }
            break;
        case "drawBitmap":
            {
                const { bitmap, offsetX, offsetY } = command;
                displayManager.assertValidBitmap(bitmap, false);
                dataView = new DataView(new ArrayBuffer(drawBitmapHeaderLength));
                dataView.setInt16(0, offsetX, true);
                dataView.setInt16(2, offsetY, true);
                dataView.setUint16(4, bitmap.width, true);
                dataView.setUint32(6, bitmap.pixels.length, true);
                dataView.setUint8(10, bitmap.numberOfColors);
                const bitmapData = getBitmapData(bitmap);
                dataView.setUint16(11, bitmapData.byteLength, true);
                const buffer = concatenateArrayBuffers(dataView, bitmapData);
                dataView = new DataView(buffer);
            }
            break;
        case "selectSpriteSheet":
            {
                const { spriteSheetIndex } = command;
                dataView = new DataView(new ArrayBuffer(1));
                dataView.setUint8(0, spriteSheetIndex);
            }
            break;
        case "drawSprite":
            {
                const { offsetX, offsetY, spriteIndex, use2Bytes } = command;
                dataView = new DataView(new ArrayBuffer(2 * 2 + (use2Bytes ? 2 : 1)));
                let offset = 0;
                dataView.setInt16(offset, offsetX, true);
                offset += 2;
                dataView.setInt16(offset, offsetY, true);
                offset += 2;
                if (use2Bytes) {
                    dataView.setUint16(offset, spriteIndex, true);
                    offset += 2;
                }
                else {
                    dataView.setUint8(offset++, spriteIndex);
                }
            }
            break;
        case "drawSprites":
            {
                const { offsetX, offsetY, spriteSerializedLines } = command;
                const lineArrayBuffers = [];
                spriteSerializedLines.forEach((spriteLines) => {
                    const subLineArrayBuffers = [];
                    spriteLines.forEach((subSpriteLine) => {
                        const { spriteSheetIndex, spriteIndices, use2Bytes } = subSpriteLine;
                        const subLineSpriteIndicesDataView = new DataView(new ArrayBuffer(spriteIndices.length * (use2Bytes ? 2 : 1)));
                        spriteIndices.forEach((spriteIndex, i) => {
                            if (use2Bytes) {
                                subLineSpriteIndicesDataView.setUint16(i * 2, spriteIndex, true);
                            }
                            else {
                                subLineSpriteIndicesDataView.setUint8(i, spriteIndex);
                            }
                        });
                        const subLineHeaderDataView = new DataView(new ArrayBuffer(2));
                        subLineHeaderDataView.setUint8(0, spriteSheetIndex);
                        subLineHeaderDataView.setUint8(1, spriteIndices.length);
                        subLineArrayBuffers.push(concatenateArrayBuffers(subLineHeaderDataView, subLineSpriteIndicesDataView));
                    });
                    const lineArrayHeaderDataView = new DataView(new ArrayBuffer(2));
                    const concatenatedSubLineArrayBuffers = concatenateArrayBuffers(...subLineArrayBuffers);
                    lineArrayHeaderDataView.setUint16(0, concatenatedSubLineArrayBuffers.byteLength, true);
                    lineArrayBuffers.push(concatenateArrayBuffers(lineArrayHeaderDataView, concatenatedSubLineArrayBuffers));
                });
                const concatenatedLineArrayBuffers = concatenateArrayBuffers(...lineArrayBuffers);
                dataView = new DataView(new ArrayBuffer(2 * 3));
                let offset = 0;
                dataView.setInt16(offset, offsetX, true);
                offset += 2;
                dataView.setInt16(offset, offsetY, true);
                offset += 2;
                dataView.setUint16(offset, concatenatedLineArrayBuffers.byteLength, true);
                offset += 2;
                const buffer = concatenateArrayBuffers(dataView, concatenatedLineArrayBuffers);
                dataView = new DataView(buffer);
            }
            break;
        case "startSprite":
            {
                const { offsetX, offsetY, width, height } = command;
                dataView = new DataView(new ArrayBuffer(2 * 4));
                dataView.setInt16(0, offsetX, true);
                dataView.setInt16(2, offsetY, true);
                dataView.setUint16(4, width, true);
                dataView.setUint16(6, height, true);
            }
            break;
    }
    return dataView;
}
function serializeContextCommands(displayManager, commands) {
    const serializedContextCommandArray = commands
        .filter((command) => !command.hide)
        .map((command) => {
        const displayContextCommandEnum = DisplayContextCommandTypes.indexOf(command.type);
        const serializedContextCommand = serializeContextCommand(displayManager, command);
        return concatenateArrayBuffers(UInt8ByteBuffer(displayContextCommandEnum), serializedContextCommand);
    });
    const serializedContextCommands = concatenateArrayBuffers(serializedContextCommandArray);
    _console$o.log("serializedContextCommands", commands, serializedContextCommandArray, serializedContextCommands);
    return serializedContextCommands;
}
const DrawDisplayContextCommandTypes = [
    "drawRect",
    "drawRoundRect",
    "drawCircle",
    "drawArc",
    "drawEllipse",
    "drawArcEllipse",
    "drawSegment",
    "drawSegments",
    "drawRegularPolygon",
    "drawPolygon",
    "drawWireframe",
    "drawQuadraticBezierCurve",
    "drawQuadraticBezierCurves",
    "drawCubicBezierCurve",
    "drawCubicBezierCurves",
    "drawPath",
    "drawClosedPath",
    "drawBitmap",
    "drawSprite",
    "drawSprites",
];
const StateDisplayContextCommandTypes = [
    "setColor",
    "setColorOpacity",
    "setOpacity",
    "saveContext",
    "restoreContext",
    "selectBackgroundColor",
    "selectFillColor",
    "selectLineColor",
    "setIgnoreFill",
    "setIgnoreLine",
    "setFillBackground",
    "setLineWidth",
    "setRotation",
    "clearRotation",
    "setHorizontalAlignment",
    "setVerticalAlignment",
    "resetAlignment",
    "setSegmentStartCap",
    "setSegmentEndCap",
    "setSegmentCap",
    "setSegmentStartRadius",
    "setSegmentEndRadius",
    "setSegmentRadius",
    "setCropTop",
    "setCropRight",
    "setCropBottom",
    "setCropLeft",
    "clearCrop",
    "setRotationCropTop",
    "setRotationCropRight",
    "setRotationCropBottom",
    "setRotationCropLeft",
    "clearRotationCrop",
    "selectBitmapColor",
    "selectBitmapColors",
    "setBitmapScaleX",
    "setBitmapScaleY",
    "setBitmapScale",
    "resetBitmapScale",
    "selectSpriteColor",
    "selectSpriteColors",
    "resetSpriteColors",
    "setSpriteScaleX",
    "setSpriteScaleY",
    "setSpriteScale",
    "resetSpriteScale",
    "setSpritesLineHeight",
    "setSpritesDirection",
    "setSpritesLineDirection",
    "setSpritesSpacing",
    "setSpritesLineSpacing",
    "setSpritesAlignment",
    "setSpritesLineAlignment",
    "selectSpriteSheet",
];
const SpritesDisplayContextCommandTypes = [
    "selectSpriteColor",
    "selectSpriteColors",
    "resetSpriteColors",
    "setSpriteScaleX",
    "setSpriteScaleY",
    "setSpriteScale",
    "resetSpriteScale",
    "setSpritesLineHeight",
    "setSpritesDirection",
    "setSpritesLineDirection",
    "setSpritesSpacing",
    "setSpritesLineSpacing",
    "setSpritesAlignment",
    "setSpritesLineAlignment",
    "selectSpriteSheet",
];
const PathDrawDisplayContextCommandTypes = [
    "drawSegment",
    "drawSegments",
    "drawQuadraticBezierCurve",
    "drawQuadraticBezierCurves",
    "drawCubicBezierCurve",
    "drawCubicBezierCurves",
    "drawPath",
    "drawWireframe",
];
const PathStateDisplayContextCommandTypes = [
    "setSegmentRadius",
    "setSegmentEndRadius",
    "setSegmentStartRadius",
    "setSegmentCap",
    "setSegmentStartCap",
    "setSegmentEndCap",
];
const BitmapDisplayContextCommandTypes = [
    "selectBitmapColor",
    "selectBitmapColors",
    "setBitmapScaleX",
    "setBitmapScaleY",
    "setBitmapScale",
    "resetBitmapScale",
];
const contextCommandDependencies = new Map();
function appendContextCommandDependencyPair(key, value) {
    contextCommandDependencies.set(new Set(key), new Set(value));
}
appendContextCommandDependencyPair([...PathStateDisplayContextCommandTypes], [...PathDrawDisplayContextCommandTypes]);
appendContextCommandDependencyPair([...StateDisplayContextCommandTypes], [...DrawDisplayContextCommandTypes]);
appendContextCommandDependencyPair([...SpritesDisplayContextCommandTypes], ["drawSprite", "drawSprites"]);
appendContextCommandDependencyPair([...BitmapDisplayContextCommandTypes], ["drawBitmap"]);
function trimContextCommands(commands) {
    _console$o.log("trimming commands", commands);
    const trimmedCommands = [];
    commands
        .slice()
        .reverse()
        .forEach((command) => {
        let include = true;
        let dependencies;
        for (const [keys, values] of contextCommandDependencies) {
            if (keys.has(command.type)) {
                dependencies = values;
                break;
            }
        }
        if (dependencies) {
            const similarCommandIndex = trimmedCommands.findIndex((trimmedCommand) => {
                return trimmedCommand.type == command.type;
            });
            const dependentCommandIndex = trimmedCommands.findIndex((trimmedCommand) => dependencies.has(trimmedCommand.type));
            if (dependentCommandIndex == -1) {
                include = false;
            }
            else if (similarCommandIndex != -1) {
                include = similarCommandIndex > dependentCommandIndex;
            }
        }
        if (include) {
            trimmedCommands.unshift(command);
        }
    });
    _console$o.log("trimmedCommands", trimmedCommands);
    return trimmedCommands;
}

if (!String.prototype.codePointAt) {
	(function() {
		var defineProperty = (function() {
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var codePointAt = function(position) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			var size = string.length;
			var index = position ? Number(position) : 0;
			if (index != index) {
				index = 0;
			}
			if (index < 0 || index >= size) {
				return undefined;
			}
			var first = string.charCodeAt(index);
			var second;
			if (
				first >= 0xD800 && first <= 0xDBFF &&
				size > index + 1
			) {
				second = string.charCodeAt(index + 1);
				if (second >= 0xDC00 && second <= 0xDFFF) {
					return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
				}
			}
			return first;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'codePointAt', {
				'value': codePointAt,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.codePointAt = codePointAt;
		}
	}());
}
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;
function Tree() {
  this.table = new Uint16Array(16);
  this.trans = new Uint16Array(288);
}
function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  this.dest = dest;
  this.destLen = 0;
  this.ltree = new Tree();
  this.dtree = new Tree();
}
var sltree = new Tree();
var sdtree = new Tree();
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);
var clcidx = new Uint8Array([
  16, 17, 18, 0, 8, 7, 9, 6,
  10, 5, 11, 4, 12, 3, 13, 2,
  14, 1, 15
]);
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;
  for (i = 0; i < delta; ++i) { bits[i] = 0; }
  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}
function tinf_build_fixed_trees(lt, dt) {
  var i;
  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }
  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;
  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }
  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }
  dt.table[5] = 32;
  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
}
var offs = new Uint16Array(16);
function tinf_build_tree(t, lengths, off, num) {
  var i, sum;
  for (i = 0; i < 16; ++i) { t.table[i] = 0; }
  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }
  t.table[0] = 0;
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }
  for (i = 0; i < num; ++i) {
    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
  }
}
function tinf_getbit(d) {
  if (!d.bitcount--) {
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }
  var bit = d.tag & 1;
  d.tag >>>= 1;
  return bit;
}
function tinf_read_bits(d, num, base) {
  if (!num)
    { return base; }
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var val = d.tag & (0xffff >>> (16 - num));
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;
    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  d.tag = tag;
  d.bitcount -= len;
  return t.trans[sum + cur];
}
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;
  hlit = tinf_read_bits(d, 5, 257);
  hdist = tinf_read_bits(d, 5, 1);
  hclen = tinf_read_bits(d, 4, 4);
  for (i = 0; i < 19; ++i) { lengths[i] = 0; }
  for (i = 0; i < hclen; ++i) {
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }
  tinf_build_tree(code_tree, lengths, 0, 19);
  for (num = 0; num < hlit + hdist;) {
    var sym = tinf_decode_symbol(d, code_tree);
    switch (sym) {
      case 16:
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        lengths[num++] = sym;
        break;
    }
  }
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);
    if (sym === 256) {
      return TINF_OK;
    }
    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs;
      var i;
      sym -= 257;
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
      dist = tinf_decode_symbol(d, dt);
      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
      for (i = offs; i < offs + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
  if (length !== (~invlength & 0x0000ffff))
    { return TINF_DATA_ERROR; }
  d.sourceIndex += 4;
  for (i = length; i; --i)
    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }
  d.bitcount = 0;
  return TINF_OK;
}
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;
  do {
    bfinal = tinf_getbit(d);
    btype = tinf_read_bits(d, 2, 0);
    switch (btype) {
      case 0:
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }
    if (res !== TINF_OK)
      { throw new Error('Data error'); }
  } while (!bfinal);
  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === 'function')
      { return d.dest.slice(0, d.destLen); }
    else
      { return d.dest.subarray(0, d.destLen); }
  }
  return d.dest;
}
tinf_build_fixed_trees(sltree, sdtree);
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);
length_bits[28] = 0;
length_base[28] = 258;
var tinyInflate = tinf_uncompress;
function derive(v0, v1, v2, v3, t) {
    return Math.pow(1 - t, 3) * v0 +
        3 * Math.pow(1 - t, 2) * t * v1 +
        3 * (1 - t) * Math.pow(t, 2) * v2 +
        Math.pow(t, 3) * v3;
}
function BoundingBox() {
    this.x1 = Number.NaN;
    this.y1 = Number.NaN;
    this.x2 = Number.NaN;
    this.y2 = Number.NaN;
}
BoundingBox.prototype.isEmpty = function() {
    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};
BoundingBox.prototype.addPoint = function(x, y) {
    if (typeof x === 'number') {
        if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x;
            this.x2 = x;
        }
        if (x < this.x1) {
            this.x1 = x;
        }
        if (x > this.x2) {
            this.x2 = x;
        }
    }
    if (typeof y === 'number') {
        if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y;
            this.y2 = y;
        }
        if (y < this.y1) {
            this.y1 = y;
        }
        if (y > this.y2) {
            this.y2 = y;
        }
    }
};
BoundingBox.prototype.addX = function(x) {
    this.addPoint(x, null);
};
BoundingBox.prototype.addY = function(y) {
    this.addPoint(null, y);
};
BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
    var p0 = [x0, y0];
    var p1 = [x1, y1];
    var p2 = [x2, y2];
    var p3 = [x, y];
    this.addPoint(x0, y0);
    this.addPoint(x, y);
    for (var i = 0; i <= 1; i++) {
        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        var c = 3 * p1[i] - 3 * p0[i];
        if (a === 0) {
            if (b === 0) { continue; }
            var t = -c / b;
            if (0 < t && t < 1) {
                if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
                if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
            }
            continue;
        }
        var b2ac = Math.pow(b, 2) - 4 * c * a;
        if (b2ac < 0) { continue; }
        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
        if (0 < t1 && t1 < 1) {
            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
        }
        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
        if (0 < t2 && t2 < 1) {
            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
        }
    }
};
BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
    var cp1x = x0 + 2 / 3 * (x1 - x0);
    var cp1y = y0 + 2 / 3 * (y1 - y0);
    var cp2x = cp1x + 1 / 3 * (x - x0);
    var cp2y = cp1y + 1 / 3 * (y - y0);
    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}
Path.prototype.moveTo = function(x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};
Path.prototype.lineTo = function(x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};
Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};
Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};
Path.prototype.close = Path.prototype.closePath = function() {
    this.commands.push({
        type: 'Z'
    });
};
Path.prototype.extend = function(pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    } else if (pathOrCommands instanceof BoundingBox) {
        var box = pathOrCommands;
        this.moveTo(box.x1, box.y1);
        this.lineTo(box.x2, box.y1);
        this.lineTo(box.x2, box.y2);
        this.lineTo(box.x1, box.y2);
        this.close();
        return;
    }
    Array.prototype.push.apply(this.commands, pathOrCommands);
};
Path.prototype.getBoundingBox = function() {
    var box = new BoundingBox();
    var startX = 0;
    var startY = 0;
    var prevX = 0;
    var prevY = 0;
    for (var i = 0; i < this.commands.length; i++) {
        var cmd = this.commands[i];
        switch (cmd.type) {
            case 'M':
                box.addPoint(cmd.x, cmd.y);
                startX = prevX = cmd.x;
                startY = prevY = cmd.y;
                break;
            case 'L':
                box.addPoint(cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Q':
                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'C':
                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Z':
                prevX = startX;
                prevY = startY;
                break;
            default:
                throw new Error('Unexpected path command ' + cmd.type);
        }
    }
    if (box.isEmpty()) {
        box.addPoint(0, 0);
    }
    return box;
};
Path.prototype.draw = function(ctx) {
    ctx.beginPath();
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }
    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }
    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};
Path.prototype.toPathData = function(decimalPlaces) {
    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;
    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }
    function packValues() {
        var arguments$1 = arguments;
        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments$1[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }
            s += floatToString(v);
        }
        return s;
    }
    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }
    return d;
};
Path.prototype.toSVG = function(decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill && this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }
    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }
    svg += '/>';
    return svg;
};
Path.prototype.toDOMElement = function(decimalPlaces) {
    var temporaryPath = this.toPathData(decimalPlaces);
    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    newPath.setAttribute('d', temporaryPath);
    return newPath;
};
function fail(message) {
    throw new Error(message);
}
function argument(predicate, message) {
    if (!predicate) {
        fail(message);
    }
}
var check = { fail: fail, argument: argument, assert: argument };
var LIMIT16 = 32768;
var LIMIT32 = 2147483648;
var decode$1 = {};
var encode$1 = {};
var sizeOf = {};
function constant(v) {
    return function() {
        return v;
    };
}
encode$1.BYTE = function(v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};
sizeOf.BYTE = constant(1);
encode$1.CHAR = function(v) {
    return [v.charCodeAt(0)];
};
sizeOf.CHAR = constant(1);
encode$1.CHARARRAY = function(v) {
    if (typeof v === 'undefined') {
        v = '';
        console.warn('Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.');
    }
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b[i] = v.charCodeAt(i);
    }
    return b;
};
sizeOf.CHARARRAY = function(v) {
    if (typeof v === 'undefined') {
        return 0;
    }
    return v.length;
};
encode$1.USHORT = function(v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};
sizeOf.USHORT = constant(2);
encode$1.SHORT = function(v) {
    if (v >= LIMIT16) {
        v = -(2 * LIMIT16 - v);
    }
    return [(v >> 8) & 0xFF, v & 0xFF];
};
sizeOf.SHORT = constant(2);
encode$1.UINT24 = function(v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};
sizeOf.UINT24 = constant(3);
encode$1.ULONG = function(v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};
sizeOf.ULONG = constant(4);
encode$1.LONG = function(v) {
    if (v >= LIMIT32) {
        v = -(2 * LIMIT32 - v);
    }
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};
sizeOf.LONG = constant(4);
encode$1.FIXED = encode$1.ULONG;
sizeOf.FIXED = sizeOf.ULONG;
encode$1.FWORD = encode$1.SHORT;
sizeOf.FWORD = sizeOf.SHORT;
encode$1.UFWORD = encode$1.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;
encode$1.LONGDATETIME = function(v) {
    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};
sizeOf.LONGDATETIME = constant(8);
encode$1.TAG = function(v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};
sizeOf.TAG = constant(4);
encode$1.Card8 = encode$1.BYTE;
sizeOf.Card8 = sizeOf.BYTE;
encode$1.Card16 = encode$1.USHORT;
sizeOf.Card16 = sizeOf.USHORT;
encode$1.OffSize = encode$1.BYTE;
sizeOf.OffSize = sizeOf.BYTE;
encode$1.SID = encode$1.USHORT;
sizeOf.SID = sizeOf.USHORT;
encode$1.NUMBER = function(v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode$1.NUMBER16(v);
    } else {
        return encode$1.NUMBER32(v);
    }
};
sizeOf.NUMBER = function(v) {
    return encode$1.NUMBER(v).length;
};
encode$1.NUMBER16 = function(v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};
sizeOf.NUMBER16 = constant(3);
encode$1.NUMBER32 = function(v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};
sizeOf.NUMBER32 = constant(5);
encode$1.REAL = function(v) {
    var value = v.toString();
    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
    if (m) {
        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(v * epsilon) / epsilon).toString();
    }
    var nibbles = '';
    for (var i = 0, ii = value.length; i < ii; i += 1) {
        var c = value[i];
        if (c === 'e') {
            nibbles += value[++i] === '-' ? 'c' : 'b';
        } else if (c === '.') {
            nibbles += 'a';
        } else if (c === '-') {
            nibbles += 'e';
        } else {
            nibbles += c;
        }
    }
    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
    var out = [30];
    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
        out.push(parseInt(nibbles.substr(i$1, 2), 16));
    }
    return out;
};
sizeOf.REAL = function(v) {
    return encode$1.REAL(v).length;
};
encode$1.NAME = encode$1.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;
encode$1.STRING = encode$1.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;
decode$1.UTF8 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes;
    for (var j = 0; j < numChars; j++, offset += 1) {
        codePoints[j] = data.getUint8(offset);
    }
    return String.fromCharCode.apply(null, codePoints);
};
decode$1.UTF16 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes / 2;
    for (var j = 0; j < numChars; j++, offset += 2) {
        codePoints[j] = data.getUint16(offset);
    }
    return String.fromCharCode.apply(null, codePoints);
};
encode$1.UTF16 = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        var codepoint = v.charCodeAt(i);
        b[b.length] = (codepoint >> 8) & 0xFF;
        b[b.length] = codepoint & 0xFF;
    }
    return b;
};
sizeOf.UTF16 = function(v) {
    return v.length * 2;
};
var eightBitMacEncodings = {
    'x-mac-croatian':
    '' +
    '',
    'x-mac-cyrillic':
    '' +
    '',
    'x-mac-gaelic':
    '' +
    '',
    'x-mac-greek':
    '' +
    '\u00AD',
    'x-mac-icelandic':
    '' +
    '',
    'x-mac-inuit':
    '' +
    '',
    'x-mac-ce':
    '' +
    '',
    macintosh:
    '' +
    '',
    'x-mac-romanian':
    '' +
    '',
    'x-mac-turkish':
    '' +
    ''
};
decode$1.MACSTRING = function(dataView, offset, dataLength, encoding) {
    var table = eightBitMacEncodings[encoding];
    if (table === undefined) {
        return undefined;
    }
    var result = '';
    for (var i = 0; i < dataLength; i++) {
        var c = dataView.getUint8(offset + i);
        if (c <= 0x7F) {
            result += String.fromCharCode(c);
        } else {
            result += table[c & 0x7F];
        }
    }
    return result;
};
var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
var macEncodingCacheKeys;
var getMacEncodingTable = function (encoding) {
    if (!macEncodingCacheKeys) {
        macEncodingCacheKeys = {};
        for (var e in eightBitMacEncodings) {
            macEncodingCacheKeys[e] = new String(e);
        }
    }
    var cacheKey = macEncodingCacheKeys[encoding];
    if (cacheKey === undefined) {
        return undefined;
    }
    if (macEncodingTableCache) {
        var cachedTable = macEncodingTableCache.get(cacheKey);
        if (cachedTable !== undefined) {
            return cachedTable;
        }
    }
    var decodingTable = eightBitMacEncodings[encoding];
    if (decodingTable === undefined) {
        return undefined;
    }
    var encodingTable = {};
    for (var i = 0; i < decodingTable.length; i++) {
        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
    }
    if (macEncodingTableCache) {
        macEncodingTableCache.set(cacheKey, encodingTable);
    }
    return encodingTable;
};
encode$1.MACSTRING = function(str, encoding) {
    var table = getMacEncodingTable(encoding);
    if (table === undefined) {
        return undefined;
    }
    var result = [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c >= 0x80) {
            c = table[c];
            if (c === undefined) {
                return undefined;
            }
        }
        result[i] = c;
    }
    return result;
};
sizeOf.MACSTRING = function(str, encoding) {
    var b = encode$1.MACSTRING(str, encoding);
    if (b !== undefined) {
        return b.length;
    } else {
        return 0;
    }
};
function isByteEncodable(value) {
    return value >= -128 && value <= 127;
}
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
        ++pos;
        ++runLength;
    }
    result.push(0x80 | (runLength - 1));
    return pos;
}
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];
        if (!isByteEncodable(value)) {
            break;
        }
        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
            break;
        }
        ++pos;
        ++runLength;
    }
    result.push(runLength - 1);
    for (var i = offset; i < pos; ++i) {
        result.push((deltas[i] + 256) & 0xff);
    }
    return pos;
}
function encodeVarDeltaRunAsWords(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];
        if (value === 0) {
            break;
        }
        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
            break;
        }
        ++pos;
        ++runLength;
    }
    result.push(0x40 | (runLength - 1));
    for (var i = offset; i < pos; ++i) {
        var val = deltas[i];
        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
    }
    return pos;
}
encode$1.VARDELTAS = function(deltas) {
    var pos = 0;
    var result = [];
    while (pos < deltas.length) {
        var value = deltas[pos];
        if (value === 0) {
            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
        } else if (value >= -128 && value <= 127) {
            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
        } else {
            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
        }
    }
    return result;
};
encode$1.INDEX = function(l) {
    var offset = 1;
    var offsets = [offset];
    var data = [];
    for (var i = 0; i < l.length; i += 1) {
        var v = encode$1.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        offset += v.length;
        offsets.push(offset);
    }
    if (data.length === 0) {
        return [0, 0];
    }
    var encodedOffsets = [];
    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
    var offsetEncoder = [undefined, encode$1.BYTE, encode$1.USHORT, encode$1.UINT24, encode$1.ULONG][offSize];
    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
        var encodedOffset = offsetEncoder(offsets[i$1]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }
    return Array.prototype.concat(encode$1.Card16(l.length),
                           encode$1.OffSize(offSize),
                           encodedOffsets,
                           data);
};
sizeOf.INDEX = function(v) {
    return encode$1.INDEX(v).length;
};
encode$1.DICT = function(m) {
    var d = [];
    var keys = Object.keys(m);
    var length = keys.length;
    for (var i = 0; i < length; i += 1) {
        var k = parseInt(keys[i], 0);
        var v = m[k];
        d = d.concat(encode$1.OPERAND(v.value, v.type));
        d = d.concat(encode$1.OPERATOR(k));
    }
    return d;
};
sizeOf.DICT = function(m) {
    return encode$1.DICT(m).length;
};
encode$1.OPERATOR = function(v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};
encode$1.OPERAND = function(v, type) {
    var d = [];
    if (Array.isArray(type)) {
        for (var i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode$1.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode$1.NUMBER(v));
        } else if (type === 'offset') {
            d = d.concat(encode$1.NUMBER32(v));
        } else if (type === 'number') {
            d = d.concat(encode$1.NUMBER(v));
        } else if (type === 'real') {
            d = d.concat(encode$1.REAL(v));
        } else {
            throw new Error('Unknown operand type ' + type);
        }
    }
    return d;
};
encode$1.OP = encode$1.BYTE;
sizeOf.OP = sizeOf.BYTE;
var wmm = typeof WeakMap === 'function' && new WeakMap();
encode$1.CHARSTRING = function(ops) {
    if (wmm) {
        var cachedValue = wmm.get(ops);
        if (cachedValue !== undefined) {
            return cachedValue;
        }
    }
    var d = [];
    var length = ops.length;
    for (var i = 0; i < length; i += 1) {
        var op = ops[i];
        d = d.concat(encode$1[op.type](op.value));
    }
    if (wmm) {
        wmm.set(ops, d);
    }
    return d;
};
sizeOf.CHARSTRING = function(ops) {
    return encode$1.CHARSTRING(ops).length;
};
encode$1.OBJECT = function(v) {
    var encodingFunction = encode$1[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};
sizeOf.OBJECT = function(v) {
    var sizeOfFunction = sizeOf[v.type];
    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
    return sizeOfFunction(v.value);
};
encode$1.TABLE = function(table) {
    var d = [];
    var length = table.fields.length;
    var subtables = [];
    var subtableOffsets = [];
    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode$1[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }
        var bytes = encodingFunction(value);
        if (field.type === 'TABLE') {
            subtableOffsets.push(d.length);
            d = d.concat([0, 0]);
            subtables.push(bytes);
        } else {
            d = d.concat(bytes);
        }
    }
    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
        var o = subtableOffsets[i$1];
        var offset = d.length;
        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
        d[o] = offset >> 8;
        d[o + 1] = offset & 0xff;
        d = d.concat(subtables[i$1]);
    }
    return d;
};
sizeOf.TABLE = function(table) {
    var numBytes = 0;
    var length = table.fields.length;
    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var sizeOfFunction = sizeOf[field.type];
        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }
        numBytes += sizeOfFunction(value);
        if (field.type === 'TABLE') {
            numBytes += 2;
        }
    }
    return numBytes;
};
encode$1.RECORD = encode$1.TABLE;
sizeOf.RECORD = sizeOf.TABLE;
encode$1.LITERAL = function(v) {
    return v;
};
sizeOf.LITERAL = function(v) {
    return v.length;
};
function Table(tableName, fields, options) {
    if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {
        for (var i = 0; i < fields.length; i += 1) {
            var field = fields[i];
            this[field.name] = field.value;
        }
    }
    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
            var k = optionKeys[i$1];
            var v = options[k];
            if (this[k] !== undefined) {
                this[k] = v;
            }
        }
    }
}
Table.prototype.encode = function() {
    return encode$1.TABLE(this);
};
Table.prototype.sizeOf = function() {
    return sizeOf.TABLE(this);
};
function ushortList(itemName, list, count) {
    if (count === undefined) {
        count = list.length;
    }
    var fields = new Array(list.length + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < list.length; i++) {
        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
    }
    return fields;
}
function tableList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = new Array(count + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
    }
    return fields;
}
function recordList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = [];
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields = fields.concat(itemCallback(records[i], i));
    }
    return fields;
}
function Coverage(coverageTable) {
    if (coverageTable.format === 1) {
        Table.call(this, 'coverageTable',
            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
            .concat(ushortList('glyph', coverageTable.glyphs))
        );
    } else if (coverageTable.format === 2) {
        Table.call(this, 'coverageTable',
            [{name: 'coverageFormat', type: 'USHORT', value: 2}]
            .concat(recordList('rangeRecord', coverageTable.ranges, function(RangeRecord) {
                return [
                    {name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start},
                    {name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end},
                    {name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index} ];
            }))
        );
    } else {
        check.assert(false, 'Coverage format must be 1 or 2.');
    }
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;
function ScriptList(scriptListTable) {
    Table.call(this, 'scriptListTable',
        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
            var script = scriptRecord.script;
            var defaultLangSys = script.defaultLangSys;
            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
            return [
                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
                        {name: 'lookupOrder', type: 'USHORT', value: 0},
                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
                        var langSys = langSysRecord.langSys;
                        return [
                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
                                {name: 'lookupOrder', type: 'USHORT', value: 0},
                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
                        ];
                    })))}
            ];
        })
    );
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;
function FeatureList(featureListTable) {
    Table.call(this, 'featureListTable',
        recordList('featureRecord', featureListTable, function(featureRecord, i) {
            var feature = featureRecord.feature;
            return [
                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
            ];
        })
    );
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;
function LookupList(lookupListTable, subtableMakers) {
    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
        var subtableCallback = subtableMakers[lookupTable.lookupType];
        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
        return new Table('lookupTable', [
            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
    }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;
var table = {
    Table: Table,
    Record: Table,
    Coverage: Coverage,
    ScriptList: ScriptList,
    FeatureList: FeatureList,
    LookupList: LookupList,
    ushortList: ushortList,
    tableList: tableList,
    recordList: recordList,
};
function getByte(dataView, offset) {
    return dataView.getUint8(offset);
}
function getUShort(dataView, offset) {
    return dataView.getUint16(offset, false);
}
function getShort(dataView, offset) {
    return dataView.getInt16(offset, false);
}
function getULong(dataView, offset) {
    return dataView.getUint32(offset, false);
}
function getFixed(dataView, offset) {
    var decimal = dataView.getInt16(offset, false);
    var fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
}
function getTag(dataView, offset) {
    var tag = '';
    for (var i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }
    return tag;
}
function getOffset(dataView, offset, offSize) {
    var v = 0;
    for (var i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }
    return v;
}
function getBytes(dataView, startOffset, endOffset) {
    var bytes = [];
    for (var i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }
    return bytes;
}
function bytesToString(bytes) {
    var s = '';
    for (var i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }
    return s;
}
var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}
Parser.prototype.parseByte = function() {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};
Parser.prototype.parseChar = function() {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};
Parser.prototype.parseCard8 = Parser.prototype.parseByte;
Parser.prototype.parseUShort = function() {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;
Parser.prototype.parseShort = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseF2Dot14 = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseULong = function() {
    var v = getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};
Parser.prototype.parseOffset32 = Parser.prototype.parseULong;
Parser.prototype.parseFixed = function() {
    var v = getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};
Parser.prototype.parseString = function(length) {
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    var string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }
    return string;
};
Parser.prototype.parseTag = function() {
    return this.parseString(4);
};
Parser.prototype.parseLongDateTime = function() {
    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
    v -= 2082844800;
    this.relativeOffset += 8;
    return v;
};
Parser.prototype.parseVersion = function(minorBase) {
    var major = getUShort(this.data, this.offset + this.relativeOffset);
    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    if (minorBase === undefined) { minorBase = 0x1000; }
    return major + minor / minorBase / 10;
};
Parser.prototype.skip = function(type, amount) {
    if (amount === undefined) {
        amount = 1;
    }
    this.relativeOffset += typeOffsets[type] * amount;
};
Parser.prototype.parseULongList = function(count) {
    if (count === undefined) { count = this.parseULong(); }
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = dataView.getUint32(offset);
        offset += 4;
    }
    this.relativeOffset += count * 4;
    return offsets;
};
Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function(count) {
    if (count === undefined) { count = this.parseUShort(); }
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = dataView.getUint16(offset);
        offset += 2;
    }
    this.relativeOffset += count * 2;
    return offsets;
};
Parser.prototype.parseShortList = function(count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getInt16(offset);
        offset += 2;
    }
    this.relativeOffset += count * 2;
    return list;
};
Parser.prototype.parseByteList = function(count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getUint8(offset++);
    }
    this.relativeOffset += count;
    return list;
};
Parser.prototype.parseList = function(count, itemCallback) {
    if (!itemCallback) {
        itemCallback = count;
        count = this.parseUShort();
    }
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        list[i] = itemCallback.call(this);
    }
    return list;
};
Parser.prototype.parseList32 = function(count, itemCallback) {
    if (!itemCallback) {
        itemCallback = count;
        count = this.parseULong();
    }
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        list[i] = itemCallback.call(this);
    }
    return list;
};
Parser.prototype.parseRecordList = function(count, recordDescription) {
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseUShort();
    }
    var records = new Array(count);
    var fields = Object.keys(recordDescription);
    for (var i = 0; i < count; i++) {
        var rec = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this);
        }
        records[i] = rec;
    }
    return records;
};
Parser.prototype.parseRecordList32 = function(count, recordDescription) {
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseULong();
    }
    var records = new Array(count);
    var fields = Object.keys(recordDescription);
    for (var i = 0; i < count; i++) {
        var rec = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this);
        }
        records[i] = rec;
    }
    return records;
};
Parser.prototype.parseStruct = function(description) {
    if (typeof description === 'function') {
        return description.call(this);
    } else {
        var fields = Object.keys(description);
        var struct = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = description[fieldName];
            struct[fieldName] = fieldType.call(this);
        }
        return struct;
    }
};
Parser.prototype.parseValueRecord = function(valueFormat) {
    if (valueFormat === undefined) {
        valueFormat = this.parseUShort();
    }
    if (valueFormat === 0) {
        return;
    }
    var valueRecord = {};
    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }
    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }
    return valueRecord;
};
Parser.prototype.parseValueRecordList = function() {
    var valueFormat = this.parseUShort();
    var valueCount = this.parseUShort();
    var values = new Array(valueCount);
    for (var i = 0; i < valueCount; i++) {
        values[i] = this.parseValueRecord(valueFormat);
    }
    return values;
};
Parser.prototype.parsePointer = function(description) {
    var structOffset = this.parseOffset16();
    if (structOffset > 0) {
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    }
    return undefined;
};
Parser.prototype.parsePointer32 = function(description) {
    var structOffset = this.parseOffset32();
    if (structOffset > 0) {
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    }
    return undefined;
};
Parser.prototype.parseListOfLists = function(itemCallback) {
    var offsets = this.parseOffset16List();
    var count = offsets.length;
    var relativeOffset = this.relativeOffset;
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        var start = offsets[i];
        if (start === 0) {
            list[i] = undefined;
            continue;
        }
        this.relativeOffset = start;
        if (itemCallback) {
            var subOffsets = this.parseOffset16List();
            var subList = new Array(subOffsets.length);
            for (var j = 0; j < subOffsets.length; j++) {
                this.relativeOffset = start + subOffsets[j];
                subList[j] = itemCallback.call(this);
            }
            list[i] = subList;
        } else {
            list[i] = this.parseUShortList();
        }
    }
    this.relativeOffset = relativeOffset;
    return list;
};
Parser.prototype.parseCoverage = function() {
    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    var count = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            glyphs: this.parseUShortList(count)
        };
    } else if (format === 2) {
        var ranges = new Array(count);
        for (var i = 0; i < count; i++) {
            ranges[i] = {
                start: this.parseUShort(),
                end: this.parseUShort(),
                index: this.parseUShort()
            };
        }
        return {
            format: 2,
            ranges: ranges
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
};
Parser.prototype.parseClassDef = function() {
    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            startGlyph: this.parseUShort(),
            classes: this.parseUShortList()
        };
    } else if (format === 2) {
        return {
            format: 2,
            ranges: this.parseRecordList({
                start: Parser.uShort,
                end: Parser.uShort,
                classId: Parser.uShort
            })
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
};
Parser.list = function(count, itemCallback) {
    return function() {
        return this.parseList(count, itemCallback);
    };
};
Parser.list32 = function(count, itemCallback) {
    return function() {
        return this.parseList32(count, itemCallback);
    };
};
Parser.recordList = function(count, recordDescription) {
    return function() {
        return this.parseRecordList(count, recordDescription);
    };
};
Parser.recordList32 = function(count, recordDescription) {
    return function() {
        return this.parseRecordList32(count, recordDescription);
    };
};
Parser.pointer = function(description) {
    return function() {
        return this.parsePointer(description);
    };
};
Parser.pointer32 = function(description) {
    return function() {
        return this.parsePointer32(description);
    };
};
Parser.tag = Parser.prototype.parseTag;
Parser.byte = Parser.prototype.parseByte;
Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
Parser.uShortList = Parser.prototype.parseUShortList;
Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
Parser.uLongList = Parser.prototype.parseULongList;
Parser.struct = Parser.prototype.parseStruct;
Parser.coverage = Parser.prototype.parseCoverage;
Parser.classDef = Parser.prototype.parseClassDef;
var langSysTable = {
    reserved: Parser.uShort,
    reqFeatureIndex: Parser.uShort,
    featureIndexes: Parser.uShortList
};
Parser.prototype.parseScriptList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        script: Parser.pointer({
            defaultLangSys: Parser.pointer(langSysTable),
            langSysRecords: Parser.recordList({
                tag: Parser.tag,
                langSys: Parser.pointer(langSysTable)
            })
        })
    })) || [];
};
Parser.prototype.parseFeatureList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        feature: Parser.pointer({
            featureParams: Parser.offset16,
            lookupListIndexes: Parser.uShortList
        })
    })) || [];
};
Parser.prototype.parseLookupList = function(lookupTableParsers) {
    return this.parsePointer(Parser.list(Parser.pointer(function() {
        var lookupType = this.parseUShort();
        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
        var lookupFlag = this.parseUShort();
        var useMarkFilteringSet = lookupFlag & 0x10;
        return {
            lookupType: lookupType,
            lookupFlag: lookupFlag,
            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
        };
    }))) || [];
};
Parser.prototype.parseFeatureVariationsList = function() {
    return this.parsePointer32(function() {
        var majorVersion = this.parseUShort();
        var minorVersion = this.parseUShort();
        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
        var featureVariations = this.parseRecordList32({
            conditionSetOffset: Parser.offset32,
            featureTableSubstitutionOffset: Parser.offset32
        });
        return featureVariations;
    }) || [];
};
var parse = {
    getByte: getByte,
    getCard8: getByte,
    getUShort: getUShort,
    getCard16: getUShort,
    getShort: getShort,
    getULong: getULong,
    getFixed: getFixed,
    getTag: getTag,
    getOffset: getOffset,
    getBytes: getBytes,
    bytesToString: bytesToString,
    Parser: Parser,
};
function parseCmapTableFormat12(cmap, p) {
    p.parseUShort();
    cmap.length = p.parseULong();
    cmap.language = p.parseULong();
    var groupCount;
    cmap.groupCount = groupCount = p.parseULong();
    cmap.glyphIndexMap = {};
    for (var i = 0; i < groupCount; i += 1) {
        var startCharCode = p.parseULong();
        var endCharCode = p.parseULong();
        var startGlyphId = p.parseULong();
        for (var c = startCharCode; c <= endCharCode; c += 1) {
            cmap.glyphIndexMap[c] = startGlyphId;
            startGlyphId++;
        }
    }
}
function parseCmapTableFormat4(cmap, p, data, start, offset) {
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();
    var segCount;
    cmap.segCount = segCount = p.parseUShort() >> 1;
    p.skip('uShort', 3);
    cmap.glyphIndexMap = {};
    var endCountParser = new parse.Parser(data, start + offset + 14);
    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
    var glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (var i = 0; i < segCount - 1; i += 1) {
        var glyphIndex = (void 0);
        var endCount = endCountParser.parseUShort();
        var startCount = startCountParser.parseUShort();
        var idDelta = idDeltaParser.parseShort();
        var idRangeOffset = idRangeOffsetParser.parseUShort();
        for (var c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);
                glyphIndexOffset += idRangeOffset;
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }
            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
}
function parseCmapTable(data, start) {
    var cmap = {};
    cmap.version = parse.getUShort(data, start);
    check.argument(cmap.version === 0, 'cmap table version should be 0.');
    cmap.numTables = parse.getUShort(data, start + 2);
    var offset = -1;
    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
        var platformId = parse.getUShort(data, start + 4 + (i * 8));
        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||
            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {
            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }
    if (offset === -1) {
        throw new Error('No valid cmap sub-tables found.');
    }
    var p = new parse.Parser(data, start + offset);
    cmap.format = p.parseUShort();
    if (cmap.format === 12) {
        parseCmapTableFormat12(cmap, p);
    } else if (cmap.format === 4) {
        parseCmapTableFormat4(cmap, p, data, start, offset);
    } else {
        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
    }
    return cmap;
}
function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0,
        glyphIndex: glyphIndex
    });
}
function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}
function makeCmapTable(glyphs) {
    var isPlan0Only = true;
    var i;
    for (i = glyphs.length - 1; i > 0; i -= 1) {
        var g = glyphs.get(i);
        if (g.unicode > 65535) {
            console.log('Adding CMAP format 12 (needed!)');
            isPlan0Only = false;
            break;
        }
    }
    var cmapTable = [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
    ];
    if (!isPlan0Only)
        { cmapTable = cmapTable.concat([
            {name: 'cmap12PlatformID', type: 'USHORT', value: 3},
            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
            {name: 'cmap12Offset', type: 'ULONG', value: 0}
        ]); }
    cmapTable = cmapTable.concat([
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'cmap4Length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    var t = new table.Table('cmap', cmapTable);
    t.segments = [];
    for (i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        for (var j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }
        t.segments = t.segments.sort(function (a, b) {
            return a.start - b.start;
        });
    }
    addTerminatorSegment(t);
    var segCount = t.segments.length;
    var segCountToRemove = 0;
    var endCounts = [];
    var startCounts = [];
    var idDeltas = [];
    var idRangeOffsets = [];
    var glyphIds = [];
    var cmap12Groups = [];
    for (i = 0; i < segCount; i += 1) {
        var segment = t.segments[i];
        if (segment.end <= 65535 && segment.start <= 65535) {
            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
            if (segment.glyphId !== undefined) {
                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
            }
        } else {
            segCountToRemove += 1;
        }
        if (!isPlan0Only && segment.glyphIndex !== undefined) {
            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
        }
    }
    t.segCountX2 = (segCount - segCountToRemove) * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;
    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);
    t.cmap4Length = 14 +
        endCounts.length * 2 +
        2 +
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;
    if (!isPlan0Only) {
        var cmap12Length = 16 +
            cmap12Groups.length * 4;
        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
        t.fields = t.fields.concat([
            {name: 'cmap12Format', type: 'USHORT', value: 12},
            {name: 'cmap12Reserved', type: 'USHORT', value: 0},
            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
            {name: 'cmap12Language', type: 'ULONG', value: 0},
            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
        ]);
        t.fields = t.fields.concat(cmap12Groups);
    }
    return t;
}
var cmap = { parse: parseCmapTable, make: makeCmapTable };
var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];
var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];
var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];
var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];
function DefaultEncoding(font) {
    this.font = font;
}
DefaultEncoding.prototype.charToGlyphIndex = function(c) {
    var code = c.codePointAt(0);
    var glyphs = this.font.glyphs;
    if (glyphs) {
        for (var i = 0; i < glyphs.length; i += 1) {
            var glyph = glyphs.get(i);
            for (var j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    }
    return null;
};
function CmapEncoding(cmap) {
    this.cmap = cmap;
}
CmapEncoding.prototype.charToGlyphIndex = function(c) {
    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
};
function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}
CffEncoding.prototype.charToGlyphIndex = function(s) {
    var code = s.codePointAt(0);
    var charName = this.encoding[code];
    return this.charset.indexOf(charName);
};
function GlyphNames(post) {
    switch (post.version) {
        case 1:
            this.names = standardNames.slice();
            break;
        case 2:
            this.names = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                if (post.glyphNameIndex[i] < standardNames.length) {
                    this.names[i] = standardNames[post.glyphNameIndex[i]];
                } else {
                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
                }
            }
            break;
        case 2.5:
            this.names = new Array(post.numberOfGlyphs);
            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
            }
            break;
        case 3:
            this.names = [];
            break;
        default:
            this.names = [];
            break;
    }
}
GlyphNames.prototype.nameToGlyphIndex = function(name) {
    return this.names.indexOf(name);
};
GlyphNames.prototype.glyphIndexToName = function(gid) {
    return this.names[gid];
};
function addGlyphNamesAll(font) {
    var glyph;
    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
    var charCodes = Object.keys(glyphIndexMap);
    for (var i = 0; i < charCodes.length; i += 1) {
        var c = charCodes[i];
        var glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs.get(glyphIndex);
        glyph.addUnicode(parseInt(c));
    }
    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
        glyph = font.glyphs.get(i$1);
        if (font.cffEncoding) {
            if (font.isCIDFont) {
                glyph.name = 'gid' + i$1;
            } else {
                glyph.name = font.cffEncoding.charset[i$1];
            }
        } else if (font.glyphNames.names) {
            glyph.name = font.glyphNames.glyphIndexToName(i$1);
        }
    }
}
function addGlyphNamesToUnicodeMap(font) {
    font._IndexToUnicodeMap = {};
    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
    var charCodes = Object.keys(glyphIndexMap);
    for (var i = 0; i < charCodes.length; i += 1) {
        var c = charCodes[i];
        var glyphIndex = glyphIndexMap[c];
        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {
            font._IndexToUnicodeMap[glyphIndex] = {
                unicodes: [parseInt(c)]
            };
        } else {
            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));
        }
    }
}
function addGlyphNames(font, opt) {
    if (opt.lowMemory) {
        addGlyphNamesToUnicodeMap(font);
    } else {
        addGlyphNamesAll(font);
    }
}
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}
var draw = { line: line };
function getPathDefinition(glyph, path) {
    var _path = path || new Path();
    return {
        configurable: true,
        get: function() {
            if (typeof _path === 'function') {
                _path = _path();
            }
            return _path;
        },
        set: function(p) {
            _path = p;
        }
    };
}
function Glyph(options) {
    this.bindConstructorValues(options);
}
Glyph.prototype.bindConstructorValues = function(options) {
    this.index = options.index || 0;
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];
    if ('xMin' in options) {
        this.xMin = options.xMin;
    }
    if ('yMin' in options) {
        this.yMin = options.yMin;
    }
    if ('xMax' in options) {
        this.xMax = options.xMax;
    }
    if ('yMax' in options) {
        this.yMax = options.yMax;
    }
    if ('advanceWidth' in options) {
        this.advanceWidth = options.advanceWidth;
    }
    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
};
Glyph.prototype.addUnicode = function(unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }
    this.unicodes.push(unicode);
};
Glyph.prototype.getBoundingBox = function() {
    return this.path.getBoundingBox();
};
Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    var commands;
    var hPoints;
    if (!options) { options = { }; }
    var xScale = options.xScale;
    var yScale = options.yScale;
    if (options.hinting && font && font.hinting) {
        hPoints = this.path && font.hinting.exec(this, fontSize);
    }
    if (hPoints) {
        commands = font.hinting.getCommands(hPoints);
        x = Math.round(x);
        y = Math.round(y);
        xScale = yScale = 1;
    } else {
        commands = this.path.commands;
        var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;
        if (xScale === undefined) { xScale = scale; }
        if (yScale === undefined) { yScale = scale; }
    }
    var p = new Path();
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }
    return p;
};
Glyph.prototype.getContours = function() {
    if (this.points === undefined) {
        return [];
    }
    var contours = [];
    var currentContour = [];
    for (var i = 0; i < this.points.length; i += 1) {
        var pt = this.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};
Glyph.prototype.getMetrics = function() {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }
        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }
        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }
    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: this.leftSideBearing
    };
    if (!isFinite(metrics.xMin)) {
        metrics.xMin = 0;
    }
    if (!isFinite(metrics.xMax)) {
        metrics.xMax = this.advanceWidth;
    }
    if (!isFinite(metrics.yMin)) {
        metrics.yMin = 0;
    }
    if (!isFinite(metrics.yMax)) {
        metrics.yMax = 0;
    }
    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};
Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
    this.getPath(x, y, fontSize, options).draw(ctx);
};
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
    function drawCircles(l, x, y, scale) {
        ctx.beginPath();
        for (var j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, Math.PI * 2, false);
        }
        ctx.closePath();
        ctx.fill();
    }
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    var scale = 1 / this.path.unitsPerEm * fontSize;
    var blueCircles = [];
    var redCircles = [];
    var path = this.path;
    for (var i = 0; i < path.commands.length; i += 1) {
        var cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }
        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }
        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }
    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.path.unitsPerEm * fontSize;
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -1e4, x, 10000);
    draw.line(ctx, -1e4, y, 10000, y);
    var xMin = this.xMin || 0;
    var yMin = this.yMin || 0;
    var xMax = this.xMax || 0;
    var yMax = this.yMax || 0;
    var advanceWidth = this.advanceWidth || 0;
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (xMin * scale), -1e4, x + (xMin * scale), 10000);
    draw.line(ctx, x + (xMax * scale), -1e4, x + (xMax * scale), 10000);
    draw.line(ctx, -1e4, y + (-yMin * scale), 10000, y + (-yMin * scale));
    draw.line(ctx, -1e4, y + (-yMax * scale), 10000, y + (-yMax * scale));
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (advanceWidth * scale), -1e4, x + (advanceWidth * scale), 10000);
};
function defineDependentProperty(glyph, externalName, internalName) {
    Object.defineProperty(glyph, externalName, {
        get: function() {
            glyph.path;
            return glyph[internalName];
        },
        set: function(newValue) {
            glyph[internalName] = newValue;
        },
        enumerable: true,
        configurable: true
    });
}
function GlyphSet(font, glyphs) {
    this.font = font;
    this.glyphs = {};
    if (Array.isArray(glyphs)) {
        for (var i = 0; i < glyphs.length; i++) {
            var glyph = glyphs[i];
            glyph.path.unitsPerEm = font.unitsPerEm;
            this.glyphs[i] = glyph;
        }
    }
    this.length = (glyphs && glyphs.length) || 0;
}
GlyphSet.prototype.get = function(index) {
    if (this.glyphs[index] === undefined) {
        this.font._push(index);
        if (typeof this.glyphs[index] === 'function') {
            this.glyphs[index] = this.glyphs[index]();
        }
        var glyph = this.glyphs[index];
        var unicodeObj = this.font._IndexToUnicodeMap[index];
        if (unicodeObj) {
            for (var j = 0; j < unicodeObj.unicodes.length; j++)
                { glyph.addUnicode(unicodeObj.unicodes[j]); }
        }
        if (this.font.cffEncoding) {
            if (this.font.isCIDFont) {
                glyph.name = 'gid' + index;
            } else {
                glyph.name = this.font.cffEncoding.charset[index];
            }
        } else if (this.font.glyphNames.names) {
            glyph.name = this.font.glyphNames.glyphIndexToName(index);
        }
        this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;
        this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;
    } else {
        if (typeof this.glyphs[index] === 'function') {
            this.glyphs[index] = this.glyphs[index]();
        }
    }
    return this.glyphs[index];
};
GlyphSet.prototype.push = function(index, loader) {
    this.glyphs[index] = loader;
    this.length++;
};
function glyphLoader(font, index) {
    return new Glyph({index: index, font: font});
}
function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
    return function() {
        var glyph = new Glyph({index: index, font: font});
        glyph.path = function() {
            parseGlyph(glyph, data, position);
            var path = buildPath(font.glyphs, glyph);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };
        defineDependentProperty(glyph, 'xMin', '_xMin');
        defineDependentProperty(glyph, 'xMax', '_xMax');
        defineDependentProperty(glyph, 'yMin', '_yMin');
        defineDependentProperty(glyph, 'yMax', '_yMax');
        return glyph;
    };
}
function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
    return function() {
        var glyph = new Glyph({index: index, font: font});
        glyph.path = function() {
            var path = parseCFFCharstring(font, glyph, charstring);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };
        return glyph;
    };
}
var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }
    return bias;
}
function parseCFFIndex(data, start, conversionFn) {
    var offsets = [];
    var objects = [];
    var count = parse.getCard16(data, start);
    var objectOffset;
    var endOffset;
    if (count !== 0) {
        var offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        var pos = start + 3;
        for (var i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }
    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }
        objects.push(value);
    }
    return {objects: objects, startOffset: start, endOffset: endOffset};
}
function parseCFFIndexLowMemory(data, start) {
    var offsets = [];
    var count = parse.getCard16(data, start);
    var objectOffset;
    var endOffset;
    if (count !== 0) {
        var offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        var pos = start + 3;
        for (var i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }
    return {offsets: offsets, startOffset: start, endOffset: endOffset};
}
function getCffIndexObject(i, offsets, data, start, conversionFn) {
    var count = parse.getCard16(data, start);
    var objectOffset = 0;
    if (count !== 0) {
        var offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
    }
    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
    return value;
}
function parseFloatOperand(parser) {
    var s = '';
    var eof = 15;
    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        var b = parser.parseByte();
        var n1 = b >> 4;
        var n2 = b & 15;
        if (n1 === eof) {
            break;
        }
        s += lookup[n1];
        if (n2 === eof) {
            break;
        }
        s += lookup[n2];
    }
    return parseFloat(s);
}
function parseOperand(parser, b0) {
    var b1;
    var b2;
    var b3;
    var b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }
    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }
    if (b0 === 30) {
        return parseFloatOperand(parser);
    }
    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }
    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }
    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }
    throw new Error('Invalid b0 ' + b0);
}
function entriesToObject(entries) {
    var o = {};
    for (var i = 0; i < entries.length; i += 1) {
        var key = entries[i][0];
        var values = entries[i][1];
        var value = (void 0);
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }
        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }
        o[key] = value;
    }
    return o;
}
function parseCFFDict(data, start, size) {
    start = start !== undefined ? start : 0;
    var parser = new parse.Parser(data, start);
    var entries = [];
    var operands = [];
    size = size !== undefined ? size : data.length;
    while (parser.relativeOffset < size) {
        var op = parser.parseByte();
        if (op <= 21) {
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }
            entries.push([op, operands]);
            operands = [];
        } else {
            operands.push(parseOperand(parser, op));
        }
    }
    return entriesToObject(entries);
}
function getCFFString(strings, index) {
    if (index <= 390) {
        index = cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }
    return index;
}
function interpretDict(dict, meta, strings) {
    var newDict = {};
    var value;
    for (var i = 0; i < meta.length; i += 1) {
        var m = meta[i];
        if (Array.isArray(m.type)) {
            var values = [];
            values.length = m.type.length;
            for (var j = 0; j < m.type.length; j++) {
                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
                if (value === undefined) {
                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
                }
                if (m.type[j] === 'SID') {
                    value = getCFFString(strings, value);
                }
                values[j] = value;
            }
            newDict[m.name] = values;
        } else {
            value = dict[m.op];
            if (value === undefined) {
                value = m.value !== undefined ? m.value : null;
            }
            if (m.type === 'SID') {
                value = getCFFString(strings, value);
            }
            newDict[m.name] = value;
        }
    }
    return newDict;
}
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse.getCard8(data, start);
    header.formatMinor = parse.getCard8(data, start + 1);
    header.size = parse.getCard8(data, start + 2);
    header.offsetSize = parse.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}
var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {
        name: 'fontMatrix',
        op: 1207,
        type: ['real', 'real', 'real', 'real', 'real', 'real'],
        value: [0.001, 0, 0, 0.001, 0, 0]
    },
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
    {name: 'uidBase', op: 1235, type: 'number'},
    {name: 'fdArray', op: 1236, type: 'offset'},
    {name: 'fdSelect', op: 1237, type: 'offset'},
    {name: 'fontName', op: 1238, type: 'SID'}
];
var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];
function parseCFFTopDict(data, strings) {
    var dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}
function parseCFFPrivateDict(data, start, size, strings) {
    var dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}
function gatherCFFTopDicts(data, start, cffIndex, strings) {
    var topDictArray = [];
    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
        var topDict = parseCFFTopDict(topDictData, strings);
        topDict._subrs = [];
        topDict._subrsBias = 0;
        topDict._defaultWidthX = 0;
        topDict._nominalWidthX = 0;
        var privateSize = topDict.private[0];
        var privateOffset = topDict.private[1];
        if (privateSize !== 0 && privateOffset !== 0) {
            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
            topDict._defaultWidthX = privateDict.defaultWidthX;
            topDict._nominalWidthX = privateDict.nominalWidthX;
            if (privateDict.subrs !== 0) {
                var subrOffset = privateOffset + privateDict.subrs;
                var subrIndex = parseCFFIndex(data, subrOffset + start);
                topDict._subrs = subrIndex.objects;
                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
            }
            topDict._privateDict = privateDict;
        }
        topDictArray.push(topDict);
    }
    return topDictArray;
}
function parseCFFCharset(data, start, nGlyphs, strings) {
    var sid;
    var count;
    var parser = new parse.Parser(data, start);
    nGlyphs -= 1;
    var charset = ['.notdef'];
    var format = parser.parseCard8();
    if (format === 0) {
        for (var i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }
    return charset;
}
function parseCFFEncoding(data, start, charset) {
    var code;
    var enc = {};
    var parser = new parse.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        var nCodes = parser.parseCard8();
        for (var i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        var nRanges = parser.parseCard8();
        code = 1;
        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
            var first = parser.parseCard8();
            var nLeft = parser.parseCard8();
            for (var j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }
    return new CffEncoding(enc, charset);
}
function parseCFFCharstring(font, glyph, code) {
    var c1x;
    var c1y;
    var c2x;
    var c2y;
    var p = new Path();
    var stack = [];
    var nStems = 0;
    var haveWidth = false;
    var open = false;
    var x = 0;
    var y = 0;
    var subrs;
    var subrsBias;
    var defaultWidthX;
    var nominalWidthX;
    if (font.isCIDFont) {
        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
        subrs = fdDict._subrs;
        subrsBias = fdDict._subrsBias;
        defaultWidthX = fdDict._defaultWidthX;
        nominalWidthX = fdDict._nominalWidthX;
    } else {
        subrs = font.tables.cff.topDict._subrs;
        subrsBias = font.tables.cff.topDict._subrsBias;
        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
    }
    var width = defaultWidthX;
    function newContour(x, y) {
        if (open) {
            p.closePath();
        }
        p.moveTo(x, y);
        open = true;
    }
    function parseStems() {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }
    function parse(code) {
        var b1;
        var b2;
        var b3;
        var b4;
        var codeIndex;
        var subrCode;
        var jpx;
        var jpy;
        var c3x;
        var c3y;
        var c4x;
        var c4y;
        var i = 0;
        while (i < code.length) {
            var v = code[i];
            i += 1;
            switch (v) {
                case 1:
                    parseStems();
                    break;
                case 3:
                    parseStems();
                    break;
                case 4:
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }
                    y += stack.pop();
                    newContour(x, y);
                    break;
                case 5:
                    while (stack.length > 0) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }
                    break;
                case 6:
                    while (stack.length > 0) {
                        x += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }
                        y += stack.shift();
                        p.lineTo(x, y);
                    }
                    break;
                case 7:
                    while (stack.length > 0) {
                        y += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }
                        x += stack.shift();
                        p.lineTo(x, y);
                    }
                    break;
                case 8:
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                case 10:
                    codeIndex = stack.pop() + subrsBias;
                    subrCode = subrs[codeIndex];
                    if (subrCode) {
                        parse(subrCode);
                    }
                    break;
                case 11:
                    return;
                case 12:
                    v = code[i];
                    i += 1;
                    switch (v) {
                        case 35:
                            c1x = x   + stack.shift();
                            c1y = y   + stack.shift();
                            c2x = c1x + stack.shift();
                            c2y = c1y + stack.shift();
                            jpx = c2x + stack.shift();
                            jpy = c2y + stack.shift();
                            c3x = jpx + stack.shift();
                            c3y = jpy + stack.shift();
                            c4x = c3x + stack.shift();
                            c4y = c3y + stack.shift();
                            x = c4x   + stack.shift();
                            y = c4y   + stack.shift();
                            stack.shift();
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 34:
                            c1x = x   + stack.shift();
                            c1y = y;
                            c2x = c1x + stack.shift();
                            c2y = c1y + stack.shift();
                            jpx = c2x + stack.shift();
                            jpy = c2y;
                            c3x = jpx + stack.shift();
                            c3y = c2y;
                            c4x = c3x + stack.shift();
                            c4y = y;
                            x = c4x + stack.shift();
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 36:
                            c1x = x   + stack.shift();
                            c1y = y   + stack.shift();
                            c2x = c1x + stack.shift();
                            c2y = c1y + stack.shift();
                            jpx = c2x + stack.shift();
                            jpy = c2y;
                            c3x = jpx + stack.shift();
                            c3y = c2y;
                            c4x = c3x + stack.shift();
                            c4y = c3y + stack.shift();
                            x = c4x + stack.shift();
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 37:
                            c1x = x   + stack.shift();
                            c1y = y   + stack.shift();
                            c2x = c1x + stack.shift();
                            c2y = c1y + stack.shift();
                            jpx = c2x + stack.shift();
                            jpy = c2y + stack.shift();
                            c3x = jpx + stack.shift();
                            c3y = jpy + stack.shift();
                            c4x = c3x + stack.shift();
                            c4y = c3y + stack.shift();
                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                                x = c4x + stack.shift();
                            } else {
                                y = c4y + stack.shift();
                            }
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        default:
                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
                            stack.length = 0;
                    }
                    break;
                case 14:
                    if (stack.length > 0 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }
                    if (open) {
                        p.closePath();
                        open = false;
                    }
                    break;
                case 18:
                    parseStems();
                    break;
                case 19:
                case 20:
                    parseStems();
                    i += (nStems + 7) >> 3;
                    break;
                case 21:
                    if (stack.length > 2 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }
                    y += stack.pop();
                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 22:
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }
                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 23:
                    parseStems();
                    break;
                case 24:
                    while (stack.length > 2) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                    break;
                case 25:
                    while (stack.length > 6) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    break;
                case 26:
                    if (stack.length % 2) {
                        x += stack.shift();
                    }
                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x;
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                case 27:
                    if (stack.length % 2) {
                        y += stack.shift();
                    }
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y;
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                case 28:
                    b1 = code[i];
                    b2 = code[i + 1];
                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                    i += 2;
                    break;
                case 29:
                    codeIndex = stack.pop() + font.gsubrsBias;
                    subrCode = font.gsubrs[codeIndex];
                    if (subrCode) {
                        parse(subrCode);
                    }
                    break;
                case 30:
                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                case 31:
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                    break;
                default:
                    if (v < 32) {
                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
                    } else if (v < 247) {
                        stack.push(v - 139);
                    } else if (v < 251) {
                        b1 = code[i];
                        i += 1;
                        stack.push((v - 247) * 256 + b1 + 108);
                    } else if (v < 255) {
                        b1 = code[i];
                        i += 1;
                        stack.push(-(v - 251) * 256 - b1 - 108);
                    } else {
                        b1 = code[i];
                        b2 = code[i + 1];
                        b3 = code[i + 2];
                        b4 = code[i + 3];
                        i += 4;
                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                    }
            }
        }
    }
    parse(code);
    glyph.advanceWidth = width;
    return p;
}
function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
    var fdSelect = [];
    var fdIndex;
    var parser = new parse.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        for (var iGid = 0; iGid < nGlyphs; iGid++) {
            fdIndex = parser.parseCard8();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            fdSelect.push(fdIndex);
        }
    } else if (format === 3) {
        var nRanges = parser.parseCard16();
        var first = parser.parseCard16();
        if (first !== 0) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
        }
        var next;
        for (var iRange = 0; iRange < nRanges; iRange++) {
            fdIndex = parser.parseCard8();
            next = parser.parseCard16();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            if (next > nGlyphs) {
                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
            }
            for (; first < next; first++) {
                fdSelect.push(fdIndex);
            }
            first = next;
        }
        if (next !== nGlyphs) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
        }
    } else {
        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
    }
    return fdSelect;
}
function parseCFFTable(data, start, font, opt) {
    font.tables.cff = {};
    var header = parseCFFHeader(data, start);
    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);
    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
    if (topDictArray.length !== 1) {
        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
    }
    var topDict = topDictArray[0];
    font.tables.cff.topDict = topDict;
    if (topDict._privateDict) {
        font.defaultWidthX = topDict._privateDict.defaultWidthX;
        font.nominalWidthX = topDict._privateDict.nominalWidthX;
    }
    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
        font.isCIDFont = true;
    }
    if (font.isCIDFont) {
        var fdArrayOffset = topDict.fdArray;
        var fdSelectOffset = topDict.fdSelect;
        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
        }
        fdArrayOffset += start;
        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
        topDict._fdArray = fdArray;
        fdSelectOffset += start;
        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
    }
    var privateDictOffset = start + topDict.private[1];
    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;
    if (privateDict.subrs !== 0) {
        var subrOffset = privateDictOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }
    var charStringsIndex;
    if (opt.lowMemory) {
        charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);
        font.nGlyphs = charStringsIndex.offsets.length;
    } else {
        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
        font.nGlyphs = charStringsIndex.objects.length;
    }
    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) {
        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) {
        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }
    font.encoding = font.encoding || font.cffEncoding;
    font.glyphs = new glyphset.GlyphSet(font);
    if (opt.lowMemory) {
        font._push = function(i) {
            var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);
            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
        };
    } else {
        for (var i = 0; i < font.nGlyphs; i += 1) {
            var charString = charStringsIndex.objects[i];
            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
        }
    }
}
function encodeString(s, strings) {
    var sid;
    var i = cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + cffStandardStrings.length;
    } else {
        sid = cffStandardStrings.length + strings.length;
        strings.push(s);
    }
    return sid;
}
function makeHeader() {
    return new table.Record('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}
function makeNameIndex(fontNames) {
    var t = new table.Record('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }
    return t;
}
function makeDict(meta, attrs, strings) {
    var m = {};
    for (var i = 0; i < meta.length; i += 1) {
        var entry = meta[i];
        var value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }
            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }
    return m;
}
function makeTopDict(attrs, strings) {
    var t = new table.Record('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}
function makeTopDictIndex(topDict) {
    var t = new table.Record('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}
function makeStringIndex(strings) {
    var t = new table.Record('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }
    return t;
}
function makeGlobalSubrIndex() {
    return new table.Record('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}
function makeCharsets(glyphNames, strings) {
    var t = new table.Record('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }
    return t;
}
function glyphToOps(glyph) {
    var ops = [];
    var path = glyph.path;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    var x = 0;
    var y = 0;
    for (var i = 0; i < path.commands.length; i += 1) {
        var dx = (void 0);
        var dy = (void 0);
        var cmd = path.commands[i];
        if (cmd.type === 'Q') {
            var _13 = 1 / 3;
            var _23 = 2 / 3;
            cmd = {
                type: 'C',
                x: cmd.x,
                y: cmd.y,
                x1: Math.round(_13 * x + _23 * cmd.x1),
                y1: Math.round(_13 * y + _23 * cmd.y1),
                x2: Math.round(_13 * cmd.x + _23 * cmd.x1),
                y2: Math.round(_13 * cmd.y + _23 * cmd.y1)
            };
        }
        if (cmd.type === 'M') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'L') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'C') {
            var dx1 = Math.round(cmd.x1 - x);
            var dy1 = Math.round(cmd.y1 - y);
            var dx2 = Math.round(cmd.x2 - cmd.x1);
            var dy2 = Math.round(cmd.y2 - cmd.y1);
            dx = Math.round(cmd.x - cmd.x2);
            dy = Math.round(cmd.y - cmd.y2);
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        }
    }
    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}
function makeCharStringsIndex(glyphs) {
    var t = new table.Record('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }
    return t;
}
function makePrivateDict(attrs, strings) {
    var t = new table.Record('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}
function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'RECORD'},
        {name: 'nameIndex', type: 'RECORD'},
        {name: 'topDictIndex', type: 'RECORD'},
        {name: 'stringIndex', type: 'RECORD'},
        {name: 'globalSubrIndex', type: 'RECORD'},
        {name: 'charsets', type: 'RECORD'},
        {name: 'charStringsIndex', type: 'RECORD'},
        {name: 'privateDict', type: 'RECORD'}
    ]);
    var fontScale = 1 / options.unitsPerEm;
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        fontBBox: options.fontBBox || [0, 0, 0, 0],
        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };
    var privateAttrs = {};
    var glyphNames = [];
    var glyph;
    for (var i = 1; i < glyphs.length; i += 1) {
        glyph = glyphs.get(i);
        glyphNames.push(glyph.name);
    }
    var strings = [];
    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    t.privateDict = makePrivateDict(privateAttrs, strings);
    t.stringIndex = makeStringIndex(strings);
    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;
    attrs.encoding = 0;
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    return t;
}
var cff = { parse: parseCFFTable, make: makeCFFTable };
function parseHeadTable(data, start) {
    var head = {};
    var p = new parse.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();
    head.glyphDataFormat = p.parseShort();
    return head;
}
function makeHeadTable(options) {
    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
    var createdTimestamp = timestamp;
    if (options.createdTimestamp) {
        createdTimestamp = options.createdTimestamp + 2082844800;
    }
    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}
var head = { parse: parseHeadTable, make: makeHeadTable };
function parseHheaTable(data, start) {
    var hhea = {};
    var p = new parse.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}
function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}
var hhea = { parse: parseHheaTable, make: makeHheaTable };
function parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {
    var advanceWidth;
    var leftSideBearing;
    var p = new parse.Parser(data, start);
    for (var i = 0; i < numGlyphs; i += 1) {
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }
        var glyph = glyphs.get(i);
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}
function parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {
    font._hmtxTableData = {};
    var advanceWidth;
    var leftSideBearing;
    var p = new parse.Parser(data, start);
    for (var i = 0; i < numGlyphs; i += 1) {
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }
        font._hmtxTableData[i] = {
            advanceWidth: advanceWidth,
            leftSideBearing: leftSideBearing
        };
    }
}
function parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {
    if (opt.lowMemory)
        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }
    else
        { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }
}
function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }
    return t;
}
var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };
function makeLtagTable(tags) {
    var result = new table.Table('ltag', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'numTags', type: 'ULONG', value: tags.length}
    ]);
    var stringPool = '';
    var stringPoolOffset = 12 + tags.length * 4;
    for (var i = 0; i < tags.length; ++i) {
        var pos = stringPool.indexOf(tags[i]);
        if (pos < 0) {
            pos = stringPool.length;
            stringPool += tags[i];
        }
        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
    }
    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
    return result;
}
function parseLtagTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
    p.skip('uLong', 1);
    var numTags = p.parseULong();
    var tags = [];
    for (var i = 0; i < numTags; i++) {
        var tag = '';
        var offset = start + p.parseUShort();
        var length = p.parseUShort();
        for (var j = offset; j < offset + length; ++j) {
            tag += String.fromCharCode(data.getInt8(j));
        }
        tags.push(tag);
    }
    return tags;
}
var ltag = { make: makeLtagTable, parse: parseLtagTable };
function parseMaxpTable(data, start) {
    var maxp = {};
    var p = new parse.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }
    return maxp;
}
function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}
var maxp = { parse: parseMaxpTable, make: makeMaxpTable };
var nameTableNames = [
    'copyright',
    'fontFamily',
    'fontSubfamily',
    'uniqueID',
    'fullName',
    'version',
    'postScriptName',
    'trademark',
    'manufacturer',
    'designer',
    'description',
    'manufacturerURL',
    'designerURL',
    'license',
    'licenseURL',
    'reserved',
    'preferredFamily',
    'preferredSubfamily',
    'compatibleFullName',
    'sampleText',
    'postScriptFindFontName',
    'wwsFamily',
    'wwsSubfamily'
];
var macLanguages = {
    0: 'en',
    1: 'fr',
    2: 'de',
    3: 'it',
    4: 'nl',
    5: 'sv',
    6: 'es',
    7: 'da',
    8: 'pt',
    9: 'no',
    10: 'he',
    11: 'ja',
    12: 'ar',
    13: 'fi',
    14: 'el',
    15: 'is',
    16: 'mt',
    17: 'tr',
    18: 'hr',
    19: 'zh-Hant',
    20: 'ur',
    21: 'hi',
    22: 'th',
    23: 'ko',
    24: 'lt',
    25: 'pl',
    26: 'hu',
    27: 'es',
    28: 'lv',
    29: 'se',
    30: 'fo',
    31: 'fa',
    32: 'ru',
    33: 'zh',
    34: 'nl-BE',
    35: 'ga',
    36: 'sq',
    37: 'ro',
    38: 'cz',
    39: 'sk',
    40: 'si',
    41: 'yi',
    42: 'sr',
    43: 'mk',
    44: 'bg',
    45: 'uk',
    46: 'be',
    47: 'uz',
    48: 'kk',
    49: 'az-Cyrl',
    50: 'az-Arab',
    51: 'hy',
    52: 'ka',
    53: 'mo',
    54: 'ky',
    55: 'tg',
    56: 'tk',
    57: 'mn-CN',
    58: 'mn',
    59: 'ps',
    60: 'ks',
    61: 'ku',
    62: 'sd',
    63: 'bo',
    64: 'ne',
    65: 'sa',
    66: 'mr',
    67: 'bn',
    68: 'as',
    69: 'gu',
    70: 'pa',
    71: 'or',
    72: 'ml',
    73: 'kn',
    74: 'ta',
    75: 'te',
    76: 'si',
    77: 'my',
    78: 'km',
    79: 'lo',
    80: 'vi',
    81: 'id',
    82: 'tl',
    83: 'ms',
    84: 'ms-Arab',
    85: 'am',
    86: 'ti',
    87: 'om',
    88: 'so',
    89: 'sw',
    90: 'rw',
    91: 'rn',
    92: 'ny',
    93: 'mg',
    94: 'eo',
    128: 'cy',
    129: 'eu',
    130: 'ca',
    131: 'la',
    132: 'qu',
    133: 'gn',
    134: 'ay',
    135: 'tt',
    136: 'ug',
    137: 'dz',
    138: 'jv',
    139: 'su',
    140: 'gl',
    141: 'af',
    142: 'br',
    143: 'iu',
    144: 'gd',
    145: 'gv',
    146: 'ga',
    147: 'to',
    148: 'el-polyton',
    149: 'kl',
    150: 'az',
    151: 'nn'
};
var macLanguageToScript = {
    0: 0,
    1: 0,
    2: 0,
    3: 0,
    4: 0,
    5: 0,
    6: 0,
    7: 0,
    8: 0,
    9: 0,
    10: 5,
    11: 1,
    12: 4,
    13: 0,
    14: 6,
    15: 0,
    16: 0,
    17: 0,
    18: 0,
    19: 2,
    20: 4,
    21: 9,
    22: 21,
    23: 3,
    24: 29,
    25: 29,
    26: 29,
    27: 29,
    28: 29,
    29: 0,
    30: 0,
    31: 4,
    32: 7,
    33: 25,
    34: 0,
    35: 0,
    36: 0,
    37: 0,
    38: 29,
    39: 29,
    40: 0,
    41: 5,
    42: 7,
    43: 7,
    44: 7,
    45: 7,
    46: 7,
    47: 7,
    48: 7,
    49: 7,
    50: 4,
    51: 24,
    52: 23,
    53: 7,
    54: 7,
    55: 7,
    56: 7,
    57: 27,
    58: 7,
    59: 4,
    60: 4,
    61: 4,
    62: 4,
    63: 26,
    64: 9,
    65: 9,
    66: 9,
    67: 13,
    68: 13,
    69: 11,
    70: 10,
    71: 12,
    72: 17,
    73: 16,
    74: 14,
    75: 15,
    76: 18,
    77: 19,
    78: 20,
    79: 22,
    80: 30,
    81: 0,
    82: 0,
    83: 0,
    84: 4,
    85: 28,
    86: 28,
    87: 28,
    88: 0,
    89: 0,
    90: 0,
    91: 0,
    92: 0,
    93: 0,
    94: 0,
    128: 0,
    129: 0,
    130: 0,
    131: 0,
    132: 0,
    133: 0,
    134: 0,
    135: 7,
    136: 4,
    137: 26,
    138: 0,
    139: 0,
    140: 0,
    141: 0,
    142: 0,
    143: 28,
    144: 0,
    145: 0,
    146: 0,
    147: 0,
    148: 6,
    149: 0,
    150: 0,
    151: 0
};
var windowsLanguages = {
    0x0436: 'af',
    0x041C: 'sq',
    0x0484: 'gsw',
    0x045E: 'am',
    0x1401: 'ar-DZ',
    0x3C01: 'ar-BH',
    0x0C01: 'ar',
    0x0801: 'ar-IQ',
    0x2C01: 'ar-JO',
    0x3401: 'ar-KW',
    0x3001: 'ar-LB',
    0x1001: 'ar-LY',
    0x1801: 'ary',
    0x2001: 'ar-OM',
    0x4001: 'ar-QA',
    0x0401: 'ar-SA',
    0x2801: 'ar-SY',
    0x1C01: 'aeb',
    0x3801: 'ar-AE',
    0x2401: 'ar-YE',
    0x042B: 'hy',
    0x044D: 'as',
    0x082C: 'az-Cyrl',
    0x042C: 'az',
    0x046D: 'ba',
    0x042D: 'eu',
    0x0423: 'be',
    0x0845: 'bn',
    0x0445: 'bn-IN',
    0x201A: 'bs-Cyrl',
    0x141A: 'bs',
    0x047E: 'br',
    0x0402: 'bg',
    0x0403: 'ca',
    0x0C04: 'zh-HK',
    0x1404: 'zh-MO',
    0x0804: 'zh',
    0x1004: 'zh-SG',
    0x0404: 'zh-TW',
    0x0483: 'co',
    0x041A: 'hr',
    0x101A: 'hr-BA',
    0x0405: 'cs',
    0x0406: 'da',
    0x048C: 'prs',
    0x0465: 'dv',
    0x0813: 'nl-BE',
    0x0413: 'nl',
    0x0C09: 'en-AU',
    0x2809: 'en-BZ',
    0x1009: 'en-CA',
    0x2409: 'en-029',
    0x4009: 'en-IN',
    0x1809: 'en-IE',
    0x2009: 'en-JM',
    0x4409: 'en-MY',
    0x1409: 'en-NZ',
    0x3409: 'en-PH',
    0x4809: 'en-SG',
    0x1C09: 'en-ZA',
    0x2C09: 'en-TT',
    0x0809: 'en-GB',
    0x0409: 'en',
    0x3009: 'en-ZW',
    0x0425: 'et',
    0x0438: 'fo',
    0x0464: 'fil',
    0x040B: 'fi',
    0x080C: 'fr-BE',
    0x0C0C: 'fr-CA',
    0x040C: 'fr',
    0x140C: 'fr-LU',
    0x180C: 'fr-MC',
    0x100C: 'fr-CH',
    0x0462: 'fy',
    0x0456: 'gl',
    0x0437: 'ka',
    0x0C07: 'de-AT',
    0x0407: 'de',
    0x1407: 'de-LI',
    0x1007: 'de-LU',
    0x0807: 'de-CH',
    0x0408: 'el',
    0x046F: 'kl',
    0x0447: 'gu',
    0x0468: 'ha',
    0x040D: 'he',
    0x0439: 'hi',
    0x040E: 'hu',
    0x040F: 'is',
    0x0470: 'ig',
    0x0421: 'id',
    0x045D: 'iu',
    0x085D: 'iu-Latn',
    0x083C: 'ga',
    0x0434: 'xh',
    0x0435: 'zu',
    0x0410: 'it',
    0x0810: 'it-CH',
    0x0411: 'ja',
    0x044B: 'kn',
    0x043F: 'kk',
    0x0453: 'km',
    0x0486: 'quc',
    0x0487: 'rw',
    0x0441: 'sw',
    0x0457: 'kok',
    0x0412: 'ko',
    0x0440: 'ky',
    0x0454: 'lo',
    0x0426: 'lv',
    0x0427: 'lt',
    0x082E: 'dsb',
    0x046E: 'lb',
    0x042F: 'mk',
    0x083E: 'ms-BN',
    0x043E: 'ms',
    0x044C: 'ml',
    0x043A: 'mt',
    0x0481: 'mi',
    0x047A: 'arn',
    0x044E: 'mr',
    0x047C: 'moh',
    0x0450: 'mn',
    0x0850: 'mn-CN',
    0x0461: 'ne',
    0x0414: 'nb',
    0x0814: 'nn',
    0x0482: 'oc',
    0x0448: 'or',
    0x0463: 'ps',
    0x0415: 'pl',
    0x0416: 'pt',
    0x0816: 'pt-PT',
    0x0446: 'pa',
    0x046B: 'qu-BO',
    0x086B: 'qu-EC',
    0x0C6B: 'qu',
    0x0418: 'ro',
    0x0417: 'rm',
    0x0419: 'ru',
    0x243B: 'smn',
    0x103B: 'smj-NO',
    0x143B: 'smj',
    0x0C3B: 'se-FI',
    0x043B: 'se',
    0x083B: 'se-SE',
    0x203B: 'sms',
    0x183B: 'sma-NO',
    0x1C3B: 'sms',
    0x044F: 'sa',
    0x1C1A: 'sr-Cyrl-BA',
    0x0C1A: 'sr',
    0x181A: 'sr-Latn-BA',
    0x081A: 'sr-Latn',
    0x046C: 'nso',
    0x0432: 'tn',
    0x045B: 'si',
    0x041B: 'sk',
    0x0424: 'sl',
    0x2C0A: 'es-AR',
    0x400A: 'es-BO',
    0x340A: 'es-CL',
    0x240A: 'es-CO',
    0x140A: 'es-CR',
    0x1C0A: 'es-DO',
    0x300A: 'es-EC',
    0x440A: 'es-SV',
    0x100A: 'es-GT',
    0x480A: 'es-HN',
    0x080A: 'es-MX',
    0x4C0A: 'es-NI',
    0x180A: 'es-PA',
    0x3C0A: 'es-PY',
    0x280A: 'es-PE',
    0x500A: 'es-PR',
    0x0C0A: 'es',
    0x040A: 'es',
    0x540A: 'es-US',
    0x380A: 'es-UY',
    0x200A: 'es-VE',
    0x081D: 'sv-FI',
    0x041D: 'sv',
    0x045A: 'syr',
    0x0428: 'tg',
    0x085F: 'tzm',
    0x0449: 'ta',
    0x0444: 'tt',
    0x044A: 'te',
    0x041E: 'th',
    0x0451: 'bo',
    0x041F: 'tr',
    0x0442: 'tk',
    0x0480: 'ug',
    0x0422: 'uk',
    0x042E: 'hsb',
    0x0420: 'ur',
    0x0843: 'uz-Cyrl',
    0x0443: 'uz',
    0x042A: 'vi',
    0x0452: 'cy',
    0x0488: 'wo',
    0x0485: 'sah',
    0x0478: 'ii',
    0x046A: 'yo'
};
function getLanguageCode(platformID, languageID, ltag) {
    switch (platformID) {
        case 0:
            if (languageID === 0xFFFF) {
                return 'und';
            } else if (ltag) {
                return ltag[languageID];
            }
            break;
        case 1:
            return macLanguages[languageID];
        case 3:
            return windowsLanguages[languageID];
    }
    return undefined;
}
var utf16 = 'utf-16';
var macScriptEncodings = {
    0: 'macintosh',
    1: 'x-mac-japanese',
    2: 'x-mac-chinesetrad',
    3: 'x-mac-korean',
    6: 'x-mac-greek',
    7: 'x-mac-cyrillic',
    9: 'x-mac-devanagai',
    10: 'x-mac-gurmukhi',
    11: 'x-mac-gujarati',
    12: 'x-mac-oriya',
    13: 'x-mac-bengali',
    14: 'x-mac-tamil',
    15: 'x-mac-telugu',
    16: 'x-mac-kannada',
    17: 'x-mac-malayalam',
    18: 'x-mac-sinhalese',
    19: 'x-mac-burmese',
    20: 'x-mac-khmer',
    21: 'x-mac-thai',
    22: 'x-mac-lao',
    23: 'x-mac-georgian',
    24: 'x-mac-armenian',
    25: 'x-mac-chinesesimp',
    26: 'x-mac-tibetan',
    27: 'x-mac-mongolian',
    28: 'x-mac-ethiopic',
    29: 'x-mac-ce',
    30: 'x-mac-vietnamese',
    31: 'x-mac-extarabic'
};
var macLanguageEncodings = {
    15: 'x-mac-icelandic',
    17: 'x-mac-turkish',
    18: 'x-mac-croatian',
    24: 'x-mac-ce',
    25: 'x-mac-ce',
    26: 'x-mac-ce',
    27: 'x-mac-ce',
    28: 'x-mac-ce',
    30: 'x-mac-icelandic',
    37: 'x-mac-romanian',
    38: 'x-mac-ce',
    39: 'x-mac-ce',
    40: 'x-mac-ce',
    143: 'x-mac-inuit',
    146: 'x-mac-gaelic'
};
function getEncoding(platformID, encodingID, languageID) {
    switch (platformID) {
        case 0:
            return utf16;
        case 1:
            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
        case 3:
            if (encodingID === 1 || encodingID === 10) {
                return utf16;
            }
            break;
    }
    return undefined;
}
function parseNameTable(data, start, ltag) {
    var name = {};
    var p = new parse.Parser(data, start);
    var format = p.parseUShort();
    var count = p.parseUShort();
    var stringOffset = p.offset + p.parseUShort();
    for (var i = 0; i < count; i++) {
        var platformID = p.parseUShort();
        var encodingID = p.parseUShort();
        var languageID = p.parseUShort();
        var nameID = p.parseUShort();
        var property = nameTableNames[nameID] || nameID;
        var byteLength = p.parseUShort();
        var offset = p.parseUShort();
        var language = getLanguageCode(platformID, languageID, ltag);
        var encoding = getEncoding(platformID, encodingID, languageID);
        if (encoding !== undefined && language !== undefined) {
            var text = (void 0);
            if (encoding === utf16) {
                text = decode$1.UTF16(data, stringOffset + offset, byteLength);
            } else {
                text = decode$1.MACSTRING(data, stringOffset + offset, byteLength, encoding);
            }
            if (text) {
                var translations = name[property];
                if (translations === undefined) {
                    translations = name[property] = {};
                }
                translations[language] = text;
            }
        }
    }
    if (format === 1) {
        p.parseUShort();
    }
    return name;
}
function reverseDict(dict) {
    var result = {};
    for (var key in dict) {
        result[dict[key]] = parseInt(key);
    }
    return result;
}
function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Record('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}
function findSubArray(needle, haystack) {
    var needleLength = needle.length;
    var limit = haystack.length - needleLength + 1;
    loop:
    for (var pos = 0; pos < limit; pos++) {
        for (; pos < limit; pos++) {
            for (var k = 0; k < needleLength; k++) {
                if (haystack[pos + k] !== needle[k]) {
                    continue loop;
                }
            }
            return pos;
        }
    }
    return -1;
}
function addStringToPool(s, pool) {
    var offset = findSubArray(s, pool);
    if (offset < 0) {
        offset = pool.length;
        var i = 0;
        var len = s.length;
        for (; i < len; ++i) {
            pool.push(s[i]);
        }
    }
    return offset;
}
function makeNameTable(names, ltag) {
    var nameID;
    var nameIDs = [];
    var namesWithNumericKeys = {};
    var nameTableIds = reverseDict(nameTableNames);
    for (var key in names) {
        var id = nameTableIds[key];
        if (id === undefined) {
            id = key;
        }
        nameID = parseInt(id);
        if (isNaN(nameID)) {
            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
        }
        namesWithNumericKeys[nameID] = names[key];
        nameIDs.push(nameID);
    }
    var macLanguageIds = reverseDict(macLanguages);
    var windowsLanguageIds = reverseDict(windowsLanguages);
    var nameRecords = [];
    var stringPool = [];
    for (var i = 0; i < nameIDs.length; i++) {
        nameID = nameIDs[i];
        var translations = namesWithNumericKeys[nameID];
        for (var lang in translations) {
            var text = translations[lang];
            var macPlatform = 1;
            var macLanguage = macLanguageIds[lang];
            var macScript = macLanguageToScript[macLanguage];
            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
            var macName = encode$1.MACSTRING(text, macEncoding);
            if (macName === undefined) {
                macPlatform = 0;
                macLanguage = ltag.indexOf(lang);
                if (macLanguage < 0) {
                    macLanguage = ltag.length;
                    ltag.push(lang);
                }
                macScript = 4;
                macName = encode$1.UTF16(text);
            }
            var macNameOffset = addStringToPool(macName, stringPool);
            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
                                            nameID, macName.length, macNameOffset));
            var winLanguage = windowsLanguageIds[lang];
            if (winLanguage !== undefined) {
                var winName = encode$1.UTF16(text);
                var winNameOffset = addStringToPool(winName, stringPool);
                nameRecords.push(makeNameRecord(3, 1, winLanguage,
                                                nameID, winName.length, winNameOffset));
            }
        }
    }
    nameRecords.sort(function(a, b) {
        return ((a.platformID - b.platformID) ||
                (a.encodingID - b.encodingID) ||
                (a.languageID - b.languageID) ||
                (a.nameID - b.nameID));
    });
    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: nameRecords.length},
        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
    ]);
    for (var r = 0; r < nameRecords.length; r++) {
        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
    }
    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
    return t;
}
var _name = { parse: parseNameTable, make: makeNameTable };
var unicodeRanges = [
    {begin: 0x0000, end: 0x007F},
    {begin: 0x0080, end: 0x00FF},
    {begin: 0x0100, end: 0x017F},
    {begin: 0x0180, end: 0x024F},
    {begin: 0x0250, end: 0x02AF},
    {begin: 0x02B0, end: 0x02FF},
    {begin: 0x0300, end: 0x036F},
    {begin: 0x0370, end: 0x03FF},
    {begin: 0x2C80, end: 0x2CFF},
    {begin: 0x0400, end: 0x04FF},
    {begin: 0x0530, end: 0x058F},
    {begin: 0x0590, end: 0x05FF},
    {begin: 0xA500, end: 0xA63F},
    {begin: 0x0600, end: 0x06FF},
    {begin: 0x07C0, end: 0x07FF},
    {begin: 0x0900, end: 0x097F},
    {begin: 0x0980, end: 0x09FF},
    {begin: 0x0A00, end: 0x0A7F},
    {begin: 0x0A80, end: 0x0AFF},
    {begin: 0x0B00, end: 0x0B7F},
    {begin: 0x0B80, end: 0x0BFF},
    {begin: 0x0C00, end: 0x0C7F},
    {begin: 0x0C80, end: 0x0CFF},
    {begin: 0x0D00, end: 0x0D7F},
    {begin: 0x0E00, end: 0x0E7F},
    {begin: 0x0E80, end: 0x0EFF},
    {begin: 0x10A0, end: 0x10FF},
    {begin: 0x1B00, end: 0x1B7F},
    {begin: 0x1100, end: 0x11FF},
    {begin: 0x1E00, end: 0x1EFF},
    {begin: 0x1F00, end: 0x1FFF},
    {begin: 0x2000, end: 0x206F},
    {begin: 0x2070, end: 0x209F},
    {begin: 0x20A0, end: 0x20CF},
    {begin: 0x20D0, end: 0x20FF},
    {begin: 0x2100, end: 0x214F},
    {begin: 0x2150, end: 0x218F},
    {begin: 0x2190, end: 0x21FF},
    {begin: 0x2200, end: 0x22FF},
    {begin: 0x2300, end: 0x23FF},
    {begin: 0x2400, end: 0x243F},
    {begin: 0x2440, end: 0x245F},
    {begin: 0x2460, end: 0x24FF},
    {begin: 0x2500, end: 0x257F},
    {begin: 0x2580, end: 0x259F},
    {begin: 0x25A0, end: 0x25FF},
    {begin: 0x2600, end: 0x26FF},
    {begin: 0x2700, end: 0x27BF},
    {begin: 0x3000, end: 0x303F},
    {begin: 0x3040, end: 0x309F},
    {begin: 0x30A0, end: 0x30FF},
    {begin: 0x3100, end: 0x312F},
    {begin: 0x3130, end: 0x318F},
    {begin: 0xA840, end: 0xA87F},
    {begin: 0x3200, end: 0x32FF},
    {begin: 0x3300, end: 0x33FF},
    {begin: 0xAC00, end: 0xD7AF},
    {begin: 0xD800, end: 0xDFFF},
    {begin: 0x10900, end: 0x1091F},
    {begin: 0x4E00, end: 0x9FFF},
    {begin: 0xE000, end: 0xF8FF},
    {begin: 0x31C0, end: 0x31EF},
    {begin: 0xFB00, end: 0xFB4F},
    {begin: 0xFB50, end: 0xFDFF},
    {begin: 0xFE20, end: 0xFE2F},
    {begin: 0xFE10, end: 0xFE1F},
    {begin: 0xFE50, end: 0xFE6F},
    {begin: 0xFE70, end: 0xFEFF},
    {begin: 0xFF00, end: 0xFFEF},
    {begin: 0xFFF0, end: 0xFFFF},
    {begin: 0x0F00, end: 0x0FFF},
    {begin: 0x0700, end: 0x074F},
    {begin: 0x0780, end: 0x07BF},
    {begin: 0x0D80, end: 0x0DFF},
    {begin: 0x1000, end: 0x109F},
    {begin: 0x1200, end: 0x137F},
    {begin: 0x13A0, end: 0x13FF},
    {begin: 0x1400, end: 0x167F},
    {begin: 0x1680, end: 0x169F},
    {begin: 0x16A0, end: 0x16FF},
    {begin: 0x1780, end: 0x17FF},
    {begin: 0x1800, end: 0x18AF},
    {begin: 0x2800, end: 0x28FF},
    {begin: 0xA000, end: 0xA48F},
    {begin: 0x1700, end: 0x171F},
    {begin: 0x10300, end: 0x1032F},
    {begin: 0x10330, end: 0x1034F},
    {begin: 0x10400, end: 0x1044F},
    {begin: 0x1D000, end: 0x1D0FF},
    {begin: 0x1D400, end: 0x1D7FF},
    {begin: 0xFF000, end: 0xFFFFD},
    {begin: 0xFE00, end: 0xFE0F},
    {begin: 0xE0000, end: 0xE007F},
    {begin: 0x1900, end: 0x194F},
    {begin: 0x1950, end: 0x197F},
    {begin: 0x1980, end: 0x19DF},
    {begin: 0x1A00, end: 0x1A1F},
    {begin: 0x2C00, end: 0x2C5F},
    {begin: 0x2D30, end: 0x2D7F},
    {begin: 0x4DC0, end: 0x4DFF},
    {begin: 0xA800, end: 0xA82F},
    {begin: 0x10000, end: 0x1007F},
    {begin: 0x10140, end: 0x1018F},
    {begin: 0x10380, end: 0x1039F},
    {begin: 0x103A0, end: 0x103DF},
    {begin: 0x10450, end: 0x1047F},
    {begin: 0x10480, end: 0x104AF},
    {begin: 0x10800, end: 0x1083F},
    {begin: 0x10A00, end: 0x10A5F},
    {begin: 0x1D300, end: 0x1D35F},
    {begin: 0x12000, end: 0x123FF},
    {begin: 0x1D360, end: 0x1D37F},
    {begin: 0x1B80, end: 0x1BBF},
    {begin: 0x1C00, end: 0x1C4F},
    {begin: 0x1C50, end: 0x1C7F},
    {begin: 0xA880, end: 0xA8DF},
    {begin: 0xA900, end: 0xA92F},
    {begin: 0xA930, end: 0xA95F},
    {begin: 0xAA00, end: 0xAA5F},
    {begin: 0x10190, end: 0x101CF},
    {begin: 0x101D0, end: 0x101FF},
    {begin: 0x102A0, end: 0x102DF},
    {begin: 0x1F030, end: 0x1F09F}
];
function getUnicodeRange(unicode) {
    for (var i = 0; i < unicodeRanges.length; i += 1) {
        var range = unicodeRanges[i];
        if (unicode >= range.begin && unicode < range.end) {
            return i;
        }
    }
    return -1;
}
function parseOS2Table(data, start) {
    var os2 = {};
    var p = new parse.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }
    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }
    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }
    return os2;
}
function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}
var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };
function parsePostTable(data, start) {
    var post = {};
    var p = new parse.Parser(data, start);
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
        case 1:
            post.names = standardNames.slice();
            break;
        case 2:
            post.numberOfGlyphs = p.parseUShort();
            post.glyphNameIndex = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                post.glyphNameIndex[i] = p.parseUShort();
            }
            post.names = [];
            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                if (post.glyphNameIndex[i$1] >= standardNames.length) {
                    var nameLength = p.parseChar();
                    post.names.push(p.parseString(nameLength));
                }
            }
            break;
        case 2.5:
            post.numberOfGlyphs = p.parseUShort();
            post.offset = new Array(post.numberOfGlyphs);
            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
                post.offset[i$2] = p.parseChar();
            }
            break;
    }
    return post;
}
function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}
var post = { parse: parsePostTable, make: makePostTable };
var subtableParsers = new Array(9);
subtableParsers[1] = function parseLookup1() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            deltaGlyphId: this.parseUShort()
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            substitute: this.parseOffset16List()
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
};
subtableParsers[2] = function parseLookup2() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        sequences: this.parseListOfLists()
    };
};
subtableParsers[3] = function parseLookup3() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        alternateSets: this.parseListOfLists()
    };
};
subtableParsers[4] = function parseLookup4() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        ligatureSets: this.parseListOfLists(function() {
            return {
                ligGlyph: this.parseUShort(),
                components: this.parseUShortList(this.parseUShort() - 1)
            };
        })
    };
};
var lookupRecordDesc = {
    sequenceIndex: Parser.uShort,
    lookupListIndex: Parser.uShort
};
subtableParsers[5] = function parseLookup5() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            ruleSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    input: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            classDef: this.parsePointer(Parser.classDef),
            classSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    classes: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        var glyphCount = this.parseUShort();
        var substCount = this.parseUShort();
        return {
            substFormat: substFormat,
            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
};
subtableParsers[6] = function parseLookup6() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            chainRuleSets: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            backtrackClassDef: this.parsePointer(Parser.classDef),
            inputClassDef: this.parsePointer(Parser.classDef),
            lookaheadClassDef: this.parsePointer(Parser.classDef),
            chainClassSet: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        return {
            substFormat: 3,
            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
};
subtableParsers[7] = function parseLookup7() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
    var extensionLookupType = this.parseUShort();
    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
    return {
        substFormat: 1,
        lookupType: extensionLookupType,
        extension: subtableParsers[extensionLookupType].call(extensionParser)
    };
};
subtableParsers[8] = function parseLookup8() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        substitutes: this.parseUShortList()
    };
};
function parseGsubTable(data, start) {
    start = start || 0;
    var p = new Parser(data, start);
    var tableVersion = p.parseVersion(1);
    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
    if (tableVersion === 1) {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers)
        };
    } else {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers),
            variations: p.parseFeatureVariationsList()
        };
    }
}
var subtableMakers = new Array(9);
subtableMakers[1] = function makeLookup1(subtable) {
    if (subtable.substFormat === 1) {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 1},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
        ]);
    } else {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 2},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
        ].concat(table.ushortList('substitute', subtable.substitute)));
    }
};
subtableMakers[2] = function makeLookup2(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('seqSet', subtable.sequences, function(sequenceSet) {
        return new table.Table('sequenceSetTable', table.ushortList('sequence', sequenceSet));
    })));
};
subtableMakers[3] = function makeLookup3(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
    })));
};
subtableMakers[4] = function makeLookup4(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
            return new table.Table('ligatureTable',
                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
            );
        }));
    })));
};
subtableMakers[6] = function makeLookup6(subtable) {
    if (subtable.substFormat === 1) {
        var returnTable = new table.Table('chainContextTable', [
            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
        ].concat(table.tableList('chainRuleSet', subtable.chainRuleSets, function(chainRuleSet) {
            return new table.Table('chainRuleSetTable', table.tableList('chainRule', chainRuleSet, function(chainRule) {
                var tableData = table.ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)
                    .concat(table.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))
                    .concat(table.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))
                    .concat(table.ushortList('substitution', [], chainRule.lookupRecords.length));
                chainRule.lookupRecords.forEach(function (record, i) {
                    tableData = tableData
                        .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})
                        .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});
                });
                return new table.Table('chainRuleTable', tableData);
            }));
        })));
        return returnTable;
    } else if (subtable.substFormat === 2) {
        check.assert(false, 'lookup type 6 format 2 is not yet supported.');
    } else if (subtable.substFormat === 3) {
        var tableData = [
            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat} ];
        tableData.push({name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length});
        subtable.backtrackCoverage.forEach(function (coverage, i) {
            tableData.push({name: 'backtrackCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});
        });
        tableData.push({name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length});
        subtable.inputCoverage.forEach(function (coverage, i) {
            tableData.push({name: 'inputCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});
        });
        tableData.push({name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length});
        subtable.lookaheadCoverage.forEach(function (coverage, i) {
            tableData.push({name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});
        });
        tableData.push({name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length});
        subtable.lookupRecords.forEach(function (record, i) {
            tableData = tableData
                .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})
                .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});
        });
        var returnTable$1 = new table.Table('chainContextTable', tableData);
        return returnTable$1;
    }
    check.assert(false, 'lookup type 6 format must be 1, 2 or 3.');
};
function makeGsubTable(gsub) {
    return new table.Table('GSUB', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
    ]);
}
var gsub = { parse: parseGsubTable, make: makeGsubTable };
function parseMetaTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported META table version.');
    p.parseULong();
    p.parseULong();
    var numDataMaps = p.parseULong();
    var tags = {};
    for (var i = 0; i < numDataMaps; i++) {
        var tag = p.parseTag();
        var dataOffset = p.parseULong();
        var dataLength = p.parseULong();
        var text = decode$1.UTF8(data, start + dataOffset, dataLength);
        tags[tag] = text;
    }
    return tags;
}
function makeMetaTable(tags) {
    var numTags = Object.keys(tags).length;
    var stringPool = '';
    var stringPoolOffset = 16 + numTags * 12;
    var result = new table.Table('meta', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
        {name: 'numTags', type: 'ULONG', value: numTags}
    ]);
    for (var tag in tags) {
        var pos = stringPool.length;
        stringPool += tags[tag];
        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
    }
    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
    return result;
}
var meta = { parse: parseMetaTable, make: makeMetaTable };
function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}
function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }
    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }
    sum %= Math.pow(2, 32);
    return sum;
}
function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Record('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}
function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;
    var recordFields = [];
    var tableFields = [];
    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }
    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }
    recordFields.sort(function(r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });
    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs.get(glyphIndex);
            return glyph.getMetrics();
        }
    }
    return notFoundMetrics;
}
function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }
    return sum / vs.length;
}
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    var firstCharIndex;
    var lastCharIndex = 0;
    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;
    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs.get(i);
        var unicode = glyph.unicode | 0;
        if (isNaN(glyph.advanceWidth)) {
            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
        }
        if (firstCharIndex > unicode || firstCharIndex === undefined) {
            if (unicode > 0) {
                firstCharIndex = unicode;
            }
        }
        if (lastCharIndex < unicode) {
            lastCharIndex = unicode;
        }
        var position = os2.getUnicodeRange(unicode);
        if (position < 32) {
            ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
            ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
            ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
            ulUnicodeRange4 |= 1 << position - 96;
        } else {
            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
        }
        if (glyph.name === '.notdef') { continue; }
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }
    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = font.ascender;
    globals.descender = font.descender;
    var headTable = head.make({
        flags: 3,
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax,
        lowestRecPPEM: 3,
        createdTimestamp: font.createdTimestamp
    });
    var hheaTable = hhea.make({
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });
    var maxpTable = maxp.make(font.glyphs.length);
    var os2Table = os2.make(Object.assign({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usFirstCharIndex: firstCharIndex,
        usLastCharIndex: lastCharIndex,
        ulUnicodeRange1: ulUnicodeRange1,
        ulUnicodeRange2: ulUnicodeRange2,
        ulUnicodeRange3: ulUnicodeRange3,
        ulUnicodeRange4: ulUnicodeRange4,
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.yMax,
        usWinDescent: Math.abs(globals.yMin),
        ulCodePageRange1: 1,
        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usDefaultChar: font.hasChar(' ') ? 32 : 0,
        usBreakChar: font.hasChar(' ') ? 32 : 0,
    }, font.tables.os2));
    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);
    var englishFamilyName = font.getEnglishName('fontFamily');
    var englishStyleName = font.getEnglishName('fontSubfamily');
    var englishFullName = englishFamilyName + ' ' + englishStyleName;
    var postScriptName = font.getEnglishName('postScriptName');
    if (!postScriptName) {
        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
    }
    var names = {};
    for (var n in font.names) {
        names[n] = font.names[n];
    }
    if (!names.uniqueID) {
        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
    }
    if (!names.postScriptName) {
        names.postScriptName = {en: postScriptName};
    }
    if (!names.preferredFamily) {
        names.preferredFamily = font.names.fontFamily;
    }
    if (!names.preferredSubfamily) {
        names.preferredSubfamily = font.names.fontSubfamily;
    }
    var languageTags = [];
    var nameTable = _name.make(names, languageTags);
    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);
    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.getEnglishName('version'),
        fullName: englishFullName,
        familyName: englishFamilyName,
        weightName: englishStyleName,
        postScriptName: postScriptName,
        unitsPerEm: font.unitsPerEm,
        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
    });
    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
    if (ltagTable) {
        tables.push(ltagTable);
    }
    if (font.tables.gsub) {
        tables.push(gsub.make(font.tables.gsub));
    }
    if (metaTable) {
        tables.push(metaTable);
    }
    var sfntTable = makeSfntTable(tables);
    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    var tableFields = sfntTable.fields;
    var checkSumAdjusted = false;
    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
        if (tableFields[i$1].name === 'head table') {
            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
            checkSumAdjusted = true;
            break;
        }
    }
    if (!checkSumAdjusted) {
        throw new Error('Could not find head table with checkSum to adjust.');
    }
    return sfntTable;
}
var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };
function searchTag(arr, tag) {
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid].tag;
        if (val === tag) {
            return imid;
        } else if (val < tag) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    return -imin - 1;
}
function binSearch(arr, value) {
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid];
        if (val === value) {
            return imid;
        } else if (val < value) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    return -imin - 1;
}
function searchRange(ranges, value) {
    var range;
    var imin = 0;
    var imax = ranges.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        range = ranges[imid];
        var start = range.start;
        if (start === value) {
            return range;
        } else if (start < value) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    if (imin > 0) {
        range = ranges[imin - 1];
        if (value > range.end) { return 0; }
        return range;
    }
}
function Layout(font, tableName) {
    this.font = font;
    this.tableName = tableName;
}
Layout.prototype = {
    searchTag: searchTag,
    binSearch: binSearch,
    getTable: function(create) {
        var layout = this.font.tables[this.tableName];
        if (!layout && create) {
            layout = this.font.tables[this.tableName] = this.createDefaultTable();
        }
        return layout;
    },
    getScriptNames: function() {
        var layout = this.getTable();
        if (!layout) { return []; }
        return layout.scripts.map(function(script) {
            return script.tag;
        });
    },
    getDefaultScriptName: function() {
        var layout = this.getTable();
        if (!layout) { return; }
        var hasLatn = false;
        for (var i = 0; i < layout.scripts.length; i++) {
            var name = layout.scripts[i].tag;
            if (name === 'DFLT') { return name; }
            if (name === 'latn') { hasLatn = true; }
        }
        if (hasLatn) { return 'latn'; }
    },
    getScriptTable: function(script, create) {
        var layout = this.getTable(create);
        if (layout) {
            script = script || 'DFLT';
            var scripts = layout.scripts;
            var pos = searchTag(layout.scripts, script);
            if (pos >= 0) {
                return scripts[pos].script;
            } else if (create) {
                var scr = {
                    tag: script,
                    script: {
                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
                        langSysRecords: []
                    }
                };
                scripts.splice(-1 - pos, 0, scr);
                return scr.script;
            }
        }
    },
    getLangSysTable: function(script, language, create) {
        var scriptTable = this.getScriptTable(script, create);
        if (scriptTable) {
            if (!language || language === 'dflt' || language === 'DFLT') {
                return scriptTable.defaultLangSys;
            }
            var pos = searchTag(scriptTable.langSysRecords, language);
            if (pos >= 0) {
                return scriptTable.langSysRecords[pos].langSys;
            } else if (create) {
                var langSysRecord = {
                    tag: language,
                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
                };
                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
                return langSysRecord.langSys;
            }
        }
    },
    getFeatureTable: function(script, language, feature, create) {
        var langSysTable = this.getLangSysTable(script, language, create);
        if (langSysTable) {
            var featureRecord;
            var featIndexes = langSysTable.featureIndexes;
            var allFeatures = this.font.tables[this.tableName].features;
            for (var i = 0; i < featIndexes.length; i++) {
                featureRecord = allFeatures[featIndexes[i]];
                if (featureRecord.tag === feature) {
                    return featureRecord.feature;
                }
            }
            if (create) {
                var index = allFeatures.length;
                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
                featureRecord = {
                    tag: feature,
                    feature: { params: 0, lookupListIndexes: [] }
                };
                allFeatures.push(featureRecord);
                featIndexes.push(index);
                return featureRecord.feature;
            }
        }
    },
    getLookupTables: function(script, language, feature, lookupType, create) {
        var featureTable = this.getFeatureTable(script, language, feature, create);
        var tables = [];
        if (featureTable) {
            var lookupTable;
            var lookupListIndexes = featureTable.lookupListIndexes;
            var allLookups = this.font.tables[this.tableName].lookups;
            for (var i = 0; i < lookupListIndexes.length; i++) {
                lookupTable = allLookups[lookupListIndexes[i]];
                if (lookupTable.lookupType === lookupType) {
                    tables.push(lookupTable);
                }
            }
            if (tables.length === 0 && create) {
                lookupTable = {
                    lookupType: lookupType,
                    lookupFlag: 0,
                    subtables: [],
                    markFilteringSet: undefined
                };
                var index = allLookups.length;
                allLookups.push(lookupTable);
                lookupListIndexes.push(index);
                return [lookupTable];
            }
        }
        return tables;
    },
    getGlyphClass: function(classDefTable, glyphIndex) {
        switch (classDefTable.format) {
            case 1:
                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
                }
                return 0;
            case 2:
                var range = searchRange(classDefTable.ranges, glyphIndex);
                return range ? range.classId : 0;
        }
    },
    getCoverageIndex: function(coverageTable, glyphIndex) {
        switch (coverageTable.format) {
            case 1:
                var index = binSearch(coverageTable.glyphs, glyphIndex);
                return index >= 0 ? index : -1;
            case 2:
                var range = searchRange(coverageTable.ranges, glyphIndex);
                return range ? range.index + glyphIndex - range.start : -1;
        }
    },
    expandCoverage: function(coverageTable) {
        if (coverageTable.format === 1) {
            return coverageTable.glyphs;
        } else {
            var glyphs = [];
            var ranges = coverageTable.ranges;
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                var start = range.start;
                var end = range.end;
                for (var j = start; j <= end; j++) {
                    glyphs.push(j);
                }
            }
            return glyphs;
        }
    }
};
function Position(font) {
    Layout.call(this, font, 'gpos');
}
Position.prototype = Layout.prototype;
Position.prototype.init = function() {
    var script = this.getDefaultScriptName();
    this.defaultKerningTables = this.getKerningTables(script);
};
Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
    for (var i = 0; i < kerningLookups.length; i++) {
        var subtables = kerningLookups[i].subtables;
        for (var j = 0; j < subtables.length; j++) {
            var subtable = subtables[j];
            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);
            if (covIndex < 0) { continue; }
            switch (subtable.posFormat) {
                case 1:
                    var pairSet = subtable.pairSets[covIndex];
                    for (var k = 0; k < pairSet.length; k++) {
                        var pair = pairSet[k];
                        if (pair.secondGlyph === rightIndex) {
                            return pair.value1 && pair.value1.xAdvance || 0;
                        }
                    }
                    break;
                case 2:
                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);
                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);
                    var pair$1 = subtable.classRecords[class1][class2];
                    return pair$1.value1 && pair$1.value1.xAdvance || 0;
            }
        }
    }
    return 0;
};
Position.prototype.getKerningTables = function(script, language) {
    if (this.font.tables.gpos) {
        return this.getLookupTables(script, language, 'kern', 2);
    }
};
function Substitution(font) {
    Layout.call(this, font, 'gsub');
}
function arraysEqual(ar1, ar2) {
    var n = ar1.length;
    if (n !== ar2.length) { return false; }
    for (var i = 0; i < n; i++) {
        if (ar1[i] !== ar2[i]) { return false; }
    }
    return true;
}
function getSubstFormat(lookupTable, format, defaultSubtable) {
    var subtables = lookupTable.subtables;
    for (var i = 0; i < subtables.length; i++) {
        var subtable = subtables[i];
        if (subtable.substFormat === format) {
            return subtable;
        }
    }
    if (defaultSubtable) {
        subtables.push(defaultSubtable);
        return defaultSubtable;
    }
    return undefined;
}
Substitution.prototype = Layout.prototype;
Substitution.prototype.createDefaultTable = function() {
    return {
        version: 1,
        scripts: [{
            tag: 'DFLT',
            script: {
                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                langSysRecords: []
            }
        }],
        features: [],
        lookups: []
    };
};
Substitution.prototype.getSingle = function(feature, script, language) {
    var substitutions = [];
    var lookupTables = this.getLookupTables(script, language, feature, 1);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var j = (void 0);
            if (subtable.substFormat === 1) {
                var delta = subtable.deltaGlyphId;
                for (j = 0; j < glyphs.length; j++) {
                    var glyph = glyphs[j];
                    substitutions.push({ sub: glyph, by: glyph + delta });
                }
            } else {
                var substitute = subtable.substitute;
                for (j = 0; j < glyphs.length; j++) {
                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
                }
            }
        }
    }
    return substitutions;
};
Substitution.prototype.getMultiple = function(feature, script, language) {
    var substitutions = [];
    var lookupTables = this.getLookupTables(script, language, feature, 2);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var j = (void 0);
            for (j = 0; j < glyphs.length; j++) {
                var glyph = glyphs[j];
                var replacements = subtable.sequences[j];
                substitutions.push({ sub: glyph, by: replacements });
            }
        }
    }
    return substitutions;
};
Substitution.prototype.getAlternates = function(feature, script, language) {
    var alternates = [];
    var lookupTables = this.getLookupTables(script, language, feature, 3);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var alternateSets = subtable.alternateSets;
            for (var j = 0; j < glyphs.length; j++) {
                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
            }
        }
    }
    return alternates;
};
Substitution.prototype.getLigatures = function(feature, script, language) {
    var ligatures = [];
    var lookupTables = this.getLookupTables(script, language, feature, 4);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var ligatureSets = subtable.ligatureSets;
            for (var j = 0; j < glyphs.length; j++) {
                var startGlyph = glyphs[j];
                var ligSet = ligatureSets[j];
                for (var k = 0; k < ligSet.length; k++) {
                    var lig = ligSet[k];
                    ligatures.push({
                        sub: [startGlyph].concat(lig.components),
                        by: lig.ligGlyph
                    });
                }
            }
        }
    }
    return ligatures;
};
Substitution.prototype.addSingle = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
    var subtable = getSubstFormat(lookupTable, 2, {
        substFormat: 2,
        coverage: {format: 1, glyphs: []},
        substitute: []
    });
    check.assert(subtable.coverage.format === 1, 'Single: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.substitute.splice(pos, 0, 0);
    }
    subtable.substitute[pos] = substitution.by;
};
Substitution.prototype.addMultiple = function(feature, substitution, script, language) {
    check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];
    var subtable = getSubstFormat(lookupTable, 1, {
        substFormat: 1,
        coverage: {format: 1, glyphs: []},
        sequences: []
    });
    check.assert(subtable.coverage.format === 1, 'Multiple: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.sequences.splice(pos, 0, 0);
    }
    subtable.sequences[pos] = substitution.by;
};
Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
    var subtable = getSubstFormat(lookupTable, 1, {
        substFormat: 1,
        coverage: {format: 1, glyphs: []},
        alternateSets: []
    });
    check.assert(subtable.coverage.format === 1, 'Alternate: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.alternateSets.splice(pos, 0, 0);
    }
    subtable.alternateSets[pos] = substitution.by;
};
Substitution.prototype.addLigature = function(feature, ligature, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
    var subtable = lookupTable.subtables[0];
    if (!subtable) {
        subtable = {
            substFormat: 1,
            coverage: { format: 1, glyphs: [] },
            ligatureSets: []
        };
        lookupTable.subtables[0] = subtable;
    }
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = ligature.sub[0];
    var ligComponents = ligature.sub.slice(1);
    var ligatureTable = {
        ligGlyph: ligature.by,
        components: ligComponents
    };
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos >= 0) {
        var ligatureSet = subtable.ligatureSets[pos];
        for (var i = 0; i < ligatureSet.length; i++) {
            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
                return;
            }
        }
        ligatureSet.push(ligatureTable);
    } else {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
    }
};
Substitution.prototype.getFeature = function(feature, script, language) {
    if (/ss\d\d/.test(feature)) {
        return this.getSingle(feature, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            return this.getSingle(feature, script, language)
                    .concat(this.getAlternates(feature, script, language));
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.getLigatures(feature, script, language);
        case 'ccmp':
            return this.getMultiple(feature, script, language)
                .concat(this.getLigatures(feature, script, language));
        case 'stch':
            return this.getMultiple(feature, script, language);
    }
    return undefined;
};
Substitution.prototype.add = function(feature, sub, script, language) {
    if (/ss\d\d/.test(feature)) {
        return this.addSingle(feature, sub, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            if (typeof sub.by === 'number') {
                return this.addSingle(feature, sub, script, language);
            }
            return this.addAlternate(feature, sub, script, language);
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.addLigature(feature, sub, script, language);
        case 'ccmp':
            if (sub.by instanceof Array) {
                return this.addMultiple(feature, sub, script, language);
            }
            return this.addLigature(feature, sub, script, language);
    }
    return undefined;
};
function isBrowser() {
    return typeof window !== 'undefined';
}
function nodeBufferToArrayBuffer(buffer) {
    var ab = new ArrayBuffer(buffer.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        view[i] = buffer[i];
    }
    return ab;
}
function arrayBufferToNodeBuffer(ab) {
    var buffer = new Buffer(ab.byteLength);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
    }
    return buffer;
}
function checkArgument(expression, message) {
    if (!expression) {
        throw message;
    }
}
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        v = p.parseByte();
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }
        v = previousValue + v;
    } else {
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            v = previousValue + p.parseShort();
        }
    }
    return v;
}
function parseGlyph(glyph, data, start) {
    var p = new parse.Parser(data, start);
    glyph.numberOfContours = p.parseShort();
    glyph._xMin = p.parseShort();
    glyph._yMin = p.parseShort();
    glyph._xMax = p.parseShort();
    glyph._yMax = p.parseShort();
    var flags;
    var flag;
    if (glyph.numberOfContours > 0) {
        var endPointIndices = glyph.endPointIndices = [];
        for (var i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }
        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
            glyph.instructions.push(p.parseByte());
        }
        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
            flag = p.parseByte();
            flags.push(flag);
            if ((flag & 8) > 0) {
                var repeatCount = p.parseByte();
                for (var j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i$2 += 1;
                }
            }
        }
        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');
        if (endPointIndices.length > 0) {
            var points = [];
            var point;
            if (numberOfCoordinates > 0) {
                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
                    flag = flags[i$3];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
                    points.push(point);
                }
                var px = 0;
                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
                    flag = flags[i$4];
                    point = points[i$4];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }
                var py = 0;
                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
                    flag = flags[i$5];
                    point = points[i$5];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }
            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        var moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            var component = {
                glyphIndex: p.parseUShort(),
                xScale: 1,
                scale01: 0,
                scale10: 0,
                yScale: 1,
                dx: 0,
                dy: 0
            };
            if ((flags & 1) > 0) {
                if ((flags & 2) > 0) {
                    component.dx = p.parseShort();
                    component.dy = p.parseShort();
                } else {
                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
                }
            } else {
                if ((flags & 2) > 0) {
                    component.dx = p.parseChar();
                    component.dy = p.parseChar();
                } else {
                    component.matchedPoints = [p.parseByte(), p.parseByte()];
                }
            }
            if ((flags & 8) > 0) {
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }
            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
        if (flags & 0x100) {
            glyph.instructionLength = p.parseUShort();
            glyph.instructions = [];
            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
                glyph.instructions.push(p.parseByte());
            }
        }
    }
}
function transformPoints(points, transform) {
    var newPoints = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        var newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }
    return newPoints;
}
function getContours(points) {
    var contours = [];
    var currentContour = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}
function getPath(points) {
    var p = new Path();
    if (!points) {
        return p;
    }
    var contours = getContours(points);
    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
        var contour = contours[contourIndex];
        var prev = null;
        var curr = contour[contour.length - 1];
        var next = contour[0];
        if (curr.onCurve) {
            p.moveTo(curr.x, curr.y);
        } else {
            if (next.onCurve) {
                p.moveTo(next.x, next.y);
            } else {
                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
                p.moveTo(start.x, start.y);
            }
        }
        for (var i = 0; i < contour.length; ++i) {
            prev = curr;
            curr = next;
            next = contour[(i + 1) % contour.length];
            if (curr.onCurve) {
                p.lineTo(curr.x, curr.y);
            } else {
                var next2 = next;
                if (!prev.onCurve) {
                    ({ x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 });
                }
                if (!next.onCurve) {
                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
                }
                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
            }
        }
        p.closePath();
    }
    return p;
}
function buildPath(glyphs, glyph) {
    if (glyph.isComposite) {
        for (var j = 0; j < glyph.components.length; j += 1) {
            var component = glyph.components[j];
            var componentGlyph = glyphs.get(component.glyphIndex);
            componentGlyph.getPath();
            if (componentGlyph.points) {
                var transformedPoints = (void 0);
                if (component.matchedPoints === undefined) {
                    transformedPoints = transformPoints(componentGlyph.points, component);
                } else {
                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
                        throw Error('Matched points out of range in ' + glyph.name);
                    }
                    var firstPt = glyph.points[component.matchedPoints[0]];
                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
                    var transform = {
                        xScale: component.xScale, scale01: component.scale01,
                        scale10: component.scale10, yScale: component.yScale,
                        dx: 0, dy: 0
                    };
                    secondPt = transformPoints([secondPt], transform)[0];
                    transform.dx = firstPt.x - secondPt.x;
                    transform.dy = firstPt.y - secondPt.y;
                    transformedPoints = transformPoints(componentGlyph.points, transform);
                }
                glyph.points = glyph.points.concat(transformedPoints);
            }
        }
    }
    return getPath(glyph.points);
}
function parseGlyfTableAll(data, start, loca, font) {
    var glyphs = new glyphset.GlyphSet(font);
    for (var i = 0; i < loca.length - 1; i += 1) {
        var offset = loca[i];
        var nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
        } else {
            glyphs.push(i, glyphset.glyphLoader(font, i));
        }
    }
    return glyphs;
}
function parseGlyfTableOnLowMemory(data, start, loca, font) {
    var glyphs = new glyphset.GlyphSet(font);
    font._push = function(i) {
        var offset = loca[i];
        var nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
        } else {
            glyphs.push(i, glyphset.glyphLoader(font, i));
        }
    };
    return glyphs;
}
function parseGlyfTable(data, start, loca, font, opt) {
    if (opt.lowMemory)
        { return parseGlyfTableOnLowMemory(data, start, loca, font); }
    else
        { return parseGlyfTableAll(data, start, loca, font); }
}
var glyf = { getPath: getPath, parse: parseGlyfTable};
var instructionTable;
var exec;
var execGlyph;
var execComponent;
function Hinting(font) {
    this.font = font;
    this.getCommands = function (hPoints) {
        return glyf.getPath(hPoints).commands;
    };
    this._fpgmState  =
    this._prepState  =
        undefined;
    this._errorState = 0;
}
function roundOff(v) {
    return v;
}
function roundToGrid(v) {
    return Math.sign(v) * Math.round(Math.abs(v));
}
function roundToDoubleGrid(v) {
    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
}
function roundToHalfGrid(v) {
    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}
function roundUpToGrid(v) {
    return Math.sign(v) * Math.ceil(Math.abs(v));
}
function roundDownToGrid(v) {
    return Math.sign(v) * Math.floor(Math.abs(v));
}
var roundSuper = function (v) {
    var period = this.srPeriod;
    var phase = this.srPhase;
    var threshold = this.srThreshold;
    var sign = 1;
    if (v < 0) {
        v = -v;
        sign = -1;
    }
    v += threshold - phase;
    v = Math.trunc(v / period) * period;
    v += phase;
    if (v < 0) { return phase * sign; }
    return v * sign;
};
var xUnitVector = {
    x: 1,
    y: 0,
    axis: 'x',
    distance: function (p1, p2, o1, o2) {
        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
    },
    interpolate: function (p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;
        if (!pv || pv === this) {
            do1 = p.xo - rp1.xo;
            do2 = p.xo - rp2.xo;
            dm1 = rp1.x - rp1.xo;
            dm2 = rp2.x - rp2.xo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;
            if (dt === 0) {
                p.x = p.xo + (dm1 + dm2) / 2;
                return;
            }
            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }
        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;
        if (dt === 0) {
            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }
        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },
    normalSlope: Number.NEGATIVE_INFINITY,
    setRelative: function (p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.x = (org ? rp.xo : rp.x) + d;
            return;
        }
        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;
        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
    },
    slope: 0,
    touch: function (p) {
        p.xTouched = true;
    },
    touched: function (p) {
        return p.xTouched;
    },
    untouch: function (p) {
        p.xTouched = false;
    }
};
var yUnitVector = {
    x: 0,
    y: 1,
    axis: 'y',
    distance: function (p1, p2, o1, o2) {
        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
    },
    interpolate: function (p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;
        if (!pv || pv === this) {
            do1 = p.yo - rp1.yo;
            do2 = p.yo - rp2.yo;
            dm1 = rp1.y - rp1.yo;
            dm2 = rp2.y - rp2.yo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;
            if (dt === 0) {
                p.y = p.yo + (dm1 + dm2) / 2;
                return;
            }
            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }
        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;
        if (dt === 0) {
            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }
        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },
    normalSlope: 0,
    setRelative: function (p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.y = (org ? rp.yo : rp.y) + d;
            return;
        }
        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;
        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
    },
    slope: Number.POSITIVE_INFINITY,
    touch: function (p) {
        p.yTouched = true;
    },
    touched: function (p) {
        return p.yTouched;
    },
    untouch: function (p) {
        p.yTouched = false;
    }
};
Object.freeze(xUnitVector);
Object.freeze(yUnitVector);
function UnitVector(x, y) {
    this.x = x;
    this.y = y;
    this.axis = undefined;
    this.slope = y / x;
    this.normalSlope = -x / y;
    Object.freeze(this);
}
UnitVector.prototype.distance = function(p1, p2, o1, o2) {
    return (
        this.x * xUnitVector.distance(p1, p2, o1, o2) +
        this.y * yUnitVector.distance(p1, p2, o1, o2)
    );
};
UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
    var dm1;
    var dm2;
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dt;
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
        return;
    }
    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};
UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
    pv = pv || this;
    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;
    var pvns = pv.normalSlope;
    var fvs = this.slope;
    var px = p.x;
    var py = p.y;
    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
    p.y = fvs * (p.x - px) + py;
};
UnitVector.prototype.touch = function(p) {
    p.xTouched = true;
    p.yTouched = true;
};
function getUnitVector(x, y) {
    var d = Math.sqrt(x * x + y * y);
    x /= d;
    y /= d;
    if (x === 1 && y === 0) { return xUnitVector; }
    else if (x === 0 && y === 1) { return yUnitVector; }
    else { return new UnitVector(x, y); }
}
function HPoint(
    x,
    y,
    lastPointOfContour,
    onCurve
) {
    this.x = this.xo = Math.round(x * 64) / 64;
    this.y = this.yo = Math.round(y * 64) / 64;
    this.lastPointOfContour = lastPointOfContour;
    this.onCurve = onCurve;
    this.prevPointOnContour = undefined;
    this.nextPointOnContour = undefined;
    this.xTouched = false;
    this.yTouched = false;
    Object.preventExtensions(this);
}
HPoint.prototype.nextTouched = function(v) {
    var p = this.nextPointOnContour;
    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }
    return p;
};
HPoint.prototype.prevTouched = function(v) {
    var p = this.prevPointOnContour;
    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }
    return p;
};
var HPZero = Object.freeze(new HPoint(0, 0));
var defaultState = {
    cvCutIn: 17 / 16,
    deltaBase: 9,
    deltaShift: 0.125,
    loop: 1,
    minDis: 1,
    autoFlip: true
};
function State(env, prog) {
    this.env = env;
    this.stack = [];
    this.prog = prog;
    switch (env) {
        case 'glyf' :
            this.zp0 = this.zp1 = this.zp2 = 1;
            this.rp0 = this.rp1 = this.rp2 = 0;
        case 'prep' :
            this.fv = this.pv = this.dpv = xUnitVector;
            this.round = roundToGrid;
    }
}
Hinting.prototype.exec = function(glyph, ppem) {
    if (typeof ppem !== 'number') {
        throw new Error('Point size is not a number!');
    }
    if (this._errorState > 2) { return; }
    var font = this.font;
    var prepState = this._prepState;
    if (!prepState || prepState.ppem !== ppem) {
        var fpgmState = this._fpgmState;
        if (!fpgmState) {
            State.prototype = defaultState;
            fpgmState =
            this._fpgmState =
                new State('fpgm', font.tables.fpgm);
            fpgmState.funcs = [ ];
            fpgmState.font = font;
            if (exports.DEBUG) {
                console.log('---EXEC FPGM---');
                fpgmState.step = -1;
            }
            try {
                exec(fpgmState);
            } catch (e) {
                console.log('Hinting error in FPGM:' + e);
                this._errorState = 3;
                return;
            }
        }
        State.prototype = fpgmState;
        prepState =
        this._prepState =
            new State('prep', font.tables.prep);
        prepState.ppem = ppem;
        var oCvt = font.tables.cvt;
        if (oCvt) {
            var cvt = prepState.cvt = new Array(oCvt.length);
            var scale = ppem / font.unitsPerEm;
            for (var c = 0; c < oCvt.length; c++) {
                cvt[c] = oCvt[c] * scale;
            }
        } else {
            prepState.cvt = [];
        }
        if (exports.DEBUG) {
            console.log('---EXEC PREP---');
            prepState.step = -1;
        }
        try {
            exec(prepState);
        } catch (e) {
            if (this._errorState < 2) {
                console.log('Hinting error in PREP:' + e);
            }
            this._errorState = 2;
        }
    }
    if (this._errorState > 1) { return; }
    try {
        return execGlyph(glyph, prepState);
    } catch (e) {
        if (this._errorState < 1) {
            console.log('Hinting error:' + e);
            console.log('Note: further hinting errors are silenced');
        }
        this._errorState = 1;
        return undefined;
    }
};
execGlyph = function(glyph, prepState) {
    var xScale = prepState.ppem / prepState.font.unitsPerEm;
    var yScale = xScale;
    var components = glyph.components;
    var contours;
    var gZone;
    var state;
    State.prototype = prepState;
    if (!components) {
        state = new State('glyf', glyph.instructions);
        if (exports.DEBUG) {
            console.log('---EXEC GLYPH---');
            state.step = -1;
        }
        execComponent(glyph, state, xScale, yScale);
        gZone = state.gZone;
    } else {
        var font = prepState.font;
        gZone = [];
        contours = [];
        for (var i = 0; i < components.length; i++) {
            var c = components[i];
            var cg = font.glyphs.get(c.glyphIndex);
            state = new State('glyf', cg.instructions);
            if (exports.DEBUG) {
                console.log('---EXEC COMP ' + i + '---');
                state.step = -1;
            }
            execComponent(cg, state, xScale, yScale);
            var dx = Math.round(c.dx * xScale);
            var dy = Math.round(c.dy * yScale);
            var gz = state.gZone;
            var cc = state.contours;
            for (var pi = 0; pi < gz.length; pi++) {
                var p = gz[pi];
                p.xTouched = p.yTouched = false;
                p.xo = p.x = p.x + dx;
                p.yo = p.y = p.y + dy;
            }
            var gLen = gZone.length;
            gZone.push.apply(gZone, gz);
            for (var j = 0; j < cc.length; j++) {
                contours.push(cc[j] + gLen);
            }
        }
        if (glyph.instructions && !state.inhibitGridFit) {
            state = new State('glyf', glyph.instructions);
            state.gZone = state.z0 = state.z1 = state.z2 = gZone;
            state.contours = contours;
            gZone.push(
                new HPoint(0, 0),
                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
            );
            if (exports.DEBUG) {
                console.log('---EXEC COMPOSITE---');
                state.step = -1;
            }
            exec(state);
            gZone.length -= 2;
        }
    }
    return gZone;
};
execComponent = function(glyph, state, xScale, yScale)
{
    var points = glyph.points || [];
    var pLen = points.length;
    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
    var contours = state.contours = [];
    var cp;
    for (var i = 0; i < pLen; i++) {
        cp = points[i];
        gZone[i] = new HPoint(
            cp.x * xScale,
            cp.y * yScale,
            cp.lastPointOfContour,
            cp.onCurve
        );
    }
    var sp;
    var np;
    for (var i$1 = 0; i$1 < pLen; i$1++) {
        cp = gZone[i$1];
        if (!sp) {
            sp = cp;
            contours.push(i$1);
        }
        if (cp.lastPointOfContour) {
            cp.nextPointOnContour = sp;
            sp.prevPointOnContour = cp;
            sp = undefined;
        } else {
            np = gZone[i$1 + 1];
            cp.nextPointOnContour = np;
            np.prevPointOnContour = cp;
        }
    }
    if (state.inhibitGridFit) { return; }
    if (exports.DEBUG) {
        console.log('PROCESSING GLYPH', state.stack);
        for (var i$2 = 0; i$2 < pLen; i$2++) {
            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
        }
    }
    gZone.push(
        new HPoint(0, 0),
        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
    );
    exec(state);
    gZone.length -= 2;
    if (exports.DEBUG) {
        console.log('FINISHED GLYPH', state.stack);
        for (var i$3 = 0; i$3 < pLen; i$3++) {
            console.log(i$3, gZone[i$3].x, gZone[i$3].y);
        }
    }
};
exec = function(state) {
    var prog = state.prog;
    if (!prog) { return; }
    var pLen = prog.length;
    var ins;
    for (state.ip = 0; state.ip < pLen; state.ip++) {
        if (exports.DEBUG) { state.step++; }
        ins = instructionTable[prog[state.ip]];
        if (!ins) {
            throw new Error(
                'unknown instruction: 0x' +
                Number(prog[state.ip]).toString(16)
            );
        }
        ins(state);
    }
};
function initTZone(state)
{
    var tZone = state.tZone = new Array(state.gZone.length);
    for (var i = 0; i < tZone.length; i++)
    {
        tZone[i] = new HPoint(0, 0);
    }
}
function skip(state, handleElse)
{
    var prog = state.prog;
    var ip = state.ip;
    var nesting = 1;
    var ins;
    do {
        ins = prog[++ip];
        if (ins === 0x58)
            { nesting++; }
        else if (ins === 0x59)
            { nesting--; }
        else if (ins === 0x40)
            { ip += prog[ip + 1] + 1; }
        else if (ins === 0x41)
            { ip += 2 * prog[ip + 1] + 1; }
        else if (ins >= 0xB0 && ins <= 0xB7)
            { ip += ins - 0xB0 + 1; }
        else if (ins >= 0xB8 && ins <= 0xBF)
            { ip += (ins - 0xB8 + 1) * 2; }
        else if (handleElse && nesting === 1 && ins === 0x1B)
            { break; }
    } while (nesting > 0);
    state.ip = ip;
}
function SVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }
    state.fv = state.pv = state.dpv = v;
}
function SPVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }
    state.pv = state.dpv = v;
}
function SFVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }
    state.fv = v;
}
function SPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];
    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }
    var dx;
    var dy;
    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }
    state.pv = state.dpv = getUnitVector(dx, dy);
}
function SFVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];
    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }
    var dx;
    var dy;
    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }
    state.fv = getUnitVector(dx, dy);
}
function SPVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }
    state.pv = state.dpv = getUnitVector(x, y);
}
function SFVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }
    state.fv = getUnitVector(x, y);
}
function GPV(state) {
    var stack = state.stack;
    var pv = state.pv;
    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }
    stack.push(pv.x * 0x4000);
    stack.push(pv.y * 0x4000);
}
function GFV(state) {
    var stack = state.stack;
    var fv = state.fv;
    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }
    stack.push(fv.x * 0x4000);
    stack.push(fv.y * 0x4000);
}
function SFVTPV(state) {
    state.fv = state.pv;
    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
}
function ISECT(state)
{
    var stack = state.stack;
    var pa0i = stack.pop();
    var pa1i = stack.pop();
    var pb0i = stack.pop();
    var pb1i = stack.pop();
    var pi = stack.pop();
    var z0 = state.z0;
    var z1 = state.z1;
    var pa0 = z0[pa0i];
    var pa1 = z0[pa1i];
    var pb0 = z1[pb0i];
    var pb1 = z1[pb1i];
    var p = state.z2[pi];
    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }
    var x1 = pa0.x;
    var y1 = pa0.y;
    var x2 = pa1.x;
    var y2 = pa1.y;
    var x3 = pb0.x;
    var y3 = pb0.y;
    var x4 = pb1.x;
    var y4 = pb1.y;
    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    var f1 = x1 * y2 - y1 * x2;
    var f2 = x3 * y4 - y3 * x4;
    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
}
function SRP0(state) {
    state.rp0 = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
}
function SRP1(state) {
    state.rp1 = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
}
function SRP2(state) {
    state.rp2 = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
}
function SZP0(state) {
    var n = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }
    state.zp0 = n;
    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z0 = state.tZone;
            break;
        case 1 :
            state.z0 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}
function SZP1(state) {
    var n = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }
    state.zp1 = n;
    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z1 = state.tZone;
            break;
        case 1 :
            state.z1 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}
function SZP2(state) {
    var n = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }
    state.zp2 = n;
    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z2 = state.tZone;
            break;
        case 1 :
            state.z2 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}
function SZPS(state) {
    var n = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }
    state.zp0 = state.zp1 = state.zp2 = n;
    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z0 = state.z1 = state.z2 = state.tZone;
            break;
        case 1 :
            state.z0 = state.z1 = state.z2 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}
function SLOOP(state) {
    state.loop = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
}
function RTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }
    state.round = roundToGrid;
}
function RTHG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }
    state.round = roundToHalfGrid;
}
function SMD(state) {
    var d = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }
    state.minDis = d / 0x40;
}
function ELSE(state) {
    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }
    skip(state, false);
}
function JMPR(state) {
    var o = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }
    state.ip += o - 1;
}
function SCVTCI(state) {
    var n = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }
    state.cvCutIn = n / 0x40;
}
function DUP(state) {
    var stack = state.stack;
    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }
    stack.push(stack[stack.length - 1]);
}
function POP(state) {
    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }
    state.stack.pop();
}
function CLEAR(state) {
    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }
    state.stack.length = 0;
}
function SWAP(state) {
    var stack = state.stack;
    var a = stack.pop();
    var b = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }
    stack.push(a);
    stack.push(b);
}
function DEPTH(state) {
    var stack = state.stack;
    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }
    stack.push(stack.length);
}
function LOOPCALL(state) {
    var stack = state.stack;
    var fn = stack.pop();
    var c = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }
    var cip = state.ip;
    var cprog = state.prog;
    state.prog = state.funcs[fn];
    for (var i = 0; i < c; i++) {
        exec(state);
        if (exports.DEBUG) { console.log(
            ++state.step,
            i + 1 < c ? 'next loopcall' : 'done loopcall',
            i
        ); }
    }
    state.ip = cip;
    state.prog = cprog;
}
function CALL(state) {
    var fn = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }
    var cip = state.ip;
    var cprog = state.prog;
    state.prog = state.funcs[fn];
    exec(state);
    state.ip = cip;
    state.prog = cprog;
    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
}
function CINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }
    stack.push(stack[stack.length - k]);
}
function MINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }
    stack.push(stack.splice(stack.length - k, 1)[0]);
}
function FDEF(state) {
    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;
    var fn = stack.pop();
    var ipBegin = ip;
    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }
    while (prog[++ip] !== 0x2D){ }
    state.ip = ip;
    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}
function MDAP(round, state) {
    var pi = state.stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;
    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }
    var d = pv.distance(p, HPZero);
    if (round) { d = state.round(d); }
    fv.setRelative(p, HPZero, d, pv);
    fv.touch(p);
    state.rp0 = state.rp1 = pi;
}
function IUP(v, state) {
    var z2 = state.z2;
    var pLen = z2.length - 2;
    var cp;
    var pp;
    var np;
    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }
    for (var i = 0; i < pLen; i++) {
        cp = z2[i];
        if (v.touched(cp)) { continue; }
        pp = cp.prevTouched(v);
        if (pp === cp) { continue; }
        np = cp.nextTouched(v);
        if (pp === np) {
            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
        }
        v.interpolate(cp, pp, np, v);
    }
}
function SHP(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var loop = state.loop;
    var z2 = state.z2;
    while (loop--)
    {
        var pi = stack.pop();
        var p = z2[pi];
        var d = pv.distance(rp, rp, false, true);
        fv.setRelative(p, p, d, pv);
        fv.touch(p);
        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ?
                   'loop ' + (state.loop - loop) + ': ' :
                   ''
                ) +
                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
            );
        }
    }
    state.loop = 1;
}
function SHC(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var ci = stack.pop();
    var sp = state.z2[state.contours[ci]];
    var p = sp;
    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }
    var d = pv.distance(rp, rp, false, true);
    do {
        if (p !== rp) { fv.setRelative(p, p, d, pv); }
        p = p.nextPointOnContour;
    } while (p !== sp);
}
function SHZ(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var e = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }
    var z;
    switch (e) {
        case 0 : z = state.tZone; break;
        case 1 : z = state.gZone; break;
        default : throw new Error('Invalid zone');
    }
    var p;
    var d = pv.distance(rp, rp, false, true);
    var pLen = z.length - 2;
    for (var i = 0; i < pLen; i++)
    {
        p = z[i];
        fv.setRelative(p, p, d, pv);
    }
}
function SHPIX(state) {
    var stack = state.stack;
    var loop = state.loop;
    var fv = state.fv;
    var d = stack.pop() / 0x40;
    var z2 = state.z2;
    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];
        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'SHPIX[]', pi, d
            );
        }
        fv.setRelative(p, p, d);
        fv.touch(p);
    }
    state.loop = 1;
}
function IP(state) {
    var stack = state.stack;
    var rp1i = state.rp1;
    var rp2i = state.rp2;
    var loop = state.loop;
    var rp1 = state.z0[rp1i];
    var rp2 = state.z1[rp2i];
    var fv = state.fv;
    var pv = state.dpv;
    var z2 = state.z2;
    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];
        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'IP[]', pi, rp1i, '<->', rp2i
            );
        }
        fv.interpolate(p, rp1, rp2, pv);
        fv.touch(p);
    }
    state.loop = 1;
}
function MSIRP(a, state) {
    var stack = state.stack;
    var d = stack.pop() / 64;
    var pi = stack.pop();
    var p = state.z1[pi];
    var rp0 = state.z0[state.rp0];
    var fv = state.fv;
    var pv = state.pv;
    fv.setRelative(p, rp0, d, pv);
    fv.touch(p);
    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }
    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (a) { state.rp0 = pi; }
}
function ALIGNRP(state) {
    var stack = state.stack;
    var rp0i = state.rp0;
    var rp0 = state.z0[rp0i];
    var loop = state.loop;
    var fv = state.fv;
    var pv = state.pv;
    var z1 = state.z1;
    while (loop--) {
        var pi = stack.pop();
        var p = z1[pi];
        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'ALIGNRP[]', pi
            );
        }
        fv.setRelative(p, rp0, 0, pv);
        fv.touch(p);
    }
    state.loop = 1;
}
function RTDG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }
    state.round = roundToDoubleGrid;
}
function MIAP(round, state) {
    var stack = state.stack;
    var n = stack.pop();
    var pi = stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;
    var cv = state.cvt[n];
    if (exports.DEBUG) {
        console.log(
            state.step,
            'MIAP[' + round + ']',
            n, '(', cv, ')', pi
        );
    }
    var d = pv.distance(p, HPZero);
    if (round) {
        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }
        d = state.round(d);
    }
    fv.setRelative(p, HPZero, d, pv);
    if (state.zp0 === 0) {
        p.xo = p.x;
        p.yo = p.y;
    }
    fv.touch(p);
    state.rp0 = state.rp1 = pi;
}
function NPUSHB(state) {
    var prog = state.prog;
    var ip = state.ip;
    var stack = state.stack;
    var n = prog[++ip];
    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }
    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }
    state.ip = ip;
}
function NPUSHW(state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;
    var n = prog[++ip];
    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }
    for (var i = 0; i < n; i++) {
        var w = (prog[++ip] << 8) | prog[++ip];
        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
        stack.push(w);
    }
    state.ip = ip;
}
function WS(state) {
    var stack = state.stack;
    var store = state.store;
    if (!store) { store = state.store = []; }
    var v = stack.pop();
    var l = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }
    store[l] = v;
}
function RS(state) {
    var stack = state.stack;
    var store = state.store;
    var l = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'RS', l); }
    var v = (store && store[l]) || 0;
    stack.push(v);
}
function WCVTP(state) {
    var stack = state.stack;
    var v = stack.pop();
    var l = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }
    state.cvt[l] = v / 0x40;
}
function RCVT(state) {
    var stack = state.stack;
    var cvte = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }
    stack.push(state.cvt[cvte] * 0x40);
}
function GC(a, state) {
    var stack = state.stack;
    var pi = stack.pop();
    var p = state.z2[pi];
    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }
    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
}
function MD(a, state) {
    var stack = state.stack;
    var pi2 = stack.pop();
    var pi1 = stack.pop();
    var p2 = state.z1[pi2];
    var p1 = state.z0[pi1];
    var d = state.dpv.distance(p1, p2, a, a);
    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }
    state.stack.push(Math.round(d * 64));
}
function MPPEM(state) {
    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
    state.stack.push(state.ppem);
}
function FLIPON(state) {
    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
    state.autoFlip = true;
}
function LT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }
    stack.push(e1 < e2 ? 1 : 0);
}
function LTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }
    stack.push(e1 <= e2 ? 1 : 0);
}
function GT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }
    stack.push(e1 > e2 ? 1 : 0);
}
function GTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }
    stack.push(e1 >= e2 ? 1 : 0);
}
function EQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }
    stack.push(e2 === e1 ? 1 : 0);
}
function NEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }
    stack.push(e2 !== e1 ? 1 : 0);
}
function ODD(state) {
    var stack = state.stack;
    var n = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }
    stack.push(Math.trunc(n) % 2 ? 1 : 0);
}
function EVEN(state) {
    var stack = state.stack;
    var n = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }
    stack.push(Math.trunc(n) % 2 ? 0 : 1);
}
function IF(state) {
    var test = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }
    if (!test) {
        skip(state, true);
        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }
    }
}
function EIF(state) {
    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
}
function AND(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }
    stack.push(e2 && e1 ? 1 : 0);
}
function OR(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }
    stack.push(e2 || e1 ? 1 : 0);
}
function NOT(state) {
    var stack = state.stack;
    var e = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }
    stack.push(e ? 0 : 1);
}
function DELTAP123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var fv = state.fv;
    var pv = state.pv;
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;
    var z0 = state.z0;
    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }
    for (var i = 0; i < n; i++) {
        var pi = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) { continue; }
        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) { mag++; }
        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }
        var p = z0[pi];
        fv.setRelative(p, p, mag * ds, pv);
    }
}
function SDB(state) {
    var stack = state.stack;
    var n = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }
    state.deltaBase = n;
}
function SDS(state) {
    var stack = state.stack;
    var n = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }
    state.deltaShift = Math.pow(0.5, n);
}
function ADD(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }
    stack.push(n1 + n2);
}
function SUB(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }
    stack.push(n1 - n2);
}
function DIV(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }
    stack.push(n1 * 64 / n2);
}
function MUL(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }
    stack.push(n1 * n2 / 64);
}
function ABS(state) {
    var stack = state.stack;
    var n = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }
    stack.push(Math.abs(n));
}
function NEG(state) {
    var stack = state.stack;
    var n = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }
    stack.push(-n);
}
function FLOOR(state) {
    var stack = state.stack;
    var n = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }
    stack.push(Math.floor(n / 0x40) * 0x40);
}
function CEILING(state) {
    var stack = state.stack;
    var n = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }
    stack.push(Math.ceil(n / 0x40) * 0x40);
}
function ROUND$1(dt, state) {
    var stack = state.stack;
    var n = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }
    stack.push(state.round(n / 0x40) * 0x40);
}
function WCVTF(state) {
    var stack = state.stack;
    var v = stack.pop();
    var l = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }
    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}
function DELTAC123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;
    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }
    for (var i = 0; i < n; i++) {
        var c = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) { continue; }
        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) { mag++; }
        var delta = mag * ds;
        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }
        state.cvt[c] += delta;
    }
}
function SROUND(state) {
    var n = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }
    state.round = roundSuper;
    var period;
    switch (n & 0xC0) {
        case 0x00:
            period = 0.5;
            break;
        case 0x40:
            period = 1;
            break;
        case 0x80:
            period = 2;
            break;
        default:
            throw new Error('invalid SROUND value');
    }
    state.srPeriod = period;
    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5  * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default: throw new Error('invalid SROUND value');
    }
    n &= 0x0F;
    if (n === 0) { state.srThreshold = 0; }
    else { state.srThreshold = (n / 8 - 0.5) * period; }
}
function S45ROUND(state) {
    var n = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }
    state.round = roundSuper;
    var period;
    switch (n & 0xC0) {
        case 0x00:
            period = Math.sqrt(2) / 2;
            break;
        case 0x40:
            period = Math.sqrt(2);
            break;
        case 0x80:
            period = 2 * Math.sqrt(2);
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }
    state.srPeriod = period;
    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5  * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }
    n &= 0x0F;
    if (n === 0) { state.srThreshold = 0; }
    else { state.srThreshold = (n / 8 - 0.5) * period; }
}
function ROFF(state) {
    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }
    state.round = roundOff;
}
function RUTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }
    state.round = roundUpToGrid;
}
function RDTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }
    state.round = roundDownToGrid;
}
function SCANCTRL(state) {
    var n = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
}
function SDPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];
    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }
    var dx;
    var dy;
    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }
    state.dpv = getUnitVector(dx, dy);
}
function GETINFO(state) {
    var stack = state.stack;
    var sel = stack.pop();
    var r = 0;
    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }
    if (sel & 0x01) { r = 35; }
    if (sel & 0x20) { r |= 0x1000; }
    stack.push(r);
}
function ROLL(state) {
    var stack = state.stack;
    var a = stack.pop();
    var b = stack.pop();
    var c = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }
    stack.push(b);
    stack.push(a);
    stack.push(c);
}
function MAX(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }
    stack.push(Math.max(e1, e2));
}
function MIN(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }
    stack.push(Math.min(e1, e2));
}
function SCANTYPE(state) {
    var n = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
}
function INSTCTRL(state) {
    var s = state.stack.pop();
    var v = state.stack.pop();
    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }
    switch (s) {
        case 1 : state.inhibitGridFit = !!v; return;
        case 2 : state.ignoreCvt = !!v; return;
        default: throw new Error('invalid INSTCTRL[] selector');
    }
}
function PUSHB(n, state) {
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;
    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }
    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }
    state.ip = ip;
}
function PUSHW(n, state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;
    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }
    for (var i = 0; i < n; i++) {
        var w = (prog[++ip] << 8) | prog[++ip];
        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
        stack.push(w);
    }
    state.ip = ip;
}
function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
    var stack = state.stack;
    var cvte = indirect && stack.pop();
    var pi = stack.pop();
    var rp0i = state.rp0;
    var rp = state.z0[rp0i];
    var p = state.z1[pi];
    var md = state.minDis;
    var fv = state.fv;
    var pv = state.dpv;
    var od;
    var d;
    var sign;
    var cv;
    d = od = pv.distance(p, rp, true, true);
    sign = d >= 0 ? 1 : -1;
    d = Math.abs(d);
    if (indirect) {
        cv = state.cvt[cvte];
        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
    }
    if (keepD && d < md) { d = md; }
    if (ro) { d = state.round(d); }
    fv.setRelative(p, rp, sign * d, pv);
    fv.touch(p);
    if (exports.DEBUG) {
        console.log(
            state.step,
            (indirect ? 'MIRP[' : 'MDRP[') +
            (setRp0 ? 'M' : 'm') +
            (keepD ? '>' : '_') +
            (ro ? 'R' : '_') +
            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
            ']',
            indirect ?
                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
                '',
            pi,
            '(d =', od, '->', sign * d, ')'
        );
    }
    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (setRp0) { state.rp0 = pi; }
}
instructionTable = [
     SVTCA.bind(undefined, yUnitVector),
     SVTCA.bind(undefined, xUnitVector),
     SPVTCA.bind(undefined, yUnitVector),
     SPVTCA.bind(undefined, xUnitVector),
     SFVTCA.bind(undefined, yUnitVector),
     SFVTCA.bind(undefined, xUnitVector),
     SPVTL.bind(undefined, 0),
     SPVTL.bind(undefined, 1),
     SFVTL.bind(undefined, 0),
     SFVTL.bind(undefined, 1),
     SPVFS,
     SFVFS,
     GPV,
     GFV,
     SFVTPV,
     ISECT,
     SRP0,
     SRP1,
     SRP2,
     SZP0,
     SZP1,
     SZP2,
     SZPS,
     SLOOP,
     RTG,
     RTHG,
     SMD,
     ELSE,
     JMPR,
     SCVTCI,
     undefined,
     undefined,
     DUP,
     POP,
     CLEAR,
     SWAP,
     DEPTH,
     CINDEX,
     MINDEX,
     undefined,
     undefined,
     undefined,
     LOOPCALL,
     CALL,
     FDEF,
     undefined,
     MDAP.bind(undefined, 0),
     MDAP.bind(undefined, 1),
     IUP.bind(undefined, yUnitVector),
     IUP.bind(undefined, xUnitVector),
     SHP.bind(undefined, 0),
     SHP.bind(undefined, 1),
     SHC.bind(undefined, 0),
     SHC.bind(undefined, 1),
     SHZ.bind(undefined, 0),
     SHZ.bind(undefined, 1),
     SHPIX,
     IP,
     MSIRP.bind(undefined, 0),
     MSIRP.bind(undefined, 1),
     ALIGNRP,
     RTDG,
     MIAP.bind(undefined, 0),
     MIAP.bind(undefined, 1),
     NPUSHB,
     NPUSHW,
     WS,
     RS,
     WCVTP,
     RCVT,
     GC.bind(undefined, 0),
     GC.bind(undefined, 1),
     undefined,
     MD.bind(undefined, 0),
     MD.bind(undefined, 1),
     MPPEM,
     undefined,
     FLIPON,
     undefined,
     undefined,
     LT,
     LTEQ,
     GT,
     GTEQ,
     EQ,
     NEQ,
     ODD,
     EVEN,
     IF,
     EIF,
     AND,
     OR,
     NOT,
     DELTAP123.bind(undefined, 1),
     SDB,
     SDS,
     ADD,
     SUB,
     DIV,
     MUL,
     ABS,
     NEG,
     FLOOR,
     CEILING,
     ROUND$1.bind(undefined, 0),
     ROUND$1.bind(undefined, 1),
     ROUND$1.bind(undefined, 2),
     ROUND$1.bind(undefined, 3),
     undefined,
     undefined,
     undefined,
     undefined,
     WCVTF,
     DELTAP123.bind(undefined, 2),
     DELTAP123.bind(undefined, 3),
     DELTAC123.bind(undefined, 1),
     DELTAC123.bind(undefined, 2),
     DELTAC123.bind(undefined, 3),
     SROUND,
     S45ROUND,
     undefined,
     undefined,
     ROFF,
     undefined,
     RUTG,
     RDTG,
     POP,
     POP,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     SCANCTRL,
     SDPVTL.bind(undefined, 0),
     SDPVTL.bind(undefined, 1),
     GETINFO,
     undefined,
     ROLL,
     MAX,
     MIN,
     SCANTYPE,
     INSTCTRL,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     undefined,
     PUSHB.bind(undefined, 1),
     PUSHB.bind(undefined, 2),
     PUSHB.bind(undefined, 3),
     PUSHB.bind(undefined, 4),
     PUSHB.bind(undefined, 5),
     PUSHB.bind(undefined, 6),
     PUSHB.bind(undefined, 7),
     PUSHB.bind(undefined, 8),
     PUSHW.bind(undefined, 1),
     PUSHW.bind(undefined, 2),
     PUSHW.bind(undefined, 3),
     PUSHW.bind(undefined, 4),
     PUSHW.bind(undefined, 5),
     PUSHW.bind(undefined, 6),
     PUSHW.bind(undefined, 7),
     PUSHW.bind(undefined, 8),
     MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
     MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
     MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
     MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
     MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
     MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
     MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
     MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
     MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
     MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
     MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
     MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
     MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
     MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
     MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
     MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
     MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
     MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
     MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
     MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
     MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
     MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
     MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
     MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
     MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
     MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
     MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
     MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
     MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
     MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
     MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
     MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
     MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
     MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
     MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
     MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
     MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
     MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
     MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
     MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
     MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
     MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
     MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
     MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
     MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
     MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
     MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
     MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
     MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
     MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
     MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
     MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
     MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
     MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
     MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
     MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
     MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
     MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
     MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
     MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
     MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
     MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
     MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
     MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
];
function Token(char) {
    this.char = char;
    this.state = {};
    this.activeState = null;
}
function ContextRange(startIndex, endOffset, contextName) {
    this.contextName = contextName;
    this.startIndex = startIndex;
    this.endOffset = endOffset;
}
function ContextChecker(contextName, checkStart, checkEnd) {
    this.contextName = contextName;
    this.openRange = null;
    this.ranges = [];
    this.checkStart = checkStart;
    this.checkEnd = checkEnd;
}
function ContextParams(context, currentIndex) {
    this.context = context;
    this.index = currentIndex;
    this.length = context.length;
    this.current = context[currentIndex];
    this.backtrack = context.slice(0, currentIndex);
    this.lookahead = context.slice(currentIndex + 1);
}
function Event(eventId) {
    this.eventId = eventId;
    this.subscribers = [];
}
function initializeCoreEvents(events) {
    var this$1$1 = this;
    var coreEvents = [
        'start', 'end', 'next', 'newToken', 'contextStart',
        'contextEnd', 'insertToken', 'removeToken', 'removeRange',
        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'
    ];
    coreEvents.forEach(function (eventId) {
        Object.defineProperty(this$1$1.events, eventId, {
            value: new Event(eventId)
        });
    });
    if (!!events) {
        coreEvents.forEach(function (eventId) {
            var event = events[eventId];
            if (typeof event === 'function') {
                this$1$1.events[eventId].subscribe(event);
            }
        });
    }
    var requiresContextUpdate = [
        'insertToken', 'removeToken', 'removeRange',
        'replaceToken', 'replaceRange', 'composeRUD'
    ];
    requiresContextUpdate.forEach(function (eventId) {
        this$1$1.events[eventId].subscribe(
            this$1$1.updateContextsRanges
        );
    });
}
function Tokenizer(events) {
    this.tokens = [];
    this.registeredContexts = {};
    this.contextCheckers = [];
    this.events = {};
    this.registeredModifiers = [];
    initializeCoreEvents.call(this, events);
}
Token.prototype.setState = function(key, value) {
    this.state[key] = value;
    this.activeState = { key: key, value: this.state[key] };
    return this.activeState;
};
Token.prototype.getState = function (stateId) {
    return this.state[stateId] || null;
};
Tokenizer.prototype.inboundIndex = function(index) {
    return index >= 0 && index < this.tokens.length;
};
Tokenizer.prototype.composeRUD = function (RUDs) {
    var this$1$1 = this;
    var silent = true;
    var state = RUDs.map(function (RUD) { return (
        this$1$1[RUD[0]].apply(this$1$1, RUD.slice(1).concat(silent))
    ); });
    var hasFAILObject = function (obj) { return (
        typeof obj === 'object' &&
        obj.hasOwnProperty('FAIL')
    ); };
    if (state.every(hasFAILObject)) {
        return {
            FAIL: "composeRUD: one or more operations hasn't completed successfully",
            report: state.filter(hasFAILObject)
        };
    }
    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);
};
Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {
    offset = offset !== null ? offset : this.tokens.length;
    var isTokenType = tokens.every(function (token) { return token instanceof Token; });
    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
        var replaced = this.tokens.splice.apply(
            this.tokens, [startIndex, offset].concat(tokens)
        );
        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }
        return [replaced, tokens];
    } else {
        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };
    }
};
Tokenizer.prototype.replaceToken = function (index, token, silent) {
    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
        var replaced = this.tokens.splice(index, 1, token);
        if (!silent) { this.dispatch('replaceToken', [index, token]); }
        return [replaced[0], token];
    } else {
        return { FAIL: 'replaceToken: invalid token or index.' };
    }
};
Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
    offset = !isNaN(offset) ? offset : this.tokens.length;
    var tokens = this.tokens.splice(startIndex, offset);
    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }
    return tokens;
};
Tokenizer.prototype.removeToken = function(index, silent) {
    if (!isNaN(index) && this.inboundIndex(index)) {
        var token = this.tokens.splice(index, 1);
        if (!silent) { this.dispatch('removeToken', [token, index]); }
        return token;
    } else {
        return { FAIL: 'removeToken: invalid token index.' };
    }
};
Tokenizer.prototype.insertToken = function (tokens, index, silent) {
    var tokenType = tokens.every(
        function (token) { return token instanceof Token; }
    );
    if (tokenType) {
        this.tokens.splice.apply(
            this.tokens, [index, 0].concat(tokens)
        );
        if (!silent) { this.dispatch('insertToken', [tokens, index]); }
        return tokens;
    } else {
        return { FAIL: 'insertToken: invalid token(s).' };
    }
};
Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
    this.events.newToken.subscribe(function(token, contextParams) {
        var conditionParams = [token, contextParams];
        var canApplyModifier = (
            condition === null ||
            condition.apply(this, conditionParams) === true
        );
        var modifierParams = [token, contextParams];
        if (canApplyModifier) {
            var newStateValue = modifier.apply(this, modifierParams);
            token.setState(modifierId, newStateValue);
        }
    });
    this.registeredModifiers.push(modifierId);
};
Event.prototype.subscribe = function (eventHandler) {
    if (typeof eventHandler === 'function') {
        return ((this.subscribers.push(eventHandler)) - 1);
    } else {
        return { FAIL: ("invalid '" + (this.eventId) + "' event handler")};
    }
};
Event.prototype.unsubscribe = function (subsId) {
    this.subscribers.splice(subsId, 1);
};
ContextParams.prototype.setCurrentIndex = function(index) {
    this.index = index;
    this.current = this.context[index];
    this.backtrack = this.context.slice(0, index);
    this.lookahead = this.context.slice(index + 1);
};
ContextParams.prototype.get = function (offset) {
    switch (true) {
        case (offset === 0):
            return this.current;
        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
            return this.backtrack.slice(offset)[0];
        case (offset > 0 && offset <= this.lookahead.length):
            return this.lookahead[offset - 1];
        default:
            return null;
    }
};
Tokenizer.prototype.rangeToText = function (range) {
    if (range instanceof ContextRange) {
        return (
            this.getRangeTokens(range)
                .map(function (token) { return token.char; }).join('')
        );
    }
};
Tokenizer.prototype.getText = function () {
    return this.tokens.map(function (token) { return token.char; }).join('');
};
Tokenizer.prototype.getContext = function (contextName) {
    var context = this.registeredContexts[contextName];
    return !!context ? context : null;
};
Tokenizer.prototype.on = function(eventName, eventHandler) {
    var event = this.events[eventName];
    if (!!event) {
        return event.subscribe(eventHandler);
    } else {
        return null;
    }
};
Tokenizer.prototype.dispatch = function(eventName, args) {
    var this$1$1 = this;
    var event = this.events[eventName];
    if (event instanceof Event) {
        event.subscribers.forEach(function (subscriber) {
            subscriber.apply(this$1$1, args || []);
        });
    }
};
Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
    if (!!this.getContext(contextName)) { return {
        FAIL:
        ("context name '" + contextName + "' is already registered.")
    }; }
    if (typeof contextStartCheck !== 'function') { return {
        FAIL:
        "missing context start check."
    }; }
    if (typeof contextEndCheck !== 'function') { return {
        FAIL:
        "missing context end check."
    }; }
    var contextCheckers = new ContextChecker(
        contextName, contextStartCheck, contextEndCheck
    );
    this.registeredContexts[contextName] = contextCheckers;
    this.contextCheckers.push(contextCheckers);
    return contextCheckers;
};
Tokenizer.prototype.getRangeTokens = function(range) {
    var endIndex = range.startIndex + range.endOffset;
    return [].concat(
        this.tokens
            .slice(range.startIndex, endIndex)
    );
};
Tokenizer.prototype.getContextRanges = function(contextName) {
    var context = this.getContext(contextName);
    if (!!context) {
        return context.ranges;
    } else {
        return { FAIL: ("context checker '" + contextName + "' is not registered.") };
    }
};
Tokenizer.prototype.resetContextsRanges = function () {
    var registeredContexts = this.registeredContexts;
    for (var contextName in registeredContexts) {
        if (registeredContexts.hasOwnProperty(contextName)) {
            var context = registeredContexts[contextName];
            context.ranges = [];
        }
    }
};
Tokenizer.prototype.updateContextsRanges = function () {
    this.resetContextsRanges();
    var chars = this.tokens.map(function (token) { return token.char; });
    for (var i = 0; i < chars.length; i++) {
        var contextParams = new ContextParams(chars, i);
        this.runContextCheck(contextParams);
    }
    this.dispatch('updateContextsRanges', [this.registeredContexts]);
};
Tokenizer.prototype.setEndOffset = function (offset, contextName) {
    var startIndex = this.getContext(contextName).openRange.startIndex;
    var range = new ContextRange(startIndex, offset, contextName);
    var ranges = this.getContext(contextName).ranges;
    range.rangeId = contextName + "." + (ranges.length);
    ranges.push(range);
    this.getContext(contextName).openRange = null;
    return range;
};
Tokenizer.prototype.runContextCheck = function(contextParams) {
    var this$1$1 = this;
    var index = contextParams.index;
    this.contextCheckers.forEach(function (contextChecker) {
        var contextName = contextChecker.contextName;
        var openRange = this$1$1.getContext(contextName).openRange;
        if (!openRange && contextChecker.checkStart(contextParams)) {
            openRange = new ContextRange(index, null, contextName);
            this$1$1.getContext(contextName).openRange = openRange;
            this$1$1.dispatch('contextStart', [contextName, index]);
        }
        if (!!openRange && contextChecker.checkEnd(contextParams)) {
            var offset = (index - openRange.startIndex) + 1;
            var range = this$1$1.setEndOffset(offset, contextName);
            this$1$1.dispatch('contextEnd', [contextName, range]);
        }
    });
};
Tokenizer.prototype.tokenize = function (text) {
    this.tokens = [];
    this.resetContextsRanges();
    var chars = Array.from(text);
    this.dispatch('start');
    for (var i = 0; i < chars.length; i++) {
        var char = chars[i];
        var contextParams = new ContextParams(chars, i);
        this.dispatch('next', [contextParams]);
        this.runContextCheck(contextParams);
        var token = new Token(char);
        this.tokens.push(token);
        this.dispatch('newToken', [token, contextParams]);
    }
    this.dispatch('end', [this.tokens]);
    return this.tokens;
};
function isArabicChar(c) {
    return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
}
function isIsolatedArabicChar(char) {
    return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
}
function isTashkeelArabicChar(char) {
    return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
}
function isLatinChar(c) {
    return /[A-z]/.test(c);
}
function isWhiteSpace$1(c) {
    return /\s/.test(c);
}
function FeatureQuery(font) {
    this.font = font;
    this.features = {};
}
function SubstitutionAction(action) {
    this.id = action.id;
    this.tag = action.tag;
    this.substitution = action.substitution;
}
function lookupCoverage(glyphIndex, coverage) {
    if (!glyphIndex) { return -1; }
    switch (coverage.format) {
        case 1:
            return coverage.glyphs.indexOf(glyphIndex);
        case 2:
            var ranges = coverage.ranges;
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (glyphIndex >= range.start && glyphIndex <= range.end) {
                    var offset = glyphIndex - range.start;
                    return range.index + offset;
                }
            }
            break;
        default:
            return -1;
    }
    return -1;
}
function singleSubstitutionFormat1(glyphIndex, subtable) {
    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
    if (substituteIndex === -1) { return null; }
    return glyphIndex + subtable.deltaGlyphId;
}
function singleSubstitutionFormat2(glyphIndex, subtable) {
    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
    if (substituteIndex === -1) { return null; }
    return subtable.substitute[substituteIndex];
}
function lookupCoverageList(coverageList, contextParams) {
    var lookupList = [];
    for (var i = 0; i < coverageList.length; i++) {
        var coverage = coverageList[i];
        var glyphIndex = contextParams.current;
        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
        var lookupIndex = lookupCoverage(glyphIndex, coverage);
        if (lookupIndex !== -1) {
            lookupList.push(lookupIndex);
        }
    }
    if (lookupList.length !== coverageList.length) { return -1; }
    return lookupList;
}
function chainingSubstitutionFormat3(contextParams, subtable) {
    var lookupsCount = (
        subtable.inputCoverage.length +
        subtable.lookaheadCoverage.length +
        subtable.backtrackCoverage.length
    );
    if (contextParams.context.length < lookupsCount) { return []; }
    var inputLookups = lookupCoverageList(
        subtable.inputCoverage, contextParams
    );
    if (inputLookups === -1) { return []; }
    var lookaheadOffset = subtable.inputCoverage.length - 1;
    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }
    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
        lookaheadContext.shift();
    }
    var lookaheadParams = new ContextParams(lookaheadContext, 0);
    var lookaheadLookups = lookupCoverageList(
        subtable.lookaheadCoverage, lookaheadParams
    );
    var backtrackContext = [].concat(contextParams.backtrack);
    backtrackContext.reverse();
    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
        backtrackContext.shift();
    }
    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }
    var backtrackParams = new ContextParams(backtrackContext, 0);
    var backtrackLookups = lookupCoverageList(
        subtable.backtrackCoverage, backtrackParams
    );
    var contextRulesMatch = (
        inputLookups.length === subtable.inputCoverage.length &&
        lookaheadLookups.length === subtable.lookaheadCoverage.length &&
        backtrackLookups.length === subtable.backtrackCoverage.length
    );
    var substitutions = [];
    if (contextRulesMatch) {
        for (var i = 0; i < subtable.lookupRecords.length; i++) {
            var lookupRecord = subtable.lookupRecords[i];
            var lookupListIndex = lookupRecord.lookupListIndex;
            var lookupTable = this.getLookupByIndex(lookupListIndex);
            for (var s = 0; s < lookupTable.subtables.length; s++) {
                var subtable$1 = lookupTable.subtables[s];
                var lookup = this.getLookupMethod(lookupTable, subtable$1);
                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);
                if (substitutionType === '12') {
                    for (var n = 0; n < inputLookups.length; n++) {
                        var glyphIndex = contextParams.get(n);
                        var substitution = lookup(glyphIndex);
                        if (substitution) { substitutions.push(substitution); }
                    }
                }
            }
        }
    }
    return substitutions;
}
function ligatureSubstitutionFormat1(contextParams, subtable) {
    var glyphIndex = contextParams.current;
    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);
    if (ligSetIndex === -1) { return null; }
    var ligature;
    var ligatureSet = subtable.ligatureSets[ligSetIndex];
    for (var s = 0; s < ligatureSet.length; s++) {
        ligature = ligatureSet[s];
        for (var l = 0; l < ligature.components.length; l++) {
            var lookaheadItem = contextParams.lookahead[l];
            var component = ligature.components[l];
            if (lookaheadItem !== component) { break; }
            if (l === ligature.components.length - 1) { return ligature; }
        }
    }
    return null;
}
function decompositionSubstitutionFormat1(glyphIndex, subtable) {
    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
    if (substituteIndex === -1) { return null; }
    return subtable.sequences[substituteIndex];
}
FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {
    var scripts = this.font.tables.gsub.scripts;
    for (var s = 0; s < scripts.length; s++) {
        var script = scripts[s];
        if (script.tag === 'DFLT') { return (
            script.script.defaultLangSys.featureIndexes
        ); }
    }
    return [];
};
FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
    var tables = this.font.tables;
    if (!tables.gsub) { return []; }
    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }
    var scripts = this.font.tables.gsub.scripts;
    for (var i = 0; i < scripts.length; i++) {
        var script = scripts[i];
        if (script.tag === scriptTag && script.script.defaultLangSys) {
            return script.script.defaultLangSys.featureIndexes;
        } else {
            var langSysRecords = script.langSysRecords;
            if (!!langSysRecords) {
                for (var j = 0; j < langSysRecords.length; j++) {
                    var langSysRecord = langSysRecords[j];
                    if (langSysRecord.tag === scriptTag) {
                        var langSys = langSysRecord.langSys;
                        return langSys.featureIndexes;
                    }
                }
            }
        }
    }
    return this.getDefaultScriptFeaturesIndexes();
};
FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {
    var tags = {};
    for (var i = 0; i < features.length; i++) {
        var tag = features[i].tag;
        var feature = features[i].feature;
        tags[tag] = feature;
    }
    this.features[scriptTag].tags = tags;
};
FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {
    var features = this.features[scriptTag];
    if (this.features.hasOwnProperty(scriptTag)) { return features; }
    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
    if (!featuresIndexes) { return null; }
    var gsub = this.font.tables.gsub;
    features = featuresIndexes.map(function (index) { return gsub.features[index]; });
    this.features[scriptTag] = features;
    this.mapTagsToFeatures(features, scriptTag);
    return features;
};
FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {
    var lookupType = lookupTable.lookupType.toString();
    var substFormat = subtable.substFormat.toString();
    return lookupType + substFormat;
};
FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {
    var this$1$1 = this;
    var substitutionType = this.getSubstitutionType(lookupTable, subtable);
    switch (substitutionType) {
        case '11':
            return function (glyphIndex) { return singleSubstitutionFormat1.apply(
                this$1$1, [glyphIndex, subtable]
            ); };
        case '12':
            return function (glyphIndex) { return singleSubstitutionFormat2.apply(
                this$1$1, [glyphIndex, subtable]
            ); };
        case '63':
            return function (contextParams) { return chainingSubstitutionFormat3.apply(
                this$1$1, [contextParams, subtable]
            ); };
        case '41':
            return function (contextParams) { return ligatureSubstitutionFormat1.apply(
                this$1$1, [contextParams, subtable]
            ); };
        case '21':
            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(
                this$1$1, [glyphIndex, subtable]
            ); };
        default:
            throw new Error(
                "lookupType: " + (lookupTable.lookupType) + " - " +
                "substFormat: " + (subtable.substFormat) + " " +
                "is not yet supported"
            );
    }
};
FeatureQuery.prototype.lookupFeature = function (query) {
    var contextParams = query.contextParams;
    var currentIndex = contextParams.index;
    var feature = this.getFeature({
        tag: query.tag, script: query.script
    });
    if (!feature) { return new Error(
        "font '" + (this.font.names.fullName.en) + "' " +
        "doesn't support feature '" + (query.tag) + "' " +
        "for script '" + (query.script) + "'."
    ); }
    var lookups = this.getFeatureLookups(feature);
    var substitutions = [].concat(contextParams.context);
    for (var l = 0; l < lookups.length; l++) {
        var lookupTable = lookups[l];
        var subtables = this.getLookupSubtables(lookupTable);
        for (var s = 0; s < subtables.length; s++) {
            var subtable = subtables[s];
            var substType = this.getSubstitutionType(lookupTable, subtable);
            var lookup = this.getLookupMethod(lookupTable, subtable);
            var substitution = (void 0);
            switch (substType) {
                case '11':
                    substitution = lookup(contextParams.current);
                    if (substitution) {
                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
                            id: 11, tag: query.tag, substitution: substitution
                        }));
                    }
                    break;
                case '12':
                    substitution = lookup(contextParams.current);
                    if (substitution) {
                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
                            id: 12, tag: query.tag, substitution: substitution
                        }));
                    }
                    break;
                case '63':
                    substitution = lookup(contextParams);
                    if (Array.isArray(substitution) && substitution.length) {
                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
                            id: 63, tag: query.tag, substitution: substitution
                        }));
                    }
                    break;
                case '41':
                    substitution = lookup(contextParams);
                    if (substitution) {
                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
                            id: 41, tag: query.tag, substitution: substitution
                        }));
                    }
                    break;
                case '21':
                    substitution = lookup(contextParams.current);
                    if (substitution) {
                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
                            id: 21, tag: query.tag, substitution: substitution
                        }));
                    }
                    break;
            }
            contextParams = new ContextParams(substitutions, currentIndex);
            if (Array.isArray(substitution) && !substitution.length) { continue; }
            substitution = null;
        }
    }
    return substitutions.length ? substitutions : null;
};
FeatureQuery.prototype.supports = function (query) {
    if (!query.script) { return false; }
    this.getScriptFeatures(query.script);
    var supportedScript = this.features.hasOwnProperty(query.script);
    if (!query.tag) { return supportedScript; }
    var supportedFeature = (
        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })
    );
    return supportedScript && supportedFeature;
};
FeatureQuery.prototype.getLookupSubtables = function (lookupTable) {
    return lookupTable.subtables || null;
};
FeatureQuery.prototype.getLookupByIndex = function (index) {
    var lookups = this.font.tables.gsub.lookups;
    return lookups[index] || null;
};
FeatureQuery.prototype.getFeatureLookups = function (feature) {
    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));
};
FeatureQuery.prototype.getFeature = function getFeature(query) {
    if (!this.font) { return { FAIL: "No font was found"}; }
    if (!this.features.hasOwnProperty(query.script)) {
        this.getScriptFeatures(query.script);
    }
    var scriptFeatures = this.features[query.script];
    if (!scriptFeatures) { return (
        { FAIL: ("No feature for script " + (query.script))}
    ); }
    if (!scriptFeatures.tags[query.tag]) { return null; }
    return this.features[query.script].tags[query.tag];
};
function arabicWordStartCheck(contextParams) {
    var char = contextParams.current;
    var prevChar = contextParams.get(-1);
    return (
        (prevChar === null && isArabicChar(char)) ||
        (!isArabicChar(prevChar) && isArabicChar(char))
    );
}
function arabicWordEndCheck(contextParams) {
    var nextChar = contextParams.get(1);
    return (
        (nextChar === null) ||
        (!isArabicChar(nextChar))
    );
}
var arabicWordCheck = {
    startCheck: arabicWordStartCheck,
    endCheck: arabicWordEndCheck
};
function arabicSentenceStartCheck(contextParams) {
    var char = contextParams.current;
    var prevChar = contextParams.get(-1);
    return (
        (isArabicChar(char) || isTashkeelArabicChar(char)) &&
        !isArabicChar(prevChar)
    );
}
function arabicSentenceEndCheck(contextParams) {
    var nextChar = contextParams.get(1);
    switch (true) {
        case nextChar === null:
            return true;
        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
            var nextIsWhitespace = isWhiteSpace$1(nextChar);
            if (!nextIsWhitespace) { return true; }
            if (nextIsWhitespace) {
                var arabicCharAhead = false;
                arabicCharAhead = (
                    contextParams.lookahead.some(
                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }
                    )
                );
                if (!arabicCharAhead) { return true; }
            }
            break;
        default:
            return false;
    }
}
var arabicSentenceCheck = {
    startCheck: arabicSentenceStartCheck,
    endCheck: arabicSentenceEndCheck
};
function singleSubstitutionFormat1$1(action, tokens, index) {
    tokens[index].setState(action.tag, action.substitution);
}
function singleSubstitutionFormat2$1(action, tokens, index) {
    tokens[index].setState(action.tag, action.substitution);
}
function chainingSubstitutionFormat3$1(action, tokens, index) {
    action.substitution.forEach(function (subst, offset) {
        var token = tokens[index + offset];
        token.setState(action.tag, subst);
    });
}
function ligatureSubstitutionFormat1$1(action, tokens, index) {
    var token = tokens[index];
    token.setState(action.tag, action.substitution.ligGlyph);
    var compsCount = action.substitution.components.length;
    for (var i = 0; i < compsCount; i++) {
        token = tokens[index + i + 1];
        token.setState('deleted', true);
    }
}
var SUBSTITUTIONS = {
    11: singleSubstitutionFormat1$1,
    12: singleSubstitutionFormat2$1,
    63: chainingSubstitutionFormat3$1,
    41: ligatureSubstitutionFormat1$1
};
function applySubstitution(action, tokens, index) {
    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {
        SUBSTITUTIONS[action.id](action, tokens, index);
    }
}
function willConnectPrev(charContextParams) {
    var backtrack = [].concat(charContextParams.backtrack);
    for (var i = backtrack.length - 1; i >= 0; i--) {
        var prevChar = backtrack[i];
        var isolated = isIsolatedArabicChar(prevChar);
        var tashkeel = isTashkeelArabicChar(prevChar);
        if (!isolated && !tashkeel) { return true; }
        if (isolated) { return false; }
    }
    return false;
}
function willConnectNext(charContextParams) {
    if (isIsolatedArabicChar(charContextParams.current)) { return false; }
    for (var i = 0; i < charContextParams.lookahead.length; i++) {
        var nextChar = charContextParams.lookahead[i];
        var tashkeel = isTashkeelArabicChar(nextChar);
        if (!tashkeel) { return true; }
    }
    return false;
}
function arabicPresentationForms(range) {
    var this$1$1 = this;
    var script = 'arab';
    var tags = this.featuresTags[script];
    var tokens = this.tokenizer.getRangeTokens(range);
    if (tokens.length === 1) { return; }
    var contextParams = new ContextParams(
        tokens.map(function (token) { return token.getState('glyphIndex'); }
    ), 0);
    var charContextParams = new ContextParams(
        tokens.map(function (token) { return token.char; }
    ), 0);
    tokens.forEach(function (token, index) {
        if (isTashkeelArabicChar(token.char)) { return; }
        contextParams.setCurrentIndex(index);
        charContextParams.setCurrentIndex(index);
        var CONNECT = 0;
        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }
        if (willConnectNext(charContextParams)) { CONNECT |= 2; }
        var tag;
        switch (CONNECT) {
            case 1: (tag = 'fina'); break;
            case 2: (tag = 'init'); break;
            case 3: (tag = 'medi'); break;
        }
        if (tags.indexOf(tag) === -1) { return; }
        var substitutions = this$1$1.query.lookupFeature({
            tag: tag, script: script, contextParams: contextParams
        });
        if (substitutions instanceof Error) { return console.info(substitutions.message); }
        substitutions.forEach(function (action, index) {
            if (action instanceof SubstitutionAction) {
                applySubstitution(action, tokens, index);
                contextParams.context[index] = action.substitution;
            }
        });
    });
}
function getContextParams(tokens, index) {
    var context = tokens.map(function (token) { return token.activeState.value; });
    return new ContextParams(context, 0);
}
function arabicRequiredLigatures(range) {
    var this$1$1 = this;
    var script = 'arab';
    var tokens = this.tokenizer.getRangeTokens(range);
    var contextParams = getContextParams(tokens);
    contextParams.context.forEach(function (glyphIndex, index) {
        contextParams.setCurrentIndex(index);
        var substitutions = this$1$1.query.lookupFeature({
            tag: 'rlig', script: script, contextParams: contextParams
        });
        if (substitutions.length) {
            substitutions.forEach(
                function (action) { return applySubstitution(action, tokens, index); }
            );
            contextParams = getContextParams(tokens);
        }
    });
}
function latinWordStartCheck(contextParams) {
    var char = contextParams.current;
    var prevChar = contextParams.get(-1);
    return (
        (prevChar === null && isLatinChar(char)) ||
        (!isLatinChar(prevChar) && isLatinChar(char))
    );
}
function latinWordEndCheck(contextParams) {
    var nextChar = contextParams.get(1);
    return (
        (nextChar === null) ||
        (!isLatinChar(nextChar))
    );
}
var latinWordCheck = {
    startCheck: latinWordStartCheck,
    endCheck: latinWordEndCheck
};
function getContextParams$1(tokens, index) {
    var context = tokens.map(function (token) { return token.activeState.value; });
    return new ContextParams(context, 0);
}
function latinLigature(range) {
    var this$1$1 = this;
    var script = 'latn';
    var tokens = this.tokenizer.getRangeTokens(range);
    var contextParams = getContextParams$1(tokens);
    contextParams.context.forEach(function (glyphIndex, index) {
        contextParams.setCurrentIndex(index);
        var substitutions = this$1$1.query.lookupFeature({
            tag: 'liga', script: script, contextParams: contextParams
        });
        if (substitutions.length) {
            substitutions.forEach(
                function (action) { return applySubstitution(action, tokens, index); }
            );
            contextParams = getContextParams$1(tokens);
        }
    });
}
function Bidi(baseDir) {
    this.baseDir = baseDir || 'ltr';
    this.tokenizer = new Tokenizer();
    this.featuresTags = {};
}
Bidi.prototype.setText = function (text) {
    this.text = text;
};
Bidi.prototype.contextChecks = ({
    latinWordCheck: latinWordCheck,
    arabicWordCheck: arabicWordCheck,
    arabicSentenceCheck: arabicSentenceCheck
});
function registerContextChecker(checkId) {
    var check = this.contextChecks[(checkId + "Check")];
    return this.tokenizer.registerContextChecker(
        checkId, check.startCheck, check.endCheck
    );
}
function tokenizeText() {
    registerContextChecker.call(this, 'latinWord');
    registerContextChecker.call(this, 'arabicWord');
    registerContextChecker.call(this, 'arabicSentence');
    return this.tokenizer.tokenize(this.text);
}
function reverseArabicSentences() {
    var this$1$1 = this;
    var ranges = this.tokenizer.getContextRanges('arabicSentence');
    ranges.forEach(function (range) {
        var rangeTokens = this$1$1.tokenizer.getRangeTokens(range);
        this$1$1.tokenizer.replaceRange(
            range.startIndex,
            range.endOffset,
            rangeTokens.reverse()
        );
    });
}
Bidi.prototype.registerFeatures = function (script, tags) {
    var this$1$1 = this;
    var supportedTags = tags.filter(
        function (tag) { return this$1$1.query.supports({script: script, tag: tag}); }
    );
    if (!this.featuresTags.hasOwnProperty(script)) {
        this.featuresTags[script] = supportedTags;
    } else {
        this.featuresTags[script] =
        this.featuresTags[script].concat(supportedTags);
    }
};
Bidi.prototype.applyFeatures = function (font, features) {
    if (!font) { throw new Error(
        'No valid font was provided to apply features'
    ); }
    if (!this.query) { this.query = new FeatureQuery(font); }
    for (var f = 0; f < features.length; f++) {
        var feature = features[f];
        if (!this.query.supports({script: feature.script})) { continue; }
        this.registerFeatures(feature.script, feature.tags);
    }
};
Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {
    this.tokenizer.registerModifier(modifierId, condition, modifier);
};
function checkGlyphIndexStatus() {
    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {
        throw new Error(
            'glyphIndex modifier is required to apply ' +
            'arabic presentation features.'
        );
    }
}
function applyArabicPresentationForms() {
    var this$1$1 = this;
    var script = 'arab';
    if (!this.featuresTags.hasOwnProperty(script)) { return; }
    checkGlyphIndexStatus.call(this);
    var ranges = this.tokenizer.getContextRanges('arabicWord');
    ranges.forEach(function (range) {
        arabicPresentationForms.call(this$1$1, range);
    });
}
function applyArabicRequireLigatures() {
    var this$1$1 = this;
    var script = 'arab';
    if (!this.featuresTags.hasOwnProperty(script)) { return; }
    var tags = this.featuresTags[script];
    if (tags.indexOf('rlig') === -1) { return; }
    checkGlyphIndexStatus.call(this);
    var ranges = this.tokenizer.getContextRanges('arabicWord');
    ranges.forEach(function (range) {
        arabicRequiredLigatures.call(this$1$1, range);
    });
}
function applyLatinLigatures() {
    var this$1$1 = this;
    var script = 'latn';
    if (!this.featuresTags.hasOwnProperty(script)) { return; }
    var tags = this.featuresTags[script];
    if (tags.indexOf('liga') === -1) { return; }
    checkGlyphIndexStatus.call(this);
    var ranges = this.tokenizer.getContextRanges('latinWord');
    ranges.forEach(function (range) {
        latinLigature.call(this$1$1, range);
    });
}
Bidi.prototype.checkContextReady = function (contextId) {
    return !!this.tokenizer.getContext(contextId);
};
Bidi.prototype.applyFeaturesToContexts = function () {
    if (this.checkContextReady('arabicWord')) {
        applyArabicPresentationForms.call(this);
        applyArabicRequireLigatures.call(this);
    }
    if (this.checkContextReady('latinWord')) {
        applyLatinLigatures.call(this);
    }
    if (this.checkContextReady('arabicSentence')) {
        reverseArabicSentences.call(this);
    }
};
Bidi.prototype.processText = function(text) {
    if (!this.text || this.text !== text) {
        this.setText(text);
        tokenizeText.call(this);
        this.applyFeaturesToContexts();
    }
};
Bidi.prototype.getBidiText = function (text) {
    this.processText(text);
    return this.tokenizer.getText();
};
Bidi.prototype.getTextGlyphs = function (text) {
    this.processText(text);
    var indexes = [];
    for (var i = 0; i < this.tokenizer.tokens.length; i++) {
        var token = this.tokenizer.tokens[i];
        if (token.state.deleted) { continue; }
        var index = token.activeState.value;
        indexes.push(Array.isArray(index) ? index[0] : index);
    }
    return indexes;
};
function Font(options) {
    options = options || {};
    options.tables = options.tables || {};
    if (!options.empty) {
        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
        checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.');
        this.names = {
            fontFamily: {en: options.familyName || ' '},
            fontSubfamily: {en: options.styleName || ' '},
            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, '')},
            designer: {en: options.designer || ' '},
            designerURL: {en: options.designerURL || ' '},
            manufacturer: {en: options.manufacturer || ' '},
            manufacturerURL: {en: options.manufacturerURL || ' '},
            license: {en: options.license || ' '},
            licenseURL: {en: options.licenseURL || ' '},
            version: {en: options.version || 'Version 0.1'},
            description: {en: options.description || ' '},
            copyright: {en: options.copyright || ' '},
            trademark: {en: options.trademark || ' '}
        };
        this.unitsPerEm = options.unitsPerEm || 1000;
        this.ascender = options.ascender;
        this.descender = options.descender;
        this.createdTimestamp = options.createdTimestamp;
        this.tables = Object.assign(options.tables, {
            os2: Object.assign({
                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,
            }, options.tables.os2)
        });
    }
    this.supported = true;
    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
    this.encoding = new DefaultEncoding(this);
    this.position = new Position(this);
    this.substitution = new Substitution(this);
    this.tables = this.tables || {};
    this._push = null;
    this._hmtxTableData = {};
    Object.defineProperty(this, 'hinting', {
        get: function() {
            if (this._hinting) { return this._hinting; }
            if (this.outlinesFormat === 'truetype') {
                return (this._hinting = new Hinting(this));
            }
        }
    });
}
Font.prototype.hasChar = function(c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};
Font.prototype.charToGlyphIndex = function(s) {
    return this.encoding.charToGlyphIndex(s);
};
Font.prototype.charToGlyph = function(c) {
    var glyphIndex = this.charToGlyphIndex(c);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        glyph = this.glyphs.get(0);
    }
    return glyph;
};
Font.prototype.updateFeatures = function (options) {
    return this.defaultRenderOptions.features.map(function (feature) {
        if (feature.script === 'latn') {
            return {
                script: 'latn',
                tags: feature.tags.filter(function (tag) { return options[tag]; })
            };
        } else {
            return feature;
        }
    });
};
Font.prototype.stringToGlyphs = function(s, options) {
    var this$1$1 = this;
    var bidi = new Bidi();
    var charToGlyphIndexMod = function (token) { return this$1$1.charToGlyphIndex(token.char); };
    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);
    var features = options ?
    this.updateFeatures(options.features) :
    this.defaultRenderOptions.features;
    bidi.applyFeatures(this, features);
    var indexes = bidi.getTextGlyphs(s);
    var length = indexes.length;
    var glyphs = new Array(length);
    var notdef = this.glyphs.get(0);
    for (var i = 0; i < length; i += 1) {
        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;
    }
    return glyphs;
};
Font.prototype.nameToGlyphIndex = function(name) {
    return this.glyphNames.nameToGlyphIndex(name);
};
Font.prototype.nameToGlyph = function(name) {
    var glyphIndex = this.nameToGlyphIndex(name);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        glyph = this.glyphs.get(0);
    }
    return glyph;
};
Font.prototype.glyphIndexToName = function(gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }
    return this.glyphNames.glyphIndexToName(gid);
};
Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    var gposKerning = this.position.defaultKerningTables;
    if (gposKerning) {
        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
    }
    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
};
Font.prototype.defaultRenderOptions = {
    kerning: true,
    features: [
        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },
        { script: 'latn', tags: ['liga', 'rlig'] }
    ]
};
Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = Object.assign({}, this.defaultRenderOptions, options);
    var fontScale = 1 / this.unitsPerEm * fontSize;
    var glyphs = this.stringToGlyphs(text, options);
    var kerningLookups;
    if (options.kerning) {
        var script = options.script || this.position.getDefaultScriptName();
        kerningLookups = this.position.getKerningTables(script, options.language);
    }
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        callback.call(this, glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }
        if (options.kerning && i < glyphs.length - 1) {
            var kerningValue = kerningLookups ?
                  this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
                  this.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }
        if (options.letterSpacing) {
            x += options.letterSpacing * fontSize;
        } else if (options.tracking) {
            x += (options.tracking / 1000) * fontSize;
        }
    }
    return x;
};
Font.prototype.getPath = function(text, x, y, fontSize, options) {
    var fullPath = new Path();
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        fullPath.extend(glyphPath);
    });
    return fullPath;
};
Font.prototype.getPaths = function(text, x, y, fontSize, options) {
    var glyphPaths = [];
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        glyphPaths.push(glyphPath);
    });
    return glyphPaths;
};
Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
};
Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};
Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawPoints(ctx, gX, gY, gFontSize);
    });
};
Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawMetrics(ctx, gX, gY, gFontSize);
    });
};
Font.prototype.getEnglishName = function(name) {
    var translations = this.names[name];
    if (translations) {
        return translations.en;
    }
};
Font.prototype.validate = function() {
    var _this = this;
    function assert(predicate, message) {
    }
    function assertNamePresent(name) {
        var englishName = _this.getEnglishName(name);
        assert(englishName && englishName.trim().length > 0);
    }
    assertNamePresent('fontFamily');
    assertNamePresent('weightName');
    assertNamePresent('manufacturer');
    assertNamePresent('copyright');
    assertNamePresent('version');
    assert(this.unitsPerEm > 0);
};
Font.prototype.toTables = function() {
    return sfnt.fontToTable(this);
};
Font.prototype.toBuffer = function() {
    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
    return this.toArrayBuffer();
};
Font.prototype.toArrayBuffer = function() {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }
    return buffer;
};
Font.prototype.download = function(fileName) {
    var familyName = this.getEnglishName('fontFamily');
    var styleName = this.getEnglishName('fontSubfamily');
    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
    var arrayBuffer = this.toArrayBuffer();
    if (isBrowser()) {
        window.URL = window.URL || window.webkitURL;
        if (window.URL) {
            var dataView = new DataView(arrayBuffer);
            var blob = new Blob([dataView], {type: 'font/opentype'});
            var link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = fileName;
            var event = document.createEvent('MouseEvents');
            event.initEvent('click', true, false);
            link.dispatchEvent(event);
        } else {
            console.warn('Font file could not be downloaded. Try using a different browser.');
        }
    } else {
        var fs = require('fs');
        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
        fs.writeFileSync(fileName, buffer);
    }
};
Font.prototype.fsSelectionValues = {
    ITALIC:              0x001,
    UNDERSCORE:          0x002,
    NEGATIVE:            0x004,
    OUTLINED:            0x008,
    STRIKEOUT:           0x010,
    BOLD:                0x020,
    REGULAR:             0x040,
    USER_TYPO_METRICS:   0x080,
    WWS:                 0x100,
    OBLIQUE:             0x200
};
Font.prototype.usWidthClasses = {
    ULTRA_CONDENSED: 1,
    EXTRA_CONDENSED: 2,
    CONDENSED: 3,
    SEMI_CONDENSED: 4,
    MEDIUM: 5,
    SEMI_EXPANDED: 6,
    EXPANDED: 7,
    EXTRA_EXPANDED: 8,
    ULTRA_EXPANDED: 9
};
Font.prototype.usWeightClasses = {
    THIN: 100,
    EXTRA_LIGHT: 200,
    LIGHT: 300,
    NORMAL: 400,
    MEDIUM: 500,
    SEMI_BOLD: 600,
    BOLD: 700,
    EXTRA_BOLD: 800,
    BLACK:    900
};
function addName(name, names) {
    var nameString = JSON.stringify(name);
    var nameID = 256;
    for (var nameKey in names) {
        var n = parseInt(nameKey);
        if (!n || n < 256) {
            continue;
        }
        if (JSON.stringify(names[nameKey]) === nameString) {
            return n;
        }
        if (nameID <= n) {
            nameID = n + 1;
        }
    }
    names[nameID] = name;
    return nameID;
}
function makeFvarAxis(n, axis, names) {
    var nameID = addName(axis.name, names);
    return [
        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
        {name: 'flags_' + n, type: 'USHORT', value: 0},
        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
    ];
}
function parseFvarAxis(data, start, names) {
    var axis = {};
    var p = new parse.Parser(data, start);
    axis.tag = p.parseTag();
    axis.minValue = p.parseFixed();
    axis.defaultValue = p.parseFixed();
    axis.maxValue = p.parseFixed();
    p.skip('uShort', 1);
    axis.name = names[p.parseUShort()] || {};
    return axis;
}
function makeFvarInstance(n, inst, axes, names) {
    var nameID = addName(inst.name, names);
    var fields = [
        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
        {name: 'flags_' + n, type: 'USHORT', value: 0}
    ];
    for (var i = 0; i < axes.length; ++i) {
        var axisTag = axes[i].tag;
        fields.push({
            name: 'axis_' + n + ' ' + axisTag,
            type: 'FIXED',
            value: inst.coordinates[axisTag] << 16
        });
    }
    return fields;
}
function parseFvarInstance(data, start, axes, names) {
    var inst = {};
    var p = new parse.Parser(data, start);
    inst.name = names[p.parseUShort()] || {};
    p.skip('uShort', 1);
    inst.coordinates = {};
    for (var i = 0; i < axes.length; ++i) {
        inst.coordinates[axes[i].tag] = p.parseFixed();
    }
    return inst;
}
function makeFvarTable(fvar, names) {
    var result = new table.Table('fvar', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'offsetToData', type: 'USHORT', value: 0},
        {name: 'countSizePairs', type: 'USHORT', value: 2},
        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
        {name: 'axisSize', type: 'USHORT', value: 20},
        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
    ]);
    result.offsetToData = result.sizeOf();
    for (var i = 0; i < fvar.axes.length; i++) {
        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
    }
    for (var j = 0; j < fvar.instances.length; j++) {
        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
    }
    return result;
}
function parseFvarTable(data, start, names) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
    var offsetToData = p.parseOffset16();
    p.skip('uShort', 1);
    var axisCount = p.parseUShort();
    var axisSize = p.parseUShort();
    var instanceCount = p.parseUShort();
    var instanceSize = p.parseUShort();
    var axes = [];
    for (var i = 0; i < axisCount; i++) {
        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
    }
    var instances = [];
    var instanceStart = start + offsetToData + axisCount * axisSize;
    for (var j = 0; j < instanceCount; j++) {
        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
    }
    return {axes: axes, instances: instances};
}
var fvar = { make: makeFvarTable, parse: parseFvarTable };
var attachList = function() {
    return {
        coverage: this.parsePointer(Parser.coverage),
        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))
    };
};
var caretValue = function() {
    var format = this.parseUShort();
    check.argument(format === 1 || format === 2 || format === 3,
        'Unsupported CaretValue table version.');
    if (format === 1) {
        return { coordinate: this.parseShort() };
    } else if (format === 2) {
        return { pointindex: this.parseShort() };
    } else if (format === 3) {
        return { coordinate: this.parseShort() };
    }
};
var ligGlyph = function() {
    return this.parseList(Parser.pointer(caretValue));
};
var ligCaretList = function() {
    return {
        coverage: this.parsePointer(Parser.coverage),
        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))
    };
};
var markGlyphSets = function() {
    this.parseUShort();
    return this.parseList(Parser.pointer(Parser.coverage));
};
function parseGDEFTable(data, start) {
    start = start || 0;
    var p = new Parser(data, start);
    var tableVersion = p.parseVersion(1);
    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,
        'Unsupported GDEF table version.');
    var gdef = {
        version: tableVersion,
        classDef: p.parsePointer(Parser.classDef),
        attachList: p.parsePointer(attachList),
        ligCaretList: p.parsePointer(ligCaretList),
        markAttachClassDef: p.parsePointer(Parser.classDef)
    };
    if (tableVersion >= 1.2) {
        gdef.markGlyphSets = p.parsePointer(markGlyphSets);
    }
    return gdef;
}
var gdef = { parse: parseGDEFTable };
var subtableParsers$1 = new Array(10);
subtableParsers$1[1] = function parseLookup1() {
    var start = this.offset + this.relativeOffset;
    var posformat = this.parseUShort();
    if (posformat === 1) {
        return {
            posFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            value: this.parseValueRecord()
        };
    } else if (posformat === 2) {
        return {
            posFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            values: this.parseValueRecordList()
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
};
subtableParsers$1[2] = function parseLookup2() {
    var start = this.offset + this.relativeOffset;
    var posFormat = this.parseUShort();
    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
    var coverage = this.parsePointer(Parser.coverage);
    var valueFormat1 = this.parseUShort();
    var valueFormat2 = this.parseUShort();
    if (posFormat === 1) {
        return {
            posFormat: posFormat,
            coverage: coverage,
            valueFormat1: valueFormat1,
            valueFormat2: valueFormat2,
            pairSets: this.parseList(Parser.pointer(Parser.list(function() {
                return {
                    secondGlyph: this.parseUShort(),
                    value1: this.parseValueRecord(valueFormat1),
                    value2: this.parseValueRecord(valueFormat2)
                };
            })))
        };
    } else if (posFormat === 2) {
        var classDef1 = this.parsePointer(Parser.classDef);
        var classDef2 = this.parsePointer(Parser.classDef);
        var class1Count = this.parseUShort();
        var class2Count = this.parseUShort();
        return {
            posFormat: posFormat,
            coverage: coverage,
            valueFormat1: valueFormat1,
            valueFormat2: valueFormat2,
            classDef1: classDef1,
            classDef2: classDef2,
            class1Count: class1Count,
            class2Count: class2Count,
            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
                return {
                    value1: this.parseValueRecord(valueFormat1),
                    value2: this.parseValueRecord(valueFormat2)
                };
            }))
        };
    }
};
subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };
function parseGposTable(data, start) {
    start = start || 0;
    var p = new Parser(data, start);
    var tableVersion = p.parseVersion(1);
    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);
    if (tableVersion === 1) {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers$1)
        };
    } else {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers$1),
            variations: p.parseFeatureVariationsList()
        };
    }
}
var subtableMakers$1 = new Array(10);
function makeGposTable(gpos) {
    return new table.Table('GPOS', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},
        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},
        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}
    ]);
}
var gpos = { parse: parseGposTable, make: makeGposTable };
function parseWindowsKernTable(p) {
    var pairs = {};
    p.skip('uShort');
    var subtableVersion = p.parseUShort();
    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
    p.skip('uShort', 2);
    var nPairs = p.parseUShort();
    p.skip('uShort', 3);
    for (var i = 0; i < nPairs; i += 1) {
        var leftIndex = p.parseUShort();
        var rightIndex = p.parseUShort();
        var value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}
function parseMacKernTable(p) {
    var pairs = {};
    p.skip('uShort');
    var nTables = p.parseULong();
    if (nTables > 1) {
        console.warn('Only the first kern subtable is supported.');
    }
    p.skip('uLong');
    var coverage = p.parseUShort();
    var subtableVersion = coverage & 0xFF;
    p.skip('uShort');
    if (subtableVersion === 0) {
        var nPairs = p.parseUShort();
        p.skip('uShort', 3);
        for (var i = 0; i < nPairs; i += 1) {
            var leftIndex = p.parseUShort();
            var rightIndex = p.parseUShort();
            var value = p.parseShort();
            pairs[leftIndex + ',' + rightIndex] = value;
        }
    }
    return pairs;
}
function parseKernTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseUShort();
    if (tableVersion === 0) {
        return parseWindowsKernTable(p);
    } else if (tableVersion === 1) {
        return parseMacKernTable(p);
    } else {
        throw new Error('Unsupported kern table version (' + tableVersion + ').');
    }
}
var kern = { parse: parseKernTable };
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p = new parse.Parser(data, start);
    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
    var glyphOffsets = [];
    for (var i = 0; i < numGlyphs + 1; i += 1) {
        var glyphOffset = parseFn.call(p);
        if (shortVersion) {
            glyphOffset *= 2;
        }
        glyphOffsets.push(glyphOffset);
    }
    return glyphOffsets;
}
var loca = { parse: parseLocaTable };
function loadFromFile(path, callback) {
    var fs = require('fs');
    fs.readFile(path, function(err, buffer) {
        if (err) {
            return callback(err.message);
        }
        callback(null, nodeBufferToArrayBuffer(buffer));
    });
}
function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function() {
        if (request.response) {
            return callback(null, request.response);
        } else {
            return callback('Font could not be loaded: ' + request.statusText);
        }
    };
    request.onerror = function () {
        callback('Font could not be loaded');
    };
    request.send();
}
function parseOpenTypeTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 12;
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var checksum = parse.getULong(data, p + 4);
        var offset = parse.getULong(data, p + 8);
        var length = parse.getULong(data, p + 12);
        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
        p += 16;
    }
    return tableEntries;
}
function parseWOFFTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 44;
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var offset = parse.getULong(data, p + 4);
        var compLength = parse.getULong(data, p + 8);
        var origLength = parse.getULong(data, p + 12);
        var compression = (void 0);
        if (compLength < origLength) {
            compression = 'WOFF';
        } else {
            compression = false;
        }
        tableEntries.push({tag: tag, offset: offset, compression: compression,
            compressedLength: compLength, length: origLength});
        p += 20;
    }
    return tableEntries;
}
function uncompressTable(data, tableEntry) {
    if (tableEntry.compression === 'WOFF') {
        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
        var outBuffer = new Uint8Array(tableEntry.length);
        tinyInflate(inBuffer, outBuffer);
        if (outBuffer.byteLength !== tableEntry.length) {
            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
        }
        var view = new DataView(outBuffer.buffer, 0);
        return {data: view, offset: 0};
    } else {
        return {data: data, offset: tableEntry.offset};
    }
}
function parseBuffer(buffer, opt) {
    opt = (opt === undefined || opt === null) ?  {} : opt;
    var indexToLocFormat;
    var ltagTable;
    var font = new Font({empty: true});
    var data = new DataView(buffer, 0);
    var numTables;
    var tableEntries = [];
    var signature = parse.getTag(data, 0);
    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
        font.outlinesFormat = 'truetype';
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'OTTO') {
        font.outlinesFormat = 'cff';
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'wOFF') {
        var flavor = parse.getTag(data, 4);
        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
            font.outlinesFormat = 'truetype';
        } else if (flavor === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType flavor ' + signature);
        }
        numTables = parse.getUShort(data, 12);
        tableEntries = parseWOFFTableEntries(data, numTables);
    } else {
        throw new Error('Unsupported OpenType signature ' + signature);
    }
    var cffTableEntry;
    var fvarTableEntry;
    var glyfTableEntry;
    var gdefTableEntry;
    var gposTableEntry;
    var gsubTableEntry;
    var hmtxTableEntry;
    var kernTableEntry;
    var locaTableEntry;
    var nameTableEntry;
    var metaTableEntry;
    var p;
    for (var i = 0; i < numTables; i += 1) {
        var tableEntry = tableEntries[i];
        var table = (void 0);
        switch (tableEntry.tag) {
            case 'cmap':
                table = uncompressTable(data, tableEntry);
                font.tables.cmap = cmap.parse(table.data, table.offset);
                font.encoding = new CmapEncoding(font.tables.cmap);
                break;
            case 'cvt ' :
                table = uncompressTable(data, tableEntry);
                p = new parse.Parser(table.data, table.offset);
                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
                break;
            case 'fvar':
                fvarTableEntry = tableEntry;
                break;
            case 'fpgm' :
                table = uncompressTable(data, tableEntry);
                p = new parse.Parser(table.data, table.offset);
                font.tables.fpgm = p.parseByteList(tableEntry.length);
                break;
            case 'head':
                table = uncompressTable(data, tableEntry);
                font.tables.head = head.parse(table.data, table.offset);
                font.unitsPerEm = font.tables.head.unitsPerEm;
                indexToLocFormat = font.tables.head.indexToLocFormat;
                break;
            case 'hhea':
                table = uncompressTable(data, tableEntry);
                font.tables.hhea = hhea.parse(table.data, table.offset);
                font.ascender = font.tables.hhea.ascender;
                font.descender = font.tables.hhea.descender;
                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                break;
            case 'hmtx':
                hmtxTableEntry = tableEntry;
                break;
            case 'ltag':
                table = uncompressTable(data, tableEntry);
                ltagTable = ltag.parse(table.data, table.offset);
                break;
            case 'maxp':
                table = uncompressTable(data, tableEntry);
                font.tables.maxp = maxp.parse(table.data, table.offset);
                font.numGlyphs = font.tables.maxp.numGlyphs;
                break;
            case 'name':
                nameTableEntry = tableEntry;
                break;
            case 'OS/2':
                table = uncompressTable(data, tableEntry);
                font.tables.os2 = os2.parse(table.data, table.offset);
                break;
            case 'post':
                table = uncompressTable(data, tableEntry);
                font.tables.post = post.parse(table.data, table.offset);
                font.glyphNames = new GlyphNames(font.tables.post);
                break;
            case 'prep' :
                table = uncompressTable(data, tableEntry);
                p = new parse.Parser(table.data, table.offset);
                font.tables.prep = p.parseByteList(tableEntry.length);
                break;
            case 'glyf':
                glyfTableEntry = tableEntry;
                break;
            case 'loca':
                locaTableEntry = tableEntry;
                break;
            case 'CFF ':
                cffTableEntry = tableEntry;
                break;
            case 'kern':
                kernTableEntry = tableEntry;
                break;
            case 'GDEF':
                gdefTableEntry = tableEntry;
                break;
            case 'GPOS':
                gposTableEntry = tableEntry;
                break;
            case 'GSUB':
                gsubTableEntry = tableEntry;
                break;
            case 'meta':
                metaTableEntry = tableEntry;
                break;
        }
    }
    var nameTable = uncompressTable(data, nameTableEntry);
    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
    font.names = font.tables.name;
    if (glyfTableEntry && locaTableEntry) {
        var shortVersion = indexToLocFormat === 0;
        var locaTable = uncompressTable(data, locaTableEntry);
        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
        var glyfTable = uncompressTable(data, glyfTableEntry);
        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);
    } else if (cffTableEntry) {
        var cffTable = uncompressTable(data, cffTableEntry);
        cff.parse(cffTable.data, cffTable.offset, font, opt);
    } else {
        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
    }
    var hmtxTable = uncompressTable(data, hmtxTableEntry);
    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);
    addGlyphNames(font, opt);
    if (kernTableEntry) {
        var kernTable = uncompressTable(data, kernTableEntry);
        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
    } else {
        font.kerningPairs = {};
    }
    if (gdefTableEntry) {
        var gdefTable = uncompressTable(data, gdefTableEntry);
        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);
    }
    if (gposTableEntry) {
        var gposTable = uncompressTable(data, gposTableEntry);
        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
        font.position.init();
    }
    if (gsubTableEntry) {
        var gsubTable = uncompressTable(data, gsubTableEntry);
        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
    }
    if (fvarTableEntry) {
        var fvarTable = uncompressTable(data, fvarTableEntry);
        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
    }
    if (metaTableEntry) {
        var metaTable = uncompressTable(data, metaTableEntry);
        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
        font.metas = font.tables.meta;
    }
    return font;
}
function load(url, callback, opt) {
    opt = (opt === undefined || opt === null) ?  {} : opt;
    var isNode = typeof window === 'undefined';
    var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;
    return new Promise(function (resolve, reject) {
        loadFn(url, function(err, arrayBuffer) {
            if (err) {
                if (callback) {
                    return callback(err);
                } else {
                    reject(err);
                }
            }
            var font;
            try {
                font = parseBuffer(arrayBuffer, opt);
            } catch (e) {
                if (callback) {
                    return callback(e, null);
                } else {
                    reject(e);
                }
            }
            if (callback) {
                return callback(null, font);
            } else {
                resolve(font);
            }
        });
    });
}
function loadSync(url, opt) {
    var fs = require('fs');
    var buffer = fs.readFileSync(url);
    return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);
}
var opentype = Object.freeze({
	__proto__: null,
	Font: Font,
	Glyph: Glyph,
	Path: Path,
	BoundingBox: BoundingBox,
	_parse: parse,
	parse: parseBuffer,
	load: load,
	loadSync: loadSync
});

var A,g=(A="file:///build/woff2-wasm.js",function(g={}){g.ready=new Promise((A,g)=>{C=A,B=g;});var C,B,Q,E,w,D,G,i,o,L,Y,c,h,F,s,N,K,a,R,H,k,J,Z,M=Object.assign({},g),W=(A,g)=>{throw g},d="";"undefined"!=typeof document&&document.currentScript&&(d=document.currentScript.src),A&&(d=A),d=0!==d.indexOf("blob:")?d.substr(0,d.replace(/[?#].*/,"").lastIndexOf("/")+1):"",g.print||console.log.bind(console);var y=g.printErr||console.error.bind(console);Object.assign(g,M),M=null,g.arguments&&g.arguments,g.thisProgram&&g.thisProgram,g.quit&&(W=g.quit),g.wasmBinary&&(Q=g.wasmBinary);g.noExitRuntime||true;"object"!=typeof WebAssembly&&X("no native wasm support detected");var p=false;function b(){var A=E.buffer;g.HEAP8=w=new Int8Array(A),g.HEAP16=G=new Int16Array(A),g.HEAPU8=D=new Uint8Array(A),g.HEAPU16=i=new Uint16Array(A),g.HEAP32=o=new Int32Array(A),g.HEAPU32=L=new Uint32Array(A),g.HEAPF32=Y=new Float32Array(A),g.HEAPF64=c=new Float64Array(A);}var l=[],S=[],m=[],q=0,V=null;function X(A){g.onAbort&&g.onAbort(A),y(A="Aborted("+A+")"),p=true,A+=". Build with -sASSERTIONS for more info.";var C=new WebAssembly.RuntimeError(A);throw B(C),C}var u="data:application/octet-stream;base64,";function n(A){return A.startsWith(u)}function x(A){this.name="ExitStatus",this.message=`Program terminated with exit(${A})`,this.status=A;}n(h="data:application/octet-stream;base64,AGFzbQEAAAABnQIeYAJ/fwBgAX8Bf2ACf38Bf2ADf39/AX9gA39/fwBgAX8AYAV/f39/fwBgAABgBH9/f38AYAR/f39/AX9gBX9/f39/AX9gBn9/f39/fwBgB39/f39/f38AYAh/f39/f39/fwBgAX8BfGAJf39/f39/f39/AX9gAn9/AXxgAXwBfGAHf39/f39/fwF/YA1/f39/f39/f39/f39/AGAJf39/f39/f39/AGALf39/f39/f39/f38AYAZ/f35/f38Bf2AGf39/f39/AX9gCn9/f39/f39/f38AYAx/f39/f39/f39/f38AYA9/f39/f39/f39/f39/f38AYA1/f39/f39/f39/f39/AX9gCn9/f39/f39/f38Bf2AEf39+fgACbRIBYQFhAAQBYQFiAAYBYQFjAAwBYQFkAAQBYQFlAAQBYQFmAAQBYQFnAAABYQFoAAIBYQFpAAgBYQFqAAABYQFrAAUBYQFsAAUBYQFtAAUBYQFuAAwBYQFvAAcBYQFwAAEBYQFxAAQBYQFyAAADmQGXAQMRAwIFAQQGBgcCDQAAAwMHAw0AAAYGEg4OAgUABQAAAgEBAAkEBAAAAA8PDgwAAAIHAAoKAQEACAAJBBMICBQFBAUBAAQKBwoCCQAACgAEABUCAAYWFxgZEBAPEAgMBhobHAEFAQMEAQIdBQEDCAQCAAkFBA0CAQEHAAEFAQkDAQkDBwACBwEBAQEBCwsGBggIAwMHAQAEBQFwASoqBQcBAYACgIACBggBfwFBsMYeCwckCAFzAgABdABZAXUBAAF2ADMBdwAWAXgApwEBeQCmAQF6AJ0BCUYBAEEBCyl+lwGoAZgBSGVklgGVAUgtlAGTAZIBZWSLAUgthQGFAaUBLaQBngGgAaMBLZ8BoQGiAS2bAS2aAS2cAVSZAVRUCuCqFpcB8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALgAUDAX8HfAJ+IAC9IglCMIinIQEgCUKAgICA8JWp9z99Qv////+flYQBWARAIAlCgICAgICAgPg/UQRARAAAAAAAAAAADwtB+KcaKwMAIgMgAEQAAAAAAADwv6AiAL1CgICAgHCDvyIEoiIFIAAgAKIiAiAAQcCoGisDAKJBuKgaKwMAoKIiBqAiByACIAKiIgggCCACIABBgKkaKwMAokH4qBorAwCgoiAAQfCoGisDAKJB6KgaKwMAoKCiIAIgAEHgqBorAwCiQdioGisDAKCiIABB0KgaKwMAokHIqBorAwCgoKCiIAAgBKEgA6IgAEGAqBorAwCioCAGIAUgB6GgoKCgDwsCQCABQfD/AWtBn4B+TQRAIAC9Qv///////////wCDUARAIwBBEGsiAUQAAAAAAADwvzkDCCABKwMIRAAAAAAAAAAAow8LIAlCgICAgICAgPj/AFENASABQfD/AXFB8P8BRyABQf//AU1xRQRAIAAgAKEiACAAow8LIABEAAAAAAAAMEOivUKAgICAgICAoAN9IQkLIAlCgICAgICAgPM/fSIKQi6Ip0E/cUEEdCIBQZCpGmorAwAgCkI0h6e3oCIDQfinGisDACIEIAFBiKkaaisDACAJIApCgICAgICAgHiDfb8gAUGIsRpqKwMAoSABQZCxGmorAwChoiIAvUKAgICAcIO/IgWiIgagIgcgACAAoiICIAIgAqIgAEGwqBorAwCiQaioGisDAKCiIAIgAEGgqBorAwCiQZioGisDAKCiIABBkKgaKwMAokGIqBorAwCgoKCiIAAgBaEgBKJBgKgaKwMAIACioCAGIAMgB6GgoKCgIQALIAALgAQBA38gAkGABE8EQCAAIAEgAhAQIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0Ag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QQF0IgYgBSAFIAZJGyACQf////8DTxsiBgR/IAYQFwVBAAsiBWoiAiABOgAAIAUgBmohASACQQFqIQYCQCADIAdGBEAgAiEFDAELIAdBf3MgA2ohDCAEQQNxIgkEQEEAIQQDQCACQQFrIgIgA0EBayIDLQAAOgAAIARBAWoiBCAJRw0ACwsgDEEDTwRAA0AgAkEBayADQQFrLQAAOgAAIAJBAmsgA0ECay0AADoAACACQQNrIANBA2stAAA6AAAgAkEEayICIANBBGsiAy0AADoAACADIAdHDQALCyAAKAIAIQMLIAAgATYCCCAAIAY2AgQgACAFNgIAIAMEQCADEBYLDwsQGwALlAQBBH8gASAAIAFGIgI6AAwCQCACDQADQCABKAIIIgItAAwNAQJAIAIgAigCCCIDKAIAIgRGBEACQCADKAIEIgRFDQAgBC0ADA0ADAILAkAgASACKAIARgRAIAIhAQwBCyACIAIoAgQiASgCACIANgIEIAEgAAR/IAAgAjYCCCACKAIIBSADCzYCCCACKAIIIgAgACgCACACR0ECdGogATYCACABIAI2AgAgAiABNgIIIAEoAggiAygCACECCyABQQE6AAwgA0EAOgAMIAMgAigCBCIANgIAIAAEQCAAIAM2AggLIAIgAygCCDYCCCADKAIIIgAgACgCACADR0ECdGogAjYCACACIAM2AgQgAyACNgIIDwsCQCAERQ0AIAQtAAwNAAwBCwJAIAEgAigCAEcEQCACIQEMAQsgAiABKAIEIgA2AgAgASAABH8gACACNgIIIAIoAggFIAMLNgIIIAIoAggiACAAKAIAIAJHQQJ0aiABNgIAIAEgAjYCBCACIAE2AgggASgCCCEDCyABQQE6AAwgA0EAOgAMIAMgAygCBCIAKAIAIgE2AgQgAQRAIAEgAzYCCAsgACADKAIINgIIIAMoAggiASABKAIAIANHQQJ0aiAANgIAIAAgAzYCACADIAA2AggMAgsgBEEMaiEFIAJBAToADCADIAAgA0Y6AAwgBUEBOgAAIAMiASAARw0ACwsL6AIBAn8CQCAAIAFGDQAgASAAIAJqIgRrQQAgAkEBdGtNBEAgACABIAIQFA8LIAAgAXNBA3EhAwJAAkAgACABSQRAIAMEQCAAIQMMAwsgAEEDcUUEQCAAIQMMAgsgACEDA0AgAkUN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ASECDAELIAggAjYCDCAIIAE2AhALIAlBBUYNAwNAAkAgBCAIIABBAnQiBWoiCigCACIBai0AACACIARqLQAATwRAIAIhAQwBCyAKIAI2AgAgCCABNgIMCwJAIAQgBSAIaiIFQQRqKAIAIgJqLQAAIAEgBGotAABPBEAgASECDAELIAUgATYCBCAIIAI2AgwLIABBAmoiACAJRw0ACwsgCUECaw4CAAECCyAHIANBA3ZqIgAgADEAACAINQIAIANBB3GthoQ3AAAgBiADIAtqIgA2AgAgByAAQQN2aiIBIAExAAAgCDUCBCAAQQdxrYaENwAAIAYgACALajYCAAwCCyAHIANBA3ZqIgAgADEAACAINQIAIANBB3GthoQ3AAAgBiADIAtqIgA2AgAgByAAQQN2aiIBIAExAAAgCDUCBCAAQQdxrYaENwAAIAYgACALaiIANgIAIAcgAEEDdmoiASABMQAAIAg1AgggAEEHca2GhDcAACAGIAAgC2o2AgAMAQsgByADQQN2aiIAIAAxAAAgCCgCACIBrSADQQdxrYaENwAAIAYgAyALaiIANgIAIAcgAEEDdmoiAiACMQAAIAg1AgQgAEEHca2GhDcAACAGIAAgC2oiADYCACAHIABBA3ZqIgIgAjEAACAINQIIIABBB3GthoQ3AAAgBiAAIAtqIgA2AgAgByAAQQN2aiICIAIxAAAgCDUCDCAAQQdxrYaENwAAIAYgACALaiIANgIAIAcgAEEDdmoiAiACMQAAIAEgBGotAABBAUatIABBB3GthoQ3AAAgBiAAQQFqNgIACyAIQRBqJAAL3gIBCX8gASAAKAIIIgMgACgCBCICa00EQCAAIAEEfyACQQAgARASIAFqBSACCzYCBA8LIAIgACgCACIFayIGIAFqIgRBAE4EQEH/////ByADIAVrIgNBAXQiCCAEIAQgCEkbIANB/////wNPGyIEBEAgBBAXIQcLIAQgB2ohCCABIAYgB2oiA0EAIAEQEiIEaiEJAkAgAiAFRgRAIAQhBwwBCyAFQX9zIAJqIQogBkEDcSIGBEBBACEBA0AgA0EBayIDIAJBAWsiAi0AADoAACABQQFqIgEgBkcNAAsLIApBA08EQANAIANBAWsgAkEBay0AADoAACADQQJrIAJBAmstAAA6AAAgA0EDayACQQNrLQAAOgAAIANB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ECIDRQ0EIAZBEGohAQsDQCABIQQgAyICQRRqIgEoAgAiAw0AIAJBEGohASACKAIQIgMNAAsgBEEANgIADAQLQcjCGiAGQShrIgBBeCACa0EHcSIBayIINgIAQdTCGiABIAJqIgE2AgAgASAIQQFyNgIEIAAgAmpBKDYCBEHYwhpBpMYaKAIANgIAIAMgBEEnIARrQQdxakEvayIAIAAgA0EQakkbIgFBGzYCBCABQYTGGikCADcCECABQfzFGikCADcCCEGExhogAUEIajYCAEGAxhogBjYCAEH8xRogAjYCAEGIxhpBADYCACABQRhqIQADQCAAQQc2AgQgAEEIaiEMIABBBGohACAMIARJDQALIAEgA0YNACABIAEoAgRBfnE2AgQgAyABIANrIgJBAXI2AgQgASACNgIAIAJB/wFNBEAgAkF4cUHkwhpqIQACf0G8whooAgAiAUEBIAJBA3Z0IgJxRQRAQbzCGiABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAMgADYCHCADQgA3AhAgAEECdEHsxBpqIQECQAJAQcDCGigCACIEQQEgAHQiBnFFBEBBwMIaIAQgBnI2AgAgASADNgIADAELIAJBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhBANAIAQiASgCBEF4cSACRg0CIABBHXYhBCAAQQF0IQAgASAEQQRxaiIGKAIQIgQNAAsgBiADNgIQCyADIAE2AhggAyADNgIMIAMgAzYCCAwBCyABKAIIIgAgAzYCDCABIAM2AgggA0EANgIYIAMgATYCDCADIAA2AggLQcjCGigCACIAIAVNDQBByMIaIAAgBWsiATYCAEHUwhpB1MIaKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwIC0G4whpBMDYCAEEAIQAMBwtBACECCyAIRQ0AAkAgBigCHCIBQQJ0QezEGmoiBCgCACAGRgRAIAQgAjYCACACDQFBwMIaQcDCGigCAEF+IAF3cTYCAAwCCyAIQRBBFCAIKAIQIAZGG2ogAjYCACACRQ0BCyACIAg2AhggBigCECIBBEAgAiABNgIQIAEg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IAEgBCkDEDcCECABIAQpAwg3AgggASAEKQMANwIADAELIAUgBkkEQCAEIAApAhg3AxggBCAAKQIQNwMQIAQgACkCCDcDCCAEIAApAgA3AwAgACACKQIYNwIYIAAgAikCEDcCECAAIAIpAgg3AgggACACKQIANwIAIAIgBCkDGDcCGCACIAQpAxA3AhAgAiAEKQMINwIIIAIgBCkDADcCAEEBDAILIAQgACkCGDcDGCAEIAApAhA3AxAgBCAAKQIINwMIIAQgACkCADcDACAAIAEpAhg3AhggACABKQIQNwIQIAAgASkCCDcCCCAAIAEpAgA3AgAgASAEKQMYNwIYIAEgBCkDEDcCECABIAQpAwg3AgggASAEKQMANwIAQQEgAigCACABKAIATw0BGiAEIAEpAhg3AxggBCABKQIQNwMQIAQgASkCCDcDCCAEIAEpAgA3AwAgASACKQIYNwIYIAEgAikCEDcCECABIAIpAgg3AgggASACKQIANwIAIAIgBCkDGDcCGCACIAQpAxA3AhAgAiAEKQMINwIIIAIgBCkDADcCAAtBAgshBSADKAIAIAIoAgBJBH8gBCACKQIYNwMYIAQgAikCEDcDECAEIAIpAgg3AwggBCACKQIANwMAIAIgAykCGDcCGCACIAMpAhA3AhAgAiADKQIINwIIIAIgAykCADcCACADIAQpAxg3AhggAyAEKQMQNwIQIAMgBCkDCDcCCCADIAQpAwA3AgAgAigCACABKAIATwRAIAVBAWoPCyAEIAEpAhg3AxggBCABKQIQNwMQIAQgASkCCDcDCCAEIAEpAgA3AwAgASACKQIYNwIYIAEgAikCEDcCECABIAIpAgg3AgggASACKQIANwIAIAIgBCkDGDcCGCACIAQpAxA3AhAgAiAEKQMINwIIIAIgBCkDADcCACABKAIAIAAoAgBPBEAgBUECag8LIAQgACkCGDcDGCAEIAApAhA3AxAgBCAAKQIINwMIIAQgACkCADcDACAAIAEpAhg3AhggACABKQIQNwIQIAAgASkCCDcCCCAAIAEpAgA3AgAgASAEKQMYNwIYIAEgBCkDEDcCECABIAQpAwg3AgggASAEKQMANwIAIAVBA2oFIAULC+EBAQR/IwBBEGsiBSQAIwBBIGsiAyQAIwBBEGsiBCQAIAQgATYCDCAEIAEgAmo2Aggg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ADcCACAGIAUpAxg3AhggBiAFKQMQNwIQIAYgBSkDCDcCCCAGIAUpAwA3AgAgACgCACAEKAIATwRAIApBA2ohCgwCCyAFIAQpAhg3AxggBSAEKQIQNwMQIAUgBCkCCDcDCCAFIAQpAgA3AwAgBCAAKQIYNwIYIAQgACkCEDcCECAEIAApAgg3AgggBCAAKQIANwIAIAAgBSkDGDcCGCAAIAUpAxA3AhAgACAFKQMINwIIIAAgBSkDADcCACAKQQRqIQoMAQsgCSgCACEAAkAgBigCACIHIAQoAgBPBEBBACEKIAAgB08NAiAFIAYpAhg3AxggBSAGKQIQNwMQIAUgBikCCDcDCCAFIAYpAgA3AwAgBiAJKQIYNwIYIAYgCSkCEDcCECAGIAkpAgg3AgggBiAJKQIANwIAIAkgBSkDGDcCGCAJIAUpAxA3AhAgCSAFKQMINwIIIAkgBSkDADcCAEEBIQogBigCACAEKAIATw0CIAUgBCkCGDcDGCAFIAQpAhA3AxAgBSAEKQIINwMIIAUgBCkCADcDACAEIAYpAhg3AhggBCAGKQIQNwIQIAQgBikCCDcCCCAEIAYpAgA3AgAgBiAFKQMYNwIYIAYgBSkDEDcCECAGIAUpAwg3AgggBiAFKQMANwIADAELIAAgB0kEQCAFIAQpAhg3AxggBSAEKQIQNwMQIAUgBCkCCDcDCCAFIAQpAgA3AwAgBCAJKQIYNwIYIAQgCSkCEDcCECAEIAkpAgg3AgggBCAJKQIANwIAIAkgBSkDGDcCGCAJIAUpAxA3AhAgCSAFKQMINwIIIAkgBSkDADcCAEEBIQoMAgsgBSAEKQIYNwMYIAUgBCkCEDcDECAFIAQpAgg3AwggBSAEKQIANwMAIAQgBikCGDcCGCAEIAYpAhA3AhAgBCAGKQIINwIIIAQgBikCADcCACAGIAUpAxg3AhggBiAFKQMQNwIQIAYgBSkDCDcCCCAGIAUpAwA3AgBBASEKIAkoAgAgBigCAE8NASAFIAYpAhg3AxggBSAGKQIQNwMQIAUgBikCCDcDCCAFIAYpAgA3AwAgBiAJKQIYNwIYIAYgCSkCEDcCECAGIAkpAgg3AgggBiAJKQIANwIAIAkgBSkDGDcCGCAJIAUpAxA3AhAgCSAFKQMINwIIIAkgBSkDADcCAAtBAiEKCyADQQFrIQMgCSEA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gICAgAQhA0EAIQdBACEAA0AgAyABIAdBAnQiCWooAgAiCiADIApJGyADIAobIgMgASAJQQRyaigCACIJIAMgCUkbIAMgCRshAyAGIApBAEdqIAlBAEdqIQYgB0ECaiEHIABBAmoiACAMRw0ACwsgDQRAIAMgASAHQQJ0aigCACIAIAAgA0sbIAMgABshAyAGIABBAEdqIQYLIAZBBUkNAAJAIANBA0sNACAIIAZrQQVLDQAgBUECSQ0AQQEhBQNAAkAgBUECdCABaiIAQQRrKAIARQ0AIAAoAgANACAAKAIERQ0AIABBATYCAAsgBUEBaiIFIARHDQALCyAGQRxJDQBBACEFIAJBACAIEBIhCiABKAIAIQNBACEHA0ACQAJAIAciACAIRiICRQRAIAEgAEECdGooAgAgA0YNAQsCQCADRSIHIAVBBEtxRQRAIAcNASAFQQdJDQEgBUUNAQsgACAKaiAFa0EBIAUQEhoLQQEhBSACDQEgASAAQQJ0aigCACEDDAELIAVBAWohBQsgAEEBaiEHIAAgCEkNAAsgCEECayEFIAEoAgggASgCBCABKAIAampBCHRBA25BpANqIQdBACEDQQAhBEEAIQYDQAJAAkACQCADIgAgCEYiCQ0AIAAgCmoiAi0AAA0AIAAEQCACQQFrLQAADQELIAEgAEECdGooAgAiAkEIdCAHa0HYCWtBz2xLDQELAkAgBkEDTQRAIAZBA0cNASAEDQELQQAhB0EBIAQgBkEBdmoiAiAGbiACIAZJG0EAIAQbIQJBACEEIAZBAWtBA08EQCAGQXxxIQtBACEDA0AgASAAIARBf3NqQQJ0aiACNgIAIAEgACAEQf7///8Dc2pBAnRqIAI2AgAgASAAIARB/f///wNzakECdGogAjYCACABIAAgBEH8////A3NqQQJ0aiACNgIAIARBBGohBCADQQRqIgMgC0cNAAsLIAZBA3EiA0UNAANAIAEgACAEQX9zakECdGogAjYCACAEQQFqIQQgB0EBaiIHIANHDQALCwJ/IAAgBUkEQCABIABBAnRqIgIoAgQgAigCAGogAigCCGpBCHRBA25BpANqDAELQQAgACAITw0AGiABIABBAnRqKAIAQQh0CyEHQQAhBEEBIQYgCQ0BIAEgAEECdGooAgAhBAwBCyACIARqIQQgBkEBaiIGQQRJDQAg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Ajg3AxggAiAAKQIwNwMQIAIgACkCKDcDCCACIAApAiA3AwAgACABKQIYNwI4IAAgASkCEDcCMCAAIAEpAgg3AiggACABKQIANwIgIAEgAikDGDcCGCABIAIpAxA3AhAgASACKQMINwIIIAEgAikDADcCACAAKAIgIAAoAgBPDQQgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgACkCODcCGCAAIAApAjA3AhAgACAAKQIoNwIIIAAgACkCIDcCACAAIAIpAxg3AjggACACKQMQNwIwIAAgAikDCDcCKCAAIAIpAwA3AiAMBAsgAyAESQRAIAIgACkCGDcDGCACIAApAhA3AxAgAiAAKQIINwMIIAIgACkCADcDACAAIAEpAhg3AhggACABKQIQNwIQIAAgASkCCDcCCCAAIAEpAgA3AgAgASACKQMYNwIYIAEgAikDEDcCECABIAIpAwg3AgggASACKQMANwIADAQLIAIgACkCGDcDGCACIAApAhA3AxAgAiAAKQIINwMIIAIgACkCADcDACAAIAApAjg3AhggACAAKQIwNwIQIAAgACkCKDcCCCAAIAApAiA3AgAgACACKQMYNwI4IAAgAikDEDcCMCAAIAIpAwg3AiggACACKQMANwIgIAEoAgAgACgCIE8NAyACIAApAjg3AxggAiAAKQIwNwMQIAIgACkCKDcDCCACIAApAiA3AwAgACABKQIYNwI4IAAgASkCEDcCMCAAIAEpAgg3AiggACABKQIANwIgIAEgAikDGDcCGCABIAIpAxA3AhAgASACKQMINwIIIAEgAikDADcCAAwDCyAAIABBIGogAEFAayABQSBrEDYaDAILIAAgAEEgaiAAQUBrIgMgAEHgAGoQNhogAUEgayIBKAIAIAAoAmBPDQEgAiAAKQJ4NwMYIAIgACkCcDcDECACIAApAmg3AwggAiAAKQJgNwMAIAAgASkCGDcCeCAAIAEpAhA3AnAgACABKQIINwJoIAAgASkCADcCYCABIAIpAxg3AhggASACKQMQNwIQIAEgAikDCDcCCCABIAIpAwA3AgAgACgCYCADKAIATw0BIAIgAykCGDcDGCACIAMpAhA3AxAgAiADKQIINwMIIAIgAykCADcDACADIAApAng3AhggAyAAKQJwNwIQIAMgACkCaDcCCCADIAApAmA3AgAgACACKQMYNwJ4IAAgAikDEDcCcCAAIAIpAwg3AmggACACKQMANwJgIAMoAgAgACgCIE8NASACIAApAjg3AxggAiAAKQIwNwMQIAIgACkCKDcDCCACIAApAiA3AwAgACADKQIYNwI4IAAgAykCEDcCMCAAIAMpAgg3AiggACADKQIANwIgIAMgAikDGDcCGCADIAIpAxA3AhAgAyACKQMINwIIIAMgAikDADcCACAAKAIgIAAoAgBPDQEgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgACkCODcCGCAAIAApAjA3AhAgACAAKQIoNwIIIAAgACkCIDcCACAAIAIpAxg3AjggACACKQMQNwIwIAAgAikDCDcCKCAAIAIpAwA3AiAMAQsgAEFAayEDIAAoAkAhBAJAIAAoAiAiBiAAKAIAIgdPBEAgBCAGTw0BIAIgACkCODcDGCACIAApAjA3AxAgAiAAKQIoNwMIIAIgACkCIDcDACAAIAMpAhg3AjggACADKQIQNwIwIAAgAykCCDcCKCAAIAMpAgA3AiAgAyACKQMYNwIYIAMgAikDEDcCECADIAIpAwg3AgggAyACKQMANwIAIAAoAiAgB08NASACIAApAhg3AxggAiAAKQIQNwMQIAIgACkCCDcDCCACIAApAgA3AwAgACAAKQI4NwIYIAAgACkCMDcCECAAIAApAig3AgggACAAKQIgNwIAIAAgAikDGDcCOCAAIAIpAxA3AjAgACACKQMINwIoIAAgAikDADcCIAwBCyAEIAZJBEAgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgAykCGDcCGCAAIAMpAhA3AhAgACADKQIINwIIIAAgAykCADcCACADIAIpAxg3AhggAyACKQMQNwIQIAMgAikDCDcCCCADIAIpAwA3AgAMAQsgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgACkCODcCGCAAIAApAjA3AhAgACAAKQIoNwIIIAAgACkCIDcCACAAIAIpAxg3AjggACACKQMQNwIwIAAgAikDCDcCKCAAIAIpAwA3AiAgBCAAKAIgTw0AIAIgACkCODcDGCACIAApAjA3AxAgAiAA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DUEAIQcgA0EETwRAIANB/AFxIQhBACEAA0AgDSAHQZAWbGpBAEGEFhASQoCAgICAgID4/wA3A4gWIA0gB0EBckGQFmxqQQBBhBYQEkKAgICAgICA+P8ANwOIFiANIAdBAnJBkBZsakEAQYQWEBJCgICAgICAgPj/ADcDiBYgDSAHQQNyQZAWbGpBAEGEFhASQoCAgICAgID4/wA3A4gWIAdBBGohByAAQQRqIgAgCEcNAAsLIAQEQANAIA0gB0GQFmxqQQBBhBYQEkKAgICAgICA+P8ANwOIFiAHQQFqIQcgAUEBaiIBIARHDQALCyAVQSlrIQcgFSADbiEIQQchCkEAIQADQCAAIBVsIANuIQEgAARAIApBp4MBbCIKIAhwIAFqIQELIA0gAEGQFmxqIgQgBCgCgBZBKGo2AoAWIAQgGiABIAcgAUEoaiAVSRtBAXRqIgEvAQBBAnRqIgsgCygCAEEBajYCACAEIAEvAQJBAnRqIgsgCygCAEEBajYCACAEIAEvAQRBAnRqIgsgCygCAEEBajYCACAEIAEvAQZBAnRqIgsgCygCAEEBajYCACAEIAEvAQhBAnRqIgsgCygCAEEBajYCACAEIAEvAQpBAnRqIgsgCygCAEEBajYCACAEIAEvAQxBAnRqIgsgCygCAEEBajYCACAEIAEvAQ5BAnRqIgsgCygCAEEBajYCACAEIAEvARBBAnRqIgsgCygCAEEBajYCACAEIAEvARJBAnRqIgsgCygCAEEBajYCACAEIAEvARRBAnRqIgsgCygCAEEBajYCACAEIAEvARZBAnRqIgsgCygCAEEBajYCACAEIAEvARhBAnRqIgsgCygCAEEBajYCACAEIAEvARpBAnRqIgsgCygCAEEBajYCACAEIAEvARxBAnRqIgsgCygCAEEBajYCACAEIAEvAR5BAnRqIgsgCygCAEEBajYCACAEIAEvASBBAnRqIgsgCygCAEEBajYCACAEIAEvASJBAnRqIgsgCygCAEEBajYCACAEIAEvASRBAnRqIgsgCygCAEEBajYCACAEIAEvASZBAnRqIgsgCygCAEEBajYCACAEIAEvAShBAnRqIgsgCygCAEEBajYCACAEIAEvASpBAnRqIgsgCygCAEEBajYCACAEIAEvASxBAnRqIgsgCygCAEEBajYCACAEIAEvAS5BAnRq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NwPAASAKQoSAgICwATcDgAIgCkKPgICAgAI3A4gCIB0gAjYCBCAdIAM2AoABIB0gBCgCADYC8AEgHSAFNgLgASAdQQA2AoQCIApBFjYCCCAKIAA2AgQgCiACNgIQIAogATYCACAdQYQCaiE9QQAhASMAQRBrIkIkACAKEC8CQCAKKALQKUF/Rw0AAkACQCAKKALUKQ4FAQAAAgIACyAdKAIEDQELIAooAgQiAEECTwRAIApBwClqIUcgCkG4KWohOyAKQbQpaiFFIApB4ABqIT4DQAJAIAopA7gBIbYBIAopA3AhtwEgChAvAkBBASAKKAIMdCIAILcBILYBfSK2AaciBkYgtgEgAK1acg0AIB0oAgQiAUUNACAAIAZrIgAgASAAIAFJGyEAIB0oAoABIQggChAvAkACQCAKKAKMASIGDQAgCigCgAEgAE0NACAKIAA2AowBIABBCWoiAQR/ID4gARAVBUEACyEBIAooApABIgYEQCABIAYgCigCiAFBCWoQFBogPigCCCAKKAKQASA+KAIEEQAACyAKIAA2AogBIAogATYCkAEgCiABQQJqNgKUASABQQA6AAEgCigClAFBAmtBADoAACAKKAKUASAKKAKIAWpBADoAACAKKAKIASAKKAKUAWpBADoAASAKKAKIASAKKAKUAWpBADoAAiAKKAKIASAKKAKUAWpBADoAAyAKKAKIASAKKAKUAWpBADoABCAKKAKIASAKKAKUAWpBADoABSAKKAKIASAKKAKUAWpBADoABiAKKAKUASAIIAAQFBogCigCjAEhBgwBCyAKKAKEASIHIAooAogBSwRAIAdBCWoiAQR/ID4gARAVBUEACyEBIAooApABIgYEQCABIAYgCigCiAFBCWoQFBogPigCCCAKKAKQASA+KAIEEQAACyAKIAc2AogBIAogATYCkAEgCiABQQJqNgKUASABQQA6AAEgCigClAFBAmtBADoAACAKKAKUASAKKAKIAWpBADoAACAKKAKIASAKKAKUAWpBADoAASAKKAKIASAKKAKUAWpBADoAAiAKKAKIASAKKAKUAWpBADoAAyAKKAKIASAKKAKUAWpBADoABCAKKAKIASAKKAKUAWpBADoABSAKKAKIASAKKAKUAWpBADoABiAKKAJ4IAooApQBakECa0EAOgAAIAooAnggCigClAFqQQFrQQA6AAAgCigCjAEhBgsgCigCgAEiByAKKAJ8IAZxIgFLBEAgCigClAEgCigCeCABamogCCAAIAcgAWsiBiAAIAZJGxAUGgsgCigClAEgAWohBgJAIAooAnggACABak8EQCAGIAggABAUGgwBCyAGIAggACAKKAKEASABayIGIAAgBkkbEBQaIAooApQBIAggCigCeCABayIBaiAAIAFrEBQaCyAKKAKMASEBIAooApQBQQJrIgYgBiAKKAJ4ai0AADoAACAKKAKUAUEBayIGIAYgCigCeGotAAA6AAAgCiAKKAKMAUH/////B3EgAEH/////B3FqIAFBgICAgHhxciIGNgKMAQsgCiAKKQNwIACtfDcDcCAKKAJ8IAZPBEAgCigClAEgBmoiAUEANgAAIAFBADYAAwsgHSAdKAKAASAAajYCgAEgHSAdKAIEIABrNgIEDAILAkACQCAKKALUKSIAQQFGBEAgCi0AkgIiAARAIApBADoAkgIgCi8BkAIhTiAKQQA7AZACIE5BBiAAdCIIciEBAn8gCigCtCkiBgRAIAYgOygCAGoMAQsgRSBHNgIAIEcLIgYgAToAAAJAIABBA0kNACAGIAFBCHY6AAEgAEELSQ0AIAYgCEEQdjoAAgsgOyA7KAIAIABBDWpBA3ZqNgIADAULIDsoAgAiCA0BIApBADYCtCkgCkEANgLUKQwDCyA7KAIAIghFDQELIB0oAvABIgBFDQEgHSgC4AEgCigCtCkgCCAAIAAgCEsbIgAQFBogHSAdKALgASAAajYC4AEgHSAdKALwASAAazYC8AEgCiAKKAK0KSAAajYCtCkgCiAKKAK4KSAAazYCuCkgCiAKKAK8KSAAaiIANgK8KSA9RQ0CID0gADYCAAwCC0EBIQYgAA0DIB0oAgQiAEUiN0EAcSFBIAooAhBFBEAgCkGAgICABEGAgICABEGAgICABCAKKQNwIAopA7gBfSK2ASAArXwitwGnILcBQv////8DVhsgtgFC/////wNWGyAAQf////8DSxs2AhALQQAhDUEAIQ5EAAAAAAAAAAAhuwFEAAAAAAAAAAAhvQFEAAAAAAAAAAAhvwEjAEGAD2siLCQAIAopA7gBIrcBpyIRIQggtwFCgICAgAxaBEAgEUEBdEEBdUGAgICAfHEgEUH/////A3FyQYCAgIB4cyEICyAK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ICo2AgAgFyAGQQV0NgIEIBdBCGohFyAGIQELIAhBAWsiCCAhTQ0BIAFBA0kNAAsLAkAgASAbTw0AIB8oAgAiKiAWcUEBdCEeIB8gECAgaigAAEG9z9bxAWxBDXZB/P8fcWoiACgCBCEHIBtBgAFJIiFFBEAgACAWNgIECyAeQQFyISkCfwJAIAcgFkYNACAbQYABICEbITJBACEIQcAAIQlBACEOA0AgFiAHayI0ICZLDQEgCUUNASAQIA4gCCAIIA5LGyIoICBqaiEvQQAhAAJAIBAgKCAHIBRxIjNqaiIGIBsgKGtqIhVBBGsiNSAGSQ0AA0AgBigAACAAIC9qKAAARw0BIABBBGohACAGQQRqIgYgNU0NAAsLAkAgBiAVTw0AIAYgFSAGayIVaiE1IAAgFWohUwNAIAAgL2otAAAgBi0AAEcNASAAQQFqIQAgBkEBaiIGIDVHDQALIFMhAAsgACAoaiEAAkAgF0UEQEEAIRcMAQsgACABTQ0AIBcgNDYCACAXIABBBXQ2AgQgF0EIaiEXIAAhAQsgACAyTwRAICENBCASIB5BAnRqIBIgByAqcUEDdGoiACgCADYCACAAQQRqDAMLIAlBAWshCSASAn8gECAAICBqai0AACAQIAAgM2pqLQAASwRAICFFBEAgEiAeQQJ0aiAHNgIACyAAIQ4gByAqcUEBdEEBciIeDAELICFFBEAgEiApQQJ0aiAHNgIACyAAIQggByAqcUEBdCIpC0ECdGooAgAiByAWRw0ACwsgIQ0BIBIgHkECdGogGSgCADYCACAZCyEAIBIgKUECdGogACgCADYCAAsgE0L/////8P///w83A8AwIBNC//////D///8PNwO4MCATQv/////w////DzcDsDAgE0L/////8P///w83A6gwIBNC//////D///8PNwOgMCATQv/////w////DzcDmDAgE0L/////8P///w83A5AwIBNC//////D///8PNwOIMCATQv/////w////DzcDgDAgE0L/////8P///w83A/gvIBNC//////D///8PNwPwLyATQv/////w////DzcD6C8gE0L/////8P///w83A+AvIBNC//////D///8PNwPYLyATQv/////w////DzcD0C8gE0L/////8P///w83A8gvIBNC//////D///8PNwPALyATQv//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ACkCADcCACAAICkoAgA2AhggACAoKQMANwIQIAAgLikDADcCCCAAIBMpA7AeNwIACyAXQQZGDQAgACoCFCATQbAvakENIBVrQQdxQRxsaiIPKgIUXgRAIBNByB5qIhUgACgCGDYCACATQcAeaiIpIAApAhA3AwAgE0G4HmoiKCAAKQIINwMAIBMgACkCADcDsB4gACAPKAIYNgIYIAAgDykCEDcCECAAIA8pAgg3AgggACAPKQIANwIAIA8gFSgCADYCGCAPICkpAwA3AhAgDyAoKQMANwIIIA8gEykDsB43AgALIBdBB0YNACAPKgIUIBNBsC9qQQYgB2tBB3FBHGxqIgAqAhReRQ0AIBNByB5qIgcgDygCGDYCACATQcAeaiIVIA8pAhA3AwAgE0G4HmoiFyAPKQIINwMAIBMgDykCADcDsB4gDyAAKAIYNgIYIA8gACkCEDcCECAPIAApAgg3AgggDyAAKQIANwIAIAAgBygCADYCGCAAIBUpAwA3AhAgACAXKQMANwIIIAAgEykDsB43AgALIAEhBwsgIyAqaigCACAIaiEIIAYhACAMQQFrIgwNAQsLIBMgATYCkDELIAZBAWohACAGQQRqIAtJDQALCyALIQYCQCAmKAIIQf///z9xDQADQCAJIAZBBHRqKAIAQQFHDQEgCSAGQQFrIgZBBHRqKAIIQf///z9xRQ0ACwsgCSAGQQR0akF/NgIMQQAhDEEAIQAgBgRAA0AgCSAGIAkgBkEEdGoiASgCCEH///8/cSABKAIAQf///w9xaiIBayIGQQR0aiABNgIMIABBAWohACAGDQALCyAcIBwoAgAgAGo2AgAgCyANICUgCSAaICcgCiAtICsQUSAkDQALICIoAgggEygClBYgIigCBBEAACATQQA2ApQWICIoAgggEygCjBYgIigCBBEAACATQQA2AowWICIoAgggCSAiKAIEEQAAICIoAgggESAiKAIEEQAAICIoAgggIyAiKAIEEQAAIBNBsM0AaiQADAELIAghESAKKAJsIQggCkHAAWohACAKQagBaiEBIAooApwBIAdBBHRqIQcgCkGkAWohBgJAAkACQAJAAkACQAJAAkACQAJAIAooAhxBAmsONQABAgMECQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJBQYHCQkJCQkJCQkJ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DEYNACAMIABrIhEgGUsNACABIBBqISdBACEAAkAgGCAGIgFJDQADQCABKAAAIAAgJ2ooAABHDQEgAEEEaiEAIAFBBGoiASAYTQ0ACwsCQCABIBZPDQAgASAWIAFrIhVqISQgACAVaiFoA0AgACAnai0AACABLQAARw0BIABBAWohACABQQFqIgEgJEcNAAsgaCEACyAAQQRJDQAgDiARZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgECAAICNqai0AACENIAEhDiARIQcgACELCwJAIBAgICgCCCIAIBRxIgEgC2pqLQAAIA1B/wFxRw0AIAAgDEYNACAMIABrIhEgGUsNACABIBBqISdBACEAAkAgGCAGIgFJDQADQCABKAAAIAAgJ2ooAABHDQEgAEEEaiEAIAFBBGoiASAYTQ0ACwsCQCABIBZPDQAgASAWIAFrIhVqISQgACAVaiFpA0AgACAnai0AACABLQAARw0BIABBAWohACABQQFqIgEgJEcNAAsgaSEACyAAQQRJDQAgDiARZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgECAAICNqai0AACENIAEhDiARIQcgACELCwJAIBAgICgCDCIAIBRxIgEgC2pqLQAAIA1B/wFxRw0AIAAgDEYNACAMIABrIg0gGUsNACABIBBqIRVBACEAAkAgGCAGIgFJDQADQCABKAAAIAAgFWooAABHDQEgAEEEaiEAIAFBBGoiASAYTQ0ACwsCQCABIBZPDQAgASAWIAFrIhFqIRYgACARaiFqA0AgACAVai0AACABLQAARw0BIABBAWohACABQQFqIgEgFkcNAAsgaiEACyAAQQRJDQAgDiANZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgASEOIA0hByAAIQsLQQAhGEEAIRECQAJAAkAgDkGkCEYEQCASKAIcIg0gEigCGCIBQQd2SQ0BIAooAlAgCUG9z9bxAWxBEHZB/P8DcWovAQAhACASIAFBAWo2AhggAEUNASAAQR9xIgcgH0sNAUEAIQsCQCAKKAJAIgkoAqQBIAkgB0ECdGooAiAgByAAQQV2Ig5samoiACAHaiIBQQRrIhEgAEkNAANAIAAoAAAgBiALaigAAEcNASALQQRqIQsgAEEEaiIAIBFNDQALCwJAIAAgAU8NACAAIAEgAGsiAWohESABIAtqIWsDQCAGIAtqLQAAIAAtAABHDQEgC0EBaiELIABBAWoiACARRw0ACyBrIQsLIAtFDQEgCigCRCALaiAHTQ0BIBlBAWogDmogCikDSCAHIAtrIhFBBmytiKdBP3EgEUECdGogByAJai0AAHRqIgcgMEsNASALQYcBbCAHZ0Efc0FibGpBwAdqIg5BpAhJDQEgEiANQQFqNgIcCyAlIAxBA3ZBA3EgHmpBAnRqIAw2AgAgDkGlCEkNAQNAIAxBAWoiFSArSSEjQQAhCCAQIAtBAWsiACAfQQFrIh8gACAfSRtBACAKKAIEQQVIGyIGIBQgFXEiJGpqLQAAISAgECAkaiINKQAAIbYBQaQIIQkCQCAVIBcoAgAiFmsiACAVTw0AICAgECAAIBRxIgAgBmpqLQAARw0AIAAgEGohGUEAIQACQCANIgEgASAfaiIIQQRrIh5LDQADQCABKAAAIAAgGWooAABHDQEgAEEEaiEAIAFBBGoiASAeTQ0ACwsCQCABIAhPDQAgASAIIAFrIghqIR4gACAIaiFsA0AgACAZai0AACABLQAARw0BIABBAWohACABQQFqIgEgHkcNAAsgbCEAC0EAIQggAEEESQ0AIABBhwFsQc8HaiIBQaUISQ0AIBAgACAkamotAAAhICABIQkgFiEIIAAhBgsgFSArICMbISMgDSAfaiIeQQRrIScCQCAgIBAgJSC2AUKAgIDo+7SNj71/fkIviKciMUECdGoiKSgCACIAIBRxIgEgBmpqLQAARw0AIAAgFUYNACAVIABrIhYgI0sNACABIBBqIS5BACEAAkAgJyANIgFJDQADQCABKAAAIAAgLmooAABHDQEgAEEEaiEAIAFBBGoiASAnTQ0ACwsCQCABIB5PDQAgASAeIAFrIhlqITIgACAZaiFtA0AgACAuai0AACABLQAARw0BIABBAWohACABQQFqIgEgMkcNAAsgbSEACyAAQQRJDQAgCSAWZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgECAAICRqai0AACEgIAEhCSAWIQggACEGCwJAICAgECApKAIEIgAgFHEiASAGamotAABHDQAgACAVRg0AIBUgAGsiFiAjSw0AIAEgEGohLkEAIQACQCAnIA0iAUkNAANAIAEoAAAgACAuaigAAEcNASAAQQRqIQAgAUEEaiIBICdNDQAL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JSgCACEhIAooAgghASAAIhggACgCACIAQQNqNgIkIBggAEEDazYCICAYIABBAmo2AhwgGCAAQQJrNgIYIBggAEEBajYCFCAYIABBAWs2AhAgGCAYKAIEIgBBA2o2AjwgGCAAQQNrNgI4IBggAEECajYCNCAYIABBAms2AjAgGCAAQQFqNgIsIBggAEEBazYCKAJAIAsgEWoiJyARQQRqTQRAIAchGgwBCyAnQQNrIi4gESALQQNLGyEvQQEgAXRBEGshKyAnQQRrITFBwABBgAQgBkEJSBsiMkECdCE6IBlBIGohHiARIDJqISMgEyEaA0AgECARIBRxIjBqIgwgJyARayImaiIXQQRrISAgESArIBEgK0kbISQgDCgAAEG9z9bxAWxBEXYhDyAKKAI8ISlBACEGQaQIIQdBACEIQaQIIRJBACEWQQAhCQNAIBEgGCAJQQJ0aigCACILayEAAkAgCQRAIB4gAEH//wNxakGAgAxqLQAAIA9B/wFxRw0BCyALICRLDQAgACARTw0AIBAgACAUcWohDUEAIQACQCAgIAwiAUkNAANAIAEoAAAgACANaigAAEcNASAAQQRqIQAgAUEEaiIBICBNDQALCwJAIAEgF08NACABIBcgAWsiDmohFSAAIA5qIZ0BA0AgACANai0AACABLQAARw0BIABBAWohACABQQFqIgEgFUcNAAsgnQEhAAsgAEECSQ0AIBIgAEGHAWwiDkHPB2oiAU8NACAJBEAgDkGQlAcgCUEOcXZBDnFrQagHaiEBCyABIBJNDQAgCyEGIAAiCCEWIAEiByESCyAJQQFqIglBEEcNAAsgD0H/A3EhKiARIB4gD0ECdGoiNCgCAGshCyAeIA9BAXQiM2pBgIAIaiI1LwEAIQ4CQCAZKAKgiFAiG0UNACAeICpBC3RqQYCAEGohNkEAIQkgGyEVIA4hASALIQADQCAAIAlqIgkgJEsNASA2IAFB//8DcUECdGohKAJAIBYgMGoiACAUSw0AIBEgCWsgFHEiASAWaiINIBRLDQAgACAQai0AACANIBBqLQAARw0AIAEgEGohLUEAIQACQCAgIAwiAUkNAANAIAEoAAAgACAtaigAAEcNASAAQQRqIQAgAUEEaiIBICBNDQALCwJAIAEgF08NACABIBcgAWsiDWohOCAAIA1qIZ4BA0AgACAtai0A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QQN2QQNxakECdGogATYCACAAIQELIAAgBkYNAQNAIBogECABIBRxaikAAEKA+p6t46Pv0zV+QiyIpyABQQN2QQNxakECdGogATYCACAaIAFBAWoiAEEDdkEDcSAQIAAgFHFqKQAAQoD6nq3jo+/TNX5CLIinakECdGogADYCACABQQJqIgEgBkcNAAsMAQsgH0EBaiEfAkAgDEEBaiIBICVNDQAgJSAtaiABSQRAIAEgDEERaiIAICsgACArSRsiAE8NAQNAIBogECABIBRxaikAAEKA+p6t46Pv0zV+QiyIpyABQQN2QQNxakECdGogATYCACAfQQRqIR8gAUEEaiIBIABJDQALDAELIAEgDEEJaiIAICsgACArSRsiAE8NAANAIBogECABIBRxaikAAEKA+p6t46Pv0zV+QiyIpyABQQN2QQNxakECdGogATYCACAfQQJqIR8gAUECaiIBIABJDQALCyABIQwLIAxBCGogIUkNAAsLIBsgHyAhaiAMazYCACAcIBwoAgAgESAVa0EEdWo2AgALCyAKKQNwIbYBIAooAgwhACAKKAIIIQEgCikDsAEhtwEgChAvQQAhByAKKAIEQQNMBEAgCigCoAEgCigCpAFqQf7fAEshBwsCQCA3IEFyDQAgBw0AQQFBFyABIAAgACABSBsiACAAQRdOG0EBanQiACC2ASC3AX2nQQEgCigCDHRqSQ0AIABBA3YiACAKKAKkAU0NACAcKAIAIABPDQAgCikDuAEitgGnIQAgtgFCgICAgAxaBEAgAEEBdEEBdUGAgICAfHEgAEH/////A3FyQYCAgIB4cyEACyAKKQNwIrYBpyEBIAogtgE3A7gBAkAgtgFCgICAgAxaBH8gAUEBdEEBdUGAgICAfHEgAUH/////A3FyQYCAgIB4cwUgAQsgAE8NACAKKAJsIgBFDQAgAEEANgIUCyA7QQA2AgAMAQsgCigCqAEiAARAIAogCigCoAEiAUEBajYCoAEgCigCnAEiBiABQQR0IghqIgFBEDsBDiABQoCAgMAANwIEIAEgADYCACAGIAhqAn8gACAAQQVNDQAaIABBgQFNBEAgAEECayIBZ0Efc0EBayIGQQF0IAEgBnZqQQJqDAELIABBwgBrZ0Efc0EKaiAAQcEQTQ0AGkEVIABBwjBJDQAaQRZBFyAAQcKwAUkbCyIB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ACAAQbAWaiILIAApA7gGNwMAICAgACkDkAY3AwAgACBHNwOIFiAAIEg3A4AWIABBgBZqIg9BwAAgAEGAFWoQGCAAIB8pAwg3A4gEIAAgHykDADcDgAQgDiAeKQMINwOYBCAOIB4pAwA3A5AEIA4gHSkDCDcDqAQgDiAdKQMANwOgBCAOIABBqBVqKQMANwPYBCAOIABBoBVqKQMANwPQBCAOIABBmBVqKQMANwPIBCAOIABBkBVqKQMANwPABCAOIAApA4gVNwO4BCAOIAApA4AVNwOwBCAOIBwpAwA3A+AEIA4gHCkDCDcD6AQgDiAbKQMANwPwBCAOIBspAwg3A/gEIBpBwAAgExAYICBCADcDACALQgA3AwAgDEIANwMAIBBCADcDACAKQgA3AwAgBUIANwMAIAAgACkDqAY3A4AXIABCADcDiBYgACAAKQOYBjcDgBYgACAAKQOgBjcDwBYgACAAKQOwBjcDwBcgACAAKQO4BjcDgBkgACAALQCABjoAgBcgACAALQCIBjoAgBggACAALQCQBjoAwBkgACAALQCBBjoAiBcgACAALQCJBjoAiBggACAALQCRBjoAyBkgACAALQCCBjoAkBcgACAALQCKBjoAkBggACAALQCSBjoA0BkgACAALQCDBjoAmBcgACAALQCLBjoAmBggACAALQCTBjoA2BkgACAALQCEBjoAoBcgACAALQCMBjoAoBggACAALQCUBjoA4BkgACAALQCFBjoAqBcgACAALQCNBjoAqBggACAALQCVBjoA6BkgACAALQCGBjoAsBcgACAALQCOBjoAsBggACAALQCWBjoA8BkgACAALQCHBjoAuBcgACAALQCPBjoAuBggACAALQCXBjoA+BkgD0HABSAEIAggCRAaIBpBwAAgBCAIIAkQGiAGDQEgCCgCACEEQQAhCiAHIQUDQCAWIApBAnRqKAIAIhBB/wFxIgYgAEGABmpqLQAAIQwgCSAEQQN2aiILIAsxAAAgAEGABGogBkEBdGozAQAgBEEHca2GhDcAACAIIAQgDGoiBDYCACAJIARBA3ZqIgwgDDEAACAQQQh2IhCtIARBB3GthoQ3AAAgCCAGQQJ0IgtBkPUBaigCACAEaiIENgIAAkAgBkEXSw0AQQAhDCALQZD5AWooAgAgEGoiBkUNAANAIAUtAAAiECAAQYAT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KQMANwPwBCAOIBspAwg3A/gEIBpBwAAgExAYICBCADcDACALQgA3AwAgDEIANwMAIBBCADcDACAKQgA3AwAgBUIANwMAIAAgACkDqAY3A4AXIABCADcDiBYgACAAKQOYBjcDgBYgACAAKQOgBjcDwBYgACAAKQOwBjcDwBcgACAAKQO4BjcDgBkgACAALQCABjoAgBcgACAALQCIBjoAgBggACAALQCQBjoAwBkgACAALQCBBjoAiBcgACAALQCJBjoAiBggACAALQCRBjoAyBkgACAALQCCBjoAkBcgACAALQCKBjoAkBggACAALQCSBjoA0BkgACAALQCDBjoAmBcgACAALQCLBjoAmBggACAALQCTBjoA2BkgACAALQCEBjoAoBcgACAALQCMBjoAoBggACAALQCUBjoA4BkgACAALQCFBjoAqBcgACAALQCNBjoAqBggACAALQCVBjoA6BkgACAALQCGBjoAsBcgACAALQCOBjoAsBggACAALQCWBjoA8BkgACAALQCHBjoAuBcgACAALQCPBjoAuBggACAALQCXBjoA+BkgD0HABSAEIAggCRAaIBpBwAAgBCAIIAkQGiAGDQEgCCgCACEEQQAhCiAHIQUDQCAWIApBAnRqKAIAIhBB/wFxIgYgAEGABmpqLQAAIQwgCSAEQQN2aiILIAsxAAAgAEGABGogBkEBdGozAQAgBEEHca2GhDcAACAIIAQgDGoiBDYCACAJIARBA3ZqIgwgDDEAACAQQQh2IhCtIARBB3GthoQ3AAAgCCAGQQJ0IgtBkPUBaigCACAEaiIENgIAAkAgBkEXSw0AQQAhDCALQZD5AWooAgAgEGoiBkUNAANAIAUtAAAiECAAQYATamotAAAhCyAJIARBA3ZqIg8gDzEAACAAQYAPaiAQQQF0ajMBACAEQQdxrYaENwAAIAggBCALaiIENgIAIAVBAWohBSAMQQFqIgwgBkcNAAsLIApBAWoiCiARRw0ACwwBCyAJIARBA3ZqIgAgADEAADcAACAIIARBAWoiADYCACAJIABBA3ZqIgUgBTEAAEEEQQUgFUGBgARJGyIFQQRrrSAAQQdxrYaENwAAIAggBEEDaiIANgIAIAkgAEEDdmoiBCAEMQAAIBRBAWutIABBB3GthoQ3AAAgCCAAIAVBAnRqIgA2AgAgCSAAQQN2aiIE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IAwgE2ooAABHDQEgDEEEaiEMIApBBGoiCiAVTQ0ACwsCQCAKIBJPDQAgCiASIAprIhBqIRsgDCAQaiEpA0AgDCATai0AACAKLQAARw0BIAxBAWohDCAKQQFqIgogG0cNAAsgKSEMCyAMIA9NDQAgESAZNgIAIBEgDEEFdDYCBCARQQhqIREgDCEPCyANQQFrIg0gGE0NASAPQQNJDQALCwJAIA8gF08NACAgKAIAIhkgDnFBAXQhFSAgIAMgHGooAABBvc/W8QFsQQ12Qfz/H3FqIggoAgQhEiAXQYABSSIYRQRAIAggDjYCBAsgFUEBciEbAn8CQCAOIBJGDQAgF0GAASAYGyEiQQAhEEHAACENQQAhEwNAIA4gEmsiJyAaSw0BIA1FDQEgAyATIBAgECATSxsiHiAcamohHUEAIQoCQCADIB4gBCAScSIoamoiDCAXIB5raiIIQQRrIiQgDEkNAANAIAwoAAAgCiAdaigAAEcNASAKQQRqIQogDEEEaiIMICRNDQALCwJAIAggDE0NACAMIAggDGsiCGohJCAIIApqISoDQCAKIB1qLQAAIAwtAABHDQEgCkEBaiEKIAxBAWoiDCAkRw0ACyAqIQoLIAogHmohCAJAIBFFBEBBACERDAELIAggD00NACARICc2AgAgESAIQQV0NgIEIBFBCGohESAIIQ8LIAggIk8EQCAYDQQgFiAVQQJ0aiAWIBIgGXFBA3RqIggoAgA2AgAgCEEEagwDCyANQQFrIQ0gFgJ/IAMgCCAcamotAAAgAyAIIChqai0AAEsEQCAYRQRAIBYgFUECdGogEjYCAAsgCCETIBIgGXFBAXRBAXIiFQwBCyAYRQRAIBYgG0ECdGogEjYCAAsgCCEQIBIgGXFBAXQiGwtBAnRqKAIAIhIgDkcNAAsLIBgNASAWIBVBAnRqIB8oAgA2AgAgHwshCCAWIBtBAnRqIAgoAgA2AgALIAtC//////D///8PNwOQMSALQv/////w////DzcDiDEgC0L/////8P///w83A4AxIAtC//////D///8PNwP4MCALQv/////w////DzcD8DAgC0L/////8P///w83A+gwIAtC//////D///8PNwPgMCALQv/////w////DzcD2DAgC0L/////8P///w83A9AwIAtC//////D///8PNwPIMCALQv//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////P3EgACgCAEH///8PcWoiAGsiAUEEdGogADYCDCAMQQFqIQwgAQ0ACwsgC0HAMWokACAMC+IRAgp/AXwCQCAAQeTClcMGEBwiAUUNACABKAIgRQRAAkAgASgCDCIDIANBA2pBfHEgA0F8SxsiAiABKAIYIAEoAhQiBWsiBEsEQCABQRRqIAIgBGsQJSABKAIMIQMgASgCFCEFDAELIAIgBE8NACABIAIgBWo2AhgLIAUgASgCECADEBQhAyABKAIMIgUgAkkEQCADIAVqQQAgAiAFaxASGgsgASADNgIQCwJAIAAiBUEMaiIAKAIAIgNFDQAgACECIAMhAQNAIAIgASABKAIQQceSzaIESSIEGyECIAFBBGogASAEGygCACIBDQALIAAgAkYNACACKAIQQceSzaIESw0AAkAgAigCBCIARQRAIAIhAANAIAAoAggiASgCACAARyEKIAEhACAKDQALDAELA0AgACIBKAIAIgANAAsLIAIgBSgCCEYEQCAFIAE2AggLIAUgBSgCEEEBazYCEAJ/AkAgAiIEIgEoAgAiAgRAIAEoAgQiAEUNAQNAIAAiASgCACIADQALCyABKAIEIgINAEEAIQJBAQwBCyACIAEoAgg2AghBAAshBwJAIAEgASgCCCIGKAIAIgBGBEAgBiACNgIAIAEgA0YEQEEAIQAgAiEDDAILIAYoAgQhAAwBCyAGIAI2AgQLIAEtAAwhCCABIARHBEAgASAEKAIIIgY2AgggBiAEKAIIKAIAIARHQQJ0aiABNgIAIAEgBCgCACIGNgIAIAYgATYCCCABIAQoAgQiBjYCBCAGBEAgBiABNgIICyABIAQtAAw6AAwgASADIAMgBEYbIQMLAkAgCEUNACADRQ0AIAcEQANAIAAtAAwhAgJAIAAgACgCCCIBKAIARwRAIAJFBEAgAEEBOgAMIAFBADoADCABIAEoAgQiAigCACIGNgIEIAYEQCAGIAE2AggLIAIgASgCCDYCCCABKAIIIgYgBigCACABR0ECdGogAjYCACACIAE2AgAgASACNgIIIAAgAyADIAAoAgAiAEYbIQMgACgCBCEACwJAAkACQAJAIAAoAgAiAQRAIAEtAAxFDQELIAAoAgQiAgRAIAItAAxFDQILIABBADoADAJAIAMgACgCCCIARgRAIAMhAAwBCyAALQAMDQYLIABBAToADAwICyAAKAIEIgJFDQELIAItAAwNACAAIQEMAQsgAUEBOgAMIABBADoADCAAIAEoAgQiAjYCACACBEAgAiAANgIICyABIAAoAgg2AgggACgCCCICIAIoAgAgAEdBAnRqIAE2AgAgASAANgIEIAAgATYCCCAAIQILIAEgASgCCCIALQAMOgAMIABBAToADCACQQE6AAwgACAAKAIEIgEoAgAiAjYCBCACBEAgAiAANgIICyABIAAoAgg2AgggACgCCCICIAIoAgAgAEdBAnRqIAE2AgAgASAANgIAIAAgATYCCAwECyACRQRAIABBAToADCABQQA6AAwgASAAKAIEIgI2AgAgAgRAIAIgATYCCAsgACABKAIINgIIIAEoAggiAiACKAIAIAFHQQJ0aiAANgIAIAAgATYCBCABIAA2AgggACADIAEgA0YbIQMgASgCACEACwJAAkAgACgCACICRQ0AIAItAAwNACAAIQEMAQsCQCAAKAIEIgEEQCABLQAMRQ0BCyAAQQA6AAwgACgCCCIALQAMQQAgACADRxsNAiAAQQE6AAwMBQsgAgRAIAItAAxFBEAgACEBDAILIAAoAgQhAQsgAUEBOgAMIABBADoADCAAIAEoAgAiAjYCBCACBEAgAiAANgIICyABIAAoAgg2AgggACgCCCICIAIoAgAgAEdBAnRqIAE2AgAgASAANgIAIAAgATYCCCAAIQILIAEgASgCCCIALQAMOgAMIABBAToADCACQQE6AAwgACAAKAIAIgEoAgQiAjYCACACBEAgAiAANgIICyABIAAoAgg2AgggACgCCCICIAIoAgAgAEdBAnRqIAE2AgAgASAANgIEIAAgATYCCAwDCyAAKAIIIgEgASgCACAARkECdGooAgAhAAwACwALIAJBAToADAsgBCgCKCIABEAgBCAANgIsIAAQFgsgBBAWIAUgBSgCEDsBBAsgBUHkwpXDBhAcIgBFDQAgACgCICIBIAAgARsiACgCDEERSQ0AIAAoAhQgACgCEC0AEEEIcjoAEAJ/IAVB5MKVwwYQHCEDIAVB5vKxuwYQHCEAIAVB4ca94wYQHCEBQQAgA0UNABpBASECAkAgACABckUNAEEAIABFIAFFcw0BGkEAIAEoAiAiAUEARyAAKAIgQQBHRw0BGiABDQAgAygCEC0AMyEEIAUQ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AhgRAgAiADYC8CZBayEHIABFDRUgAkIGNwMAQQALIgAgAigC0AEiB0gEQANAAkAgAigCDCIHQR9rQQJPBEAgDSgCACEDDAELIAIoAhQiBkUNDSACIAIoAghBCHYiBTYCCCACKAIQIgQtAAAhAyACIAZBAWs2AhQgAiAEQQFqNgIQIAIgA0EYdCAFciIDNgIIIAdBCGshBwsgAiAHQQJqNgIMIAIoAvAmIABqIAMgB3ZBA3E6AAAgAEEBaiIAIAIoAtABIgdIDQALCyACQRU2AgALIAdBBnQgLyA5IAIQkAEiB0EBRw0TIC1CADcCACAtQgA3AhggLUIANwIQIC1CADcCCCACKALQASIKBEAgOSgCACERQQAhDgNAIA5BBnQiD0EDciEGIA9BAnIhBSAPQQFyIQQgDyARai0AACELQQAhB0EAIQADQCAAIBEgBCAHamotAAAgC3MgESAHIA9qai0AACALc3IgESAFIAdqai0AACALc3IgESAGIAdqai0AACALc3JyIQAgB0E8SSFLIAdBBGohByBLDQALIABFBEAgAiAOQQN2Qfz///8BcWpB/CZqIgAgACgCAEEBIA50cjYCAAsgDkEBaiIOIApHDQALCyACQRY2AgALIAIoAvgBIgVBPkEYIAItANwmQSBxIgAbIAIoAvQBIgdBAWp0aiIEIQMCQCAARQ0AQQEgB3QhBiAHQQJ0IgNBgOMZaigCACIAIAVBEGsiBUsEQCADQZDjGWooAgAgBSAGamohAwwBCyADQZDjGWooAgAhAyAFIAAgBmoiAEsEQCADIAVqIQMMAQsgACADaiEDCyACKALYAUECdCBAID8gAhCQASIHQQFHDRIgAiATQYACQYACIAIoAugmEFggAiAbQcAFQcAFIAIoAtQBEFhxIAIgECAEIAMgAigCgAIQWHFBAXFFBEAgAkFqNgJcQQAhBwwUCyACQhc3AwBBACEDIBMhAAwBCyATIQACQAJAIAIoAgQiAw4DAgABAwsgGyEADAELIBAhAAsCfyACKALEJkEBRgRAIAIoAowQDAELIAAoAgQhBCACQQE2AsQmIAJBADYCjBAgAiAENgKQEEEACyAALwEMSARAIAIoApAQIQcDQCAALwEIIAAvAQogByAsQQxqIAIQRSIHQQFHDRIgACgCACACKAKMECIDQQJ0aiACKAKQEDYCACAs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CyAIIAQ2AlggARAWCyAIQbABaiQAIAkMAgsQIgALIAggCTYCmAEgCCABNgKgAQwBCwR/ICMoAiAhAyAjICMoAhwgQyAjLQAnIgHAQQBIIgAbNgIsICMgAyABIAAbNgIoQbwQICNBKGoQBwVBAgs2AgAgIywAJ0EASARAICMoAhwQFgsgI0EwaiQADwsQGwALrgEBBH8jAEEQayICJAAgASgCACIDQfD///8HSQRAAkAgA0EKTQRAIAIgAzoACyACIQQMAQsgA0EPckEBaiIFEBchBCACIAVBgICAgHhyNgIIIAIgBDYCACACIAM2AgQLIAQgAUEEaiADEBQgA2pBADoAACACQQxqIAIgABEAACACKAIMEAwgAigCDCIAEAsgAiwAC0EASARAIAIoAgAQFgsgAkEQaiQAIAAPCxBDAAsVAEGtCEECQawPQZgQQQJBA0EAEAILBwAgACgCBAsFAEHvCAsFAEH6CQsFAEHLCAsXACAARQRAQQAPCyAAQby6GhCCAUEARwsbACAAIAEoAgggBRAjBEAgASACIAMgBBCAAQsLOAAgACABKAIIIAUQIwRAIAEgAiADIAQQgAEPCyAAKAIIIgAgASACIAMgBCAFIAAoAgAoAhQRCwALpwEAIAAgASgCCCAEECMEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQI0UNAAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNASABQQE2AiAPCyABIAI2AhQgASADNgIgIAEgASgCKEEBajYCKAJAIAEoAiRBAUcNACABKAIYQQJHDQAgAUEBOgA2CyABQQQ2AiwLC4gCACAAIAEoAgggBBAjBEACQCABKAIEIAJHDQAgASgCHEEBRg0AIAEgAzYCHAsPCwJAIAAgASgCACAEECMEQAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNAiABQQE2AiAPCyABIAM2AiACQCABKAIsQQRGDQAgAUEAOwE0IAAoAggiACABIAIgAkEBIAQgACgCACgCFBELACABLQA1BEAgAUEDNgIsIAEtADRFDQEMAwsgAUEENgIsCyABIAI2AhQgASABKAIoQQFqNgIoIAEoAiRBAUcNASABKAIYQQJHDQEgAUEBOgA2DwsgACgCCCIAIAEgAiADIAQg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AyAANgIIIANCADcCACADQgA3AhQgA0IANwIcIANCADcCJCADQgA3AiwgA0IANwI0IAYgAzYCACADIQEgCigCCCgCACIABEAgCiAANgIIIAYoAgAhAQsgASABIAUoAgAiBEYiADoADAJAIAANAANAIAEoAggiAi0ADA0BAkAgAiACKAIIIgAoAgAiBkYEQAJAIAAoAgQiBkUNACAGLQAMDQAMAgsCQCABIAIoAgBGBEAgAiEBDAELIAIgAigCBCIBKAIAIgY2AgQgASAGBH8gBiACNgIIIAIoAggFIAALNgIIIAIoAggiACAAKAIAIAJHQQJ0aiABNgIAIAEgAjYCACACIAE2AgggASgCCCIAKAIAIQILIAFBAToADCAAQQA6AAwgACACKAIEIgE2AgAgAQRAIAEgADYCCAsgAiAAKAIINgIIIAAoAggiASABKAIAIABHQQJ0aiACNgIAIAIgADYCBCAAIAI2AggMAwsCQCAGRQ0AIAYtAAwNAAwBCwJAIAEgAigCAEcEQCACIQEMAQsgAiABKAIEIgY2AgAgASAGBH8gBiACNgIIIAIoAggFIAALNgIIIAIoAggiACAAKAIAIAJHQQJ0aiABNgIAIAEgAjYCBCACIAE2AgggASgCCCEACyABQQE6AAwgAEEAOgAMIAAgACgCBCIBKAIAIgI2AgQgAgRAIAIgADYCCAsgASAAKAIINgIIIAAoAggiAiACKAIAIABHQQJ0aiABNgIAIAEgADYCACAAIAE2AggMAgsgAkEBOgAMIAAgACAERjoADCAGQQE6AAwgBCAAIgFHDQALCyAKIAooAhBBAWo2AhALAkAgAygCNCIABEAgACgCCCEADAELIAwiACADKAIgIgEgAUEDakF8cSABQXxLG2ohDAsgAyAANgIcIA5BBGoiDiAIRw0ACyARKAIEIQ4LIA4EQCARIA42AgggDhAWCyAKQRRqIgogCUcNAAsgECgCFCIAIBAoAhgiAkYEQEEBIQEMAQsDQCAAEHciAUUNASAAQRRqIgAgAkcNAAsLIBFBEGokACABRQ0AIAcoAnghBiAHKAJ0IQACQCAdLQAQBEAgACAGRg0BAkADQAJ/QQAhGCMAQbABayIEJABBASECAkACQCAAIhBB5vKxuwYQHCIAIBBB4ca94wYQHCIBckUNAEEAIQIgAEUgAUVzDQAgASgC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QQF0IgMgACAAIANJGyACQf////8DTxsiAgR/IAIQFwVBAAsiAGoiAyAIOgAAIAAgAmohCCADQQFqIQICQCABIAlGBEAgAyEADAELIAlBf3MgAWohMEEAIQUgD0EDcSIPBEADQCADQQFrIgMgAUEBayIBLQAAOgAAIAVBAWoiBSAPRw0ACwsgMEEDTwRAA0AgA0EBayABQQFrLQAAOgAAIANBAmsgAUECay0AADoAACADQQNrIAFBA2stAAA6AAAgA0EEayIDIAFBBGsiAS0AADoAACABIAlHDQALCyAEKAKIASEBCyAEIAg2ApABIAQgAjYCjAEgBCAANgKIASABRQ0AIAEQFiAEKAKMASECCyAEKAKQASIBIAJLBEAgAiALOgAAIAQgAkEBajYCjAEMBAsgAiAEKAKIASIFayIJQQFqIgBBAEgNDCAJQf////8HIAEgBWsiAUEBdCIDIAAgACADSRsgAUH/////A08bIgMEfyADEBcFQQALIgBqIgEgCzoAACAAIANqIQggAUEBaiELAkAgAiAFRgRAIAEhAAwBCyAFQX9zIAJqITFBACEDIAlBA3EiCQRAA0AgAUEBayIBIAJBAWsiAi0AADoAACADQQFqIgMgCUcNAAsLIDFBA08EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6AAAgAUEDayACQQNrLQAAOgAAIAFBBGsiASACQQRrIgItAAA6AAAgAiAFRw0ACwsgBCgCiAEhAgsgBCAINgKQASAEIAs2AowBIAQgADYCiAEgAkUNAyACEBYMAwsgAiAEKAJYIgVrIgtBAWoiAUEASA0TIAtB/////wcgACAFayIAQQF0Ig8gASABIA9JGyAAQf////8DTxsiDwR/IA8QFwVBAAsiAGoiASADOgAAIAAgD2ohDyABQQFqIRYCQCACIAVGBEAgASEADAELIAVBf3MgAmohMkEAIQMgC0EDcSILBEADQCABQQFrIgEgAkEBayICLQAAOgAAIANBAWoiAyALRw0ACwsgMkEDTwRAA0AgAUEBayACQQFrLQAAOgAAIAFBAmsgAkECay0AADoAACABQQNrIAJBA2stAAA6AAAgAUEEayIBIAJBBGsiAi0AADoAACACIAVHDQALCyAEKAJYIQILIAQgDzYCYCAEIBY2AlwgBCAANgJYIAJFDQAgAhAWCyAIQQR2IQACQCAEKAKMASIBIAQoApABIgNJBEAgASAAOgAAIAQgAUEBaiICNgKMAQwBCyABIAQoAogBIgtrIg9BAWoiAkEASA0LIA9B/////wcgAyALayIDQQF0IgUgAiACIAVJGyADQf////8DTxsiAgR/IAIQFwVBAAsiBWoiAyAAOgAAIAIgBWohFiADQQFqIQICQCABIAtGBEAgAyEFDAELIAtBf3MgAWohM0EAIQAgD0EDcSIPBEADQCADQQFrIgMgAUEBayIBLQAAOgAAIABBAWoiACAPRw0ACwsgM0EDTwRAA0AgA0EBayABQQFrLQAAOgAAIANBAmsgAUECay0AADoAACADQQNrIAFBA2stAAA6AAAgA0EEayIDIAFBBGsiAS0AADoAACABIAtHDQALCyAEKAKIASEBCyAEIBY2ApABIAQgAjYCjAEgBCAFNgKIASABRQ0AIAEQFiAEKAKMASECCyAIQQR0IAlBCHZyIQECQCAEKAKQASIDIAJLBEAgAiABOgAAIAQgAkEBaiIBNgKMAQwBCyACIAQoAogBIghrIgtBAWoiAEEASA0LIAtB/////wcgAyAIayIDQQF0IgUgACAAIAVJGyADQf////8DTxsiBQR/IAUQFwVBAAsiAGoiAyABOgAAIAAgBWohDyADQQFqIQECQCACIAhGBEAgAyEADAELIAhBf3MgAmohNEEAIQUgC0EDcSILBEADQCADQQFrIgMgAkEBayICLQAAOgAAIAVBAWoiBSALRw0ACwsgNEEDTwRAA0AgA0EBayACQQFrLQAAOgAAIANBAmsgAkECay0AADoAACADQQNrIAJBA2stAAA6AAAgA0EEayIDIAJBBGsiAi0AADoAACACIAhHDQALCyAEKAKIASECCyAEIA82ApABIAQgATYCjAEgBCAANgKIASACRQ0AIAIQFiAEKAKMASEBCyAEKAKQASICIAFLBEAgASAJOgAAIAQgAUEBajYCjAEMAgsgASAEKAKIASIFayIIQQFqIgBBAEgNCiAIQf////8HIAIgBWsiAkEBdCIDIAAgACADSRsgAkH/////A08bIgMEfyADEBcFQQALIgBqIgIgCToAACAAIANqIQkgAkEBaiELAkAgASAFRgRAIAIhAAwBCyAFQX9zIAFqITVBACEDIAhBA3EiCARAA0AgAkEBayICIAFBAWsiAS0AADoAACADQQFqIgMgCEcNAAsLIDVBA08EQANAIAJBAWsgAUEBay0AADoAACACQQJrIAFBAmstAAA6AAAgAkEDayABQQNrLQAAOgAAIAJBBGsiAiABQQRrIgEtAAA6AAAgASAFRw0ACwsgBCgCiAEhAQsgBCAJNgKQASAEIAs2AowBIAQgADYCiAEgAUUNASABEBYMAQsgAUH8AHIhAwJAIAAgAksEQCACIAM6AAAgBCACQQFqNgJcDAELIAIgBCgCWCIFayILQQFqIgFBAEgNEiALQf////8HIAAgBWsiAEEBdCIPIAEgASAPSRsgAEH/////A08bIg8EfyAPEBcFQQALIgBqIgEgAzoAACAAIA9qIQ8gAUEBaiEWAkAgAiAFRgRAIAEhAAwBCyAFQX9zIAJqITZBACEDIAtBA3EiCwRAA0AgAUEBayIBIAJBAWsiAi0AADoAACADQQFqIgMgC0cNAAsLIDZBA08EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6AAAgAUEDayACQQNrLQAAOgAAIAFBBGsiASACQQRrIgItAAA6AAAgAiAFRw0ACwsgBCgCWCECCyAEIA82AmAgBCAWNgJcIAQgADYCWCACRQ0AIAIQFgsgCEEIdiEAAkAgBCgCjAEiASAEKAKQASIDSQRAIAEgADoAACAEIAFBAWoiAjYCjAEMAQsgASAEKAKIASILayIPQQFqIgJBAEgNCiAPQf////8HIAMgC2siA0EBdCIFIAIgAiAFSRsgA0H/////A08bIgIEfyACEBcFQQALIgVqIgMgADoAACACIAVqIRYgA0EBaiECAkAgASALRgRAIAMhBQwBCyALQX9zIAFqITdBACEAIA9BA3EiDwRAA0AgA0EBayIDIAFBAWsiAS0AADoAACAAQQFqIgAgD0cNAAsLIDdBA08EQANAIANBAWsgAUEBay0AADoAACADQQJrIAFBAmstAAA6AAAgA0EDayABQQNrLQAAOgAAIANBBGsiAyABQQRrIgEtAAA6AAAgASALRw0ACwsgBCgCiAEhAQsgBCAWNgKQASAEIAI2AowBIAQgBTYCiAEgAUUNACABEBYgBCgCjAEhAgsCQCAEKAKQASIBIAJLBEAgAiAIOgAAIAQgAkEBaiIBNgKMAQwBCyACIAQoAogBIgtrIg9BAWoiAEEASA0KIA9B/////wcgASALayIBQQF0IgMgACAAIANJGyABQf////8DTxsiAQR/IAEQFwVBAAsiAGoiAyAIOgAAIAAgAWohCCADQQFqIQECQCACIAtGBEAgAyEADAELIAtBf3MgAmohOEEAIQUgD0EDcSIPBEADQCADQQFrIgMgAkEBayICLQAAOgAAIAVBAWoiBSAPRw0ACwsgOEEDTwRAA0AgA0EBayACQQFrLQAAOgAAIANBAmsgAkECay0AADoAACADQQNrIAJBA2stAAA6AAAgA0EEayIDIAJBBGsiAi0AADoAACACIAtHDQALCyAEKAKIASECCyAEIAg2ApABIAQgATYCjAEgBCAANgKIASACRQ0AIAIQFiAEKAKMASEBCyAJQQh2IQICQCAEKAKQASIDIAFLBEAgASACOgAAIAQgAUEBaiICNgKMAQwBCyABIAQoAogBIghrIgtBAWoiAEEASA0KIAtB/////wcgAyAIayIDQQF0IgUgACAAIAVJGyADQf////8DTxsiBQR/IAUQFwVBAAsiAGoiAyACOgAAIAAgBWohDyADQQFqIQICQCABIAhGBEAgAyEADAELIAhBf3MgAWohOUEAIQUgC0EDcSILBEADQCADQQFrIgMgAUEBayIBLQAAOgAAIAVBAWoiBSALRw0ACwsgOUEDTwRAA0AgA0EBayABQQFrLQAAOgAAIANBAmsgAUECay0AADoAACADQQNrIAFBA2stAAA6AAAgA0EEayIDIAFBBGsiAS0AADoAACABIAhHDQALCyAEKAKIASEBCyAEIA82ApABIAQgAjYCjAEgBCAANgKIASABRQ0AIAEQFiAEKAKMASECCyAEKAKQASIBIAJLBEAgAiAJOgAAIAQgAkEBajYCjAEMAQsgAiAEKAKIASIFayIIQQFqIgBBAEgNCSAIQf////8HIAEgBWsiAUEBdCIDIAAgACADSRsgAUH/////A08bIgMEfyADEBcFQQALIgBqIgEgCToAACAAIANqIQkgAUEBaiELAkAgAiAFRgRAIAEhAAwBCyAFQX9zIAJqITpBACEDIAhBA3EiCARAA0AgAUEBayIBIAJBAWsiAi0AADoAACADQQFqIgMgCEcNAAsLIDpBA08EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6AAAgAUEDayACQQNrLQAAOgAAIAFBBGsiASACQQRrIgItAAA6AAAgAiAFRw0ACwsgBCgCiAEhAgsgBCAJNgKQASAEIAs2AowBIAQgADYCiAEgAkUNACACEBYLIB9BAWoiHyAnRw0ACwsgGkEBaiIaICJHDQALICEgBC8BHBBEIAQvARwiAEUNACAEKAIgIQUCQCAEKAKYASAEKAKUASIDayIBIAAgAWoiAkkEQCAgIAAQJSAEKAKUASEDDAELIAEgAk0NACAEIAIgA2o2ApgBCyABIANqIAUgABAUGgsgBCgCKCIABEAgBCgCLCIBIAAiAkcEQANAIAFBDGsiAigCACIDBEAgAUEIayADNgIAIAMQFgsgAiIBIABHDQALIAQoAighAgsgBCAANgIsIAIQFgsgGEEBaiIYIBtHDQALC0EAIQIgDkEoaiIAQQAQHiAAIAQoAqABIAQoAqQBRxAeIAAgBCgCrAEQHiAAQQAQHiAAIAQoAkQgBCgCQGsQLiAAIAQoAlAgBCgCTGsQLiAAIAQoAlwgBCgCWGsQLiAAIAQoAowBIAQoAogBaxAuIAAgBCgCaCAEKAJkaxAuIAAgBCgCdCAEKAKAAWogBCgCcCAEKAJ8amsQLiAAIAQoApgBIAQoApQBaxAuIAAgBEFAaxAmIAAgBEHMAGoQJiAAIARB2ABqECYgACAEQYgBahAmIAAgBEHkAGoQJiAAIARB8ABqECYgACAEQfwAahAmIAAgBEGUAWoQJiAEKAKgASAEKAKkAUcEQCAAIARBoAFqECYLIBBB5MKVwwYQHCIARQ0AIAAoAgxBNEkNACAOKAIoIAAoAhAtADM6AAcgDkHm87O/fjYCFCAOIA4oAigiADYCJCAOIA4oAiwgAGs2AiAgDEIANwIgIAxB4ce/5342AhRBASECCyAEKAKgASIABEAgBCAANgKkASAAEBYLIAQoApQBIgAEQCAEIAA2ApgBIAAQFgsgBCgCiAEiAARAIAQgADYCjAEgABAWCyAEKAJ8IgAEQCAEIAA2AoABIAAQFgsgBCgCcCIABEAgBCAANgJ0IAAQFgsgBCgCZCIABEAgBCAANgJoIAAQFgsgBCgCWCIABEAgBCAANgJcIAAQFgsgBCgCTCIABEAgBCAANgJQIAAQFgsgBCgCQCIARQ0AIAQgADYCRCAAEBYLIARBsAFqJAAgAgwBCwwHCwRAIAYgEEEUaiIARw0BDAILCwwDCyAHKAJ4IQYgBygCdCEACyAAIAZGDQADQCAAQebysbsGEBwhASAAQeHGveMGEBwhAiABBEAgASABLQAkQcABcjoAJAsgAgRAIAIgAi0AJEHAAXI6ACQLIABBFGoiACAGRw0ACyAHKAJ0Ig0gBygCeCIGRg0AA0BBACEDIA0oAggiAiANQQxqIgVHBEADQAJAIAIoAjQNACACKAIUIgBBgIGChHhxRQRAIA0gAEGAgYKEeHMQHA0BCyACKAIgIANqIQMLAkAgAigCBCIBBEADQCABIgAoAgAiAQ0ADAILAAsDQCACKAIIIgAoAgAgAkchOyAAIQIgOw0ACwsgBSAAIgJHDQALCyADIBJqIRIgBiANQRRqIg1HDQALC0EAIQEgB0EANgJcIAdCADcCVAJ/IBK4RDMzMzMzM/M/okQAAAAAAADEQKAiR0QAAAAAAADwQWMgR0QAAAAAAAAAAGZxBEAgR6sMAQtBAAsiAgRAIAJBAEgNAyAHIAIQFyIBNgJUIAcgASACaiIANgJcIAFBACACEBIaIAcgADYCWAtBACEAIAdBADYCUCAHQgA3AkggEgRAIBJBAEgNAyAHIBIQFyIANgJIIAcgACASaiIDNgJQIABBACASEBIaIAcgAzYCTAsgBygCdCIDIAcoAngiBUcEQEEAIQ0DQCAHQTxqIAMQOyAHKAI8IgYgBygCQCIMRwRAA0ACQAJAIAMoAgwiAEUNACAGKAIAIQEDQCAAKAIQIgogAUsEQCAAKAIAIgANAQwCCyABIApNDQIgACgCBCIADQALC0HdCRBSAAsCQCAAQRRqIgooAiANACABQYCBgoR4cQ0AIAMgAUGAgYKEeHMQHCEAIAcoAkggDWogACAKIAAbIgAoAhAgACgCDCIAEBQaIAAgDWohDQsgBkEEaiIGIAxHDQALIAcoAjwhBgsgBgRAIAcgBjYCQCAGEBYLIAUgA0EUaiIDRw0ACyAHKAJUIQEgBygCSCEACyAdKAIMIQMgByACNgI8AkAgA0ECIBIgACAHQTxqIAEQaEUEQEEAIQ0MAQsgBygCPCEQIB0oAgQhAiAdLQALIQFBACEAIAdBADYCRCAHQgA3AjwCfyACIAEgAcAiA0EASBsiArhEMzMzMzMz8z+iRAAAAAAAAMRAoCJHRAAAAAAAAPBBYyBHRAAAAAAAAAAAZnEEQCBHqwwBC0EACyIBBEAgAUEASA0EIAcgARAXIgA2AjwgByAAIAFqIgY2AkQgAEEAIAEQEhogByAGNgJACwJAIAIEQCAdKAIMITwgHSgCACEFIAcgATYCMEEAIQ0gPEEBIAIgBSAdIANBAEgbIAdBMGogABBoRQ0BIAcoAjAhHgsgB0EANgI4IAdCADcCMCAHIAdBKGoiBTYCJCAHQgA3AihBACEGIAUhAAJAAkACQCAHKAJ0IgwgBygCeCIRRwRAAkADQCAHQRhqIAwQOwJAIAcoAhgiEiAHKAIcIgRGBEBBASEGDAELAkADQAJAAkAgDCgCDCIARQ0AIBIoAgAhAQNAIAAoAhAiAiABSwRAIAAoAgAiAA0BDAILIAEgAk0NAiAAKAIEIgANAAsLQd0JEFIACwJAIAAoAjQNACAAKAIcIQogACgCFCECIAUhDSAHKAIoIgMhAQJAAkAgA0UEQCAXIAcoAjBrQQV2IQ0gBSIDIQEMAQsDQAJAIAIgASgCECIGSwRAIAFBBGohBgwBCyACIAZJBEAgASIGIQ0MAQsgAUEEaiABIAogASgCFEsiDhshBiANIAEgDhshDQsgBigCACIBDQALAkAgBSANRg0AIAIgDSgCECIBSQ0AQQAhBiABIAJJDQUgCiANKAIUTw0FCyAXIAcoAjBrQQV2IQ0DQAJAAkAgAyIBKAIQIgMgAk0EQCACIANLDQIgCiABKAIUIgNPDQELIAEoAgAiAw0CIAEhAwwDCyADIApJDQAgASEGDAMLIAEoAgQiAw0ACyABQQRqIQMLQRwQFyIGIAE2AgggBkIANwIAIAZBADsBGCAGIAKtIAqtQiCGhDcCECADIAY2AgAgBiEBIAcoAiQoAgAiAgRAIAcgAjYCJCADKAIAIQELIAcoAiggARAfIAcgBygCLEEBajYCLCAAKAIUIQILIAYgDTsBGCAALQA4IQMgACgCICIOIQ0gDCACQYCBgoR4cxAcIgAEQCAAKAIMIQ0gAC0AJEGAAnIhAwsgBygCNCIAIAcoAjhHBEAgACANNgIQIAAgDjYCDCAAIAM2AgQgACACNgIAIAcgAEEgaiIXNgI0DAELIAAgBygCMCIGayIBQQV1IhdBAWoiCkGAgIDAAE8NDkH///8/IAFBBHUiCSAKIAkgCksbIAFB4P///wdPGyIKBH8gCkGAgIDAAE8NCCAKQQV0EBcFQQALIgkgF0EFdGoiASANNgIQIAEgDjYCDCABIAM2AgQgASACNgIAIAFBIGohFyAAIAZHBEADQCABQSBrIgEgAEEgayIAKQIANwIAIAEgACkCGDcCGCABIAApAhA3AhAgASAAKQIINwIIIAAgBkcNAAsgBiEACyAHIAkgCkEFdGo2AjggByAXNgI0IAcgATYCMCAARQ0AIAAQFgsgEkEEaiISIARHDQALQQEhBgsgBygCGCESCyASBEAgByASNgIcIBIQFgsgBgRAIAxBFGoiDCARRg0CDAELC0EAIQ0MBAsgBygCMCEGIAcoAiQhAAsgB0IANwIQIAcgB0EQaiIKNgIMIwBBEGsiDiQAIAUgACICRwRAIAdBDGoiEUEEaiEDA0ACfyAOQQhqIQACQAJAAkACQCARQQRqIg0gA0YNACACKAIQIgQgAygCECIBSQ0AIAEgBEkNAiACKAIUIAMoAhRPDQELIAMoAgAhDAJAAkAgAyIBIBEoAgBGDQACQCAMRQRAIAEhAANAIAAoAggiASgCACAARiE9IAEhACA9DQALDAELIAwhAANAIAAiASgCBCIADQALCyABKAIQIgAgAigCECIESQ0AIAAgBEsNASABKAIUIAIoAhRPDQELIAxFBEAgDiADNgIMIAMMBQsgDiABNgIMIAFBBGoMBAsgDSgCACIARQRAIA4gDTYCDCANDAQLIAIoAhQhDANAAkACQAJAIAAiASgCECIAIARNBEAgACAESQ0CIAwgASgCFCIATw0BCyABIg0oAgAiAA0DDAILIAAgDE8NAQsgAUEEaiENIAEoAgQiAA0BCwsgDiABNgIMIA0MAwsgAygCFCACKAIUTw0BCwJAIAMoAgQiDEUEQCADIQADQCAAKAIIIgEoAgAgAEchPiABIQAgPg0ACwwBCyAMIQADQCAAIgEoAgAiAA0ACwsCQAJAIAEgDUYNACAEIAEoAhAiAEkNACAAIARJDQEgAigCFCABKAIUTw0BCyAMRQRAIA4gAzYCDCADQQRqDAMLIA4gATYCDCABDAILIA0oAgAiAEUEQCAOIA02AgwgDQwCCyACKAIUIQwDQAJAAkACQCAAIgEoAhAiACAETQRAIAAgBEkNAiAMIAEoAhQiAE8NAQsgASINKAIAIgANAwwCCyAAIAxPDQELIAFBBGohDSABKAIEIgANAQsLIA4gATYCDCANDAELIA4gAzYCDCAAIAM2AgAgAAsiASgCAEUEQEEcEBciACACKAIYNgIYIAAgAikCEDcCECAOKAIMIQ0gAEIANwIAIAAgDTYCCCABIAA2AgAgESgCACgCACINBEAgESANNgIAIAEoAgAhAAsgESgCBCAAEB8gESARKAIIQQFqNgIICwJAIAIoAgQiAQRAA0AgASIAKAIAIgENAAwCCwALA0AgAigCCCIAKAIAIAJHIT8gACECID8NAAsLIAAiAiAFRw0ACwsgDkEQaiQAQTAhEiAGIBdGDQEDQCAGKAIAIQFBACEAA0ACQCABIABBAnRB0BBqKAIARgRAIAAhAgwBCyAAQQFqIgJBAnRB0BBqKAIAIAFGDQAgAEECaiICQQJ0QdAQaigCACABRg0AQT8hAiAAQQNqIgBBP0cNAQsLIAYoAgwQekEFQQEgAkE/cUE/RhtqIQAgBi0ABUEBcQR/IAYoAhAQeiAAagUgAAsgEmohEiAGQSBqIgYgF0cNAAsMAQsQIgALAkAgBygCYEHmxtGjB0cNACASQQFBAkEDIAcoAngiDCAHKAJ0IhdrQRRtQf//A3EiAEH6BUkbIABB/QFJG2ogDCAXa0EUbUECdGpBBGohEiAMIBdGDQADQCASQQFBAkEDIBcvARAiAEH6BUkbIABB/QFJG2ohEiAXKAIIIgIgF0EMaiIRRwRAA0AgAigCFCIGQYCBgoR4cUUEQCACKAIcIQ4gCiINIQAgEkEBQQJBAwJ/AkACQCAHKAIQIgFFDQADQAJAAkAgASIAKAIQIgEgBk0EQCABIAZJDQIgDiAAKAIUIgFPDQELIAAhDSAAKAIAIgENAgwDCyABIA5PDQMLIAAoAgQiAQ0ACyAAQQRqIQ0LQRwQFyIDIAA2AgggA0IANwIAIANBADsBGCADIAatIA6tQiCGhDcCECANIAM2AgAgBygCDCgCACIABEAgByAANgIMIA0oAgAhAwsgAyADIAcoAhAiDUYiADoADAJAIAANAANAIAMoAggiAS0ADA0BAkAgASABKAIIIgAoAgAiBkYEQAJAIAAoAgQiBkUNACAGLQAMDQAMAgsCQCADIAEoAgBGBEAgASEGDAELIAEgASgCBCIGKAIAIgM2AgQgBiADBH8gAyABNgIIIAEoAggFIAALNgIIIAEoAggiACAAKAIAIAFHQQJ0aiAGNgIAIAYgATYCACABIAY2AgggBigCCCIAKAIAIQELIAZBAToADCAAQQA6AAwgACABKAIEIgM2AgAgAwRAIAMgADYCCAsgASAAKAIINgIIIAAoAggiAyADKAIAIABHQQJ0aiABNgIAIAEgADYCBCAAIAE2AggMAwsCQCAGRQ0AIAYtAAwNAAwBCwJAIAMgASgCAEcEQCABIQMMAQsgASADKAIEIgY2AgAgAyAGBH8gBiABNgIIIAEoAggFIAALNgIIIAEoAggiACAAKAIAIAFHQQJ0aiADNgIAIAMgATYCBCABIAM2AgggAygCCCEACyADQQE6AAwgAEEAOgAMIAAgACgCBCIBKAIAIgM2AgQgAwRAIAMgADYCCAsgASAAKAIINgIIIAAoAggiAyADKAIAIABHQQJ0aiABNgIAIAEgADYCACAAIAE2AggMAgsgAUEBOgAMIAAgACANRjoADCAGQQE6AAwgDSAAIgNHDQALCyAHIAcoAhRBAWo2AhRBAAwBCyAALwEYC0H//wNxIgBB+gVJGyAAQf0BSRtqIRILAkAgAigCBCIBBEADQCABIgAoAgAiAQ0ADAILAAsDQCACKAIIIgAoAgAgAkchQCAAIQIgQA0ACwsgESAAIgJHDQALCyAXQRRqIhcgDEcNAAsLIAdBDGogBygCEBBBQQAhDSAQIBJqIgAgAEEDakF8cSAAQXxLGyIKIB5qIgAgEygCJEsNACATIAA2AiQgFEH3npmSAzYAAAJ/IAcoAmBB5sbRowdGIgIEQEHmACEBQeMAIQZB9AAhDUH0AAwBCyAHKAJ0KAIAIgFBCHYhBiABQRB2IQ0gAUEYdgshAyAUIAA6AAsgFCABOgAHIBQgBjoABiAUIA06AAUgFCADOgAEIBQgAEEIdjoACiAUIABBEHY6AAkgFCAAQRh2OgAIIAcoAjAhAyAHKAI0IQYgFEEAOgAOIBQgBiADa0EFdSIAOgANIBQgAEEIdjoADCAHQRA2AhggFEEAOgAPAkAgAkUEQCAHKAJ0IgAvAQRBBHRBDHIhEiAAKAIIIgIgAEEMaiINRg0BA0ACQCACKAIUQYCBgoR4cQ0AIAIoAjQNACACKAIgIgAgAEEDakF8cSAAQXxLGyASaiESCwJAIAIoAgQiAQRAA0AgASIAKAIAIgENAAwCCwALA0AgAigCCCIAKAIAIAJHIUEgACECIEENAAsLIA0gACICRw0ACwwBCyAHKAJkIAcoAnggBygCdGtBFG0QQiESIAcoAnQiDCAHKAJ4Ig5GDQADQCAMLwEEQQR0QQxyIQ0gDCgCCCICIAxBDGoiEUcEQANAAkAgAigCFEGAgYKEeHENACACKAI0DQAgAigCICIAIABBA2pBfHEgAEF8SxsgDWohDQsCQCACKAIEIgEEQANAIAEiACgCACIBDQAMAgsACwNAIAIoAggiACgCACACRyFCIAAhAiBCDQALCyARIAAiAkcNAAsLIA0gEmohEiAMQRRqIgwgDkcNAAsLIBQgBygCGCIBaiIAIBJBGHY6AAAgAEGAAjYACCAAIBA6AAcgACAQQQh2OgAGIAAgEEEQdjoABSAAIBBBGHY6AAQgACASOgADIAAgEkEIdjoAAiAAIBJBEHY6AAEgAUEMaiENAkAgHgRAIA0gFGogCkEYdjoAACAAIAo6AA8gACAKQQh2OgAOIAAgCkEQdjoADSAHIAFBEWoiAjYCGCAAIB46ABMgACAeQQh2OgASIAAgHkEYdjoAECACIBRqIB5BEHY6AAAgACAdKAIEIB0tAAsiAiACwEEASBsiAkEIdjoAFiAAIAJBEHY6ABUgACACQRh2OgAUDAELQQAhAiANIBRqQQA6AAAgAEEAOwAVIABCADcADQsgAEEAOgAeIABBADsAHCAAQQA2ABggACACOgAXIAcgAUEgajYCGCAAQQA6AB8gAyAGRwRAA0AgAygCBEHAAXEhDSADKAIAIQJBACEAA0ACQCACIABBAnRB0BBqKAIARgRAIAAhAQwBCyAAQQFqIgFBAnRB0BBqKAIAIAJGDQAgAEECaiIBQQJ0QdAQaigCACACRg0AQT8hASAAQQNqIgBBP0cNAQsLIAcgBygCGCICQQFqIgw2AhggAiAUaiIAIAEgDXI6AAAgAUE/cUE/RgRAIAwgFGogAygCACIBQRh2OgAAIAAgAUEIdjoAAyAAIAFBEHY6AAIgByACQQVqNgIYIAAgAToABAsgAygCDCAHQRhqIgAgFBB5IAMtAAVBAXEEQCADKAIQIAAgFBB5CyADQSBqIgMgBkcNAAsLAkAgBygCYEHmxtGjB0cNACAUIAcoAhgiAmoiACAHKAJkIgFBGHY6AAAgACABQQh2OgACIAAgAUEQdjoAASAHIAJBBGo2AhggACABOgADIAcoAnggBygCdGtBFG0gB0EYaiAUEFMgBygCdCIXIAcoAngiEUYNAANAQQAhBiAXKAIIIgIgF0EMaiIORwRAA0AgAigCFEGAgYKEeHFFIUQCQCACKAIEIgEEQANAIAEiACgCACIBDQAMAgsACwNAIAIoAggiACgCACACRyFDIAAhAiBDDQALCyBEIAZqIQYgDiAAIgJHDQALCyAGQf//A3EgB0EYaiAUEFMgFCAHKAIYIgJqIgAgFygCACIBQRh2OgAAIAAgAUEIdjoAAiAAIAFBEHY6AAEgByACQQRqNgIYIAAgAToAAyAOIBcoAggiAkcEQANAIAJBFGoiACgCAEGAgYKEeHFFBEAgAigCNCAAIAAoAiAbKAIIIQpBACENIAcoAigiA0UNBSAAKAIAIQEgBSEMIAMhAANAAkAgASAAKAIQIgZLBEAgAEEEaiEGDAELIAEgBkkEQCAAIgYhDAwBCyAAQQRqIAAgCiAAKAIUSyIEGyEGIAwgACAEGyEMCyAGKAIAIgANAAsgBSAMRg0FIAEgDCgCECIASQ0FIAAgAU8EQCAKIAwoAhRJDQYLAkACfwNAAkACQCADIgAoAhAiAyABTQRAIAEgA0sNAiAKIAAoAhQiA08NAQsgACgCACIDDQIgAAwDCyADIApJDQAgACEGDAMLIAAoAgQiAw0ACyAAQQRqCyEDQRwQFyIGIAA2AgggBkIANwIAIAZBADsBGCAGIAGtIAqtQiCGhDcCECADIAY2AgAgBiEAIAcoAiQoAgAiAQRAIAcgATYCJCADKAIAIQALIAcoAiggABAfIAcgBygCLEEBajYCLAsgBi8BGCAHQRhqIBQQUwsCQCACKAIEIgEEQANAIAEiACgCACIBDQAMAgsACwNAIAIoAggiACgCACACRyFFIAAhAiBFDQALCyAOIAAiAkcNAAsLIBdBFGoiFyARRw0ACwsgFCAHKAIYIgBqIAcoAlQgEBAUGiAHIAAgEGoiACAAQQNqQXxxIABBfEsbIgA2AhggACAUaiAHKAI8IB4QFBogEygCJCAAIB5qRiENCyAHQSRqIAcoAigQQSAHKAIwIgAEQCAAEBYLIAcoAjwhAAsgAARAIAcgADYCQCAAEBYLIAcoAkghAAsgAARAIAcgADYCTCAAEBYLIAcoAlQiAEUNACAAEBYLIAcoAnQiAQRAIAcoAngiACABIgZHBEADQCAAQQxrIABBFGsiACgCDBAxIAAgAUcNAAsgBygCdCEGCyAHIAE2AnggBhAWCyAHQegAaiAHKAJsEEAgB0GAAWokACBGIA0EfwJAIBMoAiQiAAJ/IBwtAAtBB3YEQCAcKAIEDAELIBwtAAtB/wBxCyIBSwRAIBwgACABaxCDAQwBCyAcAn8gHC0AC0EHdgRAIBwoAgAMAQsgHAsgABBXCyATKAIcIQAgEyATKAIYIBwgEy0AIyIBwEEASCICGzYCLCATIAAgASACGzYCKEG8ECATQShqEAcFQQILNgIAIBMsAA9BAEgEQCATKAIEEBYLIBMsACNBAEgEQCATKAIYEBYLIBNBMGokAA8LEEMACxAbAAsL3dIXqB4AQYAIC8wKdW5zaWduZWQgc2hvcnQAdW5zaWduZWQgaW50AGZsb2F0AHVpbnQ2NF90AGRlY29tcHJlc3MAdmVjdG9yAHVuc2lnbmVkIGNoYXIAc3RkOjpleGNlcHRpb24AYm9vbABlbXNjcmlwdGVuOjp2YWwAYmFkX2FycmF5X25ld19sZW5ndGgAdW5zaWduZWQgbG9uZwBzdGQ6OndzdHJpbmcAYmFzaWNfc3RyaW5nAHN0ZDo6c3RyaW5nAHN0ZDo6dTE2c3RyaW5nAHN0ZDo6dTMyc3RyaW5nAGRvdWJsZQBtYXA6OmF0OiAga2V5IG5vdCBmb3VuZAB2b2lkAHN0ZDo6YmFkX2FsbG9jAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AMgHAAAQCAAATjEwZW1zY3JpcHRlbjN2YWxFAABUngYAtAcAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAABUngYA0AcAAGlpaQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAFSeBgAcCAAAYWNvbAAAAAAAAAAAcGFtY2RhZWhhZWhoeHRtaHB4YW1lbWFuMi9TT3Rzb3AgdHZjbWdwZmZ5bGdhY29scGVycCBGRkNHUk9WVERCRUNMQkVwc2FneG1kaG5yZWtIU1RMVExDUFhNRFZhZWh2eHRtdkVTQUJGRURHU09QR0JVU0dDU0JFRlRTSkhUQU1UREJDQ0xCQ1JMT0NMQVBDIEdWU3hpYnN0bmNhcmF2YXRhZGJjb2xibmxzYnJhdmNjc2RmdGFlZnh0bWZyYXZmcmF2Z3l0c2h0c3VqcmFjbHRyb214cm9tZGJwb3BvcnBrYXJ0ZnBhWmZsaVN0YWxHY29sR3RhZUZsbGlTAEHaEguDCIA/DeDKPwAAAEB4mhRAB3AlQLSrM0AAAEBADeBKQHiaVEBUZ11AB3BlQAHUbEC0q3NAfwp6QAAAgEB/zIJAB3CFQAbvh0A8TYpA3Y2MQKqzjkAFwZBAA7iSQHialEABapZACiiYQNrVmUCVdJtAPwWdQMeInkAAAKBArWuhQH/MokAWI6RAB3ClQNizpkAG76dABCKpQDxNqkARcatA3Y2sQPajrUCqs65AQ72vQAXBsEAxv7FAA7iyQLSrs0B4mrRAgoS1QAFqtkAgS7dACii4QOYAuUDa1blACae6QJV0u0CdPrxAPwW9QJrIvUDHiL5A4UW/QAAAwEA9t8BArWvBQGcdwkB/zMJACHnDQBYjxEC6ysRAB3DFQAsTxkDYs8ZAfFLHQAbvx0CEichABCLJQJK4yUA8TcpADeDKQBFxy0BTAMxA3Y3MQLsZzUD2o81AmCzOQKqzzkA1Oc9AQ73PQNs/0EAFwdBAykDRQDG/0UBCPNJAA7jSQHwy00C0q9NAsCPUQHia1EASENVAgoTVQND31UABatZAGdvWQCBL10AZutdACijYQPeU2EDmANlA22vZQNrV2UDoPtpACafaQEEO20CVdNtAB9rbQJ0+3EBZotxAPwXdQFRn3UCayN1AFCneQMeI3kC0595A4UXfQE6j30AAAOBA+VvgQD234EDNEeFArWvhQODE4UBnHeJARnXiQH/M4kAUI+NACHnjQF7O40AWI+RANHfkQLrK5ECqHeVAB3DlQNHB5UALE+ZAt2PmQNiz5kBuA+dAfFLnQAOh50AG7+dAhTzoQISJ6EAD1uhABCLpQIht6UCSuOlAIwPqQDxN6kDflupADeDqQMgo60ARcetA6bjrQFMA7EBOR+xA3Y3sQAHU7EC7Ge1ADF/tQPaj7UB56O1AmCzuQFJw7kCqs+5AoPbuQDU570Bre+9AQ73vQL3+70DbP/BAnYDwQAXB8EAUAfFAykDxQCmA8UAxv/FA5P3xQEI88kBMevJAA7jyQGj18kB8MvNAQG/zQLSr80DZ5/NAsCP0QDtf9EB4mvRAatX0QBIQ9UBvSvVAgoT1QE2+9UDQ9/VADDH2QAFq9kCwovZAGdv2QD8T90AgS/dAvoL3QBm690Ay8fdACij4QKFe+ED3lPhADsv4QOYA+UB/NvlA22v5QPmg+UDa1flAfwr6QOg++kAWc/pACaf6QMLa+kBBDvtAh0H7QJV0+0Bqp/tAB9r7QG0M/ECdPvxAlnD8QFmi/EDn0/xAPwX9QGQ2/UBUZ/1AEJj9QJrI/UDw+P1AFCn+QAZZ/kDHiP5AVrj+QLTn/kDjFv9A4UX/QK90/0BOo/9AvtH/QAAAAAABAAAAAgAAAAMAQfgaCxUBAAAAAQAAAAEAAAABAAAAAQAAAAEAQaAbCy3/////AQAAAP7///8CAAAA/f///wMAAAD/////AQAAAP7///8CAAAA/f///wMAQegbC0UBAAAAAQAAAAIAAAACAAAAAwAAAAMAAAAEAAAABAAAAAUAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAAMAAAADgAAABgAQdAcC70WAQAAAAEAAAACAAAAAgAAAAMAAAADAAAABAAAAAQAAAAFAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAAGAAAAAAAAAAEAAAACAAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAACwAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwA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EgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAACwAAAAAAAAAbAAAAAAAAACsAAAAAAAAAOwAAAAAAAADLAgAAAAAAAMsGAAAAAAAAywoAAAAAAADLDgAAAAAAANsCAAAAAAAA2wYAAAAAAADbCgAAAAAAANsOAAAAAAAA6wIAAAAAAADrBgAAAAAAAOsKAAAAAAAA6w4AAAAAAAD7AgAAAAAAAPsGAAAAAAAA+woAAAAAAAD7DgAAAAAAAMuyAAAAAAAAy7IBAAAAAADLsgIAAAAAAMuyAwAAAAAAy7YAAAAAAADLtgEAAAAAAMu2AgAAAAAAy7YDAAAAAADLugAAAAAAAMu6AQAAAAAAy7oCAAAAAADLugMAAAAAAMu+AAAAAAAAy74BAAAAAADLvgIAAAAAAMu+AwAAAAAA27IAAAAAAADbsgEAAAAAANuyAgAAAAAA27IDAAAAAADbtgAAAAAAANu2AQAAAAAA27YCAAAAAADbtgMAAAAAANu6AAAAAAAA27oBAAAAAADbugIAAAAAANu6AwAAAAAA274AAAAAAADbvgEAAAAAANu+AgAAAAAA274DAAAAAADrsgAAAAAAAOuyAQAAAAAA67ICAAAAAADrsgMAAAAAAOu2AAAAAAAA67YBAAAAAADrtgIAAAAAAOu2AwAAAAAA67oAAAAAAADrugEAAAAAAOu6AgAAAAAA67oDAAAAAADrvgAAAAAAAOu+AQAAAAAA674CAAAAAADrvgMAAAAAAPuyAAAAAAAA+7IBAAAAAAD7sgIAAAAAAPuyAwAAAAAA+7YAAAAAAAD7tgEAAAAAAPu2AgAAAAAA+7YDAAAAAAD7ugAAAAAAAPu6AQAAAAAA+7oCAAAAAAD7ugMAAAAAAPu+AAAAAAAA+74BAAAAAAD7vgIAAAAAAPu+AwAAAAAAy7IsAAAAAADLsmwAAAAAAMuyrAAAAAAAy7LsAAAAAADLsi0AAAAAAMuybQAAAAAAy7KtAAAAAADLsu0AAAAAAMuyLgAAAAAAy7JuAAAAAADLsq4AAAAAAMuy7gAAAAAAy7IvAAAAAADLsm8AAAAAAMuyrwAAAAAAy7LvAAAAAADLtiwAAAAAAMu2bAAAAAAAy7asAAAAAADLtuwAAAAAAMu2LQAAAAAAy7ZtAAAAAADLtq0AAAAAAMu27QAAAAAAy7YuAAAAAADLtm4AAAAAAMu2rgAAAAAAy7buAAAAAADLti8AAAAAAMu2bwAAAAAAy7avAAAAAADLtu8AAAAAAMu6LAAAAAAAy7psAAAAAADLuqwAAAAAAMu67AAAAAAAy7otAAAAAADLum0AAAAAAMu6rQAAAAAAy7rtAAAAAADLui4AAAAAAMu6bgAAAAAAy7quAAAAAADLuu4AAAAAAMu6LwAAAAAAy7pvAAAAAADLuq8AAAAAAMu67wAAAAAAy74sAAAAAADLvmwAAAAAAMu+rAAAAAAAy77sAAAAAADLvi0AAAAAAMu+bQAAAAAAy76tAAAAAADLvu0AAAAAAMu+LgAAAAAAy75uAAAAAADLvq4AAAAAAMu+7gAAAAAAy74vAAAAAADLvm8AAAAAAMu+rwAAAAAAy77vAAAAAADbsiwAAAAAANuybAAAAAAA27KsAAAAAADbsuwAAAAAANuyLQAAAAAA27JtAAAAAADbsq0AAAAAANuy7QAAAAAA27IuAAAAAADbsm4AAAAAANuyrgAAAAAA27LuAAAAAADbsi8AAAAAANuybwAAAAAA27KvAAAAAADbsu8AAAAAANu2LAAAAAAA27ZsAAAAAADbtqwAAAAAANu27AAAAAAA27YtAAAAAADbtm0AAAAAANu2rQAAAAAA27btAAAAAADbti4AAAAAANu2bgAAAAAA27auAAAAAADbtu4AAAAAANu2LwAAAAAA27ZvAAAAAADbtq8AAAAAANu27wAAAAAA27osAAAAAADbumwAAAAAANu6rAAAAAAA27rsAAAAAADbui0AAAAAANu6bQAAAAAA27qtAAAAAADbuu0AAAAAANu6LgAAAAAA27puAAAAAADbuq4AAAAAANu67gAAAAAA27ovAAAAAADbum8AAAAAANu6rwAAAAAA27rvAAAAAADbviwAAAAAANu+bAAAAAAA276sAAAAAADbvuwAAAAAANu+LQAAAAAA275tAAAAAADbvq0AAAAAANu+7QAAAAAA274uAAAAAADbvm4AAAAAANu+rgAAAAAA277uAAAAAADbvi8AAAAAANu+bwAAAAAA276vAAAAAADbvu8AAAAAAOuyLAAAAAAA67JsAAAAAADrsqwAAAAAAOuy7AAAAAAA67ItAAAAAADrsm0AAAAAAOuyrQAAAAAA67LtAAAAAADrsi4AAAAAAOuybgAAAAAA67KuAAAAAADrsu4AAAAAAOuyLwAAAAAA67JvAAAAAADrsq8AAAAAAOuy7wAAAAAA67YsAAAAAADrtmwAAAAAAOu2rAAAAAAA67bsAAAAAADrti0AAAAAAOu2bQAAAAAA67atAAAAAADrtu0AAAAAAOu2LgAAAAAA67ZuAAAAAADrtq4AAAAAAOu27gAAAAAA67YvAAAAAADrtm8AAAAAAOu2rwAAAAAA67bvAAAAAADruiwAAAAAAOu6bAAAAAAA67qsAAAAAADruuwAAAAAAOu6LQAAAAAA67ptAAAAAADruq0AAAAAAOu67QAAAAAA67ouAAAAAADrum4AAAAAAOu6rgAAAAAA67ruAAAAAADrui8AAAAAAOu6bwAAAAAA67qvAAAAAADruu8AAAAAAOu+LAAAAAAA675sAAAAAADrvqwAAAAAAOu+7AAAAAAA674tAAAAAADrvm0AAAAAAOu+rQAAAAAA677tAAAAAADrvi4AAAAAAOu+bgAAAAAA676uAAAAAADrvu4AAAAAAOu+LwAAAAAA675vAAAAAADrvq8AAAAAAOu+7wAAAAAA+7IsAAAAAAD7smwAAAAAAPuyrAAAAAAA+7LsAAAAAAD7si0AAAAAAPuybQAAAAAA+7KtAAAAAAD7su0AAAAAAPuyLgAAAAAA+7JuAAAAAAD7sq4AAAAAAPuy7gAAAAAA+7IvAAAAAAD7sm8AAAAAAPuyrwAAAAAA+7LvAAAAAAD7tiwAAAAAAPu2bAAAAAAA+7asAAAAAAD7tuwAAAAAAPu2LQAAAAAA+7ZtAAAAAAD7tq0AAAAAAPu27QAAAAAA+7YuAAAAAAD7tm4AAAAAAPu2rgAAAAAA+7buAAAAAAD7ti8AAAAAAPu2bwAAAAAA+7avAAAAAAD7tu8AAAAAAPu6LAAAAAAA+7psAAAAAAD7uqwAAAAAAPu67AAAAAAA+7otAAAAAAD7um0AAAAAAPu6rQAAAAAA+7rtAAAAAAD7ui4AAAAAAPu6bgAAAAAA+7quAAAAAAD7uu4AAAAAAPu6LwAAAAAA+7pvAAAAAAD7uq8AAAAAAPu67wAAAAAA+74sAAAAAAD7vmwAAAAAAPu+rAAAAAAA+77sAAAAAAD7vi0AAAAAAPu+bQAAAAAA+76tAAAAAAD7vu0AAAAAAPu+LgAAAAAA+75uAAAAAAD7vq4AAAAAAPu+7gAAAAAA+74vAAAAAAD7vm8AAAAAAPu+rwAAAAAA+77vAAAAAADLsiwLAAAAAMuyLBsAAAAAy7IsKwAAAADLsiw7AAAAAMuybAsAAAAAy7JsGwAAAADLsmwrAAAAAMuybDsAAAAAy7KsCwAAAADLsqwbAAAAAMuyrCsAAAAAy7KsOwAAAADLsuwLAAAAAMuy7BsAAAAAy7LsKwAAAADLsuw7AAAAAMuyLQsAAAAAy7ItGwAAAADLsi0rAAAAAMuyLTsAAAAAy7JtCwAAAADLsm0bAAAAAMuybSsAAAAAy7JtOwAAAADLsq0LAAAAAMuyrRsAAAAAy7KtKwAAAADLsq07AAAAAMuy7QsAAAAAy7LtGwAAAADLsu0rAAAAAMuy7TsAAAAAy7IuCwAAAADLsi4bAAAAAMuyLisAAAAAy7IuOwAAAADLsm4LAAAAAMuybhsAAAAAy7JuKwAAAADLsm47AAAAAMuyrgsAAAAAy7KuGwAAAADLsq4rAAAAAMuyrjsAAAAAy7LuCwAAAADLsu4bAAAAAMuy7isAAAAAy7LuOwAAAADLsi8LAAAAAMuyLxsAAAAAy7IvKwAAAADLsi87AAAAAMuybwsAAAAAy7JvGwAAAADLsm8rAAAAAMuybzsAAAAAy7KvCwAAAADLsq8bAAAAAMuyrysAAAAAy7KvOwAAAADLsu8LAAAAAMuy7xsAAAAAy7LvKwAAAADLsu87AAAAAMu2LAsAAAAAy7YsGwAAAADLtiwrAAAAAMu2LDsAAAAAy7ZsCwAAAADLtmwbAAAAAMu2bCsAAAAAy7ZsOwAAAADLtqwLAAAAAMu2rBsAAAAAy7asKwAAAADLtqw7AAAAAMu27AsAAAAAy7bsGwAAAADLtuwrAAAAAMu27DsAAAAAy7YtCwAAAADLti0bAAAAAMu2LSsAAAAAy7YtOwAAAADLtm0LAAAAAMu2bRsAAAAAy7ZtKwAAAADLtm07AAAAAMu2rQsAAAAAy7atGwAAAADLtq0rAAAAAMu2rTsAAAAAy7btCwAAAADLtu0bAAAAAMu27SsAAAAAy7btOwAAAADLti4LAAAAAMu2LhsAAAAAy7YuKwAAAADLti47AAAAAMu2bgsAAAAAy7ZuGwAAAADLtm4rAAAAAMu2bjsAAAAAy7auCwAAAADLtq4bAAAAAMu2risAAAAAy7auOwAAAADLtu4LAAAAAMu27hsAAAAAy7buKwAAAADLtu47AAAAAMu2LwsAAAAAy7YvGwAAAADLti8rAAAAAMu2LzsAAAAAy7ZvCwAAAADLtm8bAAAAAMu2bysAAAAAy7ZvOwAAAADLtq8LAAAAAMu2rxsAAAAAy7avKwAAAADLtq87AAAAAMu27wsAAAAAy7bvGwAAAADLtu8rAAAAAMu27zsAAAAAy7osCwAAAADLuiwbAAAAAMu6LCsAAAAAy7osOwAAAADLumwLAAAAAMu6bBsAAAAAy7psKwAAAADLumw7AAAAAMu6rAsAAAAAy7qsGwAAAADLuqwrAAAAAMu6rDsAAAAAy7rsCwAAAADLuuwbAAAAAMu67CsAAAAAy7rsOwAAAADLui0LAAAAAMu6LRsAAAAAy7otKwAAAADLui07AAAAAMu6bQsAAAAAy7ptGwAAAADLum0rAAAAAMu6bTsAAAAAy7qtCwAAAADLuq0bAAAAAMu6rSsAAAAAy7qtOwAAAADLuu0LAAAAAMu67RsAAAAAy7rtKwAAAADLuu07AAAAAMu6LgsAAAAAy7ouGwAAAADLui4rAAAAAMu6LjsAAAAAy7puCwAAAADLum4bAAAAAMu6bisAAAAAy7puOwAAAADLuq4LAAAAAMu6rhsAAAAAy7quKwAAAADLuq47AAAAAMu67gsAAAAAy7ruGwAAAADLuu4rAAAAAMu67jsAAAAAy7ovCwAAAADLui8bAAAAAMu6LysAAAAAy7ovOwAAAADLum8LAAAAAMu6bxsAAAAAy7pvKwAAAADLum87AAAAAMu6rwsAAAAAy7qvGwAAAADLuq8rAAAAAMu6rzsAAAAAy7rvCwAAAADLuu8bAAAAAMu67ysAAAAAy7rvOwAAAADLviwLAAAAAMu+LBsAAAAAy74sKwAAAADLviw7AAAAAMu+bAsAAAAAy75sGwAAAADLvmwrAAAAAMu+bDsAAAAAy76sCwAAAADLvqwbAAAAAMu+rCsAAAAAy76sOwAAAADLvuwLAAAAAMu+7BsAAAAAy77sKwAAAADLvuw7AAAAAMu+LQsAAAAAy74tGwAAAADLvi0rAAAAAMu+LTsAAAAAy75tCwAAAADLvm0bAAAAAMu+bSsAAAAAy75tOwAAAADLvq0LAAAAAMu+rRsAAAAAy76tKwAAAADLvq07AAAAAMu+7QsAAAAAy77tGwAAAADLvu0rAAAAAMu+7TsAAAAAy74uCwAAAADLvi4bAAAAAMu+LisAAAAAy74uOwAAAADLvm4LAAAAAMu+bhsAAAAAy75uKwAAAADLvm47AAAAAMu+rgsAAAAAy76uGwAAAADLvq4rAAAAAMu+rjsAAAAAy77uCwAAAADLvu4bAAAAAMu+7isAAAAAy77uOwAAAADLvi8LAAAAAMu+LxsAAAAAy74vKwAAAADLvi87AAAAAMu+bwsAAAAAy75vGwAAAADLvm8rAAAAAMu+bzsAAAAAy76vCwAAAADLvq8bAAAAAMu+rysAAAAAy76vOwAAAADLvu8LAAAAAMu+7xsAAAAAy77vKwAAAADLvu87AAAAANuyLAsAAAAA27IsGwAAAADbsiwrAAAAANuyLDsAAAAA27JsCwAAAADbsmwbAAAAANuybCsAAAAA27JsOwAAAADbsqwLAAAAANuyrBsAAAAA27KsKwAAAADbsqw7AAAAANuy7AsAAAAA27LsGwAAAADbsuwrAAAAANuy7DsAAAAA27ItCwAAAADbsi0bAAAAANuyLSsAAAAA27ItOwAAAADbsm0LAAAAANuybRsAAAAA27JtKwAAAADbsm07AAAAANuyrQsAAAAA27KtGwAAAADbsq0rAAAAANuyrTsAAAAA27LtCwAAAADbsu0bAAAAANuy7SsAAAAA27LtOwAAAADbsi4LAAAAANuyLhsAAAAA27IuKwAAAADbsi47AAAAANuybgsAAAAA27JuGwAAAADbsm4rAAAAANuybjsAAAAA27KuCwAAAADbsq4bAAAAANuyrisAAAAA27KuOwAAAADbsu4LAAAAANuy7hsAAAAA27LuKwAAAADbsu47AAAAANuyLwsAAAAA27IvGwAAAADbsi8rAAAAANuyLzsAAAAA27JvCwAAAADbsm8bAAAAANuybysAAAAA27JvOwAAAADbsq8LAAAAANuyrxsAAAAA27KvKwAAAADbsq87AAAAANuy7wsAAAAA27LvGwAAAADbsu8rAAAAANuy7zsAAAAA27YsCwAAAADbtiwbAAAAANu2LCsAAAAA27YsOwAAAADbtmwLAAAAANu2bBsAAAAA27ZsKwAAAADbtmw7AAAAANu2rAsAAAAA27asGwAAAADbtqwrAAAAANu2rDsAAAAA27bsCwAAAADbtuwbAAAAANu27CsAAAAA27bsOwAAAADbti0LAAAAANu2LRsAAAAA27YtKwAAAADbti07AAAAANu2bQsAAAAA27ZtGwAAAADbtm0rAAAAANu2bTsAAAAA27atCwAAAADbtq0bAAAAANu2rSsAAAAA27atOwAAAADbtu0LAAAAANu27RsAAAAA27btKwAAAADbtu07AAAAANu2LgsAAAAA27YuGwAAAADbti4rAAAAANu2LjsAAAAA27ZuCwAAAADbtm4bAAAAANu2bisAAAAA27ZuOwAAAADbtq4LAAAAANu2rhsAAAAA27auKwAAAADbtq47AAAAAAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+PwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AQYSmAQv8AQEBAQECAgICAwMDAwQEBAQFBQUFBgYGBgcHBwcICAgICQkJCQoKCgoLCwsLDAwMDA0NDQ0ODg4ODw8PDxAQEBAREREREhISEhMTExMUFBQUFRUVFRYWFhYXFxcXGBgYGBkZGRkaGhoaGxsbGxwcHBwdHR0dHh4eHh8fHx8gICAgISEhISIiIiIjIyMjJCQkJCUlJSUmJiYmJycnJygoKCgpKSkpKioqKisrKyssLCwsLS0tLS4uLi4vLy8vMDAwMDExMTEyMjIyMzMzMzQ0NDQ1NTU1NjY2Njc3Nzc4ODg4OTk5OTo6Ojo7Ozs7PDw8PD09PT0+Pj4+Pz8/PwBBiaoBCwUEBAAABABBoKoBC+ABCAwQDAwUDBAYHAwMIAwkDCwsLCwsLCwsLCwgIBgoHAwMMDQ0NDA0NDQwNDQ0NDQwNDQ0NDQwNDQ0NDQYDBwMDAw4PDw8ODw8PDg8PDw8PDg8PDw8PDg8PDw8PBgMHAwAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMAQaGsAQteAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQEBAQMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAQEBAQBB4K0BC9UWAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIACAgICAgICAgICAgICAgIEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgwMDAwMDAwMDAwMDAwMDA4AAEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBgYGBgYGBgYGBgYGBgYGBwkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAYAAgAFAAEABwADAASAAIAGgAKABYABgAeAA4AEQABABkACQAVAAUAHQANABMAAwAbAAsAFwAHAB8ADwAQgACAGIAIgBSABIAcgAyAEoACgBqACoAWgAaAHoAOgBGAAYAZgAmAFYAFgB2ADYATgAOAG4ALgBeAB4AfgA+AEEAAQBhACEAUQARAHEAMQBJAAkAaQApAFkAGQB5ADkARQAFAGUAJQBVABUAdQA1AE0ADQBtAC0AXQAdAH0APQBDAAMAYwAjAFMAEwBzADMASwALAGsAKwBbABsAewA7AEcABwBnACcAVwAXAHcANwBPAA8AbwAvAF8AHwB/AD8AQIAAgGCAIIBQgBCAcIAwgEiACIBogCiAWIAYgHiAOIBEgASAZIAkgFSAFIB0gDSATIAMgGyALIBcgByAfIA8gEKAAoBigCKAUoASgHKAMoBKgAqAaoAqgFqAGoB6gDqARoAGgGaAJoBWgBaAdoA2gE6ADoBugC6AXoAegH6APoBBgAGAYYAhgFGAEYBxgDGASYAJgGmAKYBZgBmAeYA5gEWABYBlgCWAVYAVgHWANYBNgA2AbYAtgF2AHYB9gD2AQ4ADgGOAI4BTgBOAc4AzgEuAC4BrgCuAW4AbgHuAO4BHgAeAZ4AngFeAF4B3gDeAT4APgG+AL4BfgB+Af4A/gEBAAEBgQCBAUEAQQHBAMEBIQAhAaEAoQFhAGEB4QDhAREAEQGRAJEBUQBRAdEA0QExADEBsQCxAXEAcQHxAPEBCQAJAYkAiQFJAEkByQDJASkAKQGpAKkBaQBpAekA6QEZABkBmQCZAVkAWQHZANkBOQA5AbkAuQF5AHkB+QD5AQUABQGFAIUBRQBFAcUAxQElACUBpQClAWUAZQHlAOUBFQAVAZUAlQFVAFUB1QDVATUANQG1ALUBdQB1AfUA9QENAA0BjQCNAU0ATQHNAM0BLQAtAa0ArQFtAG0B7QDtAR0AHQGdAJ0BXQBdAd0A3QE9AD0BvQC9AX0AfQH9AP0BAwADAYMAgwFDAEMBwwDDASMAIwGjAKMBYwBjAeMA4wETABMBkwCTAVMAUwHTANMBMwAzAbMAswFzAHMB8wDzAQsACwGLAIsBSwBLAcsAywErACsBqwCrAWsAawHrAOsBGwAbAZsAmwFbAFsB2wDbATsAOwG7ALsBewB7AfsA+wEHAAcEBwIHBgcBBwUHAwcHhwCHBIcChwaHAYcFhwOHB0cARwRHAkcGRwFHBUcDRwfHAMcExwLHBscBxwXHA8cHJwAnBCcCJwYnAScFJwMnB6cApwSnAqcGpwGnBacDpwdnAGcEZwJnBmcBZwVnA2cH5wDnBOcC5wbnAecF5wPnBxcAFwQXAhcGFwEXBRcDFweXAJcElwKXBpcBlwWXA5cHVwBXBFcCVwZXAVcFVwNXB9cA1wTXAtcG1wHXBdcD1wc3ADcENwI3BjcBNwU3AzcHtwC3BLcCtwa3AbcFtwO3B3cAdwR3AncGdwF3BXcDdwf3APcE9wL3BvcB9wX3A/cHDwAPBA8CDwYPAQ8FDwMPB48AjwSPAo8GjwGPBY8DjwdPAE8ETwJPBk8BTwVPA08HzwDPBM8CzwbPAc8FzwPPBy8ALwQvAi8GLwEvBS8DLwevAK8ErwKvBq8BrwWvA68HbwBvBG8CbwZvAW8FbwNvB+8A7wTvAu8G7wHvBe8D7wcfAB8EHwIfBh8BHwUfAx8HnwCfBJ8CnwafAZ8FnwOfB18AXwRfAl8GXwFfBV8DXwffAN8E3wLfBt8B3wXfA98HPwA/BD8CPwY/AT8FPwM/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AAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMAQeGPAgteAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQEBAQMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAQEBAQBBoJECC70EAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIACAgICAgICAgICAgICAgIEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgwMDAwMDAwMDAwMDAwMDA4AAEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBgYGBgYGBgYGBgYGBgYGBwAAAAAAAAAAAQAAAAIAAAALAAAACwAAAAwAAAAMAEHwlQILgQEBAAAAAQAAAAkAAAAJAAAAAgAAAAIAAAACAAAAAgAAAAEAAAABAAAAAQAAAAEAAAAIAAAAAwAAAAMAAAADAAAAAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAAIAAAABAAAAAQAAAAEAAAACAAAAAcAAAAEAAAABAAAAAgAQYCXAgtd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EwBB8pcGCw5lbQAAAACpO6VgLBbkTwBBnpgGCxJm2gAAAAAAAAAAzRMmbQAAZFIAQdaYBgsC5TAAQfCYBgsKiFNkbgAAxgmMTgBBkpkGCwaGtgAARngAQaKZBgsChTkAQcCZBgsYSwTkGAAAAAAAAIYwTjsAAOshAACpKQZMAEHkmQYLDDYGAACMewAAaFgmTQBB/pkGCwKGXgBBipoGCwLmxQBBoJoGCwKrIwBBvpoGCwIHKwBB0JoGCwRqQKfVAEHkmgYLDIkyAAAAAAAAAACEPgBBgpsGCwSFCAsbAEGUmwYLFAg9JiwAAAAAKRaHHQAAAABMOUQ9AEG0mwYLvb8HjF4GvAAApl4AAOfYAAAAAIgNxUoAAAAAAAAAAHRpbWVkb3dubGlmZWxlZnRiYWNrY29kZWRhdGFzaG93b25seXNpdGVjaXR5b3Blbmp1c3RsaWtlZnJlZXdvcmt0ZXh0eWVhcm92ZXJib2R5bG92ZWZvcm1ib29rcGxheWxpdmVsaW5laGVscGhvbWVzaWRlbW9yZXdvcmRsb25ndGhlbXZpZXdmaW5kcGFnZWRheXNmdWxsaGVhZHRlcm1lYWNoYXJlYWZyb210cnVlbWFya2FibGV1cG9uaGlnaGRhdGVsYW5kbmV3c2V2ZW5uZXh0Y2FzZWJvdGhwb3N0dXNlZG1hZGVoYW5kaGVyZXdoYXRuYW1lTGlua2Jsb2dzaXplYmFzZWhlbGRtYWtlbWFpbnVzZXInKSAraG9sZGVuZHN3aXRoTmV3c3JlYWR3ZXJlc2lnbnRha2VoYXZlZ2FtZXNlZW5jYWxscGF0aHdlbGxwbHVzbWVudWZpbG1wYXJ0am9pbnRoaXNsaXN0Z29vZG5lZWR3YXlzd2VzdGpvYnNtaW5kYWxzb2xvZ29yaWNodXNlc2xhc3R0ZWFtYXJteWZvb2RraW5nd2lsbGVhc3R3YXJkYmVzdGZpcmVQYWdla25vd2F3YXkucG5nbW92ZXRoYW5sb2FkZ2l2ZXNlbGZub3RlbXVjaGZlZWRtYW55cm9ja2ljb25vbmNlbG9va2hpZGVkaWVkSG9tZXJ1bGVob3N0YWpheGluZm9jbHVibGF3c2xlc3NoYWxmc29tZXN1Y2h6b25lMTAwJW9uZXNjYXJlVGltZXJhY2VibHVlZm91cndlZWtmYWNlaG9wZWdhdmVoYXJkbG9zdHdoZW5wYXJra2VwdHBhc3NzaGlwcm9vbUhUTUxwbGFuVHlwZWRvbmVzYXZla2VlcGZsYWdsaW5rc29sZGZpdmV0b29rcmF0ZXRvd25qdW1wdGh1c2RhcmtjYXJkZmlsZWZlYXJzdGF5a2lsbHRoYXRmYWxsYXV0b2V2ZXIuY29tdGFsa3Nob3B2b3RlZGVlcG1vZGVyZXN0dHVybmJvcm5iYW5kZmVsbHJvc2V1cmwoc2tpbnJvbGVjb21lYWN0c2FnZXNtZWV0Z29sZC5qcGdpdGVtdmFyeWZlbHR0aGVuc2VuZGRyb3BWaWV3Y29weTEuMCI8L2E+c3RvcGVsc2VsaWVzdG91cnBhY2suZ2lmcGFzdGNzcz9ncmF5bWVhbiZndDtyaWRlc2hvdGxhdGVzYWlkcm9hZHZhciBmZWVsam9obnJpY2twb3J0ZmFzdCdVQS1kZWFkPC9iPnBvb3JiaWxsdHlwZVUuUy53b29kbXVzdDJweDtJbmZvcmFua3dpZGV3YW50d2FsbGxlYWRbMF07cGF1bHdhdmVzdXJlJCgnI3dhaXRtYXNzYXJtc2dvZXNnYWlubGFuZ3BhaWQhLS0gbG9ja3VuaXRyb290d2Fsa2Zpcm13aWZleG1sInNvbmd0ZXN0MjBweGtpbmRyb3dzdG9vbGZvbnRtYWlsc2FmZXN0YXJtYXBzY29yZXJhaW5mbG93YmFieXNwYW5zYXlzNHB4OzZweDthcnRzZm9vdHJlYWx3aWtpaGVhdHN0ZXB0cmlwb3JnL2xha2V3ZWFrdG9sZEZvcm1jYXN0ZmFuc2Jhbmt2ZXJ5cnVuc2p1bHl0YXNrMXB4O2dvYWxncmV3c2xvd2VkZ2VpZD0ic2V0czVweDsuanM/NDBweGlmIChzb29uc2VhdG5vbmV0dWJlemVyb3NlbnRyZWVkZmFjdGludG9naWZ0aGFybTE4cHhjYW1laGlsbGJvbGR6b29tdm9pZGVhc3lyaW5nZmlsbHBlYWtpbml0Y29zdDNweDtqYWNrdGFnc2JpdHNyb2xsZWRpdGtuZXduZWFyPCEtLWdyb3dKU09OZHV0eU5hbWVzYWxleW91IGxvdHNwYWluamF6emNvbGRleWVzZmlzaHd3dy5yaXNrdGFic3ByZXYxMHB4cmlzZTI1cHhCbHVlZGluZzMwMCxiYWxsZm9yZGVhcm53aWxkYm94LmZhaXJsYWNrdmVyc3BhaXJqdW5ldGVjaGlmKCFwaWNrZXZpbCQoIiN3YXJtbG9yZGRvZXNwdWxsLDAwMGlkZWFkcmF3aHVnZXNwb3RmdW5kYnVybmhyZWZjZWxsa2V5c3RpY2tob3VybG9zc2Z1ZWwxMnB4c3VpdGRlYWxSU1MiYWdlZGdyZXlHRVQiZWFzZWFpbXNnaXJsYWlkczhweDtuYXZ5Z3JpZHRpcHMjOTk5d2Fyc2xhZHljYXJzKTsgfXBocD9oZWxsdGFsbHdob216aDrlKi8NCiAxMDBoYWxsLgoKQTdweDtwdXNoY2hhdDBweDtjcmV3Ki88L2hhc2g3NXB4ZmxhdHJhcmUgJiYgdGVsbGNhbXBvbnRvbGFpZG1pc3Nza2lwdGVudGZpbmVtYWxlZ2V0c3Bsb3Q0MDAsDQoNCmNvb2xmZWV0LnBocDxicj5lcmljbW9zdGd1aWRiZWxsZGVzY2hhaXJtYXRoYXRvbS9pbWcmIzgybHVja2NlbnQwMDA7dGlueWdvbmVodG1sc2VsbGRydWdGUkVFbm9kZW5pY2s/aWQ9bG9zZW51bGx2YXN0d2luZFJTUyB3ZWFycmVseWJlZW5zYW1lZHVrZW5hc2FjYXBld2lzaGd1bGZUMjM6aGl0c3Nsb3RnYXRla2lja2JsdXJ0aGV5MTVweCcnKTspOyI+bXNpZXdpbnNiaXJkc29ydGJldGFzZWVrVDE4Om9yZHN0cmVlbWFsbDYwcHhmYXJt4oCZc2JveXNbMF0uJyk7IlBPU1RiZWFya2lkcyk7fX1tYXJ5dGVuZChVSylxdWFkemg65i1zaXotLS0tcHJvcCcpOw1saWZ0VDE5OnZpY2VhbmR5ZGVidD5SU1Nwb29sbmVja2Jsb3dUMTY6ZG9vcmV2YWxUMTc6bGV0c2ZhaWxvcmFscG9sbG5vdmFjb2xzZ2VuZSDigJRzb2Z0cm9tZXRpbGxyb3NzPGgzPnBvdXJmYWRlcGluazx0cj5taW5pKXwhKG1pbmV6aDroYmFyc2hlYXIwMCk7bWlsayAtLT5pcm9uZnJlZGRpc2t3ZW50c29pbHB1dHMvanMvaG9seVQyMjpJU0JOVDIwOmFkYW1zZWVzPGgyPmpzb24nLCAnY29udFQyMTogUlNTbG9vcGFzaWFtb29uPC9wPnNvdWxMSU5FZm9ydGNhcnRUMTQ6PGgxPjgwcHghLS08OXB4O1QwNDptaWtlOjQ2Wm5pY2VpbmNoWW9ya3JpY2V6aDrkJykpO3B1cmVtYWdlcGFyYXRvbmVib25kOjM3Wl9vZl8nXSk7MDAwLHpoOud0YW5reWFyZGJvd2xidXNoOjU2WkphdmEzMHB4Cnx9CiVDMyU6MzRaamVmZkVYUEljYXNodmlzYWdvbGZzbm93emg66XF1ZXIuY3Nzc2lja21lYXRtaW4uYmluZGRlbGxoaXJlcGljc3JlbnQ6MzZaSFRUUC0yMDFmb3Rvd29sZkVORCB4Ym94OjU0WkJPRFlkaWNrOwp9CmV4aXQ6MzVadmFyc2JlYXQnfSk7ZGlldDk5OTthbm5lfX08L1tpXS5MYW5na23CsndpcmV0b3lzYWRkc3NlYWxhbGV4OwoJfWVjaG9uaW5lLm9yZzAwNSl0b255amV3c3NhbmRsZWdzcm9vZjAwMCkgMjAwd2luZWdlYXJkb2dzYm9vdGdhcnljdXRzdHlsZXRlbXB0aW9uLnhtbGNvY2tnYW5nJCgnLjUwcHhQaC5EbWlzY2FsYW5sb2FuZGVza21pbGVyeWFudW5peGRpc2MpO30KZHVzdGNsaXApLgoKNzBweC0yMDBEVkRzN10+PHRhcGVkZW1vaSsrKXdhZ2VldXJvcGhpbG9wdHNob2xlRkFRc2FzaW4tMjZUbGFic3BldHNVUkwgYnVsa2Nvb2s7fQ0KSEVBRFswXSlhYmJyanVhbigxOThsZXNodHdpbjwvaT5zb255Z3V5c2Z1Y2twaXBlfC0KITAwMiluZG93WzFdO1tdOwpMb2cgc2FsdA0KCQliYW5ndHJpbWJhdGgpew0KMDBweAp9KTtrbzrsZmVlc2FkPg1zOi8vIFtdO3RvbGxwbHVnKCl7CnsNCiAuanMnMjAwcGR1YWxib2F0LkpQRyk7Cn1xdW90KTsKCicpOwoNCn0NMjAxNDIwMTUyMDE2MjAxNzIwMTgyMDE5MjAyMDIwMjEyMDIyMjAyMzIwMjQyMDI1MjAyNjIwMjcyMDI4MjAyOTIwMzAyMDMxMjAzMjIwMzMyMDM0MjAzNTIwMzYyMDM3MjAxMzIwMTIyMDExMjAxMDIwMDkyMDA4MjAwNzIwMDYyMDA1MjAwNDIwMDMyMDAyMjAwMTIwMDAxOTk5MTk5ODE5OTcxOTk2MTk5NTE5OTQxOTkzMTk5MjE5OTExOTkwMTk4OTE5ODgxOTg3MTk4NjE5ODUxOTg0MTk4MzE5ODIxOTgxMTk4MDE5NzkxOTc4MTk3NzE5NzYxOTc1MTk3NDE5NzMxOTcyMTk3MTE5NzAxOTY5MTk2ODE5NjcxOTY2MTk2NTE5NjQxOTYzMTk2MjE5NjExOTYwMTk1OTE5NTgxOTU3MTk1NjE5NTUxOTU0MTk1MzE5NTIxOTUxMTk1MDEwMDAxMDI0MTM5NDAwMDA5OTk5Y29tb23DoXNlc3RlZXN0YXBlcm90b2RvaGFjZWNhZGFhw7FvYmllbmTDrWFhc8OtdmlkYWNhc29vdHJvZm9yb3NvbG9vdHJhY3VhbGRpam9zaWRvZ3JhbnRpcG90ZW1hZGViZWFsZ29xdcOpZXN0b25hZGF0cmVzcG9jb2Nhc2FiYWpvdG9kYXNpbm9hZ3VhcHVlc3Vub3NhbnRlZGljZWx1aXNlbGxhbWF5b3pvbmFhbW9ycGlzb29icmFjbGljZWxsb2Rpb3Nob3JhY2FzadC30LDQvdCw0L7QvNGA0LDRgNGD0YLQsNC90LXQv9C+0L7RgtC40LfQvdC+0LTQvtGC0L7QttC10L7QvdC40YXQndCw0LXQtdCx0YvQvNGL0JLRi9GB0L7QstGL0LLQvtCd0L7QvtCx0J/QvtC70LjQvdC40KDQpNCd0LXQnNGL0YLRi9Ce0L3QuNC80LTQsNCX0LDQlNCw0J3Rg9Ce0LHRgtC10JjQt9C10LnQvdGD0LzQvNCi0YvRg9C22YHZitij2YbZhdin2YXYudmD2YTYo9mI2LHYr9mK2KfZgdmJ2YfZiNmE2YXZhNmD2KfZiNmE2YfYqNiz2KfZhNil2YbZh9mK2KPZitmC2K/Zh9mE2KvZhdio2YfZhNmI2YTZitio2YTYp9mK2KjZg9i02YrYp9mF2KPZhdmG2KrYqNmK2YTZhtit2KjZh9mF2YXYtNmI2LRmaXJzdHZpZGVvbGlnaHR3b3JsZG1lZGlhd2hpdGVjbG9zZWJsYWNrcmlnaHRzbWFsbGJvb2tzcGxhY2VtdXNpY2ZpZWxkb3JkZXJwb2ludHZhbHVlbGV2ZWx0YWJsZWJvYXJkaG91c2Vncm91cHdvcmtzeWVhcnNzdGF0ZXRvZGF5d2F0ZXJzdGFydHN0eWxlZGVhdGhwb3dlcnBob25lbmlnaHRlcnJvcmlucHV0YWJvdXR0ZXJtc3RpdGxldG9vbHNldmVudGxvY2FsdGltZXNsYXJnZXdvcmRzZ2FtZXNzaG9ydHNwYWNlZm9jdXNjbGVhcm1vZGVsYmxvY2tndWlkZXJhZGlvc2hhcmV3b21lbmFnYWlubW9uZXlpbWFnZW5hbWVzeW91bmdsaW5lc2xhdGVyY29sb3JncmVlbmZyb250JmFtcDt3YXRjaGZvcmNlcHJpY2VydWxlc2JlZ2luYWZ0ZXJ2aXNpdGlzc3VlYXJlYXNiZWxvd2luZGV4dG90YWxob3Vyc2xhYmVscHJpbnRwcmVzc2J1aWx0bGlua3NzcGVlZHN0dWR5dHJhZGVmb3VuZHNlbnNldW5kZXJzaG93bmZvcm1zcmFuZ2VhZGRlZHN0aWxsbW92ZWR0YWtlbmFib3ZlZmxhc2hmaXhlZG9mdGVub3RoZXJ2aWV3c2NoZWNrbGVnYWxyaXZlcml0ZW1zcXVpY2tzaGFwZWh1bWFuZXhpc3Rnb2luZ21vdmlldGhpcmRiYXNpY3BlYWNlc3RhZ2V3aWR0aGxvZ2luaWRlYXN3cm90ZXBhZ2VzdXNlcnNkcml2ZXN0b3JlYnJlYWtzb3V0aHZvaWNlc2l0ZXNtb250aHdoZXJlYnVpbGR3aGljaGVhcnRoZm9ydW10aHJlZXNwb3J0cGFydHlDbGlja2xvd2VybGl2ZXNjbGFzc2xheWVyZW50cnlzdG9yeXVzYWdlc291bmRjb3VydHlvdXIgYmlydGhwb3B1cHR5cGVzYXBwbHlJbWFnZWJlaW5ndXBwZXJub3Rlc2V2ZXJ5c2hvd3NtZWFuc2V4dHJhbWF0Y2h0cmFja2tub3duZWFybHliZWdhbnN1cGVycGFwZXJub3J0aGxlYXJuZ2l2ZW5uYW1lZGVuZGVkVGVybXNwYXJ0c0dyb3VwYnJhbmR1c2luZ3dvbWFuZmFsc2VyZWFkeWF1ZGlvdGFrZXN3aGlsZS5jb20vbGl2ZWRjYXNlc2RhaWx5Y2hpbGRncmVhdGp1ZGdldGhvc2V1bml0c25ldmVyYnJvYWRjb2FzdGNvdmVyYXBwbGVmaWxlc2N5Y2xlc2NlbmVwbGFuc2NsaWNrd3JpdGVxdWVlbnBpZWNlZW1haWxmcmFtZW9sZGVycGhvdG9saW1pdGNhY2hlY2l2aWxzY2FsZWVudGVydGhlbWV0aGVyZXRvdWNoYm91bmRyb3lhbGFza2Vkd2hvbGVzaW5jZXN0b2NrIG5hbWVmYWl0aGhlYXJ0ZW1wdHlvZmZlcnNjb3Blb3duZWRtaWdodGFsYnVtdGhpbmtibG9vZGFycmF5bWFqb3J0cnVzdGNhbm9udW5pb25jb3VudHZhbGlkc3RvbmVTdHlsZUxvZ2luaGFwcHlvY2N1cmxlZnQ6ZnJlc2hxdWl0ZWZpbG1zZ3JhZGVuZWVkc3VyYmFuZmlnaHRiYXNpc2hvdmVyYXV0bztyb3V0ZS5odG1sbWl4ZWRmaW5hbFlvdXIgc2xpZGV0b3BpY2Jyb3duYWxvbmVkcmF3bnNwbGl0cmVhY2hSaWdodGRhdGVzbWFyY2hxdW90ZWdvb2RzTGlua3Nkb3VidGFzeW5jdGh1bWJhbGxvd2NoaWVmeW91dGhub3ZlbDEwcHg7c2VydmV1bnRpbGhhbmRzQ2hlY2tTcGFjZXF1ZXJ5amFtZXNlcXVhbHR3aWNlMCwwMDBTdGFydHBhbmVsc29uZ3Nyb3VuZGVpZ2h0c2hpZnR3b3J0aHBvc3RzbGVhZHN3ZWVrc2F2b2lkdGhlc2VtaWxlc3BsYW5lc21hcnRhbHBoYXBsYW50bWFya3NyYXRlc3BsYXlzY2xhaW1zYWxlc3RleHRzc3RhcnN3cm9uZzwvaDM+dGhpbmcub3JnL211bHRpaGVhcmRQb3dlcnN0YW5kdG9rZW5zb2xpZCh0aGlzYnJpbmdzaGlwc3N0YWZmdHJpZWRjYWxsc2Z1bGx5ZmFjdHNhZ2VudFRoaXMgLy8tLT5hZG1pbmVneXB0RXZlbnQxNXB4O0VtYWlsdHJ1ZSJjcm9zc3NwZW50YmxvZ3Nib3giPm5vdGVkbGVhdmVjaGluYXNpemVzZ3Vlc3Q8L2g0PnJvYm90aGVhdnl0cnVlLHNldmVuZ3JhbmRjcmltZXNpZ25zYXdhcmVkYW5jZXBoYXNlPjwhLS1lbl9VUyYjMzk7MjAwcHhfbmFtZWxhdGluZW5qb3lhamF4LmF0aW9uc21pdGhVLlMuIGhvbGRzcGV0ZXJpbmRpYW5hdiI+Y2hhaW5zY29yZWNvbWVzZG9pbmdwcmlvclNoYXJlMTk5MHNyb21hbmxpc3RzamFwYW5mYWxsc3RyaWFsb3duZXJhZ3JlZTwvaDI+YWJ1c2VhbGVydG9wZXJhIi0vL1djYXJkc2hpbGxzdGVhbXNQaG90b3RydXRoY2xlYW4ucGhwP3NhaW50bWV0YWxsb3Vpc21lYW50cHJvb2ZicmllZnJvdyI+Z2VucmV0cnVja2xvb2tzVmFsdWVGcmFtZS5uZXQvLS0+Cjx0cnkgewp2YXIgbWFrZXNjb3N0c3BsYWluYWR1bHRxdWVzdHRyYWlubGFib3JoZWxwc2NhdXNlbWFnaWNtb3RvcnRoZWlyMjUwcHhsZWFzdHN0ZXBzQ291bnRjb3VsZGdsYXNzc2lkZXNmdW5kc2hvdGVsYXdhcmRtb3V0aG1vdmVzcGFyaXNnaXZlc2R1dGNodGV4YXNmcnVpdG51bGwsfHxbXTt0b3AiPgo8IS0tUE9TVCJvY2Vhbjxici8+Zmxvb3JzcGVha2RlcHRoIHNpemViYW5rc2NhdGNoY2hhcnQyMHB4O2FsaWduZGVhbHN3b3VsZDUwcHg7dXJsPSJwYXJrc21vdXNlTW9zdCAuLi48L2Ftb25nYnJhaW5ib2R5IG5vbmU7YmFzZWRjYXJyeWRyYWZ0cmVmZXJwYWdlX2hvbWUubWV0ZXJkZWxheWRyZWFtcHJvdmVqb2ludDwvdHI+ZHJ1Z3M8IS0tIGFwcmlsaWRlYWxhbGxlbmV4YWN0Zm9ydGhjb2Rlc2xvZ2ljVmlldyBzZWVtc2JsYW5rcG9ydHMgKDIwMHNhdmVkX2xpbmtnb2Fsc2dyYW50Z3JlZWtob21lc3JpbmdzcmF0ZWQzMHB4O3dob3NlcGFyc2UoKTsiIEJsb2NrbGludXhqb25lc3BpeGVsJyk7Ij4pO2lmKC1sZWZ0ZGF2aWRob3JzZUZvY3VzcmFpc2Vib3hlc1RyYWNrZW1lbnQ8L2VtPmJhciI+LnNyYz10b3dlcmFsdD0iY2FibGVoZW5yeTI0cHg7c2V0dXBpdGFseXNoYXJwbWlub3J0YXN0ZXdhbnRzdGhpcy5yZXNldHdoZWVsZ2lybHMvY3NzLzEwMCU7Y2x1YnNzdHVmZmJpYmxldm90ZXMgMTAwMGtvcmVhfSk7DQpiYW5kc3F1ZXVlPSB7fTs4MHB4O2NraW5new0KCQlhaGVhZGNsb2NraXJpc2hsaWtlIHJhdGlvc3RhdHNGb3JtInlhaG9vKVswXTtBYm91dGZpbmRzPC9oMT5kZWJ1Z3Rhc2tzVVJMID1jZWxsc30pKCk7MTJweDtwcmltZXRlbGxzdHVybnMweDYwMC5qcGcic3BhaW5iZWFjaHRheGVzbWljcm9hbmdlbC0tPjwvZ2lmdHNzdGV2ZS1saW5rYm9keS59KTsKCW1vdW50ICgxOTlGQVE8L3JvZ2VyZnJhbmtDbGFzczI4cHg7ZmVlZHM8aDE+PHNjb3R0dGVzdHMyMnB4O2RyaW5rKSB8fCBsZXdpc3NoYWxsIzAzOTsgZm9yIGxvdmVkd2FzdGUwMHB4O2phOuOCc2ltb248Zm9udHJlcGx5bWVldHN1bnRlcmNoZWFwdGlnaHRCcmFuZCkgIT0gZHJlc3NjbGlwc3Jvb21zb25rZXltb2JpbG1haW4uTmFtZSBwbGF0ZWZ1bm55dHJlZXNjb20vIjEuanBnd21vZGVwYXJhbVNUQVJUbGVmdCBpZGRlbiwgMjAxKTsKfQpmb3JtLnZpcnVzY2hhaXJ0cmFuc3dvcnN0UGFnZXNpdGlvbnBhdGNoPCEtLQpvLWNhY2Zpcm1zdG91cnMsMDAwIGFzaWFuaSsrKXthZG9iZScpWzBdaWQ9MTBib3RoO21lbnUgLjIubWkucG5nImtldmluY29hY2hDaGlsZGJydWNlMi5qcGdVUkwpKy5qcGd8c3VpdGVzbGljZWhhcnJ5MTIwIiBzd2VldHRyPg0KbmFtZT1kaWVnb3BhZ2Ugc3dpc3MtLT4KCiNmZmY7Ij5Mb2cuY29tInRyZWF0c2hlZXQpICYmIDE0cHg7c2xlZXBudGVudGZpbGVkamE644NpZD0iY05hbWUid29yc2VzaG90cy1ib3gtZGVsdGEKJmx0O2JlYXJzOjQ4WjxkYXRhLXJ1cmFsPC9hPiBzcGVuZGJha2Vyc2hvcHM9ICIiO3BocCI+Y3Rpb24xM3B4O2JyaWFuaGVsbG9zaXplPW89JTJGIGpvaW5tYXliZTxpbWcgaW1nIj4sIGZqc2ltZyIgIilbMF1NVG9wQlR5cGUibmV3bHlEYW5za2N6ZWNodHJhaWxrbm93czwvaDU+ZmFxIj56aC1jbjEwKTsKLTEiKTt0eXBlPWJsdWVzdHJ1bHlkYXZpcy5qcyc7Pg0KPCFzdGVlbCB5b3UgaDI+DQpmb3JtIGplc3VzMTAwJSBtZW51Lg0KCQ0Kd2FsZXNyaXNrc3VtZW50ZGRpbmdiLWxpa3RlYWNoZ2lmIiB2ZWdhc2RhbnNrZWVzdGlzaHFpcHN1b21pc29icmVkZXNkZWVudHJldG9kb3NwdWVkZWHDsW9zZXN0w6F0aWVuZWhhc3Rhb3Ryb3NwYXJ0ZWRvbmRlbnVldm9oYWNlcmZvcm1hbWlzbW9tZWpvcm11bmRvYXF1w61kw61hc3PDs2xvYXl1ZGFmZWNoYXRvZGFzdGFudG9tZW5vc2RhdG9zb3RyYXNzaXRpb211Y2hvYWhvcmFsdWdhcm1heW9yZXN0b3Nob3Jhc3RlbmVyYW50ZXNmb3Rvc2VzdGFzcGHDrXNudWV2YXNhbHVkZm9yb3NtZWRpb3F1aWVubWVzZXNwb2RlcmNoaWxlc2Vyw6F2ZWNlc2RlY2lyam9zw6llc3RhcnZlbnRhZ3J1cG9oZWNob2VsbG9zdGVuZ29hbWlnb2Nvc2Fzbml2ZWxnZW50ZW1pc21hYWlyZXNqdWxpb3RlbWFzaGFjaWFmYXZvcmp1bmlvbGlicmVwdW50b2J1ZW5vYXV0b3JhYnJpbGJ1ZW5hdGV4dG9tYXJ6b3NhYmVybGlzdGFsdWVnb2PDs21vZW5lcm9qdWVnb3BlcsO6aGFiZXJlc3RveW51bmNhbXVqZXJ2YWxvcmZ1ZXJhbGlicm9ndXN0YWlndWFsdm90b3NjYXNvc2d1w61hcHVlZG9zb21vc2F2aXNvdXN0ZWRkZWJlbm5vY2hlYnVzY2FmYWx0YWV1cm9zc2VyaWVkaWNob2N1cnNvY2xhdmVjYXNhc2xlw7NucGxhem9sYXJnb29icmFzdmlzdGFhcG95b2p1bnRvdHJhdGF2aXN0b2NyZWFyY2FtcG9oZW1vc2NpbmNvY2FyZ29waXNvc29yZGVuaGFjZW7DoXJlYWRpc2NvcGVkcm9jZXJjYXB1ZWRhcGFwZWxtZW5vcsO6dGlsY2xhcm9qb3JnZWNhbGxlcG9uZXJ0YXJkZW5hZGllbWFyY2FzaWd1ZWVsbGFzc2lnbG9jb2NoZW1vdG9zbWFkcmVjbGFzZXJlc3RvbmnDsW9xdWVkYXBhc2FyYmFuY29oaWpvc3ZpYWplcGFibG/DqXN0ZXZpZW5lcmVpbm9kZWphcmZvbmRvY2FuYWxub3J0ZWxldHJhY2F1c2F0b21hcm1hbm9zbHVuZXNhdXRvc3ZpbGxhdmVuZG9wZXNhcnRpcG9zdGVuZ2FtYXJjb2xsZXZhcGFkcmV1bmlkb3ZhbW9zem9uYXNhbWJvc2JhbmRhbWFyaWFhYnVzb211Y2hhc3ViaXJyaW9qYXZpdmlyZ3JhZG9jaGljYWFsbMOtam92ZW5kaWNoYWVzdGFudGFsZXNzYWxpcnN1ZWxvcGVzb3NmaW5lc2xsYW1hYnVzY2/DqXN0YWxsZWdhbmVncm9wbGF6YWh1bW9ycGFnYXJqdW50YWRvYmxlaXNsYXNib2xzYWJhw7FvaGFibGFsdWNoYcOBcmVhZGljZW5qdWdhcm5vdGFzdmFsbGVhbGzDoWNhcmdhZG9sb3JhYmFqb2VzdMOpZ3VzdG9tZW50ZW1hcmlvZmlybWFjb3N0b2ZpY2hhcGxhdGFob2dhcmFydGVzbGV5ZXNhcXVlbG11c2VvYmFzZXNwb2Nvc21pdGFkY2llbG9jaGljb21pZWRvZ2FuYXJzYW50b2V0YXBhZGViZXNwbGF5YXJlZGVzc2lldGVjb3J0ZWNvcmVhZHVkYXNkZXNlb3ZpZWpvZGVzZWFhZ3VhcyZxdW90O2RvbWFpbmNvbW1vbnN0YXR1c2V2ZW50c21hc3RlcnN5c3RlbWFjdGlvbmJhbm5lcnJlbW92ZXNjcm9sbHVwZGF0ZWdsb2JhbG1lZGl1bWZpbHRlcm51bWJlcmNoYW5nZXJlc3VsdHB1YmxpY3NjcmVlbmNob29zZW5vcm1hbHRyYXZlbGlzc3Vlc3NvdXJjZXRhcmdldHNwcmluZ21vZHVsZW1vYmlsZXN3aXRjaHBob3Rvc2JvcmRlcnJlZ2lvbml0c2VsZnNvY2lhbGFjdGl2ZWNvbHVtbnJlY29yZGZvbGxvd3RpdGxlPmVpdGhlcmxlbmd0aGZhbWlseWZyaWVuZGxheW91dGF1dGhvcmNyZWF0ZXJldmlld3N1bW1lcnNlcnZlcnBsYXllZHBsYXllcmV4cGFuZHBvbGljeWZvcm1hdGRvdWJsZXBvaW50c3Nlcmllc3BlcnNvbmxpdmluZ2Rlc2lnbm1vbnRoc2ZvcmNlc3VuaXF1ZXdlaWdodHBlb3BsZWVuZXJneW5hdHVyZXNlYXJjaGZpZ3VyZWhhdmluZ2N1c3RvbW9mZnNldGxldHRlcndpbmRvd3N1Ym1pdHJlbmRlcmdyb3Vwc3VwbG9hZGhlYWx0aG1ldGhvZHZpZGVvc3NjaG9vbGZ1dHVyZXNoYWRvd2RlYmF0ZXZhbHVlc09iamVjdG90aGVyc3JpZ2h0c2xlYWd1ZWNocm9tZXNpbXBsZW5vdGljZXNoYXJlZGVuZGluZ3NlYXNvbnJlcG9ydG9ubGluZXNxdWFyZWJ1dHRvbmltYWdlc2VuYWJsZW1vdmluZ2xhdGVzdHdpbnRlckZyYW5jZXBlcmlvZHN0cm9uZ3JlcGVhdExvbmRvbmRldGFpbGZvcm1lZGRlbWFuZHNlY3VyZXBhc3NlZHRvZ2dsZXBsYWNlc2RldmljZXN0YXRpY2NpdGllc3N0cmVhbXllbGxvd2F0dGFja3N0cmVldGZsaWdodGhpZGRlbmluZm8iPm9wZW5lZHVzZWZ1bHZhbGxleWNhdXNlc2xlYWRlcnNlY3JldHNlY29uZGRhbWFnZXNwb3J0c2V4Y2VwdHJhdGluZ3NpZ25lZHRoaW5nc2VmZmVjdGZpZWxkc3N0YXRlc29mZmljZXZpc3VhbGVkaXRvcnZvbHVtZVJlcG9ydG11c2V1bW1vdmllc3BhcmVudGFjY2Vzc21vc3RseW1vdGhlciIgaWQ9Im1hcmtldGdyb3VuZGNoYW5jZXN1cnZleWJlZm9yZXN5bWJvbG1vbWVudHNwZWVjaG1vdGlvbmluc2lkZW1hdHRlckNlbnRlcm9iamVjdGV4aXN0c21pZGRsZUV1cm9wZWdyb3d0aGxlZ2FjeW1hbm5lcmVub3VnaGNhcmVlcmFuc3dlcm9yaWdpbnBvcnRhbGNsaWVudHNlbGVjdHJhbmRvbWNsb3NlZHRvcGljc2NvbWluZ2ZhdGhlcm9wdGlvbnNpbXBseXJhaXNlZGVzY2FwZWNob3NlbmNodXJjaGRlZmluZXJlYXNvbmNvcm5lcm91dHB1dG1lbW9yeWlmcmFtZXBvbGljZW1vZGVsc051bWJlcmR1cmluZ29mZmVyc3N0eWxlc2tpbGxlZGxpc3RlZGNhbGxlZHNpbHZlcm1hcmdpbmRlbGV0ZWJldHRlcmJyb3dzZWxpbWl0c0dsb2JhbHNpbmdsZXdpZGdldGNlbnRlcmJ1ZGdldG5vd3JhcGNyZWRpdGNsYWltc2VuZ2luZXNhZmV0eWNob2ljZXNwaXJpdC1zdHlsZXNwcmVhZG1ha2luZ25lZWRlZHJ1c3NpYXBsZWFzZWV4dGVudFNjcmlwdGJyb2tlbmFsbG93c2NoYXJnZWRpdmlkZWZhY3Rvcm1lbWJlci1iYXNlZHRoZW9yeWNvbmZpZ2Fyb3VuZHdvcmtlZGhlbHBlZENodXJjaGltcGFjdHNob3VsZGFsd2F5c2xvZ28iIGJvdHRvbWxpc3QiPil7dmFyIHByZWZpeG9yYW5nZUhlYWRlci5wdXNoKGNvdXBsZWdhcmRlbmJyaWRnZWxhdW5jaFJldmlld3Rha2luZ3Zpc2lvbmxpdHRsZWRhdGluZ0J1dHRvbmJlYXV0eXRoZW1lc2ZvcmdvdFNlYXJjaGFuY2hvcmFsbW9zdGxvYWRlZENoYW5nZXJldHVybnN0cmluZ3JlbG9hZE1vYmlsZWluY29tZXN1cHBseVNvdXJjZW9yZGVyc3ZpZXdlZCZuYnNwO2NvdXJzZUFib3V0IGlzbGFuZDxodG1sIGNvb2tpZW5hbWU9ImFtYXpvbm1vZGVybmFkdmljZWluPC9hPjogVGhlIGRpYWxvZ2hvdXNlc0JFR0lOIE1leGljb3N0YXJ0c2NlbnRyZWhlaWdodGFkZGluZ0lzbGFuZGFzc2V0c0VtcGlyZVNjaG9vbGVmZm9ydGRpcmVjdG5lYXJseW1hbnVhbFNlbGVjdC4KCk9uZWpvaW5lZG1lbnUiPlBoaWxpcGF3YXJkc2hhbmRsZWltcG9ydE9mZmljZXJlZ2FyZHNraWxsc25hdGlvblNwb3J0c2RlZ3JlZXdlZWtseSAoZS5nLmJlaGluZGRvY3RvcmxvZ2dlZHVuaXRlZDwvYj48L2JlZ2luc3BsYW50c2Fzc2lzdGFydGlzdGlzc3VlZDMwMHB4fGNhbmFkYWFnZW5jeXNjaGVtZXJlbWFpbkJyYXppbHNhbXBsZWxvZ28iPmJleW9uZC1zY2FsZWFjY2VwdHNlcnZlZG1hcmluZUZvb3RlcmNhbWVyYTwvaDE+Cl9mb3JtImxlYXZlc3N0cmVzcyIgLz4NCi5naWYiIG9ubG9hZGxvYWRlck94Zm9yZHNpc3RlcnN1cnZpdmxpc3RlbmZlbWFsZURlc2lnbnNpemU9ImFwcGVhbHRleHQiPmxldmVsc3RoYW5rc2hpZ2hlcmZvcmNlZGFuaW1hbGFueW9uZUFmcmljYWFncmVlZHJlY2VudFBlb3BsZTxiciAvPndvbmRlcnByaWNlc3R1cm5lZHx8IHt9O21haW4iPmlubGluZXN1bmRheXdyYXAiPmZhaWxlZGNlbnN1c21pbnV0ZWJlYWNvbnF1b3RlczE1MHB4fGVzdGF0ZXJlbW90ZWVtYWlsImxpbmtlZHJpZ2h0O3NpZ25hbGZvcm1hbDEuaHRtbHNpZ251cHByaW5jZWZsb2F0Oi5wbmciIGZvcnVtLkFjY2Vzc3BhcGVyc3NvdW5kc2V4dGVuZEhlaWdodHNsaWRlclVURi04IiZhbXA7IEJlZm9yZS4gV2l0aHN0dWRpb293bmVyc21hbmFnZXByb2ZpdGpRdWVyeWFubnVhbHBhcmFtc2JvdWdodGZhbW91c2dvb2dsZWxvbmdlcmkrKykge2lzcmFlbHNheWluZ2RlY2lkZWhvbWUiPmhlYWRlcmVuc3VyZWJyYW5jaHBpZWNlc2Jsb2NrO3N0YXRlZHRvcCI+PHJhY2luZ3Jlc2l6ZS0tJmd0O3BhY2l0eXNleHVhbGJ1cmVhdS5qcGciIDEwLDAwMG9idGFpbnRpdGxlc2Ftb3VudCwgSW5jLmNvbWVkeW1lbnUiIGx5cmljc3RvZGF5LmluZGVlZGNvdW50eV9sb2dvLkZhbWlseWxvb2tlZE1hcmtldGxzZSBpZlBsYXllcnR1cmtleSk7dmFyIGZvcmVzdGdpdmluZ2Vycm9yc0RvbWFpbn1lbHNle2luc2VydEJsb2c8L2Zvb3RlcmxvZ2luLmZhc3RlcmFnZW50czxib2R5IDEwcHggMHByYWdtYWZyaWRheWp1bmlvcmRvbGxhcnBsYWNlZGNvdmVyc3BsdWdpbjUsMDAwIHBhZ2UiPmJvc3Rvbi50ZXN0KGF2YXRhcnRlc3RlZF9jb3VudGZvcnVtc3NjaGVtYWluZGV4LGZpbGxlZHNoYXJlc3JlYWRlcmFsZXJ0KGFwcGVhclN1Ym1pdGxpbmUiPmJvZHkiPgoqIFRoZVRob3VnaHNlZWluZ2plcnNleU5ld3M8L3ZlcmlmeWV4cGVydGluanVyeXdpZHRoPUNvb2tpZVNUQVJUIGFjcm9zc19pbWFnZXRocmVhZG5hdGl2ZXBvY2tldGJveCI+ClN5c3RlbSBEYXZpZGNhbmNlcnRhYmxlc3Byb3ZlZEFwcmlsIHJlYWxseWRyaXZlcml0ZW0iPm1vcmUiPmJvYXJkc2NvbG9yc2NhbXB1c2ZpcnN0IHx8IFtdO21lZGlhLmd1aXRhcmZpbmlzaHdpZHRoOnNob3dlZE90aGVyIC5waHAiIGFzc3VtZWxheWVyc3dpbHNvbnN0b3Jlc3JlbGllZnN3ZWRlbkN1c3RvbWVhc2lseSB5b3VyIFN0cmluZwoKV2hpbHRheWxvcmNsZWFyOnJlc29ydGZyZW5jaHRob3VnaCIpICsgIjxib2R5PmJ1eWluZ2JyYW5kc01lbWJlcm5hbWUiPm9wcGluZ3NlY3RvcjVweDsiPnZzcGFjZXBvc3Rlcm1ham9yIGNvZmZlZW1hcnRpbm1hdHVyZWhhcHBlbjwvbmF2PmthbnNhc2xpbmsiPkltYWdlcz1mYWxzZXdoaWxlIGhzcGFjZTAmYW1wOyAKCkluICBwb3dlclBvbHNraS1jb2xvcmpvcmRhbkJvdHRvbVN0YXJ0IC1jb3VudDIuaHRtbG5ld3MiPjAxLmpwZ09ubGluZS1yaWdodG1pbGxlcnNlbmlvcklTQk4gMDAsMDAwIGd1aWRlc3ZhbHVlKWVjdGlvbnJlcGFpci54bWwiICByaWdodHMuaHRtbC1ibG9ja3JlZ0V4cDpob3ZlcndpdGhpbnZpcmdpbnBob25lczwvdHI+DXVzaW5nIAoJdmFyID4nKTsKCTwvdGQ+CjwvdHI+CmJhaGFzYWJyYXNpbGdhbGVnb21hZ3lhcnBvbHNraXNycHNradix2K/ZiOS4reaWh+eugOS9k+e5gemrlOS/oeaBr+S4reWbveaIkeS7rOS4gOS4quWFrOWPuOeuoeeQhuiuuuWdm+WPr+S7peacjeWKoeaXtumXtOS4quS6uuS6p+WTgeiHquW3seS8geS4muafpeeci+W3peS9nOiBlOezu+ayoeaciee9keermeaJgOacieivhOiuuuS4reW/g+aWh+eroOeUqOaIt+mmlumhteS9nOiAheaKgOacr+mXrumimOebuOWFs+S4i+i9veaQnOe0ouS9v+eUqOi9r+S7tuWcqOe6v+S4u+mimOi1hOaWmeinhumikeWbnuWkjeazqOWGjOe9kee7nOaUtuiXj+WGheWuueaOqOiNkOW4guWcuua2iOaBr+epuumXtOWPkeW4g+S7gOS5iOWlveWPi+eUn+a0u+WbvueJh+WPkeWxleWmguaenOaJi+acuuaWsOmXu+acgOaWsOaWueW8j+WMl+S6rOaPkOS+m+WFs+S6juabtOWkmui/meS4quezu+e7n+efpemBk+a4uOaIj+W5v+WRiuWFtuS7luWPkeihqOWuieWFqOesrOS4gOS8muWRmOi/m+ihjOeCueWHu+eJiOadg+eUteWtkOS4lueVjOiuvuiuoeWFjei0ueaVmeiCsuWKoOWFpea0u+WKqOS7luS7rOWVhuWTgeWNmuWuoueOsOWcqOS4iua1t+WmguS9leW3sue7j+eVmeiogOivpue7huekvuWMuueZu+W9leacrOermemcgOimgeS7t+agvOaUr+aMgeWbvemZhemTvuaOpeWbveWutuW7uuiuvuaci+WPi+mYheivu+azleW+i+S9jee9rue7j+a1jumAieaLqei/meagt+W9k+WJjeWIhuexu+aOkuihjOWboOS4uuS6pOaYk+acgOWQjumfs+S5kOS4jeiDvemAmui/h+ihjOS4muenkeaKgOWPr+iDveiuvuWkh+WQiOS9nOWkp+WutuekvuS8mueglOeptuS4k+S4muWFqOmDqOmhueebrui/memHjOi/mOaYr+W8gOWni+aDheWGteeUteiEkeaWh+S7tuWTgeeJjOW4ruWKqeaWh+WMlui1hOa6kOWkp+WtpuWtpuS5oOWcsOWdgOa1j+iniOaKlei1hOW3peeoi+imgeaxguaAjuS5iOaXtuWAmeWKn+iDveS4u+imgeebruWJjei1hOiur+WfjuW4guaWueazleeUteW9seaLm+iBmOWjsOaYjuS7u+S9leWBpeW6t+aVsOaNrue+juWbveaxvei9puS7i+e7jeS9huaYr+S6pOa1geeUn+S6p+aJgOS7peeUteivneaYvuekuuS4gOS6m+WNleS9jeS6uuWRmOWIhuaekOWcsOWbvuaXhea4uOW3peWFt+WtpueUn+ezu+WIl+e9keWPi+W4luWtkOWvhueggemikemBk+aOp+WItuWcsOWMuuWfuuacrOWFqOWbvee9keS4iumHjeimgeesrOS6jOWWnOasoui/m+WFpeWPi+aDhei/meS6m+iAg+ivleWPkeeOsOWfueiureS7peS4iuaUv+W6nOaIkOS4uueOr+Wig+mmmea4r+WQjOaXtuWoseS5kOWPkemAgeS4gOWumuW8gOWPkeS9nOWTgeagh+WHhuasoui/juino+WGs+WcsOaWueS4gOS4i+S7peWPiui0o+S7u+aIluiAheWuouaIt+S7o+ihqOenr+WIhuWls+S6uuaVsOeggemUgOWUruWHuueOsOemu+e6v+W6lOeUqOWIl+ihqOS4jeWQjOe8lui+kee7n+iuoeafpeivouS4jeimgeacieWFs+acuuaehOW+iOWkmuaSreaUvue7hOe7h+aUv+etluebtOaOpeiDveWKm+adpea6kOaZgumWk+eci+WIsOeDremXqOWFs+mUruS4k+WMuumdnuW4uOiLseivreeZvuW6puW4jOacm+e+juWls+avlOi+g+efpeivhuinhOWumuW7uuiurumDqOmXqOaEj+ingeeyvuW9qeaXpeacrOaPkOmrmOWPkeiogOaWuemdouWfuumHkeWkhOeQhuadg+mZkOW9seeJh+mTtuihjOi/mOacieWIhuS6q+eJqeWTgee7j+iQpea3u+WKoOS4k+Wutui/meenjeivnemimOi1t+adpeS4muWKoeWFrOWRiuiusOW9leeugOS7i+i0qOmHj+eUt+S6uuW9seWTjeW8leeUqOaKpeWRiumDqOWIhuW/q+mAn+WSqOivouaXtuWwmuazqOaEj+eUs+ivt+WtpuagoeW6lOivpeWOhuWPsuWPquaYr+i/lOWbnui0reS5sOWQjeensOS4uuS6huaIkOWKn+ivtOaYjuS+m+W6lOWtqeWtkOS4k+mimOeoi+W6j+S4gOiIrOacg+WToeWPquacieWFtuWug+S/neaKpOiAjOS4lOS7iuWkqeeql+WPo+WKqOaAgeeKtuaAgeeJueWIq+iupOS4uuW/hemhu+abtOaWsOWwj+ivtOaIkeWAkeS9nOS4uuWqkuS9k+WMheaLrOmCo+S5iOS4gOagt+WbveWGheaYr+WQpuagueaNrueUteinhuWtpumZouWFt+aciei/h+eoi+eUseS6juS6uuaJjeWHuuadpeS4jei/h+ato+WcqOaYjuaYn+aVheS6i+WFs+ezu+agh+mimOWVhuWKoei+k+WFpeS4gOebtOWfuuehgOaVmeWtpuS6huino+W7uuetkee7k+aenOWFqOeQg+mAmuefpeiuoeWIkuWvueS6juiJuuacr+ebuOWGjOWPkeeUn+ecn+eahOW7uueri+etiee6p+exu+Wei+e7j+mqjOWunueOsOWItuS9nOadpeiHquagh+etvuS7peS4i+WOn+WIm+aXoOazleWFtuS4reWAi+S6uuS4gOWIh+aMh+WNl+WFs+mXrembhuWbouesrOS4ieWFs+azqOWboOatpOeFp+eJh+a3seWcs+WVhuS4muW5v+W3nuaXpeacn+mrmOe6p+acgOi/kee7vOWQiOihqOekuuS4k+i+keihjOS4uuS6pOmAmuivhOS7t+inieW+l+eyvuWNjuWutuW6reWujOaIkOaEn+inieWuieijheW+l+WIsOmCruS7tuWItuW6pumjn+WTgeiZveeEtui9rOi9veaKpeS7t+iusOiAheaWueahiOihjOaUv+S6uuawkeeUqOWTgeS4nOilv+aPkOWHuumFkuW6l+eEtuWQjuS7mOasvueDreeCueS7peWJjeWujOWFqOWPkeW4luiuvue9rumihuWvvOW3peS4muWMu+mZoueci+eci+e7j+WFuOWOn+WboOW5s+WPsOWQhOenjeWinuWKoOadkOaWmeaWsOWinuS5i+WQjuiBjOS4muaViOaenOS7iuW5tOiuuuaWh+aIkeWbveWRiuivieeJiOS4u+S/ruaUueWPguS4juaJk+WNsOW/q+S5kOacuuaisOingueCueWtmOWcqOeyvuelnuiOt+W+l+WIqeeUqOe7p+e7reS9oOS7rOi/meS5iOaooeW8j+ivreiogOiDveWkn+mbheiZjuaTjeS9nOmjjuagvOS4gOi1t+enkeWtpuS9k+iCsuefreS/oeadoeS7tuayu+eWl+i/kOWKqOS6p+S4muS8muiuruWvvOiIquWFiOeUn+iBlOebn+WPr+aYr+WVj+mhjOe7k+aehOS9nOeUqOiwg+afpeizh+aWmeiHquWKqOi0n+i0o+WGnOS4muiuv+mXruWunuaWveaOpeWPl+iuqOiuuumCo+S4quWPjemmiOWKoOW8uuWls+aAp+iMg+WbtOacjeWLmeS8kemXsuS7iuaXpeWuouacjeingOeci+WPguWKoOeahOivneS4gOeCueS/neivgeWbvuS5puacieaViOa1i+ivleenu+WKqOaJjeiDveWGs+WumuiCoeelqOS4jeaWremcgOaxguS4jeW+l+WKnuazleS5i+mXtOmHh+eUqOiQpemUgOaKleivieebruagh+eIseaDheaRhOW9seacieS6m+ikh+ijveaWh+WtpuacuuS8muaVsOWtl+ijheS/rui0reeJqeWGnOadkeWFqOmdoueyvuWTgeWFtuWunuS6i+aDheawtOW5s+aPkOekuuS4iuW4guiwouiwouaZrumAmuaVmeW4iOS4iuS8oOexu+WIq+atjOabsuaLpeacieWIm+aWsOmFjeS7tuWPquimgeaXtuS7o+izh+ioiui+vuWIsOS6uueUn+iuoumYheiAgeW4iOWxleekuuW/g+eQhui0tOWtkOe2suermeS4u+mhjOiHqueEtue6p+WIq+eugOWNleaUuemdqemCo+S6m+adpeivtOaJk+W8gOS7o+eggeWIoOmZpOivgeWIuOiKguebrumHjeeCueasoeaVuOWkmuWwkeinhOWIkui1hOmHkeaJvuWIsOS7peWQjuWkp+WFqOS4u+mhteacgOS9s+WbnuetlOWkqeS4i+S/nemanOeOsOS7o+ajgOafpeaKleelqOWwj+aXtuaykuacieato+W4uOeUmuiHs+S7o+eQhuebruW9leWFrOW8gOWkjeWItumHkeiejeW5uOemj+eJiOacrOW9ouaIkOWHhuWkh+ihjOaDheWbnuWIsOaAneaDs+aAjuagt+WNj+iuruiupOivgeacgOWlveS6p+eUn+aMieeFp+acjeijheW5v+S4nOWKqOa8q+mHh+i0reaWsOaJi+e7hOWbvumdouadv+WPguiAg+aUv+ayu+WuueaYk+WkqeWcsOWKquWKm+S6uuS7rOWNh+e6p+mAn+W6puS6uueJqeiwg+aVtOa1geihjOmAoOaIkOaWh+Wtl+mfqeWbvei0uOaYk+W8gOWxleebuOmXnOihqOeOsOW9seinhuWmguatpOe+juWuueWkp+Wwj+aKpemBk+adoeasvuW/g+aDheiuuOWkmuazleinhOWutuWxheS5puW6l+i/nuaOpeeri+WNs+S4vuaKpeaKgOW3p+Wlpei/kOeZu+WFpeS7peadpeeQhuiuuuS6i+S7tuiHqueUseS4reWNjuWKnuWFrOWmiOWmiOecn+ato+S4jemUmeWFqOaWh+WQiOWQjOS7t+WAvOWIq+S6uuebkeedo+WFt+S9k+S4lue6quWboumYn+WIm+S4muaJv+aLheWinumVv+acieS6uuS/neaMgeWVhuWutue7tOS/ruWPsOa5vuW3puWPs+iCoeS7veetlOahiOWunumZheeUteS/oee7j+eQhueUn+WRveWuo+S8oOS7u+WKoeato+W8j+eJueiJsuS4i+adpeWNj+S8muWPquiDveW9k+eEtumHjeaWsOWFp+WuueaMh+WvvOi/kOihjOaXpeW/l+izo+Wutui2hei/h+Wcn+WcsOa1meaxn+aUr+S7mOaOqOWHuuermemVv+adreW3nuaJp+ihjOWItumAoOS5i+S4gOaOqOW5v+eOsOWcuuaPj+i/sOWPmOWMluS8oOe7n+atjOaJi+S/nemZqeivvueoi+WMu+eWl+e7j+i/h+i/h+WOu+S5i+WJjeaUtuWFpeW5tOW6puadguW/l+e+juS4veacgOmrmOeZu+mZhuacquadpeWKoOW3peWFjei0o+aVmeeoi+eJiOWdl+i6q+S9k+mHjeW6huWHuuWUruaIkOacrOW9ouW8j+Wcn+ixhuWHuuWDueS4nOaWuemCrueuseWNl+S6rOaxguiBjOWPluW+l+iBjOS9jeebuOS/oemhtemdouWIhumSn+e9kemhteehruWumuWbvuS+i+e9keWdgOenr+aegemUmeivr+ebrueahOWunei0neacuuWFs+mjjumZqeaOiOadg+eXheavkuWuoOeJqemZpOS6huipleirlueWvueXheWPiuaXtuaxgui0reermeeCueWEv+erpeavj+WkqeS4reWkruiupOivhuavj+S4quWkqea0peWtl+S9k+WPsOeBo+e7tOaKpOacrOmhteS4quaAp+WumOaWueW4uOingeebuOacuuaImOeVpeW6lOW9k+W+i+W4iOaWueS+v+agoeWbreiCoeW4guaIv+Wxi+agj+ebruWRmOW3peWvvOiHtOeqgeeEtumBk+WFt+acrOe9kee7k+WQiOaho+ahiOWKs+WKqOWPpuWklue+juWFg+W8lei1t+aUueWPmOesrOWbm+S8muiuoeiqquaYjumakOengeWuneWuneinhOiMg+a2iOi0ueWFseWQjOW/mOiusOS9k+ezu+W4puadpeWQjeWtl+eZvOihqOW8gOaUvuWKoOebn+WPl+WIsOS6jOaJi+Wkp+mHj+aIkOS6uuaVsOmHj+WFseS6q+WMuuWfn+Wls+WtqeWOn+WImeaJgOWcqOe7k+adn+mAmuS/oei2hee6p+mFjee9ruW9k+aXtuS8mOengOaAp+aEn+aIv+S6p+mBiuaIsuWHuuWPo+aPkOS6pOWwseS4muS/neWBpeeoi+W6puWPguaVsOS6i+S4muaVtOS4quWxseS4nOaDheaEn+eJueauiuWIhumhnuaQnOWwi+WxnuS6jumXqOaIt+i0ouWKoeWjsOmfs+WPiuWFtui0oue7j+WdmuaMgeW5sumDqOaIkOeri+WIqeebiuiAg+iZkeaIkOmDveWMheijheeUqOaItuavlOi1m+aWh+aYjuaLm+WVhuWujOaVtOecn+aYr+ecvOedm+S8meS8tOWogeacm+mihuWfn+WNq+eUn+S8mOaDoOirluWjh+WFrOWFseiJr+WlveWFheWIhuespuWQiOmZhOS7tueJueeCueS4jeWPr+iLseaWh+i1hOS6p+agueacrOaYjuaYvuWvhueivOWFrOS8l+awkeaXj+abtOWKoOS6q+WPl+WQjOWtpuWQr+WKqOmAguWQiOWOn+adpemXruetlOacrOaWh+e+jumjn+e7v+iJsueos+Wumue7iOS6jueUn+eJqeS+m+axguaQnOeLkOWKm+mHj+S4pemHjeawuOi/nOWGmeecn+aciemZkOernuS6ieWvueixoei0ueeUqOS4jeWlvee7neWvueWNgeWIhuS/g+i/m+eCueivhOW9semfs+S8mOWKv+S4jeWwkeaso+i1j+W5tuS4lOacieeCueaWueWQkeWFqOaWsOS/oeeUqOiuvuaWveW9ouixoei1hOagvOeqgeegtOmaj+edgOmHjeWkp+S6juaYr+avleS4muaZuuiDveWMluW3peWujOe+juWVhuWfjue7n+S4gOWHuueJiOaJk+mAoOeUouWTgeamguWGteeUqOS6juS/neeVmeWboOe0oOS4reWci+WtmOWCqOi0tOWbvuacgOaEm+mVv+acn+WPo+S7t+eQhui0ouWfuuWcsOWuieaOkuatpuaxiemHjOmdouWIm+W7uuWkqeepuummluWFiOWujOWWhOmpseWKqOS4i+mdouS4jeWGjeivmuS/oeaEj+S5iemYs+WFieiLseWbvea8guS6ruWGm+S6i+eOqeWutue+pOS8l+WGnOawkeWNs+WPr+WQjeeoseWutuWFt+WKqOeUu+aDs+WIsOazqOaYjuWwj+WtpuaAp+iDveiAg+eglOehrOS7tuingueci+a4healmuaQnueskemmlumggem7hOmHkemAgueUqOaxn+iLj+ecn+WunuS4u+euoemYtuauteiou+WGiue/u+ivkeadg+WIqeWBmuWlveS8vOS5jumAmuiur+aWveW3peeLgOaFi+S5n+iuuOeOr+S/neWfueWFu+amguW/teWkp+Wei+acuuelqOeQhuino+WMv+WQjWN1YW5kb2Vudmlhcm1hZHJpZGJ1c2NhcmluaWNpb3RpZW1wb3BvcnF1ZWN1ZW50YWVzdGFkb3B1ZWRlbmp1ZWdvc2NvbnRyYWVzdMOhbm5vbWJyZXRpZW5lbnBlcmZpbG1hbmVyYWFtaWdvc2NpdWRhZGNlbnRyb2F1bnF1ZXB1ZWRlc2RlbnRyb3ByaW1lcnByZWNpb3NlZ8O6bmJ1ZW5vc3ZvbHZlcnB1bnRvc3NlbWFuYWhhYsOtYWFnb3N0b251ZXZvc3VuaWRvc2Nhcmxvc2VxdWlwb25pw7Fvc211Y2hvc2FsZ3VuYWNvcnJlb2ltYWdlbnBhcnRpcmFycmliYW1hcsOtYWhvbWJyZWVtcGxlb3ZlcmRhZGNhbWJpb211Y2hhc2Z1ZXJvbnBhc2Fkb2zDrW5lYXBhcmVjZW51ZXZhc2N1cnNvc2VzdGFiYXF1aWVyb2xpYnJvc2N1YW50b2FjY2Vzb21pZ3VlbHZhcmlvc2N1YXRyb3RpZW5lc2dydXBvc3NlcsOhbmV1cm9wYW1lZGlvc2ZyZW50ZWFjZXJjYWRlbcOhc29mZXJ0YWNvY2hlc21vZGVsb2l0YWxpYWxldHJhc2FsZ8O6bmNvbXByYWN1YWxlc2V4aXN0ZWN1ZXJwb3NpZW5kb3ByZW5zYWxsZWdhcnZpYWplc2RpbmVyb211cmNpYXBvZHLDoXB1ZXN0b2RpYXJpb3B1ZWJsb3F1aWVyZW1hbnVlbHByb3Bpb2NyaXNpc2NpZXJ0b3NlZ3Vyb211ZXJ0ZWZ1ZW50ZWNlcnJhcmdyYW5kZWVmZWN0b3BhcnRlc21lZGlkYXByb3BpYW9mcmVjZXRpZXJyYWUtbWFpbHZhcmlhc2Zvcm1hc2Z1dHVyb29iamV0b3NlZ3VpcnJpZXNnb25vcm1hc21pc21vc8O6bmljb2NhbWlub3NpdGlvc3JhesOzbmRlYmlkb3BydWViYXRvbGVkb3RlbsOtYWplc8O6c2VzcGVyb2NvY2luYW9yaWdlbnRpZW5kYWNpZW50b2PDoWRpemhhYmxhcnNlcsOtYWxhdGluYWZ1ZXJ6YWVzdGlsb2d1ZXJyYWVudHJhcsOpeGl0b2zDs3BlemFnZW5kYXbDrWRlb2V2aXRhcnBhZ2luYW1ldHJvc2phdmllcnBhZHJlc2bDoWNpbGNhYmV6YcOhcmVhc3NhbGlkYWVudsOtb2phcMOzbmFidXNvc2JpZW5lc3RleHRvc2xsZXZhcnB1ZWRhbmZ1ZXJ0ZWNvbcO6bmNsYXNlc2h1bWFub3Rlbmlkb2JpbGJhb3VuaWRhZGVzdMOhc2VkaXRhcmNyZWFkb9C00LvRj9GH0YLQvtC60LDQutC40LvQuNGN0YLQvtCy0YHQtdC10LPQvtC/0YDQuNGC0LDQutC10YnQtdGD0LbQtdCa0LDQutCx0LXQt9Cx0YvQu9C+0L3QuNCS0YHQtdC/0L7QtNCt0YLQvtGC0L7QvNGH0LXQvNC90LXRgtC70LXRgtGA0LDQt9C+0L3QsNCz0LTQtdC80L3QtdCU0LvRj9Cf0YDQuNC90LDRgdC90LjRhdGC0LXQvNC60YLQvtCz0L7QtNCy0L7RgtGC0LDQvNCh0KjQkNC80LDRj9Cn0YLQvtCy0LDRgdCy0LDQvNC10LzRg9Ci0LDQutC00LLQsNC90LDQvNGN0YLQuNGN0YLRg9CS0LDQvNGC0LXRhdC/0YDQvtGC0YPRgtC90LDQtNC00L3Rj9CS0L7RgtGC0YDQuNC90LXQudCS0LDRgdC90LjQvNGB0LDQvNGC0L7RgtGA0YPQsdCe0L3QuNC80LjRgNC90LXQtdCe0J7QntC70LjRhtGN0YLQsNCe0L3QsNC90LXQvNC00L7QvNC80L7QudC00LLQtdC+0L3QvtGB0YPQtOCkleClh+CkueCliOCkleClgOCkuOClh+CkleCkvuCkleCli+CklOCksOCkquCksOCkqOClh+Ckj+CkleCkleCkv+CkreClgOCkh+CkuOCkleCksOCkpOCli+CkueCli+CkhuCkquCkueClgOCkr+CkueCkr+CkvuCkpOCkleCkpeCkvmphZ3JhbuCkhuCknOCknOCli+CkheCkrOCkpuCli+Ckl+CkiOCknOCkvuCkl+Ckj+CkueCkruCkh+CkqOCkteCkueCkr+Clh+CkpeClh+CkpeClgOCkmOCksOCknOCkrOCkpuClgOCkleCkiOCknOClgOCkteClh+CkqOCkiOCkqOCkj+CkueCksOCkieCkuOCkruClh+CkleCkruCkteCli+CksuClh+CkuOCkrOCkruCkiOCkpuClh+Ckk+CksOCkhuCkruCkrOCkuOCkreCksOCkrOCkqOCkmuCksuCkruCkqOCkhuCkl+CkuOClgOCksuClgNi52YTZidil2YTZidmH2LDYp9ii2K7Ysdi52K/Yr9in2YTZidmH2LDZh9i12YjYsdi62YrYsdmD2KfZhtmI2YTYp9io2YrZhti52LHYttiw2YTZg9mH2YbYp9mK2YjZhdmC2KfZhNi52YTZitin2YbYp9mE2YPZhtit2KrZidmC2KjZhNmI2K3Yqdin2K7YsdmB2YLYt9i52KjYr9ix2YPZhtil2LDYp9mD2YXYp9in2K3Yr9il2YTYp9mB2YrZh9io2LnYttmD2YrZgdio2K3Yq9mI2YXZhtmI2YfZiNij2YbYp9is2K/Yp9mE2YfYp9iz2YTZhdi52YbYr9mE2YrYs9i52KjYsdi12YTZidmF2YbYsNio2YfYp9ij2YbZh9mF2KvZhNmD2YbYqtin2YTYp9it2YrYq9mF2LXYsdi02LHYrdit2YjZhNmI2YHZitin2LDYp9mE2YPZhNmF2LHYqdin2YbYqtin2YTZgdij2KjZiNiu2KfYtdij2YbYqtin2YbZh9in2YTZiti52LbZiNmI2YLYr9in2KjZhtiu2YrYsdio2YbYqtmE2YPZhdi02KfYodmI2YfZitin2KjZiNmC2LXYtdmI2YXYp9ix2YLZhdij2K3Yr9mG2K3Zhti52K/Zhdix2KPZitin2K3YqdmD2KrYqNiv2YjZhtmK2KzYqNmF2YbZh9iq2K3Yqtis2YfYqdiz2YbYqdmK2KrZhdmD2LHYqdi62LLYqdmG2YHYs9io2YrYqtmE2YTZh9mE2YbYp9iq2YTZg9mC2YTYqNmE2YXYp9i52YbZh9ij2YjZhNi02YrYodmG2YjYsdij2YXYp9mB2YrZg9io2YPZhNiw2KfYqtix2KrYqNio2KPZhtmH2YXYs9in2YbZg9io2YrYudmB2YLYr9it2LPZhtmE2YfZhdi02LnYsdij2YfZhNi02YfYsdmC2LfYsdi32YTYqHByb2ZpbGVzZXJ2aWNlZGVmYXVsdGhpbXNlbGZkZXRhaWxzY29udGVudHN1cHBvcnRzdGFydGVkbWVzc2FnZXN1Y2Nlc3NmYXNoaW9uPHRpdGxlPmNvdW50cnlhY2NvdW50Y3JlYXRlZHN0b3JpZXNyZXN1bHRzcnVubmluZ3Byb2Nlc3N3cml0aW5nb2JqZWN0c3Zpc2libGV3ZWxjb21lYXJ0aWNsZXVua25vd25uZXR3b3JrY29tcGFueWR5bmFtaWNicm93c2VycHJpdmFjeXByb2JsZW1TZXJ2aWNlcmVzcGVjdGRpc3BsYXlyZXF1ZXN0cmVzZXJ2ZXdlYnNpdGVoaXN0b3J5ZnJpZW5kc29wdGlvbnN3b3JraW5ndmVyc2lvbm1pbGxpb25jaGFubmVsd2luZG93LmFkZHJlc3N2aXNpdGVkd2VhdGhlcmNvcnJlY3Rwcm9kdWN0ZWRpcmVjdGZvcndhcmR5b3UgY2FucmVtb3ZlZHN1YmplY3Rjb250cm9sYXJjaGl2ZWN1cnJlbnRyZWFkaW5nbGlicmFyeWxpbWl0ZWRtYW5hZ2VyZnVydGhlcnN1bW1hcnltYWNoaW5lbWludXRlc3ByaXZhdGVjb250ZXh0cHJvZ3JhbXNvY2lldHludW1iZXJzd3JpdHRlbmVuYWJsZWR0cmlnZ2Vyc291cmNlc2xvYWRpbmdlbGVtZW50cGFydG5lcmZpbmFsbHlwZXJmZWN0bWVhbmluZ3N5c3RlbXNrZWVwaW5nY3VsdHVyZSZxdW90Oyxqb3VybmFscHJvamVjdHN1cmZhY2VzJnF1b3Q7ZXhwaXJlc3Jldmlld3NiYWxhbmNlRW5nbGlzaENvbnRlbnR0aHJvdWdoUGxlYXNlIG9waW5pb25jb250YWN0YXZlcmFnZXByaW1hcnl2aWxsYWdlU3BhbmlzaGdhbGxlcnlkZWNsaW5lbWVldGluZ21pc3Npb25wb3B1bGFycXVhbGl0eW1lYXN1cmVnZW5lcmFsc3BlY2llc3Nlc3Npb25zZWN0aW9ud3JpdGVyc2NvdW50ZXJpbml0aWFscmVwb3J0c2ZpZ3VyZXNtZW1iZXJzaG9sZGluZ2Rpc3B1dGVlYXJsaWVyZXhwcmVzc2RpZ2l0YWxwaWN0dXJlQW5vdGhlcm1hcnJpZWR0cmFmZmljbGVhZGluZ2NoYW5nZWRjZW50cmFsdmljdG9yeWltYWdlcy9yZWFzb25zc3R1ZGllc2ZlYXR1cmVsaXN0aW5nbXVzdCBiZXNjaG9vbHNWZXJzaW9udXN1YWxseWVwaXNvZGVwbGF5aW5nZ3Jvd2luZ29idmlvdXNvdmVybGF5cHJlc2VudGFjdGlvbnM8L3VsPg0Kd3JhcHBlcmFscmVhZHljZXJ0YWlucmVhbGl0eXN0b3JhZ2Vhbm90aGVyZGVza3RvcG9mZmVyZWRwYXR0ZXJudW51c3VhbERpZ2l0YWxjYXBpdGFsV2Vic2l0ZWZhaWx1cmVjb25uZWN0cmVkdWNlZEFuZHJvaWRkZWNhZGVzcmVndWxhciAmYW1wOyBhbmltYWxzcmVsZWFzZUF1dG9tYXRnZXR0aW5nbWV0aG9kc25vdGhpbmdQb3B1bGFyY2FwdGlvbmxldHRlcnNjYXB0dXJlc2NpZW5jZWxpY2Vuc2VjaGFuZ2VzRW5nbGFuZD0xJmFtcDtIaXN0b3J5ID0gbmV3IENlbnRyYWx1cGRhdGVkU3BlY2lhbE5ldHdvcmtyZXF1aXJlY29tbWVudHdhcm5pbmdDb2xsZWdldG9vbGJhcnJlbWFpbnNiZWNhdXNlZWxlY3RlZERldXRzY2hmaW5hbmNld29ya2Vyc3F1aWNrbHliZXR3ZWVuZXhhY3RseXNldHRpbmdkaXNlYXNlU29jaWV0eXdlYXBvbnNleGhpYml0Jmx0OyEtLUNvbnRyb2xjbGFzc2VzY292ZXJlZG91dGxpbmVhdHRhY2tzZGV2aWNlcyh3aW5kb3dwdXJwb3NldGl0bGU9Ik1vYmlsZSBraWxsaW5nc2hvd2luZ0l0YWxpYW5kcm9wcGVkaGVhdmlseWVmZmVjdHMtMSddKTsKY29uZmlybUN1cnJlbnRhZHZhbmNlc2hhcmluZ29wZW5pbmdkcmF3aW5nYmlsbGlvbm9yZGVyZWRHZXJtYW55cmVsYXRlZDwvZm9ybT5pbmNsdWRld2hldGhlcmRlZmluZWRTY2llbmNlY2F0YWxvZ0FydGljbGVidXR0b25zbGFyZ2VzdHVuaWZvcm1qb3VybmV5c2lkZWJhckNoaWNhZ29ob2xpZGF5R2VuZXJhbHBhc3NhZ2UsJnF1b3Q7YW5pbWF0ZWZlZWxpbmdhcnJpdmVkcGFzc2luZ25hdHVyYWxyb3VnaGx5LgoKVGhlIGJ1dCBub3RkZW5zaXR5QnJpdGFpbkNoaW5lc2VsYWNrIG9mdHJpYnV0ZUlyZWxhbmQiIGRhdGEtZmFjdG9yc3JlY2VpdmV0aGF0IGlzTGlicmFyeWh1c2JhbmRpbiBmYWN0YWZmYWlyc0NoYXJsZXNyYWRpY2FsYnJvdWdodGZpbmRpbmdsYW5kaW5nOmxhbmc9InJldHVybiBsZWFkZXJzcGxhbm5lZHByZW1pdW1wYWNrYWdlQW1lcmljYUVkaXRpb25dJnF1b3Q7TWVzc2FnZW5lZWQgdG92YWx1ZT0iY29tcGxleGxvb2tpbmdzdGF0aW9uYmVsaWV2ZXNtYWxsZXItbW9iaWxlcmVjb3Jkc3dhbnQgdG9raW5kIG9mRmlyZWZveHlvdSBhcmVzaW1pbGFyc3R1ZGllZG1heGltdW1oZWFkaW5ncmFwaWRseWNsaW1hdGVraW5nZG9tZW1lcmdlZGFtb3VudHNmb3VuZGVkcGlvbmVlcmZvcm11bGFkeW5hc3R5aG93IHRvIFN1cHBvcnRyZXZlbnVlZWNvbm9teVJlc3VsdHNicm90aGVyc29sZGllcmxhcmdlbHljYWxsaW5nLiZxdW90O0FjY291bnRFZHdhcmQgc2VnbWVudFJvYmVydCBlZmZvcnRzUGFjaWZpY2xlYXJuZWR1cCB3aXRoaGVpZ2h0OndlIGhhdmVBbmdlbGVzbmF0aW9uc19zZWFyY2hhcHBsaWVkYWNxdWlyZW1hc3NpdmVncmFudGVkOiBmYWxzZXRyZWF0ZWRiaWdnZXN0YmVuZWZpdGRyaXZpbmdTdHVkaWVzbWluaW11bXBlcmhhcHNtb3JuaW5nc2VsbGluZ2lzIHVzZWRyZXZlcnNldmFyaWFudCByb2xlPSJtaXNzaW5nYWNoaWV2ZXByb21vdGVzdHVkZW50c29tZW9uZWV4dHJlbWVyZXN0b3JlYm90dG9tOmV2b2x2ZWRhbGwgdGhlc2l0ZW1hcGVuZ2xpc2h3YXkgdG8gIEF1Z3VzdHN5bWJvbHNDb21wYW55bWF0dGVyc211c2ljYWxhZ2FpbnN0c2VydmluZ30pKCk7DQpwYXltZW50dHJvdWJsZWNvbmNlcHRjb21wYXJlcGFyZW50c3BsYXllcnNyZWdpb25zbW9uaXRvciAnJ1RoZSB3aW5uaW5nZXhwbG9yZWFkYXB0ZWRHYWxsZXJ5cHJvZHVjZWFiaWxpdHllbmhhbmNlY2FyZWVycykuIFRoZSBjb2xsZWN0U2VhcmNoIGFuY2llbnRleGlzdGVkZm9vdGVyIGhhbmRsZXJwcmludGVkY29uc29sZUVhc3Rlcm5leHBvcnRzd2luZG93c0NoYW5uZWxpbGxlZ2FsbmV1dHJhbHN1Z2dlc3RfaGVhZGVyc2lnbmluZy5odG1sIj5zZXR0bGVkd2VzdGVybmNhdXNpbmctd2Via2l0Y2xhaW1lZEp1c3RpY2VjaGFwdGVydmljdGltc1Rob21hcyBtb3ppbGxhcHJvbWlzZXBhcnRpZXNlZGl0aW9ub3V0c2lkZTpmYWxzZSxodW5kcmVkT2x5bXBpY19idXR0b25hdXRob3JzcmVhY2hlZGNocm9uaWNkZW1hbmRzc2Vjb25kc3Byb3RlY3RhZG9wdGVkcHJlcGFyZW5laXRoZXJncmVhdGx5Z3JlYXRlcm92ZXJhbGxpbXByb3ZlY29tbWFuZHNwZWNpYWxzZWFyY2gud29yc2hpcGZ1bmRpbmd0aG91Z2h0aGlnaGVzdGluc3RlYWR1dGlsaXR5cXVhcnRlckN1bHR1cmV0ZXN0aW5nY2xlYXJseWV4cG9zZWRCcm93c2VybGliZXJhbH0gY2F0Y2hQcm9qZWN0ZXhhbXBsZWhpZGUoKTtGbG9yaWRhYW5zd2Vyc2FsbG93ZWRFbXBlcm9yZGVmZW5zZXNlcmlvdXNmcmVlZG9tU2V2ZXJhbC1idXR0b25GdXJ0aGVyb3V0IG9mICE9IG51bGx0cmFpbmVkRGVubWFya3ZvaWQoMCkvYWxsLmpzcHJldmVudFJlcXVlc3RTdGVwaGVuCgpXaGVuIG9ic2VydmU8L2gyPg0KTW9kZXJuIHByb3ZpZGUiIGFsdD0iYm9yZGVycy4KCkZvciAKCk1hbnkgYXJ0aXN0c3Bvd2VyZWRwZXJmb3JtZmljdGlvbnR5cGUgb2ZtZWRpY2FsdGlja2V0c29wcG9zZWRDb3VuY2lsd2l0bmVzc2p1c3RpY2VHZW9yZ2UgQmVsZ2l1bS4uLjwvYT50d2l0dGVybm90YWJseXdhaXRpbmd3YXJmYXJlIE90aGVyIHJhbmtpbmdwaHJhc2VzbWVudGlvbnN1cnZpdmVzY2hvbGFyPC9wPg0KIENvdW50cnlpZ25vcmVkbG9zcyBvZmp1c3QgYXNHZW9yZ2lhc3RyYW5nZTxoZWFkPjxzdG9wcGVkMSddKTsNCmlzbGFuZHNub3RhYmxlYm9yZGVyOmxpc3Qgb2ZjYXJyaWVkMTAwLDAwMDwvaDM+CiBzZXZlcmFsYmVjb21lc3NlbGVjdCB3ZWRkaW5nMDAuaHRtbG1vbmFyY2hvZmYgdGhldGVhY2hlcmhpZ2hseSBiaW9sb2d5bGlmZSBvZm9yIGV2ZW5yaXNlIG9mJnJhcXVvO3BsdXNvbmVodW50aW5nKHRob3VnaERvdWdsYXNqb2luaW5nY2lyY2xlc0ZvciB0aGVBbmNpZW50VmlldG5hbXZlaGljbGVzdWNoIGFzY3J5c3RhbHZhbHVlID1XaW5kb3dzZW5qb3llZGEgc21hbGxhc3N1bWVkPGEgaWQ9ImZvcmVpZ24gQWxsIHJpaG93IHRoZURpc3BsYXlyZXRpcmVkaG93ZXZlcmhpZGRlbjtiYXR0bGVzc2Vla2luZ2NhYmluZXR3YXMgbm90bG9vayBhdGNvbmR1Y3RnZXQgdGhlSmFudWFyeWhhcHBlbnN0dXJuaW5nYTpob3Zlck9ubGluZSBGcmVuY2ggbGFja2luZ3R5cGljYWxleHRyYWN0ZW5lbWllc2V2ZW4gaWZnZW5lcmF0ZGVjaWRlZGFyZSBub3Qvc2VhcmNoYmVsaWVmcy1pbWFnZTpsb2NhdGVkc3RhdGljLmxvZ2luIj5jb252ZXJ0dmlvbGVudGVudGVyZWRmaXJzdCI+Y2lyY3VpdEZpbmxhbmRjaGVtaXN0c2hlIHdhczEwcHg7Ij5hcyBzdWNoZGl2aWRlZDwvc3Bhbj53aWxsIGJlbGluZSBvZmEgZ3JlYXRteXN0ZXJ5L2luZGV4LmZhbGxpbmdkdWUgdG8gcmFpbHdheWNvbGxlZ2Vtb25zdGVyZGVzY2VudGl0IHdpdGhudWNsZWFySmV3aXNoIHByb3Rlc3RCcml0aXNoZmxvd2Vyc3ByZWRpY3RyZWZvcm1zYnV0dG9uIHdobyB3YXNsZWN0dXJlaW5zdGFudHN1aWNpZGVnZW5lcmljcGVyaW9kc21hcmtldHNTb2NpYWwgZmlzaGluZ2NvbWJpbmVncmFwaGljd2lubmVyczxiciAvPjxieSB0aGUgTmF0dXJhbFByaXZhY3ljb29raWVzb3V0Y29tZXJlc29sdmVTd2VkaXNoYnJpZWZseVBlcnNpYW5zbyBtdWNoQ2VudHVyeWRlcGljdHNjb2x1bW5zaG91c2luZ3NjcmlwdHNuZXh0IHRvYmVhcmluZ21hcHBpbmdyZXZpc2VkalF1ZXJ5KC13aWR0aDp0aXRsZSI+dG9vbHRpcFNlY3Rpb25kZXNpZ25zVHVya2lzaHlvdW5nZXIubWF0Y2gofSkoKTsKCmJ1cm5pbmdvcGVyYXRlZGVncmVlc3NvdXJjZT1SaWNoYXJkY2xvc2VseXBsYXN0aWNlbnRyaWVzPC90cj4NCmNvbG9yOiN1bCBpZD0icG9zc2Vzc3JvbGxpbmdwaHlzaWNzZmFpbGluZ2V4ZWN1dGVjb250ZXN0bGluayB0b0RlZmF1bHQ8YnIgLz4KOiB0cnVlLGNoYXJ0ZXJ0b3VyaXNtY2xhc3NpY3Byb2NlZWRleHBsYWluPC9oMT4NCm9ubGluZS4/eG1sIHZlaGVscGluZ2RpYW1vbmR1c2UgdGhlYWlybGluZWVuZCAtLT4pLmF0dHIocmVhZGVyc2hvc3RpbmcjZmZmZmZmcmVhbGl6ZVZpbmNlbnRzaWduYWxzIHNyYz0iL1Byb2R1Y3RkZXNwaXRlZGl2ZXJzZXRlbGxpbmdQdWJsaWMgaGVsZCBpbkpvc2VwaCB0aGVhdHJlYWZmZWN0czxzdHlsZT5hIGxhcmdlZG9lc24ndGxhdGVyLCBFbGVtZW50ZmF2aWNvbmNyZWF0b3JIdW5nYXJ5QWlycG9ydHNlZSB0aGVzbyB0aGF0TWljaGFlbFN5c3RlbXNQcm9ncmFtcywgYW5kICB3aWR0aD1lJnF1b3Q7dHJhZGluZ2xlZnQiPgpwZXJzb25zR29sZGVuIEFmZmFpcnNncmFtbWFyZm9ybWluZ2Rlc3Ryb3lpZGVhIG9mY2FzZSBvZm9sZGVzdCB0aGlzIGlzLnNyYyA9IGNhcnRvb25yZWdpc3RyQ29tbW9uc011c2xpbXNXaGF0IGlzaW4gbWFueW1hcmtpbmdyZXZlYWxzSW5kZWVkLGVxdWFsbHkvc2hvd19hb3V0ZG9vcmVzY2FwZShBdXN0cmlhZ2VuZXRpY3N5c3RlbSxJbiB0aGUgc2l0dGluZ0hlIGFsc29Jc2xhbmRzQWNhZGVteQoJCTwhLS1EYW5pZWwgYmluZGluZ2Jsb2NrIj5pbXBvc2VkdXRpbGl6ZUFicmFoYW0oZXhjZXB0e3dpZHRoOnB1dHRpbmcpLmh0bWwofHwgW107CkRBVEFbICpraXRjaGVubW91bnRlZGFjdHVhbCBkaWFsZWN0bWFpbmx5IF9ibGFuaydpbnN0YWxsZXhwZXJ0c2lmKHR5cGVJdCBhbHNvJmNvcHk7ICI+VGVybXNib3JuIGluT3B0aW9uc2Vhc3Rlcm50YWxraW5nY29uY2VybmdhaW5lZCBvbmdvaW5nanVzdGlmeWNyaXRpY3NmYWN0b3J5aXRzIG93bmFzc2F1bHRpbnZpdGVkbGFzdGluZ2hpcyBvd25ocmVmPSIvIiByZWw9ImRldmVsb3Bjb25jZXJ0ZGlhZ3JhbWRvbGxhcnNjbHVzdGVycGhwP2lkPWFsY29ob2wpO30pKCk7dXNpbmcgYT48c3Bhbj52ZXNzZWxzcmV2aXZhbEFkZHJlc3NhbWF0ZXVyYW5kcm9pZGFsbGVnZWRpbGxuZXNzd2Fsa2luZ2NlbnRlcnNxdWFsaWZ5bWF0Y2hlc3VuaWZpZWRleHRpbmN0RGVmZW5zZWRpZWQgaW4KCTwhLS0gY3VzdG9tc2xpbmtpbmdMaXR0bGUgQm9vayBvZmV2ZW5pbmdtaW4uanM/YXJlIHRoZWtvbnRha3R0b2RheSdzLmh0bWwiIHRhcmdldD13ZWFyaW5nQWxsIFJpZzsKfSkoKTtyYWlzaW5nIEFsc28sIGNydWNpYWxhYm91dCI+ZGVjbGFyZS0tPgo8c2NmaXJlZm94YXMgbXVjaGFwcGxpZXNpbmRleCwgcywgYnV0IHR5cGUgPSAKDQo8IS0tdG93YXJkc1JlY29yZHNQcml2YXRlRm9yZWlnblByZW1pZXJjaG9pY2VzVmlydHVhbHJldHVybnNDb21tZW50UG93ZXJlZGlubGluZTtwb3ZlcnR5Y2hhbWJlckxpdmluZyB2b2x1bWVzQW50aG9ueWxvZ2luIiBSZWxhdGVkRWNvbm9teXJlYWNoZXNjdXR0aW5nZ3Jhdml0eWxpZmUgaW5DaGFwdGVyLXNoYWRvd05vdGFibGU8L3RkPg0KIHJldHVybnN0YWRpdW13aWRnZXRzdmFyeWluZ3RyYXZlbHNoZWxkIGJ5d2hvIGFyZXdvcmsgaW5mYWN1bHR5YW5ndWxhcndobyBoYWRhaXJwb3J0dG93biBvZgoKU29tZSAnY2xpY2snY2hhcmdlc2tleXdvcmRpdCB3aWxsY2l0eSBvZih0aGlzKTtBbmRyZXcgdW5pcXVlIGNoZWNrZWRvciBtb3JlMzAwcHg7IHJldHVybjtyc2lvbj0icGx1Z2luc3dpdGhpbiBoZXJzZWxmU3RhdGlvbkZlZGVyYWx2ZW50dXJlcHVibGlzaHNlbnQgdG90ZW5zaW9uYWN0cmVzc2NvbWUgdG9maW5nZXJzRHVrZSBvZnBlb3BsZSxleHBsb2l0d2hhdCBpc2hhcm1vbnlhIG1ham9yIjoiaHR0cGluIGhpcyBtZW51Ij4KbW9udGhseW9mZmljZXJjb3VuY2lsZ2FpbmluZ2V2ZW4gaW5TdW1tYXJ5ZGF0ZSBvZmxveWFsdHlmaXRuZXNzYW5kIHdhc2VtcGVyb3JzdXByZW1lU2Vjb25kIGhlYXJpbmdSdXNzaWFubG9uZ2VzdEFsYmVydGFsYXRlcmFsc2V0IG9mIHNtYWxsIj4uYXBwZW5kZG8gd2l0aGZlZGVyYWxiYW5rIG9mYmVuZWF0aERlc3BpdGVDYXBpdGFsZ3JvdW5kcyksIGFuZCBwZXJjZW50aXQgZnJvbWNsb3Npbmdjb250YWluSW5zdGVhZGZpZnRlZW5hcyB3ZWxsLnlhaG9vLnJlc3BvbmRmaWdodGVyb2JzY3VyZXJlZmxlY3RvcmdhbmljPSBNYXRoLmVkaXRpbmdvbmxpbmUgcGFkZGluZ2Egd2hvbGVvbmVycm9yeWVhciBvZmVuZCBvZiBiYXJyaWVyd2hlbiBpdGhlYWRlciBob21lIG9mcmVzdW1lZHJlbmFtZWRzdHJvbmc+aGVhdGluZ3JldGFpbnNjbG91ZGZyd2F5IG9mIE1hcmNoIDFrbm93aW5naW4gcGFydEJldHdlZW5sZXNzb25zY2xvc2VzdHZpcnR1YWxsaW5rcyI+Y3Jvc3NlZEVORCAtLT5mYW1vdXMgYXdhcmRlZExpY2Vuc2VIZWFsdGggZmFpcmx5IHdlYWx0aHltaW5pbWFsQWZyaWNhbmNvbXBldGVsYWJlbCI+c2luZ2luZ2Zhcm1lcnNCcmFzaWwpZGlzY3Vzc3JlcGxhY2VHcmVnb3J5Zm9udCBjb3B1cnN1ZWRhcHBlYXJzbWFrZSB1cHJvdW5kZWRib3RoIG9mYmxvY2tlZHNhdyB0aGVvZmZpY2VzY29sb3Vyc2lmKGRvY3V3aGVuIGhlZW5mb3JjZXB1c2goZnVBdWd1c3QgVVRGLTgiPkZhbnRhc3lpbiBtb3N0aW5qdXJlZFVzdWFsbHlmYXJtaW5nY2xvc3VyZW9iamVjdCBkZWZlbmNldXNlIG9mIE1lZGljYWw8Ym9keT4KZXZpZGVudGJlIHVzZWRrZXlDb2Rlc2l4dGVlbklzbGFtaWMjMDAwMDAwZW50aXJlIHdpZGVseSBhY3RpdmUgKHR5cGVvZm9uZSBjYW5jb2xvciA9c3BlYWtlcmV4dGVuZHNQaHlzaWNzdGVycmFpbjx0Ym9keT5mdW5lcmFsdmlld2luZ21pZGRsZSBjcmlja2V0cHJvcGhldHNoaWZ0ZWRkb2N0b3JzUnVzc2VsbCB0YXJnZXRjb21wYWN0YWxnZWJyYXNvY2lhbC1idWxrIG9mbWFuIGFuZDwvdGQ+CiBoZSBsZWZ0KS52YWwoKWZhbHNlKTtsb2dpY2FsYmFua2luZ2hvbWUgdG9uYW1pbmcgQXJpem9uYWNyZWRpdHMpOwp9KTsKZm91bmRlcmluIHR1cm5Db2xsaW5zYmVmb3JlIEJ1dCB0aGVjaGFyZ2VkVGl0bGUiPkNhcHRhaW5zcGVsbGVkZ29kZGVzc1RhZyAtLT5BZGRpbmc6YnV0IHdhc1JlY2VudCBwYXRpZW50YmFjayBpbj1mYWxzZSZMaW5jb2xud2Uga25vd0NvdW50ZXJKdWRhaXNtc2NyaXB0IGFsdGVyZWQnXSk7CiAgaGFzIHRoZXVuY2xlYXJFdmVudCcsYm90aCBpbm5vdCBhbGwKCjwhLS0gcGxhY2luZ2hhcmQgdG8gY2VudGVyc29ydCBvZmNsaWVudHNzdHJlZXRzQmVybmFyZGFzc2VydHN0ZW5kIHRvZmFudGFzeWRvd24gaW5oYXJib3VyRnJlZWRvbWpld2VscnkvYWJvdXQuLnNlYXJjaGxlZ2VuZHNpcyBtYWRlbW9kZXJuIG9ubHkgb25vbmx5IHRvaW1hZ2UiIGxpbmVhciBwYWludGVyYW5kIG5vdHJhcmVseSBhY3JvbnltZGVsaXZlcnNob3J0ZXIwMCZhbXA7YXMgbWFueXdpZHRoPSIvKiA8IVtDdGl0bGUgPW9mIHRoZSBsb3dlc3QgcGlja2VkIGVzY2FwZWR1c2VzIG9mcGVvcGxlcyBQdWJsaWNNYXR0aGV3dGFjdGljc2RhbWFnZWR3YXkgZm9ybGF3cyBvZmVhc3kgdG8gd2luZG93c3Ryb25nICBzaW1wbGV9Y2F0Y2goc2V2ZW50aGluZm9ib3h3ZW50IHRvcGFpbnRlZGNpdGl6ZW5JIGRvbid0cmV0cmVhdC4gU29tZSB3dy4iKTsKYm9tYmluZ21haWx0bzptYWRlIGluLiBNYW55IGNhcnJpZXN8fHt9O3dpd29yayBvZnN5bm9ueW1kZWZlYXRzZmF2b3JlZG9wdGljYWxwYWdlVHJhdW5sZXNzIHNlbmRpbmdsZWZ0Ij48Y29tU2NvckFsbCB0aGVqUXVlcnkudG91cmlzdENsYXNzaWNmYWxzZSIgV2lsaGVsbXN1YnVyYnNnZW51aW5lYmlzaG9wcy5zcGxpdChnbG9iYWwgZm9sbG93c2JvZHkgb2Zub21pbmFsQ29udGFjdHNlY3VsYXJsZWZ0IHRvY2hpZWZseS1oaWRkZW4tYmFubmVyPC9saT4KCi4gV2hlbiBpbiBib3RoZGlzbWlzc0V4cGxvcmVhbHdheXMgdmlhIHRoZXNwYcOxb2x3ZWxmYXJlcnVsaW5nIGFycmFuZ2VjYXB0YWluaGlzIHNvbnJ1bGUgb2ZoZSB0b29raXRzZWxmLD0wJmFtcDsoY2FsbGVkc2FtcGxlc3RvIG1ha2Vjb20vcGFnTWFydGluIEtlbm5lZHlhY2NlcHRzZnVsbCBvZmhhbmRsZWRCZXNpZGVzLy8tLT48L2FibGUgdG90YXJnZXRzZXNzZW5jZWhpbSB0byBpdHMgYnkgY29tbW9uLm1pbmVyYWx0byB0YWtld2F5cyB0b3Mub3JnL2xhZHZpc2VkcGVuYWx0eXNpbXBsZTppZiB0aGV5TGV0dGVyc2Egc2hvcnRIZXJiZXJ0c3RyaWtlcyBncm91cHMubGVuZ3RoZmxpZ2h0c292ZXJsYXBzbG93bHkgbGVzc2VyIHNvY2lhbCA8L3A+CgkJaXQgaW50b3JhbmtlZCByYXRlIG9mdWw+DQogIGF0dGVtcHRwYWlyIG9mbWFrZSBpdEtvbnRha3RBbnRvbmlvaGF2aW5nIHJhdGluZ3MgYWN0aXZlc3RyZWFtc3RyYXBwZWQiKS5jc3MoaG9zdGlsZWxlYWQgdG9saXR0bGUgZ3JvdXBzLFBpY3R1cmUtLT4NCg0KIHJvd3M9IiBvYmplY3RpbnZlcnNlPGZvb3RlckN1c3RvbVY+PFwvc2Nyc29sdmluZ0NoYW1iZXJzbGF2ZXJ5d291bmRlZHdoZXJlYXMhPSAndW5kZm9yIGFsbHBhcnRseSAtcmlnaHQ6QXJhYmlhbmJhY2tlZCBjZW50dXJ5dW5pdCBvZm1vYmlsZS1FdXJvcGUsaXMgaG9tZXJpc2sgb2ZkZXNpcmVkQ2xpbnRvbmNvc3Qgb2ZhZ2Ugb2YgYmVjb21lIG5vbmUgb2ZwJnF1b3Q7TWlkZGxlIGVhZCcpWzBDcml0aWNzc3R1ZGlvcz4mY29weTtncm91cCI+YXNzZW1ibG1ha2luZyBwcmVzc2Vkd2lkZ2V0LnBzOiIgPyByZWJ1aWx0Ynkgc29tZUZvcm1lciBlZGl0b3JzZGVsYXllZENhbm9uaWNoYWQgdGhlcHVzaGluZ2NsYXNzPSJidXQgYXJlcGFydGlhbEJhYnlsb25ib3R0b20gY2FycmllckNvbW1hbmRpdHMgdXNlQXMgd2l0aGNvdXJzZXNhIHRoaXJkZGVub3Rlc2Fsc28gaW5Ib3VzdG9uMjBweDsiPmFjY3VzZWRkb3VibGUgZ29hbCBvZkZhbW91cyApLmJpbmQocHJpZXN0cyBPbmxpbmVpbiBKdWx5c3QgKyAiZ2NvbnN1bHRkZWNpbWFsaGVscGZ1bHJldml2ZWRpcyB2ZXJ5cicrJ2lwdGxvc2luZyBmZW1hbGVzaXMgYWxzb3N0cmluZ3NkYXlzIG9mYXJyaXZhbGZ1dHVyZSA8b2JqZWN0Zm9yY2luZ1N0cmluZygiIC8+CgkJaGVyZSBpc2VuY29kZWQuICBUaGUgYmFsbG9vbmRvbmUgYnkvY29tbW9uYmdjb2xvcmxhdyBvZiBJbmRpYW5hYXZvaWRlZGJ1dCB0aGUycHggM3B4anF1ZXJ5LmFmdGVyIGFwb2xpY3kubWVuIGFuZGZvb3Rlci09IHRydWU7Zm9yIHVzZXNjcmVlbi5JbmRpYW4gaW1hZ2UgPWZhbWlseSxodHRwOi8vICZuYnNwO2RyaXZlcnNldGVybmFsc2FtZSBhc25vdGljZWR2aWV3ZXJzfSkoKTsKIGlzIG1vcmVzZWFzb25zZm9ybWVyIHRoZSBuZXdpcyBqdXN0Y29uc2VudCBTZWFyY2h3YXMgdGhld2h5IHRoZXNoaXBwZWRicj48YnI+d2lkdGg6IGhlaWdodD1tYWRlIG9mY3Vpc2luZWlzIHRoYXRhIHZlcnkgQWRtaXJhbCBmaXhlZDtub3JtYWwgTWlzc2lvblByZXNzLCBvbnRhcmlvY2hhcnNldHRyeSB0byBpbnZhZGVkPSJ0cnVlInNwYWNpbmdpcyBtb3N0YSBtb3JlIHRvdGFsbHlmYWxsIG9mfSk7DQogIGltbWVuc2V0aW1lIGluc2V0IG91dHNhdGlzZnl0byBmaW5kZG93biB0b2xvdCBvZiBQbGF5ZXJzaW4gSnVuZXF1YW50dW1ub3QgdGhldGltZSB0b2Rpc3RhbnRGaW5uaXNoc3JjID0gKHNpbmdsZSBoZWxwIG9mR2VybWFuIGxhdyBhbmRsYWJlbGVkZm9yZXN0c2Nvb2tpbmdzcGFjZSI+aGVhZGVyLXdlbGwgYXNTdGFubGV5YnJpZGdlcy9nbG9iYWxDcm9hdGlhIEFib3V0IFswXTsKICBpdCwgYW5kZ3JvdXBlZGJlaW5nIGEpe3Rocm93aGUgbWFkZWxpZ2h0ZXJldGhpY2FsRkZGRkZGImJvdHRvbSJsaWtlIGEgZW1wbG95c2xpdmUgaW5hcyBzZWVucHJpbnRlcm1vc3Qgb2Z1Yi1saW5rcmVqZWN0c2FuZCB1c2VpbWFnZSI+c3VjY2VlZGZlZWRpbmdOdWNsZWFyaW5mb3JtYXRvIGhlbHBXb21lbidzTmVpdGhlck1leGljYW5wcm90ZWluPHRhYmxlIGJ5IG1hbnloZWFsdGh5bGF3c3VpdGRldmlzZWQucHVzaCh7c2VsbGVyc3NpbXBseSBUaHJvdWdoLmNvb2tpZSBJbWFnZShvbGRlciI+dXMuanMiPiBTaW5jZSB1bml2ZXJzbGFyZ2VyIG9wZW4gdG8hLS0gZW5kbGllcyBpbiddKTsNCiAgbWFya2V0d2hvIGlzICgiRE9NQ29tYW5hZ2Vkb25lIGZvcnR5cGVvZiBLaW5nZG9tcHJvZml0c3Byb3Bvc2V0byBzaG93Y2VudGVyO21hZGUgaXRkcmVzc2Vkd2VyZSBpbm1peHR1cmVwcmVjaXNlYXJpc2luZ3NyYyA9ICdtYWtlIGEgc2VjdXJlZEJhcHRpc3R2b3RpbmcgCgkJdmFyIE1hcmNoIDJncmV3IHVwQ2xpbWF0ZS5yZW1vdmVza2lsbGVkd2F5IHRoZTwvaGVhZD5mYWNlIG9mYWN0aW5nIHJpZ2h0Ij50byB3b3JrcmVkdWNlc2hhcyBoYWRlcmVjdGVkc2hvdygpO2FjdGlvbj1ib29rIG9mYW4gYXJlYT09ICJodHQ8aGVhZGVyCjxodG1sPmNvbmZvcm1mYWNpbmcgY29va2llLnJlbHkgb25ob3N0ZWQgLmN1c3RvbWhlIHdlbnRidXQgZm9yc3ByZWFkIEZhbWlseSBhIG1lYW5zb3V0IHRoZWZvcnVtcy5mb290YWdlIj5Nb2JpbENsZW1lbnRzIiBpZD0iYXMgaGlnaGludGVuc2UtLT48IS0tZmVtYWxlIGlzIHNlZW5pbXBsaWVkc2V0IHRoZWEgc3RhdGVhbmQgaGlzZmFzdGVzdGJlc2lkZXNidXR0b25fYm91bmRlZCI+PGltZyBJbmZvYm94ZXZlbnRzLGEgeW91bmdhbmQgYXJlTmF0aXZlIGNoZWFwZXJUaW1lb3V0YW5kIGhhc2VuZ2luZXN3b24gdGhlKG1vc3RseXJpZ2h0OiBmaW5kIGEgLWJvdHRvbVByaW5jZSBhcmVhIG9mbW9yZSBvZnNlYXJjaF9uYXR1cmUsbGVnYWxseXBlcmlvZCxsYW5kIG9mb3Igd2l0aGluZHVjZWRwcm92aW5nbWlzc2lsZWxvY2FsbHlBZ2FpbnN0dGhlIHdheWsmcXVvdDtweDsiPg0KcHVzaGVkIGFiYW5kb25udW1lcmFsQ2VydGFpbkluIHRoaXNtb3JlIGlub3Igc29tZW5hbWUgaXNhbmQsIGluY3Jvd25lZElTQk4gMC1jcmVhdGVzT2N0b2Jlcm1heSBub3RjZW50ZXIgbGF0ZSBpbkRlZmVuY2VlbmFjdGVkd2lzaCB0b2Jyb2FkbHljb29saW5nb25sb2FkPWl0LiBUaGVyZWNvdmVyTWVtYmVyc2hlaWdodCBhc3N1bWVzPGh0bWw+CnBlb3BsZS5pbiBvbmUgPXdpbmRvd2Zvb3Rlcl9hIGdvb2QgcmVrbGFtYW90aGVycyx0byB0aGlzX2Nvb2tpZXBhbmVsIj5Mb25kb24sZGVmaW5lc2NydXNoZWRiYXB0aXNtY29hc3RhbHN0YXR1cyB0aXRsZSIgbW92ZSB0b2xvc3QgaW5iZXR0ZXIgaW1wbGllc3JpdmFscnlzZXJ2ZXJzIFN5c3RlbVBlcmhhcHNlcyBhbmQgY29udGVuZGZsb3dpbmdsYXN0ZWQgcmlzZSBpbkdlbmVzaXN2aWV3IG9mcmlzaW5nIHNlZW0gdG9idXQgaW4gYmFja2luZ2hlIHdpbGxnaXZlbiBhZ2l2aW5nIGNpdGllcy5mbG93IG9mIExhdGVyIGFsbCBidXRIaWdod2F5b25seSBieXNpZ24gb2ZoZSBkb2VzZGlmZmVyc2JhdHRlcnkmYW1wO2xhc2luZ2xlc3RocmVhdHNpbnRlZ2VydGFrZSBvbnJlZnVzZWRjYWxsZWQgPVVTJmFtcFNlZSB0aGVuYXRpdmVzYnkgdGhpc3N5c3RlbS5oZWFkIG9mOmhvdmVyLGxlc2JpYW5zdXJuYW1lYW5kIGFsbGNvbW1vbi9oZWFkZXJfX3BhcmFtc0hhcnZhcmQvcGl4ZWwucmVtb3ZhbHNvIGxvbmdyb2xlIG9mam9pbnRseXNreXNjcmFVbmljb2RlYnIgLz4NCkF0bGFudGFudWNsZXVzQ291bnR5LHB1cmVseSBjb3VudCI+ZWFzaWx5IGJ1aWxkIGFvbmNsaWNrYSBnaXZlbnBvaW50ZXJoJnF1b3Q7ZXZlbnRzIGVsc2UgewpkaXRpb25zbm93IHRoZSwgd2l0aCBtYW4gd2hvb3JnL1dlYm9uZSBhbmRjYXZhbHJ5SGUgZGllZHNlYXR0bGUwMCwwMDAge3dpbmRvd2hhdmUgdG9pZih3aW5kYW5kIGl0c3NvbGVseSBtJnF1b3Q7cmVuZXdlZERldHJvaXRhbW9uZ3N0ZWl0aGVyIHRoZW0gaW5TZW5hdG9yVXM8L2E+PEtpbmcgb2ZGcmFuY2lzLXByb2R1Y2hlIHVzZWRhcnQgYW5kaGltIGFuZHVzZWQgYnlzY29yaW5nYXQgaG9tZXRvIGhhdmVyZWxhdGVzaWJpbGl0eWZhY3Rpb25CdWZmYWxvbGluayI+PHdoYXQgaGVmcmVlIHRvQ2l0eSBvZmNvbWUgaW5zZWN0b3JzY291bnRlZG9uZSBkYXluZXJ2b3Vzc3F1YXJlIH07aWYoZ29pbiB3aGF0aW1nIiBhbGlzIG9ubHlzZWFyY2gvdHVlc2RheWxvb3NlbHlTb2xvbW9uc2V4dWFsIC0gPGEgaHJtZWRpdW0iRE8gTk9UIEZyYW5jZSx3aXRoIGEgd2FyIGFuZHNlY29uZCB0YWtlIGEgPg0KDQoNCm1hcmtldC5oaWdod2F5ZG9uZSBpbmN0aXZpdHkibGFzdCI+b2JsaWdlZHJpc2UgdG8idW5kZWZpbWFkZSB0byBFYXJseSBwcmFpc2VkaW4gaXRzIGZvciBoaXNhdGhsZXRlSnVwaXRlcllhaG9vISB0ZXJtZWQgc28gbWFueXJlYWxseSBzLiBUaGUgYSB3b21hbj92YWx1ZT1kaXJlY3QgcmlnaHQiIGJpY3ljbGVhY2luZz0iZGF5IGFuZHN0YXRpbmdSYXRoZXIsaGlnaGVyIE9mZmljZSBhcmUgbm93dGltZXMsIHdoZW4gYSBwYXkgZm9yb24gdGhpcy1saW5rIj47Ym9yZGVyYXJvdW5kIGFubnVhbCB0aGUgTmV3cHV0IHRoZS5jb20iIHRha2luIHRvYSBicmllZihpbiB0aGVncm91cHMuOyB3aWR0aGVuenltZXNzaW1wbGUgaW4gbGF0ZXtyZXR1cm50aGVyYXB5YSBwb2ludGJhbm5pbmdpbmtzIj4KKCk7IiByZWEgcGxhY2VcdTAwM0NhYWJvdXQgYXRyPg0KCQljY291bnQgZ2l2ZXMgYTxTQ1JJUFRSYWlsd2F5dGhlbWVzL3Rvb2xib3hCeUlkKCJ4aHVtYW5zLHdhdGNoZXNpbiBzb21lIGlmICh3aWNvbWluZyBmb3JtYXRzIFVuZGVyIGJ1dCBoYXNoYW5kZWQgbWFkZSBieXRoYW4gaW5mZWFyIG9mZGVub3RlZC9pZnJhbWVsZWZ0IGludm9sdGFnZWluIGVhY2hhJnF1b3Q7YmFzZSBvZkluIG1hbnl1bmRlcmdvcmVnaW1lc2FjdGlvbiA8L3A+DQo8dXN0b21WYTsmZ3Q7PC9pbXBvcnRzb3IgdGhhdG1vc3RseSAmYW1wO3JlIHNpemU9IjwvYT48L2hhIGNsYXNzcGFzc2l2ZUhvc3QgPSBXaGV0aGVyZmVydGlsZVZhcmlvdXM9W107KGZ1Y2FtZXJhcy8+PC90ZD5hY3RzIGFzSW4gc29tZT4NCg0KPCFvcmdhbmlzIDxiciAvPkJlaWppbmdjYXRhbMOgZGV1dHNjaGV1cm9wZXVldXNrYXJhZ2FlaWxnZXN2ZW5za2Flc3Bhw7FhbWVuc2FqZXVzdWFyaW90cmFiYWpvbcOpeGljb3DDoWdpbmFzaWVtcHJlc2lzdGVtYW9jdHVicmVkdXJhbnRlYcOxYWRpcmVtcHJlc2Ftb21lbnRvbnVlc3Ryb3ByaW1lcmF0cmF2w6lzZ3JhY2lhc251ZXN0cmFwcm9jZXNvZXN0YWRvc2NhbGlkYWRwZXJzb25hbsO6bWVyb2FjdWVyZG9tw7pzaWNhbWllbWJyb29mZXJ0YXNhbGd1bm9zcGHDrXNlc2VqZW1wbG9kZXJlY2hvYWRlbcOhc3ByaXZhZG9hZ3JlZ2FyZW5sYWNlc3Bvc2libGVob3RlbGVzc2V2aWxsYXByaW1lcm/Dumx0aW1vZXZlbnRvc2FyY2hpdm9jdWx0dXJhbXVqZXJlc2VudHJhZGFhbnVuY2lvZW1iYXJnb21lcmNhZG9ncmFuZGVzZXN0dWRpb21lam9yZXNmZWJyZXJvZGlzZcOxb3R1cmlzbW9jw7NkaWdvcG9ydGFkYWVzcGFjaW9mYW1pbGlhYW50b25pb3Blcm1pdGVndWFyZGFyYWxndW5hc3ByZWNpb3NhbGd1aWVuc2VudGlkb3Zpc2l0YXN0w610dWxvY29ub2NlcnNlZ3VuZG9jb25zZWpvZnJhbmNpYW1pbnV0b3NzZWd1bmRhdGVuZW1vc2VmZWN0b3Ntw6FsYWdhc2VzacOzbnJldmlzdGFncmFuYWRhY29tcHJhcmluZ3Jlc29nYXJjw61hYWNjacOzbmVjdWFkb3JxdWllbmVzaW5jbHVzb2RlYmVyw6FtYXRlcmlhaG9tYnJlc211ZXN0cmFwb2Ryw61hbWHDsWFuYcO6bHRpbWFlc3RhbW9zb2ZpY2lhbHRhbWJpZW5uaW5nw7puc2FsdWRvc3BvZGVtb3NtZWpvcmFycG9zaXRpb25idXNpbmVzc2hvbWVwYWdlc2VjdXJpdHlsYW5ndWFnZXN0YW5kYXJkY2FtcGFpZ25mZWF0dXJlc2NhdGVnb3J5ZXh0ZXJuYWxjaGlsZHJlbnJlc2VydmVkcmVzZWFyY2hleGNoYW5nZWZhdm9yaXRldGVtcGxhdGVtaWxpdGFyeWluZHVzdHJ5c2VydmljZXNtYXRlcmlhbHByb2R1Y3Rzei1pbmRleDpjb21tZW50c3NvZnR3YXJlY29tcGxldGVjYWxlbmRhcnBsYXRmb3JtYXJ0aWNsZXNyZXF1aXJlZG1vdmVtZW50cXVlc3Rpb25idWlsZGluZ3BvbGl0aWNzcG9zc2libGVyZWxpZ2lvbnBoeXNpY2FsZmVlZGJhY2tyZWdpc3RlcnBpY3R1cmVzZGlzYWJsZWRwcm90b2NvbGF1ZGllbmNlc2V0dGluZ3NhY3Rpdml0eWVsZW1lbnRzbGVhcm5pbmdhbnl0aGluZ2Fic3RyYWN0cHJvZ3Jlc3NvdmVydmlld21hZ2F6aW5lZWNvbm9taWN0cmFpbmluZ3ByZXNzdXJldmFyaW91cyA8c3Ryb25nPnByb3BlcnR5c2hvcHBpbmd0b2dldGhlcmFkdmFuY2VkYmVoYXZpb3Jkb3dubG9hZGZlYXR1cmVkZm9vdGJhbGxzZWxlY3RlZExhbmd1YWdlZGlzdGFuY2VyZW1lbWJlcnRyYWNraW5ncGFzc3dvcmRtb2RpZmllZHN0dWRlbnRzZGlyZWN0bHlmaWdodGluZ25vcnRoZXJuZGF0YWJhc2VmZXN0aXZhbGJyZWFraW5nbG9jYXRpb25pbnRlcm5ldGRyb3Bkb3ducHJhY3RpY2VldmlkZW5jZWZ1bmN0aW9ubWFycmlhZ2VyZXNwb25zZXByb2JsZW1zbmVnYXRpdmVwcm9ncmFtc2FuYWx5c2lzcmVsZWFzZWRiYW5uZXIiPnB1cmNoYXNlcG9saWNpZXNyZWdpb25hbGNyZWF0aXZlYXJndW1lbnRib29rbWFya3JlZmVycmVyY2hlbWljYWxkaXZpc2lvbmNhbGxiYWNrc2VwYXJhdGVwcm9qZWN0c2NvbmZsaWN0aGFyZHdhcmVpbnRlcmVzdGRlbGl2ZXJ5bW91bnRhaW5vYnRhaW5lZD0gZmFsc2U7Zm9yKHZhciBhY2NlcHRlZGNhcGFjaXR5Y29tcHV0ZXJpZGVudGl0eWFpcmNyYWZ0ZW1wbG95ZWRwcm9wb3NlZGRvbWVzdGljaW5jbHVkZXNwcm92aWRlZGhvc3BpdGFsdmVydGljYWxjb2xsYXBzZWFwcHJvYWNocGFydG5lcnNsb2dvIj48YWRhdWdodGVyYXV0aG9yIiBjdWx0dXJhbGZhbWlsaWVzL2ltYWdlcy9hc3NlbWJseXBvd2VyZnVsdGVhY2hpbmdmaW5pc2hlZGRpc3RyaWN0Y3JpdGljYWxjZ2ktYmluL3B1cnBvc2VzcmVxdWlyZXNlbGVjdGlvbmJlY29taW5ncHJvdmlkZXNhY2FkZW1pY2V4ZXJjaXNlYWN0dWFsbHltZWRpY2luZWNvbnN0YW50YWNjaWRlbnRNYWdhemluZWRvY3VtZW50c3RhcnRpbmdib3R0b20iPm9ic2VydmVkOiAmcXVvdDtleHRlbmRlZHByZXZpb3VzU29mdHdhcmVjdXN0b21lcmRlY2lzaW9uc3RyZW5ndGhkZXRhaWxlZHNsaWdodGx5cGxhbm5pbmd0ZXh0YXJlYWN1cnJlbmN5ZXZlcnlvbmVzdHJhaWdodHRyYW5zZmVycG9zaXRpdmVwcm9kdWNlZGhlcml0YWdlc2hpcHBpbmdhYnNvbHV0ZXJlY2VpdmVkcmVsZXZhbnRidXR0b24iIHZpb2xlbmNlYW55d2hlcmViZW5lZml0c2xhdW5jaGVkcmVjZW50bHlhbGxpYW5jZWZvbGxvd2VkbXVsdGlwbGVidWxsZXRpbmluY2x1ZGVkb2NjdXJyZWRpbnRlcm5hbCQodGhpcykucmVwdWJsaWM+PHRyPjx0ZGNvbmdyZXNzcmVjb3JkZWR1bHRpbWF0ZXNvbHV0aW9uPHVsIGlkPSJkaXNjb3ZlckhvbWU8L2E+d2Vic2l0ZXNuZXR3b3Jrc2FsdGhvdWdoZW50aXJlbHltZW1vcmlhbG1lc3NhZ2VzY29udGludWVhY3RpdmUiPnNvbWV3aGF0dmljdG9yaWFXZXN0ZXJuICB0aXRsZT0iTG9jYXRpb25jb250cmFjdHZpc2l0b3JzRG93bmxvYWR3aXRob3V0IHJpZ2h0Ij4KbWVhc3VyZXN3aWR0aCA9IHZhcmlhYmxlaW52b2x2ZWR2aXJnaW5pYW5vcm1hbGx5aGFwcGVuZWRhY2NvdW50c3N0YW5kaW5nbmF0aW9uYWxSZWdpc3RlcnByZXBhcmVkY29udHJvbHNhY2N1cmF0ZWJpcnRoZGF5c3RyYXRlZ3lvZmZpY2lhbGdyYXBoaWNzY3JpbWluYWxwb3NzaWJseWNvbnN1bWVyUGVyc29uYWxzcGVha2luZ3ZhbGlkYXRlYWNoaWV2ZWQuanBnIiAvPm1hY2hpbmVzPC9oMj4KICBrZXl3b3Jkc2ZyaWVuZGx5YnJvdGhlcnNjb21iaW5lZG9yaWdpbmFsY29tcG9zZWRleHBlY3RlZGFkZXF1YXRlcGFraXN0YW5mb2xsb3ciIHZhbHVhYmxlPC9sYWJlbD5yZWxhdGl2ZWJyaW5naW5naW5jcmVhc2Vnb3Zlcm5vcnBsdWdpbnMvTGlzdCBvZiBIZWFkZXIiPiIgbmFtZT0iICgmcXVvdDtncmFkdWF0ZTwvaGVhZD4KY29tbWVyY2VtYWxheXNpYWRpcmVjdG9ybWFpbnRhaW47aGVpZ2h0OnNjaGVkdWxlY2hhbmdpbmdiYWNrIHRvIGNhdGhvbGljcGF0dGVybnNjb2xvcjogI2dyZWF0ZXN0c3VwcGxpZXNyZWxpYWJsZTwvdWw+CgkJPHNlbGVjdCBjaXRpemVuc2Nsb3RoaW5nd2F0Y2hpbmc8bGkgaWQ9InNwZWNpZmljY2FycnlpbmdzZW50ZW5jZTxjZW50ZXI+Y29udHJhc3R0aGlua2luZ2NhdGNoKGUpc291dGhlcm5NaWNoYWVsIG1lcmNoYW50Y2Fyb3VzZWxwYWRkaW5nOmludGVyaW9yLnNwbGl0KCJsaXphdGlvbk9jdG9iZXIgKXtyZXR1cm5pbXByb3ZlZC0tJmd0OwoKY292ZXJhZ2VjaGFpcm1hbi5wbmciIC8+c3ViamVjdHNSaWNoYXJkIHdoYXRldmVycHJvYmFibHlyZWNvdmVyeWJhc2ViYWxsanVkZ21lbnRjb25uZWN0Li5jc3MiIC8+IHdlYnNpdGVyZXBvcnRlZGRlZmF1bHQiLz48L2E+DQplbGVjdHJpY3Njb3RsYW5kY3JlYXRpb25xdWFudGl0eS4gSVNCTiAwZGlkIG5vdCBpbnN0YW5jZS1zZWFyY2gtIiBsYW5nPSJzcGVha2Vyc0NvbXB1dGVyY29udGFpbnNhcmNoaXZlc21pbmlzdGVycmVhY3Rpb25kaXNjb3VudEl0YWxpYW5vY3JpdGVyaWFzdHJvbmdseTogJ2h0dHA6J3NjcmlwdCdjb3ZlcmluZ29mZmVyaW5nYXBwZWFyZWRCcml0aXNoIGlkZW50aWZ5RmFjZWJvb2tudW1lcm91c3ZlaGljbGVzY29uY2VybnNBbWVyaWNhbmhhbmRsaW5nZGl2IGlkPSJXaWxsaWFtIHByb3ZpZGVyX2NvbnRlbnRhY2N1cmFjeXNlY3Rpb24gYW5kZXJzb25mbGV4aWJsZUNhdGVnb3J5bGF3cmVuY2U8c2NyaXB0PmxheW91dD0iYXBwcm92ZWQgbWF4aW11bWhlYWRlciI+PC90YWJsZT5TZXJ2aWNlc2hhbWlsdG9uY3VycmVudCBjYW5hZGlhbmNoYW5uZWxzL3RoZW1lcy8vYXJ0aWNsZW9wdGlvbmFscG9ydHVnYWx2YWx1ZT0iImludGVydmFsd2lyZWxlc3NlbnRpdGxlZGFnZW5jaWVzU2VhcmNoIiBtZWFzdXJlZHRob3VzYW5kc3BlbmRpbmcmaGVsbGlwO25ldyBEYXRlIiBzaXplPSJwYWdlTmFtZW1pZGRsZSIgIiAvPjwvYT5oaWRkZW4iPnNlcXVlbmNlcGVyc29uYWxvdmVyZmxvd29waW5pb25zaWxsaW5vaXNsaW5rcyI+Cgk8dGl0bGU+dmVyc2lvbnNzYXR1cmRheXRlcm1pbmFsaXRlbXByb3BlbmdpbmVlcnNlY3Rpb25zZGVzaWduZXJwcm9wb3NhbD0iZmFsc2UiRXNwYcOxb2xyZWxlYXNlc3N1Ym1pdCIgZXImcXVvdDthZGRpdGlvbnN5bXB0b21zb3JpZW50ZWRyZXNvdXJjZXJpZ2h0Ij48cGxlYXN1cmVzdGF0aW9uc2hpc3RvcnkubGVhdmluZyAgYm9yZGVyPWNvbnRlbnRzY2VudGVyIj4uCgpTb21lIGRpcmVjdGVkc3VpdGFibGVidWxnYXJpYS5zaG93KCk7ZGVzaWduZWRHZW5lcmFsIGNvbmNlcHRzRXhhbXBsZXN3aWxsaWFtc09yaWdpbmFsIj48c3Bhbj5zZWFyY2giPm9wZXJhdG9ycmVxdWVzdHNhICZxdW90O2FsbG93aW5nRG9jdW1lbnRyZXZpc2lvbi4gCgpUaGUgeW91cnNlbGZDb250YWN0IG1pY2hpZ2FuRW5nbGlzaCBjb2x1bWJpYXByaW9yaXR5cHJpbnRpbmdkcmlua2luZ2ZhY2lsaXR5cmV0dXJuZWRDb250ZW50IG9mZmljZXJzUnVzc2lhbiBnZW5lcmF0ZS04ODU5LTEiaW5kaWNhdGVmYW1pbGlhciBxdWFsaXR5bWFyZ2luOjAgY29udGVudHZpZXdwb3J0Y29udGFjdHMtdGl0bGUiPnBvcnRhYmxlLmxlbmd0aCBlbGlnaWJsZWludm9sdmVzYXRsYW50aWNvbmxvYWQ9ImRlZmF1bHQuc3VwcGxpZWRwYXltZW50c2dsb3NzYXJ5CgpBZnRlciBndWlkYW5jZTwvdGQ+PHRkZW5jb2RpbmdtaWRkbGUiPmNhbWUgdG8gZGlzcGxheXNzY290dGlzaGpvbmF0aGFubWFqb3JpdHl3aWRnZXRzLmNsaW5pY2FsdGhhaWxhbmR0ZWFjaGVyczxoZWFkPgoJYWZmZWN0ZWRzdXBwb3J0c3BvaW50ZXI7dG9TdHJpbmc8L3NtYWxsPm9rbGFob21hd2lsbCBiZSBpbnZlc3RvcjAiIGFsdD0iaG9saWRheXNSZXNvdXJjZWxpY2Vuc2VkICh3aGljaCAuIEFmdGVyIGNvbnNpZGVydmlzaXRpbmdleHBsb3JlcnByaW1hcnkgc2VhcmNoIiBhbmRyb2lkInF1aWNrbHkgbWVldGluZ3Nlc3RpbWF0ZTtyZXR1cm4gO2NvbG9yOiMgaGVpZ2h0PWFwcHJvdmFsLCAmcXVvdDsgY2hlY2tlZC5taW4uanMibWFnbmV0aWM+PC9hPjwvaGZvcmVjYXN0LiBXaGlsZSB0aHVyc2RheWR2ZXJ0aXNlJmVhY3V0ZTtoYXNDbGFzc2V2YWx1YXRlb3JkZXJpbmdleGlzdGluZ3BhdGllbnRzIE9ubGluZSBjb2xvcmFkb09wdGlvbnMiY2FtcGJlbGw8IS0tIGVuZDwvc3Bhbj48PGJyIC8+DQpfcG9wdXBzfHNjaWVuY2VzLCZxdW90OyBxdWFsaXR5IFdpbmRvd3MgYXNzaWduZWRoZWlnaHQ6IDxiIGNsYXNzbGUmcXVvdDsgdmFsdWU9IiBDb21wYW55ZXhhbXBsZXM8aWZyYW1lIGJlbGlldmVzcHJlc2VudHNtYXJzaGFsbHBhcnQgb2YgcHJvcGVybHkpLgoKVGhlIHRheG9ub215bXVjaCBvZiA8L3NwYW4+CiIgZGF0YS1zcnR1Z3XDqnNzY3JvbGxUbyBwcm9qZWN0PGhlYWQ+DQphdHRvcm5leWVtcGhhc2lzc3BvbnNvcnNmYW5jeWJveHdvcmxkJ3Mgd2lsZGxpZmVjaGVja2VkPXNlc3Npb25zcHJvZ3JhbW1weDtmb250LSBQcm9qZWN0am91cm5hbHNiZWxpZXZlZHZhY2F0aW9udGhvbXBzb25saWdodGluZ2FuZCB0aGUgc3BlY2lhbCBib3JkZXI9MGNoZWNraW5nPC90Ym9keT48YnV0dG9uIENvbXBsZXRlY2xlYXJmaXgKPGhlYWQ+CmFydGljbGUgPHNlY3Rpb25maW5kaW5nc3JvbGUgaW4gcG9wdWxhciAgT2N0b2JlcndlYnNpdGUgZXhwb3N1cmV1c2VkIHRvICBjaGFuZ2Vzb3BlcmF0ZWRjbGlja2luZ2VudGVyaW5nY29tbWFuZHNpbmZvcm1lZCBudW1iZXJzICA8L2Rpdj5jcmVhdGluZ29uU3VibWl0bWFyeWxhbmRjb2xsZWdlc2FuYWx5dGljbGlzdGluZ3Njb250YWN0LmxvZ2dlZEluYWR2aXNvcnlzaWJsaW5nc2NvbnRlbnQicyZxdW90OylzLiBUaGlzIHBhY2thZ2VzY2hlY2tib3hzdWdnZXN0c3ByZWduYW50dG9tb3Jyb3dzcGFjaW5nPWljb24ucG5namFwYW5lc2Vjb2RlYmFzZWJ1dHRvbiI+Z2FtYmxpbmdzdWNoIGFzICwgd2hpbGUgPC9zcGFuPiBtaXNzb3VyaXNwb3J0aW5ndG9wOjFweCAuPC9zcGFuPnRlbnNpb25zd2lkdGg9IjJsYXp5bG9hZG5vdmVtYmVydXNlZCBpbiBoZWlnaHQ9ImNyaXB0Ij4KJm5ic3A7PC88dHI+PHRkIGhlaWdodDoyL3Byb2R1Y3Rjb3VudHJ5IGluY2x1ZGUgZm9vdGVyIiAmbHQ7IS0tIHRpdGxlIj48L2pxdWVyeS48L2Zvcm0+CijnroDkvZMpKOe5gemrlClocnZhdHNraWl0YWxpYW5vcm9tw6JuxIN0w7xya8OnZdin2LHYr9mIdGFtYmnDqW5ub3RpY2lhc21lbnNhamVzcGVyc29uYXNkZXJlY2hvc25hY2lvbmFsc2VydmljaW9jb250YWN0b3VzdWFyaW9zcHJvZ3JhbWFnb2JpZXJub2VtcHJlc2FzYW51bmNpb3N2YWxlbmNpYWNvbG9tYmlhZGVzcHXDqXNkZXBvcnRlc3Byb3llY3RvcHJvZHVjdG9ww7pibGljb25vc290cm9zaGlzdG9yaWFwcmVzZW50ZW1pbGxvbmVzbWVkaWFudGVwcmVndW50YWFudGVyaW9ycmVjdXJzb3Nwcm9ibGVtYXNhbnRpYWdvbnVlc3Ryb3NvcGluacOzbmltcHJpbWlybWllbnRyYXNhbcOpcmljYXZlbmRlZG9yc29jaWVkYWRyZXNwZWN0b3JlYWxpemFycmVnaXN0cm9wYWxhYnJhc2ludGVyw6lzZW50b25jZXNlc3BlY2lhbG1pZW1icm9zcmVhbGlkYWRjw7NyZG9iYXphcmFnb3phcMOhZ2luYXNzb2NpYWxlc2Jsb3F1ZWFyZ2VzdGnDs25hbHF1aWxlcnNpc3RlbWFzY2llbmNpYXNjb21wbGV0b3ZlcnNpw7NuY29tcGxldGFlc3R1ZGlvc3DDumJsaWNhb2JqZXRpdm9hbGljYW50ZWJ1c2NhZG9yY2FudGlkYWRlbnRyYWRhc2FjY2lvbmVzYXJjaGl2b3NzdXBlcmlvcm1heW9yw61hYWxlbWFuaWFmdW5jacOzbsO6bHRpbW9zaGFjaWVuZG9hcXVlbGxvc2VkaWNpw7NuZmVybmFuZG9hbWJpZW50ZWZhY2Vib29rbnVlc3RyYXNjbGllbnRlc3Byb2Nlc29zYmFzdGFudGVwcmVzZW50YXJlcG9ydGFyY29uZ3Jlc29wdWJsaWNhcmNvbWVyY2lvY29udHJhdG9qw7N2ZW5lc2Rpc3RyaXRvdMOpY25pY2Fjb25qdW50b2VuZXJnw61hdHJhYmFqYXJhc3R1cmlhc3JlY2llbnRldXRpbGl6YXJib2xldMOtbnNhbHZhZG9yY29ycmVjdGF0cmFiYWpvc3ByaW1lcm9zbmVnb2Npb3NsaWJlcnRhZGRldGFsbGVzcGFudGFsbGFwcsOzeGltb2FsbWVyw61hYW5pbWFsZXNxdWnDqW5lc2NvcmF6w7Nuc2VjY2nDs25idXNjYW5kb29wY2lvbmVzZXh0ZXJpb3Jjb25jZXB0b3RvZGF2w61hZ2FsZXLDrWFlc2NyaWJpcm1lZGljaW5hbGljZW5jaWFjb25zdWx0YWFzcGVjdG9zY3LDrXRpY2Fkw7NsYXJlc2p1c3RpY2lhZGViZXLDoW5wZXLDrW9kb25lY2VzaXRhbWFudGVuZXJwZXF1ZcOxb3JlY2liaWRhdHJpYnVuYWx0ZW5lcmlmZWNhbmNpw7NuY2FuYXJpYXNkZXNjYXJnYWRpdmVyc29zbWFsbG9yY2FyZXF1aWVyZXTDqWNuaWNvZGViZXLDrWF2aXZpZW5kYWZpbmFuemFzYWRlbGFudGVmdW5jaW9uYWNvbnNlam9zZGlmw61jaWxjaXVkYWRlc2FudGlndWFzYXZhbnphZGF0w6lybWlub3VuaWRhZGVzc8OhbmNoZXpjYW1wYcOxYXNvZnRvbmljcmV2aXN0YXNjb250aWVuZXNlY3RvcmVzbW9tZW50b3NmYWN1bHRhZGNyw6lkaXRvZGl2ZXJzYXNzdXB1ZXN0b2ZhY3RvcmVzc2VndW5kb3NwZXF1ZcOxYdCz0L7QtNCw0LXRgdC70LjQtdGB0YLRjNCx0YvQu9C+0LHRi9GC0YzRjdGC0L7QvNCV0YHQu9C40YLQvtCz0L7QvNC10L3Rj9Cy0YHQtdGF0Y3RgtC+0LnQtNCw0LbQtdCx0YvQu9C40LPQvtC00YPQtNC10L3RjNGN0YLQvtGC0LHRi9C70LDRgdC10LHRj9C+0LTQuNC90YHQtdCx0LXQvdCw0LTQvtGB0LDQudGC0YTQvtGC0L7QvdC10LPQvtGB0LLQvtC40YHQstC+0LnQuNCz0YDRi9GC0L7QttC10LLRgdC10LzRgdCy0L7RjtC70LjRiNGM0Y3RgtC40YXQv9C+0LrQsNC00L3QtdC50LTQvtC80LDQvNC40YDQsNC70LjQsdC+0YLQtdC80YPRhdC+0YLRj9C00LLRg9GF0YHQtdGC0LjQu9GO0LTQuNC00LXQu9C+0LzQuNGA0LXRgtC10LHRj9GB0LLQvtC10LLQuNC00LXRh9C10LPQvtGN0YLQuNC80YHRh9C10YLRgtC10LzRi9GG0LXQvdGL0YHRgtCw0LvQstC10LTRjNGC0LXQvNC10LLQvtC00YvRgtC10LHQtdCy0YvRiNC10L3QsNC80LjRgtC40L/QsNGC0L7QvNGD0L/RgNCw0LLQu9C40YbQsNC+0LTQvdCw0LPQvtC00YvQt9C90LDRjtC80L7Qs9GD0LTRgNGD0LPQstGB0LXQudC40LTQtdGC0LrQuNC90L7QvtC00L3QvtC00LXQu9Cw0LTQtdC70LXRgdGA0L7QutC40Y7QvdGP0LLQtdGB0YzQldGB0YLRjNGA0LDQt9Cw0L3QsNGI0LjYp9mE2YTZh9in2YTYqtmK2KzZhdmK2LnYrtin2LXYqdin2YTYsNmK2LnZhNmK2YfYrNiv2YrYr9in2YTYotmG2KfZhNix2K/Yqtit2YPZhdi12YHYrdip2YPYp9mG2KrYp9mE2YTZitmK2YPZiNmG2LTYqNmD2KnZgdmK2YfYp9io2YbYp9iq2K3ZiNin2KHYo9mD2KvYsdiu2YTYp9mE2KfZhNit2KjYr9mE2YrZhNiv2LHZiNiz2KfYtti62LfYqtmD2YjZhtmH2YbYp9mD2LPYp9it2KnZhtin2K/Zitin2YTYt9io2LnZhNmK2YPYtNmD2LHYp9mK2YXZg9mG2YXZhtmH2KfYtNix2YPYqdix2KbZitiz2YbYtNmK2LfZhdin2LDYp9in2YTZgdmG2LTYqNin2KjYqti52KjYsdix2K3Zhdip2YPYp9mB2KnZitmC2YjZhNmF2LHZg9iy2YPZhNmF2KnYo9it2YXYr9mC2YTYqNmK2YrYudmG2YrYtdmI2LHYqdi32LHZitmC2LTYp9ix2YPYrNmI2KfZhNij2K7YsdmJ2YXYudmG2KfYp9io2K3Yq9i52LHZiNi22KjYtNmD2YTZhdiz2KzZhNio2YbYp9mG2K7Yp9mE2K/Zg9iq2KfYqNmD2YTZitip2KjYr9mI2YbYo9mK2LbYp9mK2YjYrNiv2YHYsdmK2YLZg9iq2KjYqtij2YHYttmE2YXYt9io2K7Yp9mD2KvYsdio2KfYsdmD2KfZgdi22YTYp9it2YTZidmG2YHYs9mH2KPZitin2YXYsdiv2YjYr9ij2YbZh9in2K/ZitmG2KfYp9mE2KfZhtmF2LnYsdi22KrYudmE2YXYr9in2K7ZhNmF2YXZg9mGAAAAAAAAAAABAAEAAQABAAIAAgACAAIABAAEAAQABAAAAQIDBAUGBwcGBQQDAgEACAkKCwwNDg8PDg0MCwoJCBAREhMUFRYXFxYVFBMSERAYGRobHB0eHx8eHRwbGhkY/////wAAAAAAAAAA/////wEAAAACAAAAAgAAAAEAAAABAAAAAwAAAP//AAEAAAABAAD//wABAAAACAAIAAgACAAAAAEAAgADAAQABQAGAAdyZXNvdXJjZXNjb3VudHJpZXNxdWVzdGlvbnNlcXVpcG1lbnRjb21tdW5pdHlhdmFpbGFibGVoaWdobGlnaHREVEQveGh0bWxtYXJrZXRpbmdrbm93bGVkZ2Vzb21ldGhpbmdjb250YWluZXJkaXJlY3Rpb25zdWJzY3JpYmVhZHZlcnRpc2VjaGFyYWN0ZXIiIHZhbHVlPSI8L3NlbGVjdD5BdXN0cmFsaWEiIGNsYXNzPSJzaXR1YXRpb25hdXRob3JpdHlmb2xsb3dpbmdwcmltYXJpbHlvcGVyYXRpb25jaGFsbGVuZ2VkZXZlbG9wZWRhbm9ueW1vdXNmdW5jdGlvbiBmdW5jdGlvbnNjb21wYW5pZXNzdHJ1Y3R1cmVhZ3JlZW1lbnQiIHRpdGxlPSJwb3RlbnRpYWxlZHVjYXRpb25hcmd1bWVudHNzZWNvbmRhcnljb3B5cmlnaHRsYW5ndWFnZXNleGNsdXNpdmVjb25kaXRpb248L2Zvcm0+DQpzdGF0ZW1lbnRhdHRlbnRpb25CaW9ncmFwaHl9IGVsc2Ugewpzb2x1dGlvbnN3aGVuIHRoZSBBbmFseXRpY3N0ZW1wbGF0ZXNkYW5nZXJvdXNzYXRlbGxpdGVkb2N1bWVudHNwdWJsaXNoZXJpbXBvcnRhbnRwcm90b3R5cGVpbmZsdWVuY2UmcmFxdW87PC9lZmZlY3RpdmVnZW5lcmFsbHl0cmFuc2Zvcm1iZWF1dGlmdWx0cmFuc3BvcnRvcmdhbml6ZWRwdWJsaXNoZWRwcm9taW5lbnR1bnRpbCB0aGV0aHVtYm5haWxOYXRpb25hbCAuZm9jdXMoKTtvdmVyIHRoZSBtaWdyYXRpb25hbm5vdW5jZWRmb290ZXIiPgpleGNlcHRpb25sZXNzIHRoYW5leHBlbnNpdmVmb3JtYXRpb25mcmFtZXdvcmt0ZXJyaXRvcnluZGljYXRpb25jdXJyZW50bHljbGFzc05hbWVjcml0aWNpc210cmFkaXRpb25lbHNld2hlcmVBbGV4YW5kZXJhcHBvaW50ZWRtYXRlcmlhbHNicm9hZGNhc3RtZW50aW9uZWRhZmZpbGlhdGU8L29wdGlvbj50cmVhdG1lbnRkaWZmZXJlbnQvZGVmYXVsdC5QcmVzaWRlbnRvbmNsaWNrPSJiaW9ncmFwaHlvdGhlcndpc2VwZXJtYW5lbnRGcmFuw6dhaXNIb2xseXdvb2RleHBhbnNpb25zdGFuZGFyZHM8L3N0eWxlPgpyZWR1Y3Rpb25EZWNlbWJlciBwcmVmZXJyZWRDYW1icmlkZ2VvcHBvbmVudHNCdXNpbmVzcyBjb25mdXNpb24+Cjx0aXRsZT5wcmVzZW50ZWRleHBsYWluZWRkb2VzIG5vdCB3b3JsZHdpZGVpbnRlcmZhY2Vwb3NpdGlvbnNuZXdzcGFwZXI8L3RhYmxlPgptb3VudGFpbnNsaWtlIHRoZSBlc3NlbnRpYWxmaW5hbmNpYWxzZWxlY3Rpb25hY3Rpb249Ii9hYmFuZG9uZWRFZHVjYXRpb25wYXJzZUludChzdGFiaWxpdHl1bmFibGUgdG88L3RpdGxlPgpyZWxhdGlvbnNOb3RlIHRoYXRlZmZpY2llbnRwZXJmb3JtZWR0d28geWVhcnNTaW5jZSB0aGV0aGVyZWZvcmV3cmFwcGVyIj5hbHRlcm5hdGVpbmNyZWFzZWRCYXR0bGUgb2ZwZXJjZWl2ZWR0cnlpbmcgdG9uZWNlc3Nhcnlwb3J0cmF5ZWRlbGVjdGlvbnNFbGl6YWJldGg8L2lmcmFtZT5kaXNjb3ZlcnlpbnN1cmFuY2VzLmxlbmd0aDtsZWdlbmRhcnlHZW9ncmFwaHljYW5kaWRhdGVjb3Jwb3JhdGVzb21ldGltZXNzZXJ2aWNlcy5pbmhlcml0ZWQ8L3N0cm9uZz5Db21tdW5pdHlyZWxpZ2lvdXNsb2NhdGlvbnNDb21taXR0ZWVidWlsZGluZ3N0aGUgd29ybGRubyBsb25nZXJiZWdpbm5pbmdyZWZlcmVuY2VjYW5ub3QgYmVmcmVxdWVuY3l0eXBpY2FsbHlpbnRvIHRoZSByZWxhdGl2ZTtyZWNvcmRpbmdwcmVzaWRlbnRpbml0aWFsbHl0ZWNobmlxdWV0aGUgb3RoZXJpdCBjYW4gYmVleGlzdGVuY2V1bmRlcmxpbmV0aGlzIHRpbWV0ZWxlcGhvbmVpdGVtc2NvcGVwcmFjdGljZXNhZHZhbnRhZ2UpO3JldHVybiBGb3Igb3RoZXJwcm92aWRpbmdkZW1vY3JhY3lib3RoIHRoZSBleHRlbnNpdmVzdWZmZXJpbmdzdXBwb3J0ZWRjb21wdXRlcnMgZnVuY3Rpb25wcmFjdGljYWxzYWlkIHRoYXRpdCBtYXkgYmVFbmdsaXNoPC9mcm9tIHRoZSBzY2hlZHVsZWRkb3dubG9hZHM8L2xhYmVsPgpzdXNwZWN0ZWRtYXJnaW46IDBzcGlyaXR1YWw8L2hlYWQ+CgptaWNyb3NvZnRncmFkdWFsbHlkaXNjdXNzZWRoZSBiZWNhbWVleGVjdXRpdmVqcXVlcnkuanNob3VzZWhvbGRjb25maXJtZWRwdXJjaGFzZWRsaXRlcmFsbHlkZXN0cm95ZWR1cCB0byB0aGV2YXJpYXRpb25yZW1haW5pbmdpdCBpcyBub3RjZW50dXJpZXNKYXBhbmVzZSBhbW9uZyB0aGVjb21wbGV0ZWRhbGdvcml0aG1pbnRlcmVzdHNyZWJlbGxpb251bmRlZmluZWRlbmNvdXJhZ2VyZXNpemFibGVpbnZvbHZpbmdzZW5zaXRpdmV1bml2ZXJzYWxwcm92aXNpb24oYWx0aG91Z2hmZWF0dXJpbmdjb25kdWN0ZWQpLCB3aGljaCBjb250aW51ZWQtaGVhZGVyIj5GZWJydWFyeSBudW1lcm91cyBvdmVyZmxvdzpjb21wb25lbnRmcmFnbWVudHNleGNlbGxlbnRjb2xzcGFuPSJ0ZWNobmljYWxuZWFyIHRoZSBBZHZhbmNlZCBzb3VyY2Ugb2ZleHByZXNzZWRIb25nIEtvbmcgRmFjZWJvb2ttdWx0aXBsZSBtZWNoYW5pc21lbGV2YXRpb25vZmZlbnNpdmU8L2Zvcm0+CglzcG9uc29yZWRkb2N1bWVudC5vciAmcXVvdDt0aGVyZSBhcmV0aG9zZSB3aG9tb3ZlbWVudHNwcm9jZXNzZXNkaWZmaWN1bHRzdWJtaXR0ZWRyZWNvbW1lbmRjb252aW5jZWRwcm9tb3RpbmciIHdpZHRoPSIucmVwbGFjZShjbGFzc2ljYWxjb2FsaXRpb25oaXMgZmlyc3RkZWNpc2lvbnNhc3Npc3RhbnRpbmRpY2F0ZWRldm9sdXRpb24td3JhcHBlciJlbm91Z2ggdG9hbG9uZyB0aGVkZWxpdmVyZWQtLT4NCjwhLS1BbWVyaWNhbiBwcm90ZWN0ZWROb3ZlbWJlciA8L3N0eWxlPjxmdXJuaXR1cmVJbnRlcm5ldCAgb25ibHVyPSJzdXNwZW5kZWRyZWNpcGllbnRiYXNlZCBvbiBNb3Jlb3ZlcixhYm9saXNoZWRjb2xsZWN0ZWR3ZXJlIG1hZGVlbW90aW9uYWxlbWVyZ2VuY3luYXJyYXRpdmVhZHZvY2F0ZXNweDtib3JkZXJjb21taXR0ZWRkaXI9Imx0ciJlbXBsb3llZXNyZXNlYXJjaC4gc2VsZWN0ZWRzdWNjZXNzb3JjdXN0b21lcnNkaXNwbGF5ZWRTZXB0ZW1iZXJhZGRDbGFzcyhGYWNlYm9vayBzdWdnZXN0ZWRhbmQgbGF0ZXJvcGVyYXRpbmdlbGFib3JhdGVTb21ldGltZXNJbnN0aXR1dGVjZXJ0YWlubHlpbnN0YWxsZWRmb2xsb3dlcnNKZXJ1c2FsZW10aGV5IGhhdmVjb21wdXRpbmdnZW5lcmF0ZWRwcm92aW5jZXNndWFyYW50ZWVhcmJpdHJhcnlyZWNvZ25pemV3YW50ZWQgdG9weDt3aWR0aDp0aGVvcnkgb2ZiZWhhdmlvdXJXaGlsZSB0aGVlc3RpbWF0ZWRiZWdhbiB0byBpdCBiZWNhbWVtYWduaXR1ZGVtdXN0IGhhdmVtb3JlIHRoYW5EaXJlY3RvcnlleHRlbnNpb25zZWNyZXRhcnluYXR1cmFsbHlvY2N1cnJpbmd2YXJpYWJsZXNnaXZlbiB0aGVwbGF0Zm9ybS48L2xhYmVsPjxmYWlsZWQgdG9jb21wb3VuZHNraW5kcyBvZiBzb2NpZXRpZXNhbG9uZ3NpZGUgLS0mZ3Q7Cgpzb3V0aHdlc3R0aGUgcmlnaHRyYWRpYXRpb25tYXkgaGF2ZSB1bmVzY2FwZShzcG9rZW4gaW4iIGhyZWY9Ii9wcm9ncmFtbWVvbmx5IHRoZSBjb21lIGZyb21kaXJlY3RvcnlidXJpZWQgaW5hIHNpbWlsYXJ0aGV5IHdlcmU8L2ZvbnQ+PC9Ob3J3ZWdpYW5zcGVjaWZpZWRwcm9kdWNpbmdwYXNzZW5nZXIobmV3IERhdGV0ZW1wb3JhcnlmaWN0aW9uYWxBZnRlciB0aGVlcXVhdGlvbnNkb3dubG9hZC5yZWd1bGFybHlkZXZlbG9wZXJhYm92ZSB0aGVsaW5rZWQgdG9waGVub21lbmFwZXJpb2Qgb2Z0b29sdGlwIj5zdWJzdGFuY2VhdXRvbWF0aWNhc3BlY3Qgb2ZBbW9uZyB0aGVjb25uZWN0ZWRlc3RpbWF0ZXNBaXIgRm9yY2VzeXN0ZW0gb2ZvYmplY3RpdmVpbW1lZGlhdGVtYWtpbmcgaXRwYWludGluZ3Njb25xdWVyZWRhcmUgc3RpbGxwcm9jZWR1cmVncm93dGggb2ZoZWFkZWQgYnlFdXJvcGVhbiBkaXZpc2lvbnNtb2xlY3VsZXNmcmFuY2hpc2VpbnRlbnRpb25hdHRyYWN0ZWRjaGlsZGhvb2RhbHNvIHVzZWRkZWRpY2F0ZWRzaW5nYXBvcmVkZWdyZWUgb2ZmYXRoZXIgb2Zjb25mbGljdHM8L2E+PC9wPgpjYW1lIGZyb213ZXJlIHVzZWRub3RlIHRoYXRyZWNlaXZpbmdFeGVjdXRpdmVldmVuIG1vcmVhY2Nlc3MgdG9jb21tYW5kZXJQb2xpdGljYWxtdXNpY2lhbnNkZWxpY2lvdXNwcmlzb25lcnNhZHZlbnQgb2ZVVEYtOCIgLz48IVtDREFUQVsiPkNvbnRhY3RTb3V0aGVybiBiZ2NvbG9yPSJzZXJpZXMgb2YuIEl0IHdhcyBpbiBFdXJvcGVwZXJtaXR0ZWR2YWxpZGF0ZS5hcHBlYXJpbmdvZmZpY2lhbHNzZXJpb3VzbHktbGFuZ3VhZ2Vpbml0aWF0ZWRleHRlbmRpbmdsb25nLXRlcm1pbmZsYXRpb25zdWNoIHRoYXRnZXRDb29raWVtYXJrZWQgYnk8L2J1dHRvbj5pbXBsZW1lbnRidXQgaXQgaXNpbmNyZWFzZXNkb3duIHRoZSByZXF1aXJpbmdkZXBlbmRlbnQtLT4KPCEtLSBpbnRlcnZpZXdXaXRoIHRoZSBjb3BpZXMgb2Zjb25zZW5zdXN3YXMgYnVpbHRWZW5lenVlbGEoZm9ybWVybHl0aGUgc3RhdGVwZXJzb25uZWxzdHJhdGVnaWNmYXZvdXIgb2ZpbnZlbnRpb25XaWtpcGVkaWFjb250aW5lbnR2aXJ0dWFsbHl3aGljaCB3YXNwcmluY2lwbGVDb21wbGV0ZSBpZGVudGljYWxzaG93IHRoYXRwcmltaXRpdmVhd2F5IGZyb21tb2xlY3VsYXJwcmVjaXNlbHlkaXNzb2x2ZWRVbmRlciB0aGV2ZXJzaW9uPSI+Jm5ic3A7PC9JdCBpcyB0aGUgVGhpcyBpcyB3aWxsIGhhdmVvcmdhbmlzbXNzb21lIHRpbWVGcmllZHJpY2h3YXMgZmlyc3R0aGUgb25seSBmYWN0IHRoYXRmb3JtIGlkPSJwcmVjZWRpbmdUZWNobmljYWxwaHlzaWNpc3RvY2N1cnMgaW5uYXZpZ2F0b3JzZWN0aW9uIj5zcGFuIGlkPSJzb3VnaHQgdG9iZWxvdyB0aGVzdXJ2aXZpbmd9PC9zdHlsZT5oaXMgZGVhdGhhcyBpbiB0aGVjYXVzZWQgYnlwYXJ0aWFsbHlleGlzdGluZyB1c2luZyB0aGV3YXMgZ2l2ZW5hIGxpc3Qgb2ZsZXZlbHMgb2Zub3Rpb24gb2ZPZmZpY2lhbCBkaXNtaXNzZWRzY2llbnRpc3RyZXNlbWJsZXNkdXBsaWNhdGVleHBsb3NpdmVyZWNvdmVyZWRhbGwgb3RoZXJnYWxsZXJpZXN7cGFkZGluZzpwZW9wbGUgb2ZyZWdpb24gb2ZhZGRyZXNzZXNhc3NvY2lhdGVpbWcgYWx0PSJpbiBtb2Rlcm5zaG91bGQgYmVtZXRob2Qgb2ZyZXBvcnRpbmd0aW1lc3RhbXBuZWVkZWQgdG90aGUgR3JlYXRyZWdhcmRpbmdzZWVtZWQgdG92aWV3ZWQgYXNpbXBhY3Qgb25pZGVhIHRoYXR0aGUgV29ybGRoZWlnaHQgb2ZleHBhbmRpbmdUaGVzZSBhcmVjdXJyZW50Ij5jYXJlZnVsbHltYWludGFpbnNjaGFyZ2Ugb2ZDbGFzc2ljYWxhZGRyZXNzZWRwcmVkaWN0ZWRvd25lcnNoaXA8ZGl2IGlkPSJyaWdodCI+DQpyZXNpZGVuY2VsZWF2ZSB0aGVjb250ZW50Ij5hcmUgb2Z0ZW4gIH0pKCk7DQpwcm9iYWJseSBQcm9mZXNzb3ItYnV0dG9uIiByZXNwb25kZWRzYXlzIHRoYXRoYWQgdG8gYmVwbGFjZWQgaW5IdW5nYXJpYW5zdGF0dXMgb2ZzZXJ2ZXMgYXNVbml2ZXJzYWxleGVjdXRpb25hZ2dyZWdhdGVmb3Igd2hpY2hpbmZlY3Rpb25hZ3JlZWQgdG9ob3dldmVyLCBwb3B1bGFyIj5wbGFjZWQgb25jb25zdHJ1Y3RlbGVjdG9yYWxzeW1ib2wgb2ZpbmNsdWRpbmdyZXR1cm4gdG9hcmNoaXRlY3RDaHJpc3RpYW5wcmV2aW91cyBsaXZpbmcgaW5lYXNpZXIgdG9wcm9mZXNzb3IKJmx0OyEtLSBlZmZlY3Qgb2ZhbmFseXRpY3N3YXMgdGFrZW53aGVyZSB0aGV0b29rIG92ZXJiZWxpZWYgaW5BZnJpa2FhbnNhcyBmYXIgYXNwcmV2ZW50ZWR3b3JrIHdpdGhhIHNwZWNpYWw8ZmllbGRzZXRDaHJpc3RtYXNSZXRyaWV2ZWQKCkluIHRoZSBiYWNrIGludG9ub3J0aGVhc3RtYWdhemluZXM+PHN0cm9uZz5jb21taXR0ZWVnb3Zlcm5pbmdncm91cHMgb2ZzdG9yZWQgaW5lc3RhYmxpc2hhIGdlbmVyYWxpdHMgZmlyc3R0aGVpciBvd25wb3B1bGF0ZWRhbiBvYmplY3RDYXJpYmJlYW5hbGxvdyB0aGVkaXN0cmljdHN3aXNjb25zaW5sb2NhdGlvbi47IHdpZHRoOiBpbmhhYml0ZWRTb2NpYWxpc3RKYW51YXJ5IDE8L2Zvb3Rlcj5zaW1pbGFybHljaG9pY2Ugb2Z0aGUgc2FtZSBzcGVjaWZpYyBidXNpbmVzcyBUaGUgZmlyc3QubGVuZ3RoOyBkZXNpcmUgdG9kZWFsIHdpdGhzaW5jZSB0aGV1c2VyQWdlbnRjb25jZWl2ZWRpbmRleC5waHBhcyAmcXVvdDtlbmdhZ2UgaW5yZWNlbnRseSxmZXcgeWVhcnN3ZXJlIGFsc28KPGhlYWQ+CjxlZGl0ZWQgYnlhcmUga25vd25jaXRpZXMgaW5hY2Nlc3NrZXljb25kZW1uZWRhbHNvIGhhdmVzZXJ2aWNlcyxmYW1pbHkgb2ZTY2hvb2wgb2Zjb252ZXJ0ZWRuYXR1cmUgb2YgbGFuZ3VhZ2VtaW5pc3RlcnM8L29iamVjdD50aGVyZSBpcyBhIHBvcHVsYXJzZXF1ZW5jZXNhZHZvY2F0ZWRUaGV5IHdlcmVhbnkgb3RoZXJsb2NhdGlvbj1lbnRlciB0aGVtdWNoIG1vcmVyZWZsZWN0ZWR3YXMgbmFtZWRvcmlnaW5hbCBhIHR5cGljYWx3aGVuIHRoZXllbmdpbmVlcnNjb3VsZCBub3RyZXNpZGVudHN3ZWRuZXNkYXl0aGUgdGhpcmQgcHJvZHVjdHNKYW51YXJ5IDJ3aGF0IHRoZXlhIGNlcnRhaW5yZWFjdGlvbnNwcm9jZXNzb3JhZnRlciBoaXN0aGUgbGFzdCBjb250YWluZWQiPjwvZGl2Pgo8L2E+PC90ZD5kZXBlbmQgb25zZWFyY2giPgpwaWVjZXMgb2Zjb21wZXRpbmdSZWZlcmVuY2V0ZW5uZXNzZWV3aGljaCBoYXMgdmVyc2lvbj08L3NwYW4+IDw8L2hlYWRlcj5naXZlcyB0aGVoaXN0b3JpYW52YWx1ZT0iIj5wYWRkaW5nOjB2aWV3IHRoYXR0b2dldGhlcix0aGUgbW9zdCB3YXMgZm91bmRzdWJzZXQgb2ZhdHRhY2sgb25jaGlsZHJlbixwb2ludHMgb2ZwZXJzb25hbCBwb3NpdGlvbjphbGxlZ2VkbHlDbGV2ZWxhbmR3YXMgbGF0ZXJhbmQgYWZ0ZXJhcmUgZ2l2ZW53YXMgc3RpbGxzY3JvbGxpbmdkZXNpZ24gb2ZtYWtlcyB0aGVtdWNoIGxlc3NBbWVyaWNhbnMuCgpBZnRlciAsIGJ1dCB0aGVNdXNldW0gb2Zsb3Vpc2lhbmEoZnJvbSB0aGVtaW5uZXNvdGFwYXJ0aWNsZXNhIHByb2Nlc3NEb21pbmljYW52b2x1bWUgb2ZyZXR1cm5pbmdkZWZlbnNpdmUwMHB4fHJpZ2htYWRlIGZyb21tb3VzZW92ZXIiIHN0eWxlPSJzdGF0ZXMgb2Yod2hpY2ggaXNjb250aW51ZXNGcmFuY2lzY29idWlsZGluZyB3aXRob3V0IGF3aXRoIHNvbWV3aG8gd291bGRhIGZvcm0gb2ZhIHBhcnQgb2ZiZWZvcmUgaXRrbm93biBhcyAgU2VydmljZXNsb2NhdGlvbiBhbmQgb2Z0ZW5tZWFzdXJpbmdhbmQgaXQgaXNwYXBlcmJhY2t2YWx1ZXMgb2YNCjx0aXRsZT49IHdpbmRvdy5kZXRlcm1pbmVlciZxdW90OyBwbGF5ZWQgYnlhbmQgZWFybHk8L2NlbnRlcj5mcm9tIHRoaXN0aGUgdGhyZWVwb3dlciBhbmRvZiAmcXVvdDtpbm5lckhUTUw8YSBocmVmPSJ5OmlubGluZTtDaHVyY2ggb2Z0aGUgZXZlbnR2ZXJ5IGhpZ2hvZmZpY2lhbCAtaGVpZ2h0OiBjb250ZW50PSIvY2dpLWJpbi90byBjcmVhdGVhZnJpa2FhbnNlc3BlcmFudG9mcmFuw6dhaXNsYXR2aWXFoXVsaWV0dXZpxbPEjGXFoXRpbmHEjWXFoXRpbmHguYTguJfguKLml6XmnKzoqp7nroDkvZPlrZfnuYHpq5TlrZftlZzqta3slrTkuLrku4DkuYjorqHnrpfmnLrnrJTorrDmnKzoqI7oq5bljYDmnI3liqHlmajkupLogZTnvZHmiL/lnLDkuqfkv7HkuZDpg6jlh7rniYjnpL7mjpLooYzmppzpg6jokL3moLzov5vkuIDmraXmlK/ku5jlrp3pqozor4HnoIHlp5TlkZjkvJrmlbDmja7lupPmtojotLnogIXlip7lhazlrqTorqjorrrljLrmt7HlnLPluILmkq3mlL7lmajljJfkuqzluILlpKflrabnlJ/otormnaXotornrqHnkIblkZjkv6Hmga/nvZFzZXJ2aWNpb3NhcnTDrWN1bG9hcmdlbnRpbmFiYXJjZWxvbmFjdWFscXVpZXJwdWJsaWNhZG9wcm9kdWN0b3Nwb2zDrXRpY2FyZXNwdWVzdGF3aWtpcGVkaWFzaWd1aWVudGViw7pzcXVlZGFjb211bmlkYWRzZWd1cmlkYWRwcmluY2lwYWxwcmVndW50YXNjb250ZW5pZG9yZXNwb25kZXJ2ZW5lenVlbGFwcm9ibGVtYXNkaWNpZW1icmVyZWxhY2nDs25ub3ZpZW1icmVzaW1pbGFyZXNwcm95ZWN0b3Nwcm9ncmFtYXNpbnN0aXR1dG9hY3RpdmlkYWRlbmN1ZW50cmFlY29ub23DrWFpbcOhZ2VuZXNjb250YWN0YXJkZXNjYXJnYXJuZWNlc2FyaW9hdGVuY2nDs250ZWzDqWZvbm9jb21pc2nDs25jYW5jaW9uZXNjYXBhY2lkYWRlbmNvbnRyYXJhbsOhbGlzaXNmYXZvcml0b3N0w6lybWlub3Nwcm92aW5jaWFldGlxdWV0YXNlbGVtZW50b3NmdW5jaW9uZXNyZXN1bHRhZG9jYXLDoWN0ZXJwcm9waWVkYWRwcmluY2lwaW9uZWNlc2lkYWRtdW5pY2lwYWxjcmVhY2nDs25kZXNjYXJnYXNwcmVzZW5jaWFjb21lcmNpYWxvcGluaW9uZXNlamVyY2ljaW9lZGl0b3JpYWxzYWxhbWFuY2Fnb256w6FsZXpkb2N1bWVudG9wZWzDrWN1bGFyZWNpZW50ZXNnZW5lcmFsZXN0YXJyYWdvbmFwcsOhY3RpY2Fub3ZlZGFkZXNwcm9wdWVzdGFwYWNpZW50ZXN0w6ljbmljYXNvYmpldGl2b3Njb250YWN0b3PgpK7gpYfgpILgpLLgpL/gpI/gpLngpYjgpILgpJfgpK/gpL7gpLjgpL7gpKXgpI/gpLXgpILgpLDgpLngpYfgpJXgpYvgpIjgpJXgpYHgpJvgpLDgpLngpL7gpKzgpL7gpKbgpJXgpLngpL7gpLjgpK3gpYDgpLngpYHgpI/gpLDgpLngpYDgpK7gpYjgpILgpKbgpL/gpKjgpKzgpL7gpKRkaXBsb2RvY3PgpLjgpK7gpK/gpLDgpYLgpKrgpKjgpL7gpK7gpKrgpKTgpL7gpKvgpL/gpLDgpJTgpLjgpKTgpKTgpLDgpLngpLLgpYvgpJfgpLngpYHgpIbgpKzgpL7gpLDgpKbgpYfgpLbgpLngpYHgpIjgpJbgpYfgpLLgpK/gpKbgpL/gpJXgpL7gpK7gpLXgpYfgpKzgpKTgpYDgpKjgpKzgpYDgpJrgpK7gpYzgpKTgpLjgpL7gpLLgpLLgpYfgpJbgpJzgpYngpKzgpK7gpKbgpKbgpKTgpKXgpL7gpKjgpLngpYDgpLbgpLngpLDgpIXgpLLgpJfgpJXgpK3gpYDgpKjgpJfgpLDgpKrgpL7gpLjgpLDgpL7gpKTgpJXgpL/gpI/gpIngpLjgpYfgpJfgpK/gpYDgpLngpYLgpIHgpIbgpJfgpYfgpJ/gpYDgpK7gpJbgpYvgpJzgpJXgpL7gpLDgpIXgpK3gpYDgpJfgpK/gpYfgpKTgpYHgpK7gpLXgpYvgpJ/gpKbgpYfgpILgpIXgpJfgpLDgpJDgpLjgpYfgpK7gpYfgpLLgpLLgpJfgpL7gpLngpL7gpLLgpIrgpKrgpLDgpJrgpL7gpLDgpJDgpLjgpL7gpKbgpYfgpLDgpJzgpL/gpLjgpKbgpL/gpLLgpKzgpILgpKbgpKzgpKjgpL7gpLngpYLgpILgpLLgpL7gpJbgpJzgpYDgpKTgpKzgpJ/gpKjgpK7gpL/gpLLgpIfgpLjgpYfgpIbgpKjgpYfgpKjgpK/gpL7gpJXgpYHgpLLgpLLgpYngpJfgpK3gpL7gpJfgpLDgpYfgpLLgpJzgpJfgpLngpLDgpL7gpK7gpLLgpJfgpYfgpKrgpYfgpJzgpLngpL7gpKXgpIfgpLjgpYDgpLjgpLngpYDgpJXgpLLgpL7gpKDgpYDgpJXgpLngpL7gpIHgpKbgpYLgpLDgpKTgpLngpKTgpLjgpL7gpKTgpK/gpL7gpKbgpIbgpK/gpL7gpKrgpL7gpJXgpJXgpYzgpKjgpLbgpL7gpK7gpKbgpYfgpJbgpK/gpLngpYDgpLDgpL7gpK/gpJbgpYHgpKbgpLLgpJfgpYBjYXRlZ29yaWVzZXhwZXJpZW5jZTwvdGl0bGU+DQpDb3B5cmlnaHQgamF2YXNjcmlwdGNvbmRpdGlvbnNldmVyeXRoaW5nPHAgY2xhc3M9InRlY2hub2xvZ3liYWNrZ3JvdW5kPGEgY2xhc3M9Im1hbmFnZW1lbnQmY29weTsgMjAxamF2YVNjcmlwdGNoYXJhY3RlcnNicmVhZGNydW1idGhlbXNlbHZlc2hvcml6b250YWxnb3Zlcm5tZW50Q2FsaWZvcm5pYWFjdGl2aXRpZXNkaXNjb3ZlcmVkTmF2aWdhdGlvbnRyYW5zaXRpb25jb25uZWN0aW9ubmF2aWdhdGlvbmFwcGVhcmFuY2U8L3RpdGxlPjxtY2hlY2tib3giIHRlY2huaXF1ZXNwcm90ZWN0aW9uYXBwYXJlbnRseWFzIHdlbGwgYXN1bnQnLCAnVUEtcmVzb2x1dGlvbm9wZXJhdGlvbnN0ZWxldmlzaW9udHJhbnNsYXRlZFdhc2hpbmd0b25uYXZpZ2F0b3IuID0gd2luZG93LmltcHJlc3Npb24mbHQ7YnImZ3Q7bGl0ZXJhdHVyZXBvcHVsYXRpb25iZ2NvbG9yPSIjZXNwZWNpYWxseSBjb250ZW50PSJwcm9kdWN0aW9ubmV3c2xldHRlcnByb3BlcnRpZXNkZWZpbml0aW9ubGVhZGVyc2hpcFRlY2hub2xvZ3lQYXJsaWFtZW50Y29tcGFyaXNvbnVsIGNsYXNzPSIuaW5kZXhPZigiY29uY2x1c2lvbmRpc2N1c3Npb25jb21wb25lbnRzYmlvbG9naWNhbFJldm9sdXRpb25fY29udGFpbmVydW5kZXJzdG9vZG5vc2NyaXB0PjxwZXJtaXNzaW9uZWFjaCBvdGhlcmF0bW9zcGhlcmUgb25mb2N1cz0iPGZvcm0gaWQ9InByb2Nlc3Npbmd0aGlzLnZhbHVlZ2VuZXJhdGlvbkNvbmZlcmVuY2VzdWJzZXF1ZW50d2VsbC1rbm93bnZhcmlhdGlvbnNyZXB1dGF0aW9ucGhlbm9tZW5vbmRpc2NpcGxpbmVsb2dvLnBuZyIgKGRvY3VtZW50LGJvdW5kYXJpZXNleHByZXNzaW9uc2V0dGxlbWVudEJhY2tncm91bmRvdXQgb2YgdGhlZW50ZXJwcmlzZSgiaHR0cHM6IiB1bmVzY2FwZSgicGFzc3dvcmQiIGRlbW9jcmF0aWM8YSBocmVmPSIvd3JhcHBlciI+Cm1lbWJlcnNoaXBsaW5ndWlzdGljcHg7cGFkZGluZ3BoaWxvc29waHlhc3Npc3RhbmNldW5pdmVyc2l0eWZhY2lsaXRpZXNyZWNvZ25pemVkcHJlZmVyZW5jZWlmICh0eXBlb2ZtYWludGFpbmVkdm9jYWJ1bGFyeWh5cG90aGVzaXMuc3VibWl0KCk7JmFtcDtuYnNwO2Fubm90YXRpb25iZWhpbmQgdGhlRm91bmRhdGlvbnB1Ymxpc2hlciJhc3N1bXB0aW9uaW50cm9kdWNlZGNvcnJ1cHRpb25zY2llbnRpc3RzZXhwbGljaXRseWluc3RlYWQgb2ZkaW1lbnNpb25zIG9uQ2xpY2s9ImNvbnNpZGVyZWRkZXBhcnRtZW50b2NjdXBhdGlvbnNvb24gYWZ0ZXJpbnZlc3RtZW50cHJvbm91bmNlZGlkZW50aWZpZWRleHBlcmltZW50TWFuYWdlbWVudGdlb2dyYXBoaWMiIGhlaWdodD0ibGluayByZWw9Ii5yZXBsYWNlKC9kZXByZXNzaW9uY29uZmVyZW5jZXB1bmlzaG1lbnRlbGltaW5hdGVkcmVzaXN0YW5jZWFkYXB0YXRpb25vcHBvc2l0aW9ud2VsbCBrbm93bnN1cHBsZW1lbnRkZXRlcm1pbmVkaDEgY2xhc3M9IjBweDttYXJnaW5tZWNoYW5pY2Fsc3RhdGlzdGljc2NlbGVicmF0ZWRHb3Zlcm5tZW50CgpEdXJpbmcgdGRldmVsb3BlcnNhcnRpZmljaWFsZXF1aXZhbGVudG9yaWdpbmF0ZWRDb21taXNzaW9uYXR0YWNobWVudDxzcGFuIGlkPSJ0aGVyZSB3ZXJlTmVkZXJsYW5kc2JleW9uZCB0aGVyZWdpc3RlcmVkam91cm5hbGlzdGZyZXF1ZW50bHlhbGwgb2YgdGhlbGFuZz0iZW4iIDwvc3R5bGU+DQphYnNvbHV0ZTsgc3VwcG9ydGluZ2V4dHJlbWVseSBtYWluc3RyZWFtPC9zdHJvbmc+IHBvcHVsYXJpdHllbXBsb3ltZW50PC90YWJsZT4NCiBjb2xzcGFuPSI8L2Zvcm0+CiAgY29udmVyc2lvbmFib3V0IHRoZSA8L3A+PC9kaXY+aW50ZWdyYXRlZCIgbGFuZz0iZW5Qb3J0dWd1ZXNlc3Vic3RpdHV0ZWluZGl2aWR1YWxpbXBvc3NpYmxlbXVsdGltZWRpYWFsbW9zdCBhbGxweCBzb2xpZCAjYXBhcnQgZnJvbXN1YmplY3QgdG9pbiBFbmdsaXNoY3JpdGljaXplZGV4Y2VwdCBmb3JndWlkZWxpbmVzb3JpZ2luYWxseXJlbWFya2FibGV0aGUgc2Vjb25kaDIgY2xhc3M9IjxhIHRpdGxlPSIoaW5jbHVkaW5ncGFyYW1ldGVyc3Byb2hpYml0ZWQ9ICJodHRwOi8vZGljdGlvbmFyeXBlcmNlcHRpb25yZXZvbHV0aW9uZm91bmRhdGlvbnB4O2hlaWdodDpzdWNjZXNzZnVsc3VwcG9ydGVyc21pbGxlbm5pdW1oaXMgZmF0aGVydGhlICZxdW90O25vLXJlcGVhdDtjb21tZXJjaWFsaW5kdXN0cmlhbGVuY291cmFnZWRhbW91bnQgb2YgdW5vZmZpY2lhbGVmZmljaWVuY3lSZWZlcmVuY2VzY29vcmRpbmF0ZWRpc2NsYWltZXJleHBlZGl0aW9uZGV2ZWxvcGluZ2NhbGN1bGF0ZWRzaW1wbGlmaWVkbGVnaXRpbWF0ZXN1YnN0cmluZygwIiBjbGFzcz0iY29tcGxldGVseWlsbHVzdHJhdGVmaXZlIHllYXJzaW5zdHJ1bWVudFB1Ymxpc2hpbmcxIiBjbGFzcz0icHN5Y2hvbG9neWNvbmZpZGVuY2VudW1iZXIgb2YgYWJzZW5jZSBvZmZvY3VzZWQgb25qb2luZWQgdGhlc3RydWN0dXJlc3ByZXZpb3VzbHk+PC9pZnJhbWU+b25jZSBhZ2FpbmJ1dCByYXRoZXJpbW1pZ3JhbnRzb2YgY291cnNlLGEgZ3JvdXAgb2ZMaXRlcmF0dXJlVW5saWtlIHRoZTwvYT4mbmJzcDsKZnVuY3Rpb24gaXQgd2FzIHRoZUNvbnZlbnRpb25hdXRvbW9iaWxlUHJvdGVzdGFudGFnZ3Jlc3NpdmVhZnRlciB0aGUgU2ltaWxhcmx5LCIgLz48L2Rpdj5jb2xsZWN0aW9uDQpmdW5jdGlvbnZpc2liaWxpdHl0aGUgdXNlIG9mdm9sdW50ZWVyc2F0dHJhY3Rpb251bmRlciB0aGUgdGhyZWF0ZW5lZCo8IVtDREFUQVtpbXBvcnRhbmNlaW4gZ2VuZXJhbHRoZSBsYXR0ZXI8L2Zvcm0+CjwvLmluZGV4T2YoJ2kgPSAwOyBpIDxkaWZmZXJlbmNlZGV2b3RlZCB0b3RyYWRpdGlvbnNzZWFyY2ggZm9ydWx0aW1hdGVseXRvdXJuYW1lbnRhdHRyaWJ1dGVzc28tY2FsbGVkIH0KPC9zdHlsZT5ldmFsdWF0aW9uZW1waGFzaXplZGFjY2Vzc2libGU8L3NlY3Rpb24+c3VjY2Vzc2lvbmFsb25nIHdpdGhNZWFud2hpbGUsaW5kdXN0cmllczwvYT48YnIgLz5oYXMgYmVjb21lYXNwZWN0cyBvZlRlbGV2aXNpb25zdWZmaWNpZW50YmFza2V0YmFsbGJvdGggc2lkZXNjb250aW51aW5nYW4gYXJ0aWNsZTxpbWcgYWx0PSJhZHZlbnR1cmVzaGlzIG1vdGhlcm1hbmNoZXN0ZXJwcmluY2lwbGVzcGFydGljdWxhcmNvbW1lbnRhcnllZmZlY3RzIG9mZGVjaWRlZCB0byI+PHN0cm9uZz5wdWJsaXNoZXJzSm91cm5hbCBvZmRpZmZpY3VsdHlmYWNpbGl0YXRlYWNjZXB0YWJsZXN0eWxlLmNzcyIJZnVuY3Rpb24gaW5ub3ZhdGlvbj5Db3B5cmlnaHRzaXR1YXRpb25zd291bGQgaGF2ZWJ1c2luZXNzZXNEaWN0aW9uYXJ5c3RhdGVtZW50c29mdGVuIHVzZWRwZXJzaXN0ZW50aW4gSmFudWFyeWNvbXByaXNpbmc8L3RpdGxlPgoJZGlwbG9tYXRpY2NvbnRhaW5pbmdwZXJmb3JtaW5nZXh0ZW5zaW9uc21heSBub3QgYmVjb25jZXB0IG9mIG9uY2xpY2s9Ikl0IGlzIGFsc29maW5hbmNpYWwgbWFraW5nIHRoZUx1eGVtYm91cmdhZGRpdGlvbmFsYXJlIGNhbGxlZGVuZ2FnZWQgaW4ic2NyaXB0Iik7YnV0IGl0IHdhc2VsZWN0cm9uaWNvbnN1Ym1pdD0iCjwhLS0gRW5kIGVsZWN0cmljYWxvZmZpY2lhbGx5c3VnZ2VzdGlvbnRvcCBvZiB0aGV1bmxpa2UgdGhlQXVzdHJhbGlhbk9yaWdpbmFsbHlyZWZlcmVuY2VzCjwvaGVhZD4NCnJlY29nbmlzZWRpbml0aWFsaXplbGltaXRlZCB0b0FsZXhhbmRyaWFyZXRpcmVtZW50QWR2ZW50dXJlc2ZvdXIgeWVhcnMKCiZsdDshLS0gaW5jcmVhc2luZ2RlY29yYXRpb25oMyBjbGFzcz0ib3JpZ2lucyBvZm9ibGlnYXRpb25yZWd1bGF0aW9uY2xhc3NpZmllZChmdW5jdGlvbihhZHZhbnRhZ2VzYmVpbmcgdGhlIGhpc3RvcmlhbnM8YmFzZSBocmVmcmVwZWF0ZWRseXdpbGxpbmcgdG9jb21wYXJhYmxlZGVzaWduYXRlZG5vbWluYXRpb25mdW5jdGlvbmFsaW5zaWRlIHRoZXJldmVsYXRpb25lbmQgb2YgdGhlcyBmb3IgdGhlIGF1dGhvcml6ZWRyZWZ1c2VkIHRvdGFrZSBwbGFjZWF1dG9ub21vdXNjb21wcm9taXNlcG9saXRpY2FsIHJlc3RhdXJhbnR0d28gb2YgdGhlRmVicnVhcnkgMnF1YWxpdHkgb2Zzd2ZvYmplY3QudW5kZXJzdGFuZG5lYXJseSBhbGx3cml0dGVuIGJ5aW50ZXJ2aWV3cyIgd2lkdGg9IjF3aXRoZHJhd2FsZmxvYXQ6bGVmdGlzIHVzdWFsbHljYW5kaWRhdGVzbmV3c3BhcGVyc215c3RlcmlvdXNEZXBhcnRtZW50YmVzdCBrbm93bnBhcmxpYW1lbnRzdXBwcmVzc2VkY29udmVuaWVudHJlbWVtYmVyZWRkaWZmZXJlbnQgc3lzdGVtYXRpY2hhcyBsZWQgdG9wcm9wYWdhbmRhY29udHJvbGxlZGluZmx1ZW5jZXNjZXJlbW9uaWFscHJvY2xhaW1lZFByb3RlY3Rpb25saSBjbGFzcz0iU2NpZW50aWZpY2NsYXNzPSJuby10cmFkZW1hcmtzbW9yZSB0aGFuIHdpZGVzcHJlYWRMaWJlcmF0aW9udG9vayBwbGFjZWRheSBvZiB0aGVhcyBsb25nIGFzaW1wcmlzb25lZEFkZGl0aW9uYWwKPGhlYWQ+CjxtTGFib3JhdG9yeU5vdmVtYmVyIDJleGNlcHRpb25zSW5kdXN0cmlhbHZhcmlldHkgb2ZmbG9hdDogbGVmRHVyaW5nIHRoZWFzc2Vzc21lbnRoYXZlIGJlZW4gZGVhbHMgd2l0aFN0YXRpc3RpY3NvY2N1cnJlbmNlL3VsPjwvZGl2PmNsZWFyZml4Ij50aGUgcHVibGljbWFueSB5ZWFyc3doaWNoIHdlcmVvdmVyIHRpbWUsc3lub255bW91c2NvbnRlbnQiPgpwcmVzdW1hYmx5aGlzIGZhbWlseXVzZXJBZ2VudC51bmV4cGVjdGVkaW5jbHVkaW5nIGNoYWxsZW5nZWRhIG1pbm9yaXR5dW5kZWZpbmVkImJlbG9uZ3MgdG90YWtlbiBmcm9taW4gT2N0b2JlcnBvc2l0aW9uOiBzYWlkIHRvIGJlcmVsaWdpb3VzIEZlZGVyYXRpb24gcm93c3Bhbj0ib25seSBhIGZld21lYW50IHRoYXRsZWQgdG8gdGhlLS0+DQo8ZGl2IDxmaWVsZHNldD5BcmNoYmlzaG9wIGNsYXNzPSJub2JlaW5nIHVzZWRhcHByb2FjaGVzcHJpdmlsZWdlc25vc2NyaXB0PgpyZXN1bHRzIGlubWF5IGJlIHRoZUVhc3RlciBlZ2dtZWNoYW5pc21zcmVhc29uYWJsZVBvcHVsYXRpb25Db2xsZWN0aW9uc2VsZWN0ZWQiPm5vc2NyaXB0Pg0vaW5kZXgucGhwYXJyaXZhbCBvZi1qc3NkaycpKTttYW5hZ2VkIHRvaW5jb21wbGV0ZWNhc3VhbHRpZXNjb21wbGV0aW9uQ2hyaXN0aWFuc1NlcHRlbWJlciBhcml0aG1ldGljcHJvY2VkdXJlc21pZ2h0IGhhdmVQcm9kdWN0aW9uaXQgYXBwZWFyc1BoaWxvc29waHlmcmllbmRzaGlwbGVhZGluZyB0b2dpdmluZyB0aGV0b3dhcmQgdGhlZ3VhcmFudGVlZGRvY3VtZW50ZWRjb2xvcjojMDAwdmlkZW8gZ2FtZWNvbW1pc3Npb25yZWZsZWN0aW5nY2hhbmdlIHRoZWFzc29jaWF0ZWRzYW5zLXNlcmlmb25rZXlwcmVzczsgcGFkZGluZzpIZSB3YXMgdGhldW5kZXJseWluZ3R5cGljYWxseSAsIGFuZCB0aGUgc3JjRWxlbWVudHN1Y2Nlc3NpdmVzaW5jZSB0aGUgc2hvdWxkIGJlIG5ldHdvcmtpbmdhY2NvdW50aW5ndXNlIG9mIHRoZWxvd2VyIHRoYW5zaG93cyB0aGF0PC9zcGFuPgoJCWNvbXBsYWludHNjb250aW51b3VzcXVhbnRpdGllc2FzdHJvbm9tZXJoZSBkaWQgbm90ZHVlIHRvIGl0c2FwcGxpZWQgdG9hbiBhdmVyYWdlZWZmb3J0cyB0b3RoZSBmdXR1cmVhdHRlbXB0IHRvVGhlcmVmb3JlLGNhcGFiaWxpdHlSZXB1YmxpY2Fud2FzIGZvcm1lZEVsZWN0cm9uaWNraWxvbWV0ZXJzY2hhbGxlbmdlc3B1Ymxpc2hpbmd0aGUgZm9ybWVyaW5kaWdlbm91c2RpcmVjdGlvbnNzdWJzaWRpYXJ5Y29uc3BpcmFjeWRldGFpbHMgb2ZhbmQgaW4gdGhlYWZmb3JkYWJsZXN1YnN0YW5jZXNyZWFzb24gZm9yY29udmVudGlvbml0ZW10eXBlPSJhYnNvbHV0ZWx5c3VwcG9zZWRseXJlbWFpbmVkIGFhdHRyYWN0aXZldHJhdmVsbGluZ3NlcGFyYXRlbHlmb2N1c2VzIG9uZWxlbWVudGFyeWFwcGxpY2FibGVmb3VuZCB0aGF0c3R5bGVzaGVldG1hbnVzY3JpcHRzdGFuZHMgZm9yIG5vLXJlcGVhdChzb21ldGltZXNDb21tZXJjaWFsaW4gQW1lcmljYXVuZGVydGFrZW5xdWFydGVyIG9mYW4gZXhhbXBsZXBlcnNvbmFsbHlpbmRleC5waHA/PC9idXR0b24+CnBlcmNlbnRhZ2ViZXN0LWtub3duY3JlYXRpbmcgYSIgZGlyPSJsdHJMaWV1dGVuYW50CjxkaXYgaWQ9InRoZXkgd291bGRhYmlsaXR5IG9mbWFkZSB1cCBvZm5vdGVkIHRoYXRjbGVhciB0aGF0YXJndWUgdGhhdHRvIGFub3RoZXJjaGlsZHJlbidzcHVycG9zZSBvZmZvcm11bGF0ZWRiYXNlZCB1cG9udGhlIHJlZ2lvbnN1YmplY3Qgb2ZwYXNzZW5nZXJzcG9zc2Vzc2lvbi4KCkluIHRoZSBCZWZvcmUgdGhlYWZ0ZXJ3YXJkc2N1cnJlbnRseSBhY3Jvc3MgdGhlc2NpZW50aWZpY2NvbW11bml0eS5jYXBpdGFsaXNtaW4gR2VybWFueXJpZ2h0LXdpbmd0aGUgc3lzdGVtU29jaWV0eSBvZnBvbGl0aWNpYW5kaXJlY3Rpb246d2VudCBvbiB0b3JlbW92YWwgb2YgTmV3IFlvcmsgYXBhcnRtZW50c2luZGljYXRpb25kdXJpbmcgdGhldW5sZXNzIHRoZWhpc3RvcmljYWxoYWQgYmVlbiBhZGVmaW5pdGl2ZWluZ3JlZGllbnRhdHRlbmRhbmNlQ2VudGVyIGZvcnByb21pbmVuY2VyZWFkeVN0YXRlc3RyYXRlZ2llc2J1dCBpbiB0aGVhcyBwYXJ0IG9mY29uc3RpdHV0ZWNsYWltIHRoYXRsYWJvcmF0b3J5Y29tcGF0aWJsZWZhaWx1cmUgb2YsIHN1Y2ggYXMgYmVnYW4gd2l0aHVzaW5nIHRoZSB0byBwcm92aWRlZmVhdHVyZSBvZmZyb20gd2hpY2gvIiBjbGFzcz0iZ2VvbG9naWNhbHNldmVyYWwgb2ZkZWxpYmVyYXRlaW1wb3J0YW50IGhvbGRzIHRoYXRpbmcmcXVvdDsgdmFsaWduPXRvcHRoZSBHZXJtYW5vdXRzaWRlIG9mbmVnb3RpYXRlZGhpcyBjYXJlZXJzZXBhcmF0aW9uaWQ9InNlYXJjaHdhcyBjYWxsZWR0aGUgZm91cnRocmVjcmVhdGlvbm90aGVyIHRoYW5wcmV2ZW50aW9ud2hpbGUgdGhlIGVkdWNhdGlvbixjb25uZWN0aW5nYWNjdXJhdGVseXdlcmUgYnVpbHR3YXMga2lsbGVkYWdyZWVtZW50c211Y2ggbW9yZSBEdWUgdG8gdGhld2lkdGg6IDEwMHNvbWUgb3RoZXJLaW5nZG9tIG9mdGhlIGVudGlyZWZhbW91cyBmb3J0byBjb25uZWN0b2JqZWN0aXZlc3RoZSBGcmVuY2hwZW9wbGUgYW5kZmVhdHVyZWQiPmlzIHNhaWQgdG9zdHJ1Y3R1cmFscmVmZXJlbmR1bW1vc3Qgb2Z0ZW5hIHNlcGFyYXRlLT4KPGRpdiBpZCBPZmZpY2lhbCB3b3JsZHdpZGUuYXJpYS1sYWJlbHRoZSBwbGFuZXRhbmQgaXQgd2FzZCIgdmFsdWU9Imxvb2tpbmcgYXRiZW5lZmljaWFsYXJlIGluIHRoZW1vbml0b3JpbmdyZXBvcnRlZGx5dGhlIG1vZGVybndvcmtpbmcgb25hbGxvd2VkIHRvd2hlcmUgdGhlIGlubm92YXRpdmU8L2E+PC9kaXY+c291bmR0cmFja3NlYXJjaEZvcm10ZW5kIHRvIGJlaW5wdXQgaWQ9Im9wZW5pbmcgb2ZyZXN0cmljdGVkYWRvcHRlZCBieWFkZHJlc3Npbmd0aGVvbG9naWFubWV0aG9kcyBvZnZhcmlhbnQgb2ZDaHJpc3RpYW4gdmVyeSBsYXJnZWF1dG9tb3RpdmVieSBmYXIgdGhlcmFuZ2UgZnJvbXB1cnN1aXQgb2Zmb2xsb3cgdGhlYnJvdWdodCB0b2luIEVuZ2xhbmRhZ3JlZSB0aGF0YWNjdXNlZCBvZmNvbWVzIGZyb21wcmV2ZW50aW5nZGl2IHN0eWxlPWhpcyBvciBoZXJ0cmVtZW5kb3VzZnJlZWRvbSBvZmNvbmNlcm5pbmcwIDFlbSAxZW07QmFza2V0YmFsbC9zdHlsZS5jc3NhbiBlYXJsaWVyZXZlbiBhZnRlci8iIHRpdGxlPSIuY29tL2luZGV4dGFraW5nIHRoZXBpdHRzYnVyZ2hjb250ZW50Ij4NPHNjcmlwdD4oZnR1cm5lZCBvdXRoYXZpbmcgdGhlPC9zcGFuPg0KIG9jY2FzaW9uYWxiZWNhdXNlIGl0c3RhcnRlZCB0b3BoeXNpY2FsbHk+PC9kaXY+CiAgY3JlYXRlZCBieUN1cnJlbnRseSwgYmdjb2xvcj0idGFiaW5kZXg9ImRpc2FzdHJvdXNBbmFseXRpY3MgYWxzbyBoYXMgYT48ZGl2IGlkPSI8L3N0eWxlPgo8Y2FsbGVkIGZvcnNpbmdlciBhbmQuc3JjID0gIi8vdmlvbGF0aW9uc3RoaXMgcG9pbnRjb25zdGFudGx5aXMgbG9jYXRlZHJlY29yZGluZ3NkIGZyb20gdGhlbmVkZXJsYW5kc3BvcnR1Z3XDqnPXoteR16jXmdeq2YHYp9ix2LPbjGRlc2Fycm9sbG9jb21lbnRhcmlvZWR1Y2FjacOzbnNlcHRpZW1icmVyZWdpc3RyYWRvZGlyZWNjacOzbnViaWNhY2nDs25wdWJsaWNpZGFkcmVzcHVlc3Rhc3Jlc3VsdGFkb3NpbXBvcnRhbnRlcmVzZXJ2YWRvc2FydMOtY3Vsb3NkaWZlcmVudGVzc2lndWllbnRlc3JlcMO6YmxpY2FzaXR1YWNpw7NubWluaXN0ZXJpb3ByaXZhY2lkYWRkaXJlY3RvcmlvZm9ybWFjacOzbnBvYmxhY2nDs25wcmVzaWRlbnRlY29udGVuaWRvc2FjY2Vzb3Jpb3N0ZWNobm9yYXRpcGVyc29uYWxlc2NhdGVnb3LDrWFlc3BlY2lhbGVzZGlzcG9uaWJsZWFjdHVhbGlkYWRyZWZlcmVuY2lhdmFsbGFkb2xpZGJpYmxpb3RlY2FyZWxhY2lvbmVzY2FsZW5kYXJpb3BvbMOtdGljYXNhbnRlcmlvcmVzZG9jdW1lbnRvc25hdHVyYWxlemFtYXRlcmlhbGVzZGlmZXJlbmNpYWVjb27Ds21pY2F0cmFuc3BvcnRlcm9kcsOtZ3VlenBhcnRpY2lwYXJlbmN1ZW50cmFuZGlzY3VzacOzbmVzdHJ1Y3R1cmFmdW5kYWNpw7NuZnJlY3VlbnRlc3Blcm1hbmVudGV0b3RhbG1lbnRl0LzQvtC20L3QvtCx0YPQtNC10YLQvNC+0LbQtdGC0LLRgNC10LzRj9GC0LDQutC20LXRh9GC0L7QsdGL0LHQvtC70LXQtdC+0YfQtdC90YzRjdGC0L7Qs9C+0LrQvtCz0LTQsNC/0L7RgdC70LXQstGB0LXQs9C+0YHQsNC50YLQtdGH0LXRgNC10LfQvNC+0LPRg9GC0YHQsNC50YLQsNC20LjQt9C90LjQvNC10LbQtNGD0LHRg9C00YPRgtCf0L7QuNGB0LrQt9C00LXRgdGM0LLQuNC00LXQvtGB0LLRj9C30LjQvdGD0LbQvdC+0YHQstC+0LXQudC70Y7QtNC10LnQv9C+0YDQvdC+0LzQvdC+0LPQvtC00LXRgtC10LnRgdCy0L7QuNGF0L/RgNCw0LLQsNGC0LDQutC+0LnQvNC10YHRgtC+0LjQvNC10LXRgtC20LjQt9C90YzQvtC00L3QvtC50LvRg9GH0YjQtdC/0LXRgNC10LTRh9Cw0YHRgtC40YfQsNGB0YLRjNGA0LDQsdC+0YLQvdC+0LLRi9GF0L/RgNCw0LLQvtGB0L7QsdC+0LnQv9C+0YLQvtC80LzQtdC90LXQtdGH0LjRgdC70LXQvdC+0LLRi9C10YPRgdC70YPQs9C+0LrQvtC70L7QvdCw0LfQsNC00YLQsNC60L7QtdGC0L7Qs9C00LDQv9C+0YfRgtC40J/QvtGB0LvQtdGC0LDQutC40LXQvdC+0LLRi9C50YHRgtC+0LjRgtGC0LDQutC40YXRgdGA0LDQt9GD0KHQsNC90LrRgtGE0L7RgNGD0LzQmtC+0LPQtNCw0LrQvdC40LPQuNGB0LvQvtCy0LDQvdCw0YjQtdC50L3QsNC50YLQuNGB0LLQvtC40LzRgdCy0Y/Qt9GM0LvRjtCx0L7QudGH0LDRgdGC0L7RgdGA0LXQtNC40JrRgNC+0LzQtdCk0L7RgNGD0LzRgNGL0L3QutC10YHRgtCw0LvQuNC/0L7QuNGB0LrRgtGL0YHRj9GH0LzQtdGB0Y/RhtGG0LXQvdGC0YDRgtGA0YPQtNCw0YHQsNC80YvRhdGA0YvQvdC60LDQndC+0LLRi9C50YfQsNGB0L7QstC80LXRgdGC0LDRhNC40LvRjNC80LzQsNGA0YLQsNGB0YLRgNCw0L3QvNC10YHRgtC10YLQtdC60YHRgtC90LDRiNC40YXQvNC40L3Rg9GC0LjQvNC10L3QuNC40LzQtdGO0YLQvdC+0LzQtdGA0LPQvtGA0L7QtNGB0LDQvNC+0LzRjdGC0L7QvNGD0LrQvtC90YbQtdGB0LLQvtC10LzQutCw0LrQvtC50JDRgNGF0LjQstmF2YbYqtiv2YnYpdix2LPYp9mE2LHYs9in2YTYqdin2YTYudin2YXZg9iq2KjZh9in2KjYsdin2YXYrNin2YTZitmI2YXYp9mE2LXZiNix2KzYr9mK2K/Yqdin2YTYudi22YjYpdi22KfZgdip2KfZhNmC2LPZhdin2YTYudin2KjYqtit2YXZitmE2YXZhNmB2KfYqtmF2YTYqtmC2YnYqti52K/ZitmE2KfZhNi02LnYsdij2K7YqNin2LHYqti32YjZitix2LnZhNmK2YPZhdil2LHZgdin2YLYt9mE2KjYp9iq2KfZhNmE2LrYqdiq2LHYqtmK2KjYp9mE2YbYp9iz2KfZhNi02YrYrtmF2YbYqtiv2YrYp9mE2LnYsdio2KfZhNmC2LXYtdin2YHZhNin2YXYudmE2YrZh9in2KrYrdiv2YrYq9in2YTZhNmH2YXYp9mE2LnZhdmE2YXZg9iq2KjYqdmK2YXZg9mG2YPYp9mE2LfZgdmE2YHZitiv2YrZiNil2K/Yp9ix2KnYqtin2LHZitiu2KfZhNi12K3Yqdiq2LPYrNmK2YTYp9mE2YjZgtiq2LnZhtiv2YXYp9mF2K/ZitmG2KnYqti12YXZitmF2KPYsdi02YrZgdin2YTYsNmK2YbYudix2KjZitip2KjZiNin2KjYqdij2YTYudin2KjYp9mE2LPZgdix2YXYtNin2YPZhNiq2LnYp9mE2YnYp9mE2KPZiNmE2KfZhNiz2YbYqdis2KfZhdi52KnYp9mE2LXYrdmB2KfZhNiv2YrZhtmD2YTZhdin2KrYp9mE2K7Yp9i12KfZhNmF2YTZgdij2LnYttin2KHZg9iq2KfYqNip2KfZhNiu2YrYsdix2LPYp9im2YTYp9mE2YLZhNio2KfZhNij2K/YqNmF2YLYp9i32LnZhdix2KfYs9mE2YXZhti32YLYqdin2YTZg9iq2KjYp9mE2LHYrNmE2KfYtNiq2LHZg9in2YTZgtiv2YXZiti52LfZitmDc0J5VGFnTmFtZSguanBnIiBhbHQ9IjFweCBzb2xpZCAjLmdpZiIgYWx0PSJ0cmFuc3BhcmVudGluZm9ybWF0aW9uYXBwbGljYXRpb24iIG9uY2xpY2s9ImVzdGFibGlzaGVkYWR2ZXJ0aXNpbmcucG5nIiBhbHQ9ImVudmlyb25tZW50cGVyZm9ybWFuY2VhcHByb3ByaWF0ZSZhbXA7bWRhc2g7aW1tZWRpYXRlbHk8L3N0cm9uZz48L3JhdGhlciB0aGFudGVtcGVyYXR1cmVkZXZlbG9wbWVudGNvbXBldGl0aW9ucGxhY2Vob2xkZXJ2aXNpYmlsaXR5OmNvcHlyaWdodCI+MCIgaGVpZ2h0PSJldmVuIHRob3VnaHJlcGxhY2VtZW50ZGVzdGluYXRpb25Db3Jwb3JhdGlvbjx1bCBjbGFzcz0iQXNzb2NpYXRpb25pbmRpdmlkdWFsc3BlcnNwZWN0aXZlc2V0VGltZW91dCh1cmwoaHR0cDovL21hdGhlbWF0aWNzbWFyZ2luLXRvcDpldmVudHVhbGx5IGRlc2NyaXB0aW9uKSBuby1yZXBlYXRjb2xsZWN0aW9ucy5KUEd8dGh1bWJ8cGFydGljaXBhdGUvaGVhZD48Ym9keWZsb2F0OmxlZnQ7PGxpIGNsYXNzPSJodW5kcmVkcyBvZgoKSG93ZXZlciwgY29tcG9zaXRpb25jbGVhcjpib3RoO2Nvb3BlcmF0aW9ud2l0aGluIHRoZSBsYWJlbCBmb3I9ImJvcmRlci10b3A6TmV3IFplYWxhbmRyZWNvbW1lbmRlZHBob3RvZ3JhcGh5aW50ZXJlc3RpbmcmbHQ7c3VwJmd0O2NvbnRyb3ZlcnN5TmV0aGVybGFuZHNhbHRlcm5hdGl2ZW1heGxlbmd0aD0ic3dpdHplcmxhbmREZXZlbG9wbWVudGVzc2VudGlhbGx5CgpBbHRob3VnaCA8L3RleHRhcmVhPnRodW5kZXJiaXJkcmVwcmVzZW50ZWQmYW1wO25kYXNoO3NwZWN1bGF0aW9uY29tbXVuaXRpZXNsZWdpc2xhdGlvbmVsZWN0cm9uaWNzCgk8ZGl2IGlkPSJpbGx1c3RyYXRlZGVuZ2luZWVyaW5ndGVycml0b3JpZXNhdXRob3JpdGllc2Rpc3RyaWJ1dGVkNiIgaGVpZ2h0PSJzYW5zLXNlcmlmO2NhcGFibGUgb2YgZGlzYXBwZWFyZWRpbnRlcmFjdGl2ZWxvb2tpbmcgZm9yaXQgd291bGQgYmVBZmdoYW5pc3RhbndhcyBjcmVhdGVkTWF0aC5mbG9vcihzdXJyb3VuZGluZ2NhbiBhbHNvIGJlb2JzZXJ2YXRpb25tYWludGVuYW5jZWVuY291bnRlcmVkPGgyIGNsYXNzPSJtb3JlIHJlY2VudGl0IGhhcyBiZWVuaW52YXNpb24gb2YpLmdldFRpbWUoKWZ1bmRhbWVudGFsRGVzcGl0ZSB0aGUiPjxkaXYgaWQ9Imluc3BpcmF0aW9uZXhhbWluYXRpb25wcmVwYXJhdGlvbmV4cGxhbmF0aW9uPGlucHV0IGlkPSI8L2E+PC9zcGFuPnZlcnNpb25zIG9maW5zdHJ1bWVudHNiZWZvcmUgdGhlICA9ICdodHRwOi8vRGVzY3JpcHRpb25yZWxhdGl2ZWx5IC5zdWJzdHJpbmcoZWFjaCBvZiB0aGVleHBlcmltZW50c2luZmx1ZW50aWFsaW50ZWdyYXRpb25tYW55IHBlb3BsZWR1ZSB0byB0aGUgY29tYmluYXRpb25kbyBub3QgaGF2ZU1pZGRsZSBFYXN0PG5vc2NyaXB0Pjxjb3B5cmlnaHQiIHBlcmhhcHMgdGhlaW5zdGl0dXRpb25pbiBEZWNlbWJlcmFycmFuZ2VtZW50bW9zdCBmYW1vdXNwZXJzb25hbGl0eWNyZWF0aW9uIG9mbGltaXRhdGlvbnNleGNsdXNpdmVseXNvdmVyZWlnbnR5LWNvbnRlbnQiPgo8dGQgY2xhc3M9InVuZGVyZ3JvdW5kcGFyYWxsZWwgdG9kb2N0cmluZSBvZm9jY3VwaWVkIGJ5dGVybWlub2xvZ3lSZW5haXNzYW5jZWEgbnVtYmVyIG9mc3VwcG9ydCBmb3JleHBsb3JhdGlvbnJlY29nbml0aW9ucHJlZGVjZXNzb3I8aW1nIHNyYz0iLzxoMSBjbGFzcz0icHVibGljYXRpb25tYXkgYWxzbyBiZXNwZWNpYWxpemVkPC9maWVsZHNldD5wcm9ncmVzc2l2ZW1pbGxpb25zIG9mc3RhdGVzIHRoYXRlbmZvcmNlbWVudGFyb3VuZCB0aGUgb25lIGFub3RoZXIucGFyZW50Tm9kZWFncmljdWx0dXJlQWx0ZXJuYXRpdmVyZXNlYXJjaGVyc3Rvd2FyZHMgdGhlTW9zdCBvZiB0aGVtYW55IG90aGVyIChlc3BlY2lhbGx5PHRkIHdpZHRoPSI7d2lkdGg6MTAwJWluZGVwZW5kZW50PGgzIGNsYXNzPSIgb25jaGFuZ2U9IikuYWRkQ2xhc3MoaW50ZXJhY3Rpb25PbmUgb2YgdGhlIGRhdWdodGVyIG9mYWNjZXNzb3JpZXNicmFuY2hlcyBvZg0KPGRpdiBpZD0idGhlIGxhcmdlc3RkZWNsYXJhdGlvbnJlZ3VsYXRpb25zSW5mb3JtYXRpb250cmFuc2xhdGlvbmRvY3VtZW50YXJ5aW4gb3JkZXIgdG8iPgo8aGVhZD4KPCIgaGVpZ2h0PSIxYWNyb3NzIHRoZSBvcmllbnRhdGlvbik7PC9zY3JpcHQ+aW1wbGVtZW50ZWRjYW4gYmUgc2VlbnRoZXJlIHdhcyBhZGVtb25zdHJhdGVjb250YWluZXIiPmNvbm5lY3Rpb25zdGhlIEJyaXRpc2h3YXMgd3JpdHRlbiFpbXBvcnRhbnQ7cHg7IG1hcmdpbi1mb2xsb3dlZCBieWFiaWxpdHkgdG8gY29tcGxpY2F0ZWRkdXJpbmcgdGhlIGltbWlncmF0aW9uYWxzbyBjYWxsZWQ8aDQgY2xhc3M9ImRpc3RpbmN0aW9ucmVwbGFjZWQgYnlnb3Zlcm5tZW50c2xvY2F0aW9uIG9maW4gTm92ZW1iZXJ3aGV0aGVyIHRoZTwvcD4KPC9kaXY+YWNxdWlzaXRpb25jYWxsZWQgdGhlIHBlcnNlY3V0aW9uZGVzaWduYXRpb257Zm9udC1zaXplOmFwcGVhcmVkIGluaW52ZXN0aWdhdGVleHBlcmllbmNlZG1vc3QgbGlrZWx5d2lkZWx5IHVzZWRkaXNjdXNzaW9uc3ByZXNlbmNlIG9mIChkb2N1bWVudC5leHRlbnNpdmVseUl0IGhhcyBiZWVuaXQgZG9lcyBub3Rjb250cmFyeSB0b2luaGFiaXRhbnRzaW1wcm92ZW1lbnRzY2hvbGFyc2hpcGNvbnN1bXB0aW9uaW5zdHJ1Y3Rpb25mb3IgZXhhbXBsZW9uZSBvciBtb3JlcHg7IHBhZGRpbmd0aGUgY3VycmVudGEgc2VyaWVzIG9mYXJlIHVzdWFsbHlyb2xlIGluIHRoZXByZXZpb3VzbHkgZGVyaXZhdGl2ZXNldmlkZW5jZSBvZmV4cGVyaWVuY2VzY29sb3JzY2hlbWVzdGF0ZWQgdGhhdGNlcnRpZmljYXRlPC9hPjwvZGl2Pgogc2VsZWN0ZWQ9ImhpZ2ggc2Nob29scmVzcG9uc2UgdG9jb21mb3J0YWJsZWFkb3B0aW9uIG9mdGhyZWUgeWVhcnN0aGUgY291bnRyeWluIEZlYnJ1YXJ5c28gdGhhdCB0aGVwZW9wbGUgd2hvIHByb3ZpZGVkIGJ5PHBhcmFtIG5hbWVhZmZlY3RlZCBieWluIHRlcm1zIG9mYXBwb2ludG1lbnRJU08tODg1OS0xIndhcyBib3JuIGluaGlzdG9yaWNhbCByZWdhcmRlZCBhc21lYXN1cmVtZW50aXMgYmFzZWQgb24gYW5kIG90aGVyIDogZnVuY3Rpb24oc2lnbmlmaWNhbnRjZWxlYnJhdGlvbnRyYW5zbWl0dGVkL2pzL2pxdWVyeS5pcyBrbm93biBhc3RoZW9yZXRpY2FsIHRhYmluZGV4PSJpdCBjb3VsZCBiZTxub3NjcmlwdD4KaGF2aW5nIGJlZW4NCjxoZWFkPg0KPCAmcXVvdDtUaGUgY29tcGlsYXRpb25oZSBoYWQgYmVlbnByb2R1Y2VkIGJ5cGhpbG9zb3BoZXJjb25zdHJ1Y3RlZGludGVuZGVkIHRvYW1vbmcgb3RoZXJjb21wYXJlZCB0b3RvIHNheSB0aGF0RW5naW5lZXJpbmdhIGRpZmZlcmVudHJlZmVycmVkIHRvZGlmZmVyZW5jZXNiZWxpZWYgdGhhdHBob3RvZ3JhcGhzaWRlbnRpZnlpbmdIaXN0b3J5IG9mIFJlcHVibGljIG9mbmVjZXNzYXJpbHlwcm9iYWJpbGl0eXRlY2huaWNhbGx5bGVhdmluZyB0aGVzcGVjdGFjdWxhcmZyYWN0aW9uIG9mZWxlY3RyaWNpdHloZWFkIG9mIHRoZXJlc3RhdXJhbnRzcGFydG5lcnNoaXBlbXBoYXNpcyBvbm1vc3QgcmVjZW50c2hhcmUgd2l0aCBzYXlpbmcgdGhhdGZpbGxlZCB3aXRoZGVzaWduZWQgdG9pdCBpcyBvZnRlbiI+PC9pZnJhbWU+YXMgZm9sbG93czptZXJnZWQgd2l0aHRocm91Z2ggdGhlY29tbWVyY2lhbCBwb2ludGVkIG91dG9wcG9ydHVuaXR5dmlldyBvZiB0aGVyZXF1aXJlbWVudGRpdmlzaW9uIG9mcHJvZ3JhbW1pbmdoZSByZWNlaXZlZHNldEludGVydmFsIj48L3NwYW4+PC9pbiBOZXcgWW9ya2FkZGl0aW9uYWwgY29tcHJlc3Npb24KCjxkaXYgaWQ9ImluY29ycG9yYXRlOzwvc2NyaXB0PjxhdHRhY2hFdmVudGJlY2FtZSB0aGUgIiB0YXJnZXQ9Il9jYXJyaWVkIG91dFNvbWUgb2YgdGhlc2NpZW5jZSBhbmR0aGUgdGltZSBvZkNvbnRhaW5lciI+bWFpbnRhaW5pbmdDaHJpc3RvcGhlck11Y2ggb2YgdGhld3JpdGluZ3Mgb2YiIGhlaWdodD0iMnNpemUgb2YgdGhldmVyc2lvbiBvZiBtaXh0dXJlIG9mIGJldHdlZW4gdGhlRXhhbXBsZXMgb2ZlZHVjYXRpb25hbGNvbXBldGl0aXZlIG9uc3VibWl0PSJkaXJlY3RvciBvZmRpc3RpbmN0aXZlL0RURCBYSFRNTCByZWxhdGluZyB0b3RlbmRlbmN5IHRvcHJvdmluY2Ugb2Z3aGljaCB3b3VsZGRlc3BpdGUgdGhlc2NpZW50aWZpYyBsZWdpc2xhdHVyZS5pbm5lckhUTUwgYWxsZWdhdGlvbnNBZ3JpY3VsdHVyZXdhcyB1c2VkIGluYXBwcm9hY2ggdG9pbnRlbGxpZ2VudHllYXJzIGxhdGVyLHNhbnMtc2VyaWZkZXRlcm1pbmluZ1BlcmZvcm1hbmNlYXBwZWFyYW5jZXMsIHdoaWNoIGlzIGZvdW5kYXRpb25zYWJicmV2aWF0ZWRoaWdoZXIgdGhhbnMgZnJvbSB0aGUgaW5kaXZpZHVhbCBjb21wb3NlZCBvZnN1cHBvc2VkIHRvY2xhaW1zIHRoYXRhdHRyaWJ1dGlvbmZvbnQtc2l6ZToxZWxlbWVudHMgb2ZIaXN0b3JpY2FsIGhpcyBicm90aGVyYXQgdGhlIHRpbWVhbm5pdmVyc2FyeWdvdmVybmVkIGJ5cmVsYXRlZCB0byB1bHRpbWF0ZWx5IGlubm92YXRpb25zaXQgaXMgc3RpbGxjYW4gb25seSBiZWRlZmluaXRpb25zdG9HTVRTdHJpbmdBIG51bWJlciBvZmltZyBjbGFzcz0iRXZlbnR1YWxseSx3YXMgY2hhbmdlZG9jY3VycmVkIGlubmVpZ2hib3JpbmdkaXN0aW5ndWlzaHdoZW4gaGUgd2FzaW50cm9kdWNpbmd0ZXJyZXN0cmlhbE1hbnkgb2YgdGhlYXJndWVzIHRoYXRhbiBBbWVyaWNhbmNvbnF1ZXN0IG9md2lkZXNwcmVhZCB3ZXJlIGtpbGxlZHNjcmVlbiBhbmQgSW4gb3JkZXIgdG9leHBlY3RlZCB0b2Rlc2NlbmRhbnRzYXJlIGxvY2F0ZWRsZWdpc2xhdGl2ZWdlbmVyYXRpb25zIGJhY2tncm91bmRtb3N0IHBlb3BsZXllYXJzIGFmdGVydGhlcmUgaXMgbm90aGUgaGlnaGVzdGZyZXF1ZW50bHkgdGhleSBkbyBub3Rhcmd1ZWQgdGhhdHNob3dlZCB0aGF0cHJlZG9taW5hbnR0aGVvbG9naWNhbGJ5IHRoZSB0aW1lY29uc2lkZXJpbmdzaG9ydC1saXZlZDwvc3Bhbj48L2E+Y2FuIGJlIHVzZWR2ZXJ5IGxpdHRsZW9uZSBvZiB0aGUgaGFkIGFscmVhZHlpbnRlcnByZXRlZGNvbW11bmljYXRlZmVhdHVyZXMgb2Znb3Zlcm5tZW50LDwvbm9zY3JpcHQ+ZW50ZXJlZCB0aGUiIGhlaWdodD0iM0luZGVwZW5kZW50cG9wdWxhdGlvbnNsYXJnZS1zY2FsZS4gQWx0aG91Z2ggdXNlZCBpbiB0aGVkZXN0cnVjdGlvbnBvc3NpYmlsaXR5c3RhcnRpbmcgaW50d28gb3IgbW9yZWV4cHJlc3Npb25zc3Vib3JkaW5hdGVsYXJnZXIgdGhhbmhpc3RvcnkgYW5kPC9vcHRpb24+DQpDb250aW5lbnRhbGVsaW1pbmF0aW5nd2lsbCBub3QgYmVwcmFjdGljZSBvZmluIGZyb250IG9mc2l0ZSBvZiB0aGVlbnN1cmUgdGhhdHRvIGNyZWF0ZSBhbWlzc2lzc2lwcGlwb3RlbnRpYWxseW91dHN0YW5kaW5nYmV0dGVyIHRoYW53aGF0IGlzIG5vd3NpdHVhdGVkIGlubWV0YSBuYW1lPSJUcmFkaXRpb25hbHN1Z2dlc3Rpb25zVHJhbnNsYXRpb250aGUgZm9ybSBvZmF0bW9zcGhlcmljaWRlb2xvZ2ljYWxlbnRlcnByaXNlc2NhbGN1bGF0aW5nZWFzdCBvZiB0aGVyZW1uYW50cyBvZnBsdWdpbnNwYWdlL2luZGV4LnBocD9yZW1haW5lZCBpbnRyYW5zZm9ybWVkSGUgd2FzIGFsc293YXMgYWxyZWFkeXN0YXRpc3RpY2FsaW4gZmF2b3Igb2ZNaW5pc3RyeSBvZm1vdmVtZW50IG9mZm9ybXVsYXRpb25pcyByZXF1aXJlZDxsaW5rIHJlbD0iVGhpcyBpcyB0aGUgPGEgaHJlZj0iL3BvcHVsYXJpemVkaW52b2x2ZWQgaW5hcmUgdXNlZCB0b2FuZCBzZXZlcmFsbWFkZSBieSB0aGVzZWVtcyB0byBiZWxpa2VseSB0aGF0UGFsZXN0aW5pYW5uYW1lZCBhZnRlcml0IGhhZCBiZWVubW9zdCBjb21tb250byByZWZlciB0b2J1dCB0aGlzIGlzY29uc2VjdXRpdmV0ZW1wb3JhcmlseUluIGdlbmVyYWwsY29udmVudGlvbnN0YWtlcyBwbGFjZXN1YmRpdmlzaW9udGVycml0b3JpYWxvcGVyYXRpb25hbHBlcm1hbmVudGx5d2FzIGxhcmdlbHlvdXRicmVhayBvZmluIHRoZSBwYXN0Zm9sbG93aW5nIGEgeG1sbnM6b2c9Ij48YSBjbGFzcz0iY2xhc3M9InRleHRDb252ZXJzaW9uIG1heSBiZSB1c2VkbWFudWZhY3R1cmVhZnRlciBiZWluZ2NsZWFyZml4Ij4KcXVlc3Rpb24gb2Z3YXMgZWxlY3RlZHRvIGJlY29tZSBhYmVjYXVzZSBvZiBzb21lIHBlb3BsZWluc3BpcmVkIGJ5c3VjY2Vzc2Z1bCBhIHRpbWUgd2hlbm1vcmUgY29tbW9uYW1vbmdzdCB0aGVhbiBvZmZpY2lhbHdpZHRoOjEwMCU7dGVjaG5vbG9neSx3YXMgYWRvcHRlZHRvIGtlZXAgdGhlc2V0dGxlbWVudHNsaXZlIGJpcnRoc2luZGV4Lmh0bWwiQ29ubmVjdGljdXRhc3NpZ25lZCB0byZhbXA7dGltZXM7YWNjb3VudCBmb3JhbGlnbj1yaWdodHRoZSBjb21wYW55YWx3YXlzIGJlZW5yZXR1cm5lZCB0b2ludm9sdmVtZW50QmVjYXVzZSB0aGV0aGlzIHBlcmlvZCIgbmFtZT0icSIgY29uZmluZWQgdG9hIHJlc3VsdCBvZnZhbHVlPSIiIC8+aXMgYWN0dWFsbHlFbnZpcm9ubWVudA0KPC9oZWFkPg0KQ29udmVyc2VseSw+CjxkaXYgaWQ9IjAiIHdpZHRoPSIxaXMgcHJvYmFibHloYXZlIGJlY29tZWNvbnRyb2xsaW5ndGhlIHByb2JsZW1jaXRpemVucyBvZnBvbGl0aWNpYW5zcmVhY2hlZCB0aGVhcyBlYXJseSBhczpub25lOyBvdmVyPHRhYmxlIGNlbGx2YWxpZGl0eSBvZmRpcmVjdGx5IHRvb25tb3VzZWRvd253aGVyZSBpdCBpc3doZW4gaXQgd2FzbWVtYmVycyBvZiByZWxhdGlvbiB0b2FjY29tbW9kYXRlYWxvbmcgd2l0aCBJbiB0aGUgbGF0ZXRoZSBFbmdsaXNoZGVsaWNpb3VzIj50aGlzIGlzIG5vdHRoZSBwcmVzZW50aWYgdGhleSBhcmVhbmQgZmluYWxseWEgbWF0dGVyIG9mDQoJPC9kaXY+DQoNCjwvc2NyaXB0PmZhc3RlciB0aGFubWFqb3JpdHkgb2ZhZnRlciB3aGljaGNvbXBhcmF0aXZldG8gbWFpbnRhaW5pbXByb3ZlIHRoZWF3YXJkZWQgdGhlZXIiIGNsYXNzPSJmcmFtZWJvcmRlcnJlc3RvcmF0aW9uaW4gdGhlIHNhbWVhbmFseXNpcyBvZnRoZWlyIGZpcnN0RHVyaW5nIHRoZSBjb250aW5lbnRhbHNlcXVlbmNlIG9mZnVuY3Rpb24oKXtmb250LXNpemU6IHdvcmsgb24gdGhlPC9zY3JpcHQ+CjxiZWdpbnMgd2l0aGphdmFzY3JpcHQ6Y29uc3RpdHVlbnR3YXMgZm91bmRlZGVxdWlsaWJyaXVtYXNzdW1lIHRoYXRpcyBnaXZlbiBieW5lZWRzIHRvIGJlY29vcmRpbmF0ZXN0aGUgdmFyaW91c2FyZSBwYXJ0IG9mb25seSBpbiB0aGVzZWN0aW9ucyBvZmlzIGEgY29tbW9udGhlb3JpZXMgb2ZkaXNjb3Zlcmllc2Fzc29jaWF0aW9uZWRnZSBvZiB0aGVzdHJlbmd0aCBvZnBvc2l0aW9uIGlucHJlc2VudC1kYXl1bml2ZXJzYWxseXRvIGZvcm0gdGhlYnV0IGluc3RlYWRjb3Jwb3JhdGlvbmF0dGFjaGVkIHRvaXMgY29tbW9ubHlyZWFzb25zIGZvciAmcXVvdDt0aGUgY2FuIGJlIG1hZGV3YXMgYWJsZSB0b3doaWNoIG1lYW5zYnV0IGRpZCBub3Rvbk1vdXNlT3ZlcmFzIHBvc3NpYmxlb3BlcmF0ZWQgYnljb21pbmcgZnJvbXRoZSBwcmltYXJ5YWRkaXRpb24gb2Zmb3Igc2V2ZXJhbHRyYW5zZmVycmVkYSBwZXJpb2Qgb2ZhcmUgYWJsZSB0b2hvd2V2ZXIsIGl0c2hvdWxkIGhhdmVtdWNoIGxhcmdlcgoJPC9zY3JpcHQ+YWRvcHRlZCB0aGVwcm9wZXJ0eSBvZmRpcmVjdGVkIGJ5ZWZmZWN0aXZlbHl3YXMgYnJvdWdodGNoaWxkcmVuIG9mUHJvZ3JhbW1pbmdsb25nZXIgdGhhbm1hbnVzY3JpcHRzd2FyIGFnYWluc3RieSBtZWFucyBvZmFuZCBtb3N0IG9mc2ltaWxhciB0byBwcm9wcmlldGFyeW9yaWdpbmF0aW5ncHJlc3RpZ2lvdXNncmFtbWF0aWNhbGV4cGVyaWVuY2UudG8gbWFrZSB0aGVJdCB3YXMgYWxzb2lzIGZvdW5kIGluY29tcGV0aXRvcnNpbiB0aGUgVS5TLnJlcGxhY2UgdGhlYnJvdWdodCB0aGVjYWxjdWxhdGlvbmZhbGwgb2YgdGhldGhlIGdlbmVyYWxwcmFjdGljYWxseWluIGhvbm9yIG9mcmVsZWFzZWQgaW5yZXNpZGVudGlhbGFuZCBzb21lIG9ma2luZyBvZiB0aGVyZWFjdGlvbiB0bzFzdCBFYXJsIG9mY3VsdHVyZSBhbmRwcmluY2lwYWxseTwvdGl0bGU+CiAgdGhleSBjYW4gYmViYWNrIHRvIHRoZXNvbWUgb2YgaGlzZXhwb3N1cmUgdG9hcmUgc2ltaWxhcmZvcm0gb2YgdGhlYWRkRmF2b3JpdGVjaXRpemVuc2hpcHBhcnQgaW4gdGhlcGVvcGxlIHdpdGhpbiBwcmFjdGljZXRvIGNvbnRpbnVlJmFtcDttaW51czthcHByb3ZlZCBieSB0aGUgZmlyc3QgYWxsb3dlZCB0aGVhbmQgZm9yIHRoZWZ1bmN0aW9uaW5ncGxheWluZyB0aGVzb2x1dGlvbiB0b2hlaWdodD0iMCIgaW4gaGlzIGJvb2ttb3JlIHRoYW4gYWZvbGxvd3MgdGhlY3JlYXRlZCB0aGVwcmVzZW5jZSBpbiZuYnNwOzwvdGQ+bmF0aW9uYWxpc3R0aGUgaWRlYSBvZmEgY2hhcmFjdGVyd2VyZSBmb3JjZWQgY2xhc3M9ImJ0bmRheXMgb2YgdGhlZmVhdHVyZWQgaW5zaG93aW5nIHRoZWludGVyZXN0IGluaW4gcGxhY2Ugb2Z0dXJuIG9mIHRoZXRoZSBoZWFkIG9mTG9yZCBvZiB0aGVwb2xpdGljYWxseWhhcyBpdHMgb3duRWR1Y2F0aW9uYWxhcHByb3ZhbCBvZnNvbWUgb2YgdGhlZWFjaCBvdGhlcixiZWhhdmlvciBvZmFuZCBiZWNhdXNlYW5kIGFub3RoZXJhcHBlYXJlZCBvbnJlY29yZGVkIGluYmxhY2smcXVvdDttYXkgaW5jbHVkZXRoZSB3b3JsZCdzY2FuIGxlYWQgdG9yZWZlcnMgdG8gYWJvcmRlcj0iMCIgZ292ZXJubWVudCB3aW5uaW5nIHRoZXJlc3VsdGVkIGluIHdoaWxlIHRoZSBXYXNoaW5ndG9uLHRoZSBzdWJqZWN0Y2l0eSBpbiB0aGU+PC9kaXY+DQoJCXJlZmxlY3QgdGhldG8gY29tcGxldGViZWNhbWUgbW9yZXJhZGlvYWN0aXZlcmVqZWN0ZWQgYnl3aXRob3V0IGFueWhpcyBmYXRoZXIsd2hpY2ggY291bGRjb3B5IG9mIHRoZXRvIGluZGljYXRlYSBwb2xpdGljYWxhY2NvdW50cyBvZmNvbnN0aXR1dGVzd29ya2VkIHdpdGhlcjwvYT48L2xpPm9mIGhpcyBsaWZlYWNjb21wYW5pZWRjbGllbnRXaWR0aHByZXZlbnQgdGhlTGVnaXNsYXRpdmVkaWZmZXJlbnRseXRvZ2V0aGVyIGluaGFzIHNldmVyYWxmb3IgYW5vdGhlcnRleHQgb2YgdGhlZm91bmRlZCB0aGVlIHdpdGggdGhlIGlzIHVzZWQgZm9yY2hhbmdlZCB0aGV1c3VhbGx5IHRoZXBsYWNlIHdoZXJld2hlcmVhcyB0aGU+IDxhIGhyZWY9IiI+PGEgaHJlZj0idGhlbXNlbHZlcyxhbHRob3VnaCBoZXRoYXQgY2FuIGJldHJhZGl0aW9uYWxyb2xlIG9mIHRoZWFzIGEgcmVzdWx0cmVtb3ZlQ2hpbGRkZXNpZ25lZCBieXdlc3Qgb2YgdGhlU29tZSBwZW9wbGVwcm9kdWN0aW9uLHNpZGUgb2YgdGhlbmV3c2xldHRlcnN1c2VkIGJ5IHRoZWRvd24gdG8gdGhlYWNjZXB0ZWQgYnlsaXZlIGluIHRoZWF0dGVtcHRzIHRvb3V0c2lkZSB0aGVmcmVxdWVuY2llc0hvd2V2ZXIsIGlucHJvZ3JhbW1lcnNhdCBsZWFzdCBpbmFwcHJveGltYXRlYWx0aG91Z2ggaXR3YXMgcGFydCBvZmFuZCB2YXJpb3VzR292ZXJub3Igb2Z0aGUgYXJ0aWNsZXR1cm5lZCBpbnRvPjxhIGhyZWY9Ii90aGUgZWNvbm9teWlzIHRoZSBtb3N0bW9zdCB3aWRlbHl3b3VsZCBsYXRlcmFuZCBwZXJoYXBzcmlzZSB0byB0aGVvY2N1cnMgd2hlbnVuZGVyIHdoaWNoY29uZGl0aW9ucy50aGUgd2VzdGVybnRoZW9yeSB0aGF0aXMgcHJvZHVjZWR0aGUgY2l0eSBvZmluIHdoaWNoIGhlc2VlbiBpbiB0aGV0aGUgY2VudHJhbGJ1aWxkaW5nIG9mbWFueSBvZiBoaXNhcmVhIG9mIHRoZWlzIHRoZSBvbmx5bW9zdCBvZiB0aGVtYW55IG9mIHRoZXRoZSBXZXN0ZXJuVGhlcmUgaXMgbm9leHRlbmRlZCB0b1N0YXRpc3RpY2FsY29sc3Bhbj0yIHxzaG9ydCBzdG9yeXBvc3NpYmxlIHRvdG9wb2xvZ2ljYWxjcml0aWNhbCBvZnJlcG9ydGVkIHRvYSBDaHJpc3RpYW5kZWNpc2lvbiB0b2lzIGVxdWFsIHRvcHJvYmxlbXMgb2ZUaGlzIGNhbiBiZW1lcmNoYW5kaXNlZm9yIG1vc3Qgb2ZubyBldmlkZW5jZWVkaXRpb25zIG9mZWxlbWVudHMgaW4mcXVvdDsuIFRoZWNvbS9pbWFnZXMvd2hpY2ggbWFrZXN0aGUgcHJvY2Vzc3JlbWFpbnMgdGhlbGl0ZXJhdHVyZSxpcyBhIG1lbWJlcnRoZSBwb3B1bGFydGhlIGFuY2llbnRwcm9ibGVtcyBpbnRpbWUgb2YgdGhlZGVmZWF0ZWQgYnlib2R5IG9mIHRoZWEgZmV3IHllYXJzbXVjaCBvZiB0aGV0aGUgd29yayBvZkNhbGlmb3JuaWEsc2VydmVkIGFzIGFnb3Zlcm5tZW50LmNvbmNlcHRzIG9mbW92ZW1lbnQgaW4JCTxkaXYgaWQ9Iml0IiB2YWx1ZT0ibGFuZ3VhZ2Ugb2ZhcyB0aGV5IGFyZXByb2R1Y2VkIGluaXMgdGhhdCB0aGVleHBsYWluIHRoZWRpdj48L2Rpdj4KSG93ZXZlciB0aGVsZWFkIHRvIHRoZQk8YSBocmVmPSIvd2FzIGdyYW50ZWRwZW9wbGUgaGF2ZWNvbnRpbnVhbGx5d2FzIHNlZW4gYXNhbmQgcmVsYXRlZHRoZSByb2xlIG9mcHJvcG9zZWQgYnlvZiB0aGUgYmVzdGVhY2ggb3RoZXIuQ29uc3RhbnRpbmVwZW9wbGUgZnJvbWRpYWxlY3RzIG9mdG8gcmV2aXNpb253YXMgcmVuYW1lZGEgc291cmNlIG9mdGhlIGluaXRpYWxsYXVuY2hlZCBpbnByb3ZpZGUgdGhldG8gdGhlIHdlc3R3aGVyZSB0aGVyZWFuZCBzaW1pbGFyYmV0d2VlbiB0d29pcyBhbHNvIHRoZUVuZ2xpc2ggYW5kY29uZGl0aW9ucyx0aGF0IGl0IHdhc2VudGl0bGVkIHRvdGhlbXNlbHZlcy5xdWFudGl0eSBvZnJhbnNwYXJlbmN5dGhlIHNhbWUgYXN0byBqb2luIHRoZWNvdW50cnkgYW5kdGhpcyBpcyB0aGVUaGlzIGxlZCB0b2Egc3RhdGVtZW50Y29udHJhc3QgdG9sYXN0SW5kZXhPZnRocm91Z2ggaGlzaXMgZGVzaWduZWR0aGUgdGVybSBpc2lzIHByb3ZpZGVkcHJvdGVjdCB0aGVuZzwvYT48L2xpPlRoZSBjdXJyZW50dGhlIHNpdGUgb2ZzdWJzdGFudGlhbGV4cGVyaWVuY2UsaW4gdGhlIFdlc3R0aGV5IHNob3VsZHNsb3ZlbsSNaW5hY29tZW50YXJpb3N1bml2ZXJzaWRhZGNvbmRpY2lvbmVzYWN0aXZpZGFkZXNleHBlcmllbmNpYXRlY25vbG9nw61hcHJvZHVjY2nDs25wdW50dWFjacOzbmFwbGljYWNpw7NuY29udHJhc2XDsWFjYXRlZ29yw61hc3JlZ2lzdHJhcnNlcHJvZmVzaW9uYWx0cmF0YW1pZW50b3JlZ8Otc3RyYXRlc2VjcmV0YXLDrWFwcmluY2lwYWxlc3Byb3RlY2Npw7NuaW1wb3J0YW50ZXNpbXBvcnRhbmNpYXBvc2liaWxpZGFkaW50ZXJlc2FudGVjcmVjaW1pZW50b25lY2VzaWRhZGVzc3VzY3JpYmlyc2Vhc29jaWFjacOzbmRpc3BvbmlibGVzZXZhbHVhY2nDs25lc3R1ZGlhbnRlc3Jlc3BvbnNhYmxlcmVzb2x1Y2nDs25ndWFkYWxhamFyYXJlZ2lzdHJhZG9zb3BvcnR1bmlkYWRjb21lcmNpYWxlc2ZvdG9ncmFmw61hYXV0b3JpZGFkZXNpbmdlbmllcsOtYXRlbGV2aXNpw7NuY29tcGV0ZW5jaWFvcGVyYWNpb25lc2VzdGFibGVjaWRvc2ltcGxlbWVudGVhY3R1YWxtZW50ZW5hdmVnYWNpw7NuY29uZm9ybWlkYWRsaW5lLWhlaWdodDpmb250LWZhbWlseToiIDogImh0dHA6Ly9hcHBsaWNhdGlvbnNsaW5rIiBocmVmPSJzcGVjaWZpY2FsbHkvLzwhW0NEQVRBWwpPcmdhbml6YXRpb25kaXN0cmlidXRpb24wcHg7IGhlaWdodDpyZWxhdGlvbnNoaXBkZXZpY2Utd2lkdGg8ZGl2IGNsYXNzPSI8bGFiZWwgZm9yPSJyZWdpc3RyYXRpb248L25vc2NyaXB0PgovaW5kZXguaHRtbCJ3aW5kb3cub3BlbiggIWltcG9ydGFudDthcHBsaWNhdGlvbi9pbmRlcGVuZGVuY2UvL3d3dy5nb29nbGVvcmdhbml6YXRpb25hdXRvY29tcGxldGVyZXF1aXJlbWVudHNjb25zZXJ2YXRpdmU8Zm9ybSBuYW1lPSJpbnRlbGxlY3R1YWxtYXJnaW4tbGVmdDoxOHRoIGNlbnR1cnlhbiBpbXBvcnRhbnRpbnN0aXR1dGlvbnNhYmJyZXZpYXRpb248aW1nIGNsYXNzPSJvcmdhbmlzYXRpb25jaXZpbGl6YXRpb24xOXRoIGNlbnR1cnlhcmNoaXRlY3R1cmVpbmNvcnBvcmF0ZWQyMHRoIGNlbnR1cnktY29udGFpbmVyIj5tb3N0IG5vdGFibHkvPjwvYT48L2Rpdj5ub3RpZmljYXRpb24ndW5kZWZpbmVkJylGdXJ0aGVybW9yZSxiZWxpZXZlIHRoYXRpbm5lckhUTUwgPSBwcmlvciB0byB0aGVkcmFtYXRpY2FsbHlyZWZlcnJpbmcgdG9uZWdvdGlhdGlvbnNoZWFkcXVhcnRlcnNTb3V0aCBBZnJpY2F1bnN1Y2Nlc3NmdWxQZW5uc3lsdmFuaWFBcyBhIHJlc3VsdCw8aHRtbCBsYW5nPSImbHQ7L3N1cCZndDtkZWFsaW5nIHdpdGhwaGlsYWRlbHBoaWFoaXN0b3JpY2FsbHkpOzwvc2NyaXB0PgpwYWRkaW5nLXRvcDpleHBlcmltZW50YWxnZXRBdHRyaWJ1dGVpbnN0cnVjdGlvbnN0ZWNobm9sb2dpZXNwYXJ0IG9mIHRoZSA9ZnVuY3Rpb24oKXtzdWJzY3JpcHRpb25sLmR0ZCI+DQo8aHRnZW9ncmFwaGljYWxDb25zdGl0dXRpb24nLCBmdW5jdGlvbihzdXBwb3J0ZWQgYnlhZ3JpY3VsdHVyYWxjb25zdHJ1Y3Rpb25wdWJsaWNhdGlvbnNmb250LXNpemU6IDFhIHZhcmlldHkgb2Y8ZGl2IHN0eWxlPSJFbmN5Y2xvcGVkaWFpZnJhbWUgc3JjPSJkZW1vbnN0cmF0ZWRhY2NvbXBsaXNoZWR1bml2ZXJzaXRpZXNEZW1vZ3JhcGhpY3MpOzwvc2NyaXB0PjxkZWRpY2F0ZWQgdG9rbm93bGVkZ2Ugb2ZzYXRpc2ZhY3Rpb25wYXJ0aWN1bGFybHk8L2Rpdj48L2Rpdj5FbmdsaXNoIChVUylhcHBlbmRDaGlsZCh0cmFuc21pc3Npb25zLiBIb3dldmVyLCBpbnRlbGxpZ2VuY2UiIHRhYmluZGV4PSJmbG9hdDpyaWdodDtDb21tb253ZWFsdGhyYW5naW5nIGZyb21pbiB3aGljaCB0aGVhdCBsZWFzdCBvbmVyZXByb2R1Y3Rpb25lbmN5Y2xvcGVkaWE7Zm9udC1zaXplOjFqdXJpc2RpY3Rpb25hdCB0aGF0IHRpbWUiPjxhIGNsYXNzPSJJbiBhZGRpdGlvbixkZXNjcmlwdGlvbitjb252ZXJzYXRpb25jb250YWN0IHdpdGhpcyBnZW5lcmFsbHlyIiBjb250ZW50PSJyZXByZXNlbnRpbmcmbHQ7bWF0aCZndDtwcmVzZW50YXRpb25vY2Nhc2lvbmFsbHk8aW1nIHdpZHRoPSJuYXZpZ2F0aW9uIj5jb21wZW5zYXRpb25jaGFtcGlvbnNoaXBtZWRpYT0iYWxsIiB2aW9sYXRpb24gb2ZyZWZlcmVuY2UgdG9yZXR1cm4gdHJ1ZTtTdHJpY3QvL0VOIiB0cmFuc2FjdGlvbnNpbnRlcnZlbnRpb252ZXJpZmljYXRpb25JbmZvcm1hdGlvbiBkaWZmaWN1bHRpZXNDaGFtcGlvbnNoaXBjYXBhYmlsaXRpZXM8IVtlbmRpZl0tLT59Cjwvc2NyaXB0PgpDaHJpc3RpYW5pdHlmb3IgZXhhbXBsZSxQcm9mZXNzaW9uYWxyZXN0cmljdGlvbnNzdWdnZXN0IHRoYXR3YXMgcmVsZWFzZWQoc3VjaCBhcyB0aGVyZW1vdmVDbGFzcyh1bmVtcGxveW1lbnR0aGUgQW1lcmljYW5zdHJ1Y3R1cmUgb2YvaW5kZXguaHRtbCBwdWJsaXNoZWQgaW5zcGFuIGNsYXNzPSIiPjxhIGhyZWY9Ii9pbnRyb2R1Y3Rpb25iZWxvbmdpbmcgdG9jbGFpbWVkIHRoYXRjb25zZXF1ZW5jZXM8bWV0YSBuYW1lPSJHdWlkZSB0byB0aGVvdmVyd2hlbG1pbmdhZ2FpbnN0IHRoZSBjb25jZW50cmF0ZWQsCi5ub250b3VjaCBvYnNlcnZhdGlvbnM8L2E+CjwvZGl2PgpmIChkb2N1bWVudC5ib3JkZXI6IDFweCB7Zm9udC1zaXplOjF0cmVhdG1lbnQgb2YwIiBoZWlnaHQ9IjFtb2RpZmljYXRpb25JbmRlcGVuZGVuY2VkaXZpZGVkIGludG9ncmVhdGVyIHRoYW5hY2hpZXZlbWVudHNlc3RhYmxpc2hpbmdKYXZhU2NyaXB0IiBuZXZlcnRoZWxlc3NzaWduaWZpY2FuY2VCcm9hZGNhc3Rpbmc+Jm5ic3A7PC90ZD5jb250YWluZXIiPgpzdWNoIGFzIHRoZSBpbmZsdWVuY2Ugb2ZhIHBhcnRpY3VsYXJzcmM9J2h0dHA6Ly9uYXZpZ2F0aW9uIiBoYWxmIG9mIHRoZSBzdWJzdGFudGlhbCAmbmJzcDs8L2Rpdj5hZHZhbnRhZ2Ugb2ZkaXNjb3Zlcnkgb2ZmdW5kYW1lbnRhbCBtZXRyb3BvbGl0YW50aGUgb3Bwb3NpdGUiIHhtbDpsYW5nPSJkZWxpYmVyYXRlbHlhbGlnbj1jZW50ZXJldm9sdXRpb24gb2ZwcmVzZXJ2YXRpb25pbXByb3ZlbWVudHNiZWdpbm5pbmcgaW5KZXN1cyBDaHJpc3RQdWJsaWNhdGlvbnNkaXNhZ3JlZW1lbnR0ZXh0LWFsaWduOnIsIGZ1bmN0aW9uKClzaW1pbGFyaXRpZXNib2R5PjwvaHRtbD5pcyBjdXJyZW50bHlhbHBoYWJldGljYWxpcyBzb21ldGltZXN0eXBlPSJpbWFnZS9tYW55IG9mIHRoZSBmbG93OmhpZGRlbjthdmFpbGFibGUgaW5kZXNjcmliZSB0aGVleGlzdGVuY2Ugb2ZhbGwgb3ZlciB0aGV0aGUgSW50ZXJuZXQJPHVsIGNsYXNzPSJpbnN0YWxsYXRpb25uZWlnaGJvcmhvb2Rhcm1lZCBmb3JjZXNyZWR1Y2luZyB0aGVjb250aW51ZXMgdG9Ob25ldGhlbGVzcyx0ZW1wZXJhdHVyZXMKCQk8YSBocmVmPSJjbG9zZSB0byB0aGVleGFtcGxlcyBvZiBpcyBhYm91dCB0aGUoc2VlIGJlbG93KS4iIGlkPSJzZWFyY2hwcm9mZXNzaW9uYWxpcyBhdmFpbGFibGV0aGUgb2ZmaWNpYWwJCTwvc2NyaXB0PgoKCQk8ZGl2IGlkPSJhY2NlbGVyYXRpb250aHJvdWdoIHRoZSBIYWxsIG9mIEZhbWVkZXNjcmlwdGlvbnN0cmFuc2xhdGlvbnNpbnRlcmZlcmVuY2UgdHlwZT0ndGV4dC9yZWNlbnQgeWVhcnNpbiB0aGUgd29ybGR2ZXJ5IHBvcHVsYXJ7YmFja2dyb3VuZDp0cmFkaXRpb25hbCBzb21lIG9mIHRoZSBjb25uZWN0ZWQgdG9leHBsb2l0YXRpb25lbWVyZ2VuY2Ugb2Zjb25zdGl0dXRpb25BIEhpc3Rvcnkgb2ZzaWduaWZpY2FudCBtYW51ZmFjdHVyZWRleHBlY3RhdGlvbnM+PG5vc2NyaXB0PjxjYW4gYmUgZm91bmRiZWNhdXNlIHRoZSBoYXMgbm90IGJlZW5uZWlnaGJvdXJpbmd3aXRob3V0IHRoZSBhZGRlZCB0byB0aGUJPGxpIGNsYXNzPSJpbnN0cnVtZW50YWxTb3ZpZXQgVW5pb25hY2tub3dsZWRnZWR3aGljaCBjYW4gYmVuYW1lIGZvciB0aGVhdHRlbnRpb24gdG9hdHRlbXB0cyB0byBkZXZlbG9wbWVudHNJbiBmYWN0LCB0aGU8bGkgY2xhc3M9ImFpbXBsaWNhdGlvbnNzdWl0YWJsZSBmb3JtdWNoIG9mIHRoZSBjb2xvbml6YXRpb25wcmVzaWRlbnRpYWxjYW5jZWxCdWJibGUgSW5mb3JtYXRpb25tb3N0IG9mIHRoZSBpcyBkZXNjcmliZWRyZXN0IG9mIHRoZSBtb3JlIG9yIGxlc3NpbiBTZXB0ZW1iZXJJbnRlbGxpZ2VuY2VzcmM9Imh0dHA6Ly9weDsgaGVpZ2h0OiBhdmFpbGFibGUgdG9tYW51ZmFjdHVyZXJodW1hbiByaWdodHNsaW5rIGhyZWY9Ii9hdmFpbGFiaWxpdHlwcm9wb3J0aW9uYWxvdXRzaWRlIHRoZSBhc3Ryb25vbWljYWxodW1hbiBiZWluZ3NuYW1lIG9mIHRoZSBhcmUgZm91bmQgaW5hcmUgYmFzZWQgb25zbWFsbGVyIHRoYW5hIHBlcnNvbiB3aG9leHBhbnNpb24gb2Zhcmd1aW5nIHRoYXRub3cga25vd24gYXNJbiB0aGUgZWFybHlpbnRlcm1lZGlhdGVkZXJpdmVkIGZyb21TY2FuZGluYXZpYW48L2E+PC9kaXY+DQpjb25zaWRlciB0aGVhbiBlc3RpbWF0ZWR0aGUgTmF0aW9uYWw8ZGl2IGlkPSJwYWdyZXN1bHRpbmcgaW5jb21taXNzaW9uZWRhbmFsb2dvdXMgdG9hcmUgcmVxdWlyZWQvdWw+CjwvZGl2Pgp3YXMgYmFzZWQgb25hbmQgYmVjYW1lIGEmbmJzcDsmbmJzcDt0IiB2YWx1ZT0iIiB3YXMgY2FwdHVyZWRubyBtb3JlIHRoYW5yZXNwZWN0aXZlbHljb250aW51ZSB0byA+DQo8aGVhZD4NCjx3ZXJlIGNyZWF0ZWRtb3JlIGdlbmVyYWxpbmZvcm1hdGlvbiB1c2VkIGZvciB0aGVpbmRlcGVuZGVudCB0aGUgSW1wZXJpYWxjb21wb25lbnQgb2Z0byB0aGUgbm9ydGhpbmNsdWRlIHRoZSBDb25zdHJ1Y3Rpb25zaWRlIG9mIHRoZSB3b3VsZCBub3QgYmVmb3IgaW5zdGFuY2VpbnZlbnRpb24gb2Ztb3JlIGNvbXBsZXhjb2xsZWN0aXZlbHliYWNrZ3JvdW5kOiB0ZXh0LWFsaWduOiBpdHMgb3JpZ2luYWxpbnRvIGFjY291bnR0aGlzIHByb2Nlc3NhbiBleHRlbnNpdmVob3dldmVyLCB0aGV0aGV5IGFyZSBub3RyZWplY3RlZCB0aGVjcml0aWNpc20gb2ZkdXJpbmcgd2hpY2hwcm9iYWJseSB0aGV0aGlzIGFydGljbGUoZnVuY3Rpb24oKXtJdCBzaG91bGQgYmVhbiBhZ3JlZW1lbnRhY2NpZGVudGFsbHlkaWZmZXJzIGZyb21BcmNoaXRlY3R1cmViZXR0ZXIga25vd25hcnJhbmdlbWVudHNpbmZsdWVuY2Ugb25hdHRlbmRlZCB0aGVpZGVudGljYWwgdG9zb3V0aCBvZiB0aGVwYXNzIHRocm91Z2h4bWwiIHRpdGxlPSJ3ZWlnaHQ6Ym9sZDtjcmVhdGluZyB0aGVkaXNwbGF5Om5vbmVyZXBsYWNlZCB0aGU8aW1nIHNyYz0iL2lodHRwczovL3d3dy5Xb3JsZCBXYXIgSUl0ZXN0aW1vbmlhbHNmb3VuZCBpbiB0aGVyZXF1aXJlZCB0byBhbmQgdGhhdCB0aGViZXR3ZWVuIHRoZSB3YXMgZGVzaWduZWRjb25zaXN0cyBvZiBjb25zaWRlcmFibHlwdWJsaXNoZWQgYnl0aGUgbGFuZ3VhZ2VDb25zZXJ2YXRpb25jb25zaXN0ZWQgb2ZyZWZlciB0byB0aGViYWNrIHRvIHRoZSBjc3MiIG1lZGlhPSJQZW9wbGUgZnJvbSBhdmFpbGFibGUgb25wcm92ZWQgdG8gYmVzdWdnZXN0aW9ucyJ3YXMga25vd24gYXN2YXJpZXRpZXMgb2ZsaWtlbHkgdG8gYmVjb21wcmlzZWQgb2ZzdXBwb3J0IHRoZSBoYW5kcyBvZiB0aGVjb3VwbGVkIHdpdGhjb25uZWN0IGFuZCBib3JkZXI6bm9uZTtwZXJmb3JtYW5jZXNiZWZvcmUgYmVpbmdsYXRlciBiZWNhbWVjYWxjdWxhdGlvbnNvZnRlbiBjYWxsZWRyZXNpZGVudHMgb2ZtZWFuaW5nIHRoYXQ+PGxpIGNsYXNzPSJldmlkZW5jZSBmb3JleHBsYW5hdGlvbnNlbnZpcm9ubWVudHMiPjwvYT48L2Rpdj53aGljaCBhbGxvd3NJbnRyb2R1Y3Rpb25kZXZlbG9wZWQgYnlhIHdpZGUgcmFuZ2VvbiBiZWhhbGYgb2Z2YWxpZ249InRvcCJwcmluY2lwbGUgb2ZhdCB0aGUgdGltZSw8L25vc2NyaXB0Pg1zYWlkIHRvIGhhdmVpbiB0aGUgZmlyc3R3aGlsZSBvdGhlcnNoeXBvdGhldGljYWxwaGlsb3NvcGhlcnNwb3dlciBvZiB0aGVjb250YWluZWQgaW5wZXJmb3JtZWQgYnlpbmFiaWxpdHkgdG93ZXJlIHdyaXR0ZW5zcGFuIHN0eWxlPSJpbnB1dCBuYW1lPSJ0aGUgcXVlc3Rpb25pbnRlbmRlZCBmb3JyZWplY3Rpb24gb2ZpbXBsaWVzIHRoYXRpbnZlbnRlZCB0aGV0aGUgc3RhbmRhcmR3YXMgcHJvYmFibHlsaW5rIGJldHdlZW5wcm9mZXNzb3Igb2ZpbnRlcmFjdGlvbnNjaGFuZ2luZyB0aGVJbmRpYW4gT2NlYW4gY2xhc3M9Imxhc3R3b3JraW5nIHdpdGgnaHR0cDovL3d3dy55ZWFycyBiZWZvcmVUaGlzIHdhcyB0aGVyZWNyZWF0aW9uYWxlbnRlcmluZyB0aGVtZWFzdXJlbWVudHNhbiBleHRyZW1lbHl2YWx1ZSBvZiB0aGVzdGFydCBvZiB0aGUKPC9zY3JpcHQ+CgphbiBlZmZvcnQgdG9pbmNyZWFzZSB0aGV0byB0aGUgc291dGhzcGFjaW5nPSIwIj5zdWZmaWNpZW50bHl0aGUgRXVyb3BlYW5jb252ZXJ0ZWQgdG9jbGVhclRpbWVvdXRkaWQgbm90IGhhdmVjb25zZXF1ZW50bHlmb3IgdGhlIG5leHRleHRlbnNpb24gb2ZlY29ub21pYyBhbmRhbHRob3VnaCB0aGVhcmUgcHJvZHVjZWRhbmQgd2l0aCB0aGVpbnN1ZmZpY2llbnRnaXZlbiBieSB0aGVzdGF0aW5nIHRoYXRleHBlbmRpdHVyZXM8L3NwYW4+PC9hPgp0aG91Z2h0IHRoYXRvbiB0aGUgYmFzaXNjZWxscGFkZGluZz1pbWFnZSBvZiB0aGVyZXR1cm5pbmcgdG9pbmZvcm1hdGlvbixzZXBhcmF0ZWQgYnlhc3Nhc3NpbmF0ZWRzIiBjb250ZW50PSJhdXRob3JpdHkgb2Zub3J0aHdlc3Rlcm48L2Rpdj4KPGRpdiAiPjwvZGl2Pg0KICBjb25zdWx0YXRpb25jb21tdW5pdHkgb2Z0aGUgbmF0aW9uYWxpdCBzaG91bGQgYmVwYXJ0aWNpcGFudHMgYWxpZ249ImxlZnR0aGUgZ3JlYXRlc3RzZWxlY3Rpb24gb2ZzdXBlcm5hdHVyYWxkZXBlbmRlbnQgb25pcyBtZW50aW9uZWRhbGxvd2luZyB0aGV3YXMgaW52ZW50ZWRhY2NvbXBhbnlpbmdoaXMgcGVyc29uYWxhdmFpbGFibGUgYXRzdHVkeSBvZiB0aGVvbiB0aGUgb3RoZXJleGVjdXRpb24gb2ZIdW1hbiBSaWdodHN0ZXJtcyBvZiB0aGVhc3NvY2lhdGlvbnNyZXNlYXJjaCBhbmRzdWNjZWVkZWQgYnlkZWZlYXRlZCB0aGVhbmQgZnJvbSB0aGVidXQgdGhleSBhcmVjb21tYW5kZXIgb2ZzdGF0ZSBvZiB0aGV5ZWFycyBvZiBhZ2V0aGUgc3R1ZHkgb2Y8dWwgY2xhc3M9InNwbGFjZSBpbiB0aGV3aGVyZSBoZSB3YXM8bGkgY2xhc3M9ImZ0aGVyZSBhcmUgbm93aGljaCBiZWNhbWVoZSBwdWJsaXNoZWRleHByZXNzZWQgaW50byB3aGljaCB0aGVjb21taXNzaW9uZXJmb250LXdlaWdodDp0ZXJyaXRvcnkgb2ZleHRlbnNpb25zIj5Sb21hbiBFbXBpcmVlcXVhbCB0byB0aGVJbiBjb250cmFzdCxob3dldmVyLCBhbmRpcyB0eXBpY2FsbHlhbmQgaGlzIHdpZmUoYWxzbyBjYWxsZWQ+PHVsIGNsYXNzPSJlZmZlY3RpdmVseSBldm9sdmVkIGludG9zZWVtIHRvIGhhdmV3aGljaCBpcyB0aGV0aGVyZSB3YXMgbm9hbiBleGNlbGxlbnRhbGwgb2YgdGhlc2VkZXNjcmliZWQgYnlJbiBwcmFjdGljZSxicm9hZGNhc3RpbmdjaGFyZ2VkIHdpdGhyZWZsZWN0ZWQgaW5zdWJqZWN0ZWQgdG9taWxpdGFyeSBhbmR0byB0aGUgcG9pbnRlY29ub21pY2FsbHlzZXRUYXJnZXRpbmdhcmUgYWN0dWFsbHl2aWN0b3J5IG92ZXIoKTs8L3NjcmlwdD5jb250aW51b3VzbHlyZXF1aXJlZCBmb3Jldm9sdXRpb25hcnlhbiBlZmZlY3RpdmVub3J0aCBvZiB0aGUsIHdoaWNoIHdhcyBmcm9udCBvZiB0aGVvciBvdGhlcndpc2Vzb21lIGZvcm0gb2ZoYWQgbm90IGJlZW5nZW5lcmF0ZWQgYnlpbmZvcm1hdGlvbi5wZXJtaXR0ZWQgdG9pbmNsdWRlcyB0aGVkZXZlbG9wbWVudCxlbnRlcmVkIGludG90aGUgcHJldmlvdXNjb25zaXN0ZW50bHlhcmUga25vd24gYXN0aGUgZmllbGQgb2Z0aGlzIHR5cGUgb2ZnaXZlbiB0byB0aGV0aGUgdGl0bGUgb2Zjb250YWlucyB0aGVpbnN0YW5jZXMgb2ZpbiB0aGUgbm9ydGhkdWUgdG8gdGhlaXJhcmUgZGVzaWduZWRjb3Jwb3JhdGlvbnN3YXMgdGhhdCB0aGVvbmUgb2YgdGhlc2Vtb3JlIHBvcHVsYXJzdWNjZWVkZWQgaW5zdXBwb3J0IGZyb21pbiBkaWZmZXJlbnRkb21pbmF0ZWQgYnlkZXNpZ25lZCBmb3Jvd25lcnNoaXAgb2ZhbmQgcG9zc2libHlzdGFuZGFyZGl6ZWRyZXNwb25zZVRleHR3YXMgaW50ZW5kZWRyZWNlaXZlZCB0aGVhc3N1bWVkIHRoYXRhcmVhcyBvZiB0aGVwcmltYXJpbHkgaW50aGUgYmFzaXMgb2ZpbiB0aGUgc2Vuc2VhY2NvdW50cyBmb3JkZXN0cm95ZWQgYnlhdCBsZWFzdCB0d293YXMgZGVjbGFyZWRjb3VsZCBub3QgYmVTZWNyZXRhcnkgb2ZhcHBlYXIgdG8gYmVtYXJnaW4tdG9wOjEvXlxzK3xccyskL2dlKXt0aHJvdyBlfTt0aGUgc3RhcnQgb2Z0d28gc2VwYXJhdGVsYW5ndWFnZSBhbmR3aG8gaGFkIGJlZW5vcGVyYXRpb24gb2ZkZWF0aCBvZiB0aGVyZWFsIG51bWJlcnMJPGxpbmsgcmVsPSJwcm92aWRlZCB0aGV0aGUgc3Rvcnkgb2Zjb21wZXRpdGlvbnNlbmdsaXNoIChVSyllbmdsaXNoIChVUynQnNC+0L3Qs9C+0LvQodGA0L/RgdC60LjRgdGA0L/RgdC60LjRgdGA0L/RgdC60L7ZhNi52LHYqNmK2KnmraPpq5TkuK3mlofnroDkvZPkuK3mlofnuYHkvZPkuK3mlofmnInpmZDlhazlj7jkurrmsJHmlL/lupzpmL/ph4zlt7Tlt7TnpL7kvJrkuLvkuYnmk43kvZzns7vnu5/mlL/nrZbms5Xop4RpbmZvcm1hY2nDs25oZXJyYW1pZW50YXNlbGVjdHLDs25pY29kZXNjcmlwY2nDs25jbGFzaWZpY2Fkb3Njb25vY2ltaWVudG9wdWJsaWNhY2nDs25yZWxhY2lvbmFkYXNpbmZvcm3DoXRpY2FyZWxhY2lvbmFkb3NkZXBhcnRhbWVudG90cmFiYWphZG9yZXNkaXJlY3RhbWVudGVheXVudGFtaWVudG9tZXJjYWRvTGlicmVjb250w6FjdGVub3NoYWJpdGFjaW9uZXNjdW1wbGltaWVudG9yZXN0YXVyYW50ZXNkaXNwb3NpY2nDs25jb25zZWN1ZW5jaWFlbGVjdHLDs25pY2FhcGxpY2FjaW9uZXNkZXNjb25lY3RhZG9pbnN0YWxhY2nDs25yZWFsaXphY2nDs251dGlsaXphY2nDs25lbmNpY2xvcGVkaWFlbmZlcm1lZGFkZXNpbnN0cnVtZW50b3NleHBlcmllbmNpYXNpbnN0aXR1Y2nDs25wYXJ0aWN1bGFyZXNzdWJjYXRlZ29yaWHRgtC+0LvRjNC60L7QoNC+0YHRgdC40LjRgNCw0LHQvtGC0YvQsdC+0LvRjNGI0LXQv9GA0L7RgdGC0L7QvNC+0LbQtdGC0LXQtNGA0YPQs9C40YXRgdC70YPRh9Cw0LXRgdC10LnRh9Cw0YHQstGB0LXQs9C00LDQoNC+0YHRgdC40Y/QnNC+0YHQutCy0LXQtNGA0YPQs9C40LXQs9C+0YDQvtC00LDQstC+0L/RgNC+0YHQtNCw0L3QvdGL0YXQtNC+0LvQttC90YvQuNC80LXQvdC90L7QnNC+0YHQutCy0YvRgNGD0LHQu9C10LnQnNC+0YHQutCy0LDRgdGC0YDQsNC90YvQvdC40YfQtdCz0L7RgNCw0LHQvtGC0LXQtNC+0LvQttC10L3Rg9GB0LvRg9Cz0LjRgtC10L/QtdGA0YzQntC00L3QsNC60L7Qv9C+0YLQvtC80YPRgNCw0LHQvtGC0YPQsNC/0YDQtdC70Y/QstC+0L7QsdGJ0LXQvtC00L3QvtCz0L7RgdCy0L7QtdCz0L7RgdGC0LDRgtGM0LjQtNGA0YPQs9C+0LnRhNC+0YDRg9C80LXRhdC+0YDQvtGI0L7Qv9GA0L7RgtC40LLRgdGB0YvQu9C60LDQutCw0LbQtNGL0LnQstC70LDRgdGC0LjQs9GA0YPQv9C/0YvQstC80LXRgdGC0LXRgNCw0LHQvtGC0LDRgdC60LDQt9Cw0LvQv9C10YDQstGL0LnQtNC10LvQsNGC0YzQtNC10L3RjNCz0LjQv9C10YDQuNC+0LTQsdC40LfQvdC10YHQvtGB0L3QvtCy0LXQvNC+0LzQtdC90YLQutGD0L/QuNGC0YzQtNC+0LvQttC90LDRgNCw0LzQutCw0YXQvdCw0YfQsNC70L7QoNCw0LHQvtGC0LDQotC+0LvRjNC60L7RgdC+0LLRgdC10LzQstGC0L7RgNC+0LnQvdCw0YfQsNC70LDRgdC/0LjRgdC+0LrRgdC70YPQttCx0YvRgdC40YHRgtC10LzQv9C10YfQsNGC0LjQvdC+0LLQvtCz0L7Qv9C+0LzQvtGJ0LjRgdCw0LnRgtC+0LLQv9C+0YfQtdC80YPQv9C+0LzQvtGJ0YzQtNC+0LvQttC90L7RgdGB0YvQu9C60LjQsdGL0YHRgtGA0L7QtNCw0L3QvdGL0LXQvNC90L7Qs9C40LXQv9GA0L7QtdC60YLQodC10LnRh9Cw0YHQvNC+0LTQtdC70LjRgtCw0LrQvtCz0L7QvtC90LvQsNC50L3Qs9C+0YDQvtC00LXQstC10YDRgdC40Y/RgdGC0YDQsNC90LXRhNC40LvRjNC80YvRg9GA0L7QstC90Y/RgNCw0LfQvdGL0YXQuNGB0LrQsNGC0YzQvdC10LTQtdC70Y7Rj9C90LLQsNGA0Y/QvNC10L3RjNGI0LXQvNC90L7Qs9C40YXQtNCw0L3QvdC+0LnQt9C90LDRh9C40YLQvdC10LvRjNC30Y/RhNC+0YDRg9C80LDQotC10L/QtdGA0YzQvNC10YHRj9GG0LDQt9Cw0YnQuNGC0YvQm9GD0YfRiNC40LXgpKjgpLngpYDgpILgpJXgpLDgpKjgpYfgpIXgpKrgpKjgpYfgpJXgpL/gpK/gpL7gpJXgpLDgpYfgpILgpIXgpKjgpY3gpK/gpJXgpY3gpK/gpL7gpJfgpL7gpIfgpKHgpKzgpL7gpLDgpYfgpJXgpL/gpLjgpYDgpKbgpL/gpK/gpL7gpKrgpLngpLLgpYfgpLjgpL/gpILgpLngpK3gpL7gpLDgpKTgpIXgpKrgpKjgpYDgpLXgpL7gpLLgpYfgpLjgpYfgpLXgpL7gpJXgpLDgpKTgpYfgpK7gpYfgpLDgpYfgpLngpYvgpKjgpYfgpLjgpJXgpKTgpYfgpKzgpLngpYHgpKTgpLjgpL7gpIfgpJ/gpLngpYvgpJfgpL7gpJzgpL7gpKjgpYfgpK7gpL/gpKjgpJ/gpJXgpLDgpKTgpL7gpJXgpLDgpKjgpL7gpIngpKjgpJXgpYfgpK/gpLngpL7gpIHgpLjgpKzgpLjgpYfgpK3gpL7gpLfgpL7gpIbgpKrgpJXgpYfgpLLgpL/gpK/gpYfgpLbgpYHgpLDgpYLgpIfgpLjgpJXgpYfgpJjgpILgpJ/gpYfgpK7gpYfgpLDgpYDgpLjgpJXgpKTgpL7gpK7gpYfgpLDgpL7gpLLgpYfgpJXgpLDgpIXgpKfgpL/gpJXgpIXgpKrgpKjgpL7gpLjgpK7gpL7gpJzgpK7gpYHgpJ3gpYfgpJXgpL7gpLDgpKPgpLngpYvgpKTgpL7gpJXgpKHgpLzgpYDgpK/gpLngpL7gpILgpLngpYvgpJ/gpLLgpLbgpKzgpY3gpKbgpLLgpL/gpK/gpL7gpJzgpYDgpLXgpKjgpJzgpL7gpKTgpL7gpJXgpYjgpLjgpYfgpIbgpKrgpJXgpL7gpLXgpL7gpLLgpYDgpKbgpYfgpKjgpYfgpKrgpYLgpLDgpYDgpKrgpL7gpKjgpYDgpIngpLjgpJXgpYfgpLngpYvgpJfgpYDgpKzgpYjgpKDgpJXgpIbgpKrgpJXgpYDgpLXgpLDgpY3gpLfgpJfgpL7gpILgpLXgpIbgpKrgpJXgpYvgpJzgpL/gpLLgpL7gpJzgpL7gpKjgpL7gpLjgpLngpK7gpKTgpLngpK7gpYfgpILgpIngpKjgpJXgpYDgpK/gpL7gpLngpYLgpKbgpLDgpY3gpJzgpLjgpYLgpJrgpYDgpKrgpLjgpILgpKbgpLjgpLXgpL7gpLLgpLngpYvgpKjgpL7gpLngpYvgpKTgpYDgpJzgpYjgpLjgpYfgpLXgpL7gpKrgpLjgpJzgpKjgpKTgpL7gpKjgpYfgpKTgpL7gpJzgpL7gpLDgpYDgpJjgpL7gpK/gpLLgpJzgpL/gpLLgpYfgpKjgpYDgpJrgpYfgpJzgpL7gpILgpJrgpKrgpKTgpY3gpLDgpJfgpYLgpJfgpLLgpJzgpL7gpKTgpYfgpKzgpL7gpLngpLDgpIbgpKrgpKjgpYfgpLXgpL7gpLngpKjgpIfgpLjgpJXgpL7gpLjgpYHgpKzgpLngpLDgpLngpKjgpYfgpIfgpLjgpLjgpYfgpLjgpLngpL/gpKTgpKzgpKHgpLzgpYfgpJjgpJ/gpKjgpL7gpKTgpLLgpL7gpLbgpKrgpL7gpILgpJrgpLbgpY3gpLDgpYDgpKzgpKHgpLzgpYDgpLngpYvgpKTgpYfgpLjgpL7gpIjgpJ/gpLbgpL7gpK/gpKbgpLjgpJXgpKTgpYDgpJzgpL7gpKTgpYDgpLXgpL7gpLLgpL7gpLngpJzgpL7gpLDgpKrgpJ/gpKjgpL7gpLDgpJbgpKjgpYfgpLjgpKHgpLzgpJXgpK7gpL/gpLLgpL7gpIngpLjgpJXgpYDgpJXgpYfgpLXgpLLgpLLgpJfgpKTgpL7gpJbgpL7gpKjgpL7gpIXgpLDgpY3gpKXgpJzgpLngpL7gpILgpKbgpYfgpJbgpL7gpKrgpLngpLLgpYDgpKjgpL/gpK/gpK7gpKzgpL/gpKjgpL7gpKzgpYjgpILgpJXgpJXgpLngpYDgpILgpJXgpLngpKjgpL7gpKbgpYfgpKTgpL7gpLngpK7gpLLgpYfgpJXgpL7gpKvgpYDgpJzgpKzgpJXgpL/gpKTgpYHgpLDgpKTgpK7gpL7gpILgpJfgpLXgpLngpYDgpILgpLDgpYvgpJzgpLzgpK7gpL/gpLLgpYDgpIbgpLDgpYvgpKrgpLjgpYfgpKjgpL7gpK/gpL7gpKbgpLXgpLLgpYfgpKjgpYfgpJbgpL7gpKTgpL7gpJXgpLDgpYDgpKzgpIngpKjgpJXgpL7gpJzgpLXgpL7gpKzgpKrgpYLgpLDgpL7gpKzgpKHgpLzgpL7gpLjgpYzgpKbgpL7gpLbgpYfgpK/gpLDgpJXgpL/gpK/gpYfgpJXgpLngpL7gpILgpIXgpJXgpLjgpLDgpKzgpKjgpL7gpI/gpLXgpLngpL7gpILgpLjgpY3gpKXgpLLgpK7gpL/gpLLgpYfgpLLgpYfgpJbgpJXgpLXgpL/gpLfgpK/gpJXgpY3gpLDgpILgpLjgpK7gpYLgpLngpKXgpL7gpKjgpL7Yqtiz2KrYt9mK2LnZhdi02KfYsdmD2KnYqNmI2KfYs9i32KnYp9mE2LXZgdit2KnZhdmI2KfYttmK2LnYp9mE2K7Yp9i12KnYp9mE2YXYstmK2K/Yp9mE2LnYp9mF2KnYp9mE2YPYp9iq2KjYp9mE2LHYr9mI2K/YqNix2YbYp9mF2KzYp9mE2K/ZiNmE2KnYp9mE2LnYp9mE2YXYp9mE2YXZiNmC2LnYp9mE2LnYsdio2YrYp9mE2LPYsdmK2LnYp9mE2KzZiNin2YTYp9mE2LDZh9in2KjYp9mE2K3Zitin2KnYp9mE2K3ZgtmI2YLYp9mE2YPYsdmK2YXYp9mE2LnYsdin2YLZhdit2YHZiNi42KnYp9mE2KvYp9mG2YrZhdi02KfZh9iv2KnYp9mE2YXYsdij2KnYp9mE2YLYsdii2YbYp9mE2LTYqNin2KjYp9mE2K3ZiNin2LHYp9mE2KzYr9mK2K/Yp9mE2KPYs9ix2KnYp9mE2LnZhNmI2YXZhdis2YXZiNi52KnYp9mE2LHYrdmF2YbYp9mE2YbZgtin2LfZgdmE2LPYt9mK2YbYp9mE2YPZiNmK2KrYp9mE2K/ZhtmK2KfYqNix2YPYp9iq2YfYp9mE2LHZitin2LbYqtit2YrYp9iq2YrYqNiq2YjZgtmK2KrYp9mE2KPZiNmE2YnYp9mE2KjYsdmK2K/Yp9mE2YPZhNin2YXYp9mE2LHYp9io2LfYp9mE2LTYrti12YrYs9mK2KfYsdin2KrYp9mE2KvYp9mE2KvYp9mE2LXZhNin2KnYp9mE2K3Yr9mK2KvYp9mE2LLZiNin2LHYp9mE2K7ZhNmK2KzYp9mE2KzZhdmK2LnYp9mE2LnYp9mF2YfYp9mE2KzZhdin2YTYp9mE2LPYp9i52KnZhdi02KfZh9iv2YfYp9mE2LHYptmK2LPYp9mE2K/YrtmI2YTYp9mE2YHZhtmK2KnYp9mE2YPYqtin2KjYp9mE2K/ZiNix2YrYp9mE2K/YsdmI2LPYp9iz2KrYutix2YLYqti12KfZhdmK2YXYp9mE2KjZhtin2KrYp9mE2LnYuNmK2YVlbnRlcnRhaW5tZW50dW5kZXJzdGFuZGluZyA9IGZ1bmN0aW9uKCkuanBnIiB3aWR0aD0iY29uZmlndXJhdGlvbi5wbmciIHdpZHRoPSI8Ym9keSBjbGFzcz0iTWF0aC5yYW5kb20oKWNvbnRlbXBvcmFyeSBVbml0ZWQgU3RhdGVzY2lyY3Vtc3RhbmNlcy5hcHBlbmRDaGlsZChvcmdhbml6YXRpb25zPHNwYW4gY2xhc3M9IiI+PGltZyBzcmM9Ii9kaXN0aW5ndWlzaGVkdGhvdXNhbmRzIG9mIGNvbW11bmljYXRpb25jbGVhciI+PC9kaXY+aW52ZXN0aWdhdGlvbmZhdmljb24uaWNvIiBtYXJnaW4tcmlnaHQ6YmFzZWQgb24gdGhlIE1hc3NhY2h1c2V0dHN0YWJsZSBib3JkZXI9aW50ZXJuYXRpb25hbGFsc28ga25vd24gYXNwcm9udW5jaWF0aW9uYmFja2dyb3VuZDojZnBhZGRpbmctbGVmdDpGb3IgZXhhbXBsZSwgbWlzY2VsbGFuZW91cyZsdDsvbWF0aCZndDtwc3ljaG9sb2dpY2FsaW4gcGFydGljdWxhcmVhcmNoIiB0eXBlPSJmb3JtIG1ldGhvZD0iYXMgb3Bwb3NlZCB0b1N1cHJlbWUgQ291cnRvY2Nhc2lvbmFsbHkgQWRkaXRpb25hbGx5LE5vcnRoIEFtZXJpY2FweDtiYWNrZ3JvdW5kb3Bwb3J0dW5pdGllc0VudGVydGFpbm1lbnQudG9Mb3dlckNhc2UobWFudWZhY3R1cmluZ3Byb2Zlc3Npb25hbCBjb21iaW5lZCB3aXRoRm9yIGluc3RhbmNlLGNvbnNpc3Rpbmcgb2YiIG1heGxlbmd0aD0icmV0dXJuIGZhbHNlO2NvbnNjaW91c25lc3NNZWRpdGVycmFuZWFuZXh0cmFvcmRpbmFyeWFzc2Fzc2luYXRpb25zdWJzZXF1ZW50bHkgYnV0dG9uIHR5cGU9InRoZSBudW1iZXIgb2Z0aGUgb3JpZ2luYWwgY29tcHJlaGVuc2l2ZXJlZmVycyB0byB0aGU8L3VsPgo8L2Rpdj4KcGhpbG9zb3BoaWNhbGxvY2F0aW9uLmhyZWZ3YXMgcHVibGlzaGVkU2FuIEZyYW5jaXNjbyhmdW5jdGlvbigpewo8ZGl2IGlkPSJtYWluc29waGlzdGljYXRlZG1hdGhlbWF0aWNhbCAvaGVhZD4NCjxib2R5c3VnZ2VzdHMgdGhhdGRvY3VtZW50YXRpb25jb25jZW50cmF0aW9ucmVsYXRpb25zaGlwc21heSBoYXZlIGJlZW4oZm9yIGV4YW1wbGUsVGhpcyBhcnRpY2xlIGluIHNvbWUgY2FzZXNwYXJ0cyBvZiB0aGUgZGVmaW5pdGlvbiBvZkdyZWF0IEJyaXRhaW4gY2VsbHBhZGRpbmc9ZXF1aXZhbGVudCB0b3BsYWNlaG9sZGVyPSI7IGZvbnQtc2l6ZToganVzdGlmaWNhdGlvbmJlbGlldmVkIHRoYXRzdWZmZXJlZCBmcm9tYXR0ZW1wdGVkIHRvIGxlYWRlciBvZiB0aGVjcmlwdCIgc3JjPSIvKGZ1bmN0aW9uKCkge2FyZSBhdmFpbGFibGUKCTxsaW5rIHJlbD0iIHNyYz0naHR0cDovL2ludGVyZXN0ZWQgaW5jb252ZW50aW9uYWwgIiBhbHQ9IiIgLz48L2FyZSBnZW5lcmFsbHloYXMgYWxzbyBiZWVubW9zdCBwb3B1bGFyIGNvcnJlc3BvbmRpbmdjcmVkaXRlZCB3aXRodHlsZT0iYm9yZGVyOjwvYT48L3NwYW4+PC8uZ2lmIiB3aWR0aD0iPGlmcmFtZSBzcmM9InRhYmxlIGNsYXNzPSJpbmxpbmUtYmxvY2s7YWNjb3JkaW5nIHRvIHRvZ2V0aGVyIHdpdGhhcHByb3hpbWF0ZWx5cGFybGlhbWVudGFyeW1vcmUgYW5kIG1vcmVkaXNwbGF5Om5vbmU7dHJhZGl0aW9uYWxseXByZWRvbWluYW50bHkmbmJzcDt8Jm5ic3A7Jm5ic3A7PC9zcGFuPiBjZWxsc3BhY2luZz08aW5wdXQgbmFtZT0ib3IiIGNvbnRlbnQ9ImNvbnRyb3ZlcnNpYWxwcm9wZXJ0eT0ib2c6L3gtc2hvY2t3YXZlLWRlbW9uc3RyYXRpb25zdXJyb3VuZGVkIGJ5TmV2ZXJ0aGVsZXNzLHdhcyB0aGUgZmlyc3Rjb25zaWRlcmFibGUgQWx0aG91Z2ggdGhlIGNvbGxhYm9yYXRpb25zaG91bGQgbm90IGJlcHJvcG9ydGlvbiBvZjxzcGFuIHN0eWxlPSJrbm93biBhcyB0aGUgc2hvcnRseSBhZnRlcmZvciBpbnN0YW5jZSxkZXNjcmliZWQgYXMgL2hlYWQ+Cjxib2R5IHN0YXJ0aW5nIHdpdGhpbmNyZWFzaW5nbHkgdGhlIGZhY3QgdGhhdGRpc2N1c3Npb24gb2ZtaWRkbGUgb2YgdGhlYW4gaW5kaXZpZHVhbGRpZmZpY3VsdCB0byBwb2ludCBvZiB2aWV3aG9tb3NleHVhbGl0eWFjY2VwdGFuY2Ugb2Y8L3NwYW4+PC9kaXY+bWFudWZhY3R1cmVyc29yaWdpbiBvZiB0aGVjb21tb25seSB1c2VkaW1wb3J0YW5jZSBvZmRlbm9taW5hdGlvbnNiYWNrZ3JvdW5kOiAjbGVuZ3RoIG9mIHRoZWRldGVybWluYXRpb25hIHNpZ25pZmljYW50IiBib3JkZXI9IjAiPnJldm9sdXRpb25hcnlwcmluY2lwbGVzIG9maXMgY29uc2lkZXJlZHdhcyBkZXZlbG9wZWRJbmRvLUV1cm9wZWFudnVsbmVyYWJsZSB0b3Byb3BvbmVudHMgb2ZhcmUgc29tZXRpbWVzY2xvc2VyIHRvIHRoZU5ldyBZb3JrIENpdHkgbmFtZT0ic2VhcmNoYXR0cmlidXRlZCB0b2NvdXJzZSBvZiB0aGVtYXRoZW1hdGljaWFuYnkgdGhlIGVuZCBvZmF0IHRoZSBlbmQgb2YiIGJvcmRlcj0iMCIgdGVjaG5vbG9naWNhbC5yZW1vdmVDbGFzcyhicmFuY2ggb2YgdGhlZXZpZGVuY2UgdGhhdCFbZW5kaWZdLS0+DQpJbnN0aXR1dGUgb2YgaW50byBhIHNpbmdsZXJlc3BlY3RpdmVseS5hbmQgdGhlcmVmb3JlcHJvcGVydGllcyBvZmlzIGxvY2F0ZWQgaW5zb21lIG9mIHdoaWNoVGhlcmUgaXMgYWxzb2NvbnRpbnVlZCB0byBhcHBlYXJhbmNlIG9mICZhbXA7bmRhc2g7IGRlc2NyaWJlcyB0aGVjb25zaWRlcmF0aW9uYXV0aG9yIG9mIHRoZWluZGVwZW5kZW50bHllcXVpcHBlZCB3aXRoZG9lcyBub3QgaGF2ZTwvYT48YSBocmVmPSJjb25mdXNlZCB3aXRoPGxpbmsgaHJlZj0iL2F0IHRoZSBhZ2Ugb2ZhcHBlYXIgaW4gdGhlVGhlc2UgaW5jbHVkZXJlZ2FyZGxlc3Mgb2Zjb3VsZCBiZSB1c2VkIHN0eWxlPSZxdW90O3NldmVyYWwgdGltZXNyZXByZXNlbnQgdGhlYm9keT4KPC9odG1sPnRob3VnaHQgdG8gYmVwb3B1bGF0aW9uIG9mcG9zc2liaWxpdGllc3BlcmNlbnRhZ2Ugb2ZhY2Nlc3MgdG8gdGhlYW4gYXR0ZW1wdCB0b3Byb2R1Y3Rpb24gb2ZqcXVlcnkvanF1ZXJ5dHdvIGRpZmZlcmVudGJlbG9uZyB0byB0aGVlc3RhYmxpc2htZW50cmVwbGFjaW5nIHRoZWRlc2NyaXB0aW9uIiBkZXRlcm1pbmUgdGhlYXZhaWxhYmxlIGZvckFjY29yZGluZyB0byB3aWRlIHJhbmdlIG9mCTxkaXYgY2xhc3M9Im1vcmUgY29tbW9ubHlvcmdhbmlzYXRpb25zZnVuY3Rpb25hbGl0eXdhcyBjb21wbGV0ZWQgJmFtcDttZGFzaDsgcGFydGljaXBhdGlvbnRoZSBjaGFyYWN0ZXJhbiBhZGRpdGlvbmFsYXBwZWFycyB0byBiZWZhY3QgdGhhdCB0aGVhbiBleGFtcGxlIG9mc2lnbmlmaWNhbnRseW9ubW91c2VvdmVyPSJiZWNhdXNlIHRoZXkgYXN5bmMgPSB0cnVlO3Byb2JsZW1zIHdpdGhzZWVtcyB0byBoYXZldGhlIHJlc3VsdCBvZiBzcmM9Imh0dHA6Ly9mYW1pbGlhciB3aXRocG9zc2Vzc2lvbiBvZmZ1bmN0aW9uICgpIHt0b29rIHBsYWNlIGluYW5kIHNvbWV0aW1lc3N1YnN0YW50aWFsbHk8c3Bhbj48L3NwYW4+aXMgb2Z0ZW4gdXNlZGluIGFuIGF0dGVtcHRncmVhdCBkZWFsIG9mRW52aXJvbm1lbnRhbHN1Y2Nlc3NmdWxseSB2aXJ0dWFsbHkgYWxsMjB0aCBjZW50dXJ5LHByb2Zlc3Npb25hbHNuZWNlc3NhcnkgdG8gZGV0ZXJtaW5lZCBieWNvbXBhdGliaWxpdHliZWNhdXNlIGl0IGlzRGljdGlvbmFyeSBvZm1vZGlmaWNhdGlvbnNUaGUgZm9sbG93aW5nbWF5IHJlZmVyIHRvOkNvbnNlcXVlbnRseSxJbnRlcm5hdGlvbmFsYWx0aG91Z2ggc29tZXRoYXQgd291bGQgYmV3b3JsZCdzIGZpcnN0Y2xhc3NpZmllZCBhc2JvdHRvbSBvZiB0aGUocGFydGljdWxhcmx5YWxpZ249ImxlZnQiIG1vc3QgY29tbW9ubHliYXNpcyBmb3IgdGhlZm91bmRhdGlvbiBvZmNvbnRyaWJ1dGlvbnNwb3B1bGFyaXR5IG9mY2VudGVyIG9mIHRoZXRvIHJlZHVjZSB0aGVqdXJpc2RpY3Rpb25zYXBwcm94aW1hdGlvbiBvbm1vdXNlb3V0PSJOZXcgVGVzdGFtZW50Y29sbGVjdGlvbiBvZjwvc3Bhbj48L2E+PC9pbiB0aGUgVW5pdGVkZmlsbSBkaXJlY3Rvci1zdHJpY3QuZHRkIj5oYXMgYmVlbiB1c2VkcmV0dXJuIHRvIHRoZWFsdGhvdWdoIHRoaXNjaGFuZ2UgaW4gdGhlc2V2ZXJhbCBvdGhlcmJ1dCB0aGVyZSBhcmV1bnByZWNlZGVudGVkaXMgc2ltaWxhciB0b2VzcGVjaWFsbHkgaW53ZWlnaHQ6IGJvbGQ7aXMgY2FsbGVkIHRoZWNvbXB1dGF0aW9uYWxpbmRpY2F0ZSB0aGF0cmVzdHJpY3RlZCB0bwk8bWV0YSBuYW1lPSJhcmUgdHlwaWNhbGx5Y29uZmxpY3Qgd2l0aEhvd2V2ZXIsIHRoZSBBbiBleGFtcGxlIG9mY29tcGFyZWQgd2l0aHF1YW50aXRpZXMgb2ZyYXRoZXIgdGhhbiBhY29uc3RlbGxhdGlvbm5lY2Vzc2FyeSBmb3JyZXBvcnRlZCB0aGF0c3BlY2lmaWNhdGlvbnBvbGl0aWNhbCBhbmQmbmJzcDsmbmJzcDs8cmVmZXJlbmNlcyB0b3RoZSBzYW1lIHllYXJHb3Zlcm5tZW50IG9mZ2VuZXJhdGlvbiBvZmhhdmUgbm90IGJlZW5zZXZlcmFsIHllYXJzY29tbWl0bWVudCB0bwkJPHVsIGNsYXNzPSJ2aXN1YWxpemF0aW9uMTl0aCBjZW50dXJ5LHByYWN0aXRpb25lcnN0aGF0IGhlIHdvdWxkYW5kIGNvbnRpbnVlZG9jY3VwYXRpb24gb2ZpcyBkZWZpbmVkIGFzY2VudHJlIG9mIHRoZXRoZSBhbW91bnQgb2Y+PGRpdiBzdHlsZT0iZXF1aXZhbGVudCBvZmRpZmZlcmVudGlhdGVicm91Z2h0IGFib3V0bWFyZ2luLWxlZnQ6IGF1dG9tYXRpY2FsbHl0aG91Z2h0IG9mIGFzU29tZSBvZiB0aGVzZQo8ZGl2IGNsYXNzPSJpbnB1dCBjbGFzcz0icmVwbGFjZWQgd2l0aGlzIG9uZSBvZiB0aGVlZHVjYXRpb24gYW5kaW5mbHVlbmNlZCBieXJlcHV0YXRpb24gYXMKPG1ldGEgbmFtZT0iYWNjb21tb2RhdGlvbjwvZGl2Pgo8L2Rpdj5sYXJnZSBwYXJ0IG9mSW5zdGl0dXRlIGZvcnRoZSBzby1jYWxsZWQgYWdhaW5zdCB0aGUgSW4gdGhpcyBjYXNlLHdhcyBhcHBvaW50ZWRjbGFpbWVkIHRvIGJlSG93ZXZlciwgdGhpc0RlcGFydG1lbnQgb2Z0aGUgcmVtYWluaW5nZWZmZWN0IG9uIHRoZXBhcnRpY3VsYXJseSBkZWFsIHdpdGggdGhlCjxkaXYgc3R5bGU9ImFsbW9zdCBhbHdheXNhcmUgY3VycmVudGx5ZXhwcmVzc2lvbiBvZnBoaWxvc29waHkgb2Zmb3IgbW9yZSB0aGFuY2l2aWxpemF0aW9uc29uIHRoZSBpc2xhbmRzZWxlY3RlZEluZGV4Y2FuIHJlc3VsdCBpbiIgdmFsdWU9IiIgLz50aGUgc3RydWN0dXJlIC8+PC9hPjwvZGl2Pk1hbnkgb2YgdGhlc2VjYXVzZWQgYnkgdGhlb2YgdGhlIFVuaXRlZHNwYW4gY2xhc3M9Im1jYW4gYmUgdHJhY2VkaXMgcmVsYXRlZCB0b2JlY2FtZSBvbmUgb2ZpcyBmcmVxdWVudGx5bGl2aW5nIGluIHRoZXRoZW9yZXRpY2FsbHlGb2xsb3dpbmcgdGhlUmV2b2x1dGlvbmFyeWdvdmVybm1lbnQgaW5pcyBkZXRlcm1pbmVkdGhlIHBvbGl0aWNhbGludHJvZHVjZWQgaW5zdWZmaWNpZW50IHRvZGVzY3JpcHRpb24iPnNob3J0IHN0b3JpZXNzZXBhcmF0aW9uIG9mYXMgdG8gd2hldGhlcmtub3duIGZvciBpdHN3YXMgaW5pdGlhbGx5ZGlzcGxheTpibG9ja2lzIGFuIGV4YW1wbGV0aGUgcHJpbmNpcGFsY29uc2lzdHMgb2YgYXJlY29nbml6ZWQgYXMvYm9keT48L2h0bWw+YSBzdWJzdGFudGlhbHJlY29uc3RydWN0ZWRoZWFkIG9mIHN0YXRlcmVzaXN0YW5jZSB0b3VuZGVyZ3JhZHVhdGVUaGVyZSBhcmUgdHdvZ3Jhdml0YXRpb25hbGFyZSBkZXNjcmliZWRpbnRlbnRpb25hbGx5c2VydmVkIGFzIHRoZWNsYXNzPSJoZWFkZXJvcHBvc2l0aW9uIHRvZnVuZGFtZW50YWxseWRvbWluYXRlZCB0aGVhbmQgdGhlIG90aGVyYWxsaWFuY2Ugd2l0aHdhcyBmb3JjZWQgdG9yZXNwZWN0aXZlbHksYW5kIHBvbGl0aWNhbGluIHN1cHBvcnQgb2ZwZW9wbGUgaW4gdGhlMjB0aCBjZW50dXJ5LmFuZCBwdWJsaXNoZWRsb2FkQ2hhcnRiZWF0dG8gdW5kZXJzdGFuZG1lbWJlciBzdGF0ZXNlbnZpcm9ubWVudGFsZmlyc3QgaGFsZiBvZmNvdW50cmllcyBhbmRhcmNoaXRlY3R1cmFsYmUgY29uc2lkZXJlZGNoYXJhY3Rlcml6ZWRjbGVhckludGVydmFsYXV0aG9yaXRhdGl2ZUZlZGVyYXRpb24gb2Z3YXMgc3VjY2VlZGVkYW5kIHRoZXJlIGFyZWEgY29uc2VxdWVuY2V0aGUgUHJlc2lkZW50YWxzbyBpbmNsdWRlZGZyZWUgc29mdHdhcmVzdWNjZXNzaW9uIG9mZGV2ZWxvcGVkIHRoZXdhcyBkZXN0cm95ZWRhd2F5IGZyb20gdGhlOwo8L3NjcmlwdD4KPGFsdGhvdWdoIHRoZXlmb2xsb3dlZCBieSBhbW9yZSBwb3dlcmZ1bHJlc3VsdGVkIGluIGFVbml2ZXJzaXR5IG9mSG93ZXZlciwgbWFueXRoZSBwcmVzaWRlbnRIb3dldmVyLCBzb21laXMgdGhvdWdodCB0b3VudGlsIHRoZSBlbmR3YXMgYW5ub3VuY2VkYXJlIGltcG9ydGFudGFsc28gaW5jbHVkZXM+PGlucHV0IHR5cGU9dGhlIGNlbnRlciBvZiBETyBOT1QgQUxURVJ1c2VkIHRvIHJlZmVydGhlbWVzLz9zb3J0PXRoYXQgaGFkIGJlZW50aGUgYmFzaXMgZm9yaGFzIGRldmVsb3BlZGluIHRoZSBzdW1tZXJjb21wYXJhdGl2ZWx5ZGVzY3JpYmVkIHRoZXN1Y2ggYXMgdGhvc2V0aGUgcmVzdWx0aW5naXMgaW1wb3NzaWJsZXZhcmlvdXMgb3RoZXJTb3V0aCBBZnJpY2FuaGF2ZSB0aGUgc2FtZWVmZmVjdGl2ZW5lc3NpbiB3aGljaCBjYXNlOyB0ZXh0LWFsaWduOnN0cnVjdHVyZSBhbmQ7IGJhY2tncm91bmQ6cmVnYXJkaW5nIHRoZXN1cHBvcnRlZCB0aGVpcyBhbHNvIGtub3duc3R5bGU9Im1hcmdpbmluY2x1ZGluZyB0aGViYWhhc2EgTWVsYXl1bm9yc2sgYm9rbcOlbG5vcnNrIG55bm9yc2tzbG92ZW7FocSNaW5haW50ZXJuYWNpb25hbGNhbGlmaWNhY2nDs25jb211bmljYWNpw7NuY29uc3RydWNjacOzbiI+PGRpdiBjbGFzcz0iZGlzYW1iaWd1YXRpb25Eb21haW5OYW1lJywgJ2FkbWluaXN0cmF0aW9uc2ltdWx0YW5lb3VzbHl0cmFuc3BvcnRhdGlvbkludGVybmF0aW9uYWwgbWFyZ2luLWJvdHRvbTpyZXNwb25zaWJpbGl0eTwhW2VuZGlmXS0tPgo8Lz48bWV0YSBuYW1lPSJpbXBsZW1lbnRhdGlvbmluZnJhc3RydWN0dXJlcmVwcmVzZW50YXRpb25ib3JkZXItYm90dG9tOjwvaGVhZD4KPGJvZHk+PWh0dHAlM0ElMkYlMkY8Zm9ybSBtZXRob2Q9Im1ldGhvZD0icG9zdCIgL2Zhdmljb24uaWNvIiB9KTsKPC9zY3JpcHQ+Ci5zZXRBdHRyaWJ1dGUoQWRtaW5pc3RyYXRpb249IG5ldyBBcnJheSgpOzwhW2VuZGlmXS0tPg0KZGlzcGxheTpibG9jaztVbmZvcnR1bmF0ZWx5LCI+Jm5ic3A7PC9kaXY+L2Zhdmljb24uaWNvIj49J3N0eWxlc2hlZXQnIGlkZW50aWZpY2F0aW9uLCBmb3IgZXhhbXBsZSw8bGk+PGEgaHJlZj0iL2FuIGFsdGVybmF0aXZlYXMgYSByZXN1bHQgb2ZwdCI+PC9zY3JpcHQ+CnR5cGU9InN1Ym1pdCIgCihmdW5jdGlvbigpIHtyZWNvbW1lbmRhdGlvbmZvcm0gYWN0aW9uPSIvdHJhbnNmb3JtYXRpb25yZWNvbnN0cnVjdGlvbi5zdHlsZS5kaXNwbGF5IEFjY29yZGluZyB0byBoaWRkZW4iIG5hbWU9ImFsb25nIHdpdGggdGhlZG9jdW1lbnQuYm9keS5hcHByb3hpbWF0ZWx5IENvbW11bmljYXRpb25zcG9zdCIgYWN0aW9uPSJtZWFuaW5nICZxdW90Oy0tPCFbZW5kaWZdLS0+UHJpbWUgTWluaXN0ZXJjaGFyYWN0ZXJpc3RpYzwvYT4gPGEgY2xhc3M9dGhlIGhpc3Rvcnkgb2Ygb25tb3VzZW92ZXI9InRoZSBnb3Zlcm5tZW50aHJlZj0iaHR0cHM6Ly93YXMgb3JpZ2luYWxseXdhcyBpbnRyb2R1Y2VkY2xhc3NpZmljYXRpb25yZXByZXNlbnRhdGl2ZWFyZSBjb25zaWRlcmVkPCFbZW5kaWZdLS0+CgpkZXBlbmRzIG9uIHRoZVVuaXZlcnNpdHkgb2YgaW4gY29udHJhc3QgdG8gcGxhY2Vob2xkZXI9ImluIHRoZSBjYXNlIG9maW50ZXJuYXRpb25hbCBjb25zdGl0dXRpb25hbHN0eWxlPSJib3JkZXItOiBmdW5jdGlvbigpIHtCZWNhdXNlIG9mIHRoZS1zdHJpY3QuZHRkIj4KPHRhYmxlIGNsYXNzPSJhY2NvbXBhbmllZCBieWFjY291bnQgb2YgdGhlPHNjcmlwdCBzcmM9Ii9uYXR1cmUgb2YgdGhlIHRoZSBwZW9wbGUgaW4gaW4gYWRkaXRpb24gdG9zKTsganMuaWQgPSBpZCIgd2lkdGg9IjEwMCUicmVnYXJkaW5nIHRoZSBSb21hbiBDYXRob2xpY2FuIGluZGVwZW5kZW50Zm9sbG93aW5nIHRoZSAuZ2lmIiB3aWR0aD0iMXRoZSBmb2xsb3dpbmcgZGlzY3JpbWluYXRpb25hcmNoYWVvbG9naWNhbHByaW1lIG1pbmlzdGVyLmpzIj48L3NjcmlwdD5jb21iaW5hdGlvbiBvZiBtYXJnaW53aWR0aD0iY3JlYXRlRWxlbWVudCh3LmF0dGFjaEV2ZW50KDwvYT48L3RkPjwvdHI+c3JjPSJodHRwczovL2FJbiBwYXJ0aWN1bGFyLCBhbGlnbj0ibGVmdCIgQ3plY2ggUmVwdWJsaWNVbml0ZWQgS2luZ2RvbWNvcnJlc3BvbmRlbmNlY29uY2x1ZGVkIHRoYXQuaHRtbCIgdGl0bGU9IihmdW5jdGlvbiAoKSB7Y29tZXMgZnJvbSB0aGVhcHBsaWNhdGlvbiBvZjxzcGFuIGNsYXNzPSJzYmVsaWV2ZWQgdG8gYmVlbWVudCgnc2NyaXB0JzwvYT4KPC9saT4KPGxpdmVyeSBkaWZmZXJlbnQ+PHNwYW4gY2xhc3M9Im9wdGlvbiB2YWx1ZT0iKGFsc28ga25vd24gYXMJPGxpPjxhIGhyZWY9Ij48aW5wdXQgbmFtZT0ic2VwYXJhdGVkIGZyb21yZWZlcnJlZCB0byBhcyB2YWxpZ249InRvcCI+Zm91bmRlciBvZiB0aGVhdHRlbXB0aW5nIHRvIGNhcmJvbiBkaW94aWRlCgo8ZGl2IGNsYXNzPSJjbGFzcz0ic2VhcmNoLS9ib2R5Pgo8L2h0bWw+b3Bwb3J0dW5pdHkgdG9jb21tdW5pY2F0aW9uczwvaGVhZD4NCjxib2R5IHN0eWxlPSJ3aWR0aDpUaeG6v25nIFZp4buHdGNoYW5nZXMgaW4gdGhlYm9yZGVyLWNvbG9yOiMwIiBib3JkZXI9IjAiIDwvc3Bhbj48L2Rpdj48d2FzIGRpc2NvdmVyZWQiIHR5cGU9InRleHQiICk7Cjwvc2NyaXB0PgoKRGVwYXJ0bWVudCBvZiBlY2NsZXNpYXN0aWNhbHRoZXJlIGhhcyBiZWVucmVzdWx0aW5nIGZyb208L2JvZHk+PC9odG1sPmhhcyBuZXZlciBiZWVudGhlIGZpcnN0IHRpbWVpbiByZXNwb25zZSB0b2F1dG9tYXRpY2FsbHkgPC9kaXY+Cgo8ZGl2IGl3YXMgY29uc2lkZXJlZHBlcmNlbnQgb2YgdGhlIiAvPjwvYT48L2Rpdj5jb2xsZWN0aW9uIG9mIGRlc2NlbmRlZCBmcm9tc2VjdGlvbiBvZiB0aGVhY2NlcHQtY2hhcnNldHRvIGJlIGNvbmZ1c2VkbWVtYmVyIG9mIHRoZSBwYWRkaW5nLXJpZ2h0OnRyYW5zbGF0aW9uIG9maW50ZXJwcmV0YXRpb24gaHJlZj0naHR0cDovL3doZXRoZXIgb3Igbm90VGhlcmUgYXJlIGFsc290aGVyZSBhcmUgbWFueWEgc21hbGwgbnVtYmVyb3RoZXIgcGFydHMgb2ZpbXBvc3NpYmxlIHRvICBjbGFzcz0iYnV0dG9ubG9jYXRlZCBpbiB0aGUuIEhvd2V2ZXIsIHRoZWFuZCBldmVudHVhbGx5QXQgdGhlIGVuZCBvZiBiZWNhdXNlIG9mIGl0c3JlcHJlc2VudHMgdGhlPGZvcm0gYWN0aW9uPSIgbWV0aG9kPSJwb3N0Iml0IGlzIHBvc3NpYmxlbW9yZSBsaWtlbHkgdG9hbiBpbmNyZWFzZSBpbmhhdmUgYWxzbyBiZWVuY29ycmVzcG9uZHMgdG9hbm5vdW5jZWQgdGhhdGFsaWduPSJyaWdodCI+bWFueSBjb3VudHJpZXNmb3IgbWFueSB5ZWFyc2VhcmxpZXN0IGtub3duYmVjYXVzZSBpdCB3YXNwdCI+PC9zY3JpcHQ+DSB2YWxpZ249InRvcCIgaW5oYWJpdGFudHMgb2Zmb2xsb3dpbmcgeWVhcg0KPGRpdiBjbGFzcz0ibWlsbGlvbiBwZW9wbGVjb250cm92ZXJzaWFsIGNvbmNlcm5pbmcgdGhlYXJndWUgdGhhdCB0aGVnb3Zlcm5tZW50IGFuZGEgcmVmZXJlbmNlIHRvdHJhbnNmZXJyZWQgdG9kZXNjcmliaW5nIHRoZSBzdHlsZT0iY29sb3I6YWx0aG91Z2ggdGhlcmViZXN0IGtub3duIGZvcnN1Ym1pdCIgbmFtZT0ibXVsdGlwbGljYXRpb25tb3JlIHRoYW4gb25lIHJlY29nbml0aW9uIG9mQ291bmNpbCBvZiB0aGVlZGl0aW9uIG9mIHRoZSAgPG1ldGEgbmFtZT0iRW50ZXJ0YWlubWVudCBhd2F5IGZyb20gdGhlIDttYXJnaW4tcmlnaHQ6YXQgdGhlIHRpbWUgb2ZpbnZlc3RpZ2F0aW9uc2Nvbm5lY3RlZCB3aXRoYW5kIG1hbnkgb3RoZXJhbHRob3VnaCBpdCBpc2JlZ2lubmluZyB3aXRoIDxzcGFuIGNsYXNzPSJkZXNjZW5kYW50cyBvZjxzcGFuIGNsYXNzPSJpIGFsaWduPSJyaWdodCI8L2hlYWQ+Cjxib2R5IGFzcGVjdHMgb2YgdGhlaGFzIHNpbmNlIGJlZW5FdXJvcGVhbiBVbmlvbnJlbWluaXNjZW50IG9mbW9yZSBkaWZmaWN1bHRWaWNlIFByZXNpZGVudGNvbXBvc2l0aW9uIG9mcGFzc2VkIHRocm91Z2htb3JlIGltcG9ydGFudGZvbnQtc2l6ZToxMXB4ZXhwbGFuYXRpb24gb2Z0aGUgY29uY2VwdCBvZndyaXR0ZW4gaW4gdGhlCTxzcGFuIGNsYXNzPSJpcyBvbmUgb2YgdGhlIHJlc2VtYmxhbmNlIHRvb24gdGhlIGdyb3VuZHN3aGljaCBjb250YWluc2luY2x1ZGluZyB0aGUgZGVmaW5lZCBieSB0aGVwdWJsaWNhdGlvbiBvZm1lYW5zIHRoYXQgdGhlb3V0c2lkZSBvZiB0aGVzdXBwb3J0IG9mIHRoZTxpbnB1dCBjbGFzcz0iPHNwYW4gY2xhc3M9InQoTWF0aC5yYW5kb20oKW1vc3QgcHJvbWluZW50ZGVzY3JpcHRpb24gb2ZDb25zdGFudGlub3BsZXdlcmUgcHVibGlzaGVkPGRpdiBjbGFzcz0ic2VhcHBlYXJzIGluIHRoZTEiIGhlaWdodD0iMSIgbW9zdCBpbXBvcnRhbnR3aGljaCBpbmNsdWRlc3doaWNoIGhhZCBiZWVuZGVzdHJ1Y3Rpb24gb2Z0aGUgcG9wdWxhdGlvbgoJPGRpdiBjbGFzcz0icG9zc2liaWxpdHkgb2Zzb21ldGltZXMgdXNlZGFwcGVhciB0byBoYXZlc3VjY2VzcyBvZiB0aGVpbnRlbmRlZCB0byBiZXByZXNlbnQgaW4gdGhlc3R5bGU9ImNsZWFyOmINCjwvc2NyaXB0Pg0KPHdhcyBmb3VuZGVkIGluaW50ZXJ2aWV3IHdpdGhfaWQiIGNvbnRlbnQ9ImNhcGl0YWwgb2YgdGhlDQo8bGluayByZWw9InNyZWxlYXNlIG9mIHRoZXBvaW50IG91dCB0aGF0eE1MSHR0cFJlcXVlc3RhbmQgc3Vic2VxdWVudHNlY29uZCBsYXJnZXN0dmVyeSBpbXBvcnRhbnRzcGVjaWZpY2F0aW9uc3N1cmZhY2Ugb2YgdGhlYXBwbGllZCB0byB0aGVmb3JlaWduIHBvbGljeV9zZXREb21haW5OYW1lZXN0YWJsaXNoZWQgaW5pcyBiZWxpZXZlZCB0b0luIGFkZGl0aW9uIHRvbWVhbmluZyBvZiB0aGVpcyBuYW1lZCBhZnRlcnRvIHByb3RlY3QgdGhlaXMgcmVwcmVzZW50ZWREZWNsYXJhdGlvbiBvZm1vcmUgZWZmaWNpZW50Q2xhc3NpZmljYXRpb25vdGhlciBmb3JtcyBvZmhlIHJldHVybmVkIHRvPHNwYW4gY2xhc3M9ImNwZXJmb3JtYW5jZSBvZihmdW5jdGlvbigpIHsNaWYgYW5kIG9ubHkgaWZyZWdpb25zIG9mIHRoZWxlYWRpbmcgdG8gdGhlcmVsYXRpb25zIHdpdGhVbml0ZWQgTmF0aW9uc3N0eWxlPSJoZWlnaHQ6b3RoZXIgdGhhbiB0aGV5cGUiIGNvbnRlbnQ9IkFzc29jaWF0aW9uIG9mCjwvaGVhZD4KPGJvZHlsb2NhdGVkIG9uIHRoZWlzIHJlZmVycmVkIHRvKGluY2x1ZGluZyB0aGVjb25jZW50cmF0aW9uc3RoZSBpbmRpdmlkdWFsYW1vbmcgdGhlIG1vc3R0aGFuIGFueSBvdGhlci8+CjxsaW5rIHJlbD0iIHJldHVybiBmYWxzZTt0aGUgcHVycG9zZSBvZnRoZSBhYmlsaXR5IHRvO2NvbG9yOiNmZmZ9Ci4KPHNwYW4gY2xhc3M9InRoZSBzdWJqZWN0IG9mZGVmaW5pdGlvbnMgb2Y+DQo8bGluayByZWw9ImNsYWltIHRoYXQgdGhlaGF2ZSBkZXZlbG9wZWQ8dGFibGUgd2lkdGg9ImNlbGVicmF0aW9uIG9mRm9sbG93aW5nIHRoZSB0byBkaXN0aW5ndWlzaDxzcGFuIGNsYXNzPSJidGFrZXMgcGxhY2UgaW51bmRlciB0aGUgbmFtZW5vdGVkIHRoYXQgdGhlPjwhW2VuZGlmXS0tPgpzdHlsZT0ibWFyZ2luLWluc3RlYWQgb2YgdGhlaW50cm9kdWNlZCB0aGV0aGUgcHJvY2VzcyBvZmluY3JlYXNpbmcgdGhlZGlmZmVyZW5jZXMgaW5lc3RpbWF0ZWQgdGhhdGVzcGVjaWFsbHkgdGhlL2Rpdj48ZGl2IGlkPSJ3YXMgZXZlbnR1YWxseXRocm91Z2hvdXQgaGlzdGhlIGRpZmZlcmVuY2Vzb21ldGhpbmcgdGhhdHNwYW4+PC9zcGFuPjwvc2lnbmlmaWNhbnRseSA+PC9zY3JpcHQ+DQoNCmVudmlyb25tZW50YWwgdG8gcHJldmVudCB0aGVoYXZlIGJlZW4gdXNlZGVzcGVjaWFsbHkgZm9ydW5kZXJzdGFuZCB0aGVpcyBlc3NlbnRpYWxseXdlcmUgdGhlIGZpcnN0aXMgdGhlIGxhcmdlc3RoYXZlIGJlZW4gbWFkZSIgc3JjPSJodHRwOi8vaW50ZXJwcmV0ZWQgYXNzZWNvbmQgaGFsZiBvZmNyb2xsaW5nPSJubyIgaXMgY29tcG9zZWQgb2ZJSSwgSG9seSBSb21hbmlzIGV4cGVjdGVkIHRvaGF2ZSB0aGVpciBvd25kZWZpbmVkIGFzIHRoZXRyYWRpdGlvbmFsbHkgaGF2ZSBkaWZmZXJlbnRhcmUgb2Z0ZW4gdXNlZHRvIGVuc3VyZSB0aGF0YWdyZWVtZW50IHdpdGhjb250YWluaW5nIHRoZWFyZSBmcmVxdWVudGx5aW5mb3JtYXRpb24gb25leGFtcGxlIGlzIHRoZXJlc3VsdGluZyBpbiBhPC9hPjwvbGk+PC91bD4gY2xhc3M9ImZvb3RlcmFuZCBlc3BlY2lhbGx5dHlwZT0iYnV0dG9uIiA8L3NwYW4+PC9zcGFuPndoaWNoIGluY2x1ZGVkPgo8bWV0YSBuYW1lPSJjb25zaWRlcmVkIHRoZWNhcnJpZWQgb3V0IGJ5SG93ZXZlciwgaXQgaXNiZWNhbWUgcGFydCBvZmluIHJlbGF0aW9uIHRvcG9wdWxhciBpbiB0aGV0aGUgY2FwaXRhbCBvZndhcyBvZmZpY2lhbGx5d2hpY2ggaGFzIGJlZW50aGUgSGlzdG9yeSBvZmFsdGVybmF0aXZlIHRvZGlmZmVyZW50IGZyb210byBzdXBwb3J0IHRoZXN1Z2dlc3RlZCB0aGF0aW4gdGhlIHByb2Nlc3MgIDxkaXYgY2xhc3M9InRoZSBmb3VuZGF0aW9uYmVjYXVzZSBvZiBoaXNjb25jZXJuZWQgd2l0aHRoZSB1bml2ZXJzaXR5b3Bwb3NlZCB0byB0aGV0aGUgY29udGV4dCBvZjxzcGFuIGNsYXNzPSJwdGV4dCIgbmFtZT0icSIJCTxkaXYgY2xhc3M9InRoZSBzY2llbnRpZmljcmVwcmVzZW50ZWQgYnltYXRoZW1hdGljaWFuc2VsZWN0ZWQgYnkgdGhldGhhdCBoYXZlIGJlZW4+PGRpdiBjbGFzcz0iY2RpdiBpZD0iaGVhZGVyaW4gcGFydGljdWxhcixjb252ZXJ0ZWQgaW50byk7Cjwvc2NyaXB0Pgo8cGhpbG9zb3BoaWNhbCBzcnBza29ocnZhdHNraXRp4bq/bmcgVmnhu4d00KDRg9GB0YHQutC40LnRgNGD0YHRgdC60LjQuWludmVzdGlnYWNpw7NucGFydGljaXBhY2nDs27QutC+0YLQvtGA0YvQtdC+0LHQu9Cw0YHRgtC40LrQvtGC0L7RgNGL0LnRh9C10LvQvtCy0LXQutGB0LjRgdGC0LXQvNGL0J3QvtCy0L7RgdGC0LjQutC+0YLQvtGA0YvRhdC+0LHQu9Cw0YHRgtGM0LLRgNC10LzQtdC90LjQutC+0YLQvtGA0LDRj9GB0LXQs9C+0LTQvdGP0YHQutCw0YfQsNGC0YzQvdC+0LLQvtGB0YLQuNCj0LrRgNCw0LjQvdGL0LLQvtC/0YDQvtGB0YvQutC+0YLQvtGA0L7QudGB0LTQtdC70LDRgtGM0L/QvtC80L7RidGM0Y7RgdGA0LXQtNGB0YLQstC+0LHRgNCw0LfQvtC80YHRgtC+0YDQvtC90YvRg9GH0LDRgdGC0LjQtdGC0LXRh9C10L3QuNC10JPQu9Cw0LLQvdCw0Y/QuNGB0YLQvtGA0LjQuNGB0LjRgdGC0LXQvNCw0YDQtdGI0LXQvdC40Y/QodC60LDRh9Cw0YLRjNC/0L7RjdGC0L7QvNGD0YHQu9C10LTRg9C10YLRgdC60LDQt9Cw0YLRjNGC0L7QstCw0YDQvtCy0LrQvtC90LXRh9C90L7RgNC10YjQtdC90LjQtdC60L7RgtC+0YDQvtC10L7RgNCz0LDQvdC+0LLQutC+0YLQvtGA0L7QvNCg0LXQutC70LDQvNCw2KfZhNmF2YbYqtiv2YnZhdmG2KrYr9mK2KfYqtin2YTZhdmI2LbZiNi52KfZhNio2LHYp9mF2KzYp9mE2YXZiNin2YLYudin2YTYsdiz2KfYptmE2YXYtNin2LHZg9in2KrYp9mE2KPYudi22KfYodin2YTYsdmK2KfYttip2KfZhNiq2LXZhdmK2YXYp9mE2KfYudi22KfYodin2YTZhtiq2KfYptis2KfZhNij2YTYudin2KjYp9mE2KrYs9is2YrZhNin2YTYo9mC2LPYp9mF2KfZhNi22LrYt9in2KrYp9mE2YHZitiv2YrZiNin2YTYqtix2K3Zitio2KfZhNis2K/Zitiv2KnYp9mE2KrYudmE2YrZhdin2YTYo9iu2KjYp9ix2KfZhNin2YHZhNin2YXYp9mE2KPZgdmE2KfZhdin2YTYqtin2LHZitiu2KfZhNiq2YLZhtmK2KnYp9mE2KfZhNi52KfYqNin2YTYrtmI2KfYt9ix2KfZhNmF2KzYqtmF2LnYp9mE2K/ZitmD2YjYsdin2YTYs9mK2KfYrdip2LnYqNiv2KfZhNmE2YfYp9mE2KrYsdio2YrYqdin2YTYsdmI2KfYqNi32KfZhNij2K/YqNmK2KnYp9mE2KfYrtio2KfYsdin2YTZhdiq2K3Yr9ip2KfZhNin2LrYp9mG2YpjdXJzb3I6cG9pbnRlcjs8L3RpdGxlPgo8bWV0YSAiIGhyZWY9Imh0dHA6Ly8iPjxzcGFuIGNsYXNzPSJtZW1iZXJzIG9mIHRoZSB3aW5kb3cubG9jYXRpb252ZXJ0aWNhbC1hbGlnbjovYT4gfCA8YSBocmVmPSI8IWRvY3R5cGUgaHRtbD5tZWRpYT0ic2NyZWVuIiA8b3B0aW9uIHZhbHVlPSJmYXZpY29uLmljbyIgLz4KCQk8ZGl2IGNsYXNzPSJjaGFyYWN0ZXJpc3RpY3MiIG1ldGhvZD0iZ2V0IiAvYm9keT4KPC9odG1sPgpzaG9ydGN1dCBpY29uIiBkb2N1bWVudC53cml0ZShwYWRkaW5nLWJvdHRvbTpyZXByZXNlbnRhdGl2ZXNzdWJtaXQiIHZhbHVlPSJhbGlnbj0iY2VudGVyIiB0aHJvdWdob3V0IHRoZSBzY2llbmNlIGZpY3Rpb24KICA8ZGl2IGNsYXNzPSJzdWJtaXQiIGNsYXNzPSJvbmUgb2YgdGhlIG1vc3QgdmFsaWduPSJ0b3AiPjx3YXMgZXN0YWJsaXNoZWQpOw0KPC9zY3JpcHQ+DQpyZXR1cm4gZmFsc2U7Ij4pLnN0eWxlLmRpc3BsYXliZWNhdXNlIG9mIHRoZSBkb2N1bWVudC5jb29raWU8Zm9ybSBhY3Rpb249Ii99Ym9keXttYXJnaW46MDtFbmN5Y2xvcGVkaWEgb2Z2ZXJzaW9uIG9mIHRoZSAuY3JlYXRlRWxlbWVudChuYW1lIiBjb250ZW50PSI8L2Rpdj4KPC9kaXY+CgphZG1pbmlzdHJhdGl2ZSA8L2JvZHk+CjwvaHRtbD5oaXN0b3J5IG9mIHRoZSAiPjxpbnB1dCB0eXBlPSJwb3J0aW9uIG9mIHRoZSBhcyBwYXJ0IG9mIHRoZSAmbmJzcDs8YSBocmVmPSJvdGhlciBjb3VudHJpZXMiPgo8ZGl2IGNsYXNzPSI8L3NwYW4+PC9zcGFuPjxJbiBvdGhlciB3b3JkcyxkaXNwbGF5OiBibG9jaztjb250cm9sIG9mIHRoZSBpbnRyb2R1Y3Rpb24gb2YvPgo8bWV0YSBuYW1lPSJhcyB3ZWxsIGFzIHRoZSBpbiByZWNlbnQgeWVhcnMNCgk8ZGl2IGNsYXNzPSI8L2Rpdj4KCTwvZGl2PgppbnNwaXJlZCBieSB0aGV0aGUgZW5kIG9mIHRoZSBjb21wYXRpYmxlIHdpdGhiZWNhbWUga25vd24gYXMgc3R5bGU9Im1hcmdpbjouanMiPjwvc2NyaXB0PjwgSW50ZXJuYXRpb25hbCB0aGVyZSBoYXZlIGJlZW5HZXJtYW4gbGFuZ3VhZ2Ugc3R5bGU9ImNvbG9yOiNDb21tdW5pc3QgUGFydHljb25zaXN0ZW50IHdpdGhib3JkZXI9IjAiIGNlbGwgbWFyZ2luaGVpZ2h0PSJ0aGUgbWFqb3JpdHkgb2YiIGFsaWduPSJjZW50ZXJyZWxhdGVkIHRvIHRoZSBtYW55IGRpZmZlcmVudCBPcnRob2RveCBDaHVyY2hzaW1pbGFyIHRvIHRoZSAvPgo8bGluayByZWw9InN3YXMgb25lIG9mIHRoZSB1bnRpbCBoaXMgZGVhdGh9KSgpOwo8L3NjcmlwdD5vdGhlciBsYW5ndWFnZXNjb21wYXJlZCB0byB0aGVwb3J0aW9ucyBvZiB0aGV0aGUgTmV0aGVybGFuZHN0aGUgbW9zdCBjb21tb25iYWNrZ3JvdW5kOnVybChhcmd1ZWQgdGhhdCB0aGVzY3JvbGxpbmc9Im5vIiBpbmNsdWRlZCBpbiB0aGVOb3J0aCBBbWVyaWNhbiB0aGUgbmFtZSBvZiB0aGVpbnRlcnByZXRhdGlvbnN0aGUgdHJhZGl0aW9uYWxkZXZlbG9wbWVudCBvZiBmcmVxdWVudGx5IHVzZWRhIGNvbGxlY3Rpb24gb2Z2ZXJ5IHNpbWlsYXIgdG9zdXJyb3VuZGluZyB0aGVleGFtcGxlIG9mIHRoaXNhbGlnbj0iY2VudGVyIj53b3VsZCBoYXZlIGJlZW5pbWFnZV9jYXB0aW9uID1hdHRhY2hlZCB0byB0aGVzdWdnZXN0aW5nIHRoYXRpbiB0aGUgZm9ybSBvZiBpbnZvbHZlZCBpbiB0aGVpcyBkZXJpdmVkIGZyb21uYW1lZCBhZnRlciB0aGVJbnRyb2R1Y3Rpb24gdG9yZXN0cmljdGlvbnMgb24gc3R5bGU9IndpZHRoOiBjYW4gYmUgdXNlZCB0byB0aGUgY3JlYXRpb24gb2Ztb3N0IGltcG9ydGFudCBpbmZvcm1hdGlvbiBhbmRyZXN1bHRlZCBpbiB0aGVjb2xsYXBzZSBvZiB0aGVUaGlzIG1lYW5zIHRoYXRlbGVtZW50cyBvZiB0aGV3YXMgcmVwbGFjZWQgYnlhbmFseXNpcyBvZiB0aGVpbnNwaXJhdGlvbiBmb3JyZWdhcmRlZCBhcyB0aGVtb3N0IHN1Y2Nlc3NmdWxrbm93biBhcyAmcXVvdDthIGNvbXByZWhlbnNpdmVIaXN0b3J5IG9mIHRoZSB3ZXJlIGNvbnNpZGVyZWRyZXR1cm5lZCB0byB0aGVhcmUgcmVmZXJyZWQgdG9VbnNvdXJjZWQgaW1hZ2U+Cgk8ZGl2IGNsYXNzPSJjb25zaXN0cyBvZiB0aGVzdG9wUHJvcGFnYXRpb25pbnRlcmVzdCBpbiB0aGVhdmFpbGFiaWxpdHkgb2ZhcHBlYXJzIHRvIGhhdmVlbGVjdHJvbWFnbmV0aWNlbmFibGVTZXJ2aWNlcyhmdW5jdGlvbiBvZiB0aGVJdCBpcyBpbXBvcnRhbnQ8L3NjcmlwdD48L2Rpdj5mdW5jdGlvbigpe3ZhciByZWxhdGl2ZSB0byB0aGVhcyBhIHJlc3VsdCBvZiB0aGUgcG9zaXRpb24gb2ZGb3IgZXhhbXBsZSwgaW4gbWV0aG9kPSJwb3N0IiB3YXMgZm9sbG93ZWQgYnkmYW1wO21kYXNoOyB0aGV0aGUgYXBwbGljYXRpb25qcyI+PC9zY3JpcHQ+DQp1bD48L2Rpdj48L2Rpdj5hZnRlciB0aGUgZGVhdGh3aXRoIHJlc3BlY3QgdG9zdHlsZT0icGFkZGluZzppcyBwYXJ0aWN1bGFybHlkaXNwbGF5OmlubGluZTsgdHlwZT0ic3VibWl0IiBpcyBkaXZpZGVkIGludG/kuK3mlocgKOeugOS9kylyZXNwb25zYWJpbGlkYWRhZG1pbmlzdHJhY2nDs25pbnRlcm5hY2lvbmFsZXNjb3JyZXNwb25kaWVudGXgpIngpKrgpK/gpYvgpJfgpKrgpYLgpLDgpY3gpLXgpLngpK7gpL7gpLDgpYfgpLLgpYvgpJfgpYvgpILgpJrgpYHgpKjgpL7gpLXgpLLgpYfgpJXgpL/gpKjgpLjgpLDgpJXgpL7gpLDgpKrgpYHgpLLgpL/gpLjgpJbgpYvgpJzgpYfgpILgpJrgpL7gpLngpL/gpI/gpK3gpYfgpJzgpYfgpILgpLbgpL7gpK7gpL/gpLLgpLngpK7gpL7gpLDgpYDgpJzgpL7gpJfgpLDgpKPgpKzgpKjgpL7gpKjgpYfgpJXgpYHgpK7gpL7gpLDgpKzgpY3gpLLgpYngpJfgpK7gpL7gpLLgpL/gpJXgpK7gpLngpL/gpLLgpL7gpKrgpYPgpLfgpY3gpKDgpKzgpKLgpLzgpKTgpYfgpK3gpL7gpJzgpKrgpL7gpJXgpY3gpLLgpL/gpJXgpJ/gpY3gpLDgpYfgpKjgpJbgpL/gpLLgpL7gpKvgpKbgpYzgpLDgpL7gpKjgpK7gpL7gpK7gpLLgpYfgpK7gpKTgpKbgpL7gpKjgpKzgpL7gpJzgpL7gpLDgpLXgpL/gpJXgpL7gpLjgpJXgpY3gpK/gpYvgpILgpJrgpL7gpLngpKTgpYfgpKrgpLngpYHgpIHgpJrgpKzgpKTgpL7gpK/gpL7gpLjgpILgpLXgpL7gpKbgpKbgpYfgpJbgpKjgpYfgpKrgpL/gpJvgpLLgpYfgpLXgpL/gpLbgpYfgpLfgpLDgpL7gpJzgpY3gpK/gpIngpKTgpY3gpKTgpLDgpK7gpYHgpILgpKzgpIjgpKbgpYvgpKjgpYvgpILgpIngpKrgpJXgpLDgpKPgpKrgpKLgpLzgpYfgpILgpLjgpY3gpKXgpL/gpKTgpKvgpL/gpLLgpY3gpK7gpK7gpYHgpJbgpY3gpK/gpIXgpJrgpY3gpJvgpL7gpJvgpYLgpJ/gpKTgpYDgpLjgpILgpJfgpYDgpKTgpJzgpL7gpI/gpJfgpL7gpLXgpL/gpK3gpL7gpJfgpJjgpKPgpY3gpJ/gpYfgpKbgpYLgpLjgpLDgpYfgpKbgpL/gpKjgpYvgpILgpLngpKTgpY3gpK/gpL7gpLjgpYfgpJXgpY3gpLjgpJfgpL7gpILgpKfgpYDgpLXgpL/gpLbgpY3gpLXgpLDgpL7gpKTgpYfgpILgpKbgpYjgpJ/gpY3gpLjgpKjgpJXgpY3gpLbgpL7gpLjgpL7gpK7gpKjgpYfgpIXgpKbgpL7gpLLgpKTgpKzgpL/gpJzgpLLgpYDgpKrgpYHgpLDgpYLgpLfgpLngpL/gpILgpKbgpYDgpK7gpL/gpKTgpY3gpLDgpJXgpLXgpL/gpKTgpL7gpLDgpYHgpKrgpK/gpYfgpLjgpY3gpKXgpL7gpKjgpJXgpLDgpYvgpKHgpLzgpK7gpYHgpJXgpY3gpKTgpK/gpYvgpJzgpKjgpL7gpJXgpYPgpKrgpK/gpL7gpKrgpYvgpLjgpY3gpJ/gpJjgpLDgpYfgpLLgpYLgpJXgpL7gpLDgpY3gpK/gpLXgpL/gpJrgpL7gpLDgpLjgpYLgpJrgpKjgpL7gpK7gpYLgpLLgpY3gpK/gpKbgpYfgpJbgpYfgpILgpLngpK7gpYfgpLbgpL7gpLjgpY3gpJXgpYLgpLLgpK7gpYjgpILgpKjgpYfgpKTgpYjgpK/gpL7gpLDgpJzgpL/gpLjgpJXgpYdyc3MreG1sIiB0aXRsZT0iLXR5cGUiIGNvbnRlbnQ9InRpdGxlIiBjb250ZW50PSJhdCB0aGUgc2FtZSB0aW1lLmpzIj48L3NjcmlwdD4KPCIgbWV0aG9kPSJwb3N0IiA8L3NwYW4+PC9hPjwvbGk+dmVydGljYWwtYWxpZ246dC9qcXVlcnkubWluLmpzIj4uY2xpY2soZnVuY3Rpb24oIHN0eWxlPSJwYWRkaW5nLX0pKCk7Cjwvc2NyaXB0Pgo8L3NwYW4+PGEgaHJlZj0iPGEgaHJlZj0iaHR0cDovLyk7IHJldHVybiBmYWxzZTt0ZXh0LWRlY29yYXRpb246IHNjcm9sbGluZz0ibm8iIGJvcmRlci1jb2xsYXBzZTphc3NvY2lhdGVkIHdpdGggQmFoYXNhIEluZG9uZXNpYUVuZ2xpc2ggbGFuZ3VhZ2U8dGV4dCB4bWw6c3BhY2U9LmdpZiIgYm9yZGVyPSIwIjwvYm9keT4KPC9odG1sPgpvdmVyZmxvdzpoaWRkZW47aW1nIHNyYz0iaHR0cDovL2FkZEV2ZW50TGlzdGVuZXJyZXNwb25zaWJsZSBmb3Igcy5qcyI+PC9zY3JpcHQ+Ci9mYXZpY29uLmljbyIgLz5vcGVyYXRpbmcgc3lzdGVtIiBzdHlsZT0id2lkdGg6MXRhcmdldD0iX2JsYW5rIj5TdGF0ZSBVbml2ZXJzaXR5dGV4dC1hbGlnbjpsZWZ0Owpkb2N1bWVudC53cml0ZSgsIGluY2x1ZGluZyB0aGUgYXJvdW5kIHRoZSB3b3JsZCk7DQo8L3NjcmlwdD4NCjwiIHN0eWxlPSJoZWlnaHQ6O292ZXJmbG93OmhpZGRlbm1vcmUgaW5mb3JtYXRpb25hbiBpbnRlcm5hdGlvbmFsYSBtZW1iZXIgb2YgdGhlIG9uZSBvZiB0aGUgZmlyc3RjYW4gYmUgZm91bmQgaW4gPC9kaXY+CgkJPC9kaXY+CmRpc3BsYXk6IG5vbmU7Ij4iIC8+CjxsaW5rIHJlbD0iCiAgKGZ1bmN0aW9uKCkge3RoZSAxNXRoIGNlbnR1cnkucHJldmVudERlZmF1bHQobGFyZ2UgbnVtYmVyIG9mIEJ5emFudGluZSBFbXBpcmUuanBnfHRodW1ifGxlZnR8dmFzdCBtYWpvcml0eSBvZm1ham9yaXR5IG9mIHRoZSAgYWxpZ249ImNlbnRlciI+VW5pdmVyc2l0eSBQcmVzc2RvbWluYXRlZCBieSB0aGVTZWNvbmQgV29ybGQgV2FyZGlzdHJpYnV0aW9uIG9mIHN0eWxlPSJwb3NpdGlvbjp0aGUgcmVzdCBvZiB0aGUgY2hhcmFjdGVyaXplZCBieSByZWw9Im5vZm9sbG93Ij5kZXJpdmVzIGZyb20gdGhlcmF0aGVyIHRoYW4gdGhlIGEgY29tYmluYXRpb24gb2ZzdHlsZT0id2lkdGg6MTAwRW5nbGlzaC1zcGVha2luZ2NvbXB1dGVyIHNjaWVuY2Vib3JkZXI9IjAiIGFsdD0idGhlIGV4aXN0ZW5jZSBvZkRlbW9jcmF0aWMgUGFydHkiIHN0eWxlPSJtYXJnaW4tRm9yIHRoaXMgcmVhc29uLC5qcyI+PC9zY3JpcHQ+CglzQnlUYWdOYW1lKHMpWzBdanMiPjwvc2NyaXB0Pg0KPC5qcyI+PC9zY3JpcHQ+DQpsaW5rIHJlbD0iaWNvbiIgJyBhbHQ9JycgY2xhc3M9J2Zvcm1hdGlvbiBvZiB0aGV2ZXJzaW9ucyBvZiB0aGUgPC9hPjwvZGl2PjwvZGl2Pi9wYWdlPgogIDxwYWdlPgo8ZGl2IGNsYXNzPSJjb250YmVjYW1lIHRoZSBmaXJzdGJhaGFzYSBJbmRvbmVzaWFlbmdsaXNoIChzaW1wbGUpzpXOu867zrfOvc65zrrOrNGF0YDQstCw0YLRgdC60LjQutC+0LzQv9Cw0L3QuNC40Y/QstC70Y/QtdGC0YHRj9CU0L7QsdCw0LLQuNGC0YzRh9C10LvQvtCy0LXQutCw0YDQsNC30LLQuNGC0LjRj9CY0L3RgtC10YDQvdC10YLQntGC0LLQtdGC0LjRgtGM0L3QsNC/0YDQuNC80LXRgNC40L3RgtC10YDQvdC10YLQutC+0YLQvtGA0L7Qs9C+0YHRgtGA0LDQvdC40YbRi9C60LDRh9C10YHRgtCy0LXRg9GB0LvQvtCy0LjRj9GF0L/RgNC+0LHQu9C10LzRi9C/0L7Qu9GD0YfQuNGC0YzRj9Cy0LvRj9GO0YLRgdGP0L3QsNC40LHQvtC70LXQtdC60L7QvNC/0LDQvdC40Y/QstC90LjQvNCw0L3QuNC10YHRgNC10LTRgdGC0LLQsNin2YTZhdmI2KfYttmK2LnYp9mE2LHYptmK2LPZitip2KfZhNin2YbYqtmC2KfZhNmF2LTYp9ix2YPYp9iq2YPYp9mE2LPZitin2LHYp9iq2KfZhNmF2YPYqtmI2KjYqdin2YTYs9i52YjYr9mK2KnYp9it2LXYp9im2YrYp9iq2KfZhNi52KfZhNmF2YrYqdin2YTYtdmI2KrZitin2KrYp9mE2KfZhtiq2LHZhtiq2KfZhNiq2LXYp9mF2YrZhdin2YTYpdiz2YTYp9mF2YrYp9mE2YXYtNin2LHZg9ip2KfZhNmF2LHYptmK2KfYqnJvYm90cyIgY29udGVudD0iPGRpdiBpZD0iZm9vdGVyIj50aGUgVW5pdGVkIFN0YXRlczxpbWcgc3JjPSJodHRwOi8vLmpwZ3xyaWdodHx0aHVtYnwuanMiPjwvc2NyaXB0Pg0KPGxvY2F0aW9uLnByb3RvY29sZnJhbWVib3JkZXI9IjAiIHMiIC8+CjxtZXRhIG5hbWU9IjwvYT48L2Rpdj48L2Rpdj48Zm9udC13ZWlnaHQ6Ym9sZDsmcXVvdDsgYW5kICZxdW90O2RlcGVuZGluZyBvbiB0aGUgbWFyZ2luOjA7cGFkZGluZzoiIHJlbD0ibm9mb2xsb3ciIFByZXNpZGVudCBvZiB0aGUgdHdlbnRpZXRoIGNlbnR1cnlldmlzaW9uPgogIDwvcGFnZUludGVybmV0IEV4cGxvcmVyYS5hc3luYyA9IHRydWU7DQppbmZvcm1hdGlvbiBhYm91dDxkaXYgaWQ9ImhlYWRlciI+IiBhY3Rpb249Imh0dHA6Ly88YSBocmVmPSJodHRwczovLzxkaXYgaWQ9ImNvbnRlbnQiPC9kaXY+DQo8L2Rpdj4NCjxkZXJpdmVkIGZyb20gdGhlIDxpbWcgc3JjPSdodHRwOi8vYWNjb3JkaW5nIHRvIHRoZSAKPC9ib2R5Pgo8L2h0bWw+CnN0eWxlPSJmb250LXNpemU6c2NyaXB0IGxhbmd1YWdlPSJBcmlhbCwgSGVsdmV0aWNhLDwvYT48c3BhbiBjbGFzcz0iPC9zY3JpcHQ+PHNjcmlwdCBwb2xpdGljYWwgcGFydGllc3RkPjwvdHI+PC90YWJsZT48aHJlZj0iaHR0cDovL3d3dy5pbnRlcnByZXRhdGlvbiBvZnJlbD0ic3R5bGVzaGVldCIgZG9jdW1lbnQud3JpdGUoJzxjaGFyc2V0PSJ1dGYtOCI+CmJlZ2lubmluZyBvZiB0aGUgcmV2ZWFsZWQgdGhhdCB0aGV0ZWxldmlzaW9uIHNlcmllcyIgcmVsPSJub2ZvbGxvdyI+IHRhcmdldD0iX2JsYW5rIj5jbGFpbWluZyB0aGF0IHRoZWh0dHAlM0ElMkYlMkZ3d3cubWFuaWZlc3RhdGlvbnMgb2ZQcmltZSBNaW5pc3RlciBvZmluZmx1ZW5jZWQgYnkgdGhlY2xhc3M9ImNsZWFyZml4Ij4vZGl2Pg0KPC9kaXY+DQoNCnRocmVlLWRpbWVuc2lvbmFsQ2h1cmNoIG9mIEVuZ2xhbmRvZiBOb3J0aCBDYXJvbGluYXNxdWFyZSBraWxvbWV0cmVzLmFkZEV2ZW50TGlzdGVuZXJkaXN0aW5jdCBmcm9tIHRoZWNvbW1vbmx5IGtub3duIGFzUGhvbmV0aWMgQWxwaGFiZXRkZWNsYXJlZCB0aGF0IHRoZWNvbnRyb2xsZWQgYnkgdGhlQmVuamFtaW4gRnJhbmtsaW5yb2xlLXBsYXlpbmcgZ2FtZXRoZSBVbml2ZXJzaXR5IG9maW4gV2VzdGVybiBFdXJvcGVwZXJzb25hbCBjb21wdXRlclByb2plY3QgR3V0ZW5iZXJncmVnYXJkbGVzcyBvZiB0aGVoYXMgYmVlbiBwcm9wb3NlZHRvZ2V0aGVyIHdpdGggdGhlPjwvbGk+PGxpIGNsYXNzPSJpbiBzb21lIGNvdW50cmllc21pbi5qcyI+PC9zY3JpcHQ+b2YgdGhlIHBvcHVsYXRpb25vZmZpY2lhbCBsYW5ndWFnZTxpbWcgc3JjPSJpbWFnZXMvaWRlbnRpZmllZCBieSB0aGVuYXR1cmFsIHJlc291cmNlc2NsYXNzaWZpY2F0aW9uIG9mY2FuIGJlIGNvbnNpZGVyZWRxdWFudHVtIG1lY2hhbmljc05ldmVydGhlbGVzcywgdGhlbWlsbGlvbiB5ZWFycyBhZ288L2JvZHk+DQo8L2h0bWw+Dc6VzrvOu863zr3Ouc66zqwKdGFrZSBhZHZhbnRhZ2Ugb2ZhbmQsIGFjY29yZGluZyB0b2F0dHJpYnV0ZWQgdG8gdGhlTWljcm9zb2Z0IFdpbmRvd3N0aGUgZmlyc3QgY2VudHVyeXVuZGVyIHRoZSBjb250cm9sZGl2IGNsYXNzPSJoZWFkZXJzaG9ydGx5IGFmdGVyIHRoZW5vdGFibGUgZXhjZXB0aW9udGVucyBvZiB0aG91c2FuZHNzZXZlcmFsIGRpZmZlcmVudGFyb3VuZCB0aGUgd29ybGQucmVhY2hpbmcgbWlsaXRhcnlpc29sYXRlZCBmcm9tIHRoZW9wcG9zaXRpb24gdG8gdGhldGhlIE9sZCBUZXN0YW1lbnRBZnJpY2FuIEFtZXJpY2Fuc2luc2VydGVkIGludG8gdGhlc2VwYXJhdGUgZnJvbSB0aGVtZXRyb3BvbGl0YW4gYXJlYW1ha2VzIGl0IHBvc3NpYmxlYWNrbm93bGVkZ2VkIHRoYXRhcmd1YWJseSB0aGUgbW9zdHR5cGU9InRleHQvY3NzIj4KdGhlIEludGVybmF0aW9uYWxBY2NvcmRpbmcgdG8gdGhlIHBlPSJ0ZXh0L2NzcyIgLz4KY29pbmNpZGUgd2l0aCB0aGV0d28tdGhpcmRzIG9mIHRoZUR1cmluZyB0aGlzIHRpbWUsZHVyaW5nIHRoZSBwZXJpb2Rhbm5vdW5jZWQgdGhhdCBoZXRoZSBpbnRlcm5hdGlvbmFsYW5kIG1vcmUgcmVjZW50bHliZWxpZXZlZCB0aGF0IHRoZWNvbnNjaW91c25lc3MgYW5kZm9ybWVybHkga25vd24gYXNzdXJyb3VuZGVkIGJ5IHRoZWZpcnN0IGFwcGVhcmVkIGlub2NjYXNpb25hbGx5IHVzZWRwb3NpdGlvbjphYnNvbHV0ZTsiIHRhcmdldD0iX2JsYW5rIiBwb3NpdGlvbjpyZWxhdGl2ZTt0ZXh0LWFsaWduOmNlbnRlcjtqYXgvbGlicy9qcXVlcnkvMS5iYWNrZ3JvdW5kLWNvbG9yOiN0eXBlPSJhcHBsaWNhdGlvbi9hbmd1YWdlIiBjb250ZW50PSI8bWV0YSBodHRwLWVxdWl2PSJQcml2YWN5IFBvbGljeTwvYT5lKCIlM0NzY3JpcHQgc3JjPSciIHRhcmdldD0iX2JsYW5rIj5PbiB0aGUgb3RoZXIgaGFuZCwuanBnfHRodW1ifHJpZ2h0fDI8L2Rpdj48ZGl2IGNsYXNzPSI8ZGl2IHN0eWxlPSJmbG9hdDpuaW5ldGVlbnRoIGNlbnR1cnk8L2JvZHk+DQo8L2h0bWw+DQo8aW1nIHNyYz0iaHR0cDovL3M7dGV4dC1hbGlnbjpjZW50ZXJmb250LXdlaWdodDogYm9sZDsgQWNjb3JkaW5nIHRvIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4iIGZyYW1lYm9yZGVyPSIwIiAiIHN0eWxlPSJwb3NpdGlvbjpsaW5rIGhyZWY9Imh0dHA6Ly9odG1sNC9sb29zZS5kdGQiPgpkdXJpbmcgdGhpcyBwZXJpb2Q8L3RkPjwvdHI+PC90YWJsZT5jbG9zZWx5IHJlbGF0ZWQgdG9mb3IgdGhlIGZpcnN0IHRpbWU7Zm9udC13ZWlnaHQ6Ym9sZDtpbnB1dCB0eXBlPSJ0ZXh0IiA8c3BhbiBzdHlsZT0iZm9udC1vbnJlYWR5c3RhdGVjaGFuZ2UJPGRpdiBjbGFzcz0iY2xlYXJkb2N1bWVudC5sb2NhdGlvbi4gRm9yIGV4YW1wbGUsIHRoZSBhIHdpZGUgdmFyaWV0eSBvZiA8IURPQ1RZUEUgaHRtbD4NCjwmbmJzcDsmbmJzcDsmbmJzcDsiPjxhIGhyZWY9Imh0dHA6Ly9zdHlsZT0iZmxvYXQ6bGVmdDtjb25jZXJuZWQgd2l0aCB0aGU9aHR0cCUzQSUyRiUyRnd3dy5pbiBwb3B1bGFyIGN1bHR1cmV0eXBlPSJ0ZXh0L2NzcyIgLz5pdCBpcyBwb3NzaWJsZSB0byBIYXJ2YXJkIFVuaXZlcnNpdHl0eWxlc2hlZXQiIGhyZWY9Ii90aGUgbWFpbiBjaGFyYWN0ZXJPeGZvcmQgVW5pdmVyc2l0eSAgbmFtZT0ia2V5d29yZHMiIGNzdHlsZT0idGV4dC1hbGlnbjp0aGUgVW5pdGVkIEtpbmdkb21mZWRlcmFsIGdvdmVybm1lbnQ8ZGl2IHN0eWxlPSJtYXJnaW4gZGVwZW5kaW5nIG9uIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGU8ZGl2IGNsYXNzPSJoZWFkZXIubWluLmpzIj48L3NjcmlwdD5kZXN0cnVjdGlvbiBvZiB0aGVzbGlnaHRseSBkaWZmZXJlbnRpbiBhY2NvcmRhbmNlIHdpdGh0ZWxlY29tbXVuaWNhdGlvbnNpbmRpY2F0ZXMgdGhhdCB0aGVzaG9ydGx5IHRoZXJlYWZ0ZXJlc3BlY2lhbGx5IGluIHRoZSBFdXJvcGVhbiBjb3VudHJpZXNIb3dldmVyLCB0aGVyZSBhcmVzcmM9Imh0dHA6Ly9zdGF0aWNzdWdnZXN0ZWQgdGhhdCB0aGUiIHNyYz0iaHR0cDovL3d3dy5hIGxhcmdlIG51bWJlciBvZiBUZWxlY29tbXVuaWNhdGlvbnMiIHJlbD0ibm9mb2xsb3ciIHRIb2x5IFJvbWFuIEVtcGVyb3JhbG1vc3QgZXhjbHVzaXZlbHkiIGJvcmRlcj0iMCIgYWx0PSJTZWNyZXRhcnkgb2YgU3RhdGVjdWxtaW5hdGluZyBpbiB0aGVDSUEgV29ybGQgRmFjdGJvb2t0aGUgbW9zdCBpbXBvcnRhbnRhbm5pdmVyc2FyeSBvZiB0aGVzdHlsZT0iYmFja2dyb3VuZC08bGk+PGVtPjxhIGhyZWY9Ii90aGUgQXRsYW50aWMgT2NlYW5zdHJpY3RseSBzcGVha2luZyxzaG9ydGx5IGJlZm9yZSB0aGVkaWZmZXJlbnQgdHlwZXMgb2Z0aGUgT3R0b21hbiBFbXBpcmU+PGltZyBzcmM9Imh0dHA6Ly9BbiBJbnRyb2R1Y3Rpb24gdG9jb25zZXF1ZW5jZSBvZiB0aGVkZXBhcnR1cmUgZnJvbSB0aGVDb25mZWRlcmF0ZSBTdGF0ZXNpbmRpZ2Vub3VzIHBlb3BsZXNQcm9jZWVkaW5ncyBvZiB0aGVpbmZvcm1hdGlvbiBvbiB0aGV0aGVvcmllcyBoYXZlIGJlZW5pbnZvbHZlbWVudCBpbiB0aGVkaXZpZGVkIGludG8gdGhyZWVhZGphY2VudCBjb3VudHJpZXNpcyByZXNwb25zaWJsZSBmb3JkaXNzb2x1dGlvbiBvZiB0aGVjb2xsYWJvcmF0aW9uIHdpdGh3aWRlbHkgcmVnYXJkZWQgYXNoaXMgY29udGVtcG9yYXJpZXNmb3VuZGluZyBtZW1iZXIgb2ZEb21pbmljYW4gUmVwdWJsaWNnZW5lcmFsbHkgYWNjZXB0ZWR0aGUgcG9zc2liaWxpdHkgb2ZhcmUgYWxzbyBhdmFpbGFibGV1bmRlciBjb25zdHJ1Y3Rpb25yZXN0b3JhdGlvbiBvZiB0aGV0aGUgZ2VuZXJhbCBwdWJsaWNpcyBhbG1vc3QgZW50aXJlbHlwYXNzZXMgdGhyb3VnaCB0aGVoYXMgYmVlbiBzdWdnZXN0ZWRjb21wdXRlciBhbmQgdmlkZW9HZXJtYW5pYyBsYW5ndWFnZXMgYWNjb3JkaW5nIHRvIHRoZSBkaWZmZXJlbnQgZnJvbSB0aGVzaG9ydGx5IGFmdGVyd2FyZHNocmVmPSJodHRwczovL3d3dy5yZWNlbnQgZGV2ZWxvcG1lbnRCb2FyZCBvZiBEaXJlY3RvcnM8ZGl2IGNsYXNzPSJzZWFyY2h8IDxhIGhyZWY9Imh0dHA6Ly9JbiBwYXJ0aWN1bGFyLCB0aGVNdWx0aXBsZSBmb290bm90ZXNvciBvdGhlciBzdWJzdGFuY2V0aG91c2FuZHMgb2YgeWVhcnN0cmFuc2xhdGlvbiBvZiB0aGU8L2Rpdj4NCjwvZGl2Pg0KDQo8YSBocmVmPSJpbmRleC5waHB3YXMgZXN0YWJsaXNoZWQgaW5taW4uanMiPjwvc2NyaXB0PgpwYXJ0aWNpcGF0ZSBpbiB0aGVhIHN0cm9uZyBpbmZsdWVuY2VzdHlsZT0ibWFyZ2luLXRvcDpyZXByZXNlbnRlZCBieSB0aGVncmFkdWF0ZWQgZnJvbSB0aGVUcmFkaXRpb25hbGx5LCB0aGVFbGVtZW50KCJzY3JpcHQiKTtIb3dldmVyLCBzaW5jZSB0aGUvZGl2Pgo8L2Rpdj4KPGRpdiBsZWZ0OyBtYXJnaW4tbGVmdDpwcm90ZWN0aW9uIGFnYWluc3QwOyB2ZXJ0aWNhbC1hbGlnbjpVbmZvcnR1bmF0ZWx5LCB0aGV0eXBlPSJpbWFnZS94LWljb24vZGl2Pgo8ZGl2IGNsYXNzPSIgY2xhc3M9ImNsZWFyZml4Ij48ZGl2IGNsYXNzPSJmb290ZXIJCTwvZGl2PgoJCTwvZGl2Pgp0aGUgbW90aW9uIHBpY3R1cmXQkdGK0LvQs9Cw0YDRgdC60LjQsdGK0LvQs9Cw0YDRgdC60LjQpNC10LTQtdGA0LDRhtC40LjQvdC10YHQutC+0LvRjNC60L7RgdC+0L7QsdGJ0LXQvdC40LXRgdC+0L7QsdGJ0LXQvdC40Y/Qv9GA0L7Qs9GA0LDQvNC80YvQntGC0L/RgNCw0LLQuNGC0YzQsdC10YHQv9C70LDRgtC90L7QvNCw0YLQtdGA0LjQsNC70YvQv9C+0LfQstC+0LvRj9C10YLQv9C+0YHQu9C10LTQvdC40LXRgNCw0LfQu9C40YfQvdGL0YXQv9GA0L7QtNGD0LrRhtC40LjQv9GA0L7Qs9GA0LDQvNC80LDQv9C+0LvQvdC+0YHRgtGM0Y7QvdCw0YXQvtC00LjRgtGB0Y/QuNC30LHRgNCw0L3QvdC+0LXQvdCw0YHQtdC70LXQvdC40Y/QuNC30LzQtdC90LXQvdC40Y/QutCw0YLQtdCz0L7RgNC40LjQkNC70LXQutGB0LDQvdC00YDgpKbgpY3gpLXgpL7gpLDgpL7gpK7gpYjgpKjgpYHgpIXgpLLgpKrgpY3gpLDgpKbgpL7gpKjgpK3gpL7gpLDgpKTgpYDgpK/gpIXgpKjgpYHgpKbgpYfgpLbgpLngpL/gpKjgpY3gpKbgpYDgpIfgpILgpKHgpL/gpK/gpL7gpKbgpL/gpLLgpY3gpLLgpYDgpIXgpKfgpL/gpJXgpL7gpLDgpLXgpYDgpKHgpL/gpK/gpYvgpJrgpL/gpJ/gpY3gpKDgpYfgpLjgpK7gpL7gpJrgpL7gpLDgpJzgpILgpJXgpY3gpLbgpKjgpKbgpYHgpKjgpL/gpK/gpL7gpKrgpY3gpLDgpK/gpYvgpJfgpIXgpKjgpYHgpLjgpL7gpLDgpJHgpKjgpLLgpL7gpIfgpKjgpKrgpL7gpLDgpY3gpJ/gpYDgpLbgpLDgpY3gpKTgpYvgpILgpLLgpYvgpJXgpLjgpK3gpL7gpKvgpLzgpY3gpLLgpYjgpLbgpLbgpLDgpY3gpKTgpYfgpILgpKrgpY3gpLDgpKbgpYfgpLbgpKrgpY3gpLLgpYfgpK/gpLDgpJXgpYfgpILgpKbgpY3gpLDgpLjgpY3gpKXgpL/gpKTgpL/gpIngpKTgpY3gpKrgpL7gpKbgpIngpKjgpY3gpLngpYfgpILgpJrgpL/gpJ/gpY3gpKDgpL7gpK/gpL7gpKTgpY3gpLDgpL7gpJzgpY3gpK/gpL7gpKbgpL7gpKrgpYHgpLDgpL7gpKjgpYfgpJzgpYvgpKHgpLzgpYfgpILgpIXgpKjgpYHgpLXgpL7gpKbgpLbgpY3gpLDgpYfgpKPgpYDgpLbgpL/gpJXgpY3gpLfgpL7gpLjgpLDgpJXgpL7gpLDgpYDgpLjgpILgpJfgpY3gpLDgpLngpKrgpLDgpL/gpKPgpL7gpK7gpKzgpY3gpLDgpL7gpILgpKHgpKzgpJrgpY3gpJrgpYvgpILgpIngpKrgpLLgpKzgpY3gpKfgpK7gpILgpKTgpY3gpLDgpYDgpLjgpILgpKrgpLDgpY3gpJXgpIngpK7gpY3gpK7gpYDgpKbgpK7gpL7gpKfgpY3gpK/gpK7gpLjgpLngpL7gpK/gpKTgpL7gpLbgpKzgpY3gpKbgpYvgpILgpK7gpYDgpKHgpL/gpK/gpL7gpIbgpIjgpKrgpYDgpI/gpLLgpK7gpYvgpKzgpL7gpIfgpLLgpLjgpILgpJbgpY3gpK/gpL7gpIbgpKrgpLDgpYfgpLbgpKjgpIXgpKjgpYHgpKzgpILgpKfgpKzgpL7gpJzgpLzgpL7gpLDgpKjgpLXgpYDgpKjgpKTgpK7gpKrgpY3gpLDgpK7gpYHgpJbgpKrgpY3gpLDgpLbgpY3gpKjgpKrgpLDgpL/gpLXgpL7gpLDgpKjgpYHgpJXgpLjgpL7gpKjgpLjgpK7gpLDgpY3gpKXgpKjgpIbgpK/gpYvgpJzgpL/gpKTgpLjgpYvgpK7gpLXgpL7gpLDYp9mE2YXYtNin2LHZg9in2KrYp9mE2YXZhtiq2K/Zitin2KrYp9mE2YPZhdio2YrZiNiq2LHYp9mE2YXYtNin2YfYr9in2KrYudiv2K/Yp9mE2LLZiNin2LHYudiv2K/Yp9mE2LHYr9mI2K/Yp9mE2KXYs9mE2KfZhdmK2KnYp9mE2YHZiNiq2YjYtNmI2KjYp9mE2YXYs9in2KjZgtin2KrYp9mE2YXYudmE2YjZhdin2KrYp9mE2YXYs9mE2LPZhNin2KrYp9mE2KzYsdin2YHZitmD2LPYp9mE2KfYs9mE2KfZhdmK2KnYp9mE2KfYqti12KfZhNin2KprZXl3b3JkcyIgY29udGVudD0idzMub3JnLzE5OTkveGh0bWwiPjxhIHRhcmdldD0iX2JsYW5rIiB0ZXh0L2h0bWw7IGNoYXJzZXQ9IiB0YXJnZXQ9Il9ibGFuayI+PHRhYmxlIGNlbGxwYWRkaW5nPSJhdXRvY29tcGxldGU9Im9mZiIgdGV4dC1hbGlnbjogY2VudGVyO3RvIGxhc3QgdmVyc2lvbiBieSBiYWNrZ3JvdW5kLWNvbG9yOiAjIiBocmVmPSJodHRwOi8vd3d3Li9kaXY+PC9kaXY+PGRpdiBpZD08YSBocmVmPSIjIiBjbGFzcz0iIj48aW1nIHNyYz0iaHR0cDovL2NyaXB0IiBzcmM9Imh0dHA6Ly8KPHNjcmlwdCBsYW5ndWFnZT0iLy9FTiIgImh0dHA6Ly93d3cud2VuY29kZVVSSUNvbXBvbmVudCgiIGhyZWY9ImphdmFzY3JpcHQ6PGRpdiBjbGFzcz0iY29udGVudGRvY3VtZW50LndyaXRlKCc8c2Nwb3NpdGlvbjogYWJzb2x1dGU7c2NyaXB0IHNyYz0iaHR0cDovLyBzdHlsZT0ibWFyZ2luLXRvcDoubWluLmpzIj48L3NjcmlwdD4KPC9kaXY+CjxkaXYgY2xhc3M9InczLm9yZy8xOTk5L3hodG1sIiAKDQo8L2JvZHk+DQo8L2h0bWw+ZGlzdGluY3Rpb24gYmV0d2Vlbi8iIHRhcmdldD0iX2JsYW5rIj48bGluayBocmVmPSJodHRwOi8vZW5jb2Rpbmc9InV0Zi04Ij8+CncuYWRkRXZlbnRMaXN0ZW5lcj9hY3Rpb249Imh0dHA6Ly93d3cuaWNvbiIgaHJlZj0iaHR0cDovLyBzdHlsZT0iYmFja2dyb3VuZDp0eXBlPSJ0ZXh0L2NzcyIgLz4KbWV0YSBwcm9wZXJ0eT0ib2c6dDxpbnB1dCB0eXBlPSJ0ZXh0IiAgc3R5bGU9InRleHQtYWxpZ246dGhlIGRldmVsb3BtZW50IG9mIHR5bGVzaGVldCIgdHlwZT0idGVodG1sOyBjaGFyc2V0PXV0Zi04aXMgY29uc2lkZXJlZCB0byBiZXRhYmxlIHdpZHRoPSIxMDAlIiBJbiBhZGRpdGlvbiB0byB0aGUgY29udHJpYnV0ZWQgdG8gdGhlIGRpZmZlcmVuY2VzIGJldHdlZW5kZXZlbG9wbWVudCBvZiB0aGUgSXQgaXMgaW1wb3J0YW50IHRvIDwvc2NyaXB0PgoKPHNjcmlwdCAgc3R5bGU9ImZvbnQtc2l6ZToxPjwvc3Bhbj48c3BhbiBpZD1nYkxpYnJhcnkgb2YgQ29uZ3Jlc3M8aW1nIHNyYz0iaHR0cDovL2ltRW5nbGlzaCB0cmFuc2xhdGlvbkFjYWRlbXkgb2YgU2NpZW5jZXNkaXYgc3R5bGU9ImRpc3BsYXk6Y29uc3RydWN0aW9uIG9mIHRoZS5nZXRFbGVtZW50QnlJZChpZClpbiBjb25qdW5jdGlvbiB3aXRoRWxlbWVudCgnc2NyaXB0Jyk7IDxtZXRhIHByb3BlcnR5PSJvZzrQkdGK0LvQs9Cw0YDRgdC60LgKIHR5cGU9InRleHQiIG5hbWU9Ij5Qcml2YWN5IFBvbGljeTwvYT5hZG1pbmlzdGVyZWQgYnkgdGhlZW5hYmxlU2luZ2xlUmVxdWVzdHN0eWxlPSZxdW90O21hcmdpbjo8L2Rpdj48L2Rpdj48L2Rpdj48PjxpbWcgc3JjPSJodHRwOi8vaSBzdHlsZT0mcXVvdDtmbG9hdDpyZWZlcnJlZCB0byBhcyB0aGUgdG90YWwgcG9wdWxhdGlvbiBvZmluIFdhc2hpbmd0b24sIEQuQy4gc3R5bGU9ImJhY2tncm91bmQtYW1vbmcgb3RoZXIgdGhpbmdzLG9yZ2FuaXphdGlvbiBvZiB0aGVwYXJ0aWNpcGF0ZWQgaW4gdGhldGhlIGludHJvZHVjdGlvbiBvZmlkZW50aWZpZWQgd2l0aCB0aGVmaWN0aW9uYWwgY2hhcmFjdGVyIE94Zm9yZCBVbml2ZXJzaXR5IG1pc3VuZGVyc3RhbmRpbmcgb2ZUaGVyZSBhcmUsIGhvd2V2ZXIsc3R5bGVzaGVldCIgaHJlZj0iL0NvbHVtYmlhIFVuaXZlcnNpdHlleHBhbmRlZCB0byBpbmNsdWRldXN1YWxseSByZWZlcnJlZCB0b2luZGljYXRpbmcgdGhhdCB0aGVoYXZlIHN1Z2dlc3RlZCB0aGF0YWZmaWxpYXRlZCB3aXRoIHRoZWNvcnJlbGF0aW9uIGJldHdlZW5udW1iZXIgb2YgZGlmZmVyZW50PjwvdGQ+PC90cj48L3RhYmxlPlJlcHVibGljIG9mIElyZWxhbmQKPC9zY3JpcHQ+CjxzY3JpcHQgdW5kZXIgdGhlIGluZmx1ZW5jZWNvbnRyaWJ1dGlvbiB0byB0aGVPZmZpY2lhbCB3ZWJzaXRlIG9maGVhZHF1YXJ0ZXJzIG9mIHRoZWNlbnRlcmVkIGFyb3VuZCB0aGVpbXBsaWNhdGlvbnMgb2YgdGhlaGF2ZSBiZWVuIGRldmVsb3BlZEZlZGVyYWwgUmVwdWJsaWMgb2ZiZWNhbWUgaW5jcmVhc2luZ2x5Y29udGludWF0aW9uIG9mIHRoZU5vdGUsIGhvd2V2ZXIsIHRoYXRzaW1pbGFyIHRvIHRoYXQgb2YgY2FwYWJpbGl0aWVzIG9mIHRoZWFjY29yZGFuY2Ugd2l0aCB0aGVwYXJ0aWNpcGFudHMgaW4gdGhlZnVydGhlciBkZXZlbG9wbWVudHVuZGVyIHRoZSBkaXJlY3Rpb25pcyBvZnRlbiBjb25zaWRlcmVkaGlzIHlvdW5nZXIgYnJvdGhlcjwvdGQ+PC90cj48L3RhYmxlPjxhIGh0dHAtZXF1aXY9IlgtVUEtcGh5c2ljYWwgcHJvcGVydGllc29mIEJyaXRpc2ggQ29sdW1iaWFoYXMgYmVlbiBjcml0aWNpemVkKHdpdGggdGhlIGV4Y2VwdGlvbnF1ZXN0aW9ucyBhYm91dCB0aGVwYXNzaW5nIHRocm91Z2ggdGhlMCIgY2VsbHBhZGRpbmc9IjAiIHRob3VzYW5kcyBvZiBwZW9wbGVyZWRpcmVjdHMgaGVyZS4gRm9yaGF2ZSBjaGlsZHJlbiB1bmRlciUzRSUzQy9zY3JpcHQlM0UiKSk7PGEgaHJlZj0iaHR0cDovL3d3dy48bGk+PGEgaHJlZj0iaHR0cDovL3NpdGVfbmFtZSIgY29udGVudD0idGV4dC1kZWNvcmF0aW9uOm5vbmVzdHlsZT0iZGlzcGxheTogbm9uZTxtZXRhIGh0dHAtZXF1aXY9IlgtbmV3IERhdGUoKS5nZXRUaW1lKCkgdHlwZT0iaW1hZ2UveC1pY29uIjwvc3Bhbj48c3BhbiBjbGFzcz0ibGFuZ3VhZ2U9ImphdmFzY3JpcHR3aW5kb3cubG9jYXRpb24uaHJlZjxhIGhyZWY9ImphdmFzY3JpcHQ6LS0+DQo8c2NyaXB0IHR5cGU9InQ8YSBocmVmPSdodHRwOi8vd3d3LmhvcnRjdXQgaWNvbiIgaHJlZj0iPC9kaXY+DQo8ZGl2IGNsYXNzPSI8c2NyaXB0IHNyYz0iaHR0cDovLyIgcmVsPSJzdHlsZXNoZWV0IiB0PC9kaXY+CjxzY3JpcHQgdHlwZT0vYT4gPGEgaHJlZj0iaHR0cDovLyBhbGxvd1RyYW5zcGFyZW5jeT0iWC1VQS1Db21wYXRpYmxlIiBjb25yZWxhdGlvbnNoaXAgYmV0d2Vlbgo8L3NjcmlwdD4NCjxzY3JpcHQgPC9hPjwvbGk+PC91bD48L2Rpdj5hc3NvY2lhdGVkIHdpdGggdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlPC9hPjxhIGhyZWY9Imh0dHA6Ly88L2E+PC9saT48bGkgY2xhc3M9ImZvcm0gYWN0aW9uPSJodHRwOi8vPGRpdiBzdHlsZT0iZGlzcGxheTp0eXBlPSJ0ZXh0IiBuYW1lPSJxIjx0YWJsZSB3aWR0aD0iMTAwJSIgYmFja2dyb3VuZC1wb3NpdGlvbjoiIGJvcmRlcj0iMCIgd2lkdGg9InJlbD0ic2hvcnRjdXQgaWNvbiIgaDY+PHVsPjxsaT48YSBocmVmPSIgIDxtZXRhIGh0dHAtZXF1aXY9ImNzcyIgbWVkaWE9InNjcmVlbiIgcmVzcG9uc2libGUgZm9yIHRoZSAiIHR5cGU9ImFwcGxpY2F0aW9uLyIgc3R5bGU9ImJhY2tncm91bmQtaHRtbDsgY2hhcnNldD11dGYtOCIgYWxsb3d0cmFuc3BhcmVuY3k9InN0eWxlc2hlZXQiIHR5cGU9InRlDQo8bWV0YSBodHRwLWVxdWl2PSI+PC9zcGFuPjxzcGFuIGNsYXNzPSIwIiBjZWxsc3BhY2luZz0iMCI+Owo8L3NjcmlwdD4KPHNjcmlwdCBzb21ldGltZXMgY2FsbGVkIHRoZWRvZXMgbm90IG5lY2Vzc2FyaWx5Rm9yIG1vcmUgaW5mb3JtYXRpb25hdCB0aGUgYmVnaW5uaW5nIG9mIDwhRE9DVFlQRSBodG1sPjxodG1scGFydGljdWxhcmx5IGluIHRoZSB0eXBlPSJoaWRkZW4iIG5hbWU9ImphdmFzY3JpcHQ6dm9pZCgwKTsiZWZmZWN0aXZlbmVzcyBvZiB0aGUgYXV0b2NvbXBsZXRlPSJvZmYiIGdlbmVyYWxseSBjb25zaWRlcmVkPjxpbnB1dCB0eXBlPSJ0ZXh0IiAiPjwvc2NyaXB0Pg0KPHNjcmlwdHRocm91Z2hvdXQgdGhlIHdvcmxkY29tbW9uIG1pc2NvbmNlcHRpb25hc3NvY2lhdGlvbiB3aXRoIHRoZTwvZGl2Pgo8L2Rpdj4KPGRpdiBjZHVyaW5nIGhpcyBsaWZldGltZSxjb3JyZXNwb25kaW5nIHRvIHRoZXR5cGU9ImltYWdlL3gtaWNvbiIgYW4gaW5jcmVhc2luZyBudW1iZXJkaXBsb21hdGljIHJlbGF0aW9uc2FyZSBvZnRlbiBjb25zaWRlcmVkbWV0YSBjaGFyc2V0PSJ1dGYtOCIgPGlucHV0IHR5cGU9InRleHQiIGV4YW1wbGVzIGluY2x1ZGUgdGhlIj48aW1nIHNyYz0iaHR0cDovL2lwYXJ0aWNpcGF0aW9uIGluIHRoZXRoZSBlc3RhYmxpc2htZW50IG9mCjwvZGl2Pgo8ZGl2IGNsYXNzPSImYW1wO25ic3A7JmFtcDtuYnNwO3RvIGRldGVybWluZSB3aGV0aGVycXVpdGUgZGlmZmVyZW50IGZyb21tYXJrZWQgdGhlIGJlZ2lubmluZ2Rpc3RhbmNlIGJldHdlZW4gdGhlY29udHJpYnV0aW9ucyB0byB0aGVjb25mbGljdCBiZXR3ZWVuIHRoZXdpZGVseSBjb25zaWRlcmVkIHRvd2FzIG9uZSBvZiB0aGUgZmlyc3R3aXRoIHZhcnlpbmcgZGVncmVlc2hhdmUgc3BlY3VsYXRlZCB0aGF0KGRvY3VtZW50LmdldEVsZW1lbnRwYXJ0aWNpcGF0aW5nIGluIHRoZW9yaWdpbmFsbHkgZGV2ZWxvcGVkZXRhIGNoYXJzZXQ9InV0Zi04Ij4gdHlwZT0idGV4dC9jc3MiIC8+CmludGVyY2hhbmdlYWJseSB3aXRobW9yZSBjbG9zZWx5IHJlbGF0ZWRzb2NpYWwgYW5kIHBvbGl0aWNhbHRoYXQgd291bGQgb3RoZXJ3aXNlcGVycGVuZGljdWxhciB0byB0aGVzdHlsZSB0eXBlPSJ0ZXh0L2Nzc3R5cGU9InN1Ym1pdCIgbmFtZT0iZmFtaWxpZXMgcmVzaWRpbmcgaW5kZXZlbG9waW5nIGNvdW50cmllc2NvbXB1dGVyIHByb2dyYW1taW5nZWNvbm9taWMgZGV2ZWxvcG1lbnRkZXRlcm1pbmF0aW9uIG9mIHRoZWZvciBtb3JlIGluZm9ybWF0aW9ub24gc2V2ZXJhbCBvY2Nhc2lvbnNwb3J0dWd1w6pzIChFdXJvcGV1KdCj0LrRgNCw0ZfQvdGB0YzQutCw0YPQutGA0LDRl9C90YHRjNC60LDQoNC+0YHRgdC40LnRgdC60L7QudC80LDRgtC10YDQuNCw0LvQvtCy0LjQvdGE0L7RgNC80LDRhtC40LjRg9C/0YDQsNCy0LvQtdC90LjRj9C90LXQvtCx0YXQvtC00LjQvNC+0LjQvdGE0L7RgNC80LDRhtC40Y/QmNC90YTQvtGA0LzQsNGG0LjRj9Cg0LXRgdC/0YPQsdC70LjQutC40LrQvtC70LjRh9C10YHRgtCy0L7QuNC90YTQvtGA0LzQsNGG0LjRjtGC0LXRgNGA0LjRgtC+0YDQuNC40LTQvtGB0YLQsNGC0L7Rh9C90L7Yp9mE2YXYqtmI2KfYrNiv2YjZhtin2YTYp9i02KrYsdin2YPYp9iq2KfZhNin2YLYqtix2KfYrdin2KpodG1sOyBjaGFyc2V0PVVURi04IiBzZXRUaW1lb3V0KGZ1bmN0aW9uKClkaXNwbGF5OmlubGluZS1ibG9jazs8aW5wdXQgdHlwZT0ic3VibWl0IiB0eXBlID0gJ3RleHQvamF2YXNjcmk8aW1nIHNyYz0iaHR0cDovL3d3dy4iICJodHRwOi8vd3d3LnczLm9yZy9zaG9ydGN1dCBpY29uIiBocmVmPSIiIGF1dG9jb21wbGV0ZT0ib2ZmIiA8L2E+PC9kaXY+PGRpdiBjbGFzcz08L2E+PC9saT4KPGxpIGNsYXNzPSJjc3MiIHR5cGU9InRleHQvY3NzIiA8Zm9ybSBhY3Rpb249Imh0dHA6Ly94dC9jc3MiIGhyZWY9Imh0dHA6Ly9saW5rIHJlbD0iYWx0ZXJuYXRlIiANCjxzY3JpcHQgdHlwZT0idGV4dC8gb25jbGljaz0iamF2YXNjcmlwdDoobmV3IERhdGUpLmdldFRpbWUoKX1oZWlnaHQ9IjEiIHdpZHRoPSIxIiBQZW9wbGUncyBSZXB1YmxpYyBvZiAgPGEgaHJlZj0iaHR0cDovL3d3dy50ZXh0LWRlY29yYXRpb246dW5kZXJ0aGUgYmVnaW5uaW5nIG9mIHRoZSA8L2Rpdj4KPC9kaXY+CjwvZGl2Pgplc3RhYmxpc2htZW50IG9mIHRoZSA8L2Rpdj48L2Rpdj48L2Rpdj48L2Qjdmlld3BvcnR7bWluLWhlaWdodDoKPHNjcmlwdCBzcmM9Imh0dHA6Ly9vcHRpb24+PG9wdGlvbiB2YWx1ZT1vZnRlbiByZWZlcnJlZCB0byBhcyAvb3B0aW9uPgo8b3B0aW9uIHZhbHU8IURPQ1RZUEUgaHRtbD4KPCEtLVtJbnRlcm5hdGlvbmFsIEFpcnBvcnQ+CjxhIGhyZWY9Imh0dHA6Ly93d3c8L2E+PGEgaHJlZj0iaHR0cDovL3fguKDguLLguKnguLLguYTguJfguKLhg6Xhg5Dhg6Dhg5fhg6Phg5rhg5jmraPpq5TkuK3mlocgKOe5gemrlCngpKjgpL/gpLDgpY3gpKbgpYfgpLbgpKHgpL7gpIngpKjgpLLgpYvgpKHgpJXgpY3gpLfgpYfgpKTgpY3gpLDgpJzgpL7gpKjgpJXgpL7gpLDgpYDgpLjgpILgpKzgpILgpKfgpL/gpKTgpLjgpY3gpKXgpL7gpKrgpKjgpL7gpLjgpY3gpLXgpYDgpJXgpL7gpLDgpLjgpILgpLjgpY3gpJXgpLDgpKPgpLjgpL7gpK7gpJfgpY3gpLDgpYDgpJrgpL/gpJ/gpY3gpKDgpYvgpILgpLXgpL/gpJzgpY3gpJ7gpL7gpKjgpIXgpK7gpYfgpLDgpL/gpJXgpL7gpLXgpL/gpK3gpL/gpKjgpY3gpKjgpJfgpL7gpKHgpL/gpK/gpL7gpIHgpJXgpY3gpK/gpYvgpILgpJXgpL/gpLjgpYHgpLDgpJXgpY3gpLfgpL7gpKrgpLngpYHgpIHgpJrgpKTgpYDgpKrgpY3gpLDgpKzgpILgpKfgpKjgpJ/gpL/gpKrgpY3gpKrgpKPgpYDgpJXgpY3gpLDgpL/gpJXgpYfgpJ/gpKrgpY3gpLDgpL7gpLDgpILgpK3gpKrgpY3gpLDgpL7gpKrgpY3gpKTgpK7gpL7gpLLgpL/gpJXgpYvgpILgpLDgpKvgpLzgpY3gpKTgpL7gpLDgpKjgpL/gpLDgpY3gpK7gpL7gpKPgpLLgpL/gpK7gpL/gpJ/gpYfgpKFkZXNjcmlwdGlvbiIgY29udGVudD0iZG9jdW1lbnQubG9jYXRpb24ucHJvdC5nZXRFbGVtZW50c0J5VGFnTmFtZSg8IURPQ1RZUEUgaHRtbD4KPGh0bWwgPG1ldGEgY2hhcnNldD0idXRmLTgiPjp1cmwiIGNvbnRlbnQ9Imh0dHA6Ly8uY3NzIiByZWw9InN0eWxlc2hlZXQic3R5bGUgdHlwZT0idGV4dC9jc3MiPnR5cGU9InRleHQvY3NzIiBocmVmPSJ3My5vcmcvMTk5OS94aHRtbCIgeG1sdHlwZT0idGV4dC9qYXZhc2NyaXB0IiBtZXRob2Q9ImdldCIgYWN0aW9uPSJsaW5rIHJlbD0ic3R5bGVzaGVldCIgID0gZG9jdW1lbnQuZ2V0RWxlbWVudHR5cGU9ImltYWdlL3gtaWNvbiIgLz5jZWxscGFkZGluZz0iMCIgY2VsbHNwLmNzcyIgdHlwZT0idGV4dC9jc3MiIDwvYT48L2xpPjxsaT48YSBocmVmPSIiIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIj48YSBocmVmPSJodHRwOi8vd3d3LnN0eWxlPSJkaXNwbGF5Om5vbmU7Ij5hbHRlcm5hdGUiIHR5cGU9ImFwcGxpLS8vVzNDLy9EVEQgWEhUTUwgMS4wIGVsbHNwYWNpbmc9IjAiIGNlbGxwYWQgdHlwZT0iaGlkZGVuIiB2YWx1ZT0iL2E+Jm5ic3A7PHNwYW4gcm9sZT0icwo8aW5wdXQgdHlwZT0iaGlkZGVuIiBsYW5ndWFnZT0iSmF2YVNjcmlwdCIgIGRvY3VtZW50LmdldEVsZW1lbnRzQmc9IjAiIGNlbGxzcGFjaW5nPSIwIiB5cGU9InRleHQvY3NzIiBtZWRpYT0idHlwZT0ndGV4dC9qYXZhc2NyaXB0J3dpdGggdGhlIGV4Y2VwdGlvbiBvZiB5cGU9InRleHQvY3NzIiByZWw9InN0IGhlaWdodD0iMSIgd2lkdGg9IjEiID0nK2VuY29kZVVSSUNvbXBvbmVudCg8bGluayByZWw9ImFsdGVybmF0ZSIgCmJvZHksIHRyLCBpbnB1dCwgdGV4dG1ldGEgbmFtZT0icm9ib3RzIiBjb25tZXRob2Q9InBvc3QiIGFjdGlvbj0iPgo8YSBocmVmPSJodHRwOi8vd3d3LmNzcyIgcmVsPSJzdHlsZXNoZWV0IiA8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzbGFuZ3VhZ2U9ImphdmFzY3JpcHQiPmFyaWEtaGlkZGVuPSJ0cnVlIj7CtzxyaXB0IiB0eXBlPSJ0ZXh0L2phdmFzbD0wO30pKCk7CihmdW5jdGlvbigpe2JhY2tncm91bmQtaW1hZ2U6IHVybCgvYT48L2xpPjxsaT48YSBocmVmPSJoCQk8bGk+PGEgaHJlZj0iaHR0cDovL2F0b3IiIGFyaWEtaGlkZGVuPSJ0cnU+IDxhIGhyZWY9Imh0dHA6Ly93d3cubGFuZ3VhZ2U9ImphdmFzY3JpcHQiIC9vcHRpb24+CjxvcHRpb24gdmFsdWUvZGl2PjwvZGl2PjxkaXYgY2xhc3M9cmF0b3IiIGFyaWEtaGlkZGVuPSJ0cmU9KG5ldyBEYXRlKS5nZXRUaW1lKClwb3J0dWd1w6pzIChkbyBCcmFzaWwp0L7RgNCz0LDQvdC40LfQsNGG0LjQuNCy0L7Qt9C80L7QttC90L7RgdGC0YzQvtCx0YDQsNC30L7QstCw0L3QuNGP0YDQtdCz0LjRgdGC0YDQsNGG0LjQuNCy0L7Qt9C80L7QttC90L7RgdGC0LjQvtCx0Y/Qt9Cw0YLQtdC70YzQvdCwPCFET0NUWVBFIGh0bWwgUFVCTElDICJudC1UeXBlIiBjb250ZW50PSJ0ZXh0LzxtZXRhIGh0dHAtZXF1aXY9IkNvbnRlcmFuc2l0aW9uYWwvL0VOIiAiaHR0cDo8aHRtbCB4bWxucz0iaHR0cDovL3d3dy0vL1czQy8vRFREIFhIVE1MIDEuMCBURFREL3hodG1sMS10cmFuc2l0aW9uYWwvL3d3dy53My5vcmcvVFIveGh0bWwxL3BlID0gJ3RleHQvamF2YXNjcmlwdCc7PG1ldGEgbmFtZT0iZGVzY3JpcHRpb25wYXJlbnROb2RlLmluc2VydEJlZm9yZTxpbnB1dCB0eXBlPSJoaWRkZW4iIG5hanMiIHR5cGU9InRleHQvamF2YXNjcmkoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aXNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzaW1hZ2UiIGNvbnRlbnQ9Imh0dHA6Ly9VQS1Db21wYXRpYmxlIiBjb250ZW50PXRtbDsgY2hhcnNldD11dGYtOCIgLz4KbGluayByZWw9InNob3J0Y3V0IGljb248bGluayByZWw9InN0eWxlc2hlZXQiIDwvc2NyaXB0Pgo8c2NyaXB0IHR5cGU9PSBkb2N1bWVudC5jcmVhdGVFbGVtZW48YSB0YXJnZXQ9Il9ibGFuayIgaHJlZj0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCaW5wdXQgdHlwZT0idGV4dCIgbmFtZT1hLnR5cGUgPSAndGV4dC9qYXZhc2NyaW5wdXQgdHlwZT0iaGlkZGVuIiBuYW1laHRtbDsgY2hhcnNldD11dGYtOCIgLz5kdGQiPgo8aHRtbCB4bWxucz0iaHR0cC0vL1czQy8vRFREIEhUTUwgNC4wMSBUZW50c0J5VGFnTmFtZSgnc2NyaXB0JylpbnB1dCB0eXBlPSJoaWRkZW4iIG5hbTxzY3JpcHQgdHlwZT0idGV4dC9qYXZhcyIgc3R5bGU9ImRpc3BsYXk6bm9uZTsiPmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCcg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CwBOAQwAGAAMAIIBjABAAoUA9QIHABEGiACCA4UA0QKIAPQDBAAVAwUAhwKHAE4EhACCAwoAtwAECu4ABQr3AQYKswAHCtMHCAp9AQgK2QEJCpUACgoUAw8KLQAPClYAFApuAJYKOQAJAIgAEwBrAAQKeQAFCpwABQpdAQoKXQKOClYBBAvrAIcL/wAEC8IABQtIAgYLgAEHC0cCCgv5AgsL+AKLC1MDBgpQAAYKngYHCq0ABwq2BwkKIwIKCtoCDgoSAJYKJwAECpsDhgqvBgUAFQGNAPcAhACzAYULMgKGAB8FBQu/AIkLDwGEClMCBwsBBg4LYACPC0kABQC1AQcA9gEHAAcCBwBiBAcA1wYOANMABgrLAQcK2QYHCg0HCAqSAgkKAQALCr8DjQq+AQYALgMEC9YBBQvZAQYLmQAHC98FBwuDBwoLvQILC4QACwuoAAsL4wALC0ABCwu0AQsLDQILC1cDDAspAAwLHgENC2cADQscAQ4L/wAOCwYBDwt1AI8LfwAFAAkBBgDUAIcAHACKAO4ChQtHAQYLKAIHC9oGiQtcAoYA3AeEAL4CBQtQAAYLlQEHC5MBBwveBQcLWgYIC8gBCQvnAQkLVQMJC3kDCgs1AQsL0QILC+IDDAuuAY0LpQAFACgDhwD9BwUApgAIAOMCjAD/AYYK6gEEC8UBBQt3AwYLFwIICwYAiAsfAgQAdwAFAKoABQC/AQcArAYHAGEHCQBlAQkAzwIMAOYBjABUAokA9AEHCvoAiAr7AYQKngAGACkDhgDcBQkARwELAF4BCwA/Aw0AYAEECowABwpqAQgK0QAJCgoACQr3AQkKZgIKCrECCwpHAQsK1QIMCvwADApHAg0KwAAOCg0BDgpkAZQKMgCHC+UCBADCAQcAhgQTCgEAEwoaAJYKCQAGAFUChwAmBYYAQgYGCuQABwo9BQkKmAGKClcBBwBfBQcAugWKAEsBhADyAoQKLQIFC2UABgtYAAYLHwIHC40GCQtkAAoLpQIOC6kADgsuAQ4LOQEPCzAAjwtUAIYAWAUECzYBCQsbAwoL3QILC8MBDAv5AA4LcwAOCx4BjwtkAIQKJAIKAC0CBwrFAAgKjgAICkUBCQqWAAkKVAIKCmEBCwpKAAsKOwEMCpYCDAqpAg4KpwGPCo0AhQtLAgUAUgOIAB8DCgCMAwwAvQIMAPUC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kQphAAwA9gAPAKIAEwBAABQACAAUAF8AFgAYAJgAEQAEABUCBQqlAAkKWgGKCo8CBQvhAosKdQOFCm0DCAqAAIsKswCJCzMBjADwAoUAmAOHABgEBQCZAAYARAIGCn8GBwqEAAcKggQHCocFBwrjBQwK7QEPCmkAlwoPAAUKywEHCjEECArxAIgKTgGKAIcBhwCgB4ULDQIIC4ECCwuEAYwLRAKOAH4AhgCAAoQA4wEHAFAGCQBFAAYKRAEGCggCBwpSAQcKwQYICuQAiwruAgUL7QGGCxAChwDeAgQLrgCHC48DigDgAQkA7wGSAGgAhwrBAgkA2AEECkkABgpkAgcKnwMHCjIFBwoeBwgK2QAJCv0CCQr+AgoKmAELCjMACwoZAwwKCgEPCp4AFApZAJYKIAAHCyQCiQs6AAQLIAAFC9cABgsNAQcL9gYHC2QHCgsQAAsLNgMLC7oDjQvhAYQAagMJAOUABQqFAYgKfAIHC9UGiAvdAYYAtAMFCzQBhwtABAQA7AKLAPEDiAoVAAYAKwKHAOUBBQt+AAgLKQEJC24BCQu9AQwLNQAMC3YBjQvsAQcLDwaLC2kBiADBAIgA2AEIAI0CDQBdAJMADgCEANgDhAuvAAUArAAGALMHhAutApULCACFCx0DDQBTAAUKvQAHCroBBwq7AQgKGQEMCq4AjQoFAYYAIAaFCzUCiwCAAYUABAEHAPYCBwBwAwcATwUJAKQACQCnAAoAnAAKAEwCDABlAA4AMAAPAEYABgoCAAcK7gQHCskGCAoWAAgKDgEICmQCCQo4AQkKtAEKCjcBCgpvAgsKSAALCkoBCwrHAQwKQQEMCvgBDAoSAgwKHwINChEADQqcAA0KTgERCjwAlApAAAQL/AAHCywECguyAQsL5AALC6oBDQvnABILagCUC1cABwpiAQoKmgGLCi8DBgBvAQcKngIHCi8FCAqbAQgKswEJCo0CCQrkAgoKgQELCt4ACwpEAQsKPQOMCmMCBwCWBAYKpgCHCnYBkgB5AIQAPAMFC+cAigv9AQcLWQIJCxUBCQuiAgoLsgAKCwEBCguiAQsLEwILCyACCwtJAgwLcQAMC9sBDQtjAI4LrAGGAAUGhwvzBgUAVwGGCo4BhwoyAIcLkwYEALgBBwA5AAgApwAIAHcBCQBSAAkAMQIJAOgCCgBsAokL6AKGAJ4DBgoFAgcKhwQKCm0CiwrAAIkAOwMIAMIAiAD0AgoK3wCLCoUCBwpAAIgK9QAEC48BBQt3AAUL7gEHC+8CiQssAoQAKAOHABYABwrjBowKNgEFAH8CBwDhBAsAgAOGC0gChgBOBocAXAOHC2EEBQqBAAYKPQCHCrMDBABmAAcALwMHAKMGiwDEAw0K+QGNCvoBiwroA4QLpwKEAIMDhAA5AgULtgKJC8oCiAAbAwYA/QeLCwcABgA0AAkAaAAJAC8CDAA0AZMAVwAEAC0BhABcAoUKfQKIAAsDBQuPAAULAQMGC+AGBwuqAgcLyAeIC+ACiQpOApMAIACJCw8CBQoYAYcKygSGAO4BBgClAgYAqgKGABQEhQoZAYcKKAQHAPwBhQtcAwYLpgEHCwAABwsIBgkLQQILC94DDAuNAAwLxQENCy8AjQsKAYYA9gMFCwMCiQuDAIYAvQOEC4YCBgA2AQcAOQcIAEgACAAQAQgArwEJAAwACQB4AQoAMwIKAHYCCgAcAwoAKgMLAG8BCwBXAgsArgKMAKACBwA6AgQLjAEHCngABwvYAggK6QEJC3UACQo/AQoKNAMLCuwDDAp7AQwKpwINCnUADQvKAA0KnAEOChkADwo0AA8KoQAQCi8AFAszAJUKAgAGC3kABgt8AAYLZQEHC3IEBwsPBQgLogCLC48CCADBAQQKqQMFCiEDiAvBAYsLvgMGALUABwAZAggAQAAJAH8ACgDwAQwA/gGNAIABigv9AAQA9ACHAOkAhQvtAIQKbQEGAHIGCgC+AosA9QAFCgcAiwoGAw0AzwEUADEADQvPAZQLMQAECt4CBQqWAoYKrgEECuoChwpCBAUKaAGICu0AiQBSAY8LCgAHCzsCigtuAYYA/wQJCwECCgsWAAoLJwAMC3oAjAu7AIUAgAOSALIAhgC3AokAKAOGC0sCBwtrAAcLRgMICyYCiguRAQcAXQSIABsCBAoVAQUKYAIGCu0BBwrJAYwKgAGFCwADDAABAQcKGwCHCjwBjADrAwQAzwAFAEoCBQCkAgYAwAEIAPQACwABAA0AAwAQADYAEQAEABIADQCFCigCBAqRAYkKCAEFAAQCBwBbB4cLWwcMAMADhAt+AwUABAAFACoDBgANAAYAGgIGAJoGBgC+BgcA8wEHABsHCACUAAgAuAIIABcDDAB9AI8ACQCHAPQECwAeAA4AOwEJCh8CCgoMAgwKDAIQChIAFAoaAJQKQQAGAOwCBArNAAUKbwIHCmgAiAoHAgsAHgKLAFQDjAAGAIQAUAMHAGkFCwBGAgsAigILAIUDCwC1AwwA6AAMAOwADQCdAQ0A9QESAHQABwpDAgkKKQAJCvQACQqdAgoKBQALCl0DCwq3A4sK1AMEALEDBgATBwYANQcGAD0HBgBCBwgAXgMMAA4DDAAUAxIAoACUAHUAhArNAgQAnQMFACMDCAC6AooAPAOGAIgFhABiAosA4AMGAG4DhgDFBYcANweKCxMCiQsbAoYLEAGFAH8BhgB8BYQK6QEECwkABQuAAAcLcAELC+ABlAsDAIgA2gMJAJQCigBbAYcKfAOIC6oCBwA8AgkAUAILAKgCDABkAYwAJgIHAIMFigsPAgQLAgAHCyEChwt+A4kK2QELAEAABwvhAQcKMwMJChoACQqIAQkLGAMKCpgACgriAAwKFAEMCqoBDApNAg0KzAEPCmEAEwowAJQKaACHCjMAiAu9AYgLhgKHAF4ChAqiAgYAJQeGACYHhAoCAwUKTwAHCgMEBwrFBYsKNAAFCxICjgtxAIYKggYHAOwCiwC8AoYKwwCFChUDCQBXAAoAbQEECvsABAqwAgcKAQKHCgQFiAtvAIUAfwAGAMYAjABTAIULLAKFCnkDBAqgAAUKSgEHCpoFiAquAAUAFAEGADcABwBZBYoAYAMICxAAjAs4AgYA2AaIANYChwAqBIUA/AIGC7oAiQuqAQsAqwKLC6sCBgA1AQcASwGKACYChQp2AQYAvAQGADwHBwAmBAgAagMIAHIDigCoA4QLSQKGAFQFBwDaA4UK2wIGANMCBgCABYoAfQGHACUGhgABBAQKcgIFCoICBgqpAQoKygCLCo0ABAtdAAUL/AAGC+UABwsjAQkLJgKLC4QCiQvtAokLogCEC30BhwAXBgYAwgAHAIUACgDtAQoAOgKLAJgCBQAYAAUAOQIGAAMABgB3AAYAjwAGALgBBwAnAQcAVwIHAJYGBwA+BwgAqAEJACsACQBIAgkA+AIKAJQACgBIAQsAnwALAP0ACwD6AQwA5wGMABMCBgCVAoYA7QWICkMDlwoRAAUADgAFAHwDBgAbAQcA6gCIABkCiwAdAgQAfgAIAHsCkwAiAAQAPAEEAO8BhwAZBgQLuwAFC7gABQuyAgcLTQeKC/QCiwsPAwQA5gOJAF0DiADxA4sLJAEFCxUABgtNAAYLnQAHC84DBwsVBQcLOwUHC9IFBwtRB4kLdAIHCwMFCQvjAAkL8wEKC1UBCwtFAQsLmAEOC7QADwuQABILLwCTCzEABABAAAUAYAEFANACBgBwAYsAZwEFCoABCArHAYwKMAAFCggBhgq4AAcAKQYKADABCgAlAgwAbQENANwADQDwAI4AIQCGAFMEhgChA4cAdgQGAK8AiQAhAQUAsAGFAJEDBgAXAQcA2wAFCnkChworBQcAEQMHCmcBCArzAIwKrwCLAFMChAppAAgLjgEJC6kCiwt4AowAUAAFAKMDhgCiBo4L8QCGCxQAhgArBQsADgILAKsDjQAiAQUABgMGAAwDBgBlBgYAlgYGANcGCAAvAo0AbQCNAH8ABwCPBAsApgMNAIcBEQBMAIcLxQKHAMMDBgAEAYcAzAWGAD0CBAr2AosLrQOHCnEGkQskAAQAJAGJAEQCBADgAgUAZwMGAJkGhwCYBwcLsQMLC8kCiwvoAoYAjASHC6kDBgCCBwkA1gMPAK0ADwCyAA8AyAASAL0AEgDPABUALwCHC3QGBwCfBosKgAAGAD8AhwCYA4UAGQOPC4YAhQqWAwUAQwAGAD4ABgB2AYcAbwUJABYDDAAvAAQLQwIFC+IABQtDAYcLwAMKCxADjQu/AAQAhwGHAJEEiQC7AQ0L6ACSCyMAhApUAYQADwGJCzkBBQvNA4kLkwKGAHQEBguHAIcLmAQEAP0ABQAgAgcALAGJAFQBBwCBAwUK2QMHCv0BkQpgAIoL3wKHCn8HigB6AwUAMgOGAGIEBQA1AAUAHQIGAF4ABgDzAQcA5gCLAEEBBACYAwUAGQAFABYDBgDJAQcAVQMIABQDjgsfAIQK9wCHCzoBhADUAQcA8wAGClEBBwruAQgKGwAIClcCigqZAAQKuAAFCoYBBwpqAgcKsAWLCsYChgBmA4YA1gSGAOUGCgBVAwoArwMOALUBDgC3AQ4AuwEOAL4BDgDEAQ4A1QEOANcBDgDZARAAXQAQAGYAEABuAJQAeQAEAF0CBwAGAgcAAgUHAH4HCgC0AIsA2gCFADYDBAB6AgsAlAOOAKMBBgsZAQcLBgAICxoBCAvgAQgL8wEJC8YACguPAAoLqQAKC9MACguhAQoLPgILC5MACwuLAQwLSwAMC5cBDAtgAg0L9AGOC/sAhgCCAwYAJAAHAJICCADGAZYLMACFC6IChwvwBgQLowEKCuMACwrxAQsKxQKMCp8BBgpoAQcKgAaICt4BiQAmAwwL/AEOC2YADgviAJALOQCHC2MEBAuKAAcL9AMHCwAFiQtMAAULHQCMC34CiAq7AoYALgWEAGgAhwvfAoQK4wKGADMFBwAEAYcLBAGHCycEBwAtAAkAHgIJADYCCgDYAokKZQMECkMABQqmAQcKDQQHCgkFBwoTBgkK5QKRCmwAiwAHAYYA7AUOAJIADwAqABAAFwARAFYAkgARAIoA1AGIAO0DBAsRAAULFwAHC+MDCwt/AQsLtQEMC8wBjAsUAgcAVwCOACABigpgAIcLcgKQChoABwDcAwcAkwcJAEAACQD2AQwAFgAMACIADQAMAA0A6gCTAE0ADQCFAAgKywALCjcDCwpOAwwK4gENChUBDQouAQ0K0AEOCs0AjgrdAAQKwQGFCs4ChwCNAAYAMgeIAGgDCAtGAAwLqwCNCxABBApjAQYKNwEJCgABigqUAYQAawKJAAUBCgvpAAoK9gKLC0wABQD2AAgAvQAJAGMBCQAAAgoAfAAKAMUBCwCPAAsAoAELAFsDjQBVAYYLugGFCjsDBQpAAIwKRQIECroBBwoXBAcKSAWHCmsGhgutBgUApgIGADEBBwAHAwcAKQSFCtEDCwtFAAwLaQAMC3UADQvVAA4LDQAOCz4ADguxAA4LpQEPCxMAkguNAIkLNQEFACMABwBeAwcAXgeKALMAiAAdAYQABQIHC9ADCQuSAAoLzgAKC1QCDQvaAI4LmQCECv4ABgDWAAwAHAIEChMBBwrDBIwKeAEIAJsCCwCTAZIAUwAMAEoACguIAgsLnwKPCy4AhwB9AIYK2QaFAPkCBgCQAwQLBgIGCnEBBgr2AQcKDAQHC3AECApcAQkKxAEKChoACwrgAAsKgwELCgQDDApfAAwKdQINCsMADQrPAA0K8QAOCgQBDgoOAY8KjAAKAIMAjABIAIQKDQEFCuABBwoUAgcKrQQHCk4FCAojAQsKXQGOCowBCAuxAokLXwMIAE0BigC2AAQLEgAHC5EABwu8AQcL/gQICzEACAuQAQkLRwAJC/oACgvLAQwLoACQCxgADgsjAI4LvwCHC0gHhwA6BZQKDwAOAF4ADwBBABAABAAQAE0AEABQAJEABQAMC1IAjwskAIUL8gOFAMEBhQCGAgcAVgAIAGcAhwqRAgcA7AeKAIECiAoVAoYAAQCLC8oDBQtXAAcLOQEHC08ECgtwAAoLRgILC4UBCwstAwwLgQENCx4BDgt8AJILbAAGAGUDhAsLAQYAFQEHAPoEBwBqBZIAVwAGALsABwAnAAcAswQIAHwBDgB1AJUAHAAECtMABApMAQUKTwEGCu4ABwoNAQcKKwMHCgUHCApEAwkK+wGNCvIABAARAwUAcAEGACkBBwAZA4sAqgMHANABCAAuAgsAaQAMAOcADgCCAQ8AZgCUAEsAhQrxAwgAbQOMANsCiwshAQoL+QCLC9EAhAsxAoYASAaEC/gChgCVBQkLmgCMC+UBBQrkAAYKywAHCpwACApbAYkKCQEHAPIDCwDdAgsA9wINACIADgCrAZIALQAHCmsEhwq8BYgL/wAHAHgGCQBxAQoAUgEKAOoBCwCaAAsAIQILAAcDDQBNAI0AEgGFC20ChgAOBAQLcAGHC4ECBgDaBwgA0wMIANkDCgC3A4oA8wOGAO0DEwB5AAUKIwEFCj4BBwr9AgkKhQGMCiQCBQAUAAYAKgEHAJMCiQDbAAcAoAULAFYDCwBoAwsAmQMMACcCDQDYAY4AbwEFAOoBBgBnAgYAbAKHAKsCBgAuBIYAPQaLAAoChAC3AYgAnQIGAP4CBgB3BAYA3QQKCg0CiwpSAAkLXACTC1sABgCcAoYAwgQGCw0CCQtsA4wLHAGEAOkAiAAjAoQKpgEFCmMBkQoAAAYLLAGHC+sFBADiAYkKiQMEAHYDBwBaAYULUgKFCmEDBQqSA4YKWQaHAE4BBQAbAwYAzQaFCuoAhwpnBQYLaQaICzQDhwBzAQcLIQWKC5QChwogBYcAbgIHAHEChwDWBocAUwEEAMsAhwCQBw8AHQAQACYADwsdAJALJgAFAFIBhwDoBIcK1QUKAIIABgqlAQcKPQAHCgQGigr1AQYLhQEHC5UACQuOAIoLXgCJClUBCwCmAgwAMwGOCmIABgsIAAcLWQeIC1sAhwD8BwYAAgMGACIDBgAsAwcANwEJADQBDAD/AAYKZgAHCkgADwqOAJMKQwCXCh4Ahwo3A4cA8gSHC9IGhwpOBwQAkAEFAAsBhwDoAAcLGAALCx4CiwtUA4cLywYEC/cBhwt9BgULggAHCyIFCQtiAgoLzgILC1kCCwszAwsLsgOMCxgCCguVAAsLGAGOC1ABBwDjAgsAsgIHC5oHCAowAAgKWAAICkYCCAqpAgkKdQEJCmADCwqdAAsKSwOUChsAhgDeAwQKWAAFCokABQquAAUKCQMGCoAGBgq9BgcKTQAHCqoBBwolBQcKSwUICn4ACAozAgkKCwIJCu4CCgo2AQoKRAMLCioACwo+AQsK2wIMCkQADApcAAwK+wEMCrQCDQpRAA0K7gANCnYBDgq0ARIKigATCk4AEwpvABQKNwAUCk0AlApcAI0KogEHACcHhAqqAwYACAOGAJMDigpfAQULXAEGCwoCBgqEBgcK2wUICnUACQo6AYoKrgCHCsMChABlAoUKkwGEC4gBBQuxAQkLeQKLC3UChQD7AoQAbgOEANEDhABkAAYAzwEECiwABQo3AQcKfwIHCvoCBwojBwkKCAAJCs4BlApTAIYL6gAECloBBwpzAAkKtAAJCsgBigprAQUAagEFALsBBgA+AQcA+wOLAG8CBQDPAQgAKAEHC4wABwueBwgLqAILCzEDkwtYAAcLxgSKC4IBjgCJAIQAxgEHAHoHBgsFAAcKGwQJCiECCwv5AAwLOQEQC0IAkQsaAIcA9wWRADoAlAs7AAUAMAAFAJQBBgAtAgcAygEIAFUCCgDHAQoAXgILADEACwAkAgwA3AENABIAjQDCAQULwwOGC+0GhQDZAooLSgIFALoBhwDAB4YAwQGQACgABABVAwcLtAAIC/0BiAsYAwYKuQAHCmsHCQprA4sKoQKGCwwCDADjAAQKRwEFCt4BBwo0BYgK8QIGANMFBQr8A4UK/gMECmcAhQqRAYQLowMECvMBhwqNBQUANwAHAHgBjAChAIUAwgEGAJYEhgAaBgoAPgANAJABhwstB4wAzwCHAGUDBAsFAwULagKJC/QChApgAAQA1QAHAN8ACABQAIcKyAMEC1oABQtRAQULIQIHC/ICCQu6AAoLSAAKCw4DCwsBAgsLQQILC2ICCwt5AwsLwQMMC2IBDAtqAQwLzQEMC1MCDQtPAI8LeQAHAH0BBwAmAwcANAMIAGIBCAC1AQgAEwMJAJECCgA6AAoAUwEKAO0CCwCSAwwAogANAEsADgBqAA4AxgAOAEABDgCdAZIAKwCIAOsCiAC6A4YAMQSHACwCBwuXAAkLSQGLC/4ABQC0AoYAcwUGCjMCiQrgAIYAvwCEACQDCQu7AAoLJAARCywAkgtAAAcLpQAHC5cDiAsFAgQL+gEFCycBBwuQBg8LDgCQCwUABADCAgYAogAHAKgHiAA/A4cLYAUHC9sDCQuwAgoLCgILCxQDjAs2ApYAIwCKAKoBhwDTBIcLzQYHC4UBBwu8AgcLrAMICwICCQt0AAkLFwIKC3YACwtrAAsLlAALC5oDDAv+AAwLpQGOC+4AhgDSBIQL5wIECo4DBQpAA4cLNwWNAGAAhwu5AJIAlQAEAMwAiQCGAwQLEAOFC+kCiABBA4gAtQMHAG4BCQAfAQwAxwAMACwCDABBAgULUQAHC5IABws+BQcLpgUICzUACAsxAggLtgIIC/ICCQthAAkLcwAJC34DCgvOAQoLLQMLC+YACwuRAgsLuwILC+wCDAt3AAwLyAAMCxsBDgsRAZELDwAFC5gBiQvrAgkL8gGMC7UABgDkB4gA4AMFAGQBhwDgAIYAEAMHAHYCCQA3AgsAlgALALwBDQB3AAgKEAKJClwBhgAbAgQKFACFCmgCjgAbAAcLHgAIC1YACAs7AQgLvAIJC0ACCQtaAwsLNgELC3gDCwuIAwwLaQGNC/gAigtHA4YA8wKGACcEBwpDBIcK5QaGC6wBBwsMAggLqQAIC+oACQvgAYoLhgKLAC4DBwu2BYsLkwIEChoABQqtAQYK9QAHCsACBwpjBYcKwgUHC7UEigt9AosLIwOECm0CiADbAwQLCgEICwQACQsnAAoLpgALC5YDDAt7AhQLCgAWCxsAlgsrAAQA6wCHAP8ABADCAAUASAIGAIABBwBHAgoA+QILAPgCiwBTA4UKHgKGAD4EhQpkAwgA+AOIAPoDBwB0BQcLdAWICrEBhwrXBYoK1wCNCnwABwudAAgLFwEJC/cCEAsfABALJwAQC0sAEgsYABQLKgCYCwEABQAyAoYLXAKGAJEDBQC/AIkADwEEANYBBgCZAAcA3wUHAIMHCgC9AgsAhAALAOMACwBAAQsAtAELAA0CCwBXAwsAaQMMACkADAAeAQ0AZwANABwBDgD/AA4ABgEPAHUAjwB/AAcA2wEMAC0AkwpwAIQLNwKJC1sDBgDJAgYAyQMGAAoFhgAPBoUARwEGACgCBgAMBQcA2gaJAFwCBADfAAYAZwELAAMADQBsAA4AWQAQABYABQv6AgcLWAcJC6gCiwseAwUAUAAGAJUBBwCTAQcA3gUIAMgBCQDnAQkAVQMJAHkDCgA1AQsA0QILAOIDDACuAY0ApQCFCyoBhAqHAoYA4AcSCgoAkgsKAAQAxQEFAHcDBgAXAggABgAIAB8CiAA6A4gAzwMKAMEDigDCA4oK3AAGAGMHBgBlBwkAlAMJAMUDCQDMAwwAIQMMAFsDDABzAw8A4gCVADMAhAptAIcLCwEHC1wABwu2AAgLxQEJC8wACwu2AwwLXgAMC4QCEAsUABALRgAQC1oAkws3AIYK0gYGC0cABwtNAwcLHAUIC6AAiQs+AQUAZQAGAFgABwAHAQcAdAIHAI0GCABdAQkAZAAKAKUCDgCpAA4ALgEOADkBDwAwAA8AVAAHC+0ACAuYAgkLKgAJCwoBCQt8AQkLhQIKC7EAigsUAYoLRQAEADYBBwDEAgcA5AMJABsDCgCGAQoA3QILAMMBDAD5AA4AcwAOAB4BjwBkAAUASwIECigACgpDAAsKdQALCgADiwqnAwYAlgcHAAACiADXAwcK4AMICi0BCQrSAgwKPwANCh0ADgqhAI8KEgCIC0wAiwqbA4YAhQKGAFMDBADyAYQLJQEHANkACACMAAoAYgIOC2ABEQs1ABILkgASC5gAEwsLAJYLNgCGAKgFigtJA4UAiQMEC10CBwsGAgcLAgUHC34HCgu0AIsL2gCLC5UDhwo5A4wKSAEEAMgBBwBpAAcAZgEHAGUGCACDAosA4wGGABgDBgtgAIcLkgWJC7MCBAuLAoULIQEHC7ACCAsjAAkL/wEKC/8Ckwt2AJYAOAAFAPMABQAXAgYKzAAKCkABCgpHAg0K9gEOCkgADgoSAQ4KOAEOClgBDwqfABAKPgAQCkUAEQoeABIKKgASCjUAEgpUABIKjAATCkQAEwpVABQKBQAUCi0AFAplABYKBwCWChQABAouAgYKhgEHCqIABwqxAgkKaAGKCo0CkgsXAIcA1AYFClgDBgqIBgYK3QaGCvUGBQAbAgUA8gIGAGwDhAvAAocLNgQFClwACgrgAowKZgARAFsABQpOAokK1QCGAB0GBgBbAIcAswEEAKsDjAAYA4YAdwUEABAABQA8AQUASgMGAHIBBgDyBggApgALACwDDADOAAwAXwEOAKIBEAAPABAAIgASAAMAEwADABMABwAUAAQAFQAVAAQL0AKFCzIBkABfAIULrwGEC+oAhwAnAgQA5wMGAK4HhgD6BwcAawIKACMCCwB6AAwAWQIPAAcAlAAUAAUL0AEGC+wABwsUAQcLuAIHC5IDBwtUBAcLqAUJCw8ACQs0AgoLDgAMCzUCDQvBAQ4LNQAPCw0AEAtAAJELKQAGAHQDBgD7A4YAfgQGC+cGDAvCAJELawCICvcBhQtIAwcAnwKGCtIBhAB4AwQAlQCKAHABBACaAAcAbgSIAGkAhwDXAwkLggILC+wAjgvBAAQAHwAGAK0BBwDCAwkAygGLALMCBgCDAoYATgSEADgBBAtEAAULegIGC4IBBwsaAwgLEQEJCzMCCgtpAAoLqwALC14AiwtiAYUA5AKHAGoGBAtfAAcLoAEIC9MAiws+A4QA7ACKCvEABwvbAg0LFACPCwsABQBEAwUAWQMGAJAGhwA7AAoARAALAO4BmAsGAAQAUQCLAGMDhwAbA4ULsQIEAOkDBQAaAQYAjAcGALkHBgDDBwYAyAcIAIoCCACXAwgAmAMIAJsDCACeAwgAnwMIAKMDCACrAwgAswMIALwDCADlAwkAiwMKALYDCgC5AwoAugMKALwDCgC+AwoAvwMKAMQDCgDKAwoAzAMKAM0DCgDPAwoA0AMKANQDCgDVAwoA2AMKANwDCgDeAwoA4wMKAOcDCgDqAwoA6wMKAO0DCgDuAwoA8AMKAPEDCgD0AwoA9gMKAPcDCgD7AwoA/AMKAP4DDAC/AwwAwQMMAMIDDADDAwwAxAMMAMUDDADHAwwAyAMMAMkDDADKAwwAywMMAMwDDADNAwwAzgMMAM8DDADQAwwA0QMMANMDDADVAwwA1gMMANcDDADYAwwA2QMMANoDDADbAwwA3QMMAN4DDADgAwwA4QMMAOMDDADmAwwA5wMMAOgDDADpAwwA6gMMAOwDDADtAwwA7gMMAO8DDADwAwwA8QMMAPIDDADzAwwA9AMMAPYDDAD3AwwA+AMMAPkDDAD6AwwA+wMMAP4DDAD/Aw4A2wEOAN0BDgDeAQ4A3wEOAOABDgDiAQ4A4wEOAOQBDgDlAQ4A5gEOAOcBDgDoAQ4A6QEOAOoBDgDrAQ4A7AEOAO0BDgDuAQ4A7wEOAPABDgDxAQ4A8gEOAPMBDgD0AQ4A9QEOAPYBDgD3AQ4A+AEOAPoBDgD7AQ4A/AEOAP0BDgD+AQ4A/wEQAHEAEAByABAAcwAQAHUAEAB2ABAAdwAQAHkAEAB6ABAAewAQAHwAEAB9ABAAfgAQAH8AEgDyABIA8wASAPQAEgD1ABIA+AASAPkAEgD6ABIA+wASAPwAEgD9ABIA/gASAP8AFAB9ABQAfgCUAH8ABwu1BgcL6QaKCyICBwtnBAcLJAYKCykBCgumAQsL/AILCyoDDAsIAQ0LZgANCywBDQvkAQ4LkwAOC+UAEQtHABILdgCTC3gABgB8BIYAMgaEAAcDhwq6A4ULYAOFC6ADigu9AIcKpgcGCiUCCAoiAAgKGwEJCqUAigrbAQUKjAIFCr0ChwrBAYcLtwIECo8CBwpSAxEKSwCSCokAjAuqAoULCwIIAMoDiAqeAogLKwIHC0wACAssAAkLdAMKC0QCCwuPAQsLfgMPC3oAEguQAJMLPQAGCp8ABgpsAQcKBAIHCp8FiQoGAgQARwAFAHgBBwB3AIoAmQKNCpcACwA7Aw4AIgCPAJQAhQsGAgQA3wGHC/sGhws8B4cK4QMHAF8CiABjAIYAqAeEABkDBAApAAUASgAHAFsGCwBnA4wAawIHAF4ACwBJAQsAxQMMAPEADgBiAQ8AFgCUAD8ABwr1AQkKbwAKCo0ACwpMAQ0KKwANCq0BDgqCAA4KnwGRCmYACQDRAIkALAGGANkFigv/AAQLpgMFC4oAiAtiAoUAYgAGACQFCgskA4oLQAMIC2AACQskAAoLXwILC6cBCwu6AQwLNQEOC8cADwtaAJELbgCEAM8BBQqVAIgK6QCFCqcDBAuMAggLQAEJCw0ACQuOAQkL1wIKC0sACgu4AAoL5gAKCzQCCgs5AgsLzQMMC0YADAu9AA0LOQANCwEBFgsGAJYLEACOACMBDApGApIKgwCICiEDhQDYA5ELdAAEC7QChQtBAQQAtgAGAM0AhwDcAAQAKgAJAM0ACQASA4oAkwIGACEDCwuCAIwLYQKEAHsCBQtZAYcL+AOLABUChABzAQQAEAGHAEQDBgACBYcLTAQFADkDhgBoBocLLQWFC6ECBAsfAYUL+gOHAGUBBgDTAYkAbwMHAD0BhwA5AgYAnAOGADQGBQsiAAUKlgEKC9QCDAu8AQ0LYgESCyAAFwsYABcLHwCYCwUABgADBwYAKwcGACwHBgBABwgATAMIAFEDCABWAwgAZgMIAHcDCgBUA4oArgMGCkUAhwp1AIkAMwEEALADBgAHBwYAIQcKAFADCgBrAwoAfwMKAIMDCgCGA4wABQMLACsADQBIAI0AjgCHCiYHhgt+AQQKsAGHCjgDhAtJAQcAHAeLC3wAhQo6A4UADQKEC4oDBwuUB4gLbgGKCwoABAt7AAQLiQIFC10CBwvlBYgLJAAGAG4AhwCRBoUA7QGFC/8CBACuAIcAjwOKCxIDCAChAYkADgOFCugDBwDdAokARwIECikBBgoRAgcKmAAHCskCBwo1BwgKxgIICs0CDAp/AowKrQIEACAABQDXAAYADQEHAPYGBwBkBwoAEAALADYDCwC6A40A4QEECxEBBQuSAoUL4wOIAN0BhgtIAIcLQQUFADQBBwBABAQKCAKHCj8ChQtNAgUAfgAIACkBCQBuAYwAdgEHAA8GiwBpAQULdQAGCwICBgsdAgcLjAQHC5wFCAvcAAgLiAIKC7ACiwswAoULrgIEALIDBgAPBwgAZwMKAFYDCgBmAwoAeAMKAIEDCgCYAwwA0gIMAPkCDAD7AgwA/AIOAMYBDgDRARAAawASAKcAEgCoAJIArACEAK8AhwAbBYQArQKHCyoHhQAdAwYA6QIGAFoDhgDDA4UANQIFCo0BBgqaAAcLxAAHCqQCCAq7AQgKYQIJChgACQpFAQoKIwAKC/0CCwtbAQsKFwILCygCCwtAAgsKoAILCxYDCwr6AwwLBwEMCn0CDQv2AA0LDgENC4sBDgtKAA4LsAAOC74ADguOAQ4LnAEPCyAADws/ABAKHgAQC1gAkwtpAA0LVACNC3oABAD8AAcALAQKALIBCwDkAAsAqgENAOcAEgBqAJQAVwCJADoDBAtNAosLGgEFC30BhwsAB4QAFwMFAOcACgD9AYUK1QMHAFkCCQAVAQkAogIKALIACgCiAQoAOwILABMCDABxAAwA2wENAGMAjgCsAQQKOAAHC2gCBwr/BggKXwIICosCCgudAQsK0QELCkMDDApRAY0K4AEHADcGkAArAAkKngCKCpsBhwCTBggAIQELAC0ADAAWAYwAGQIGC3gABwukBAcLrgYICx4BCQubAgsLUAKLC9oCiAppAocAYASHC3oEiwozAgQLYAEECnEBhwuvAo8LJgAEAI8BBQB3AAUA7gEHAO8CCQAsAg4LswAPC5cAlgsLAAQLwAAFCzEABgvIAAYLJQEGC6AGhwvoAQQAjgGFAJQCBwAGBIYKbgKHC1MCjQCoAIQLkwAHAM0DCgpwAo4KFwGECmsBhACCAoULpgOGAE8GBwv5AYcLCwIHAFICBwBTAwcAQgcJAJsBCQA+AgkAmgIJAOECCgBaAQoAyAILAPYACwCwAQsABQILAIcCCwCnAgsA1wIMADABDAAxAQwAQwEMAOMBDAA8AgwAUQIMAFoCDQBfAA0AZQANAKsADQA7AQ0AegENAKkBDQDbAQ4APwAOAHwBDgCAAQ8AhQASAHAAlABIAIcARQSEAKcCCACRAwoAhwMKAJMDDACIAgwAiQIOAMcBEABwAIoLtgGJAMsAhgokAYYA1AUHAF4FCAAcAgUKsQAGCmgCBwo7AwkKDQKKCpAChwDOBQkAygKKCh8AiAA5A4YA5wWEC30ChgC4AwQKoQCFCncCBQCPAAUAAQMGAOAGBwCqAgcAyAeIAOAChAC8AoYABAaECwkDCQtjA4oLRQMHABUGhwqUBoUAXAMGAKYBBwAAAAcACAYJAF0CCwDeAwwA6wAMAMUBDQAvAA0ACgEJCtUBCQrFAgwKAAIOCkEAkQoMAAsAJwMKCuUACwpJAIsKeAEGC6oABws4BAgLiwEIC+cBCwt9AI0LkwAFAAMCiQCDAAcARQYLAMIDkgCLAIQAhgIEAIwBBwDYAgkAdQANAMoAlAAzAAYAeQAGAHwABgBlAQcAcgQHAA8FCACiAAgA/AELAI8CBAsXAgYKLgIHCosCCAtqAgkKAAAKCiIAiwrwA4cL3QSKAGUBlgsXAIUA7QCHAPgGBwooB4oKdgGEAMkChAsuAAYAAAYKAFwBBQsrAwYLjwYGC7IGhwvwBwsLtgCOC8MABgALAgcA4gIHCgMDBwrDBgkKlQGKCqUBBwuyBQkLlwGLCw8ABgsiAAcLRQAHC4ACBwtBBAgLxAIIC9ECCQtrAQkLgwIKC3QClAtiAIUAsgGHAFUHBwA7AooAbgEFCnEDhQp1AwkAAQIKABkACgAnAAwAegCMALsAhABEAgUKjgCGCiIChAvOAYkAaQMFCtIBCwo7AgwKxgANChsBDgq6AA8KFQCPCmcABwCrAAQKuQAFCgEBBQpHAwUKqAMJCo8BCgoCAQoKiwEKCt4CCwr2AwwKFwANCl4BDgqWAJMKBgCGAHECBwBrAAcARgMIACYCigCRAQULSQAGCxcAhgtSAQQArwMGADoHDADJAo4AsgELAEwCCwBgAwsAqAMLAMgDDABJAAwAVwEMAIoBDQATAQ4AAQEPAKAABwqUAQcKYQUHCpYFBwrhBwgKlQAICu8ACAoAAggKGQMICjIDCQraAQkKUwIKCnoACgo1AgoKiQIKCg8DCwrvAAsKJwELCr8BCwoQAgsKfwILCiADDAoZAAwKnQAMCjwBDAqGAQwKhwEMCosBDAreAQwK9wEMClACDAqoAg0KMgANCjUADQqEAA0KxgANCkIBDQqfAQ0K/wEOCkcADgqLAQ8KRwAPCogAEQp7ABIKXQCTCjoAhQAAAwsAZwCOAAAAiArIAoQAHwOEAH4DBwvVAggL8gGLCwwBhwsGB4cLBQONC2gBBAp5AZgKDQCHAIkGhAtHAoYAHASFC9wAjAtFAIQLIAIECrQAhwpyB4YAEAEEALkBhgCNBQQACQAFAIAABwBwAQsA4AGUAAMABQuwAAYLtQEGCzQCCwu1AI0LtwCECusBBwCeBI0LQwAGAEIFBAqrAIoK6gAECkoCBwqiBIoKdwKIAKoChgDsAw8AGACPCxgAhgDIAwQAAgAGAOYCBgAZAwcAIQIHAH4DCQqjAwoKTgGUCkcAiAtYAoUK/QIJAAEDjAC5AAQLFgMFCxEBhguKAQcA2gGJAEICBAuHAAYLfwAHC6EEBwvnBQgLZQILCwUADAuFAAwL7wEMC0oCDguBAQ8LdgARCxQAkgtiAIUKqAEFABICjgBxAAYL5gAHC8EDBws9BIgLzgEHC6IHiQt8AogKygKVCwYAhwqtAgkKpAEKCg0BCgodAQoKQAILCo0BDQqvAJEKWgCECq0BBQAsAgULogCIC0QAhAuOAgQLnAAHC+YDBwsVBAcLRAcJCzAACQu0AgsLowGLC1oCBgAlBQgAEAAJADkDDAA4AgcL/AQIC9oBiQuMAhIAYQAHChIABwq7AgcKrgcICvACCQoRAQkKnAEJCr8CCgpHAAoKqwGKCvwBCgC/AgcLrgWKC78CBAo1AAUKugCHCvAChgB8A4YAIwYICj8CCgohAYsKPwEGALoAiQCqAYYATQSECqMChABJAgYATgeJAKkDmAsKAAkLxQAKCywBDAvZAQ0LWgCNC5UBBABdAAUA/AAGAOUABwAjAQkAJgKLAIQCiQDtAgkAogAGCtEACArUAQkK0gALCiQADAocAAwKdgINChUADQpdAQ4KBwCRCg0AhAB9AYQLXgIEClYBhwqbBAcLMwYHC6sGCgsQAosL+AEMCycADQsJAY0LtwEECqADhQqOAwcKLgcHC7oHiAukAgYA+gIGABwDhgC8AwQKPgEECvABBwpYA4sKjgKJC/IABAtpAYULOwGEC80BhAvYAYQAWQMFABUABgBNAAYAnQAHAM4DBwAVBQcAOwUHANIFBwBRBwkAdAIHCpMDCAr3AJMKAAAECsoABQp+AQYKxgEHCqgDBwoLBwgK9gIJCncBCQp/AwoK5wIKChgDCwrSAwsK9AOOCm0ABwtpAgoL8gELC/UBDAsQAIwLlgAHCn4EBwqRBQcKrQUKC+sCjAoBAoULmwALAJcDjQCZAYoKFwMKAHkCiwvZAgcLowAICz8BCQuSAQoLGAAKC6kCCwvIAAsLNwIMC/0ADAuaAY4L2wAFC9sBBwv0BgkL5gALCykBCwsuAg4LQgGTC0wABwBMAQYKvQGJCo0DhwukB4gLEgGGCkIChwDRBYcLOAcFC7ADhgvpBoQLkACICv4CBABAA4cKHQIIAI4BCQCpAosAeAKIAIUCCQAXAwoAXQAQAA0AEQAXABIAhwATAAwAFAABABQADACUAA4ABgv3AIkLKwKGABQAhAAgA4cAMQeLCtcDiQoAA4QKSAKNCzMABgDJBwQLbAKKCxgBiAABAwsAIgELAJkCBwsSBwsLYgMMC2cADQvvARELQwCTC0oAhgCSBYsAPAAECkYBhwrqBgcAUgcJAIEChAriAAYAhAIFCqoBCAoeAAkKAgALCiUCkwp6AAULrAGKC7oBhwtPB4cA3QaTCnUAhwCpA4cAdAYGAI4ChgDEBYULYwCHAA8ChApZAQQKgQEEC40BBwoJAYcKSwIEAEMCBQDiAAUAQwGHAMADhgDOBQgL9gGQCwkABApbAQUKpwEFCuQDhwoxBQcL1wKSC0kABAvlAQcLYQEHCusEBwvzBQkKfQCLCkEABgBFAQUKiAAGC24BBwtoBQcLQQaICoQCigugAAYAQQWJCxoBEgBbAJMARgCIAJQBBAudAIUL1wGFAM0DBgCHAIcAmAQIC3QACwsnAo4LnwAEACUCBAqxAYUKzwKIANADBQugAAcLawEHC00CCguqAI0LNwCQABUAkAAzAIcAOgGHClMFBAtsAAcLlQEKC+sBiwvyAZIABAAECisCCAoYAgoKIAGLCu0DhwvtAwYAGQEHAAYACAAaAQgA4AEIAPMBCQDGAAoAjwAKAKkACgDTAAoAoQEKAD4CCwCTAAsAiwEMAEsADACXAQwAYAINAPQBjgD7AAYARQQGAH0FCQpyAYoKWgAEC54DhQvXA4cA8AaGAPgFhACjAYQLGgIGCyYBBwvzBIgLcAKHC+wGigstAQQKAQGHCu8HBACKAAcA9AMHAAAFCQBMAIcK6AaEC/UCBQAdAIwAfgIHC48Chws0BwcAigUGCwEBhwvyBQgL1QGKCy8AjgsWAQYKUwAGCsUGhwptBQsLzAALC/MAjAslAYcLUwcGAK4GhwD2B4kLKwEEABEABQAXAAcA4wMLAH8BCwC1AQwAzAGMABQChQBeA4kKuAIGAFACigCyA4oLVwIHCrYGCQpfAAkKEgEKChcBCgo9AQoKpAELCi8BCwooAwwKhgAMCm8BDQqVAA0KWwEOCl0BDgqWARIKFgASClkAEgp6AJMKLwAIAEYADACrAI0AEAGFChoAhAomAokALAMKAOkAiwBMAIYA3AOGALoBiAo2AwcAgAMECoYDBQopA4YKegAFC5YABwtqAAgLWwIJC1ECCQt6AgoLLAAKC60ACwvOAQsLAwINC9gADQsgAY4LkAGIAOMBhwoGAQYArQaFCmwCBAoiAAUKPgIHChcBBwpYBogKWQKJCqoAkwB3AAwLbACNCyMBCwBFAAwAaQAMAHUADQDVAA4ADQAOAD4ADgCxAA4ApQEPABMAkgCNAIkANQELCxYBjgtJAAcAYAIHANADCQCSAAoAzgAKAFQCDQDaAI4AmQCFCkwBBgoFAQgKtgCLCq8DBAvtAZALNwCGCrkGhAAAAwQKpQOFCnADBwsrAgcLJAUHC4QFBwsvBwkLwAAJC00CCwvxAAsLpAILCysDCwt7AwwLjAAMC1oBDAvfAQ0LHgANCzEADQt9AQ4LvAAPC5YAEAtMABILHgCUCzQABAAGAocAcAQGCzgCBwtwAAcLDAcIC2oBCAuaAQgLPgMJCwICCwuJAo4LnQCHC6ECCACxAokAXwMEABIABwCRAAcAvAEHAP4ECAAxAAgAkAEJAEcACQD6AAoAywEMAKAAEAAYAIQLcQKMAPwDBADlAwYAmgcGAMAHhgDOBwYLEAAGC54ABwsrAAcLgQAHC7UACAsUAQgLeQEKCwsCCwswAwwLxwENCy8BjguHAIUKLAOGAJICBAsBAAcLdwQHC7cFCAs9AAkLzwAJC4YBCQvTAYsLRAOWCxoAjABqAAYAIwcKAKMDEgCmABQAcgAECokABwqaBAcLJwWHCvAFhQDyAwQL0wIFC38DBwsHBAgLxwAIC1QBCQuZAAkL1wAKCxUACgs7AAoLUAAKC+AACwvlAAsLjAIMC8AADQuSAI4LWwCECycBBgtrAgcLggMHC0QECAvlARILHACTC3QAiQszAAYKfQYHCrcHBwrZB4cK2wcFCzUBjAvTAAUAVwAHADkBBwBPBAoA0AAKAEYCCwCFAQsALQMMAIEBDQAeAQ4AfACSAGwABQt9AAgLTQCKCw8AhAALAYUAvwKJC5sAhQu3AQsLpACMC0wACQDwAQUKWQAHCnsHCQq5AAkK6wAKCkAACgoOAQoKkwEKCtUBCgoRAgoKTgILCowACwpcAw0KAQANCqYBDgpVAQ4KbAERCl0AEgpxABMKYQCTCnEAhQq3AocAYQQFCgYABgq3AAcKqAIHCtIDBwr1AwcKHwQMCuYADQqsAJIKHQAECwgABwuABAcLgQQHC7MGCQt2AQoL3gGLC4gChwtLBAYKHQCLCj8ABAAxAgoA+QCLANEAhAD4AgcLHwOKC/8BiAtXAAkAmgCMAOUBiAD/AIQAQwGMAKMBhAo3AYYKzAYEAHABhwCBAgcKqgAICloACAqxAAgKnwELCsoCjgoZAQQLRQAFC3oACQuQAooL0AEFC1EDhgthBggACgKOAEgBCwpbAA0KgQAPCmUAkQp9AAcAMgIIACcCBAruAQYKSgAHCiwACwvzAQwKEQAPCgUAlAoLAAQKFAGFCigBCQBcAJMAWwAECgcABQpaAAUKngAGCh4CBwrdAAcKJgYJCuoBCgocAgsKuwGLCvUCBgANAgYAuAcIACYDCQBsA4wAHAEFC1sDBwpMAgcLiAQIC2sACQqvAAkLIwEJC7cBCgoSAgoLlwILC2ECjAvFAAcLqAANC8QAjQvtAIsAvgOFAFIChwpEAgcKWACICnMCBgDfAQYAMgIHACQEDQAGAAUKaAMGCjkABwrXAQkKvwGJCsYBiAudAZELEwAEC3UABgt0AQcLcQeOC0MBBAvSAosL1wERAD0A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hwudAwQL1wEFCzMABgtaAggL5AEKC8MAjAufAIQKMwGIC7AChAu5AgcLLAMHC+0EBwtQBQkLeAKMC2ABBQCiAAgARACFCsQDBACOAogL1AAEAJwABwDmAwcAFQQHAEQHCQAwAAkAtAILAKMBiwBaAoUL3QAEC3UBBQsbAQYL4AGHC2ECjgvYAIQA8AAGC8AACQsZA5ELNwAECksABQq0AAYK9AEHCjoABwrGAooKhQIEC4QABQtFAAUKiQKHC9oEBgoUAQcKGgEHCm8DBwqcAwgKywEJClcCCQryAgsKPgIMCoAADAruAQ0KNAANCi0BDwoeAI8KhACECsgABAtvAIcLLgEJAMUACgAsAQwA2QENAFoAjQCVAYQL/wIGCyoABwuIBQcLNgYHC9UHCAuDAAgL0gEJC6ACDQv8AJQLZwAIAL4DCADnAwoAwwOKAOkDhwpVBocAWgMEAF4CiQu8AQYLLACIC3ABiwusAAQLOgKFC3gAiwtwAgcAugcIAKQCBgrhAIkK0wAHAMwDCwBmAIgKrwIGC+MAhws1BggKOgAJCtQCCwopAw0KcQCRCkgABABpAYUAOwGEAM0BBgpZAYcK3wSEANgBCAr/AggKIwMJCi0BiQqHA4cLNQWHC90BBwqdB4gKogIGAIkDigDrAoUAmwCGCgMBBwCjAAgAPwEJAJIBCgAYAAoAqQILAMgADAD9AAwAmgGOANsABQDbAQcA9AYJAOYACwApAQsALgIOAEIBEwBMAAYLgwYHC/QHigtYAogK/gAGAFADhwCkBwYL/wGMC4QABQs4AgYLigCHCw0FBgB3AokARgOVACQABAs1AggLFwCICzsDBQCwA4YA6QYEAJAABgBKAwYAeAUEC5oDhQv/A4UK+AAJCiADCgq1AgsK4gELCt4CiwoVAwcL6gOLC5EABAp0AAUKXwAFCr0BBwqYBggKHQAJChABCwr9AYsKkwMOAHEBkgBIAIcKaQaEC+QChQofAowLdAAGAPcACQArAgUKtQCICikAhQqRAogA5AOKCsUCBwC9AAgKygCKChgCiAuSAQQLzAKNCx8ACgAYAYoAHQMJCqcBjApZAAgKcQAJCm0DCgoqAgsKUwAMCogAkwptAIUK0AMHAOoChArOAIgADgKLAFkBiAD5AwgLmAAJCzUACQsMAQkLhQMKCwYCCgs9AwsLvAANC0oA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CwoxAAsKJAIMCtwBDQoSAI0KwgGFAJ4BhwDiBgULpQGHCy8ABQq6AYcKwAeGAFcChgDVBoYAWwYEAOgBhAteAYkL7wKEAFMAjACkAoULxwMHAGcGBQo3AIwKoQAEC9kBBwtvAggLKAMJC2cDCQt9AwsLJgALC68BDAtwAAwL2QAMC/MADAsyAgwLqwINC40ADQvFAA0L4wANC5YBDQvnAQ4LnAAOC8sADgvgAA4LAAESCzoAlgsAAIUKwgEHC+ACiwsIAYYAFgEEC94ABwseAYgLdQKHCmUDjABhAJAADgCGAD0EBArVAAcK3wCIClAABwCEAQcAhAKLAA0DhABRAwcA5QAIADsACQC+AAoAegGMAL8ABwp9AQcKJgMHCjQDCApiAQgKtQEIChMDCQqRAgoKOgAKClMBCgrtAgsKkgMMCqIADQpLAA4KagAOCsYADgpAAQ4KnQGSCisAjQsyAYgK6wKGAFsEEABeABAAbACIC5IABgC8AgYAMQOGAOoDhQq0AgQL0QGHC38Ghgq/AAYAhgWHC5EDhACUAgcACwSKAOECBgqiAAcKqAeICj8DhArCAgcAsgIJANkACQBLAowACQKKCqoBhwrTBAYLUgAHC4oABwsFAgkLoQKLC+4AigAQAQUL7wEHC0IDCQvdAosLegGGANAGhADzAwcLPAOOC3QABADdAgkAwgAKAFwACwDGAAwAVAANAIAAhQsvAgoAOQAKABUBBgsVAAYLyQYHC6QFiAvgAAQKzACJCoYDiApBAwsAXAEMAGMAEgABABIACwATAAQABwpuAQkKHwEMCscADAosAowKQQIGAL0HiACoAxUAIQCWACgABQsHAooLzAAFCmQBhwrgAIYABwOHADIBBwp2AgkKNwILCpYACwq8AY0KdwAFANMDhgobAoUAYwIEC5IBhwuPBgUAsgAHCwIACAtDAYgL3wEFCzsAhwugAgQA8gMGALEHigvtAIULnAGSCyIABwvMBpILMACGAJgCiwouAwQLVQCHCyUChQteAIULyQGEAIYBhgDmBQQK6wCHCv8ABArCAAUKSAIGCwsABgqAAQcLuwAHCkcCCgr5AgsK+AKLClMDBAsKAosLIgOHAO0BCgsIAw0LWQGOC6kBkgAlAAQLNACHC5UChgDUAoYAPQOFCwgChQoyAgQLGQEFCyYABwvCAAcLnAIHC2UHiQuNAQUKvwCJCg8BBwABBg4AYACPAEkABQDZAQsAqAAECtYBBgqZAAcK3wUHCoMHCgq9AgsKhAALCuMACwpAAQsKtAELCg0CCwpXAwwKKQAMCh4BDQpnAA0KHAEOCv8ADgoGAQ8KdQCPCn8AhQBpAAUAtgEJALYCDABzAo0A0gCFCkcBBgooAgcK2gaJClwChgDoBJgACwAFC8ABCwtiAIsLDAIHAFoGBQpQAAYKlQEHCpMBBwreBQgKyAEJCucBCQpVAwkKeQMKCjUBCwrRAgsK4gMMCq4BDQqlAA4LEACSCywAhAALAwgAGQCKADoDBArFAQUKdwMGChcCCAoGAAgKHwKICjoDiQvNAYwLeAKEADQBhwDlAoQAnwIHAJYACACJAogA/AMJAGMABgtQAQgLKAIJCx0BCgtjAIsLOAKGAAkCBQBTAQ4AAwAPACkADwCmAJMAQgAGC6cBBwuZAgcLugQJC9oAjQveAAYAHwIFCmUABQsAAQYKWAAHCo0GCQpkAAoKpQIOCqkADgouAQ4KOQEPCjAAjwpUAAQKNgEHCsQCBwrkAwkKGwMKCoYBCgrdAgsKwwEMCvkADgpzAA4KHgGPCmQAhQpLAg0LoQEOC4EAjwsPAIYATgWICyoChAryAQcK2QAICowAigpiAocL3QOHC3oCBgCbAIwA6gCHC84BhAtqAoYAXAaEAP4CBAtTAQUKiQOHCwMBhwA9AwQL9wKNC6kABwClBQQKyAEHCmYBBwplBggKgwKLCuMBBQDmAYcARQUFC7AChwvIAgcAYwYIABEACgDZAAoAJwEMAAIAjAsCAIoALgKWCjgABAsWAQUL0QGHC1cFiAviAYUKFwIGAFIFBgC1BQoLEgEKC3ECiwsSAgUAVwIFC1ABBgtVAQYL3gEGC+MGiAuCAQcK1AaJC5cAhgBgBYUKGwKHC0kAhwuzB4sLGwEJAF0AiwDaAQYKWwCHCrMBBgC/AQULjAGGC/UBBAoQAAUKPAEFCkoDBgpyAQYK8gYICqYACwosAwwKzgAMCl8BDgqiARAKDwAQCiIAEgoDABMKAwATCgcAFAoEAJUKFQAHAEECBwCYBQkA2wEJAPkBCQAOAgkAYQIJALECCQDWAgkA3wIJAOICCgAsAgoAogIKAKwCCwBZAAsAygALABABCwB8AQsAnwELAPkBCwAZAgsAJgILADICCwCAAgsAmwILALACCwBPAwsAnwMLAKIDCwCsAwwAkAAMAEUBDABJAQwAhQEMAJMBDADDAQwAAwIMAFwCDABoAgwAcgINAEIADQCDAA0ApwANAOwADQBwAQ0AmwENALIBDQDFAQ0AzQENANoBDgA7AA4APAAOAIsADgCYAA4AFAEOAGEBDgCSAQ8AHAAPAFEADwB7AA8AmAASAIgAlABYAAQLoQOFCx8DiAsuAI4AMwEEAGECBwD0AgkAIAILAJ0BkAAZAAoArwIHCmsCCgojAgsKegCMClkCBACiA4UAswOFAKsDjgAVAAQLfAOFCwIDhQDCAwUAiwIIAKoACQA9AAkAPwAKABcACgAlAAoAQgMLAAQACwC7AAsAGQELAPcBCwClAgwAYAAMAIIADAD0AA4ABQAOACgADgCiAA4AygCSAIUABACWAQUAQwIMAOwBlgAPAIcLngCHAFUChADVA4QKeAMECpUAigpwAYQAIQIECpoABwpuBIgKaQCHC9EHhgAWBgQKHwAGCq0BBwrCAwkKygGLCrMChAo4AYcKagYGABEABgAYBQcAEAAHAOkDCQB2AwoA6QEKACADCwAOAwwAQAENANMBDgCRAA4AgwGPAHcAhwC+BxEAEQAHC7UFjAtbAAQK7ACEC1oCigCLA4gAbgAHABABEwA1AAUKRAMFClkDhgqQBgUAygEHC8IEiAsvAQcAvwcIAAAACACrAAkAeAAJANwCCgDZAQsAkAILAOYDEgAAABIAAgATABUACgpEAIsK7gGJC5YCBAsNAAULNwIHC9oFCQt8AAsLCQKMC5UBBApRAIsKYwOHC+4DBwsgAwcL9waKCwwACQAnAQoAuwEFChoBCAqKAokKiwOEC98CBAuqAAQKBwOHC0MBBgA0BwoAnAMLC0wDDAtoAIwLcQIFCzABBwt7BYwL8gGGANAEBAAHAgoARgAMABoADgARAA4AsgAPACIAlQAMAIQA4QMEC5QAhQvmAgYAHwAHAOsBBwASAggAUAILADUACwALAwwApwAMAJsBDgAOAA4AiAAPAEgAEAARAJAASACFAIsDhgDdAoULbwAECkcABQp4AQcKdwCKCpkCiAA3AAgArgGIC64BBADQAAUAagAGABMCCACYAQkAvACKADwCDAA4AAsKOwMOCiIAjwqUAIYAnQaFC7wBhArfAYwAuQEJAMEBCgDAAIoA5AKGAKADBADxAAcKXwKICmMACAt7AA8LBgCQCwcABgsdAQgLjgILC+0CDAu+AAwLRwENC3gADQt5AA0LRwEPCy8AkgsoAAQKKQAFCkoABwpbBgsKZwOMCmsCBwD1BQsKSQELCsUDDArxAA4KYgEPChYAlAo/AIQAAwGHC7cACQrRAIkKLAEFC6kDhwtkAIUKYgAEAK0ABQA4AQUAAAKHAAUFjQC5AAcAQwYHAJsGCQDQAQsAwwAMABcBDADAAQ4ACwCTAGYAhwBZBIUK2AMEAMQBBQBHAocA0AIEACMCBQAxAwYAsQEHAFECBwBiBQgAoQAJABwBCgA5AYsAdgMIANICBAq2AAYKzQCHCtwAlgANAAQKKgAJCs0ACQoSA4oKkwIGACEBBwCGBgwAOQCXAAQAhAp7Ag4AKwCSABUAiwoVAocAngYIAKQBiwDBAIcAmQGECnMBBAoQAYcKRAMFCjkDhgpoBgUL+wAFC7wDCAsMAQkL1gCSC44AigA0AQYARweNCyUAiQpvAwcKPQGHCjkChAsmAYYAFgMFAOoDiADpAgULWgEFC8cCiAuGAYcAIQEFAPgBCwBEAIkKMwEEAO8ABgDdAQcARwaLAGkClQANAIUAYQKFC3ACBQsPAwcLzgeHC/8HhQoNAoQAbwGEC1ICBgAQAoUK7QEECq4AhwqPAwgKoQGJCg4DhAC2AgcAJAKJADoABAogAAUK1wAGCg0BBwr2BgcKZAcKChAACwo2AwsKugONCuEBjACvAgcA1QaICt0BhAs5AoUKNAGHCkAEBACVAooA7AMFCyUABgsnAAYLwwEHC9oABwubAgcLjgQHC5cGCAuWApALAgAJAL0BDAA1AA0A7AEFCn4ACAopAQkKbgGMCnYBBwoPBosKaQGUAEoAhgv8AYcA1QCECq8AhAqtAgYA+AIGAEIDhgDgBAcLxQEHC3sCBwscAwgLSwEJC0gBCQtKAQkLYQMKC3cACgvrAAsLbwALC4EACwvwAAwLHwAMC0IADAveAAwLDQEMC1cCDAuxAg0LugANC2wBjgtZAQcAiAaLAL0AhQodA4UKNQIGAAwGBgtiAAcLSQKHC74CCQDIAw8AwACVADgABAr8AAYLJQAHCysBBwosBAcLggYIC8MACAs8AQkLsgAJCxQBCQtTAQkLGAIKC2YACgtqAQoKsgEKCxEDCws3AAsLlQALCuQACwqqAQsLBQMNCucADQugAQ0LowEOCyYADgspAA4L0gASCmoAlApXAAQA7wILAIYBjAAgAAQAmQGFAE4ACwvKAQwLDwCMC7ABBwBCBgoAAQEKALoCCwAgAgsASQIMANQADQAzAQUK5wAHClkCCQoVAQkKogIKCrIACgqiAQoK/QELChMCDApxAAwK2wENCmMAjgqsAQYA2QGRAGkABgCdBw8AnACFC4UCBwo3BpAKKwCHAPMGhwqTBgQLIgGHC0wFhgD7AgYLRgAHCwwFCgv6AosLIAGOAB0AjAusAQcAcwMHC4MABwumAQgL0gCMCz0ChgDoAQQKjwEFCncABQruAQcK7wKJCiwChQBpAoQLqAOLADIABwDuBYsAtgKJABEDBAAiAocA+gcHC8wCDQthAI0L+wCEC40CkQAWAIYA+AMEADkBhQBBAogLkQIIALgAjQCxAYcApwMGANACCQByAJILUAAMALoADAAkAQ4AZAASAEYABwpSAgcKUwMHCkIHCQqbAQkKPgIJCpoCCQrhAgoKWgEKCsgCCwr2AAsKsAELCgUCCwqHAgsKpwILCtcCDAowAQwKMQEMCkMBDArjAQwKPAIMClECDApaAg0KXwANCmUADQqrAA0KOwENCnoBDQqpAQ0K2wEOCj8ADgp8AQ4KgAEPCoUAEgpwAJQKSACHCkUEhwssB4QKpwKJCssACwCSAQwAbQAMAK8BDQCzAA0AzgAOANkAEAADAJQANQAHC1gFCAvoAAgLaQEKC6oCigvmAokKygIFAHYDBgAuAAYA/gYHAA4ABwDcAgcAdgYIAF8ACABHAQgAaAIJAHwDCgBWAgoAAQMLAIYACwDrAgwAegEOAGEAiQsWAgQAyQOICjkDiQsbAAYA1wKOCwwAhQD9A4YApgSGC3kGBQqPAAUKAQMGCuAGBwqqAgcKyAeICuAChACZAIcLfwCFAB4DhABLAgYAVgIHACoACAC3AgoA1AALAJ4ADgDEAJEAVQCFClwDBgCJB4YAjQcFAL0DBQDwAwkAQQIMAI0ABgqmAQcKAAAHCggGCAtsAQsK3gMMCsUBDQovAI0KCgGGACcFBACBAIcA0QEHANYBBwAhBAcAsQQJAPMCCwCKA4wADwIHAIwDkgAHAAUAlACIAMIBBQoDAokKgwAHCkUGCwrCA5IKiwCECoYChgCOBAQKjAEHCtgCCQp1AA0KygCUCjMABgp5AAYKfAAGCmUBBwpyBAcKDwUICqIAiwqPAg4AdgGOC3YBigD9AIsA6wMFC40DCQtRA4oLJQOFCu0ABwsNAgcLKwYIC/EBiAs9AokALgCEAG8DhgAmA4cATAcGAC0HhgA2BwYA2gKGAHEDBwDFAwcAtAUHAEQGBwvBAAcLjQEHC1EECAt8AAgLawIJCzEBCgsIAQsLKAAMC10BDQuGAA0LJwEOC5sADwt4AJILaQCIAPoBjwAKAAQLBgEHC1YBBwo7AgcKVQcKCm4BjQsXAIULgQIKABYACQoBAgoKJwAMCnoAjAq7AIcLlwWWCzEABAtjAAYL+gAGC1oBCAt/AIoLUQAGAN4HCACgAwoAwAMKANMDjADkA4YAKAGEC5MDBQtLAAkLBQIKC9YBDAubAI0L4ACJCmkDBABWA4wLEgCGAEsCBwprAAcKRgMICiYCigqRAQsAfAIPAJEAEQAiABMAMgAXABQACwpMAgsKYAMLCsgDjwqgAIcL2AAHANYDCgAgAI8AOACFCgADhQu6AwYLMAEHC1oECAuiAQoLWQELC1UBCwujAo0LKAAJC5oBiwupAYgArQMFALMBhAp+AwUAVQAGAKMBBwCGAAcAMQEHAGkBBwA5BQgARwCMAAcCjACwAocA5AIFALMCBwBZAQkAXgCMAKkABQC3AAYARgIKAKcCjACzAYYLDgAGALEDhwD/AYYLrAYFC3EABgvzAAcLSQcLC6EAEAslAJELYwCECxIBiQAbAgcAyQcIAKwChgoQAQYAkwKGANYDBAoJAAUKgAAHCnABCwrgAZQKAwCGAEcChAAjA4UAwAIEALMABQDGAIUAuQIHAFsBBwDLAwgAtQAKAMcChwumAIgKqgIECgIABwohAgcKfgOICwkChwDhAYQA8wAFAMsABwATAAcARwAHAHEACgCVAQsAZQGOAPAABQvVAgUL1wKHCxMHBgA6A4kLMAEHAKoFiwBjAIULjgKGAOwBBQCGAAYAmAEGAO8BBwA5BgYLEQEKC7wADQt5AZILTQAJCgEDjAq5AIcLmgGOAAQABACZAoYL+QYEAPgABwCJAIkAXQEFChICjgpxAAcA9gSLAGQChAsMAwUAcwGHADMChwA6AwYA/wUXABUAlwAXAAQAdgEHACMCBwCkBgcAKQeLAFoDhQosAgcLZAIICyECCAs4AggLggIJC80CCgsdAgoL+wILC8EBDAvpAQ0LmQANCygBDguKAA4LiAEPCzIAEAsGABALDACUCwkACQA3AY0AKgAIChAAjAo4AgYAsAcGAOsHigDfAwYAbwYHABAGBwDaBwkA7gGJAP0BhQu0AwYKugCJCqoBhgABA4YAggKECkkCBgB7AAcA1gAJANgCCgCdAAsAWgELAJYCjwBqAI4LfQGHAJsFBAsUAgULwgKHC5YCBQtFA4YLcwYECl0ABQr8AAYK5QAHCiMBCQomAosKhAKUAE8AiQrtAoYAkQWJCqIABAtqAQcLNAAHCy8BjAumAIQKfQEEC0oBBwulAwcL3AeICyQBhwv/AgQAwwIFAEwCBgCJAQ0AagASADEAkwApAAYA0wAHAJoGCwDmAYwAcQGJC3MDBAu/AocLzwAEALsABQC4AAUAsgIHAE0HCgD0AosADwOECzsChgBmBQUArwAGCk0ABgqdAAcKzgMHChUFBwo7BQcK0gUHClEHiQp0AoYA1QUFC2kDhQvAA4YA7wMMC10ADAv1AQ0LagEOC5cADwsoAA8LOwAQCy4AEQsZABILDgASC4YAEwsZABMLRQAUCxAAFAsTABQLQgAVCxcAFQsZAJYLKgALCpcDjQqZAYYA2wAFAEYCBgBuBgcAYwAHAKoHBwDCBwgAAwIIAAUDCQAXAAkA6wEMAGwCjgBdAIUAUwMFCyEAhgvWAYcLCwWGAP4EhwtaB4cK0QWEAOgDigDWAwgA+gIIACwDiQCOAwYLLwAHC1oABwuYAgcLPgMHC2QFBwvpBwgLwAGICzwDBABiAAQArAMGABsHBgAqBwYAMQcHAFUFCABbAwgAgQMIAJYDCQCmAQkAngIKAAcDCgB+AwoAjQMKAI4DCgCnAwsA0gAMAO4CDADzAg0AGgANAMkBDQDcARAAZAAQAG0AEgCtABIArwAICo4BCQqpAosKeAIJC6EBiQvtAYgKhQKKAIoDhgDCBoYKFACFC/sDhgChBAoAKACICgEDCQCTAIYL0ACMAIoCBQDRAAYAHgALADgAiwAxAYQAKQKKC1gBBgtEAAcLjgEHC8ABBwtdBgcLFQcIC4MBCAu6AQkLxgIKCxoBigvSAgUAVQIOABQAjgsUAIcATgaHCt0GBACWAAUALwEGAEcBhwqpAxAAMQAHCnQGkAsxAAgAwAAKAE4AjQBnAYcAEgOPAIYABgBmBgcATwAHAPABCQCKAAoAUAELAAwADACcAQwAuAGOADEBiAvrAQQKQwIFCuIABQpDAYcKwAMHAMwABwCfAQgAKgAKAFUAiwA0AoQAZgIEC5MBBQu5AQcLwgELC2UADAvBAI0LrgGHC4cHhwsyBQQAAwAFAPcABQCEAgcA6AIHALcEBwDJBAcAdQeSAJMAiACuAwQA+wOGAOcHBQunAoUKzQMFAB0BCQBDAA0A2QGPAFIABwtIAYkLRgGXAAgABgqHAIcKmASHC2gEhgAdBYcLBAeHCjoBBAs+AgcLXgEHCwAECAtSAQkLpQIKCygDiwv8AQcLMgMRCw4AEQstABILSwCUCxIAkgoEAIcLOQQEAB0ABgAUAgcAXAYHAHAGCQBeAQoAsQELAGEACwAtAgsA6QIMACEBDABPAQwAXAEMAF4CDQB0AA0A6QANANIBDgC1AA4A0QAOAOgADgDsAA4ALAEQACkAlABhAAcAPgEGChkBCAoaAQgK4AEICvMBCQrGAAoKjwAKCqkACgrTAAoKoQEKCj4CCwqTAAsKiwEMCksADAqXAQwKYAINCvQBjgr7AIcLjAaHC/UHhwCcBgUA9QEHAKgGCQApAgsACAIMAC0CjQD5AAYA9wUOAEQBDwA3AA8AUAAOC0QBDws3AI8LUACHCvAGCADcA4kLKQGECqMBjgDfAIsL6gAHAGMEDAD8AQ4AZgAOAOIAkAA5AAQKigAHCvQDBwoABYkKTAAHAOQGBQodAIwKfgKGAN8HhgA/BooLOAAGCzIBBwt0BAcLPAUIC4UAigvBAYsL8wMGCq4Ghwr2BwcL4waMCzYBBgCBAAQKEQAFChcABwrjAwsKfwELCrUBDArMAYwKFAIFC0kBiAsEAYUKXgOEABYCBgArA4cAcgKEC5ECBAAZAAUAPAAGAPgBBwBmAgcAgwQMAAAAmAsHAAcA4AQLAG0CiwC+AokAQQEICkYADAqrAI0KEAEKCukAiwpMAAQAewEHAHUFhgq6AQULQgAHC2gHiAsgAYYLawaGCq0GBAsVAAULWwAFCzoCBQuIAgUL7gIFCw0DBgs2AAYLcAAGC5IBBgvEBgcLOwEHC+0CBwtDBQcLbAcJC04ACQv8AQoLYwILC/4BCwvYAg0LJAAOCycAEAtTABELfACUCx4ABAB2AAYAEgEGAGkBBwBLAI0AuQEKC0IBCgvPAosLlwGTCncADAslAg4LQwCTCzwACwpFAAwKaQAMCnUADQrVAA4KDQAOCj4ADgqxAA4KpQEPChMAkgqNAAkASQOJCjUBBwpgAgcK0AMIC30ACAtxAQgLDAIJCpIACgrOAAoL5gEKClQCCwsNAAsLfQELC+ACCwv+AgsLTQMNC3IADQraAA0LJAEOCy8AjgqZAAwAtQKHC/cCBQA6AQYA3QAHAKMBCgCKAgsAjAEMAJwADQBxAQ4ATQGRAC8ABguUBgYLwwYHC2QBBwuMBwgLNgAIC90ACQvhAAkLZAEKC00ACgu+AQoL2wIMC5QBjQvrAYQLdwEECgYChwpwBAQAkQMEC5sBCwuDAowLcwAEC1AAhQssAAgKsQKJCl8DigBwAwQKEgAHCpEABwq8AQcK/gQICjEACAqQAQkKRwAJCvoACgrLAQwKoACQChgAiADbAQUA+AMFCysBhws7BAcAWgIIALMACgANA4wAfgAGAEkBigBvAIcASAcEC9sABwvhBokLVgAGAGAHBgBkBwYAbQcGAHAHCQC5AwkA2QMJAN8DCQDpAwwAMgMMAE4DDABPAwwAXQMMAF4DDABpAwwAawMMAG0DDABvAwwAcQMMAHQDDACHAwwAkwMMAJ4DDACrAw8AtgAPANsADwD/ABIAvwASANEAEgDTAJUAKQAFC0gBhwuWA4kADAMMAFIAjwAkAIUK8gMFADUDhgCXBoULAgKEALwDhgCcBAoAcAAFClcABwo5AQcKTwQKCkYCCwqFAQsKLQMMCoEBDQoeAQ4KfACSCmwABQBHAAcAfwUJAMACCgAFAQoAawILACMCCwBrAo8AnQAEABMCBQDHAQULLQEGCzsCDgsxAJILZgCECgsBBgCBAQcA2AcJAFEBigAFAoUL1gKFC2wBBAtMAAcLDgYJCzIBCQuuAQkLlwIKC6sCCwurAQsL8QIMC04BDAu6AQ4LAgEOC24BjwuDAAYASQcGAFcHBgBZBwYAZgcGAHQHCQCTAwkAngMJAKwDCQCvAwkAxgMJANQDCQDdAwkA7QMJAPIDDAAtAwwAMQMMAEgDDABLAwwAVwMMAGADDABnAwwAaAMMAIMDDACJAwwAnAMPAKsADwC1AA8A4AAPAOsADwD7AJIAuACJCzQABQAQAAYAVgAGAFsCBwAkAQcAMQIIAAEBCAB+AQkA0QIJAAoDCwBFAowA0gEEAOYBBQDrAYcKYQQEAEgABgAJAYcAFAWHC58ECgr5AIsK0QCECjECiQsHAgQLkAIECvgChwsLAwkKmgCMCuUBhwsBB4cLkACICv8AhQBtAgQKcAGHCoEChwtdBQcLKgIHC10CjQsKAIkA6gAFAC8DBgCYBoYA2wYFC0YDBQtJA4YLcQYHAMMHBwD4B4gA5wKFC/QDBgDFAIgAzQAGADoBhgs6AZALNQAGC/sABwttAQcLTQUHC9kFCAuaAI0LGQGFC1QBBgDEAQcAOAGKANsAigBNAgQATQEJALAADABhAY0AuwAJClwAkwpbAIYAVgQLAC8AiwvvAQYKDQIICiYDCQpsA4wKHAEICwUBCQuQAAkL0gEKC3IBDAvWAQ0LkACOC1wBiQuBAwgAXwMIAGADCABkAwgAdAMKAGIDCgBkAwoAaQMKAI8DCgCQAwoAsAMMANcCBgv4AAkLIgIKCxcCCwupAo0LhwAGACwBhwDrBYYA1QSLCr4DhQpSAowL+gCGAJUGhgs3AgcAhwAIAAcACAA+AAkA8wAKAJICCgC5AgsAyAGLAPQCCQCLAYoATwAGCmkGiAo0AwQKLgGHCuYGhguuAIcKIQWHAHcChgqKBoYLiwGKAEMDBwCWAQcAywEIAF4CiwDWAoYLaQKGANMDBgqFAQcKlQAJCo4AigpeAAULbgOFC8wDBgoIAAcKWQcIClsAiAv/AYUAZAKEC18BBAB0AQcA4gEIAJ4ACQBaAgkAZwIKAPUACgCmAgoA6AILAPgAiwAmAwUAVgOHAMcHhAseAYcLWAEHC7YBBwtzAgcL7AUICygACQs4AAkLJgEKCx4ACgsDAQsLyQOSC5QAhwDUBQULAwEHC54BBwtWA44LawCHCtIGBgBBA4YA5gOHChgABgDuAocAywYECvcBhwp9BgUKggAHCiIFCQpiAgoKzgILClkCCwozAwsKsgOMChgCCgqVAAsKGAGOClABhAviAocKmgcFAMMAhwCVBgcAzQcIANoCiwDuA5cLEQCFC2IDDgDPAQ4A1gGWAD0ABQDvAggACgELAEICBAqIAYcKPQYFCrEBCQp5AosKdQKHADUDBgDLAoYALQWFC3QABgBkA4QLyQGGAL8DBgrqAIoLxwAHAB0EBwqeBwgKqAILCjEDkwpYAAcKxgSKCoIBBQC2AwUA4gMGAF8BhgBkBIYAOQQHADsGBgoFAAsK+QAMCjkBEApCAJEKGgCUADsABQsPAgYLvQCHC1sDBQrDAwYK7QYLC2gACwsqAg8LPACPC30AhwAvAIkArAKGC3QAhgBGBoYACQMHAPwDCAr9AYgKGAOHAEYEhABeAYUL5wEEC1YABQubAgUL8QIGCzwBBgvHAYcLsgMHABQHDQADAQ0AZAEOAPIAkwByAIQKowOFAMcDBADZAQcAbwIIACgDCQBnAwkAfQMLACYACwCvAQwAcAAMANkADADzAAwAMgIMAJcCDACrAg0AjQANAMUADQDjAA0AlgENAOcBDgCcAA4AywAOAOAADgAAARIAOgCWAAAAigAeAQcKrwOLCmYChwotB5YLLQCEAB4DBADeAAcAHgGIAHUCBAtPAAcL7QYKC8IBCwtNAg0LTAENC+0BDgu3AA4LTgEOC2oBDgtwAQ4LeAEOC3sBEwtaABMLZwATC38AlAtaAAUAUQELAAECCwB5AwsAwQMMAM0BDQBPAA8AeQAECloABQohAgcK8gIJCroACgpIAAoKDgMLCkECCwpiAgwKYgEMCmoBjApTAo0AMgGIAJIABwBuBgkKSQELCv4AjQt8AAQA0QGHAH8GhAANAoULlwIKACsBEgBKAAkKuwALCvgDkQosAAcApQAHAJcDBAr6AYgKBQIFCicBhwqQBoULTgOGACgEBQt6AQcLegUHC4YFCAvRAQkLHgEKC7kACgsyAgoLewILCx8ACwuJAQwLyAENCzgBEgtBABILYACTC1kAhABUAgcK2wMJCrACCgoKAgsKFAOMCjYCBgBSAAcAigAHAAUCBwDNBgsA7gAEC4gChgrvBgcA0QQHCrwCBwqsAwgKAgIJCnQACQoXAgoKdgALCmsACwqUAAsKmgMMCv4ADAqlAY4K7gAEAMIDBgAgBwgAfgMMAMQCDADVAg4AwwEUAF4AFgA7AJYAPgAFC7EDBgt4BgYL+wYHC6cACAs4AwkLhwEKC3cBiwu5AAUA7wEHAEIDCQDdAosAegEECucChwv5BAYAtAQHC20GCAtgAYkL+QCLCiQBhQAvAoQLmAAJAPMBCgBVAQ8AkAATADEABwoDBQkK4wALCkUBCwqYAQ4KtACSCi8ABgAVAAYAyQYHAKQFiADgAIUL7gMHAKYFCQBhABEADwAFClEABwqSAAcKPgUICjUACAoxAggKtgIICvICCQpzAAkKfgMKCs4BCgotAwsK5gALCpECCwq7AgsK7AIMCncADArIAAwKGwGOChEBBQqYAYkK6wKHC68BhwtAAwYA2QKGALkDBADXAggANQIFC18BBwsIAYgLNQKGAJwHBQAHAgULKAAHC1YCBwtmBggLTgAJC6YACQuAAgkLrQIJCwUDCwvXAA0LQQAOC6wADgs9AZELBgAICzwACQtXAYsLAQOJC8cBhgCpBIwAFgMHC58HCAv9AggLBAOMC58CBwtsAAgL2wAIC4QBCQt/AgkLBwMLCxMBjAvQAYQL1AEHCh4ACApWAAgKOwEICrwCCQpAAgkKWgMLCjYBCwp4AwsKiAMMCmkBjQr4AAULDwAGCzgABwveBggL9AEJC9oCCwtLAQ0LlgCOCxoBBACSAQcAAgAIAEMBiADfAYoKRwMLAEQCjgDJAAUAOwCHAKACiQppApIAIgCGC14HBADBA4gAgAMGAAUFBQvNAAYLtgGJC8cChgqsAQcKDAIICqkACArqAAkK4AGKCoYClAAuAI0A3wGFCxYCBgDjB4YKcAYEAFUABwAlAgcKtQSKCn0CBACXAgUAXgAHC+sABwvDBQ8LRACSC3gABgu7AQkL7QAJCzsCCQu3AgoLiwALC8sCDAuhAY0LpQGEAA8DBACqAggAQQAJCicACgqmAAsKlgMMCnsCFAoKABYKGwAWCisAlgo0AAYACwCHALsAhAAKAgQANACHAJUCBAB/AYUACAKHCyICCwBXAY4AfwAEC0ICBwqdAAcLcAIHC5QDCAoXAQoLAAELC1cAiwu/AoYKXAIEABkBBQAmAAcAwgAHAJwCBwBlB4kAjQEHCrEDCwrJAosK6AKLCv4DCQB7AosALwIFC5sDBwvqAQwLKQINC2QADgt2AI8LSwCEAM8DhAo3AokKWwMHCjYHBws2BwgKdAKIC3QClAB0AIoL7gIOADMADgszAA8LBwCUCxQAhABaA4YAMwQEC5wDhQr6AogAFwKFAMABCgoQA40KvwCFCioBBwBiAocA3QUHCnkCBwqJAwcKjQMHCgIGCQr/AowKfAIECwkBBwsnA4cLtgMFC10ADAsLAZALGgCIAL8AiwotAYcKsgeHAAsBBAA/AQUAuwKKAKECBgBQAQcAXAAHALYACADFAQgAKAIJAMwACQAdAQoAYwALADgCCwC2AwwAXgAQABQAEABGABMANwAMCoQCkApaAAYAJwIHABwFBwpNAwcL4gMICqAAiQo+ARMLAQATCxoAlgsJAAcAfgUJANoAjQDeAAUAAAGKAEUABQvpAAULQAEGC4wABwtKAYgLJwEGALwHiAC4AwQAQQOJC6YChQvSAwQLiQMGC6UGiQtLA4oK3wKICkwAEQAnAJQAJAASAFEAkgtRAA4AYAERADUAEgCSABIAmAATAAsAlgA2AIcAegKKCkkDhABqAgQAUwEHAAMBEQBJAAQLEwGMC3gBhAv9AQcLEQGLC3kBBAD3Ag0AqQCJCiQDBgpgAIcKkgUECosChQohAQcAMwQICiMACQr/AQoK/wKTCnYABgCJAgYAngKIAOIBBQBQAQYAVQEGAN4BBgDjBogAggEFCyIDBwvlBwgLJQMOC14ADwtBABALBAAQC00AEAtQAJELBQAGAAsEBQunAAULgwMGC5oBiQsJA4YLqQYFAJwDhQDJA4QKwAKHAEkAhwsKAIcKNgQFCwsABgt1AAYL5QEHC20ECQtGAgkLUgILCxUACwsyAwwLFwKNC1YAhwCzBwQLCAEHCysECAvMAAgLgQGLC7kDBgCyBYcAQAUFAIwBhgD1AQQK0AKFCjIBBAChAwUAHwMIAC4ACADkAoUKrwEHC4YCBwvCBgsLvgGNC7IABwAUAQUK0AEGCuwABwq4AgcKkgMHClQEBwqoBQkKDwAJCjQCCgoOAAwKNQINCsEBDgo1AA8KDQAQCkAAkQopAAQAfAOFAAIDBgrnBgwKwgCRCmsAhwCeAAUKSAOKC2AChgCYBYoL+gAICxoDCQuQAQoLKgGOC+QAlwAZAAcLawSHC7wFhwDRBwkKggILCuwAjgrBAAQKRAAFCnoCBgqCAQcKGgMIChEBCQozAgoKaQAKCqsACwpeAIsKYgGIC9QChADeAQsLAAINC80AEwseABYLJACXCxMABwC1BYwAWwAGC74ABwsAA4cLkgQEAFoCCADTAAQKXwAHCqABiwo+AwcK2wINChQAjwoLAAYALASHAFAHBAANAAUANwIHANoFCQB8AAsACQIMAJUBhwv/A4cA7gOEAN8CigAsAwQAqgCHAEMBBguJAAkLSwAJC/0ACgvCAIoLvAEFADABBwB7BQUKYAMKCogCCwqfAo8KLgCHC5wEhQqgAwQAlACFAOYCCwraA4wKqgKFAAsChwvPBgcA2gISAJAAEwA9AAgKLAAJCnQDCgpEAgsKjwELCn4Djwp6AAUL+AIHCx4CCAuHAIgL8AGIANUDhQBvAAoAhAALAL8ACwBmAYsAzAEHCz8BBwtjAQcL+wIKC4UBkQsrAIYAegOGAIwFiAstAoUKBgKFALwBhwD7BocKPAcIAHsADwAGAJAABwAGAPkHCgsmAIsLEAOIAKQDBQCpA4cAZAAGAOMDBAs6AAULHgEGCz8BBwuSAQcL5gQHC28HCAtkAYwLmAEEC4UBCQu1AAkL/wAKCwgACgsdAAoLMAMLCzcBCwsxAgwLQwCNC7UAigD/AAUAigAECqYDiApiAgQAxQMKAF8DigCCAwoKJAOKCkADDAB3AggKYAAJCiQACgpfAgsKpwELCroBDAo1AQ4KxwAPCloAkQpuAIYAcgUEAIwCCABAARYABgAWABAACQoNAAkKjgEJCtcCCgpLAAoKuAAKCuYACgo0AgoKOQILCs0DDApGAAwKvQANCjkAjQoBAQYAgQOGADUFBAC0AoUAQQGFC3UBhwCaAwUAawKFALoCiQp3AgUKWQGHCvgDCQC9AwkA+gMMADwDDABMAwwAgQMMAIUDDACvAw8AtAASAMUAEgDIABIA1QASANYAkgDiAAUAlQOGAHsGhwBMBIYAlQSGAIoHBQD7AAUAvAMIAAwBCQDWAJIAjgCFCqECiQpSAwQKHwGFCvoDhAugAgUAWgEFAMcCCACGAQsL8AKLC3UDBQoiAAoK1AIMCrwBDQpiARIKIAAXChgAFwofAJgKBQAEC8YChgteAoYA6AKGCn4BhQuRAAQKSQEHC3QDjAt8AAQL0wEFC5UBhgsgAgkKTgOKCjsDhQBwAgkLdAEPCwIAEwsKAJMLEgAEC4MBhwsIBQUADwMHAM4HhwD/B4QKigOICm4BhwsmAgQKewAECokCBQpdAgcK5QWICiQAhgBlBIQAUgKFCv8ChwvLBIgL0wEEC0AChwvvBAQADAEHAP4Fhwv+BQQKEQEFCpICBQuXAwUK4wOGC4kGhQAzAoYKSACHCkEFBAtSAAULTQEFC4gDBgvPAAcLRQEHC74GCAtlAAoLCgOLC9wABQAlAAYAJwAGAMMBBwDaAAcAmwIHAI4EBwCXBggAlgIQAAIAhQpNAoYANAWFC4cDhgD8AQUKdQAGCgICBgodAgcKjAQHCpwFCArcAAgKiAIKCrACCwowAowLkwAGCysChwvlAYUKrgIHAMUBBwB7AgcAHAMIAEsBCQBKAQkAYQMKAHcACgDrAAsAbwALAIEACwDwAAwAHwAMAEIADADeAAwADQEMAFcCDACsAgwAsQIMALMCjgBZAYcAKgcEC8ECBwtnAooL+wCIC1kBiQAPAgYAYgAHAL4ChwDfAwsAQAIOAEoABwrEAAoK/QILClsBCwooAgsKFgMMCgcBDQr2AA0KDgENCosBDgqwAA4KvgAOCo4BDgqcAQ8KIAAPCj8AEApYAJMKaQCGC1oADQBUAI0AegAGACUABwArAQcAggYIAMMACAA8AQkAsgAJABQBCQBTAQkAGAIKAGYACgBqAQoAEQMLADcACwCVAAsABQMNAKABDQCjAQ4AJgAOACkAjgDSAAUKfQGHCgAHBwstAwwL8QGNCzgABwpoAooKnQGFAIUCBgt9AIcL/QSEACIBBgBGAAcADAUKAPoCiwAgAQYKeAAHCqQEBwquBggKHgEJCpsCCwpQAosK2gKHC/gGBwAjBYcLIwWGAKMHhwp6BAcAgwAHAKYBCADSAIwAPQIECmABhwqvAosAHQOPACYADgCzAA8AlwCWAAsABwDoAQQKwAAFCjEABgrIAAYKJQGGCqAGhACoA4cLvwIGC6AABwtSBAkLAgMKC2oCCwtwAIwLnQEFAMUBhgC5AYcAUwKECooChAqTAAYA3wMGAJ4EDAsPAZELbQCFCqYDjAvdAIQAjQIHAPkBhwALAoYAhwOHC98BBwswAQkLhgIJC14DCgsGAQsLuAIMC9AADwtPAJMLbACSAFAAhwvVA44AsAGEADoBiQuYAAcAWAUIAOgACABpAQoAqgKKAOYChwsyBgkAFgIEC7IBCwuXAgwL0gANC6YADQs2AQ4LdQGTCysABwtDBIcL5QYGCyYChwuMAokAGwCOAAwABAp9AgULKQIHC/4Cigs4AwcL4QIICyoBiAvEAQcA4AKLAAgBhgB5BoULJAGKC4cABgBMA4YAXQSHAH8ACQpjA4oKRQMGAKAEhgC4BIYADgWIAGwBBgCHBQcANgULAH0ABgqqAAcLiQEICosBCArnAQoLWwILC84AjQqTAIkL7AIEC5ADiQvoAAQKFwKICmoCiQAYAwcLtQeIC8wChwtiAAUAjQMJAFEDigAlAwQAdgKEALsCBQvdAg4LZwCWChcADAueABILCAATCz4AFAsGABYLBAAXCwIAlwsJAIQAyAOECgoDhAouAAUKKwMGCo8GBgqyBocK8AcGAKYFBwqyBQkKlwGLCg8ABwDOAAcAjQEHAG0CBwCAAggAfAAIAGsCCQAxAQkAgwIKAAgBCgB0AgsAKAAMAF0BDQCGAA0AJwEOAJsADwB4ABIAaQAGCiIABwpBBAgKxAIICtECCQprAZQKYgAEAAYBBQCBAocAVgGJC0gABABjAAYA+gAGAFoBCAB/AIoAUQCEAJMDBQBLAAkABQIKANYBDACbAI0A4ACECs4BCwtYAgsLngKNC/UAjgBTAAUKSQAGChcAhgpSAQYABwSLC5sDBwukAAcLIwYJC2sAjAvhAIYAvgWFALoDBgAwAQgAogEKAFkBCwBVAYsAowIJAJoBiwCpAQQLGwAFC+QBBQv+AQYLsgEHC+gDBwtKBAgLAgCIC8gAhgDeAowLAQEHCtUCCAryAYsKDAGGAB4HhwAGB4cKBQOEC8wBBAukA4ULewOGAA4AhApHAgcKtgUIC3ECiwqTAgUAcQAGAPMABgCsBgcASQcLAKEAEAAlABEAYwCFCtwAhgtMAAULzQGHC4UHjABFAAgLXACJC90AiwojA4QKIAIEABIBhgCaA4QAHQIFAHMCBgq1AQYKNAILCrUAjQq3AIcKqAQHAKYAhAv7AoUL/QCGAFEDCQtJAAoLbgAOC7kAkQt3AAUL1AAMCyMAjQt+AYUAzQKJADABiABYAoUAjgIGABEBCgC8AA0AeQGSAE0ABAoWAwUKEQGGCooBhAAfAocAmgELAGIACwAMAo0AVwCEAK0DhwuXBAQA+gAHAEwGCwC6AAwAhQAGCn8ABwrnBQgKZQIMCu8BDApKAgwKlAIMCpwCDgqBAQ8KdgARChQAkgpiAAYA+QaFCzADhgA7BQcAwQMHAD0EBwC/BggAzgEGCuYAhwu/BgkAfAKHCqIHhAAMAwULZQMFC8gDBgtaBggL3gKICxADBAseAgYLtAYGC78GBws6BAcLCQYICzgACAt2AAgLnAEICzQCCQt4AwkLjAMKCzIACgunAQsLrQILC7kCCwulAwwLKwENC34ADQuIAA0LqgCNC74AhgviAAQL6AAJC8oACgvaAYwLsQGJC/QBBQARAogKRACECo4CBAqcAAcK5gMHChUEBwpEBwkKMAAJCrQCCwqjAYsKWgIHAPwECADaAQkAjAIGC2wABwvrAwcLnQSIC1cBBwvwBAcLjgYLC7EDDAtVAQwL1wGMCzkChguwBgUAtAMMANQBEwBgAJQAGAAEC4UABwvHAgcLEgUHCzEGhwuJBwYA8QKMAJECiwCtAwYLYwAHCxAHkQs5AAYLPgIHC6wBBwviBAoLnQILC+UBCwtIAwwLLAGOC/oABAAUAgUAwgKHAJYCBQBFAwYAcwaLANkDBwBFBwkKxQAKCiwBDArZAQ0KWgCNCpUBiQv8AAYLQwGHCxwGBABKAQQAXwMHAKUDBwDcBwgAJAEHC80BCAsHA4oLswGECl4CBAuPAgcLUgMRC0sAkguJAIcA/wIHCroHiAqkAoQAgQKHCxcGhgDRBIkA8gARAHIABAppAYUKOwGJAHMDhArNAYoAEgGGANgHhgACBwQAvwKHAM8ADAAdAYQK2AGEADsCBQBpAwUAwAMIADcDCQBxA4gLQQIHAGkCCgDyAQsA9QEMABAAjACWAIoK6wKEAK8BhQqbAAsAGwELADcCBwqjAAgKPwEJCpIBCgoYAAoKqQILCsgADAr9AAwKmgGOCtsABAudAQULpQIIC7ABjAsYAQkAkQEFCtsBBwr0BgsKKQELCi4CDgpCAZMKTAAGAA0DCQCGAAoAAgAKABsACgBNAQsA0gKPAAEABQAhAAYA1gGLAKgBhwDWBwwADwOHCqQHiAASAYcAWgeEABoDhwA4BwUKsAOGCukGBgAvAAcAWgAHAJgCBwA+AwcAZAUHAOkHCADAAYgAPAOECpAAhgCvBAQLiwGLC/oChwvgBQkAoQGJAO0BCQuuAAoLpAALC7gBCwtJA48LYgCGC6oBiwvqA4YAJwGGADADBgr3AIkKKwKFAPsDBABsAgUL3AEKChgBigodA4sA0AEFC0wABgvKAQYL8QEHC/wCBwtkAwkLkgIKC1ICCwutAAsLNgIMCxQADAtSAY0LyACGANAABAsOAgcLBQSHCx4EhAt8AgYL6QAHC5QCBwtkBBELHwATCxYAlwsOAAoAugGFCqwBCgCiA4wACgMGAEQABwDAAQcAXQYHAOkGBwAVBwgAugEIAAQCCQDGAgoAGgEKANICBwq1BooKIgKGAGgECwBMAwwAaACMAHECBAuwAYcLOAOKCr0AhQATA4UKYwAECxcBBwstAYkLagEIAOsBBAqNAYgKKwIEC7IAhQuPAYYAxwKQAAkABACTAQUAuQEHAMIBCgBIAwsAZQAMAMEAjQCuAYcL3gQMCo4BFAonABUKCwCWCikABArlAQcKYQGHCvMFBgpuAQcKaAUHCkEGhwt4BwcAjAEKAKAAhwuMAYkKGgGGC5wGBAqdAAUK1wEGC8oACgvAAQsL0AAMC2gBEQt1ABELdgASCxsAlAtDAIUApwKJAEYBiAp0AAcLaAMKCwQCiwunAIQL4AAFCyICBwsjAAgLCwAICwwACQs7AQkLFQIKCyIDCwumAAwLDQKOC/MABwBoBIcLgAcFC/EACAvyAAkLwwEKC5sCCwtWAowLrQEGAOECBQqgAAcKawEHCk0CCgqqAI0KNwCHAAQHjgv+AAQAPgIHAF4BBwAABAgAUgEJAKUCigAoA4YASASJCwQCBwCVAQoA6wEECmwABAtuAYsK8gELC1EBjgsvAYYLyAYHADkEjAtsAQcK7QOMCmECBwCMBgQKfwOFCgQDhwD1BwYAtwQLC5QDjgujAQ4LjACUCykABgtLAYgLbwIJALADCQDJAwkA/gMMAJEDDACoAw8AsQAPAMEABAqeA4UK1wMFAGIBhwv6AQgAVgIJAJgCigC5AQQLgAKFCwECiQApAYQKGgIGCiYBBwrzBIgKcAIHAOwGBwtgBwgLIQELCy0ADAsWAYwLGQKHCi0FigDvAo0AJQCGACQHhAr1AoQLigEGAAEBhwDyBQQARgIJAL8AhwuLBwcLPgIHC7cGiQuRAIQLkgIKABYDhAtxAQkLDQMKC5AACwuBAQ0LoQANC+QADQsMAZQLawAIANUBCgAvAIgLdgEGADIBBwB0BAcAPAUIAIUAigDBAYsA8wMHClMHiwp8AAQLWAEGC/IBiwtDAYkAKwGEAEUDhQuKAwUASQEIAAQBigAKAIYAKAUEAJECkgCeAIcApwSYAAcABgCTBwgAzgOKAOQDhwCBBgsLfgCLCx8BjwAIAA4LlQAOC48Bjws5AAUAQgAHAGgHiAAgAQcArwAKAO4BBQqWAAgKWwIJClECCQp6AgoKrQALCs4BCwoDAg0K2AANCiABjgqQAYYAawaICxUABAAVAAUAWwAFAIgCBQDuAgUADQMGADYABgBwAAYAkgEGAMQGBwA7AQcA7QIHAJMFBwBsBwkATgAJAPwBCgBjAgoAKwMLAP4BCwDYAg0AJAAOACcAEABTABEAfACUAB4ABACcAogAOgIKAEIBCgDPAosAlwGHC2UFiAvBAAwKbACNCiMBhAtoAogLtAIIAH0ACABxAQgADAIKAOYBCwANAAsAfQELAOACCwD+AgsATQMNAHIADQAkAY4ALwCGAN8EBgCUBgYAwwYHAGQBCAA2AAgA3QAJAOEACQBkAQoATQAKAL4BCgDbAgwAlAGNAOsBhwrxBgQLMQEECu0BkAo3AAQAtwMGABEHBgA5BwgATgMIAGIDCACDAwoAgAMMALYCjgDUAQUL1gAHC1sCCAtjAgkLrgIKC1gACwvLAQsL8AEMC88BDAtOAg0LAACOC9YAhACbAQQAUACFACwAjAtKAI8AHwAHAJ0CBgo4AgcKDAcICmoBCAqaAQgKPgMJCgICCwqJAo4KnQAHAKEChgunBoQKcQKGABcFBQArAYcAOwSKAMACBgATAQcAmAEGCp4ABwqBAAcKtQAIChQBCAp5AQoKCwILCjADDArHAQ0KLwGOCocABADbAAcAbwEHALEGBwDhBgkAVgAJABkCCgClAAwA2wCMADECCADYAAQKAQAEC+ECBgs9AQcKdwQHCrcFCQrPAAkKhgEJCtMBCgtiAAsLJgELCkQDDAs8AAwLtQENC0AADQt8AY4LrgEGC94GCAsIAgkLWQEJC5MBjgteAQULLwAKC/IAigtDAgULiwAHC5AEigsbAocAJwUECicBBArTAgUKfwMHCgcECArHAAgKVAEJCpkACQrXAAoKFQAKCjsACgpQAAoK4AAKCkYDCwrlAAsKjAIMCsAADQqSAI4KWwCMAKwBiQozAIUAAgIFCjUBjArTAAYA8gMFCn0ACApNAIoKDwAEADcABQAtAQYAOwKOADEAkgBmAIgLcgEEC2sABwtlAggLZgEIC7cBCAv4AQkL9QEKC38BiwvdAYQL5QCFAGwBhQq3AQQLhwOHCxgHCwB7AYwKTAAEAEwABADLAwcADgYJADIBCQCuAQkAlwIKAKsCCgCZAwsAqwELAPECDABOAQwAugEOAAIBDgBuAY8AgwCJADQABAsvAAYLdQEHC8QBBwsfAgcLsgYHC0AHCQsGAAsLAQGLC4cBBAoIAAcKgAQHCoEEBwqzBgkKdgEKCt4BiwqIAgQLEQOFC3ABhwpLBIcLXAMFC9QDhgvaBoYA6gQGACIEBgBPBQcLGAIHCzMFiAuPAAQAkAKHAAsDiApXAAULEwAGCxUCkgt+AAcAkACKCrYBBQuLAQULtwOGC/AGhwBdBQcAKgIHAF0CjQAKAAQKRQAFCnoACQqQAooK0AEFClEDhgphBgUARgMFAEkDhgBxBoUA9AOLCvMBBwrcAQcKOAaKClcABgD7AAcAbQEHAE0FBwDZBQgAmgCNABkBhAu5AYQLtwIHC/EBCQuDAZMLUQCFAFQBDgobAY4LGwGGACoDhwtmB4sA7wEFCxwBBgsxAAYLXgEHCwEABwt5AQcLnQYICxIACAumAgkLoQAJC0kCCQufAgkLRwMLC5ADjQurAQUKWwMHCogECAprAAkKIwEJCrcBCgqXAgsKYQKMCsUACAAFAQkAkAAJANIBCgByAQwA1gENAJAAjgBcAYkAgQMGAPgACQAiAgoAFwILAKkCjQCHAAQAZgGHANgFhgA3AogAvQEECnUABgp0AQcKcQeOCkMBBArSAosK1wEGALkChgDkAwcL1wcJC2UACQvCAQoLQgAKC0oDCwsYAowLSwKEAEEChgA4BQkKBQAMCtgADAomAQwKKgEMCpABDAoGAg0K5QCPCosABgCuAIoAlQOGCu4GBQoMAAcKdwEJClgACQq2AQsLPgCLCg4BhgvmBgYLAAAHC1QABwowAwcK2QQJChsBCQoIAgoK1QAKCjMBCgrPAQoKnwIKCuoCCwqRAQsKGgMLC38DDAoFAhELCwASCmsAkwpzAAUAbgOFAMwDBguBBgcLAAEHC2wFigvzAQQKAgGICn8CBAsWAAULCgAGChYABwtQAwcKhwMHCqsHCAthAIoKQQIFCqkCiAoOA4UL4QGEAF8BBAqYAgUKJAOLCvUDBguGAAcLtQEHC78DCQslAA4LHQEOC3MBkAs8AAcL5gEIC5sACwtdAIwLpACEAB4BBwC2AQcAcwIHAOwFCAAoAAkAOAAJACYBCgAeAAsAyQMLAOMDkgCUAAULTwKHC1EBhgCeB4UKIACKC/QBBQt8AQULigKICzYBBAtsAQcLhAQHC6MEiQuZAQQA4gKGC+IBBAsNAwYL5wEHC54DCAsHAYsL9AGHC6IBBgD/BwoAyQMECiEBBwp1AgcKogYHCq8G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BgsTAAcLhQWLC6wBhQB1AYQKLwIHC2AACAuRAYkLgAMHAB8DBwC0BwUK+QOKCv8BhwABBwcLqQcHC60HCAu+AogL7gIIC5YACAvhAowLbgGEAEIBhQrFAggLIAMJC5QACQtoAwkLegMLCzUBCwvpAw0LCwGNC0MBhgrRBgcAIgGICs4ABwBzBpEAWQCLAAIAhACgAgYARAcIAIkDCgBMAwoATgMKAFoDDAC7AgwA6gKMAAQDhwuoAYULIwKFAOECBQvqAQYLZwIGC2wChwurAgYA6gKGAEwGhAoIAwkLgQGVCxEAhQCRAIcK+AQHAHQDjAB8AAQAgwGHAAgFBQuFAIgKlgGIC7sABgCnAggLCACKCwAAhwAmAocLHgOIC60CBws+BJELLgAICq8ACgqoAIoKPQKHABkFBABAAocA7wQGAK4ChgAbBoYAXwIFAJcDhgCJBpQAJQAICwYDCgueAowLMwCFChADiwpyAwQAUgAFAE0BBQCIAwYAzwAHAEUBBwC+BggAZQAKAAoDiwDcAIcLcwGEAL4DhQCHAwQLfwAFC14BBgtkAQgLqgEJCzwCCgv3AIsLOAGMAJMABgs7AAcLdQMJC1sCjQuNAQoAbwEJCg4ACQq5AYsKCQALCsYDDAofAQ0KVgENCpIBDwpuAI8KowCGALIChADBAgkAiwILAMsDDQARAQcKlAUHCmgGBwpLBwkKqQAJCrYACQpvAQkK3gEJCvoBCQonAgkKLQIJCogCCQq5AgkKwQIJCtUCCQoTAwkKGgMKCsYACgrWAAoKCwEKChMBCgrIAQoKJwIKCjECCgplAgoKcwIKCpwCCgqjAgoKswIKCrcCCgrDAgoKywILCrcACwrJAAsKBgELCmABCwq3AQsK7QELCjwCCwpPAgsKYAILCmMCCwqGAgsKogILCscCCwrvAgsK+QILCggDCwoRAwsKUgMLClUDCwpeAwsKYQMLCmQDCwprAwsKggMLCoYDCwqHAwsKjgMLCqQDCwquAwsKvQMLCscDCwrMAwwKlAAMCsMADArcAAwK7QAMCj4BDApTAQwKiQEMCr0BDArCAQwK2gEMCvkBDAr9AQwKFQIMCk8CDApSAgwKVQIMCm0CDAp5AgwKggINCjsADQo8AA0KkQANCu8ADQr6AA0KSQENClgBDQptAQ0KdAENCoMBDQqTAQ0KngENCsgBDQrWAQ0K3gENCuMBDQrpAQ4KNwAOCjkADgpRAA4KWgAOCpQADgrvAA4KCgEOCkEBDgpGAQ4KRwEOCkoBDgpbAQ4KYwEOCpEBDgqUAQ4KmwEOCp4BDgqgAQ4KpAEPCj0ADwpKAA8KVwAPClgADwpeAA8KYAAPCnQADwqVAA8KmgAQCjIAEAo/ABAKSQARCgIAEQpCABEKXAARCmcAEQpwABEKeAASCjIAEgo2ABIKUgASClYAEgpaABIKbwASCnMAEgqcABMKKAATCk8AFApOAJUKFgAHAHcDBQqhAIcKRwOOC2IAhgBaAIoLZAGHC7kBBgtvAAcLBAAIC6MACAsIA4oLNgKGAIwDhgDtBAcALQMMAPEBjQA4AIYA0wSHAK0BhwvKB4oAiAMGAH0ABwD9BIkABAOXAAwABABJAwUAggGFC4IBBQspAYcLDgQGAFwDBgAtBIcLNQGIALIDhwoWB40LogGIC2sBCgAAA4sAEwMWCx4AlgshAAYAoAAHAFIECQACAwsAcACMAJ0BCwvYAIsLVAGICosAhwtuBYcLKAOECxgBDAAPAREAbQAHCoMCiArsAIwLNgAEC6UBhQskAgsAzwIMACQAjQBRAQcARQIJAIQCiQC7AgsL/wENC4oBDgsqAQ4LPgGSC2cABwAwAQkAhgIJAF4DCwC4AgwA0AAPAE8AkwBsAAQAdwIHAGYEhwAABocL9wUIAHADCgBlA4oAkQMHAOkFBQo2AAYL/gAJC20AigtnAIcA1QOFC9kChAroAoQAsgGGACYCBwCiAwoA3AENAMQBEwBoAAYLXgYKCpIBkgo3AAUAKQKKADgDiADEAQgAlwCJCnAChAo8AoQABAOFC58ChQAkAYoAhwCEC3kDjAvPAAkA+AEGCisABwomAAgK+ACKCgECBgBBBIcLdgcEC3MChQsHA4cADwOFCv4ChQprAQcAgwGHC4MBBwCJAQoAWwILAM4ABwvKAAsLagELC7QDjAuEAQYL+wEHC8MBCAuFAQwL6gENCxAADQvXAA0LXwESC4QAkwt9AAQAkAMJAOgAhwtJAwYKAgGMCpkBBQr5AJQKUgCICzYCBgDRA4cLvgQHALUHiADMAocAYgCFAN0CBQuQA4YLnwYFCokBBgp6AQcKvQcJCiAACQpPAgoKrQIKCuUCjgp+AYUKFAMKABMACwCPAwcKsAeNCv0BBQCcAgUL7AAGCzwCCAvsAQsLagKQCzgAhwv9BgQAaAEFAHsCBQC8AgUKOgAFCqsABQqrAgYKIwEGCjYCBwpyBgsKCwIMChEBDAovAQ8KJwCPCm8AhQCFA4YKTQIFC74AiAs+AYwAkAIHANYCmAAJAAQKlQOFCu0Dhwo+BoYL6wEECpcDhQuyAYkASAAGAPUEBgAeBoYAVQYJAM8BCgBTAgQK/wAFCi4BBgqEAAcKgAAHChsBBwoTBQoKNAAKCgICCwqdAw0KXACOCjUBhwCuBYYABwULAFgCDQD1AIkKrQCIAN0DBwCkAAcAIwYJAGsAjADhAAYAJQSNCroBBAAbAAUA5AEFAP4BBgCyAQcA6AMHAEoEiAACAAcLVQAHC/cACAtJAgoLowCKCzwBCwtnAI4LAACGAGcEBADMAYYAVAOGCtIABACkA4UAewMGAEwCkwtTAAgAcQIEChwBhgrfAIYATAAIAFwAiQDdAAQLfAAKC8kBCwt5AAsLqQALC6YBCwtmAwwL1gANC4UBDgu7AI8LTQAJC2oCigviAQQK2gAHCg4CjwqJAA0ACQAOAGgADgA3AQQKDgEFCsAABgpMAYcKKgWMCpUChwupBAYLawAHC34CBwtgBokLjAGEAPsCBABuAgULcgGGC9wGhQD9AIcAIgIJAEkACgBuAA4AuQARAHcAhQvMAAcAcAIHAJQDCgAAAYsAVwAHCnsBCArhAYkKeQEFANQADAAjAA0AfgEFC8oDhguqBgkA6gIFCusDhgqVAAoAlgALAFEDDQBKAQgKBgEJCnMCCwrWAAsKlAELCskBCwoMAwsKkQMNCpEBjgrIAIYAugWHCwMABgATBQQLIwAFC3kABQvjAQULrQIGC+kBBwu0BIgLigGHCuYCBAqOAIgKMAEEC5kDhQvvA4YA7gUGAM0EhwCXBIUAMAMMAJ8ABArXAQQLyAIFCjMABgpaAgcKnQMICuQBigrDAIYLXQYFAGUDBQDIAwYAWgYIAN4CiAAQAwQAHgIGALQGBgC/BgcAOgQHAAkGCAA4AAgAdgAIAJwBCAA0AgkAeAMJAIwDCgAyAAoApwELAK0CCwC5AgsApQMMACsBDQB+AA0AiAANAKoADQC+AIgKsAKECrkCBADoAAkAygAKANoBjACxAYgA1AAGAGwABwDrAwcAnQQIAG8AiABXAQUK3QCHC+cEhQvlAYYAsAaOANgABQCDAgYABAIECx0BBQs9AQYLLQEHCwcACAuZAAoL/gILC9QBDAvTAY0LjwAEAIUABwDHAgcAEgWHADEGhgCKAocLAAIGAGMABwAQB5EAOQAGAPYABgA+AgcArAEJABkDCgCdAgsA5QELAEgDDAAsAQ4A+gCRADcABAqEAAUKRQCHCtoEiAD/AwcALgGECm8AhwBPB4QA2AIJAPwAhAr/AgYAzQEHADYGBwqIBQcK1QcICoMACArSAQkKoAINCvwAlApnAAYAQwGHABwGBwDNAYgABwMGCiwAiApwAYsArACEANABBAo6AoUKeACJCw0BBgrjAIcKNQYGC7cGBgvHBgcL4AcHC+QHCAtFA4kLVAMHANcCkgBJAIQA/wOHC1QDhwr5BYgAQQKKCzgChgANBAgLQwCKC6MBBACdAQUApQIIALABjAAYAQoAWAIGCoMGBwvHAwcK9AeNCwsABgr/AYwKhAAGAB8DBQo4AgYKigCHCg0FCACfAAQKNQKICjsDBwCGAgcAwgYLAL4BjQCyAAQKmgOFCv8DhwsLAIQAiwELAJEAhwrqAwkArgAKAKQACwC4AQsAAgILAEkDDwBiAJUAFACGAKoBCgBgAosA6gMHC0ABCAszAAwL4QEMCzoClAtqAAkA0QMJANcDhAu9AYoA+gCLAGQABgC+B4gKkgGFC+8ABArMAo0KHwAFANwBBwtTAAcLxgcIC4IAiwvQAggKswKICtsCBQt7AAYLEgIHC1wBhwuLBQUATAAGAMoBBgDxAQcAZAMJAJICCgBSAgsArQALADYCDAAUAAwAUgGNAMgACQuLAAoLjwELC9UBDAt6Ao0L3wAJCkgDigojA4UKTwMLC98AjAuoAIQL0gAIAL8BCQo1AAkKDAEJCoUDCgoGAgoKPQMLCrwADQpKAA4KLgAPChEADwohABEKKAASCiQAEwoUABYKAQCYCgIABAAOAgcABQSHAB4EEws7AJYLAgAEAHwCBgBTBwYAgAcJAOcDDAAnAwwAOQMPALMADwC+ABIAtgCIChQCBgCjBgcAlAIHAGQEEQAfABMAFgCXAA4AhwqpAoQLrgGMCqUCBAqsAogKgAGEC/QChQvVAAcAvAAHCm4ACAoiAQgKTwIJCn4BCQqJAgsKRwALCpsACwo5AQwKBQANCkUBjgofAQcKaAEHCqkBCQpCAAkKFgGKCoQCjgukAAQAFwEHAC0BiQBqAYYLSgKHAM8GBACyAIUAjwEECoQDhQpdAwUK/gAHCtkDiApJAIULbAAHCqcHiAqrAoUL2wAEC8EABQuUAwcLbAEKC44BCgvWAgsLPQELC3ICDAuOAAwLIAEMC6YCDQs5AQ8LcQASC3IAFQseAJYLNQAGC/EABwuLAwgLQAMJC1YBCgvZAgsLHAELC70BCwuLAgsLXwMNC44BkgtjAIQAaAOGAD8DhgCcBgYAygAGAO4DCQBAAwoAfAILANAADABoAREAdgASABsAFABDAIkL3gKECtUCBwvhA4oLmgKGAKIHhgrEAAcAaAMKAAQCiwCnAIUKPwMECzICCQv+AIsLbwOJADkBBADgAIQLEgMLABgADACqAIgK0wIFACICBwAjAAgACwAIAAwACQA7AQkAFQIKACIDCwCmAAwADQKOAPMABwCRBw0KUAANCrUBkQpKAAUA8QAIAPIACQDDAQoAmwILAFYCjACtAZYALgAGAPkEiQA+AwUKUAMGCkIAiAr8AgYAOQOGAOEDBADuAwoARwENAA8BBAokAAcKawWLCvMChgD/A4cALAYEAG4BiQAEAoQKdwMGAMgGhwBjBwYL2AAHC4UDBws/BYgL7QEGCqUAigqEAQcLVQGLC9sABArPAocKmwCGAI8HhAA6AwYASwEGAEUGCABvAgsAiwCLAKsAhwvGBgoLcwALC6QBDAuaAA0LlAEOC1oBDws2AI8LcAAHACABBAphAQYKkgAGCv0GBwreAwcKRAUJCpkCCQqCAwsKfQOOCtQABgCUA4YAOAYHAGAHBAotAIcK6QQFC/MDiAu9AosLVAIECzYABQuaAgcLDwQHC2oECQvDAIoLLgGGAL8FhgAiBoQAigGMCkEAiAowA4cAiwcHAD4ChwC3BoYL0wGEAJICCQANAwoAkAALAIEBDQChAA0A5AANAAwBFABrAIYLhQaIAHYBhwDfAgQAWAEGAPIBiwBDAQcASgIHACcEBgovAoYKmwaJAJsAhQCKAwcLegAJCwMBCgtUAAsL1gEMCx0CjQt7AYYAcwQKAGwAiwB0AIYKyAGFCp0DBQtSAAULgwAHC9sGCAsfAAkLqAAJC/wCiwtlA4YLXQIFCxYBiQtEAAQLowAFC8kABQszAQULNgEGC08BBwscAYgLpQCHC3wGBgshAIcL3AQEAGgCiAvjAQgAWQMIAIYDCACOAwoAbwMMANYCBAvHAIsLIgCIALQCBgrBAAcK8AAHCpIGCgozAAoKgAILCpoBDQpSAA4K9wAOCksBjgp5AQYANwOGANcDiwqbAYQAMQGICnkCigvLAIYAqQIGC0YBBwulAokLqQEFANYABwBbAggAYwIJAK4CCgBYAAsAywELAPABDADPAQwATgKNAAAAiADsA44AFwCGAKcGkwsIAJELOACHAKMFBArtAIcKAgIGAMoCkQATAAULZgEHC9kBBwugBAoLlgINC9QADQswAQ0LTQGRC2IABADhAgoAYgALACYBDAA8AAwAtQENAEAADQB8AY4ArgEGCogBBwpBAIcK4wcGAN4GCAAIAgkAWQEJAJMBjgBeAQUALwAKAPIAigBDAgUAiwAHAJAEigAbAoYAswUNAIQBjQuEAYYA/QAHCuwEhwr+BgoA/AAJCt4AiwqEA4wA6QKFC7IDBABrAAcAZQIIALcBCAD4AQkA9QEKAH8BiwDdAYcLzQWEAGcDBwubAQcLTgIIC3cCCQtDAQoLYwELC+sBDAuPAAwLkgENC0kADguYAQ8LawCSC0cAhADlAIQAhwOMAEcAhQAlAgQALwAGAHUBBwDEAQcAHwIHACQHBwBABwkABgALAAEBiwCHAQcLuwUIC0gBCgsgAgsLuwMNC0ABkQtTAAUA1AOGANoGiABhAwUAwQKJAF4CBwChAAgKyQCICl0CjwsjAAULQwMGC+MBjArgAAcAGAIHADMFiACPAIYAbAUFANQCCgAxAQsAlwAMACEADAB5AAwAfQERAAMAEQAbABEATgASABIAEwA2AJUABQAECgsChQp+AgUAEwCGABUCBQCLAQUAtwOGAPAGhwB0B4QATgMKAEoACwCXAgwA0gANAKYADQA2AQ4AdQESAF8AEwArAAYK8gAHCuMABwotBggKaAAJCnEACQrcAAkKqwEKCu8ACwpDAgsK/wMNCgQADQrMAA0KPAGUClYACQvMAgsLbAANC3sADgv8ABMLJgAVCwMAlwsLAAgAdAEJAHoAigCvAIQLpQIHC14FiAscAocKXQOEALcCBwDxAQkAgwGTAFEAiACpA4YAzgIHADAFiAruAYQLSwEGAC0GhQvrAgUAHAEGADEABgBeAQcAAQAHAHkBBwCdBggAEgAIAKYCCQChAAkASQIJAJ8CCQBHAwsAkAONAKsBBwoaBQgK+QEJCuIBCgp+AAsK4QAMClsBDArBAQ0KEwAOCtoAjgqzAQoK/AIMCngADQonAJEKfwAEAFUChQoMAYYARgQEAPADhgC1B4QAKwOLAIwDhwC/BYULRgEECoABhwr+AwcAjwcIAEQBDAAqAAQLswIHC48HCAtEAQkLIwAKC6gCCwtsAQwLKgANC2UBkgsQAIcA3gcHANcHCQBlAAkAwgEKAEIACgBKAwsAGAIMAEsCBgsgAAcLgQEHC/UCBwt8BwgLJQAIC14ACAvHAgkLHQIKC6IACgsbAwsL3QMLC/IDDAsOAI4LNAGLAEoChwqnBgcANQQLABwACQqfAIwKWwIGAMUEiApHAgYLmAAGC10BBguSBgcL5AQIC3AACQuzAQkLnAIKCyIBCgs/AQoLLwMLC7QACwtFAwwL8AANC5gADQvbAI4LngCLAD4AhAoDAggKeAIICrkCiQpWA4YA5gaEC0UCBgt+AAcLPQIIC40BjgssAJYAHAALAJ4CFgAZAAQKiACFCicCBgCBBgcAAAEHAGwFigDzAQQAFgAFAAoABwAoBogAYQCGCvYGBQDhAQcKBwUJCiwACgooAgoKggILCkcDDAoSAQwKEwEMCnQBDQpbAI4KfQCFC54DBwvQBIkLEwIGAIYABwC1AQcAIAcJACUADgAdAY4AcwEHAOYBCACbAAsAXQCMAKQABgBvBYYAogWFC54ChQBPAgYKkwAHCnYDBwulBwkK8QKKCgwBBQB8AQUAigIHAJUEiAA2AQQAbAEHAIQEBwCjBIkAmQGHC1UGhgDiAYUL+gEEAA0DBgDnAQcAngMIAAcBiwD0AYoKiQCHC/IAiwtgAIUKngGHCuIGhgAkAwULQgMHC7IECAsOAAkL4QGJC3ADhgpXAgQAXgCHAPEEBACfAYQAoQEFAFwBBgAKAgYK1QYHC/YFigvRAYYKWwaEAPQDhAroAQQLZQEGC6wABwuPAIkLnQEEClMABAtOApILTACMCqQCBwsfAQgLYwEJCyUBiQvnAoYKFgEGAAsHEgClABgAFQAFC6kABwtNAYgLLQAMCmEAjAthAAQAmAEEAOUChwD0AYQLxgAHCoQBBwqEAosKDQMECxgABQuMAAULuQAHC9wFCws1AosLRgMGACkFCQABAQcK5QAICjsACQq+AAoKegGMCr8ABAtOAYULUQKHC10HhgByBAQA+QAGAEkAhwCxAIUAQAKOAOcAiQAgAYQKlAIHCgsEigrhAocAzwUGAN0DCQCxAQcKsgIJCksCjAoJAgcA8AQHAI4GCwCxAwwAVQEMANcBjAA5AoQLxQKFC4EDBQvgAA0LrgCSCzQAhwswB4YK0AYMAFcAEABKAAQK3QIJCsIACgpcAAsKxgAMClQAjQqAAIwACwOHABoCBAtgAoUL8QGFAJ0BBwtfBQcLugWKC0sBiADvAQYLHAKIC4gABwA2AAgAOAEKAL8ACgBmAowANwIGANQBBwA3AgcAxgUIABICDgAiAYUL5wMECysBBwoyAYcL7AOOCygBhgDMBYUK0wMGAGECCQAvAwwLiQAOCwkADgsYAI4LQACFC8gBBgDkAYcANgOFCrIAiAu0AIQL8wKJAIQDhwA3BQYAvAaHAOYHhwtzBAUAgAKECoYBBgAnB4oLeQKHCzYCBAt6AwULJQMFCzMDBQvBAwYLjAEGC18GBguOBgcLrwcHC/kHCQt2AgsLCAALC/sDDAuwAA0L4QAOCyQBlQsYAIQA2gGGAE8EhwDgBYYAKAYGAMEDBgAKBIwAjwILCwIClQsUAAUAMQGHCxcHBwvhBQoLvgAKC3oCCwsYAwwLZgGMC78BBQsAAAYLGAIHC1wCDQu9AZELfgAHANQEhQppAAQA4AEGANkABgAuAQYAagYHAIIABwBFAwcAKQUHAAsGBwB5BggArQEJAOQADQAhAQ0AVwETAGUABgvoAAYLnAEHCzIECAsJAAgLnQAICxIDCQvEAAkLYAEJC8kBCgtRAQsL6AALC20DDAvgAYwLIgIFCrYBBwu+AwkKtgIMCnMCDQsmAI0K0gAEC34BiAtDAgcAFgEKAOMCCwDEAo0AXAEEC9QAhwu2BIcLagcGAMQCBgBABZgKCwCJCwADhgAwB4wA6QAIChkAigo6AwYA4QeFC48CBgDQBYsLIgGECjQBhgA2BoYACAeGAOsEEAAcAAYL5wAHC18AiAunAYULLAGHCpYAiAqJAgcLUgeJC4ECBgvtAAcLYwIIC2QACQugAQsLTwEMC60AkgtlAIkALQCGCgkCEQAkAA4LGgCSC5YABwCiBQ4AFgAFClMBDwopAA8KpgCTCkIACAB6AQYLRQKHC18EhgDjBZMLdQCLACcAhgAeBAYAawEHAKMHiADVAoYA9AeFC8cABgBPBwkApwMJAMEDCQDsAwkA+AMMACUDDABUAwwAVQMMAGUDDAByAwwAgAMMAIoDDACVAwwArAMPAKoADwCwAA8AvAAPAMkADwDNAA8A1AAPAOoADwD0ABIAtQASAMEAEgDEABIAyQASAMoAEgDSABIA2QASAOsAEgDsABIA7QAVADYAFQA3ABUAOgAVADsAmAAWAIYKXAaJACUDBQAtA4cA/geOCyoABQDIAgYA2AQLABEADQBBAZAAQwCEAGkChwo9AwYAQAEHAA0DBwCBBwkANwAKALoACgARAQoAmAIKACEDCwDkAwsA5QMNAJ0AjgCqAIgADwEFCuYBhwpFBRILWwCTC0YACgC9AQcKYwYIChEAigonAYgLlAEHAGcABwBfAwsAuACRAD4AigouAokAkwIGCzgBBguzBgoLSAILCyICCwu0AgwLAwEMCycBDQsuAI0LmgCGAKQChAtMAgQL5wAFCz0ABgtoAAcL2QIHC8QDBwt6BowLngEGCwcBigv1AgsAUQGOAC8BhwtTBYQLQAGMAPoBhgq/AQUATQAHAK8FCgBLA5MASQAHCkECBwqYBQkK2wEJCvkBCQoOAgkKYQIJCrECCQrWAgkK3wIJCuICCgosAgoKogIKCqwCCwpZAAsKygALChABCwp8AQsKnwELCvkBCwoZAgsKJgILCjICCwqAAgsKmwILCrACCwpPAwsKnwMLCqIDCwqsAwwKkAAMCkUBDApJAQwKhQEMCpMBDArDAQwKAwIMClwCDApoAgwKcgINCkIADQqDAA0KpwANCuwADQpwAQ0KmwENCrIBDQrFAQ0KzQENCtoBDgo7AA4KPAAOCosADgqYAA4KFAEOCmEBDgqSAQ8KHAAPClEADwp7AA8KmAASCogAlApYAIQAygGHAIwFBgBtAAoAfgEEC5UBBAphAgcK9AIHCzEDCQogAgsKnQEOCzoADgozARAKGQARCyUAkgt8AAYASgEHADwECwCOAIULzgMECqIDhQqzAwUKqwOOC4oBEABbAJEAVwAFC+sABQrCAwcL1wQLC4MAjAtyAQsA7AEFCosCCAqqAAkKPQAJCj8ACgoXAAoKJQAKCkIDCwoEAAsKGQELCvcBCwqlAgwKYAAMCoIADAr0AA4KBQAOCigADgqiAA4KygCSCoUABAqWAQUKQwIMCuwBlgoPAAkLiQCKC90AhgDXBAsA0wCMAJEABwuGAYoLjACHC4oFhwt4BIYAGQQHAEEBBgoRAAcK6QMHCr4HCQp2AwoK6QEKCiADCwoOAwwKQAENCtMBDgqRAA4KgwGPCncAkQoRAAULlwELC+kBEwslABQLSQCWCyYAhQrKAYcAwQcHCr8HCAoAAAgKqwAJCngACQrcAgoK2QELCpACCwrmAxIKAAASCgIAkwoVAAULRQEHC8sFCAsFAAgL4wAJC2kACgtJAowLZgKIAHoAhADqAIcLrAQGANADBgBKBIYAoQUHAP0AiAAlAgYLbQINC/gBkAsTAIQKBwIFAK4BBQCkAwYAgwAHAKEBCQAKAgsAOgGNAIYBDgCVAA4AjwGPADkABQqLAwYKHwAGC9oABwrrAQcKEgIIClACCwo1AAsKCwMMCqcADAqbAQ4KDgAOCogADwpIABAKEQCQCkgAjAtKAQcLxgEHCw4DiAsAA4QA+wEKC6QCjAvOAQYAdgIJACsDBArQAAUKagAGChMCCAqYAQkKvACKCjwCBABXAQUA/wGGCp0GhgukAIQAwAEHAMcBigBPAocAZQUMCrkBlgsyAAkKwQEKCsAAigrkAgYAPwKECvEAhgCXBIYAjQKGAOEGhgCuBIQKAwEGC1cBBwvDAAkL4gAKC8UACgs/AgsL9gGLC4MDBwBnBAcAJAYKACkBCgCmAQsA/AILACoDDAAIAQ0AZgANACwBDQDkAQ4AkwAOAOUAEQBHABIAdgCTAHgAhwuaAoQApgIECq0ABQo4AQUKAAKHCgUFBwpDBgcKmwYJCtABCwrDAAwKFwEMCsABDgoLAJMKZgAQAGMAkgCkAAcLZQQJC48ACws9AA4LlQGWCxUAiQsEAQQKxAEFCkcCBQoxAwYKsQEHClECBwrQAgcKYgUICqEACQocAQoKOQGLCnYDhAojAogK0gIOACMAjgC/AI0ALQCKAHkAhAB9AIYAVgaFC78DCAqkAYsKwQCEANEChwqZAYgAkQAHABgDCACTAAoANQMLAMoDCwD9A4gLrQCGCwoBhADLAgcAzweKCjQBhQATAgUAqAAFAKIDCABKAAkAbwIMAPQBjABDApAAQQCKC/YABgDcAAcATQQNAGkAjgs6AQUK6gOICukChgDAAxQAAACUCwAABADtAwQK7wAGCt0BBwpHBgsKRACLCmkCBgATAAcAhQWLAKwBlQoNAAcAYAAIAJEBCAC/AgkAgAOICywBhgA7BpEAdACIAP0DBwCpBwcArQcHAO4HCACWAAgAvgIIAOECCADuAowAbgELC0sAjgsLAYQKbwEIACADCQCUAAkAaAMJAHoDCwA1AQsA6QMNAAsBDQBDAQULqwEFC94CBwveAYgLNAAHC+8ACwvZAI4LpQCEC0MBjAujAQ0AKwGOAEsABgtXAAYLxgYHCxQABwsgBAgL3AIJC5YBCQuPA4oLtgKGAGcFhAq2AoULZQKJAAsDBABWAowKrwIGAMoDhwCoAYUAIwIHCyAABwvYAwgLVQAIC8UCCQtDAgkLTwMJC1gDCgsfAwsLAgELC+8DDAtLAQwLZwINC7wADQuzAQ4LCAAPC6UAEAsbAJQLKAAGAMYEhgBpBYQAbAOKC5cAhwrVAAQLpwCHC1IAhQCFAAYLGAAHC0oABwumAokLAgEFCz4ABgsWAgcLrAIHCxMEBwswBAgLGAEICx0CCAuuAgoLBwILC/wAjAsaAYgAuwAIAAgACgAAAAoAMgOLANwDhAtnAQsArQEPADMAhwqIBogArQIFC9MABwtYAIgLcwKGANgBiACEAAYLkQCNC1ABBArvAgsKhgGMCiAABgCqAwYAJAQECwcBBAqZAYUKTgCJAGoDCAAGAwoAngIMADMABAuUAwYK2QEHCkIGCgq6AgwK1AANCjMBkQppAJIAXACPCpwAhAA+A4kAvQIEC1cCBgtiBgcLBQAHCzcABwtDAAcLYQAHC7MCBwvTAwcLoQYIC88ACAvWAAgL5wAICyYBCAtQAQgLrAEIC8MBCAvMAQgL1wEIC24CCAtyAggLpwIIC/cCCAs9AwkLCwAJC/YACQvkAQkLPQIJC8ICCQv6AgkLHgMJC1cDCQtmAwkLkAMKCy8BCgtPAQoLqAEKC80BCgsfAgoL9wIKCy4DCws7AAsLxwALC+sACwvbAQsLTgILC6EDCwvDAwwLcgAMC7YADAviAAwLTAEMC7cBDAs/AgwLVgINCwgADQt9AA0LwgANCx8BDgvFAA4LfwEPCzUAEQs/ABMLLgATC2IAEwtqAJQLVQAEAH8ABQBeAQYAZAEIAKoBCQA8AgoA9wCLADgBhgC/BAYAOwAJAFsCDQCNAQcLPQeKC7UBhgDiBpMLfgCHCnMD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EQAyAAUKRgIGCm4GBwpjAAcKqgcHCsIHCAoDAggKBQMJChcACQrrAQwKbAKOCl0AigthABQAFQAUACwAhQpTA4gAMwOLAJUDBQvmAAULiAEGC6QBCAr6AggKLAMJCzgCCQqOA4wLZAKHABADDwCHAI8LhwAKAMYBjABEAQQLAAAFCykABwuzBQcLvQUHC1IGBwtDBwkLJQKLC4kDBApiAAcKVQUJCqYBCQqeAgoKBwMLCtIADQoaAA0KyQGNCtwBBgC3BgYAxwYHAOAHBwDkBwgARQOJAFQDhQu4AocAVAOEALgDhgrCBoQLAwOKADgCiQDAAYsAkgAIAEMAigCjAYULmQOJCpMAhgAiBwoAkQIOACkBjgBpAQYAmgIGAP8ChgAGBosA2QIGC7QABwtxBAgL7wKLCyUDBAu3AAcLDwELCzgDCwu4Aw0LFgENC1MBDQviAQ4LqAGUC2MABACdAgUL3QEFC1QCBgv5AQcLxQQLC4sDDAvRAI0L1gCHC78EBQCSAQYKHgALCjgAiwoxAQcLNAKOC6gAiwCYAAcAkAOHCk4GBAqWAAUKLwGGCkcBBwBAAQgAMwAJAGQDCgBBAwwA4QEMADoClABqAIQAvQEHCxIBCwsHAQsL3wELC/sBjAsVAQoAKwILADQBEwBfAAYLbQYICsAACgpOAI0KZwGHChIDBgtcAAYLvAAHC/UEBwv0BQcLVAcKC+QAiwv8AwQLywGFC8YDCwCCAQYKZgYHCk8ABwrwAQkKigAKClABDAqcAQwKuAGOCjEBhQDvAAcAUwAHAMYHCACCAIsA0AKKC8UCBACPAAUAJgKFAPACBQB7AAYAEgIHAFwBhwCLBYcA6AcGCxIABwuzAAcL0QIHC6QDCAskAggL9QIJCzYACQtBAAkLFAIJC0wDCgtxAAoLdQAKC+wACgs7AQoLrgEKCx4DCwuZAAsLXwELC3cBDAtOAAwLlwAMC4gBDgv4AI8LFwAHCswABwqfAQgKKgAKClUAiwo0AoYAvgOFC8UDhADSAIcLlQWKC+ABhgu2AIsLWQEKC0EACgvoAYoL8QEECgMABQr3AAUKhAIHCugCBwq3BAcKyQQHCnUHkgqTAIQArgEFCh0BCQpDAA0K2QGPClIAkAsQAAcLigQJC0wCCgsEAZcKCACFANUAigAHAIcAIQOGC/oGhws0AQYAqAOGAAkF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BwBSAQcAwQYIAOQAiwDuAhUAHgAWADUABArBAAUKlAMHCmwBCgqOAQoK1gILCj0BCwpyAgwKjgAMCiABDAqmAg0KOQEPCnEAkgpyAAYLbgCHC5EGhwCOAwYK8QAHCosDCApAAwkKVgEKCtkCCwocAQsKvQELCosCCwpfAw0KjgGSCmMABwDBAgkA3gIFC+gDBwvdAokLRwIEAEkABgBkAgcAnwMHAB4HCADZAAkA/QIJAP4CCgCYAQsAMwALABkDDAAKAQ8AngAUAFkAlgAgAAcAMgUECykBBgsRAgcLmAAHC8kCBws1BwgLxgIIC80CjAt/AgUAhQGIAHwChgCBBQQKMgIJCv4AiwpvA4YAfQOEChIDBAsIAocLPwKIABUAjADRAogAvwMHC5QFBwtoBgkLqQAJC7YACQtvAQkL3gEJC/oBCQsnAgkLiAIJC4sCCQu5AgkLwQIJC9UCCQsTAwkLGgMKC8YACgvWAAoLCwEKCxMBCgvIAQoLJwIKCzECCgtlAgoLcwIKC5wCCgujAgoLswIKC7cCCgvDAgoLywILC7cACwvJAAsL9AALCwYBCwtgAQsLtwELC+0BCws8AgsLTwILC2ACCwtjAgsLhgILC6ICCwvHAgsL7wILC/kCCwsIAwsLEQMLC1IDCwtVAwsLXgMLC2EDCwtkAwsLggMLC4YDCwuHAwsLjgMLC6QDCwuuAwsLvQMLC8cDCwvMAwwLlAAMC8MADAvcAAwL7QAMCz4BDAtTAQwLiQEMC70BDAvCAQwL2gEMC/0BDAsVAgwLTwIMC1ICDAtVAgwLbQIMC3kCDAuCAg0LOwANCzwADQuRAA0L7wANC/oADQsRAQ0LSQENC1gBDQttAQ0LdAENC4MBDQuTAQ0LngENC8gBDQveAQ0L4wENC+kBDgs3AA4LOQAOC1EADgtaAA4LlAAOC+8ADgsKAQ4LQQEOC0YBDgtHAQ4LSgEOC1sBDgtjAQ4LkQEOC5sBDgueAQ4LoAEOC6QBDws9AA8LSgAPC1cADwtYAA8LXgAPC2AADwt0AA8LlQAPC5oAEAsyABALPwAQC0kAEQsCABELQgARC1wAEQtnABELcAASCzIAEgs2ABILUgASC1YAEgtaABILbwASC3MAEgucABMLKAATC08AFAtOAJULFgCJC6oAhgCZBYcLGwWLC5sBBQC9AAcAugEHALsB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BwoSAQsK3wGLCvsBBgDBAgYADwMGAPsEBgDJBQQLGgEHCwoECwuOAQsLegIMCwEADAtPAAwLIAIOC+0AEQsKAJILFACGAMUBBAArAggAGAIKACABCwDtAwQK8QGHCjAGBQt2AAUL8wEGC9wBBwtYAgcLeAOHC0gEigDbAwcAUwQHCgUBBwpbBAcKSgUHCjQGBwqpBgcKbgcJCtEBCgr4AAoKXQEKCocCCwoPAgsKlAILCp0CDAoRAo0KMQEHCygBBwtUAggLMAIIC0oCCQtkAgsLZAALCzABDAsuAA0LWQAOC3AAkQt6AAkAcgGKAFoAiAoNAIQAXAMHCoICCAr6AAsKewALCokADQowAI4KXwCHCpUFiQtBAYQAAQGHAO8HBwDoBgcLPwYHC7sGCAtPAAgLagAIC74ACAsuAQgLfwEJC3cACQvpAAkLKgEJC6MBCQvXAQoLtQAKC5YBCws5AAsLVQALC3gACwuxAAsLKAELC34BCwvGAQsL9gILC+cDDAsbAAwLYgAMC4MADAv1AAwLOAEMC74BDAvGAQ0LGQANC2IADQuqAQ0L/AEOCwYADgujAA4LEAEOCxUBDgtyAQ8LXwAPC4oADwunABELEgARCyYAFAtgAJULIAAFC9IChgvfBpELEAAGAC8EhgAZBgoKIQKMCi0BBgBTAAYAxQaHAG0FBABDA4cAGgeFCwIBBAqIA4UKGgOGANYHBQseAAcL7wEIC4YACQsUA4wLtgGHC9QHiQC4AgULMgAGC7cBBwsMA4cLEAQHCwQDBwtQBAcLbwYLCw0BCwsbAgsLXwILC3MCCwvCAgsLzwMMC/gADAs3AQwLsgEMC1gCDAtuAg0LKQENC28BDQvlAQ4LRQAOC5kBjwtsAAULAQAGC1EAigsIAgcAtgYJAF8ACQASAQoAFwEKAD0BCgCkAQsALwELACgDDACGAAwAbwENAJUADQBbAQ4AXQEOAJYBEgAWABIAWQASAHoAkwAvAAUL4gEIC2IACQusAAoL3gAKC7wCCgs2AwsLLgELCwoDDAsyAAwLfwAMC4wBDQs+AA0LSAEOC3oAkwtIAAcKggGKCskCBgoHAAYKIwAHCpMABwotBAcKIAYHCicGBwp9BwgKKwAICtAACQqAAAkKYgMKChQACwrVA5MKIQCFABoAhAAmAgULAgAHC9YFiAtNAgYLAAIHCx0D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bSAEIGJ5IAEoBi4gVGhlIAQgb24gBCBhcyAEIGlzIARpbmcgAgoJAToDZWQgAj0iBCBhdCADbHkgASwCPScFLmNvbS8HLiBUaGlzIAUgbm90IANlciADYWwgBGZ1bCAEaXZlIAVsZXNzIARlc3QgBGl6ZSACwqAEb3VzIAUgdGhlIAJlIABB4twZC2ECAAUADgATABYAGAAeACMAJQAqAC0ALwAyADQAOgA+AEUARwBOAFUAWgBcAGMAaABtAHIAdwB6AHwAgACDAIgAjACOAJEAlwCfAKUAqQCtALIAtwC9AMIAxwDKAM8A1QDYAEHQ3RkLggMxADExAAAAAAAxDDExCgAxAC8AADEEAAAxAAMxCjExAAYxDTExATEBAAAxAAEACgAxAAcxAAkwAAAxAAgxAAUxAAoxAAsxAzExAA0xAA4xDjExAjExAA8xABAACjExAAwFADEAAAExDzExABIxABExABMxABQxEDExETEvADExBDExABYxCzExABcxABgxABkxBzExARoxABsxABwAAAwxAB0xFDExEjExBjExABUxCgExCDExAB8xACAvAAMxBTExCTEACgExCggFABUxCwAxCgoxAB4AAAUjADEvAAIxChExACQxACEFAAAxChUxCgUxACUAAB4xACYACwAxACcACzExACIxCwgxCgwAABUxACgACgwxACkxACoxCxExACsACgUxCwoAACIxCiExACwxCwUtADEAACExCh4xCx4xAC4xCwExCiIACiEACx4ACwExCyExCxUxCwwACwUxCyIACwwACh4ACyIACiIAAAAAAAECAwQABREGEAcICQoLDA0ODwBB4OAZC4cBAgICAwICAgQCAgIDAgICBAAEAwIABAMBAAQDAgAEAwUBAAIABQACAAkAAgANAAIAEQADABkAAwAhAAMAKQADADEABABBAAQAUQAEAGEABABxAAUAkQAFALEABQDRAAUA8QAGADEBBgBxAQcA8QEIAPECCQDxBAoA8QgLAPEQDADxIA0A8UAYAEH04RkLgAEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9//////wBBhOMZC5wCBAAAAAwAAAAcAAAASQAAAH4AAADkAAAAqAEAAAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+PwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AQaTnGQv8AQEBAQECAgICAwMDAwQEBAQFBQUFBgYGBgcHBwcICAgICQkJCQoKCgoLCwsLDAwMDA0NDQ0ODg4ODw8PDxAQEBAREREREhISEhMTExMUFBQUFRUVFRYWFhYXFxcXGBgYGBkZGRkaGhoaGxsbGxwcHBwdHR0dHh4eHh8fHx8gICAgISEhISIiIiIjIyMjJCQkJCUlJSUmJiYmJycnJygoKCgpKSkpKioqKisrKyssLCwsLS0tLS4uLi4vLy8vMDAwMDExMTEyMjIyMzMzMzQ0NDQ1NTU1NjY2Njc3Nzc4ODg4OTk5OTo6Ojo7Ozs7PDw8PD09PT0+Pj4+Pz8/PwBBqesZCwUEBAAABABBwOsZC+ABCAwQDAwUDBAYHAwMIAwkDCwsLCwsLCwsLCwgIBgoHAwMMDQ0NDA0NDQwNDQ0NDQwNDQ0NDQwNDQ0NDQYDBwMDAw4PDw8ODw8PDg8PDw8PDg8PDw8PDg8PDw8PBgMHAwAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMAQcHtGQteAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQEBAQMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAQEBAQBBgO8ZC5dRAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIACAgICAgICAgICAgICAgIEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgwMDAwMDAwMDAwMDAwMDA4AAEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBgYGBgYGBgYGBgYGBgYGBwAAAAAAAAIAAAAAAQAAAwAAAAACAAAEAAAAAAMAAAUAAAAAAwAABgAAAAADAAAHAAAAAAMAAAgAAAAAAwAACQAAAAAAAQACAAAAAAEBAAMAAAAAAgEABAAAAAADAQAFAAAAAAMBAAYAAAAAAwEABwAAAAADAQAIAAAAAAMBAAkAAAAAAAIAAgAAAAABAgADAAAAAAICAAQAAAAAAwIABQAAAAADAgAGAAAAAAMCAAcAAAAAAwIACAAAAAADAgAJAAAAAAADAAIAAAAAAQMAAwAAAAACAwAEAAAAAAMDAAUAAAAAAwMABgAAAAADAwAHAAAAAAMDAAgAAAAAAwMACQAAAAAABAACAAAAAAEEAAMAAAAAAgQABAAAAAADBAAFAAAAAAMEAAYAAAAAAwQABwAAAAADBAAIAAAAAAMEAAkAAAAAAAUAAgAAAAABBQADAAAAAAIFAAQAAAAAAwUABQAAAAADBQAGAAAAAAMFAAcAAAAAAwUACAAAAAADBQAJAAEAAAAGAAIAAQAAAQYAAwABAAACBgAEAAEAAAMGAAUAAQAAAwYABgABAAADBgAHAAEAAAMGAAgAAQAAAwYACQABAAAACAACAAEAAAEIAAMAAQAAAggABAABAAADCAAFAAEAAAMIAAYAAQAAAwgABwABAAADCAAIAAEAAAMIAAkAAAEAAwAACgAAAQADAAAMAAACAAMAAA4AAAIAAwAAEgAAAwADAAAWAAADAAMAAB4AAAQAAwAAJgAABAADAAA2AAABAAMBAAoAAAEAAwEADAAAAgADAQAOAAACAAMBABIAAAMAAwEAFgAAAwADAQAeAAAEAAMBACYAAAQAAwEANgAAAQADAgAKAAABAAMCAAwAAAIAAwIADgAAAgADAgASAAADAAMCABYAAAMAAwIAHgAABAADAgAmAAAEAAMCADYAAAEAAwMACgAAAQADAwAMAAACAAMDAA4AAAIAAwMAEgAAAwADAwAWAAADAAMDAB4AAAQAAwMAJgAABAADAwA2AAABAAMEAAoAAAEAAwQADAAAAgADBAAOAAACAAMEABIAAAMAAwQAFgAAAwADBAAeAAAEAAMEACYAAAQAAwQANgAAAQADBQAKAAABAAMFAAwAAAIAAwUADgAAAgADBQASAAADAAMFABYAAAMAAwUAHgAABAADBQAmAAAEAAMFADYAAQEAAwYACgABAQADBgAMAAECAAMGAA4AAQIAAwYAEgABAwADBgAWAAEDAAMGAB4AAQQAAwYAJgABBAADBgA2AAEBAAMIAAoAAQEAAwgADAABAgADCAAOAAECAAMIABIAAQMAAwgAFgABAwADCAAeAAEEAAMIACYAAQQAAwgANgAAAP8AAAACAAAA/wEAAAMAAAD/AgAABAAAAP8DAAAFAAAA/wMAAAYAAAD/AwAABwAAAP8DAAAIAAAA/wMAAAkAAAD/AAEAAgAAAP8BAQADAAAA/wIBAAQAAAD/AwEABQAAAP8DAQAGAAAA/wMBAAcAAAD/AwEACAAAAP8DAQAJAAAA/wACAAIAAAD/AQIAAwAAAP8CAgAEAAAA/wMCAAUAAAD/AwIABgAAAP8DAgAHAAAA/wMCAAgAAAD/AwIACQAAAP8AAwACAAAA/wEDAAMAAAD/AgMABAAAAP8DAwAFAAAA/wMDAAYAAAD/AwMABwAAAP8DAwAIAAAA/wMDAAkAAAD/AAQAAgAAAP8BBAADAAAA/wIEAAQAAAD/AwQABQAAAP8DBAAGAAAA/wMEAAcAAAD/AwQACAAAAP8DBAAJAAAA/wAFAAIAAAD/AQUAAwAAAP8CBQAEAAAA/wMFAAUAAAD/AwUABgAAAP8DBQAHAAAA/wMFAAgAAAD/AwUACQABAP8ABgACAAEA/wEGAAMAAQD/AgYABAABAP8DBgAFAAEA/wMGAAYAAQD/AwYABwABAP8DBgAIAAEA/wMGAAkAAQD/AAgAAgABAP8BCAADAAEA/wIIAAQAAQD/AwgABQABAP8DCAAGAAEA/wMIAAcAAQD/AwgACAABAP8DCAAJAAAB/wMAAAoAAAH/AwAADAAAAv8DAAAOAAAC/wMAABIAAAP/AwAAFgAAA/8DAAAeAAAE/wMAACYAAAT/AwAANgAAAf8DAQAKAAAB/wMBAAwAAAL/AwEADgAAAv8DAQASAAAD/wMBABYAAAP/AwEAHgAABP8DAQAmAAAE/wMBADYAAAH/AwIACgAAAf8DAgAMAAAC/wMCAA4AAAL/AwIAEgAAA/8DAgAWAAAD/wMCAB4AAAT/AwIAJgAABP8DAgA2AAAB/wMDAAoAAAH/AwMADAAAAv8DAwAOAAAC/wMDABIAAAP/AwMAFgAAA/8DAwAeAAAE/wMDACYAAAT/AwMANgAAAf8DBAAKAAAB/wMEAAwAAAL/AwQADgAAAv8DBAASAAAD/wMEABYAAAP/AwQAHgAABP8DBAAmAAAE/wMEADYAAAH/AwUACgAAAf8DBQAMAAAC/wMFAA4AAAL/AwUAEgAAA/8DBQAWAAAD/wMFAB4AAAT/AwUAJgAABP8DBQA2AAEB/wMGAAoAAQH/AwYADAABAv8DBgAOAAEC/wMGABIAAQP/AwYAFgABA/8DBgAeAAEE/wMGACYAAQT/AwYANgABAf8DCAAKAAEB/wMIAAwAAQL/AwgADgABAv8DCAASAAED/wMIABYAAQP/AwgAHgABBP8DCAAmAAEE/wMIADYAAgD/AAoAAgACAP8BCgADAAIA/wIKAAQAAgD/AwoABQACAP8DCgAGAAIA/wMKAAcAAgD/AwoACAACAP8DCgAJAAIA/wAOAAIAAgD/AQ4AAwACAP8CDgAEAAIA/wMO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tnb2Do5Ozi6ubu4enl7ePr5+/gGBQcEhoWHhEZFR0TGxcfEJiUnJKalp6RmZWdk5uXn5BYVFxSWlZeUVlVXVNbV19Q2NTc0trW3tHZ1d3T29ff0Dg0PDI6Nj4xOTU9Mzs3PzC4tLyyura+sbm1vbO7t7+weHR8cnp2fnF5dX1ze3d/cPj0/PL69v7x+fX98/v3//AAGSAbQB1AH0ARYCNgJWAnYClgK2AtYC9gIWAzYDVgN2A5gDuAPYA/gDGAQ4BFgEeASYBLgE2AT4BBgFOAVYBXgFmAW4BdgF+AVOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAAAABUngYA6pAGAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAABUngYANJEGAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAAVJ4GAHyRBgBOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAFSeBgDIkQYATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAABUngYAFJIGAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAVJ4GADySBgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAFSeBgBkkgYATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAABUngYAjJIGAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAVJ4GALSSBgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAFSeBgDckgYATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAABUngYABJMGAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAVJ4GACyTBgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAAFSeBgBUkwYATjEwZW1zY3JpcHRlbjExbWVtb3J5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")||(H=h,h=g.locateFile?g.locateFile(H,d):d+H);var j=A=>{for(;A.length>0;)A.shift()(g);};function v(A){this.excPtr=A,this.ptr=A-24,this.set_type=function(A){L[this.ptr+4>>2]=A;},this.get_type=function(){return L[this.ptr+4>>2]},this.set_destructor=function(A){L[this.ptr+8>>2]=A;},this.get_destructor=function(){return L[this.ptr+8>>2]},this.set_caught=function(A){A=A?1:0,w[this.ptr+12>>0]=A;},this.get_caught=function(){return 0!=w[this.ptr+12>>0]},this.set_rethrown=function(A){A=A?1:0,w[this.ptr+13>>0]=A;},this.get_rethrown=function(){return 0!=w[this.ptr+13>>0]},this.init=function(A,g){this.set_adjusted_ptr(0),this.set_type(A),this.set_destructor(g);},this.set_adjusted_ptr=function(A){L[this.ptr+16>>2]=A;},this.get_adjusted_ptr=function(){return L[this.ptr+16>>2]},this.get_exception_ptr=function(){if(AP(this.get_type()))return L[this.excPtr>>2];var A=this.get_adjusted_ptr();return 0!==A?A:this.excPtr};}var O=0,P=A=>{for(var g="",C=A;D[C];)g+=F[D[C++]];return g},z={},e={},T={},f=A=>{throw new s(A)},_=A=>{throw new N(A)},$=(A,g,C)=>{function B(g){var B=C(g);B.length!==A.length&&_("Mismatched type converter count");for(var I=0;I<A.length;++I)AA(A[I],B[I]);}A.forEach(function(A){T[A]=g;});var I=Array(g.length),Q=[],E=0;g.forEach((A,g)=>{e.hasOwnProperty(A)?I[g]=e[A]:(Q.push(A),z.hasOwnProperty(A)||(z[A]=[]),z[A].push(()=>{I[g]=e[A],++E===Q.length&&B(I);}));}),0===Q.length&&B(I);};function AA(A,g,C={}){if(!("argPackAdvance"in g))throw TypeError("registerType registeredInstance requires argPackAdvance");return function(A,g,C={}){var B=g.name;if(A||f(`type "${B}" must have a positive integer typeid pointer`),e.hasOwnProperty(A)){if(C.ignoreDuplicateRegistrations)return;f(`Cannot register type '${B}' twice`);}if(e[A]=g,delete T[A],z.hasOwnProperty(A)){var I=z[A];delete z[A],I.forEach(A=>A());}}(A,g,C)}function Ag(){this.allocated=[void 0],this.freelist=[];}var AC=new Ag,AB=A=>{A>=AC.reserved&&0==--AC.get(A).refcount&&AC.free(A);},AI={toValue:A=>(A||f("Cannot use deleted val. handle = "+A),AC.get(A).value),toHandle:A=>{switch(A){case void 0:return 1;case null:return 2;case  true:return 3;case  false:return 4;default:return AC.allocate({refcount:1,value:A})}}};function AQ(A){return this.fromWireType(o[A>>2])}var AE=(A,g)=>{switch(g){case 4:return function(A){return this.fromWireType(Y[A>>2])};case 8:return function(A){return this.fromWireType(c[A>>3])};default:throw TypeError(`invalid float width (${g}): ${A}`)}},Aw=A=>{if(void 0===A)return "_unknown";var g=(A=A.replace(/[^a-zA-Z0-9_]/g,"$")).charCodeAt(0);return g>=48&&g<=57?`_${A}`:A},AD=A=>{for(;A.length;){var g=A.pop();A.pop()(g);}};function AG(A,g){return ({[A=Aw(A)]:function(){return g.apply(this,arguments)}})[A]}var Ai=(A,g,C)=>{if(void 0===A[g].overloadTable){var B=A[g];A[g]=function(){return A[g].overloadTable.hasOwnProperty(arguments.length)||f(`Function '${C}' called with an invalid number of arguments (${arguments.length}) - expects one of (${A[g].overloadTable})!`),A[g].overloadTable[arguments.length].apply(this,arguments)},A[g].overloadTable=[],A[g].overloadTable[B.argCount]=B;}},Ao=(A,C,B)=>{g.hasOwnProperty(A)?((void 0===B||void 0!==g[A].overloadTable&&void 0!==g[A].overloadTable[B])&&f(`Cannot register public name '${A}' twice`),Ai(g,A,A),g.hasOwnProperty(B)&&f(`Cannot register multiple overloads of a function with the same number of arguments (${B})!`),g[A].overloadTable[B]=C):(g[A]=C,void 0!==B&&(g[A].numArguments=B));},AL=(A,g)=>{for(var C=[],B=0;B<A;B++)C.push(L[g+4*B>>2]);return C},AY=(A,C,B)=>{g.hasOwnProperty(A)||_("Replacing nonexistant public symbol"),void 0!==g[A].overloadTable&&void 0!==B?g[A].overloadTable[B]=C:(g[A]=C,g[A].argCount=B);},Ac=(A,C,B)=>{var I=g["dynCall_"+A];return B&&B.length?I.apply(null,[C].concat(B)):I.call(null,C)},Ah=[],AF=A=>{var g=Ah[A];return g||(A>=Ah.length&&(Ah.length=A+1),Ah[A]=g=K.get(A)),g},As=(A,g,C)=>A.includes("j")?Ac(A,g,C):AF(g).apply(null,C),AN=(A,g)=>{var C=[];return function(){return C.length=0,Object.assign(C,arguments),As(A,g,C)}},AK=(A,g)=>{var C=(A=P(A)).includes("j")?AN(A,g):AF(g);return "function"!=typeof C&&f(`unknown function pointer with signature ${A}: ${g}`),C},Aa=A=>{var g=Ar(A),C=P(g);return AO(g),C},AR=(A,g)=>{var C=[],B={};throw g.forEach(function A(g){if(!B[g]&&!e[g]){if(T[g]){T[g].forEach(A);return}C.push(g),B[g]=true;}}),new a(`${A}: `+C.map(Aa).join([", "]))},AH=(A,g,C)=>{switch(g){case 1:return C?A=>w[A>>0]:A=>D[A>>0];case 2:return C?A=>G[A>>1]:A=>i[A>>1];case 4:return C?A=>o[A>>2]:A=>L[A>>2];default:throw TypeError(`invalid integer width (${g}): ${A}`)}};function Ak(A){return this.fromWireType(L[A>>2])}var AJ=(A,g,C,B)=>{if(!(B>0))return 0;for(var I=C,Q=C+B-1,E=0;E<A.length;++E){var w=A.charCodeAt(E);if(w>=55296&&w<=57343&&(w=65536+((1023&w)<<10)|1023&A.charCodeAt(++E)),w<=127){if(C>=Q)break;g[C++]=w;}else if(w<=2047){if(C+1>=Q)break;g[C++]=192|w>>6,g[C++]=128|63&w;}else if(w<=65535){if(C+2>=Q)break;g[C++]=224|w>>12,g[C++]=128|w>>6&63,g[C++]=128|63&w;}else {if(C+3>=Q)break;g[C++]=240|w>>18,g[C++]=128|w>>12&63,g[C++]=128|w>>6&63,g[C++]=128|63&w;}}return g[C]=0,C-I},AZ=(A,g,C)=>AJ(A,D,g,C),AM=A=>{for(var g=0,C=0;C<A.length;++C){var B=A.charCodeAt(C);B<=127?g++:B<=2047?g+=2:B>=55296&&B<=57343?(g+=4,++C):g+=3;}return g},AW="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,Ad=(A,g,C)=>{for(var B=g+C,I=g;A[I]&&!(I>=B);)++I;if(I-g>16&&A.buffer&&AW)return AW.decode(A.subarray(g,I));for(var Q="";g<I;){var E=A[g++];if(!(128&E)){Q+=String.fromCharCode(E);continue}var w=63&A[g++];if((224&E)==192){Q+=String.fromCharCode((31&E)<<6|w);continue}var D=63&A[g++];if((E=(240&E)==224?(15&E)<<12|w<<6|D:(7&E)<<18|w<<12|D<<6|63&A[g++])<65536)Q+=String.fromCharCode(E);else {var G=E-65536;Q+=String.fromCharCode(55296|G>>10,56320|1023&G);}}return Q},Ay=(A,g)=>A?Ad(D,A,g):"",AU="undefined"!=typeof TextDecoder?new TextDecoder("utf-16le"):void 0,Ap=(A,g)=>{for(var C=A,B=C>>1,I=B+g/2;!(B>=I)&&i[B];)++B;if((C=B<<1)-A>32&&AU)return AU.decode(D.subarray(A,C));for(var Q="",E=0;!(E>=g/2);++E){var w=G[A+2*E>>1];if(0==w)break;Q+=String.fromCharCode(w);}return Q},Ab=(A,g,C)=>{if(void 0===C&&(C=2147483647),C<2)return 0;for(var B=g,I=(C-=2)<2*A.length?C/2:A.length,Q=0;Q<I;++Q){var E=A.charCodeAt(Q);G[g>>1]=E,g+=2;}return G[g>>1]=0,g-B},Al=A=>2*A.length,AS=(A,g)=>{for(var C=0,B="";!(C>=g/4);){var I=o[A+4*C>>2];if(0==I)break;if(++C,I>=65536){var Q=I-65536;B+=String.fromCharCode(55296|Q>>10,56320|1023&Q);}else B+=String.fromCharCode(I);}return B},Am=(A,g,C)=>{if(void 0===C&&(C=2147483647),C<4)return 0;for(var B=g,I=B+C-4,Q=0;Q<A.length;++Q){var E=A.charCodeAt(Q);if(E>=55296&&E<=57343&&(E=65536+((1023&E)<<10)|1023&A.charCodeAt(++Q)),o[g>>2]=E,(g+=4)+4>I)break}return o[g>>2]=0,g-B},Aq=A=>{for(var g=0,C=0;C<A.length;++C){var B=A.charCodeAt(C);B>=55296&&B<=57343&&++C,g+=4;}return g},At=(A,g)=>{var C=e[A];return void 0===C&&f(g+" has unknown type "+Aa(A)),C},AV=()=>2147483648,AX=A=>{var g=(A-E.buffer.byteLength+65535)/65536;try{return E.grow(g),b(),1}catch(A){}},An=A=>{W(A,new x(A));};(()=>{for(var A=Array(256),g=0;g<256;++g)A[g]=String.fromCharCode(g);F=A;})(),s=g.BindingError=class extends Error{constructor(A){super(A),this.name="BindingError";}},N=g.InternalError=class extends Error{constructor(A){super(A),this.name="InternalError";}},Object.assign(Ag.prototype,{get(A){return this.allocated[A]},has(A){return void 0!==this.allocated[A]},allocate(A){var g=this.freelist.pop()||this.allocated.length;return this.allocated[g]=A,g},free(A){this.allocated[A]=void 0,this.freelist.push(A);}}),AC.allocated.push({value:void 0},{value:null},{value:true},{value:false}),AC.reserved=AC.allocated.length,g.count_emval_handles=()=>{for(var A=0,g=AC.reserved;g<AC.allocated.length;++g) void 0!==AC.allocated[g]&&++A;return A},a=g.UnboundTypeError=(k=Error,(Z=AG(J="UnboundTypeError",function(A){this.name=J,this.message=A;var g=Error(A).stack;void 0!==g&&(this.stack=this.toString()+"\n"+g.replace(/^Error(:[^\n]*)?\n/,""));})).prototype=Object.create(k.prototype),Z.prototype.constructor=Z,Z.prototype.toString=function(){return void 0===this.message?this.name:`${this.name}: ${this.message}`},Z);var Ax={e:(A,g,C)=>{throw new v(A).init(g,C),O=A,O},n:(A,g,C,B,I)=>{},i:(A,g,C,B)=>{AA(A,{name:g=P(g),fromWireType:function(A){return !!A},toWireType:function(A,g){return g?C:B},argPackAdvance:8,readValueFromPointer:function(A){return this.fromWireType(D[A])},destructorFunction:null});},r:(A,g)=>{AA(A,{name:g=P(g),fromWireType:A=>{var g=AI.toValue(A);return AB(A),g},toWireType:(A,g)=>AI.toHandle(g),argPackAdvance:8,readValueFromPointer:AQ,destructorFunction:null});},f:(A,g,C)=>{AA(A,{name:g=P(g),fromWireType:A=>A,toWireType:(A,g)=>g,argPackAdvance:8,readValueFromPointer:AE(g,C),destructorFunction:null});},c:(A,g,C,B,I,Q,E)=>{var w=AL(g,C);A=P(A),I=AK(B,I),Ao(A,function(){AR(`Cannot call ${A} due to unbound types`,w);},g-1),$([],w,function(C){return AY(A,function(A,g,C,B,I,Q){var E=g.length;E<2&&f("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var w=null!==g[1]&&false,D=false,G=1;G<g.length;++G)if(null!==g[G]&&void 0===g[G].destructorFunction){D=true;break}for(var i="void"!==g[0].name,o="",L="",G=0;G<E-2;++G)o+=(0!==G?", ":"")+"arg"+G,L+=(0!==G?", ":"")+"arg"+G+"Wired";var Y=`
        return function ${Aw(A)}(${o}) {
        if (arguments.length !== ${E-2}) {
          throwBindingError('function ${A} called with ' + arguments.length + ' arguments, expected ${E-2}');
        }`;D&&(Y+="var destructors = [];\n");var c=D?"destructors":"null",h=["throwBindingError","invoker","fn","runDestructors","retType","classParam"],F=[f,B,I,AD,g[0],g[1]];w&&(Y+="var thisWired = classParam.toWireType("+c+", this);\n");for(var G=0;G<E-2;++G)Y+="var arg"+G+"Wired = argType"+G+".toWireType("+c+", arg"+G+"); // "+g[G+2].name+"\n",h.push("argType"+G),F.push(g[G+2]);if(w&&(L="thisWired"+(L.length>0?", ":"")+L),Y+=(i||Q?"var rv = ":"")+"invoker(fn"+(L.length>0?", ":"")+L+");\n",D)Y+="runDestructors(destructors);\n";else for(var G=w?1:2;G<g.length;++G){var s=1===G?"thisWired":"arg"+(G-2)+"Wired";null!==g[G].destructorFunction&&(Y+=s+"_dtor("+s+"); // "+g[G].name+"\n",h.push(s+"_dtor"),F.push(g[G].destructorFunction));}return i&&(Y+="var ret = retType.fromWireType(rv);\nreturn ret;\n"),Y+="}\n",h.push(Y),(function(A,g){if(!(A instanceof Function))throw TypeError(`new_ called with constructor type ${typeof A} which is not a function`);var C=AG(A.name||"unknownFunctionName",function(){});C.prototype=A.prototype;var B=new C,I=A.apply(B,g);return I instanceof Object?I:B})(Function,h).apply(null,F)}(A,[C[0],null].concat(C.slice(1)),0,I,Q,E),g-1),[]});},b:(A,g,C,B,I)=>{g=P(g);var Q=A=>A;if(0===B){var E=32-8*C;Q=A=>A<<E>>>E;}var w=g.includes("unsigned"),D=(A,g)=>{};AA(A,{name:g,fromWireType:Q,toWireType:w?function(A,g){return D(g,this.name),g>>>0}:function(A,g){return D(g,this.name),g},argPackAdvance:8,readValueFromPointer:AH(g,C,0!==B),destructorFunction:null});},a:(A,g,C)=>{var B=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][g];function I(A){var g=L[A>>2],C=L[A+4>>2];return new B(w.buffer,C,g)}AA(A,{name:C=P(C),fromWireType:I,argPackAdvance:8,readValueFromPointer:I},{ignoreDuplicateRegistrations:true});},g:(A,g)=>{var C="std::string"===(g=P(g));AA(A,{name:g,fromWireType(A){var g,B=L[A>>2],I=A+4;if(C)for(var Q=I,E=0;E<=B;++E){var w=I+E;if(E==B||0==D[w]){var G=w-Q,i=Ay(Q,G);void 0===g?g=i:g+="\x00"+i,Q=w+1;}}else {for(var o=Array(B),E=0;E<B;++E)o[E]=String.fromCharCode(D[I+E]);g=o.join("");}return AO(A),g},toWireType(A,g){g instanceof ArrayBuffer&&(g=new Uint8Array(g));var B,I="string"==typeof g;I||g instanceof Uint8Array||g instanceof Uint8ClampedArray||g instanceof Int8Array||f("Cannot pass non-string to std::string"),B=C&&I?AM(g):g.length;var Q=Av(4+B+1),E=Q+4;if(L[Q>>2]=B,C&&I)AZ(g,E,B+1);else if(I)for(var w=0;w<B;++w){var G=g.charCodeAt(w);G>255&&(AO(E),f("String has UTF-16 code units that do not fit in 8 bits")),D[E+w]=G;}else for(var w=0;w<B;++w)D[E+w]=g[w];return null!==A&&A.push(AO,Q),Q},argPackAdvance:8,readValueFromPointer:Ak,destructorFunction(A){AO(A);}});},d:(A,g,C)=>{var B,I,Q,E,w;C=P(C),2===g?(B=Ap,I=Ab,E=Al,Q=()=>i,w=1):4===g&&(B=AS,I=Am,E=Aq,Q=()=>L,w=2),AA(A,{name:C,fromWireType:A=>{for(var C,I=L[A>>2],E=Q(),D=A+4,G=0;G<=I;++G){var i=A+4+G*g;if(G==I||0==E[i>>w]){var o=i-D,Y=B(D,o);void 0===C?C=Y:C+="\x00"+Y,D=i+g;}}return AO(A),C},toWireType:(A,B)=>{"string"!=typeof B&&f(`Cannot pass non-string to C++ string type ${C}`);var Q=E(B),D=Av(4+Q+g);return L[D>>2]=Q>>w,I(B,D+4,Q+g),null!==A&&A.push(AO,D),D},argPackAdvance:8,readValueFromPointer:AQ,destructorFunction(A){AO(A);}});},j:(A,g)=>{AA(A,{isVoid:true,name:g=P(g),argPackAdvance:0,fromWireType:()=>void 0,toWireType:(A,g)=>void 0});},l:AB,m:A=>{A>4&&(AC.get(A).refcount+=1);},h:(A,g)=>{var C=(A=At(A,"_emval_take_value")).readValueFromPointer(g);return AI.toHandle(C)},o:()=>{X("");},q:(A,g,C)=>D.copyWithin(A,g,g+C),p:A=>{var g=D.length;A>>>=0;var C=AV();if(A>C)return  false;for(var B=(A,g)=>A+(g-A%g)%g,I=1;I<=4;I*=2){var Q=g*(1+.2/I);if(Q=Math.min(Q,A+100663296),AX(Math.min(C,B(Math.max(A,Q),65536))))return  true}return  false},k:(A,g)=>{An(A);}},Aj=function(){var A,C={a:Ax};function w(A,C){var B;return E=(Aj=A.exports).s,b(),K=Aj.u,B=Aj.t,S.unshift(B),function(A){if(q--,g.monitorRunDependencies&&g.monitorRunDependencies(q),0==q&&(V)){var C=V;V=null,C();}}(),Aj}if(q++,g.monitorRunDependencies&&g.monitorRunDependencies(q),g.instantiateWasm)try{return g.instantiateWasm(C,w)}catch(A){y(`Module.instantiateWasm callback failed with error: ${A}`),B(A);}return (A=h,Promise.resolve().then(()=>(function(A){if(A==h&&Q)return new Uint8Array(Q);var g=function(A){if(n(A))return function(A){try{for(var g=atob(A),C=new Uint8Array(g.length),B=0;B<g.length;++B)C[B]=g.charCodeAt(B);return C}catch(A){throw Error("Converting base64 string to bytes failed.")}}(A.slice(u.length))}(A);if(g)return g;throw "both async and sync fetching of the wasm failed"})(A)).then(A=>WebAssembly.instantiate(A,C)).then(A=>A).then(function(A){w(A.instance);},A=>{y(`failed to asynchronously prepare wasm: ${A}`),X(A);})).catch(B),{}}(),Av=A=>(Av=Aj.v)(A),AO=A=>(AO=Aj.w)(A),Ar=A=>(Ar=Aj.x)(A),AP=(g.__embind_initialize_bindings=()=>(g.__embind_initialize_bindings=Aj.y)(),A=>(AP=Aj.z)(A));function Az(){!(q>0)&&(function(){if(g.preRun)for("function"==typeof g.preRun&&(g.preRun=[g.preRun]);g.preRun.length;){var A;A=g.preRun.shift(),l.unshift(A);}j(l);}(),q>0||(g.setStatus?(g.setStatus("Running..."),setTimeout(function(){setTimeout(function(){g.setStatus("");},1),A();},1)):A()));function A(){!R&&(R=true,g.calledRun=true,p||(j(S),C(g),g.onRuntimeInitialized&&g.onRuntimeInitialized(),function(){if(g.postRun)for("function"==typeof g.postRun&&(g.postRun=[g.postRun]);g.postRun.length;){var A;A=g.postRun.shift(),m.unshift(A);}j(m);}()));}}if(V=function A(){R||Az(),R||(V=A);},g.preInit)for("function"==typeof g.preInit&&(g.preInit=[g.preInit]);g.preInit.length>0;)g.preInit.pop()();return Az(),g.ready});let C=new Promise(A=>{g({onRuntimeInitialized(){A(this);}});});
async function B(){let A=await C;return new Promise(g=>{setTimeout(()=>{g(A);},0);})}async function Q(A){let g=await B(),C=await g.decompress(A);if(!C)throw Error("Failed to decompress the font data.");return Uint8Array.from(C)}

var simplify$1 = {exports: {}};

(function (module) {
	(function () {	function getSqDist(p1, p2) {
	    var dx = p1.x - p2.x,
	        dy = p1.y - p2.y;
	    return dx * dx + dy * dy;
	}
	function getSqSegDist(p, p1, p2) {
	    var x = p1.x,
	        y = p1.y,
	        dx = p2.x - x,
	        dy = p2.y - y;
	    if (dx !== 0 || dy !== 0) {
	        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
	        if (t > 1) {
	            x = p2.x;
	            y = p2.y;
	        } else if (t > 0) {
	            x += dx * t;
	            y += dy * t;
	        }
	    }
	    dx = p.x - x;
	    dy = p.y - y;
	    return dx * dx + dy * dy;
	}
	function simplifyRadialDist(points, sqTolerance) {
	    var prevPoint = points[0],
	        newPoints = [prevPoint],
	        point;
	    for (var i = 1, len = points.length; i < len; i++) {
	        point = points[i];
	        if (getSqDist(point, prevPoint) > sqTolerance) {
	            newPoints.push(point);
	            prevPoint = point;
	        }
	    }
	    if (prevPoint !== point) newPoints.push(point);
	    return newPoints;
	}
	function simplifyDPStep(points, first, last, sqTolerance, simplified) {
	    var maxSqDist = sqTolerance,
	        index;
	    for (var i = first + 1; i < last; i++) {
	        var sqDist = getSqSegDist(points[i], points[first], points[last]);
	        if (sqDist > maxSqDist) {
	            index = i;
	            maxSqDist = sqDist;
	        }
	    }
	    if (maxSqDist > sqTolerance) {
	        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
	        simplified.push(points[index]);
	        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
	    }
	}
	function simplifyDouglasPeucker(points, sqTolerance) {
	    var last = points.length - 1;
	    var simplified = [points[0]];
	    simplifyDPStep(points, 0, last, sqTolerance, simplified);
	    simplified.push(points[last]);
	    return simplified;
	}
	function simplify(points, tolerance, highestQuality) {
	    if (points.length <= 2) return points;
	    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
	    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
	    points = simplifyDouglasPeucker(points, sqTolerance);
	    return points;
	}
	{
	    module.exports = simplify;
	    module.exports.default = simplify;
	}
	})();
} (simplify$1));
var simplifyExports = simplify$1.exports;
var simplify = getDefaultExportFromCjs(simplifyExports);

var fitCurve$1 = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
	    {
	        factory(module);
	    }
	})(commonjsGlobal, function (module) {
	    function _classCallCheck(instance, Constructor) {
	        if (!(instance instanceof Constructor)) {
	            throw new TypeError("Cannot call a class as a function");
	        }
	    }
	    function fitCurve(points, maxError, progressCallback) {
	        if (!Array.isArray(points)) {
	            throw new TypeError("First argument should be an array");
	        }
	        points.forEach(function (point) {
	            if (!Array.isArray(point) || point.some(function (item) {
	                return typeof item !== 'number';
	            }) || point.length !== points[0].length) {
	                throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
	            }
	        });
	        points = points.filter(function (point, i) {
	            return i === 0 || !point.every(function (val, j) {
	                return val === points[i - 1][j];
	            });
	        });
	        if (points.length < 2) {
	            return [];
	        }
	        var len = points.length;
	        var leftTangent = createTangent(points[1], points[0]);
	        var rightTangent = createTangent(points[len - 2], points[len - 1]);
	        return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
	    }
	    function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
	        var MaxIterations = 20;
	        var bezCurve,
	        u,
	        uPrime,
	        maxError, prevErr,
	        splitPoint, prevSplit,
	        centerVector, toCenterTangent, fromCenterTangent,
	        beziers,
	        dist, i;
	        if (points.length === 2) {
	            dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0;
	            bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]];
	            return [bezCurve];
	        }
	        u = chordLengthParameterize(points);
	        var _generateAndReport = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);
	        bezCurve = _generateAndReport[0];
	        maxError = _generateAndReport[1];
	        splitPoint = _generateAndReport[2];
	        if (maxError === 0 || maxError < error) {
	            return [bezCurve];
	        }
	        if (maxError < error * error) {
	            uPrime = u;
	            prevErr = maxError;
	            prevSplit = splitPoint;
	            for (i = 0; i < MaxIterations; i++) {
	                uPrime = reparameterize(bezCurve, points, uPrime);
	                var _generateAndReport2 = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);
	                bezCurve = _generateAndReport2[0];
	                maxError = _generateAndReport2[1];
	                splitPoint = _generateAndReport2[2];
	                if (maxError < error) {
	                    return [bezCurve];
	                }
	                else if (splitPoint === prevSplit) {
	                        var errChange = maxError / prevErr;
	                        if (errChange > .9999 && errChange < 1.0001) {
	                            break;
	                        }
	                    }
	                prevErr = maxError;
	                prevSplit = splitPoint;
	            }
	        }
	        beziers = [];
	        centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);
	        if (centerVector.every(function (val) {
	            return val === 0;
	        })) {
	            centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
	            var _ref = [-centerVector[1], centerVector[0]];
	            centerVector[0] = _ref[0];
	            centerVector[1] = _ref[1];
	        }
	        toCenterTangent = maths.normalize(centerVector);
	        fromCenterTangent = maths.mulItems(toCenterTangent, -1);
	        beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
	        beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
	        return beziers;
	    }	    function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
	        var bezCurve, maxError, splitPoint;
	        bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent);
	        var _computeMaxError = computeMaxError(points, bezCurve, paramsOrig);
	        maxError = _computeMaxError[0];
	        splitPoint = _computeMaxError[1];
	        if (progressCallback) {
	            progressCallback({
	                bez: bezCurve,
	                points: points,
	                params: paramsOrig,
	                maxErr: maxError,
	                maxPoint: splitPoint
	            });
	        }
	        return [bezCurve, maxError, splitPoint];
	    }
	    function generateBezier(points, parameters, leftTangent, rightTangent) {
	        var bezCurve,
	        A,
	            a,
	        C,
	            X,
	        det_C0_C1,
	            det_C0_X,
	            det_X_C1,
	        alpha_l,
	            alpha_r,
	        epsilon,
	            segLength,
	            i,
	            len,
	            tmp,
	            u,
	            ux,
	            firstPoint = points[0],
	            lastPoint = points[points.length - 1];
	        bezCurve = [firstPoint, null, null, lastPoint];
	        A = maths.zeros_Xx2x2(parameters.length);
	        for (i = 0, len = parameters.length; i < len; i++) {
	            u = parameters[i];
	            ux = 1 - u;
	            a = A[i];
	            a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));
	            a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));
	        }
	        C = [[0, 0], [0, 0]];
	        X = [0, 0];
	        for (i = 0, len = points.length; i < len; i++) {
	            u = parameters[i];
	            a = A[i];
	            C[0][0] += maths.dot(a[0], a[0]);
	            C[0][1] += maths.dot(a[0], a[1]);
	            C[1][0] += maths.dot(a[0], a[1]);
	            C[1][1] += maths.dot(a[1], a[1]);
	            tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
	            X[0] += maths.dot(a[0], tmp);
	            X[1] += maths.dot(a[1], tmp);
	        }
	        det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
	        det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
	        det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
	        alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
	        alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
	        segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
	        epsilon = 1.0e-6 * segLength;
	        if (alpha_l < epsilon || alpha_r < epsilon) {
	            bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0));
	            bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0));
	        } else {
	            bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
	            bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
	        }
	        return bezCurve;
	    }	    function reparameterize(bezier, points, parameters) {
	        return parameters.map(function (p, i) {
	            return newtonRaphsonRootFind(bezier, points[i], p);
	        });
	    }	    function newtonRaphsonRootFind(bez, point, u) {
	        var d = maths.subtract(bezier.q(bez, u), point),
	            qprime = bezier.qprime(bez, u),
	            numerator = maths.mulMatrix(d, qprime),
	            denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));
	        if (denominator === 0) {
	            return u;
	        } else {
	            return u - numerator / denominator;
	        }
	    }	    function chordLengthParameterize(points) {
	        var u = [],
	            currU,
	            prevU,
	            prevP;
	        points.forEach(function (p, i) {
	            currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
	            u.push(currU);
	            prevU = currU;
	            prevP = p;
	        });
	        u = u.map(function (x) {
	            return x / prevU;
	        });
	        return u;
	    }	    function computeMaxError(points, bez, parameters) {
	        var dist,
	        maxDist,
	        splitPoint,
	        v,
	        i, count, point, t;
	        maxDist = 0;
	        splitPoint = Math.floor(points.length / 2);
	        var t_distMap = mapTtoRelativeDistances(bez, 10);
	        for (i = 0, count = points.length; i < count; i++) {
	            point = points[i];
	            t = find_t(bez, parameters[i], t_distMap, 10);
	            v = maths.subtract(bezier.q(bez, t), point);
	            dist = v[0] * v[0] + v[1] * v[1];
	            if (dist > maxDist) {
	                maxDist = dist;
	                splitPoint = i;
	            }
	        }
	        return [maxDist, splitPoint];
	    }	    var mapTtoRelativeDistances = function mapTtoRelativeDistances(bez, B_parts) {
	        var B_t_curr;
	        var B_t_dist = [0];
	        var B_t_prev = bez[0];
	        var sumLen = 0;
	        for (var i = 1; i <= B_parts; i++) {
	            B_t_curr = bezier.q(bez, i / B_parts);
	            sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
	            B_t_dist.push(sumLen);
	            B_t_prev = B_t_curr;
	        }
	        B_t_dist = B_t_dist.map(function (x) {
	            return x / sumLen;
	        });
	        return B_t_dist;
	    };
	    function find_t(bez, param, t_distMap, B_parts) {
	        if (param < 0) {
	            return 0;
	        }
	        if (param > 1) {
	            return 1;
	        }
	        var lenMax, lenMin, tMax, tMin, t;
	        for (var i = 1; i <= B_parts; i++) {
	            if (param <= t_distMap[i]) {
	                tMin = (i - 1) / B_parts;
	                tMax = i / B_parts;
	                lenMin = t_distMap[i - 1];
	                lenMax = t_distMap[i];
	                t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
	                break;
	            }
	        }
	        return t;
	    }
	    function createTangent(pointA, pointB) {
	        return maths.normalize(maths.subtract(pointA, pointB));
	    }
	    var maths = function () {
	        function maths() {
	            _classCallCheck(this, maths);
	        }
	        maths.zeros_Xx2x2 = function zeros_Xx2x2(x) {
	            var zs = [];
	            while (x--) {
	                zs.push([0, 0]);
	            }
	            return zs;
	        };
	        maths.mulItems = function mulItems(items, multiplier) {
	            return items.map(function (x) {
	                return x * multiplier;
	            });
	        };
	        maths.mulMatrix = function mulMatrix(m1, m2) {
	            return m1.reduce(function (sum, x1, i) {
	                return sum + x1 * m2[i];
	            }, 0);
	        };
	        maths.subtract = function subtract(arr1, arr2) {
	            return arr1.map(function (x1, i) {
	                return x1 - arr2[i];
	            });
	        };
	        maths.addArrays = function addArrays(arr1, arr2) {
	            return arr1.map(function (x1, i) {
	                return x1 + arr2[i];
	            });
	        };
	        maths.addItems = function addItems(items, addition) {
	            return items.map(function (x) {
	                return x + addition;
	            });
	        };
	        maths.sum = function sum(items) {
	            return items.reduce(function (sum, x) {
	                return sum + x;
	            });
	        };
	        maths.dot = function dot(m1, m2) {
	            return maths.mulMatrix(m1, m2);
	        };
	        maths.vectorLen = function vectorLen(v) {
	            return Math.hypot.apply(Math, v);
	        };
	        maths.divItems = function divItems(items, divisor) {
	            return items.map(function (x) {
	                return x / divisor;
	            });
	        };
	        maths.squareItems = function squareItems(items) {
	            return items.map(function (x) {
	                return x * x;
	            });
	        };
	        maths.normalize = function normalize(v) {
	            return this.divItems(v, this.vectorLen(v));
	        };
	        return maths;
	    }();
	    var bezier = function () {
	        function bezier() {
	            _classCallCheck(this, bezier);
	        }
	        bezier.q = function q(ctrlPoly, t) {
	            var tx = 1.0 - t;
	            var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx),
	                pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t),
	                pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t),
	                pD = maths.mulItems(ctrlPoly[3], t * t * t);
	            return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
	        };
	        bezier.qprime = function qprime(ctrlPoly, t) {
	            var tx = 1.0 - t;
	            var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx),
	                pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t),
	                pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);
	            return maths.addArrays(maths.addArrays(pA, pB), pC);
	        };
	        bezier.qprimeprime = function qprimeprime(ctrlPoly, t) {
	            return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));
	        };
	        return bezier;
	    }();
	    module.exports = fitCurve;
	    module.exports.fitCubic = fitCubic;
	    module.exports.createTangent = createTangent;
	});
} (fitCurve$1));
var fitCurveExports = fitCurve$1.exports;
var fitCurve = getDefaultExportFromCjs(fitCurveExports);

createConsole("PathUtils", { log: false });
function perpendicularDistance(p, p1, p2) {
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    if (dx === 0 && dy === 0)
        return Math.hypot(p.x - p1.x, p.y - p1.y);
    const t = ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / (dx * dx + dy * dy);
    const projX = p1.x + t * dx;
    const projY = p1.y + t * dy;
    return Math.hypot(p.x - projX, p.y - projY);
}
function rdp(points, epsilon) {
    if (points.length < 3)
        return points;
    let maxDist = 0;
    let index = 0;
    for (let i = 1; i < points.length - 1; i++) {
        const d = perpendicularDistance(points[i], points[0], points[points.length - 1]);
        if (d > maxDist) {
            maxDist = d;
            index = i;
        }
    }
    if (maxDist > epsilon) {
        const left = rdp(points.slice(0, index + 1), epsilon);
        const right = rdp(points.slice(index), epsilon);
        return left.slice(0, -1).concat(right);
    }
    return [points[0], points[points.length - 1]];
}
function sampleQuadratic(p0, p1, p2, steps = 5) {
    const points = [];
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = (1 - t) ** 2 * p0.x + 2 * (1 - t) * t * p1.x + t ** 2 * p2.x;
        const y = (1 - t) ** 2 * p0.y + 2 * (1 - t) * t * p1.y + t ** 2 * p2.y;
        points.push({ x, y });
    }
    return points;
}
function sampleCubic(p0, p1, p2, p3, steps = 5) {
    const points = [];
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const mt = 1 - t;
        const x = mt ** 3 * p0.x +
            3 * mt ** 2 * t * p1.x +
            3 * mt * t ** 2 * p2.x +
            t ** 3 * p3.x;
        const y = mt ** 3 * p0.y +
            3 * mt ** 2 * t * p1.y +
            3 * mt * t ** 2 * p2.y +
            t ** 3 * p3.y;
        points.push({ x, y });
    }
    return points;
}
function areCollinear(p1, p2, p3, epsilon = 1e-6) {
    const dx1 = p2.x - p1.x;
    const dy1 = p2.y - p1.y;
    const dx2 = p3.x - p2.x;
    const dy2 = p3.y - p2.y;
    const cross = dx1 * dy2 - dy1 * dx2;
    return Math.abs(cross) < epsilon;
}
function simplifyCurves(curves, epsilon = 1) {
    const simplified = [];
    let cursor;
    curves.forEach((curve, index) => {
        const { controlPoints } = curve;
        const isFirst = index == 0;
        if (isFirst) {
            cursor = controlPoints[0];
        }
        switch (curve.type) {
            case "segment":
                {
                    const lastPoint = controlPoints.at(-1);
                    const lastCommand = simplified.at(-1);
                    if (lastCommand?.type == "segment" && simplified.length >= 2) {
                        const [c1, c2] = [simplified.at(-1), simplified.at(-2)];
                        if (areCollinear(c2.controlPoints.at(-1), c1.controlPoints.at(-1), lastPoint)) {
                            simplified.pop();
                        }
                    }
                    simplified.push({ ...curve });
                    cursor = lastPoint;
                }
                break;
            case "quadratic":
                {
                    const p0 = cursor;
                    const p1 = controlPoints.at(-2);
                    const p2 = controlPoints.at(-1);
                    const sampled = sampleQuadratic(p0, p1, p2, 5);
                    const simplifiedPoints = rdp(sampled, epsilon);
                    if (simplifiedPoints.length === 2) {
                        simplified.push({
                            type: "segment",
                            controlPoints: [{ x: p2.x, y: p2.y }],
                        });
                        if (isFirst) {
                            simplified.at(-1).controlPoints.unshift({ ...p0 });
                        }
                    }
                    else {
                        simplified.push({ ...curve });
                    }
                    cursor = p2;
                }
                break;
            case "cubic":
                {
                    const p0 = cursor;
                    const p1 = controlPoints.at(-3);
                    const p2 = controlPoints.at(-2);
                    const p3 = controlPoints.at(-1);
                    const sampled = sampleCubic(p0, p1, p2, p3, 5);
                    const simplifiedPoints = rdp(sampled, epsilon);
                    if (simplifiedPoints.length === 2) {
                        simplified.push({
                            type: "segment",
                            controlPoints: [{ x: p3.x, y: p3.y }],
                        });
                        if (isFirst) {
                            simplified.at(-1).controlPoints.unshift({ ...p0 });
                        }
                    }
                    else {
                        simplified.push({ ...curve });
                    }
                    cursor = p3;
                }
                break;
        }
        cursor = curve.controlPoints[curve.controlPoints.length - 1];
    });
    return simplified;
}
function simplifyPoints(points, tolerance) {
    points = simplify(points, tolerance, false);
    return points;
}
function simplifyPointsAsCubicCurveControlPoints(points, error) {
    const flatPoints = points.map(({ x, y }) => [x, y]);
    const curves = fitCurve(flatPoints, error ?? 50);
    const controlPoints = [];
    curves.forEach((curve, index) => {
        const points = curve.map(([x, y]) => ({ x, y }));
        if (index != 0) {
            points.shift();
        }
        controlPoints.push(...points);
    });
    return controlPoints;
}

var svgson_umd = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, (function () {	  var isBuffer_1 = function (obj) {
	    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	  };
	  function isBuffer (obj) {
	    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	  }
	  function isSlowBuffer (obj) {
	    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	  }
	  var toString = Object.prototype.toString;
	  var kindOf = function kindOf(val) {
	    if (typeof val === 'undefined') {
	      return 'undefined';
	    }
	    if (val === null) {
	      return 'null';
	    }
	    if (val === true || val === false || val instanceof Boolean) {
	      return 'boolean';
	    }
	    if (typeof val === 'string' || val instanceof String) {
	      return 'string';
	    }
	    if (typeof val === 'number' || val instanceof Number) {
	      return 'number';
	    }
	    if (typeof val === 'function' || val instanceof Function) {
	      return 'function';
	    }
	    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
	      return 'array';
	    }
	    if (val instanceof RegExp) {
	      return 'regexp';
	    }
	    if (val instanceof Date) {
	      return 'date';
	    }
	    var type = toString.call(val);
	    if (type === '[object RegExp]') {
	      return 'regexp';
	    }
	    if (type === '[object Date]') {
	      return 'date';
	    }
	    if (type === '[object Arguments]') {
	      return 'arguments';
	    }
	    if (type === '[object Error]') {
	      return 'error';
	    }
	    if (isBuffer_1(val)) {
	      return 'buffer';
	    }
	    if (type === '[object Set]') {
	      return 'set';
	    }
	    if (type === '[object WeakSet]') {
	      return 'weakset';
	    }
	    if (type === '[object Map]') {
	      return 'map';
	    }
	    if (type === '[object WeakMap]') {
	      return 'weakmap';
	    }
	    if (type === '[object Symbol]') {
	      return 'symbol';
	    }
	    if (type === '[object Int8Array]') {
	      return 'int8array';
	    }
	    if (type === '[object Uint8Array]') {
	      return 'uint8array';
	    }
	    if (type === '[object Uint8ClampedArray]') {
	      return 'uint8clampedarray';
	    }
	    if (type === '[object Int16Array]') {
	      return 'int16array';
	    }
	    if (type === '[object Uint16Array]') {
	      return 'uint16array';
	    }
	    if (type === '[object Int32Array]') {
	      return 'int32array';
	    }
	    if (type === '[object Uint32Array]') {
	      return 'uint32array';
	    }
	    if (type === '[object Float32Array]') {
	      return 'float32array';
	    }
	    if (type === '[object Float64Array]') {
	      return 'float64array';
	    }
	    return 'object';
	  };
	  function createCommonjsModule(fn, module) {
	  	return module = { exports: {} }, fn(module, module.exports), module.exports;
	  }
	  var renameKeys = createCommonjsModule(function (module) {
	  (function() {
	    function rename(obj, fn) {
	      if (typeof fn !== 'function') {
	        return obj;
	      }
	      var res = {};
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          res[fn(key, obj[key]) || key] = obj[key];
	        }
	      }
	      return res;
	    }
	    if (module.exports) {
	      module.exports = rename;
	    } else {
	      {
	        window.rename = rename;
	      }
	    }
	  })();
	  });
	  var deepRenameKeys = function renameDeep(obj, cb) {
	    var type = kindOf(obj);
	    if (type !== 'object' && type !== 'array') {
	      throw new Error('expected an object');
	    }
	    var res = [];
	    if (type === 'object') {
	      obj = renameKeys(obj, cb);
	      res = {};
	    }
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        var val = obj[key];
	        if (kindOf(val) === 'object' || kindOf(val) === 'array') {
	          res[key] = renameDeep(val, cb);
	        } else {
	          res[key] = val;
	        }
	      }
	    }
	    return res;
	  };
	  var eventemitter3 = createCommonjsModule(function (module) {
	  var has = Object.prototype.hasOwnProperty
	    , prefix = '~';
	  function Events() {}
	  if (Object.create) {
	    Events.prototype = Object.create(null);
	    if (!new Events().__proto__) prefix = false;
	  }
	  function EE(fn, context, once) {
	    this.fn = fn;
	    this.context = context;
	    this.once = once || false;
	  }
	  function EventEmitter() {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }
	  EventEmitter.prototype.eventNames = function eventNames() {
	    var names = []
	      , events
	      , name;
	    if (this._eventsCount === 0) return names;
	    for (name in (events = this._events)) {
	      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	    }
	    if (Object.getOwnPropertySymbols) {
	      return names.concat(Object.getOwnPropertySymbols(events));
	    }
	    return names;
	  };
	  EventEmitter.prototype.listeners = function listeners(event, exists) {
	    var evt = prefix ? prefix + event : event
	      , available = this._events[evt];
	    if (exists) return !!available;
	    if (!available) return [];
	    if (available.fn) return [available.fn];
	    for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	      ee[i] = available[i].fn;
	    }
	    return ee;
	  };
	  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	    var evt = prefix ? prefix + event : event;
	    if (!this._events[evt]) return false;
	    var listeners = this._events[evt]
	      , len = arguments.length
	      , args
	      , i;
	    if (listeners.fn) {
	      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
	      switch (len) {
	        case 1: return listeners.fn.call(listeners.context), true;
	        case 2: return listeners.fn.call(listeners.context, a1), true;
	        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	      }
	      for (i = 1, args = new Array(len -1); i < len; i++) {
	        args[i - 1] = arguments[i];
	      }
	      listeners.fn.apply(listeners.context, args);
	    } else {
	      var length = listeners.length
	        , j;
	      for (i = 0; i < length; i++) {
	        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
	        switch (len) {
	          case 1: listeners[i].fn.call(listeners[i].context); break;
	          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	          case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
	          default:
	            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	              args[j - 1] = arguments[j];
	            }
	            listeners[i].fn.apply(listeners[i].context, args);
	        }
	      }
	    }
	    return true;
	  };
	  EventEmitter.prototype.on = function on(event, fn, context) {
	    var listener = new EE(fn, context || this)
	      , evt = prefix ? prefix + event : event;
	    if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
	    else if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [this._events[evt], listener];
	    return this;
	  };
	  EventEmitter.prototype.once = function once(event, fn, context) {
	    var listener = new EE(fn, context || this, true)
	      , evt = prefix ? prefix + event : event;
	    if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
	    else if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [this._events[evt], listener];
	    return this;
	  };
	  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	    var evt = prefix ? prefix + event : event;
	    if (!this._events[evt]) return this;
	    if (!fn) {
	      if (--this._eventsCount === 0) this._events = new Events();
	      else delete this._events[evt];
	      return this;
	    }
	    var listeners = this._events[evt];
	    if (listeners.fn) {
	      if (
	           listeners.fn === fn
	        && (!once || listeners.once)
	        && (!context || listeners.context === context)
	      ) {
	        if (--this._eventsCount === 0) this._events = new Events();
	        else delete this._events[evt];
	      }
	    } else {
	      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	        if (
	             listeners[i].fn !== fn
	          || (once && !listeners[i].once)
	          || (context && listeners[i].context !== context)
	        ) {
	          events.push(listeners[i]);
	        }
	      }
	      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
	      else if (--this._eventsCount === 0) this._events = new Events();
	      else delete this._events[evt];
	    }
	    return this;
	  };
	  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	    var evt;
	    if (event) {
	      evt = prefix ? prefix + event : event;
	      if (this._events[evt]) {
	        if (--this._eventsCount === 0) this._events = new Events();
	        else delete this._events[evt];
	      }
	    } else {
	      this._events = new Events();
	      this._eventsCount = 0;
	    }
	    return this;
	  };
	  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
	  EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	    return this;
	  };
	  EventEmitter.prefixed = prefix;
	  EventEmitter.EventEmitter = EventEmitter;
	  {
	    module.exports = EventEmitter;
	  }
	  });
	  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	  var noop = function noop() {};
	  var State = {
	      data: 'state-data',
	      cdata: 'state-cdata',
	      tagBegin: 'state-tag-begin',
	      tagName: 'state-tag-name',
	      tagEnd: 'state-tag-end',
	      attributeNameStart: 'state-attribute-name-start',
	      attributeName: 'state-attribute-name',
	      attributeNameEnd: 'state-attribute-name-end',
	      attributeValueBegin: 'state-attribute-value-begin',
	      attributeValue: 'state-attribute-value'
	  };
	  var Action = {
	      lt: 'action-lt',
	      gt: 'action-gt',
	      space: 'action-space',
	      equal: 'action-equal',
	      quote: 'action-quote',
	      slash: 'action-slash',
	      char: 'action-char',
	      error: 'action-error'
	  };
	  var Type$1 = {
	      text: 'text',
	      openTag: 'open-tag',
	      closeTag: 'close-tag',
	      attributeName: 'attribute-name',
	      attributeValue: 'attribute-value'
	  };
	  var charToAction = {
	      ' ': Action.space,
	      '\t': Action.space,
	      '\n': Action.space,
	      '\r': Action.space,
	      '<': Action.lt,
	      '>': Action.gt,
	      '"': Action.quote,
	      "'": Action.quote,
	      '=': Action.equal,
	      '/': Action.slash
	  };
	  var getAction = function getAction(char) {
	      return charToAction[char] || Action.char;
	  };
	  var create$1 = function create(options) {
	      var _State$data, _State$tagBegin, _State$tagName, _State$tagEnd, _State$attributeNameS, _State$attributeName, _State$attributeNameE, _State$attributeValue, _State$attributeValue2, _lexer$stateMachine;
	      options = Object.assign({ debug: false }, options);
	      var lexer = new eventemitter3();
	      var state = State.data;
	      var data = '';
	      var tagName = '';
	      var attrName = '';
	      var attrValue = '';
	      var isClosing = '';
	      var openingQuote = '';
	      var emit = function emit(type, value) {
	          if (tagName[0] === '?' || tagName[0] === '!') {
	              return;
	          }
	          var event = { type: type, value: value };
	          if (options.debug) {
	              console.log('emit:', event);
	          }
	          lexer.emit('data', event);
	      };
	      lexer.stateMachine = (_lexer$stateMachine = {}, _defineProperty(_lexer$stateMachine, State.data, (_State$data = {}, _defineProperty(_State$data, Action.lt, function () {
	          if (data.trim()) {
	              emit(Type$1.text, data);
	          }
	          tagName = '';
	          isClosing = false;
	          state = State.tagBegin;
	      }), _defineProperty(_State$data, Action.char, function (char) {
	          data += char;
	      }), _State$data)), _defineProperty(_lexer$stateMachine, State.cdata, _defineProperty({}, Action.char, function (char) {
	          data += char;
	          if (data.substr(-3) === ']]>') {
	              emit(Type$1.text, data.slice(0, -3));
	              data = '';
	              state = State.data;
	          }
	      })), _defineProperty(_lexer$stateMachine, State.tagBegin, (_State$tagBegin = {}, _defineProperty(_State$tagBegin, Action.space, noop), _defineProperty(_State$tagBegin, Action.char, function (char) {
	          tagName = char;
	          state = State.tagName;
	      }), _defineProperty(_State$tagBegin, Action.slash, function () {
	          tagName = '';
	          isClosing = true;
	      }), _State$tagBegin)), _defineProperty(_lexer$stateMachine, State.tagName, (_State$tagName = {}, _defineProperty(_State$tagName, Action.space, function () {
	          if (isClosing) {
	              state = State.tagEnd;
	          } else {
	              state = State.attributeNameStart;
	              emit(Type$1.openTag, tagName);
	          }
	      }), _defineProperty(_State$tagName, Action.gt, function () {
	          if (isClosing) {
	              emit(Type$1.closeTag, tagName);
	          } else {
	              emit(Type$1.openTag, tagName);
	          }
	          data = '';
	          state = State.data;
	      }), _defineProperty(_State$tagName, Action.slash, function () {
	          state = State.tagEnd;
	          emit(Type$1.openTag, tagName);
	      }), _defineProperty(_State$tagName, Action.char, function (char) {
	          tagName += char;
	          if (tagName === '![CDATA[') {
	              state = State.cdata;
	              data = '';
	              tagName = '';
	          }
	      }), _State$tagName)), _defineProperty(_lexer$stateMachine, State.tagEnd, (_State$tagEnd = {}, _defineProperty(_State$tagEnd, Action.gt, function () {
	          emit(Type$1.closeTag, tagName);
	          data = '';
	          state = State.data;
	      }), _defineProperty(_State$tagEnd, Action.char, noop), _State$tagEnd)), _defineProperty(_lexer$stateMachine, State.attributeNameStart, (_State$attributeNameS = {}, _defineProperty(_State$attributeNameS, Action.char, function (char) {
	          attrName = char;
	          state = State.attributeName;
	      }), _defineProperty(_State$attributeNameS, Action.gt, function () {
	          data = '';
	          state = State.data;
	      }), _defineProperty(_State$attributeNameS, Action.space, noop), _defineProperty(_State$attributeNameS, Action.slash, function () {
	          isClosing = true;
	          state = State.tagEnd;
	      }), _State$attributeNameS)), _defineProperty(_lexer$stateMachine, State.attributeName, (_State$attributeName = {}, _defineProperty(_State$attributeName, Action.space, function () {
	          state = State.attributeNameEnd;
	      }), _defineProperty(_State$attributeName, Action.equal, function () {
	          emit(Type$1.attributeName, attrName);
	          state = State.attributeValueBegin;
	      }), _defineProperty(_State$attributeName, Action.gt, function () {
	          attrValue = '';
	          emit(Type$1.attributeName, attrName);
	          emit(Type$1.attributeValue, attrValue);
	          data = '';
	          state = State.data;
	      }), _defineProperty(_State$attributeName, Action.slash, function () {
	          isClosing = true;
	          attrValue = '';
	          emit(Type$1.attributeName, attrName);
	          emit(Type$1.attributeValue, attrValue);
	          state = State.tagEnd;
	      }), _defineProperty(_State$attributeName, Action.char, function (char) {
	          attrName += char;
	      }), _State$attributeName)), _defineProperty(_lexer$stateMachine, State.attributeNameEnd, (_State$attributeNameE = {}, _defineProperty(_State$attributeNameE, Action.space, noop), _defineProperty(_State$attributeNameE, Action.equal, function () {
	          emit(Type$1.attributeName, attrName);
	          state = State.attributeValueBegin;
	      }), _defineProperty(_State$attributeNameE, Action.gt, function () {
	          attrValue = '';
	          emit(Type$1.attributeName, attrName);
	          emit(Type$1.attributeValue, attrValue);
	          data = '';
	          state = State.data;
	      }), _defineProperty(_State$attributeNameE, Action.char, function (char) {
	          attrValue = '';
	          emit(Type$1.attributeName, attrName);
	          emit(Type$1.attributeValue, attrValue);
	          attrName = char;
	          state = State.attributeName;
	      }), _State$attributeNameE)), _defineProperty(_lexer$stateMachine, State.attributeValueBegin, (_State$attributeValue = {}, _defineProperty(_State$attributeValue, Action.space, noop), _defineProperty(_State$attributeValue, Action.quote, function (char) {
	          openingQuote = char;
	          attrValue = '';
	          state = State.attributeValue;
	      }), _defineProperty(_State$attributeValue, Action.gt, function () {
	          attrValue = '';
	          emit(Type$1.attributeValue, attrValue);
	          data = '';
	          state = State.data;
	      }), _defineProperty(_State$attributeValue, Action.char, function (char) {
	          openingQuote = '';
	          attrValue = char;
	          state = State.attributeValue;
	      }), _State$attributeValue)), _defineProperty(_lexer$stateMachine, State.attributeValue, (_State$attributeValue2 = {}, _defineProperty(_State$attributeValue2, Action.space, function (char) {
	          if (openingQuote) {
	              attrValue += char;
	          } else {
	              emit(Type$1.attributeValue, attrValue);
	              state = State.attributeNameStart;
	          }
	      }), _defineProperty(_State$attributeValue2, Action.quote, function (char) {
	          if (openingQuote === char) {
	              emit(Type$1.attributeValue, attrValue);
	              state = State.attributeNameStart;
	          } else {
	              attrValue += char;
	          }
	      }), _defineProperty(_State$attributeValue2, Action.gt, function (char) {
	          if (openingQuote) {
	              attrValue += char;
	          } else {
	              emit(Type$1.attributeValue, attrValue);
	              data = '';
	              state = State.data;
	          }
	      }), _defineProperty(_State$attributeValue2, Action.slash, function (char) {
	          if (openingQuote) {
	              attrValue += char;
	          } else {
	              emit(Type$1.attributeValue, attrValue);
	              isClosing = true;
	              state = State.tagEnd;
	          }
	      }), _defineProperty(_State$attributeValue2, Action.char, function (char) {
	          attrValue += char;
	      }), _State$attributeValue2)), _lexer$stateMachine);
	      var step = function step(char) {
	          if (options.debug) {
	              console.log(state, char);
	          }
	          var actions = lexer.stateMachine[state];
	          var action = actions[getAction(char)] || actions[Action.error] || actions[Action.char];
	          action(char);
	      };
	      lexer.write = function (str) {
	          var len = str.length;
	          for (var i = 0; i < len; i++) {
	              step(str[i]);
	          }
	      };
	      return lexer;
	  };
	  var lexer = {
	      State: State,
	      Action: Action,
	      Type: Type$1,
	      create: create$1
	  };
	  var Type = lexer.Type;
	  var NodeType = {
	      element: 'element',
	      text: 'text'
	  };
	  var createNode = function createNode(params) {
	      return Object.assign({
	          name: '',
	          type: NodeType.element,
	          value: '',
	          parent: null,
	          attributes: {},
	          children: []
	      }, params);
	  };
	  var create = function create(options) {
	      options = Object.assign({
	          stream: false,
	          parentNodes: true,
	          doneEvent: 'done',
	          tagPrefix: 'tag:',
	          emitTopLevelOnly: false,
	          debug: false
	      }, options);
	      var lexer$1 = void 0,
	          rootNode = void 0,
	          current = void 0,
	          attrName = void 0;
	      var reader = new eventemitter3();
	      var handleLexerData = function handleLexerData(data) {
	          switch (data.type) {
	              case Type.openTag:
	                  if (current === null) {
	                      current = rootNode;
	                      current.name = data.value;
	                  } else {
	                      var node = createNode({
	                          name: data.value,
	                          parent: current
	                      });
	                      current.children.push(node);
	                      current = node;
	                  }
	                  break;
	              case Type.closeTag:
	                  var parent = current.parent;
	                  if (!options.parentNodes) {
	                      current.parent = null;
	                  }
	                  if (current.name !== data.value) {
	                      break;
	                  }
	                  if (options.stream && parent === rootNode) {
	                      rootNode.children = [];
	                      current.parent = null;
	                  }
	                  if (!options.emitTopLevelOnly || parent === rootNode) {
	                      reader.emit(options.tagPrefix + current.name, current);
	                      reader.emit('tag', current.name, current);
	                  }
	                  if (current === rootNode) {
	                      lexer$1.removeAllListeners('data');
	                      reader.emit(options.doneEvent, current);
	                      rootNode = null;
	                  }
	                  current = parent;
	                  break;
	              case Type.text:
	                  if (current) {
	                      current.children.push(createNode({
	                          type: NodeType.text,
	                          value: data.value,
	                          parent: options.parentNodes ? current : null
	                      }));
	                  }
	                  break;
	              case Type.attributeName:
	                  attrName = data.value;
	                  current.attributes[attrName] = '';
	                  break;
	              case Type.attributeValue:
	                  current.attributes[attrName] = data.value;
	                  break;
	          }
	      };
	      reader.reset = function () {
	          lexer$1 = lexer.create({ debug: options.debug });
	          lexer$1.on('data', handleLexerData);
	          rootNode = createNode();
	          current = null;
	          attrName = '';
	          reader.parse = lexer$1.write;
	      };
	      reader.reset();
	      return reader;
	  };
	  var parseSync = function parseSync(xml, options) {
	      options = Object.assign({}, options, { stream: false, tagPrefix: ':' });
	      var reader = create(options);
	      var res = void 0;
	      reader.on('done', function (ast) {
	          res = ast;
	      });
	      reader.parse(xml);
	      return res;
	  };
	  var reader = {
	      parseSync: parseSync};
	  var reader_1 = reader.parseSync;
	  var parseInput = function parseInput(input) {
	    var parsed = reader_1("<root>".concat(input, "</root>"), {
	      parentNodes: false
	    });
	    var isValid = parsed.children && parsed.children.length > 0 && parsed.children.every(function (node) {
	      return node.name === 'svg';
	    });
	    if (isValid) {
	      return parsed.children.length === 1 ? parsed.children[0] : parsed.children;
	    } else {
	      throw Error('nothing to parse');
	    }
	  };
	  var camelize = function camelize(node) {
	    return deepRenameKeys(node, function (key) {
	      if (!notCamelcase(key)) {
	        return toCamelCase(key);
	      }
	      return key;
	    });
	  };
	  var toCamelCase = function toCamelCase(prop) {
	    return prop.replace(/[-|:]([a-z])/gi, function (all, letter) {
	      return letter.toUpperCase();
	    });
	  };
	  var notCamelcase = function notCamelcase(prop) {
	    return /^(data|aria)(-\w+)/.test(prop);
	  };
	  var escapeText = function escapeText(text) {
	    if (text) {
	      var str = String(text);
	      return /[&<>]/.test(str) ? "<![CDATA[".concat(str.replace(/]]>/, ']]]]><![CDATA[>'), "]]>") : str;
	    }
	    return '';
	  };
	  var escapeAttr = function escapeAttr(attr) {
	    return String(attr).replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	  };
	  var svgsonSync = function svgsonSync(input) {
	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$transformNode = _ref.transformNode,
	      transformNode = _ref$transformNode === void 0 ? function (node) {
	        return node;
	      } : _ref$transformNode,
	      _ref$camelcase = _ref.camelcase,
	      camelcase = _ref$camelcase === void 0 ? false : _ref$camelcase;
	    var applyFilters = function applyFilters(input) {
	      var n;
	      n = transformNode(input);
	      if (camelcase) {
	        n = camelize(n);
	      }
	      return n;
	    };
	    return applyFilters(parseInput(input));
	  };
	  function svgson() {
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    return new Promise(function (resolve, reject) {
	      try {
	        var res = svgsonSync.apply(void 0, args);
	        resolve(res);
	      } catch (e) {
	        reject(e);
	      }
	    });
	  }
	  var stringify = function stringify(_ast) {
	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$transformAttr = _ref.transformAttr,
	      transformAttr = _ref$transformAttr === void 0 ? function (key, value, escape) {
	        return "".concat(key, "=\"").concat(escape(value), "\"");
	      } : _ref$transformAttr,
	      _ref$transformNode = _ref.transformNode,
	      transformNode = _ref$transformNode === void 0 ? function (node) {
	        return node;
	      } : _ref$transformNode,
	      _ref$selfClose = _ref.selfClose,
	      selfClose = _ref$selfClose === void 0 ? true : _ref$selfClose;
	    if (Array.isArray(_ast)) {
	      return _ast.map(function (ast) {
	        return stringify(ast, {
	          transformAttr: transformAttr,
	          selfClose: selfClose,
	          transformNode: transformNode
	        });
	      }).join('');
	    }
	    var ast = transformNode(_ast);
	    if (ast.type === 'text') {
	      return escapeText(ast.value);
	    }
	    var attributes = '';
	    for (var attr in ast.attributes) {
	      var attrStr = transformAttr(attr, ast.attributes[attr], escapeAttr, ast.name);
	      attributes += attrStr ? " ".concat(attrStr) : '';
	    }
	    return ast.children && ast.children.length > 0 || !selfClose ? "<".concat(ast.name).concat(attributes, ">").concat(stringify(ast.children, {
	      transformAttr: transformAttr,
	      transformNode: transformNode,
	      selfClose: selfClose
	    }), "</").concat(ast.name, ">") : "<".concat(ast.name).concat(attributes, "/>");
	  };
	  var indexUmd = Object.assign({}, {
	    parse: svgson,
	    parseSync: svgsonSync,
	    stringify: stringify
	  });
	  return indexUmd;
	}));
} (svgson_umd));
var svgson_umdExports = svgson_umd.exports;
getDefaultExportFromCjs(svgson_umdExports);

const WSP = ' ';
function encodeSVGPath(commands) {
    let str = '';
    if (!Array.isArray(commands)) {
        commands = [commands];
    }
    for (let i = 0; i < commands.length; i++) {
        const command = commands[i];
        if (command.type === SVGPathData.CLOSE_PATH) {
            str += 'z';
        }
        else if (command.type === SVGPathData.HORIZ_LINE_TO) {
            str += (command.relative ? 'h' : 'H') + command.x;
        }
        else if (command.type === SVGPathData.VERT_LINE_TO) {
            str += (command.relative ? 'v' : 'V') + command.y;
        }
        else if (command.type === SVGPathData.MOVE_TO) {
            str += (command.relative ? 'm' : 'M') + command.x + WSP + command.y;
        }
        else if (command.type === SVGPathData.LINE_TO) {
            str += (command.relative ? 'l' : 'L') + command.x + WSP + command.y;
        }
        else if (command.type === SVGPathData.CURVE_TO) {
            str +=
                (command.relative ? 'c' : 'C') +
                    command.x1 +
                    WSP +
                    command.y1 +
                    WSP +
                    command.x2 +
                    WSP +
                    command.y2 +
                    WSP +
                    command.x +
                    WSP +
                    command.y;
        }
        else if (command.type === SVGPathData.SMOOTH_CURVE_TO) {
            str +=
                (command.relative ? 's' : 'S') +
                    command.x2 +
                    WSP +
                    command.y2 +
                    WSP +
                    command.x +
                    WSP +
                    command.y;
        }
        else if (command.type === SVGPathData.QUAD_TO) {
            str +=
                (command.relative ? 'q' : 'Q') +
                    command.x1 +
                    WSP +
                    command.y1 +
                    WSP +
                    command.x +
                    WSP +
                    command.y;
        }
        else if (command.type === SVGPathData.SMOOTH_QUAD_TO) {
            str += (command.relative ? 't' : 'T') + command.x + WSP + command.y;
        }
        else if (command.type === SVGPathData.ARC) {
            str +=
                (command.relative ? 'a' : 'A') +
                    command.rX +
                    WSP +
                    command.rY +
                    WSP +
                    command.xRot +
                    WSP +
                    +command.lArcFlag +
                    WSP +
                    +command.sweepFlag +
                    WSP +
                    command.x +
                    WSP +
                    command.y;
        }
        else {
            throw new Error(`Unexpected command type "${command?.type}" at index ${i}.`);
        }
    }
    return str;
}

function rotate([x, y], rad) {
    return [
        x * Math.cos(rad) - y * Math.sin(rad),
        x * Math.sin(rad) + y * Math.cos(rad),
    ];
}
function assertNumbers(...numbers) {
    {
        for (let i = 0; i < numbers.length; i++) {
            if ('number' !== typeof numbers[i]) {
                throw new Error(`assertNumbers arguments[${i}] is not a number. ${typeof numbers[i]} == typeof ${numbers[i]}`);
            }
        }
    }
    return true;
}
const PI = Math.PI;
function annotateArcCommand(c, x1, y1) {
    c.lArcFlag = 0 === c.lArcFlag ? 0 : 1;
    c.sweepFlag = 0 === c.sweepFlag ? 0 : 1;
    let { rX, rY } = c;
    const { x, y } = c;
    if (Math.abs(rX) < 1e-10 || Math.abs(rY) < 1e-10) {
        c.rX = 0;
        c.rY = 0;
        c.cX = (x1 + x) / 2;
        c.cY = (y1 + y) / 2;
        c.phi1 = 0;
        c.phi2 = 0;
        return;
    }
    rX = Math.abs(c.rX);
    rY = Math.abs(c.rY);
    const xRotRad = (c.xRot / 180) * PI;
    const [x1_, y1_] = rotate([(x1 - x) / 2, (y1 - y) / 2], -xRotRad);
    const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);
    if (1 < testValue) {
        rX *= Math.sqrt(testValue);
        rY *= Math.sqrt(testValue);
    }
    c.rX = rX;
    c.rY = rY;
    const c_ScaleTemp = Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2);
    const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) *
        Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));
    const cx_ = ((rX * y1_) / rY) * c_Scale;
    const cy_ = ((-rY * x1_) / rX) * c_Scale;
    const cRot = rotate([cx_, cy_], xRotRad);
    c.cX = cRot[0] + (x1 + x) / 2;
    c.cY = cRot[1] + (y1 + y) / 2;
    c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);
    c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);
    if (0 === c.sweepFlag && c.phi2 > c.phi1) {
        c.phi2 -= 2 * PI;
    }
    if (1 === c.sweepFlag && c.phi2 < c.phi1) {
        c.phi2 += 2 * PI;
    }
    c.phi1 *= 180 / PI;
    c.phi2 *= 180 / PI;
}
function intersectionUnitCircleLine(a, b, c) {
    assertNumbers(a, b, c);
    const termSqr = a * a + b * b - c * c;
    if (0 > termSqr) {
        return [];
    }
    else if (0 === termSqr) {
        return [[(a * c) / (a * a + b * b), (b * c) / (a * a + b * b)]];
    }
    const term = Math.sqrt(termSqr);
    return [
        [
            (a * c + b * term) / (a * a + b * b),
            (b * c - a * term) / (a * a + b * b),
        ],
        [
            (a * c - b * term) / (a * a + b * b),
            (b * c + a * term) / (a * a + b * b),
        ],
    ];
}
const DEG = Math.PI / 180;
function lerp(a, b, t) {
    return (1 - t) * a + t * b;
}
function arcAt(c, x1, x2, phiDeg) {
    return (c + Math.cos((phiDeg / 180) * PI) * x1 + Math.sin((phiDeg / 180) * PI) * x2);
}
function bezierRoot(x0, x1, x2, x3) {
    const EPS = 1e-6;
    const x01 = x1 - x0;
    const x12 = x2 - x1;
    const x23 = x3 - x2;
    const a = 3 * x01 + 3 * x23 - 6 * x12;
    const b = (x12 - x01) * 6;
    const c = 3 * x01;
    if (Math.abs(a) < EPS) {
        return Math.abs(b) < EPS ? [] : [-c / b];
    }
    return pqFormula(b / a, c / a, EPS);
}
function bezierAt(x0, x1, x2, x3, t) {
    const s = 1 - t;
    const c0 = s * s * s;
    const c1 = 3 * s * s * t;
    const c2 = 3 * s * t * t;
    const c3 = t * t * t;
    return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;
}
function pqFormula(p, q, PRECISION = 1e-6) {
    const discriminantX4 = (p * p) / 4 - q;
    if (discriminantX4 < -PRECISION) {
        return [];
    }
    else if (discriminantX4 <= PRECISION) {
        return [-p / 2];
    }
    const root = Math.sqrt(discriminantX4);
    return [-(p / 2) - root, -(p / 2) + root];
}
function a2c(arc, x0, y0) {
    if (!arc.cX) {
        annotateArcCommand(arc, x0, y0);
    }
    const xRotRad = (arc.xRot / 180) * PI;
    if (Math.abs(arc.rX) < 1e-10 || Math.abs(arc.rY) < 1e-10) {
        return [
            {
                relative: arc.relative,
                type: SVGPathData.CURVE_TO,
                x1: x0 + (arc.x - x0) / 3,
                y1: y0 + (arc.y - y0) / 3,
                x2: x0 + (2 * (arc.x - x0)) / 3,
                y2: y0 + (2 * (arc.y - y0)) / 3,
                x: arc.x,
                y: arc.y,
            },
        ];
    }
    const phiMin = Math.min(arc.phi1, arc.phi2), phiMax = Math.max(arc.phi1, arc.phi2), deltaPhi = phiMax - phiMin;
    const partCount = Math.ceil(deltaPhi / 90);
    const result = new Array(partCount);
    let prevX = x0;
    let prevY = y0;
    const transform = (x, y) => {
        const [xTemp, yTemp] = rotate([x * arc.rX, y * arc.rY], xRotRad);
        return [arc.cX + xTemp, arc.cY + yTemp];
    };
    for (let i = 0; i < partCount; i++) {
        const phiStart = lerp(arc.phi1, arc.phi2, i / partCount);
        const phiEnd = lerp(arc.phi1, arc.phi2, (i + 1) / partCount);
        const deltaPhi = phiEnd - phiStart;
        const f = (4 / 3) * Math.tan((deltaPhi * DEG) / 4);
        const x1 = Math.cos(phiStart * DEG) - f * Math.sin(phiStart * DEG);
        const y1 = Math.sin(phiStart * DEG) + f * Math.cos(phiStart * DEG);
        const x = Math.cos(phiEnd * DEG);
        const y = Math.sin(phiEnd * DEG);
        const x2 = x + f * y;
        const y2 = y - f * x;
        const cp1 = transform(x1, y1);
        const cp2 = transform(x2, y2);
        const end = transform(x, y);
        const command = {
            relative: arc.relative,
            type: SVGPathData.CURVE_TO,
            x: end[0],
            y: end[1],
            x1: cp1[0],
            y1: cp1[1],
            x2: cp2[0],
            y2: cp2[1],
        };
        if (arc.relative) {
            command.x1 -= prevX;
            command.y1 -= prevY;
            command.x2 -= prevX;
            command.y2 -= prevY;
            command.x -= prevX;
            command.y -= prevY;
        }
        prevX = end[0];
        prevY = end[1];
        result[i] = command;
    }
    return result;
}
function arePointsCollinear(p1, p2, p3) {
    const v1x = p2[0] - p1[0];
    const v1y = p2[1] - p1[1];
    const v2x = p3[0] - p1[0];
    const v2y = p3[1] - p1[1];
    const cross = v1x * v2y - v1y * v2x;
    const isCollinear = Math.abs(cross) < 1e-10;
    if (!isCollinear)
        return false;
    const dot = v1x * v2x + v1y * v2y;
    const lenSqV1 = v1x * v1x + v1y * v1y;
    const lenSqV2 = v2x * v2x + v2y * v2y;
    return 0 <= dot && dot <= lenSqV2 && lenSqV1 <= lenSqV2;
}

function REMOVE_COLLINEAR(commands) {
    if (commands.length <= 2)
        return commands;
    const results = [];
    const points = commands.map(SVGPathDataTransformer.INFO((cmd, pXAbs, pYAbs) => {
        const isRelatve = 'relative' in cmd && cmd.relative;
        return [
            'x' in cmd ? cmd.x + (isRelatve ? pXAbs : 0) : pXAbs,
            'y' in cmd ? cmd.y + (isRelatve ? pYAbs : 0) : pYAbs,
        ];
    }));
    let prevPoint = points[0];
    results.push(commands[0]);
    for (let i = 1; i < commands.length; i++) {
        const cmd = commands[i];
        const nextCmd = commands[i + 1];
        if (i < commands.length - 1 &&
            nextCmd &&
            cmd.type & SVGPathData.LINE_COMMANDS &&
            nextCmd.type & SVGPathData.LINE_COMMANDS) {
            const nextPoint = points[i + 1];
            if (arePointsCollinear(prevPoint, points[i], nextPoint)) {
                if ('relative' in nextCmd && nextCmd.relative) {
                    if ('x' in nextCmd)
                        nextCmd.x = nextPoint[0] - prevPoint[0];
                    if ('y' in nextCmd)
                        nextCmd.y = nextPoint[1] - prevPoint[1];
                }
                continue;
            }
        }
        results.push(cmd);
        prevPoint = points[i];
    }
    return results;
}

function REVERSE_PATH(commands, preserveSubpathOrder = true) {
    if (commands.length < 2)
        return commands;
    const normalized = SVGPathDataTransformer.INFO((command, px, py) => ({
        ...command,
        x: command.x ?? px,
        y: command.y ?? py,
        relative: command.relative ?? false,
    }));
    const result = [];
    let processing = [];
    for (const original of commands) {
        const cmd = normalized(original);
        if (cmd.type === SVGPathData.MOVE_TO && processing.length > 0) {
            if (preserveSubpathOrder) {
                result.push(...reverseSubpath(processing));
            }
            else {
                result.unshift(...reverseSubpath(processing));
            }
            processing = [];
        }
        processing.push(cmd);
    }
    if (processing.length > 0) {
        if (preserveSubpathOrder) {
            result.push(...reverseSubpath(processing));
        }
        else {
            result.unshift(...reverseSubpath(processing));
        }
    }
    return result;
}
function reverseSubpath(commands) {
    const isExplicitlyClosed = commands[commands.length - 1]?.type === SVGPathData.CLOSE_PATH;
    const startPointIndex = isExplicitlyClosed
        ? commands.length - 2
        : commands.length - 1;
    const reversed = [
        {
            type: SVGPathData.MOVE_TO,
            relative: false,
            x: commands[startPointIndex].x,
            y: commands[startPointIndex].y,
        },
    ];
    for (let i = startPointIndex; i > 0; i--) {
        const curCmd = commands[i];
        const prevPoint = commands[i - 1];
        if (curCmd.relative) {
            throw new Error('Relative command are not supported convert first with `toAbs()`');
        }
        switch (curCmd.type) {
            case SVGPathData.HORIZ_LINE_TO:
                reversed.push({
                    type: SVGPathData.HORIZ_LINE_TO,
                    relative: false,
                    x: prevPoint.x,
                });
                break;
            case SVGPathData.VERT_LINE_TO:
                reversed.push({
                    type: SVGPathData.VERT_LINE_TO,
                    relative: false,
                    y: prevPoint.y,
                });
                break;
            case SVGPathData.LINE_TO:
            case SVGPathData.MOVE_TO:
                reversed.push({
                    type: SVGPathData.LINE_TO,
                    relative: false,
                    x: prevPoint.x,
                    y: prevPoint.y,
                });
                break;
            case SVGPathData.CURVE_TO:
                reversed.push({
                    type: SVGPathData.CURVE_TO,
                    relative: false,
                    x: prevPoint.x,
                    y: prevPoint.y,
                    x1: curCmd.x2,
                    y1: curCmd.y2,
                    x2: curCmd.x1,
                    y2: curCmd.y1,
                });
                break;
            case SVGPathData.SMOOTH_CURVE_TO:
                throw new Error(`Unsupported command: S (smooth cubic bezier)`);
            case SVGPathData.SMOOTH_QUAD_TO:
                throw new Error(`Unsupported command: T (smooth quadratic bezier)`);
            case SVGPathData.ARC:
                throw new Error(`Unsupported command: A (arc)`);
            case SVGPathData.QUAD_TO:
                throw new Error(`Unsupported command: Q (quadratic bezier)`);
        }
    }
    if (isExplicitlyClosed) {
        reversed.push({ type: SVGPathData.CLOSE_PATH });
    }
    return reversed;
}

function ROUND(roundVal = 1e13) {
    assertNumbers(roundVal);
    function rf(val) {
        return Math.round(val * roundVal) / roundVal;
    }
    return function round(command) {
        if ('x1' in command && 'undefined' !== typeof command.x1) {
            command.x1 = rf(command.x1);
        }
        if ('y1' in command && 'undefined' !== typeof command.y1) {
            command.y1 = rf(command.y1);
        }
        if ('x2' in command && 'undefined' !== typeof command.x2) {
            command.x2 = rf(command.x2);
        }
        if ('y2' in command && 'undefined' !== typeof command.y2) {
            command.y2 = rf(command.y2);
        }
        if ('x' in command && 'undefined' !== typeof command.x) {
            command.x = rf(command.x);
        }
        if ('y' in command && 'undefined' !== typeof command.y) {
            command.y = rf(command.y);
        }
        if ('rX' in command && 'undefined' !== typeof command.rX) {
            command.rX = rf(command.rX);
        }
        if ('rY' in command && 'undefined' !== typeof command.rY) {
            command.rY = rf(command.rY);
        }
        return command;
    };
}
function TO_ABS() {
    return INFO((command, prevX, prevY) => {
        if (command.relative) {
            if ('undefined' !== typeof command.x1) {
                command.x1 += prevX;
            }
            if ('undefined' !== typeof command.y1) {
                command.y1 += prevY;
            }
            if ('undefined' !== typeof command.x2) {
                command.x2 += prevX;
            }
            if ('undefined' !== typeof command.y2) {
                command.y2 += prevY;
            }
            if ('undefined' !== typeof command.x) {
                command.x += prevX;
            }
            if ('undefined' !== typeof command.y) {
                command.y += prevY;
            }
            command.relative = false;
        }
        return command;
    });
}
function TO_REL() {
    return INFO((command, prevX, prevY) => {
        if (!command.relative) {
            if ('undefined' !== typeof command.x1) {
                command.x1 -= prevX;
            }
            if ('undefined' !== typeof command.y1) {
                command.y1 -= prevY;
            }
            if ('undefined' !== typeof command.x2) {
                command.x2 -= prevX;
            }
            if ('undefined' !== typeof command.y2) {
                command.y2 -= prevY;
            }
            if ('undefined' !== typeof command.x) {
                command.x -= prevX;
            }
            if ('undefined' !== typeof command.y) {
                command.y -= prevY;
            }
            command.relative = true;
        }
        return command;
    });
}
function NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true, normalizeC = true) {
    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {
        if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) {
            throw new Error('path must start with moveto');
        }
        if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {
            command.type = SVGPathData.LINE_TO;
            command.y = command.relative ? 0 : prevY;
        }
        if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {
            command.type = SVGPathData.LINE_TO;
            command.x = command.relative ? 0 : prevX;
        }
        if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {
            command.type = SVGPathData.LINE_TO;
            command.x = command.relative ? pathStartX - prevX : pathStartX;
            command.y = command.relative ? pathStartY - prevY : pathStartY;
        }
        if (command.type & SVGPathData.ARC &&
            (0 === command.rX || 0 === command.rY)) {
            command.type = SVGPathData.LINE_TO;
            delete command.rX;
            delete command.rY;
            delete command.xRot;
            delete command.lArcFlag;
            delete command.sweepFlag;
        }
        if (normalizeC && command.type & SVGPathData.QUAD_TO) {
            const startPoint = [prevX, prevY];
            const controlPoint = command.relative
                ? [prevX + command.x1, prevY + command.y1]
                : [command.x1, command.y1];
            const endPoint = command.relative
                ? [prevX + command.x, prevY + command.y]
                : [command.x, command.y];
            if (arePointsCollinear(startPoint, controlPoint, endPoint)) {
                command.type = SVGPathData.LINE_TO;
                delete command.x1;
                delete command.y1;
            }
        }
        if (normalizeC && command.type & SVGPathData.CURVE_TO) {
            const startPoint = [prevX, prevY];
            const control1 = command.relative
                ? [prevX + command.x1, prevY + command.y1]
                : [command.x1, command.y1];
            const control2 = command.relative
                ? [prevX + command.x2, prevY + command.y2]
                : [command.x2, command.y2];
            const endPoint = command.relative
                ? [prevX + command.x, prevY + command.y]
                : [command.x, command.y];
            if (arePointsCollinear(startPoint, control1, endPoint) &&
                arePointsCollinear(startPoint, control2, endPoint)) {
                command.type = SVGPathData.LINE_TO;
                delete command.x1;
                delete command.y1;
                delete command.x2;
                delete command.y2;
            }
        }
        return command;
    });
}
function NORMALIZE_ST() {
    let prevCurveC2X = NaN;
    let prevCurveC2Y = NaN;
    let prevQuadCX = NaN;
    let prevQuadCY = NaN;
    return INFO((command, prevX, prevY) => {
        if (command.type & SVGPathData.SMOOTH_CURVE_TO) {
            command.type = SVGPathData.CURVE_TO;
            prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;
            prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;
            command.x1 = command.relative
                ? prevX - prevCurveC2X
                : 2 * prevX - prevCurveC2X;
            command.y1 = command.relative
                ? prevY - prevCurveC2Y
                : 2 * prevY - prevCurveC2Y;
        }
        if (command.type & SVGPathData.CURVE_TO) {
            prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;
            prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;
        }
        else {
            prevCurveC2X = NaN;
            prevCurveC2Y = NaN;
        }
        if (command.type & SVGPathData.SMOOTH_QUAD_TO) {
            command.type = SVGPathData.QUAD_TO;
            prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;
            prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;
            command.x1 = command.relative
                ? prevX - prevQuadCX
                : 2 * prevX - prevQuadCX;
            command.y1 = command.relative
                ? prevY - prevQuadCY
                : 2 * prevY - prevQuadCY;
        }
        if (command.type & SVGPathData.QUAD_TO) {
            prevQuadCX = command.relative ? prevX + command.x1 : command.x1;
            prevQuadCY = command.relative ? prevY + command.y1 : command.y1;
        }
        else {
            prevQuadCX = NaN;
            prevQuadCY = NaN;
        }
        return command;
    });
}
function QT_TO_C() {
    let prevQuadX1 = NaN;
    let prevQuadY1 = NaN;
    return INFO((command, prevX, prevY) => {
        if (command.type & SVGPathData.SMOOTH_QUAD_TO) {
            command.type = SVGPathData.QUAD_TO;
            prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;
            prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;
            command.x1 = command.relative
                ? prevX - prevQuadX1
                : 2 * prevX - prevQuadX1;
            command.y1 = command.relative
                ? prevY - prevQuadY1
                : 2 * prevY - prevQuadY1;
        }
        if (command.type & SVGPathData.QUAD_TO) {
            prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;
            prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;
            const x1 = command.x1;
            const y1 = command.y1;
            command.type = SVGPathData.CURVE_TO;
            command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;
            command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;
            command.x2 = (command.x + x1 * 2) / 3;
            command.y2 = (command.y + y1 * 2) / 3;
        }
        else {
            prevQuadX1 = NaN;
            prevQuadY1 = NaN;
        }
        return command;
    });
}
function INFO(f) {
    let prevXAbs = 0;
    let prevYAbs = 0;
    let pathStartXAbs = NaN;
    let pathStartYAbs = NaN;
    return function transform(command) {
        if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) {
            throw new Error('path must start with moveto');
        }
        const result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);
        if (command.type & SVGPathData.CLOSE_PATH) {
            prevXAbs = pathStartXAbs;
            prevYAbs = pathStartYAbs;
        }
        if ('x' in command && 'undefined' !== typeof command.x) {
            prevXAbs = command.relative ? prevXAbs + command.x : command.x;
        }
        if ('y' in command && 'undefined' !== typeof command.y) {
            prevYAbs = command.relative ? prevYAbs + command.y : command.y;
        }
        if (command.type & SVGPathData.MOVE_TO) {
            pathStartXAbs = prevXAbs;
            pathStartYAbs = prevYAbs;
        }
        return result;
    };
}
function SANITIZE(EPS = 0) {
    assertNumbers(EPS);
    let prevCurveC2X = NaN;
    let prevCurveC2Y = NaN;
    let prevQuadCX = NaN;
    let prevQuadCY = NaN;
    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {
        const abs = Math.abs;
        let skip = false;
        let x1Rel = 0;
        let y1Rel = 0;
        if (command.type & SVGPathData.SMOOTH_CURVE_TO) {
            x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;
            y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;
        }
        if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {
            prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;
            prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;
        }
        else {
            prevCurveC2X = NaN;
            prevCurveC2Y = NaN;
        }
        if (command.type & SVGPathData.SMOOTH_QUAD_TO) {
            prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;
            prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;
        }
        else if (command.type & SVGPathData.QUAD_TO) {
            prevQuadCX = command.relative ? prevX + command.x1 : command.x1;
            prevQuadCY = command.relative ? prevY + command.y1 : command.y2;
        }
        else {
            prevQuadCX = NaN;
            prevQuadCY = NaN;
        }
        if (command.type & SVGPathData.LINE_COMMANDS ||
            (command.type & SVGPathData.ARC &&
                (0 === command.rX || 0 === command.rY || !command.lArcFlag)) ||
            command.type & SVGPathData.CURVE_TO ||
            command.type & SVGPathData.SMOOTH_CURVE_TO ||
            command.type & SVGPathData.QUAD_TO ||
            command.type & SVGPathData.SMOOTH_QUAD_TO) {
            const xRel = 'undefined' === typeof command.x
                ? 0
                : command.relative
                    ? command.x
                    : command.x - prevX;
            const yRel = 'undefined' === typeof command.y
                ? 0
                : command.relative
                    ? command.y
                    : command.y - prevY;
            x1Rel = !isNaN(prevQuadCX)
                ? prevQuadCX - prevX
                : 'undefined' === typeof command.x1
                    ? x1Rel
                    : command.relative
                        ? command.x
                        : command.x1 - prevX;
            y1Rel = !isNaN(prevQuadCY)
                ? prevQuadCY - prevY
                : 'undefined' === typeof command.y1
                    ? y1Rel
                    : command.relative
                        ? command.y
                        : command.y1 - prevY;
            const x2Rel = 'undefined' === typeof command.x2
                ? 0
                : command.relative
                    ? command.x
                    : command.x2 - prevX;
            const y2Rel = 'undefined' === typeof command.y2
                ? 0
                : command.relative
                    ? command.y
                    : command.y2 - prevY;
            if (abs(xRel) <= EPS &&
                abs(yRel) <= EPS &&
                abs(x1Rel) <= EPS &&
                abs(y1Rel) <= EPS &&
                abs(x2Rel) <= EPS &&
                abs(y2Rel) <= EPS) {
                skip = true;
            }
        }
        if (command.type & SVGPathData.CLOSE_PATH) {
            if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) {
                skip = true;
            }
        }
        return skip ? [] : command;
    });
}
function MATRIX(a, b, c, d, e, f) {
    assertNumbers(a, b, c, d, e, f);
    return INFO((command, prevX, prevY, pathStartX) => {
        const origX1 = command.x1;
        const origX2 = command.x2;
        const comRel = command.relative && !isNaN(pathStartX);
        const x = 'undefined' !== typeof command.x ? command.x : comRel ? 0 : prevX;
        const y = 'undefined' !== typeof command.y ? command.y : comRel ? 0 : prevY;
        if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {
            command.type = SVGPathData.LINE_TO;
            command.y = command.relative ? 0 : prevY;
        }
        if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {
            command.type = SVGPathData.LINE_TO;
            command.x = command.relative ? 0 : prevX;
        }
        if ('undefined' !== typeof command.x) {
            command.x = command.x * a + y * c + (comRel ? 0 : e);
        }
        if ('undefined' !== typeof command.y) {
            command.y = x * b + command.y * d + (comRel ? 0 : f);
        }
        if ('undefined' !== typeof command.x1) {
            command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);
        }
        if ('undefined' !== typeof command.y1) {
            command.y1 = origX1 * b + command.y1 * d + (comRel ? 0 : f);
        }
        if ('undefined' !== typeof command.x2) {
            command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);
        }
        if ('undefined' !== typeof command.y2) {
            command.y2 = origX2 * b + command.y2 * d + (comRel ? 0 : f);
        }
        function sqr(x) {
            return x * x;
        }
        const det = a * d - b * c;
        if ('undefined' !== typeof command.xRot) {
            if (1 !== a || 0 !== b || 0 !== c || 1 !== d) {
                if (0 === det) {
                    delete command.rX;
                    delete command.rY;
                    delete command.xRot;
                    delete command.lArcFlag;
                    delete command.sweepFlag;
                    command.type = SVGPathData.LINE_TO;
                }
                else {
                    const xRot = (command.xRot * Math.PI) / 180;
                    const sinRot = Math.sin(xRot);
                    const cosRot = Math.cos(xRot);
                    const xCurve = 1 / sqr(command.rX);
                    const yCurve = 1 / sqr(command.rY);
                    const A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;
                    const B = 2 * sinRot * cosRot * (xCurve - yCurve);
                    const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;
                    const A1 = A * d * d - B * b * d + C * b * b;
                    const B1 = B * (a * d + b * c) - 2 * (A * c * d + C * a * b);
                    const C1 = A * c * c - B * a * c + C * a * a;
                    const newXRot = ((Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI) / 2;
                    const newSinRot = Math.sin(newXRot);
                    const newCosRot = Math.cos(newXRot);
                    command.rX =
                        Math.abs(det) /
                            Math.sqrt(A1 * sqr(newCosRot) +
                                B1 * newSinRot * newCosRot +
                                C1 * sqr(newSinRot));
                    command.rY =
                        Math.abs(det) /
                            Math.sqrt(A1 * sqr(newSinRot) -
                                B1 * newSinRot * newCosRot +
                                C1 * sqr(newCosRot));
                    command.xRot = (newXRot * 180) / Math.PI;
                }
            }
        }
        if ('undefined' !== typeof command.sweepFlag && 0 > det) {
            command.sweepFlag = +!command.sweepFlag;
        }
        return command;
    });
}
function ROTATE(a, x = 0, y = 0) {
    assertNumbers(a, x, y);
    const sin = Math.sin(a);
    const cos = Math.cos(a);
    return MATRIX(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);
}
function TRANSLATE(dX, dY = 0) {
    assertNumbers(dX, dY);
    return MATRIX(1, 0, 0, 1, dX, dY);
}
function SCALE(dX, dY = dX) {
    assertNumbers(dX, dY);
    return MATRIX(dX, 0, 0, dY, 0, 0);
}
function SKEW_X(a) {
    assertNumbers(a);
    return MATRIX(1, 0, Math.tan(a), 1, 0, 0);
}
function SKEW_Y(a) {
    assertNumbers(a);
    return MATRIX(1, Math.tan(a), 0, 1, 0, 0);
}
function X_AXIS_SYMMETRY(xOffset = 0) {
    assertNumbers(xOffset);
    return MATRIX(-1, 0, 0, 1, xOffset, 0);
}
function Y_AXIS_SYMMETRY(yOffset = 0) {
    assertNumbers(yOffset);
    return MATRIX(1, 0, 0, -1, 0, yOffset);
}
function A_TO_C() {
    return INFO((command, prevX, prevY) => {
        if (SVGPathData.ARC === command.type) {
            return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);
        }
        return command;
    });
}
function ANNOTATE_ARCS() {
    return INFO((c, x1, y1) => {
        if (c.relative) {
            x1 = 0;
            y1 = 0;
        }
        if (SVGPathData.ARC === c.type) {
            annotateArcCommand(c, x1, y1);
        }
        return c;
    });
}
function CLONE() {
    return (c) => {
        return { ...c };
    };
}
function CALCULATE_BOUNDS() {
    const clone = CLONE();
    const toAbs = TO_ABS();
    const qtToC = QT_TO_C();
    const normST = NORMALIZE_ST();
    const f = INFO((command, prevXAbs, prevYAbs) => {
        const c = normST(qtToC(toAbs(clone(command))));
        function fixX(absX) {
            if (absX > f.maxX) {
                f.maxX = absX;
            }
            if (absX < f.minX) {
                f.minX = absX;
            }
        }
        function fixY(absY) {
            if (absY > f.maxY) {
                f.maxY = absY;
            }
            if (absY < f.minY) {
                f.minY = absY;
            }
        }
        if (c.type & SVGPathData.DRAWING_COMMANDS) {
            fixX(prevXAbs);
            fixY(prevYAbs);
        }
        if (c.type & SVGPathData.HORIZ_LINE_TO) {
            fixX(c.x);
        }
        if (c.type & SVGPathData.VERT_LINE_TO) {
            fixY(c.y);
        }
        if (c.type & SVGPathData.LINE_TO) {
            fixX(c.x);
            fixY(c.y);
        }
        if (c.type & SVGPathData.CURVE_TO) {
            fixX(c.x);
            fixY(c.y);
            const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);
            for (const derivRoot of xDerivRoots) {
                if (0 < derivRoot && 1 > derivRoot) {
                    fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));
                }
            }
            const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);
            for (const derivRoot of yDerivRoots) {
                if (0 < derivRoot && 1 > derivRoot) {
                    fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));
                }
            }
        }
        if (c.type & SVGPathData.ARC) {
            fixX(c.x);
            fixY(c.y);
            annotateArcCommand(c, prevXAbs, prevYAbs);
            const xRotRad = (c.xRot / 180) * Math.PI;
            const x0 = Math.cos(xRotRad) * c.rX;
            const y0 = Math.sin(xRotRad) * c.rX;
            const x90 = -Math.sin(xRotRad) * c.rY;
            const y90 = Math.cos(xRotRad) * c.rY;
            const [phiMin, phiMax] = c.phi1 < c.phi2
                ? [c.phi1, c.phi2]
                : -180 > c.phi2
                    ? [c.phi2 + 360, c.phi1 + 360]
                    : [c.phi2, c.phi1];
            const normalizeXiEta = ([xi, eta]) => {
                const phiRad = Math.atan2(eta, xi);
                const phi = (phiRad * 180) / Math.PI;
                return phi < phiMin ? phi + 360 : phi;
            };
            const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);
            for (const derivRoot of xDerivRoots) {
                if (derivRoot > phiMin && derivRoot < phiMax) {
                    fixX(arcAt(c.cX, x0, x90, derivRoot));
                }
            }
            const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);
            for (const derivRoot of yDerivRoots) {
                if (derivRoot > phiMin && derivRoot < phiMax) {
                    fixY(arcAt(c.cY, y0, y90, derivRoot));
                }
            }
        }
        return command;
    });
    f.minX = Infinity;
    f.maxX = -Infinity;
    f.minY = Infinity;
    f.maxY = -Infinity;
    return f;
}
const SVGPathDataTransformer = {
    ROUND,
    TO_ABS,
    TO_REL,
    NORMALIZE_HVZ,
    NORMALIZE_ST,
    QT_TO_C,
    INFO,
    SANITIZE,
    MATRIX,
    ROTATE,
    TRANSLATE,
    SCALE,
    SKEW_X,
    SKEW_Y,
    X_AXIS_SYMMETRY,
    Y_AXIS_SYMMETRY,
    A_TO_C,
    ANNOTATE_ARCS,
    CLONE,
    CALCULATE_BOUNDS,
    REVERSE_PATH,
    REMOVE_COLLINEAR,
};

class TransformableSVG {
    round(x) {
        return this.transform(SVGPathDataTransformer.ROUND(x));
    }
    toAbs() {
        return this.transform(SVGPathDataTransformer.TO_ABS());
    }
    toRel() {
        return this.transform(SVGPathDataTransformer.TO_REL());
    }
    normalizeHVZ(a, b, c) {
        return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a, b, c));
    }
    normalizeST() {
        return this.transform(SVGPathDataTransformer.NORMALIZE_ST());
    }
    qtToC() {
        return this.transform(SVGPathDataTransformer.QT_TO_C());
    }
    aToC() {
        return this.transform(SVGPathDataTransformer.A_TO_C());
    }
    sanitize(eps) {
        return this.transform(SVGPathDataTransformer.SANITIZE(eps));
    }
    translate(x, y) {
        return this.transform(SVGPathDataTransformer.TRANSLATE(x, y));
    }
    scale(x, y) {
        return this.transform(SVGPathDataTransformer.SCALE(x, y));
    }
    rotate(a, x, y) {
        return this.transform(SVGPathDataTransformer.ROTATE(a, x, y));
    }
    matrix(a, b, c, d, e, f) {
        return this.transform(SVGPathDataTransformer.MATRIX(a, b, c, d, e, f));
    }
    skewX(a) {
        return this.transform(SVGPathDataTransformer.SKEW_X(a));
    }
    skewY(a) {
        return this.transform(SVGPathDataTransformer.SKEW_Y(a));
    }
    xSymmetry(xOffset) {
        return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));
    }
    ySymmetry(yOffset) {
        return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));
    }
    annotateArcs() {
        return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());
    }
}

const isWhiteSpace = (c) => ' ' === c || '\t' === c || '\r' === c || '\n' === c;
const isDigit = (c) => '0'.charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= '9'.charCodeAt(0);
class SVGPathDataParser extends TransformableSVG {
    curNumber = '';
    curCommandType = -1;
    curCommandRelative = false;
    canParseCommandOrComma = true;
    curNumberHasExp = false;
    curNumberHasExpDigits = false;
    curNumberHasDecimal = false;
    curArgs = [];
    constructor() {
        super();
    }
    finish(commands = []) {
        this.parse(' ', commands);
        if (0 !== this.curArgs.length || !this.canParseCommandOrComma) {
            throw new SyntaxError('Unterminated command at the path end.');
        }
        return commands;
    }
    parse(str, commands = []) {
        const finishCommand = (command) => {
            commands.push(command);
            this.curArgs.length = 0;
            this.canParseCommandOrComma = true;
        };
        for (let i = 0; i < str.length; i++) {
            const c = str[i];
            const isAArcFlag = this.curCommandType === SVGPathData.ARC &&
                (this.curArgs.length === 3 || this.curArgs.length === 4) &&
                this.curNumber.length === 1 &&
                (this.curNumber === '0' || this.curNumber === '1');
            const isEndingDigit = isDigit(c) && ((this.curNumber === '0' && c === '0') || isAArcFlag);
            if (isDigit(c) && !isEndingDigit) {
                this.curNumber += c;
                this.curNumberHasExpDigits = this.curNumberHasExp;
                continue;
            }
            if ('e' === c || 'E' === c) {
                this.curNumber += c;
                this.curNumberHasExp = true;
                continue;
            }
            if (('-' === c || '+' === c) &&
                this.curNumberHasExp &&
                !this.curNumberHasExpDigits) {
                this.curNumber += c;
                continue;
            }
            if ('.' === c &&
                !this.curNumberHasExp &&
                !this.curNumberHasDecimal &&
                !isAArcFlag) {
                this.curNumber += c;
                this.curNumberHasDecimal = true;
                continue;
            }
            if (this.curNumber && -1 !== this.curCommandType) {
                const val = Number(this.curNumber);
                if (isNaN(val)) {
                    throw new SyntaxError(`Invalid number ending at ${i}`);
                }
                if (this.curCommandType === SVGPathData.ARC) {
                    if (0 === this.curArgs.length || 1 === this.curArgs.length) {
                        if (0 > val) {
                            throw new SyntaxError(`Expected positive number, got "${val}" at index "${i}"`);
                        }
                    }
                    else if (3 === this.curArgs.length || 4 === this.curArgs.length) {
                        if ('0' !== this.curNumber && '1' !== this.curNumber) {
                            throw new SyntaxError(`Expected a flag, got "${this.curNumber}" at index "${i}"`);
                        }
                    }
                }
                this.curArgs.push(val);
                if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {
                    if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) {
                        finishCommand({
                            type: SVGPathData.HORIZ_LINE_TO,
                            relative: this.curCommandRelative,
                            x: val,
                        });
                    }
                    else if (SVGPathData.VERT_LINE_TO === this.curCommandType) {
                        finishCommand({
                            type: SVGPathData.VERT_LINE_TO,
                            relative: this.curCommandRelative,
                            y: val,
                        });
                    }
                    else if (this.curCommandType === SVGPathData.MOVE_TO ||
                        this.curCommandType === SVGPathData.LINE_TO ||
                        this.curCommandType === SVGPathData.SMOOTH_QUAD_TO) {
                        finishCommand({
                            type: this.curCommandType,
                            relative: this.curCommandRelative,
                            x: this.curArgs[0],
                            y: this.curArgs[1],
                        });
                        if (SVGPathData.MOVE_TO === this.curCommandType) {
                            this.curCommandType = SVGPathData.LINE_TO;
                        }
                    }
                    else if (this.curCommandType === SVGPathData.CURVE_TO) {
                        finishCommand({
                            type: SVGPathData.CURVE_TO,
                            relative: this.curCommandRelative,
                            x1: this.curArgs[0],
                            y1: this.curArgs[1],
                            x2: this.curArgs[2],
                            y2: this.curArgs[3],
                            x: this.curArgs[4],
                            y: this.curArgs[5],
                        });
                    }
                    else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) {
                        finishCommand({
                            type: SVGPathData.SMOOTH_CURVE_TO,
                            relative: this.curCommandRelative,
                            x2: this.curArgs[0],
                            y2: this.curArgs[1],
                            x: this.curArgs[2],
                            y: this.curArgs[3],
                        });
                    }
                    else if (this.curCommandType === SVGPathData.QUAD_TO) {
                        finishCommand({
                            type: SVGPathData.QUAD_TO,
                            relative: this.curCommandRelative,
                            x1: this.curArgs[0],
                            y1: this.curArgs[1],
                            x: this.curArgs[2],
                            y: this.curArgs[3],
                        });
                    }
                    else if (this.curCommandType === SVGPathData.ARC) {
                        finishCommand({
                            type: SVGPathData.ARC,
                            relative: this.curCommandRelative,
                            rX: this.curArgs[0],
                            rY: this.curArgs[1],
                            xRot: this.curArgs[2],
                            lArcFlag: this.curArgs[3],
                            sweepFlag: this.curArgs[4],
                            x: this.curArgs[5],
                            y: this.curArgs[6],
                        });
                    }
                }
                this.curNumber = '';
                this.curNumberHasExpDigits = false;
                this.curNumberHasExp = false;
                this.curNumberHasDecimal = false;
                this.canParseCommandOrComma = true;
            }
            if (isWhiteSpace(c)) {
                continue;
            }
            if (',' === c && this.canParseCommandOrComma) {
                this.canParseCommandOrComma = false;
                continue;
            }
            if ('+' === c || '-' === c || '.' === c) {
                this.curNumber = c;
                this.curNumberHasDecimal = '.' === c;
                continue;
            }
            if (isEndingDigit) {
                this.curNumber = c;
                this.curNumberHasDecimal = false;
                continue;
            }
            if (0 !== this.curArgs.length) {
                throw new SyntaxError(`Unterminated command at index ${i}.`);
            }
            if (!this.canParseCommandOrComma) {
                throw new SyntaxError(`Unexpected character "${c}" at index ${i}. Command cannot follow comma`);
            }
            this.canParseCommandOrComma = false;
            if ('z' === c || 'Z' === c) {
                commands.push({
                    type: SVGPathData.CLOSE_PATH,
                });
                this.canParseCommandOrComma = true;
                this.curCommandType = -1;
                continue;
            }
            else if ('h' === c || 'H' === c) {
                this.curCommandType = SVGPathData.HORIZ_LINE_TO;
                this.curCommandRelative = 'h' === c;
            }
            else if ('v' === c || 'V' === c) {
                this.curCommandType = SVGPathData.VERT_LINE_TO;
                this.curCommandRelative = 'v' === c;
            }
            else if ('m' === c || 'M' === c) {
                this.curCommandType = SVGPathData.MOVE_TO;
                this.curCommandRelative = 'm' === c;
            }
            else if ('l' === c || 'L' === c) {
                this.curCommandType = SVGPathData.LINE_TO;
                this.curCommandRelative = 'l' === c;
            }
            else if ('c' === c || 'C' === c) {
                this.curCommandType = SVGPathData.CURVE_TO;
                this.curCommandRelative = 'c' === c;
            }
            else if ('s' === c || 'S' === c) {
                this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;
                this.curCommandRelative = 's' === c;
            }
            else if ('q' === c || 'Q' === c) {
                this.curCommandType = SVGPathData.QUAD_TO;
                this.curCommandRelative = 'q' === c;
            }
            else if ('t' === c || 'T' === c) {
                this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;
                this.curCommandRelative = 't' === c;
            }
            else if ('a' === c || 'A' === c) {
                this.curCommandType = SVGPathData.ARC;
                this.curCommandRelative = 'a' === c;
            }
            else {
                throw new SyntaxError(`Unexpected character "${c}" at index ${i}.`);
            }
        }
        return commands;
    }
    transform(transform) {
        const result = Object.create(this, {
            parse: {
                value(chunk, commands = []) {
                    const parsedCommands = Object.getPrototypeOf(this).parse.call(this, chunk);
                    for (const c of parsedCommands) {
                        const cT = transform(c);
                        if (Array.isArray(cT)) {
                            commands.push(...cT);
                        }
                        else {
                            commands.push(cT);
                        }
                    }
                    return commands;
                },
            },
        });
        return result;
    }
}

class SVGPathData extends TransformableSVG {
    commands;
    constructor(content) {
        super();
        if ('string' === typeof content) {
            this.commands = SVGPathData.parse(content);
        }
        else {
            this.commands = content;
        }
    }
    encode() {
        return SVGPathData.encode(this.commands);
    }
    getBounds() {
        const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();
        this.transform(boundsTransform);
        return boundsTransform;
    }
    transform(transformFunction) {
        const newCommands = [];
        for (const command of this.commands) {
            const transformedCommand = transformFunction(command);
            if (Array.isArray(transformedCommand)) {
                newCommands.push(...transformedCommand);
            }
            else {
                newCommands.push(transformedCommand);
            }
        }
        this.commands = newCommands;
        return this;
    }
    reverse(preserveSubpathOrder = true) {
        this.commands = SVGPathDataTransformer.REVERSE_PATH(this.commands, preserveSubpathOrder);
        return this;
    }
    removeCollinear() {
        this.commands = SVGPathDataTransformer.REMOVE_COLLINEAR(this.commands);
        return this;
    }
    static encode(commands) {
        return encodeSVGPath(commands);
    }
    static parse(path) {
        const parser = new SVGPathDataParser();
        const commands = [];
        parser.parse(path, commands);
        parser.finish(commands);
        return commands;
    }
    static CLOSE_PATH = 1;
    static MOVE_TO = 2;
    static HORIZ_LINE_TO = 4;
    static VERT_LINE_TO = 8;
    static LINE_TO = 16;
    static CURVE_TO = 32;
    static SMOOTH_CURVE_TO = 64;
    static QUAD_TO = 128;
    static SMOOTH_QUAD_TO = 256;
    static ARC = 512;
    static LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;
    static DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO |
        SVGPathData.VERT_LINE_TO |
        SVGPathData.LINE_TO |
        SVGPathData.CURVE_TO |
        SVGPathData.SMOOTH_CURVE_TO |
        SVGPathData.QUAD_TO |
        SVGPathData.SMOOTH_QUAD_TO |
        SVGPathData.ARC;
}
const COMMAND_ARG_COUNTS = {
    [SVGPathData.MOVE_TO]: 2,
    [SVGPathData.LINE_TO]: 2,
    [SVGPathData.HORIZ_LINE_TO]: 1,
    [SVGPathData.VERT_LINE_TO]: 1,
    [SVGPathData.CLOSE_PATH]: 0,
    [SVGPathData.QUAD_TO]: 4,
    [SVGPathData.SMOOTH_QUAD_TO]: 2,
    [SVGPathData.CURVE_TO]: 6,
    [SVGPathData.SMOOTH_CURVE_TO]: 4,
    [SVGPathData.ARC]: 7,
};

const _console$n = createConsole("SvgUtils", { log: false });
function decomposeTransform(t, tolerance = 1e-6) {
    const tx = t.e;
    const ty = t.f;
    const scaleX = Math.sqrt(t.a * t.a + t.b * t.b);
    const scaleY = Math.sqrt(t.c * t.c + t.d * t.d);
    let rotation = 0;
    if (scaleX !== 0) {
        rotation = Math.atan2(t.b / scaleX, t.a / scaleX);
    }
    let skewX = 0;
    let skewY = 0;
    if (scaleX !== 0 && scaleY !== 0) {
        skewX = Math.atan2(t.a * t.c + t.b * t.d, scaleX * scaleX);
        skewY = 0;
    }
    const isScaleUniform = Math.abs(scaleX - scaleY) < tolerance;
    return {
        translation: { x: tx, y: ty },
        rotation,
        scale: { x: scaleX, y: scaleY },
        skew: { x: skewX, y: skewY },
        isScaleUniform,
    };
}
const identity = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
function multiply(t1, t2) {
    return {
        a: t1.a * t2.a + t1.c * t2.b,
        b: t1.b * t2.a + t1.d * t2.b,
        c: t1.a * t2.c + t1.c * t2.d,
        d: t1.b * t2.c + t1.d * t2.d,
        e: t1.a * t2.e + t1.c * t2.f + t1.e,
        f: t1.b * t2.e + t1.d * t2.f + t1.f,
    };
}
function parseTransform(transformStr) {
    if (!transformStr)
        return identity;
    const t = transformStr.match(/(\w+)\(([^)]+)\)/g);
    if (!t)
        return identity;
    let matrix = structuredClone(identity);
    for (const part of t) {
        const [, fn, argsStr] = /(\w+)\(([^)]+)\)/.exec(part);
        const args = argsStr.split(/[\s,]+/).map(Number);
        let m = structuredClone(identity);
        switch (fn) {
            case "translate":
                m.e = args[0];
                m.f = args[1] || 0;
                break;
            case "scale":
                m.a = args[0];
                m.d = args[1] !== undefined ? args[1] : args[0];
                break;
            case "rotate":
                const angle = (args[0] * Math.PI) / 180;
                const cos = Math.cos(angle), sin = Math.sin(angle);
                if (args[1] !== undefined && args[2] !== undefined) {
                    const [cx, cy] = [args[1], args[2]];
                    m = {
                        a: cos,
                        b: sin,
                        c: -sin,
                        d: cos,
                        e: cx - cos * cx + sin * cy,
                        f: cy - sin * cx - cos * cy,
                    };
                }
                else {
                    m.a = cos;
                    m.b = sin;
                    m.c = -sin;
                    m.d = cos;
                }
                break;
            case "matrix":
                [m.a, m.b, m.c, m.d, m.e, m.f] = args;
                break;
        }
        matrix = multiply(matrix, m);
    }
    return matrix;
}
function applyTransform(x, y, t) {
    const value = {
        x: t.a * x + t.c * y + t.e,
        y: t.b * x + t.d * y + t.f,
    };
    return value;
}
function parseStyle(styleStr) {
    const style = {};
    if (!styleStr)
        return style;
    styleStr.split(";").forEach((item) => {
        const [key, value] = item.split(":").map((s) => s.trim());
        if (key && value)
            style[key] = value;
    });
    return style;
}
const circleBezierConstant = 0.5522847498307936;
function svgJsonToCanvasCommands(svgJson) {
    const commands = [];
    function traverse(node, parentTransform) {
        const transform = parseTransform(node.attributes.transform);
        const nodeTransform = multiply(parentTransform, transform);
        const { scale, rotation, isScaleUniform } = decomposeTransform(nodeTransform);
        const uniformScale = scale.x;
        const style = parseStyle(node.attributes.style);
        if (style.fill)
            commands.push({ type: "fillStyle", fillStyle: style.fill });
        if (node.attributes.fill)
            commands.push({ type: "fillStyle", fillStyle: node.attributes.fill });
        if (style.stroke)
            commands.push({ type: "strokeStyle", strokeStyle: style.stroke });
        if (node.attributes.stroke)
            commands.push({
                type: "strokeStyle",
                strokeStyle: node.attributes.stroke,
            });
        let strokeWidth = 0;
        if (style["stroke-width"])
            strokeWidth = parseLength(style["stroke-width"]) ?? 0;
        if (node.attributes["stroke-width"])
            strokeWidth = parseLength(node.attributes["stroke-width"]) ?? strokeWidth;
        if (strokeWidth)
            commands.push({
                type: "lineWidth",
                lineWidth: strokeWidth * nodeTransform.a,
            });
        let fillRule = style["fill-rule"];
        if (node.attributes["fill-rule"])
            fillRule = node.attributes["fill-rule"];
        if (fillRule)
            commands.push({ type: "fillRule", fillRule: fillRule });
        switch (node.name) {
            case "path":
                const d = node.attributes.d;
                if (!d)
                    break;
                const pathData = new SVGPathData(d)
                    .toAbs()
                    .aToC()
                    .normalizeHVZ(false)
                    .normalizeST()
                    .removeCollinear()
                    .sanitize();
                commands.push({ type: "pathStart" });
                for (const cmd of pathData.commands) {
                    switch (cmd.type) {
                        case SVGPathData.MOVE_TO:
                            commands.push({ type: "closePath" });
                            const m = applyTransform(cmd.x, cmd.y, nodeTransform);
                            commands.push({ type: "moveTo", x: m.x, y: m.y });
                            break;
                        case SVGPathData.LINE_TO:
                            const l = applyTransform(cmd.x, cmd.y, nodeTransform);
                            commands.push({ type: "lineTo", x: l.x, y: l.y });
                            break;
                        case SVGPathData.CURVE_TO:
                            const c1 = applyTransform(cmd.x1, cmd.y1, nodeTransform);
                            const c2 = applyTransform(cmd.x2, cmd.y2, nodeTransform);
                            const ce = applyTransform(cmd.x, cmd.y, nodeTransform);
                            commands.push({
                                type: "bezierCurveTo",
                                cp1x: c1.x,
                                cp1y: c1.y,
                                cp2x: c2.x,
                                cp2y: c2.y,
                                x: ce.x,
                                y: ce.y,
                            });
                            break;
                        case SVGPathData.QUAD_TO:
                            const qcp = applyTransform(cmd.x1, cmd.y1, nodeTransform);
                            const qe = applyTransform(cmd.x, cmd.y, nodeTransform);
                            commands.push({
                                type: "quadraticCurveTo",
                                cpx: qcp.x,
                                cpy: qcp.y,
                                x: qe.x,
                                y: qe.y,
                            });
                            break;
                        case SVGPathData.CLOSE_PATH:
                            commands.push({ type: "closePath" });
                            break;
                        default:
                            _console$n.warn("uncaught command", cmd);
                            break;
                    }
                }
                if (commands.at(-1)?.type != "closePath") {
                    commands.push({ type: "closePath" });
                }
                commands.push({ type: "pathEnd" });
                break;
            case "rect": {
                const x = parseFloat(node.attributes.x || "0");
                const y = parseFloat(node.attributes.y || "0");
                const width = parseFloat(node.attributes.width || "0");
                const height = parseFloat(node.attributes.height || "0");
                let rx = parseFloat(node.attributes.rx || "0");
                let ry = parseFloat(node.attributes.ry || "0");
                if (!node.attributes.ry && rx)
                    ry = rx;
                rx = Math.min(rx, width / 2);
                ry = Math.min(ry, height / 2);
                if (rx === 0 && ry === 0) {
                    if (isScaleUniform) {
                        const center = applyTransform(x + width / 2, y + height / 2, nodeTransform);
                        commands.push({
                            type: "rect",
                            x: center.x,
                            y: center.y,
                            width: width * uniformScale,
                            height: height * uniformScale,
                            rotation,
                        });
                    }
                    else {
                        const tl = applyTransform(x, y, nodeTransform);
                        const tr = applyTransform(x + width, y, nodeTransform);
                        const br = applyTransform(x + width, y + height, nodeTransform);
                        const bl = applyTransform(x, y + height, nodeTransform);
                        commands.push({ type: "moveTo", x: tl.x, y: tl.y });
                        commands.push({ type: "lineTo", x: tr.x, y: tr.y });
                        commands.push({ type: "lineTo", x: br.x, y: br.y });
                        commands.push({ type: "lineTo", x: bl.x, y: bl.y });
                        commands.push({ type: "closePath" });
                    }
                }
                else {
                    if (rx == ry && isScaleUniform) {
                        const center = applyTransform(x + width / 2, y + height / 2, nodeTransform);
                        commands.push({
                            type: "roundRect",
                            x: center.x,
                            y: center.y,
                            width: width * uniformScale,
                            height: height * uniformScale,
                            rotation,
                            r: rx * uniformScale,
                        });
                    }
                    else {
                        const ox = rx * circleBezierConstant;
                        const oy = ry * circleBezierConstant;
                        const p1 = { x: x + rx, y: y };
                        const p2 = { x: x + width - rx, y: y };
                        const p3 = { x: x + width, y: y + ry };
                        const p4 = { x: x + width, y: y + height - ry };
                        const p5 = { x: x + width - rx, y: y + height };
                        const p6 = { x: x + rx, y: y + height };
                        const p7 = { x: x, y: y + height - ry };
                        const p8 = { x: x, y: y + ry };
                        const start = applyTransform(p1.x, p1.y, nodeTransform);
                        commands.push({ type: "moveTo", x: start.x, y: start.y });
                        let cp1 = applyTransform(p2.x + ox, p2.y, nodeTransform);
                        let cp2 = applyTransform(p3.x, p3.y - oy, nodeTransform);
                        let end = applyTransform(p3.x, p3.y, nodeTransform);
                        commands.push({
                            type: "lineTo",
                            x: applyTransform(p2.x, p2.y, nodeTransform).x,
                            y: applyTransform(p2.x, p2.y, nodeTransform).y,
                        });
                        commands.push({
                            type: "bezierCurveTo",
                            cp1x: cp1.x,
                            cp1y: cp1.y,
                            cp2x: cp2.x,
                            cp2y: cp2.y,
                            x: end.x,
                            y: end.y,
                        });
                        cp1 = applyTransform(p4.x, p4.y + oy, nodeTransform);
                        cp2 = applyTransform(p5.x + ox, p5.y, nodeTransform);
                        end = applyTransform(p5.x, p5.y, nodeTransform);
                        commands.push({
                            type: "lineTo",
                            x: applyTransform(p4.x, p4.y, nodeTransform).x,
                            y: applyTransform(p4.x, p4.y, nodeTransform).y,
                        });
                        commands.push({
                            type: "bezierCurveTo",
                            cp1x: cp1.x,
                            cp1y: cp1.y,
                            cp2x: cp2.x,
                            cp2y: cp2.y,
                            x: end.x,
                            y: end.y,
                        });
                        cp1 = applyTransform(p6.x - ox, p6.y, nodeTransform);
                        cp2 = applyTransform(p7.x, p7.y + oy, nodeTransform);
                        end = applyTransform(p7.x, p7.y, nodeTransform);
                        commands.push({
                            type: "lineTo",
                            x: applyTransform(p6.x, p6.y, nodeTransform).x,
                            y: applyTransform(p6.x, p6.y, nodeTransform).y,
                        });
                        commands.push({
                            type: "bezierCurveTo",
                            cp1x: cp1.x,
                            cp1y: cp1.y,
                            cp2x: cp2.x,
                            cp2y: cp2.y,
                            x: end.x,
                            y: end.y,
                        });
                        cp1 = applyTransform(p8.x, p8.y - oy, nodeTransform);
                        cp2 = applyTransform(p1.x - ox, p1.y, nodeTransform);
                        end = applyTransform(p1.x, p1.y, nodeTransform);
                        commands.push({
                            type: "lineTo",
                            x: applyTransform(p8.x, p8.y, nodeTransform).x,
                            y: applyTransform(p8.x, p8.y, nodeTransform).y,
                        });
                        commands.push({
                            type: "bezierCurveTo",
                            cp1x: cp1.x,
                            cp1y: cp1.y,
                            cp2x: cp2.x,
                            cp2y: cp2.y,
                            x: end.x,
                            y: end.y,
                        });
                        commands.push({ type: "closePath" });
                    }
                }
                break;
            }
            case "circle": {
                const cx = parseFloat(node.attributes.cx || "0");
                const cy = parseFloat(node.attributes.cy || "0");
                const r = parseFloat(node.attributes.r || "0");
                if (r === 0)
                    break;
                if (isScaleUniform) {
                    const center = applyTransform(cx, cy, nodeTransform);
                    commands.push({
                        type: "circle",
                        x: center.x,
                        y: center.y,
                        r: r * uniformScale,
                    });
                }
                else {
                    const ox = r * circleBezierConstant;
                    const pTop = applyTransform(cx, cy - r, nodeTransform);
                    const pRight = applyTransform(cx + r, cy, nodeTransform);
                    const pBottom = applyTransform(cx, cy + r, nodeTransform);
                    const pLeft = applyTransform(cx - r, cy, nodeTransform);
                    const cpTopRight = applyTransform(cx + ox, cy - r, nodeTransform);
                    const cpRightTop = applyTransform(cx + r, cy - ox, nodeTransform);
                    const cpRightBottom = applyTransform(cx + r, cy + ox, nodeTransform);
                    const cpBottomRight = applyTransform(cx + ox, cy + r, nodeTransform);
                    const cpBottomLeft = applyTransform(cx - ox, cy + r, nodeTransform);
                    const cpLeftBottom = applyTransform(cx - r, cy + ox, nodeTransform);
                    const cpLeftTop = applyTransform(cx - r, cy - ox, nodeTransform);
                    const cpTopLeft = applyTransform(cx - ox, cy - r, nodeTransform);
                    commands.push({ type: "moveTo", x: pTop.x, y: pTop.y });
                    commands.push({
                        type: "bezierCurveTo",
                        cp1x: cpTopRight.x,
                        cp1y: cpTopRight.y,
                        cp2x: cpRightTop.x,
                        cp2y: cpRightTop.y,
                        x: pRight.x,
                        y: pRight.y,
                    });
                    commands.push({
                        type: "bezierCurveTo",
                        cp1x: cpRightBottom.x,
                        cp1y: cpRightBottom.y,
                        cp2x: cpBottomRight.x,
                        cp2y: cpBottomRight.y,
                        x: pBottom.x,
                        y: pBottom.y,
                    });
                    commands.push({
                        type: "bezierCurveTo",
                        cp1x: cpBottomLeft.x,
                        cp1y: cpBottomLeft.y,
                        cp2x: cpLeftBottom.x,
                        cp2y: cpLeftBottom.y,
                        x: pLeft.x,
                        y: pLeft.y,
                    });
                    commands.push({
                        type: "bezierCurveTo",
                        cp1x: cpLeftTop.x,
                        cp1y: cpLeftTop.y,
                        cp2x: cpTopLeft.x,
                        cp2y: cpTopLeft.y,
                        x: pTop.x,
                        y: pTop.y,
                    });
                    commands.push({ type: "closePath" });
                }
                break;
            }
            case "ellipse": {
                const cx = parseFloat(node.attributes.cx || "0");
                const cy = parseFloat(node.attributes.cy || "0");
                const rx = parseFloat(node.attributes.rx || "0");
                const ry = parseFloat(node.attributes.ry || "0");
                if (rx === 0 || ry === 0)
                    break;
                if (isScaleUniform) {
                    const center = applyTransform(cx, cy, nodeTransform);
                    if (rx == ry) {
                        commands.push({
                            type: "circle",
                            x: center.x,
                            y: center.y,
                            r: rx * uniformScale,
                        });
                    }
                    else {
                        commands.push({
                            type: "ellipse",
                            x: center.x,
                            y: center.y,
                            rx: rx * uniformScale,
                            ry: ry * uniformScale,
                            rotation,
                        });
                    }
                }
                else {
                    const ox = rx * circleBezierConstant;
                    const oy = ry * circleBezierConstant;
                    const pTop = applyTransform(cx, cy - ry, nodeTransform);
                    const pRight = applyTransform(cx + rx, cy, nodeTransform);
                    const pBottom = applyTransform(cx, cy + ry, nodeTransform);
                    const pLeft = applyTransform(cx - rx, cy, nodeTransform);
                    const cpTopRight = applyTransform(cx + ox, cy - ry, nodeTransform);
                    const cpRightTop = applyTransform(cx + rx, cy - oy, nodeTransform);
                    const cpRightBottom = applyTransform(cx + rx, cy + oy, nodeTransform);
                    const cpBottomRight = applyTransform(cx + ox, cy + ry, nodeTransform);
                    const cpBottomLeft = applyTransform(cx - ox, cy + ry, nodeTransform);
                    const cpLeftBottom = applyTransform(cx - rx, cy + oy, nodeTransform);
                    const cpLeftTop = applyTransform(cx - rx, cy - oy, nodeTransform);
                    const cpTopLeft = applyTransform(cx - ox, cy - ry, nodeTransform);
                    commands.push({ type: "moveTo", x: pTop.x, y: pTop.y });
                    commands.push({
                        type: "bezierCurveTo",
                        cp1x: cpTopRight.x,
                        cp1y: cpTopRight.y,
                        cp2x: cpRightTop.x,
                        cp2y: cpRightTop.y,
                        x: pRight.x,
                        y: pRight.y,
                    });
                    commands.push({
                        type: "bezierCurveTo",
                        cp1x: cpRightBottom.x,
                        cp1y: cpRightBottom.y,
                        cp2x: cpBottomRight.x,
                        cp2y: cpBottomRight.y,
                        x: pBottom.x,
                        y: pBottom.y,
                    });
                    commands.push({
                        type: "bezierCurveTo",
                        cp1x: cpBottomLeft.x,
                        cp1y: cpBottomLeft.y,
                        cp2x: cpLeftBottom.x,
                        cp2y: cpLeftBottom.y,
                        x: pLeft.x,
                        y: pLeft.y,
                    });
                    commands.push({
                        type: "bezierCurveTo",
                        cp1x: cpLeftTop.x,
                        cp1y: cpLeftTop.y,
                        cp2x: cpTopLeft.x,
                        cp2y: cpTopLeft.y,
                        x: pTop.x,
                        y: pTop.y,
                    });
                    commands.push({ type: "closePath" });
                }
                break;
            }
            case "polyline":
            case "polygon": {
                const pointsStr = node.attributes.points || "";
                const points = pointsStr
                    .trim()
                    .split(/[\s,]+/)
                    .map(Number)
                    .reduce((acc, val, idx) => {
                    if (idx % 2 === 0)
                        acc.push({ x: val, y: 0 });
                    else
                        acc[acc.length - 1].y = val;
                    return acc;
                }, [])
                    .map((p) => ({ x: p.x, y: p.y }));
                if (points.length === 0)
                    break;
                const start = applyTransform(points[0].x, points[0].y, nodeTransform);
                commands.push({ type: "moveTo", x: start.x, y: start.y });
                for (let i = 1; i < points.length; i++) {
                    const p = applyTransform(points[i].x, points[i].y, nodeTransform);
                    commands.push({ type: "lineTo", x: p.x, y: p.y });
                }
                commands.push({ type: "closePath" });
                break;
            }
            case "line": {
                const x1 = parseFloat(node.attributes.x1 || "0");
                const y1 = parseFloat(node.attributes.y1 || "0");
                const x2 = parseFloat(node.attributes.x2 || "0");
                const y2 = parseFloat(node.attributes.y2 || "0");
                const p1 = applyTransform(x1, y1, nodeTransform);
                const p2 = applyTransform(x2, y2, nodeTransform);
                commands.push({ type: "line", x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y });
                break;
            }
            case "svg":
                break;
            default:
                _console$n.log("uncaught node", node);
                break;
        }
        if (node.children) {
            for (const child of node.children)
                traverse(child, nodeTransform);
        }
    }
    traverse(svgJson, getSvgTransformToPixels(svgJson));
    return commands;
}
function parseLength(str, relativeTo) {
    if (!str)
        return undefined;
    const match = /^([0-9.]+)([a-z%]*)$/.exec(str.trim());
    if (!match)
        return undefined;
    const value = parseFloat(match[1]);
    const unit = match[2] || "px";
    switch (unit) {
        case "px":
            return value;
        case "pt":
            return value * (96 / 72);
        case "in":
            return value * 96;
        case "cm":
            return value * (96 / 2.54);
        case "mm":
            return value * (96 / 25.4);
        case "%":
            return undefined;
        case "":
            return value;
        default:
            return value;
    }
}
function getSvgJsonSize(svgJson) {
    const attrs = svgJson.attributes || {};
    let width = parseLength(attrs.width);
    let height = parseLength(attrs.height);
    if ((width == null || height == null) && attrs.viewBox) {
        const [, , vbWidth, vbHeight] = attrs.viewBox
            .split(/[\s,]+/)
            .map(parseFloat);
        width ??= vbWidth;
        height ??= vbHeight;
    }
    const size = {
        width: width ?? 300,
        height: height ?? 150,
    };
    return size;
}
function getSvgJsonViewBox(svgJson) {
    const attrs = svgJson.attributes || {};
    let x = 0, y = 0, width, height;
    if (attrs.viewBox) {
        [x, y, width, height] = attrs.viewBox.split(/[\s,]+/).map(parseFloat);
    }
    if (width == null || height == null) {
        const size = getSvgJsonSize(svgJson);
        width ??= size.width;
        height ??= size.height;
    }
    const viewBox = {
        x,
        y,
        width: width,
        height: height,
    };
    return viewBox;
}
function getSvgJsonBoundingBox(svgJson) {
    const { width, height } = getSvgJsonSize(svgJson);
    const viewBox = getSvgJsonViewBox(svgJson);
    if (width !== undefined && height !== undefined) {
        return { x: 0, y: 0, width, height };
    }
    else if (viewBox.width !== undefined && viewBox.height !== undefined) {
        return viewBox;
    }
    else {
        return { x: 0, y: 0, width: 300, height: 150 };
    }
}
function getSvgTransformToPixels(svgJson) {
    const attrs = svgJson.attributes || {};
    const { width, height } = getSvgJsonSize(svgJson);
    const viewBox = getSvgJsonViewBox(svgJson);
    let scaleX = width / viewBox.width;
    let scaleY = height / viewBox.height;
    let offsetX = 0;
    let offsetY = 0;
    if (attrs.preserveAspectRatio?.includes("meet")) {
        const s = Math.min(scaleX, scaleY);
        offsetX = (width - viewBox.width * s) / 2;
        offsetY = (height - viewBox.height * s) / 2;
        scaleX = scaleY = s;
    }
    return {
        a: scaleX,
        b: 0,
        c: 0,
        d: scaleY,
        e: -viewBox.x * scaleX + offsetX,
        f: -viewBox.y * scaleY + offsetY,
    };
}
const defaultParseSvgOptions = {
    fit: false,
    centered: true,
};
function transformCanvasCommands(canvasCommands, xCallback, yCallback, type) {
    return canvasCommands.map((command) => {
        switch (command.type) {
            case "moveTo":
            case "lineTo": {
                let { x, y } = command;
                x = xCallback(x);
                y = yCallback(y);
                return { type: command.type, x, y };
            }
            case "quadraticCurveTo": {
                let { x, y, cpx, cpy } = command;
                x = xCallback(x);
                y = yCallback(y);
                cpx = xCallback(cpx);
                cpy = yCallback(cpy);
                return { type: command.type, x, y, cpx, cpy };
            }
            case "bezierCurveTo": {
                let { x, y, cp1x, cp1y, cp2x, cp2y } = command;
                x = xCallback(x);
                y = yCallback(y);
                cp1x = xCallback(cp1x);
                cp1y = yCallback(cp1y);
                cp2x = xCallback(cp2x);
                cp2y = yCallback(cp2y);
                return { type: command.type, x, y, cp1x, cp1y, cp2x, cp2y };
            }
            case "lineWidth": {
                if (type == "scale") {
                    let { lineWidth } = command;
                    lineWidth = xCallback(lineWidth);
                    return { type: command.type, lineWidth };
                }
                break;
            }
            case "rect":
            case "roundRect": {
                let { x, y, width, height, rotation } = command;
                x = xCallback(x);
                y = yCallback(y);
                if (type == "scale") {
                    width = xCallback(width);
                    height = yCallback(height);
                }
                if (command.type == "roundRect") {
                    let { r } = command;
                    if (type == "scale") {
                        r = xCallback(r);
                    }
                    return { type: command.type, x, y, width, height, rotation, r };
                }
                return { type: command.type, x, y, width, height, rotation };
            }
            case "circle":
                {
                    let { x, y, r } = command;
                    x = xCallback(x);
                    y = yCallback(y);
                    if (type == "scale") {
                        r = xCallback(r);
                    }
                    return { type: command.type, x, y, r };
                }
            case "ellipse":
                {
                    let { x, y, rx, ry, rotation } = command;
                    x = xCallback(x);
                    y = yCallback(y);
                    if (type == "scale") {
                        rx = xCallback(rx);
                        ry = xCallback(ry);
                    }
                    return { type: command.type, x, y, rx, ry, rotation };
                }
            default:
                return command;
        }
        return command;
    });
}
function forEachCanvasCommandVector2(canvasCommands, vectorCallback) {
    canvasCommands.forEach((command) => {
        switch (command.type) {
            case "moveTo":
            case "lineTo":
                {
                    let { x, y } = command;
                    vectorCallback(x, y);
                }
                break;
            case "quadraticCurveTo":
                {
                    let { x, y, cpx, cpy } = command;
                    vectorCallback(x, y);
                    vectorCallback(cpx, cpy);
                }
                break;
            case "bezierCurveTo": {
                let { x, y, cp1x, cp1y, cp2x, cp2y } = command;
                vectorCallback(x, y);
                vectorCallback(cp1x, cp1y);
                vectorCallback(cp2x, cp2y);
            }
        }
    });
}
function offsetCanvasCommands(canvasCommands, offsetX = 0, offsetY = 0) {
    return transformCanvasCommands(canvasCommands, (x) => x + offsetX, (y) => y + offsetY, "offset");
}
function scaleCanvasCommands(canvasCommands, scaleX, scaleY) {
    return transformCanvasCommands(canvasCommands, (x) => x * scaleX, (y) => y * scaleY, "scale");
}
function getBoundingBox(path) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const p of path) {
        if (p.x < minX)
            minX = p.x;
        if (p.y < minY)
            minY = p.y;
        if (p.x > maxX)
            maxX = p.x;
        if (p.y > maxY)
            maxY = p.y;
    }
    return { minX, minY, maxX, maxY };
}
function bboxContains(a, b) {
    return (a.minX <= b.minX && a.minY <= b.minY && a.maxX >= b.maxX && a.maxY >= b.maxY);
}
function classifySubpath(subpath, previous, fillRule) {
    const centroid = subpath.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
    centroid.x /= subpath.length;
    centroid.y /= subpath.length;
    const subBBox = getBoundingBox(subpath);
    let insideCount = 0;
    for (const other of previous) {
        const otherBBox = getBoundingBox(other.path);
        if (!bboxContains(otherBBox, subBBox))
            continue;
        const insidePoints = subpath.filter((p) => pointInPolygon(p, other.path)).length;
        const allInside = insidePoints > subpath.length * 0.8;
        if (!allInside)
            continue;
        insideCount++;
    }
    if (fillRule === "evenodd") {
        return insideCount % 2 === 1;
    }
    else {
        let winding = 0;
        for (const other of previous) {
            const otherBBox = getBoundingBox(other.path);
            if (!bboxContains(otherBBox, subBBox))
                continue;
            if (pointInPolygon(centroid, other.path)) {
                winding += contourArea(other.path) > 0 ? 1 : -1;
            }
        }
        return winding !== 0;
    }
}
function svgToDisplayContextCommands(svgString, numberOfColors, paletteOffset, colors, options) {
    _console$n.assertWithError(numberOfColors > 1, "numberOfColors must be greater than 1");
    options = { ...defaultParseSvgOptions, ...options };
    _console$n.log("options", options);
    const svgJson = svgson_umdExports.parseSync(svgString);
    let canvasCommands = svgJsonToCanvasCommands(svgJson);
    _console$n.log("canvasCommands", canvasCommands);
    const boundingBox = getSvgJsonBoundingBox(svgJson);
    let intrinsicWidth = boundingBox.width;
    let intrinsicHeight = boundingBox.height;
    _console$n.log({ intrinsicWidth, intrinsicHeight });
    let scaleX = 1, scaleY = 1;
    if (options.width && options.height) {
        scaleX = options.width / intrinsicWidth;
        scaleY = options.height / intrinsicHeight;
    }
    else if (options.width) {
        scaleX = scaleY = options.width / intrinsicWidth;
        if (options.aspectRatio)
            scaleY = scaleX / options.aspectRatio;
    }
    else if (options.height) {
        scaleX = scaleY = options.height / intrinsicHeight;
        if (options.aspectRatio)
            scaleX = scaleY * options.aspectRatio;
    }
    _console$n.log({ scaleX, scaleY });
    let width = intrinsicWidth * scaleX;
    let height = intrinsicWidth * scaleX;
    _console$n.log({ width, height });
    if (scaleX !== 1 || scaleY !== 1) {
        canvasCommands = scaleCanvasCommands(canvasCommands, scaleX, scaleY);
    }
    if (options.fit) {
        const rangeHelper = {
            x: new RangeHelper(),
            y: new RangeHelper(),
        };
        forEachCanvasCommandVector2(canvasCommands, (x, y) => {
            rangeHelper.x.update(x);
            rangeHelper.y.update(y);
        });
        width = rangeHelper.x.span;
        height = rangeHelper.y.span;
        const offsetX = -rangeHelper.x.min;
        const offsetY = -rangeHelper.y.min;
        canvasCommands = offsetCanvasCommands(canvasCommands, offsetX, offsetY);
    }
    if (options.offsetX || options.offsetY) {
        const offsetX = options.offsetX || 0;
        const offsetY = options.offsetY || 0;
        canvasCommands = offsetCanvasCommands(canvasCommands, offsetX, offsetY);
    }
    if (options.centered) {
        const offsetX = -width / 2;
        const offsetY = -height / 2;
        canvasCommands = offsetCanvasCommands(canvasCommands, offsetX, offsetY);
    }
    let svgColors = [];
    canvasCommands.forEach((canvasCommand) => {
        let color;
        switch (canvasCommand.type) {
            case "fillStyle":
                color = canvasCommand.fillStyle;
                break;
            case "strokeStyle":
                color = canvasCommand.strokeStyle;
                break;
            default:
                return;
        }
        if (color && color != "none" && !svgColors.includes(color)) {
            svgColors.push(color);
        }
    });
    if (svgColors.length == 0) {
        svgColors.push("black");
    }
    if (svgColors.length == 1) {
        svgColors.push("white");
    }
    _console$n.log("colors", svgColors);
    const colorToIndex = {};
    if (colors) {
        colors = colors.slice(0, numberOfColors);
        const mapping = mapToClosestPaletteIndex(svgColors, colors.slice(1));
        _console$n.log("mapping", mapping, colors);
        svgColors.forEach((color) => {
            colorToIndex[color] = mapping[color] + 1;
        });
    }
    else {
        const { palette, mapping } = kMeansColors(svgColors, numberOfColors);
        _console$n.log("mapping", mapping);
        _console$n.log("palette", palette);
        svgColors.forEach((color) => {
            colorToIndex[color] = mapping[color];
        });
        colors = palette;
    }
    _console$n.log("colorToIndex", colorToIndex);
    _console$n.log("transformed canvasCommands", canvasCommands);
    let curves = [];
    let startPoint = { x: 0, y: 0 };
    let fillRule = "nonzero";
    let fillStyle;
    let strokeStyle = "none";
    let lineWidth = 1;
    let segmentRadius = 1;
    let wasHole = false;
    let ignoreFill = false;
    let ignoreLine = true;
    let fillColorIndex = 1;
    let lineColorIndex = 1;
    const getFillColorIndex = () => fillColorIndex + paletteOffset;
    const getLineColorIndex = () => lineColorIndex + paletteOffset;
    let isDrawingPath = false;
    const parsedPaths = [];
    let displayCommands = [];
    displayCommands.push({
        type: "selectFillColor",
        fillColorIndex: getFillColorIndex(),
    });
    displayCommands.push({
        type: "selectLineColor",
        lineColorIndex: getLineColorIndex(),
    });
    displayCommands.push({ type: "setIgnoreLine", ignoreLine: true });
    displayCommands.push({ type: "setLineWidth", lineWidth });
    displayCommands.push({
        type: "setSegmentRadius",
        segmentRadius,
    });
    canvasCommands.forEach((canvasCommand) => {
        switch (canvasCommand.type) {
            case "moveTo":
                {
                    const { x, y } = canvasCommand;
                    startPoint.x = x;
                    startPoint.y = y;
                }
                break;
            case "lineTo":
                {
                    const { x, y } = canvasCommand;
                    const controlPoints = [{ x, y }];
                    if (curves.length === 0) {
                        controlPoints.unshift({ ...startPoint });
                    }
                    curves.push({ type: "segment", controlPoints });
                }
                break;
            case "quadraticCurveTo":
                {
                    const { x, y, cpx, cpy } = canvasCommand;
                    const controlPoints = [
                        { x: cpx, y: cpy },
                        { x, y },
                    ];
                    if (curves.length === 0) {
                        controlPoints.unshift({ ...startPoint });
                    }
                    curves.push({ type: "quadratic", controlPoints });
                }
                break;
            case "bezierCurveTo":
                {
                    const { x, y, cp1x, cp1y, cp2x, cp2y } = canvasCommand;
                    const controlPoints = [
                        { x: cp1x, y: cp1y },
                        { x: cp2x, y: cp2y },
                        { x, y },
                    ];
                    if (curves.length === 0) {
                        controlPoints.unshift({ ...startPoint });
                    }
                    curves.push({ type: "cubic", controlPoints });
                }
                break;
            case "closePath":
                if (curves.length === 0)
                    break;
                curves = simplifyCurves(curves);
                const controlPoints = curves.flatMap((c) => c.controlPoints);
                if (isDrawingPath) {
                    const isHole = classifySubpath(controlPoints, parsedPaths, fillRule);
                    parsedPaths.push({ path: controlPoints, isHole });
                    if (isHole != wasHole) {
                        wasHole = isHole;
                        if (isHole) {
                            displayCommands.push({
                                type: "selectFillColor",
                                fillColorIndex: 0,
                            });
                        }
                        else {
                            displayCommands.push({
                                type: "selectFillColor",
                                fillColorIndex: getFillColorIndex(),
                            });
                        }
                    }
                }
                if (ignoreFill) {
                    displayCommands.push({
                        type: "setLineWidth",
                        lineWidth: 0,
                    });
                    displayCommands.push({
                        type: "selectFillColor",
                        fillColorIndex: getLineColorIndex(),
                    });
                    displayCommands.push({
                        type: "setIgnoreFill",
                        ignoreFill: false,
                    });
                }
                const isSegments = curves.every((c) => c.type === "segment");
                if (isSegments) {
                    if (ignoreFill) {
                        displayCommands.push({
                            type: "drawSegments",
                            points: controlPoints,
                        });
                    }
                    else {
                        displayCommands.push({
                            type: "drawPolygon",
                            points: controlPoints,
                        });
                    }
                }
                else {
                    if (ignoreFill) {
                        displayCommands.push({ type: "drawPath", curves });
                    }
                    else {
                        displayCommands.push({ type: "drawClosedPath", curves });
                    }
                }
                if (ignoreFill) {
                    displayCommands.push({
                        type: "setLineWidth",
                        lineWidth,
                    });
                    displayCommands.push({
                        type: "selectFillColor",
                        fillColorIndex: getFillColorIndex(),
                    });
                    displayCommands.push({
                        type: "setIgnoreFill",
                        ignoreFill,
                    });
                }
                curves = [];
                break;
            case "pathStart":
                parsedPaths.length = 0;
                if (wasHole) {
                    displayCommands.push({ type: "selectFillColor", fillColorIndex });
                }
                wasHole = false;
                isDrawingPath = true;
                break;
            case "pathEnd":
                isDrawingPath = false;
                break;
            case "line":
                if (strokeStyle != "none") {
                    displayCommands.push({
                        type: "setLineWidth",
                        lineWidth: 0,
                    });
                    displayCommands.push({
                        type: "selectFillColor",
                        fillColorIndex: getLineColorIndex(),
                    });
                    displayCommands.push({
                        type: "setIgnoreFill",
                        ignoreFill: false,
                    });
                    const { x1, y1, x2, y2 } = canvasCommand;
                    displayCommands.push({
                        type: "drawSegment",
                        startX: x1,
                        startY: y1,
                        endX: x2,
                        endY: y2,
                    });
                    displayCommands.push({
                        type: "setLineWidth",
                        lineWidth,
                    });
                    displayCommands.push({
                        type: "selectFillColor",
                        fillColorIndex: getFillColorIndex(),
                    });
                    displayCommands.push({
                        type: "setIgnoreFill",
                        ignoreFill,
                    });
                }
                break;
            case "fillStyle":
                _console$n.log("fillStyle", canvasCommand.fillStyle);
                if (fillStyle != canvasCommand.fillStyle) {
                    const newIgnoreFill = canvasCommand.fillStyle == "none";
                    if (ignoreFill != newIgnoreFill) {
                        ignoreFill = newIgnoreFill;
                        _console$n.log({ ignoreFill });
                        displayCommands.push({ type: "setIgnoreFill", ignoreFill });
                    }
                    if (!ignoreFill) {
                        if (fillStyle != canvasCommand.fillStyle) {
                            fillStyle = canvasCommand.fillStyle;
                            if (fillColorIndex != colorToIndex[fillStyle]) {
                                _console$n.log({ fillColorIndex });
                                fillColorIndex = colorToIndex[fillStyle];
                                displayCommands.push({
                                    type: "selectFillColor",
                                    fillColorIndex: getFillColorIndex(),
                                });
                            }
                        }
                    }
                }
                break;
            case "strokeStyle":
                _console$n.log("strokeStyle", canvasCommand.strokeStyle);
                if (strokeStyle != canvasCommand.strokeStyle) {
                    const newIgnoreLine = canvasCommand.strokeStyle == "none";
                    if (ignoreLine != newIgnoreLine) {
                        ignoreLine = newIgnoreLine;
                        _console$n.log({ ignoreLine });
                        displayCommands.push({ type: "setIgnoreLine", ignoreLine });
                    }
                    if (!ignoreLine) {
                        if (strokeStyle != canvasCommand.strokeStyle) {
                            strokeStyle = canvasCommand.strokeStyle;
                            if (lineColorIndex != colorToIndex[strokeStyle]) {
                                _console$n.log({ lineColorIndex });
                                lineColorIndex = colorToIndex[strokeStyle];
                                displayCommands.push({
                                    type: "selectLineColor",
                                    lineColorIndex: getLineColorIndex(),
                                });
                            }
                        }
                    }
                }
                break;
            case "lineWidth":
                if (lineWidth != canvasCommand.lineWidth) {
                    lineWidth = canvasCommand.lineWidth;
                    displayCommands.push({ type: "setLineWidth", lineWidth });
                    segmentRadius = lineWidth / 2;
                    displayCommands.push({
                        type: "setSegmentRadius",
                        segmentRadius,
                    });
                }
                break;
            case "fillRule":
                fillRule = canvasCommand.fillRule;
                break;
            case "rect":
                {
                    const { x, y, width, height, rotation } = canvasCommand;
                    displayCommands.push({
                        type: "setRotation",
                        rotation,
                        isRadians: true,
                    });
                    displayCommands.push({
                        type: "drawRect",
                        offsetX: x,
                        offsetY: y,
                        width: width,
                        height: height,
                    });
                }
                break;
            case "roundRect":
                {
                    const { x, y, width, height, rotation, r } = canvasCommand;
                    displayCommands.push({
                        type: "setRotation",
                        rotation,
                        isRadians: true,
                    });
                    displayCommands.push({
                        type: "drawRoundRect",
                        offsetX: x,
                        offsetY: y,
                        width: width,
                        height: height,
                        borderRadius: r,
                    });
                }
                break;
            case "circle":
                {
                    const { x, y, r } = canvasCommand;
                    displayCommands.push({
                        type: "drawCircle",
                        offsetX: x,
                        offsetY: y,
                        radius: r,
                    });
                }
                break;
            case "ellipse":
                {
                    const { x, y, rx, ry, rotation } = canvasCommand;
                    displayCommands.push({
                        type: "setRotation",
                        rotation,
                        isRadians: true,
                    });
                    displayCommands.push({
                        type: "drawEllipse",
                        offsetX: x,
                        offsetY: y,
                        radiusX: rx,
                        radiusY: ry,
                    });
                }
                break;
            default:
                _console$n.warn("uncaught canvasCommand", canvasCommand);
                break;
        }
    });
    displayCommands = trimContextCommands(displayCommands);
    _console$n.log("displayCommands", displayCommands);
    _console$n.log("colors", colors);
    return { commands: displayCommands, colors, width, height };
}
function svgToSprite(svgString, spriteName, numberOfColors, paletteName, overridePalette, spriteSheet, paletteOffset = 0, options) {
    options = { ...defaultParseSvgOptions, ...options };
    _console$n.log("options", options, { overridePalette });
    let palette = spriteSheet.palettes?.find((palette) => palette.name == paletteName);
    if (!palette) {
        palette = {
            name: paletteName,
            numberOfColors,
            colors: new Array(numberOfColors).fill("#000000"),
        };
        spriteSheet.palettes = spriteSheet.palettes || [];
        spriteSheet.palettes?.push(palette);
    }
    _console$n.log("pallete", palette);
    const { commands, colors, width, height } = svgToDisplayContextCommands(svgString, numberOfColors, paletteOffset, !overridePalette ? palette.colors : undefined, options);
    const sprite = {
        name: spriteName,
        width,
        height,
        paletteSwaps: [],
        commands,
    };
    if (overridePalette) {
        _console$n.log("overriding palette", colors);
        colors.forEach((color, index) => {
            palette.colors[index + paletteOffset] = color;
        });
    }
    const spriteIndex = spriteSheet.sprites.findIndex((sprite) => sprite.name == spriteName);
    if (spriteIndex == -1) {
        spriteSheet.sprites.push(sprite);
    }
    else {
        _console$n.log(`overwriting spriteInde ${spriteIndex}`);
        spriteSheet.sprites[spriteIndex] = sprite;
    }
    return sprite;
}
function svgToSpriteSheet(svgString, spriteSheetName, numberOfColors, paletteName, options) {
    const spriteSheet = {
        name: spriteSheetName,
        palettes: [],
        paletteSwaps: [],
        sprites: [],
    };
    svgToSprite(svgString, "svg", numberOfColors, paletteName, true, spriteSheet, 0, options);
    return spriteSheet;
}
function getSvgStringFromDataUrl(string) {
    if (!string.startsWith("data:image/svg+xml"))
        throw new Error("Not a data URL");
    const data = string.split(",")[1];
    if (string.includes("base64")) {
        return atob(data);
    }
    else {
        return decodeURIComponent(data);
    }
}
function isValidSVG(svgString) {
    if (typeof svgString !== "string")
        return false;
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgString, "image/svg+xml");
    if (doc.querySelector("parsererror") ||
        doc.getElementsByTagName("parsererror").length > 0) {
        return false;
    }
    const root = doc.documentElement;
    return (!!root &&
        root.nodeName.toLowerCase() === "svg" &&
        root.namespaceURI === "http://www.w3.org/2000/svg");
}

function capitalizeFirstCharacter(string) {
    return string[0].toUpperCase() + string.slice(1);
}
function removeRedundantCharacters(string) {
    return removeRedundancies(Array.from(string)).join("");
}
function removeSubstrings(string, substrings) {
    let result = string;
    for (const sub of substrings) {
        result = result.split(sub).join("");
    }
    return result;
}

const _console$m = createConsole("DisplaySpriteSheetUtils", { log: false });
const spriteHeaderLength = 3 * 2;
function calculateSpriteSheetHeaderLength(numberOfSprites) {
    return 2 + numberOfSprites * 2 + numberOfSprites * spriteHeaderLength;
}
function getCurvesPoints(curves) {
    const curvePoints = [];
    curves.forEach((curve, index) => {
        if (index == 0) {
            curvePoints.push(curve.controlPoints[0]);
        }
        curvePoints.push(curve.controlPoints.at(-1));
    });
    return curvePoints;
}
function serializeSpriteSheet(displayManager, spriteSheet) {
    const { name, sprites } = spriteSheet;
    _console$m.log(`serializing ${name} spriteSheet`, spriteSheet);
    const numberOfSprites = sprites.length;
    const numberOfSpritesDataView = new DataView(new ArrayBuffer(2));
    numberOfSpritesDataView.setUint16(0, numberOfSprites, true);
    const spritePayloads = sprites.map((sprite, index) => {
        const commandsData = serializeContextCommands(displayManager, sprite.commands);
        const dataView = new DataView(new ArrayBuffer(spriteHeaderLength));
        dataView.setUint16(0, sprite.width, true);
        dataView.setUint16(2, sprite.height, true);
        dataView.setUint16(4, commandsData.byteLength, true);
        const serializedSprite = concatenateArrayBuffers(dataView, commandsData);
        _console$m.log("serializedSprite", sprite, serializedSprite);
        return serializedSprite;
    });
    const spriteOffsetsDataView = new DataView(new ArrayBuffer(sprites.length * 2));
    let offset = numberOfSpritesDataView.byteLength + spriteOffsetsDataView.byteLength;
    spritePayloads.forEach((spritePayload, index) => {
        spriteOffsetsDataView.setUint16(index * 2, offset, true);
        offset += spritePayload.byteLength;
    });
    const serializedSpriteSheet = concatenateArrayBuffers(numberOfSpritesDataView, spriteOffsetsDataView, spritePayloads);
    _console$m.log("serializedSpriteSheet", serializedSpriteSheet);
    return serializedSpriteSheet;
}
const defaultFontToSpriteSheetOptions = {
    stroke: false,
    strokeWidth: 1,
    unicodeOnly: true,
    englishOnly: true,
    usePath: false,
};
function isWoff2(arrayBuffer) {
    if (arrayBuffer.byteLength < 4)
        return false;
    const header = new Uint8Array(arrayBuffer, 0, 4);
    return (header[0] === 0x77 &&
        header[1] === 0x4f &&
        header[2] === 0x46 &&
        header[3] === 0x32
    );
}
async function parseFont(arrayBuffer) {
    if (isWoff2(arrayBuffer)) {
        const result = await Q(arrayBuffer);
        arrayBuffer = result.buffer;
    }
    const font = opentype.parse(arrayBuffer);
    return font;
}
function getFontUnicodeRange(font) {
    const rangeHelper = new RangeHelper();
    for (let i = 0; i < font.glyphs.length; i++) {
        const glyph = font.glyphs.get(i);
        if (!glyph.unicodes || glyph.unicodes.length === 0)
            continue;
        glyph.unicodes
            .filter((unicode) => {
            const char = String.fromCodePoint(unicode);
            return /\p{Letter}/u.test(char);
        })
            .forEach((unicode) => rangeHelper.update(unicode));
    }
    return rangeHelper.span > 0 ? rangeHelper.range : undefined;
}
const englishRegex = /^[A-Za-z0-9 !"#$%&'()*+,\-./:;?@[\]^_`{|}~\\]+$/;
function contourArea(points) {
    let area = 0;
    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
        area += (points[j].x - points[i].x) * (points[j].y + points[i].y);
    }
    return area;
}
function getFontMetrics(font, fontSize, options) {
    _console$m.assertTypeWithError(fontSize, "number");
    options = options
        ? { ...defaultFontToSpriteSheetOptions, ...options }
        : defaultFontToSpriteSheetOptions;
    const fonts = Array.isArray(font) ? font : [font];
    let minSpriteY = Infinity;
    let maxSpriteY = -Infinity;
    const strokeWidth = options.stroke ? options.strokeWidth || 1 : 0;
    let string = options.string;
    if (string) {
        string = removeRedundantCharacters(string);
        console.log("filtered string", string);
    }
    for (let font of fonts) {
        const fontScale = (1 / font.unitsPerEm) * fontSize;
        let filteredGlyphs;
        if (string != undefined) {
            filteredGlyphs = font
                .stringToGlyphs(string)
                .filter((glyph) => glyph.unicode != undefined);
            string = removeSubstrings(string, filteredGlyphs.map((glyph) => String.fromCharCode(glyph.unicode)));
        }
        for (let index = 0; index < font.glyphs.length; index++) {
            const glyph = font.glyphs.get(index);
            const hasUnicode = glyph.unicode != undefined;
            if (filteredGlyphs) {
                if (!filteredGlyphs.includes(glyph)) {
                    continue;
                }
            }
            if (options.unicodeOnly || options.englishOnly) {
                if (!hasUnicode) {
                    continue;
                }
            }
            if (options.script && hasUnicode) {
                const regex = new RegExp(`\\p{Script=${options.script}}`, "u");
                if (!regex.test(String.fromCharCode(glyph.unicode))) {
                    continue;
                }
            }
            if (options.englishOnly) {
                if (!englishRegex.test(String.fromCharCode(glyph.unicode))) {
                    continue;
                }
            }
            const bbox = glyph.getBoundingBox();
            minSpriteY = Math.min(minSpriteY, bbox.y1 * fontScale);
            maxSpriteY = Math.max(maxSpriteY, bbox.y2 * fontScale);
        }
    }
    minSpriteY = options.minSpriteY ?? minSpriteY;
    maxSpriteY = options.maxSpriteY ?? maxSpriteY;
    const maxSpriteHeight = options.maxSpriteheight ?? maxSpriteY - minSpriteY + strokeWidth;
    return { maxSpriteHeight, maxSpriteY, minSpriteY };
}
async function fontToSpriteSheet(font, fontSize, spriteSheetName, options) {
    _console$m.assertTypeWithError(fontSize, "number");
    options = options
        ? { ...defaultFontToSpriteSheetOptions, ...options }
        : defaultFontToSpriteSheetOptions;
    const fonts = Array.isArray(font) ? font : [font];
    font = fonts[0];
    spriteSheetName = spriteSheetName || font.getEnglishName("fullName");
    const spriteSheet = {
        name: spriteSheetName,
        sprites: [],
    };
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const { maxSpriteHeight, maxSpriteY, minSpriteY } = getFontMetrics(fonts, fontSize, options);
    const strokeWidth = options.stroke ? options.strokeWidth || 1 : 0;
    let string = options.string;
    if (string) {
        string = removeRedundantCharacters(string);
        _console$m.log("filtered string", string);
    }
    for (let font of fonts) {
        const fontScale = (1 / font.unitsPerEm) * fontSize;
        const glyphs = [];
        let filteredGlyphs;
        if (string != undefined) {
            filteredGlyphs = font
                .stringToGlyphs(string)
                .filter((glyph) => glyph.unicode != undefined);
            string = removeSubstrings(string, filteredGlyphs.map((glyph) => String.fromCharCode(glyph.unicode)));
        }
        for (let index = 0; index < font.glyphs.length; index++) {
            const glyph = font.glyphs.get(index);
            const hasUnicode = glyph.unicode != undefined;
            if (filteredGlyphs) {
                if (!filteredGlyphs.includes(glyph)) {
                    continue;
                }
            }
            if (options.unicodeOnly || options.englishOnly) {
                if (!hasUnicode) {
                    continue;
                }
            }
            if (options.script && hasUnicode) {
                const regex = new RegExp(`\\p{Script=${options.script}}`, "u");
                if (!regex.test(String.fromCharCode(glyph.unicode))) {
                    continue;
                }
            }
            if (options.englishOnly) {
                if (!englishRegex.test(String.fromCharCode(glyph.unicode))) {
                    continue;
                }
            }
            glyphs.push(glyph);
        }
        for (let i = 0; i < glyphs.length; i++) {
            const glyph = glyphs[i];
            let name = glyph.name;
            if (glyph.unicode != undefined) {
                name = String.fromCharCode(glyph.unicode);
            }
            if (typeof name != "string") {
                continue;
            }
            const bbox = glyph.getBoundingBox();
            const spriteWidth = Math.max(Math.max(bbox.x2, bbox.x2 - bbox.x1), glyph.advanceWidth || 0) *
                fontScale +
                strokeWidth;
            const spriteHeight = maxSpriteHeight;
            const commands = [];
            const path = glyph.getPath(-bbox.x1 * fontScale, bbox.y2 * fontScale, fontSize);
            if (options.stroke) {
                path.stroke = "white";
                path.strokeWidth = strokeWidth;
                commands.push({ type: "setLineWidth", lineWidth: strokeWidth });
                commands.push({ type: "setIgnoreFill", ignoreFill: true });
            }
            else {
                path.fill = "white";
            }
            const bitmapWidth = (bbox.x2 - bbox.x1) * fontScale + strokeWidth;
            const bitmapHeight = (bbox.y2 - bbox.y1) * fontScale + strokeWidth;
            const bitmapX = (spriteWidth - bitmapWidth) / 2;
            const bitmapY = (spriteHeight - bitmapHeight) / 2 - (bbox.y1 * fontScale - minSpriteY);
            if (options.usePath) {
                const pathOffset = {
                    x: -bitmapWidth / 2 + bitmapX,
                    y: -bitmapHeight / 2 + bitmapY,
                };
                let curves = [];
                let startPoint = { x: 0, y: 0 };
                const allCurves = [];
                const parsedPaths = [];
                let wasHole = false;
                let pathCommands = path.commands;
                pathCommands.forEach((cmd) => {
                    switch (cmd.type) {
                        case "M":
                            {
                                startPoint.x = cmd.x;
                                startPoint.y = cmd.y;
                            }
                            break;
                        case "L":
                            {
                                const controlPoints = [{ x: cmd.x, y: cmd.y }];
                                if (curves.length === 0) {
                                    controlPoints.unshift({ ...startPoint });
                                }
                                curves.push({ type: "segment", controlPoints });
                            }
                            break;
                        case "Q":
                            {
                                const controlPoints = [
                                    { x: cmd.x1, y: cmd.y1 },
                                    { x: cmd.x, y: cmd.y },
                                ];
                                if (curves.length === 0) {
                                    controlPoints.unshift({ ...startPoint });
                                }
                                curves.push({ type: "quadratic", controlPoints });
                            }
                            break;
                        case "C":
                            {
                                const controlPoints = [
                                    { x: cmd.x1, y: cmd.y1 },
                                    { x: cmd.x2, y: cmd.y2 },
                                    { x: cmd.x, y: cmd.y },
                                ];
                                if (curves.length === 0) {
                                    controlPoints.unshift({ ...startPoint });
                                }
                                curves.push({ type: "cubic", controlPoints });
                            }
                            break;
                        case "Z":
                            {
                                if (curves.length === 0) {
                                    break;
                                }
                                curves = simplifyCurves(curves);
                                const controlPoints = curves.flatMap((c) => c.controlPoints);
                                controlPoints.forEach((pt) => {
                                    pt.x = pt.x + pathOffset.x;
                                    pt.y = pt.y + pathOffset.y;
                                });
                                allCurves.push(curves);
                                curves = [];
                            }
                            break;
                    }
                });
                allCurves.sort((a, b) => {
                    const aPoints = getCurvesPoints(a);
                    const bPoints = getCurvesPoints(b);
                    return contourArea(bPoints) - contourArea(aPoints);
                });
                allCurves.forEach((curve) => {
                    const controlPoints = curve.flatMap((c) => c.controlPoints);
                    const isHole = classifySubpath(controlPoints, parsedPaths, "nonzero");
                    parsedPaths.push({ path: controlPoints, isHole });
                    if (isHole != wasHole) {
                        wasHole = isHole;
                        if (isHole) {
                            commands.push({
                                type: "selectFillColor",
                                fillColorIndex: 0,
                            });
                        }
                        else {
                            commands.push({
                                type: "selectFillColor",
                                fillColorIndex: 1,
                            });
                        }
                    }
                    const isSegments = curves.every((c) => c.type === "segment");
                    if (isSegments) {
                        commands.push({
                            type: "drawPolygon",
                            points: controlPoints,
                        });
                    }
                    else {
                        commands.push({ type: "drawClosedPath", curves });
                    }
                });
            }
            else {
                if (bitmapWidth > 0 && bitmapHeight > 0) {
                    canvas.width = bitmapWidth;
                    canvas.height = bitmapHeight;
                    ctx.imageSmoothingEnabled = false;
                    ctx.fillStyle = "black";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    path.draw(ctx);
                    const { colorIndices } = await quantizeCanvas(canvas, 2, [
                        "#000000",
                        "#ffffff",
                    ]);
                    const bitmap = {
                        width: bitmapWidth,
                        height: bitmapHeight,
                        numberOfColors: 2,
                        pixels: colorIndices,
                    };
                    commands.push({
                        type: "selectBitmapColor",
                        bitmapColorIndex: 1,
                        colorIndex: 1,
                    });
                    commands.push({
                        type: "drawBitmap",
                        offsetX: bitmapX,
                        offsetY: bitmapY,
                        bitmap,
                    });
                }
            }
            const sprite = {
                name,
                commands,
                width: spriteWidth,
                height: spriteHeight,
            };
            spriteSheet.sprites.push(sprite);
        }
        if (string != undefined && string.length == 0) {
            break;
        }
    }
    return spriteSheet;
}
function stringToSprites(string, spriteSheet, requireAll = false) {
    const sprites = [];
    let substring = string;
    while (substring.length > 0) {
        let longestSprite;
        spriteSheet.sprites.forEach((sprite) => {
            if (substring.startsWith(sprite.name)) {
                if (!longestSprite || sprite.name.length > longestSprite.name.length) {
                    longestSprite = sprite;
                }
            }
        });
        if (requireAll) {
            _console$m.assertWithError(longestSprite, `couldn't find sprite with name prefixing "${substring}"`);
        }
        if (longestSprite) {
            sprites.push(longestSprite);
            substring = substring.substring(longestSprite.name.length);
        }
        else {
            substring = substring.substring(1);
        }
    }
    return sprites;
}
function getReferencedSprites(sprite, spriteSheet) {
    const sprites = [];
    sprite.commands
        .filter((command) => command.type == "drawSprite")
        .map((command) => command.spriteIndex)
        .map((spriteIndex) => spriteSheet.sprites[spriteIndex])
        .forEach((_sprite) => {
        if (!sprites.includes(_sprite)) {
            sprites.push(_sprite);
            sprites.push(...getReferencedSprites(_sprite, spriteSheet));
        }
    });
    _console$m.log("referencedSprites", sprite, sprites);
    return sprites;
}
function reduceSpriteSheet(spriteSheet, spriteNames, requireAll = false) {
    const reducedSpriteSheet = Object.assign({}, spriteSheet);
    if (!(spriteNames instanceof Array)) {
        spriteNames = stringToSprites(spriteNames, spriteSheet, requireAll).map((sprite) => sprite.name);
    }
    _console$m.log("reducingSpriteSheet", spriteSheet, spriteNames);
    reducedSpriteSheet.sprites = [];
    spriteSheet.sprites.forEach((sprite) => {
        if (spriteNames.includes(sprite.name)) {
            reducedSpriteSheet.sprites.push(sprite);
            reducedSpriteSheet.sprites.push(...getReferencedSprites(sprite, spriteSheet));
        }
    });
    _console$m.log("reducedSpriteSheet", reducedSpriteSheet);
    return reducedSpriteSheet;
}
function stringToSpriteLines(string, spriteSheets, contextState, requireAll = false, maxLineBreadth = Infinity, separators = [" "]) {
    _console$m.log("stringToSpriteLines", string);
    const isSpritesDirectionHorizontal = isDirectionHorizontal(contextState.spritesDirection);
    const isSpritesLineDirectionHorizontal = isDirectionHorizontal(contextState.spritesLineDirection);
    const areSpritesDirectionsOrthogonal = isSpritesDirectionHorizontal != isSpritesLineDirectionHorizontal;
    const lineStrings = string.split("\n");
    let lineBreadth = 0;
    if (isSpritesDirectionHorizontal) {
        maxLineBreadth /= contextState.spriteScaleX;
    }
    else {
        maxLineBreadth /= contextState.spriteScaleY;
    }
    const sprites = [];
    let latestSeparatorIndex = -1;
    let latestSeparator;
    let latestSeparatorLineBreadth;
    let latestSeparatorBreadth;
    const spritesLineIndices = [];
    lineStrings.forEach((lineString) => {
        sprites.push([]);
        spritesLineIndices.push([]);
        const i = sprites.length - 1;
        if (areSpritesDirectionsOrthogonal) {
            lineBreadth = 0;
        }
        else {
            lineBreadth += contextState.spritesLineSpacing;
        }
        let lineSubstring = lineString;
        while (lineSubstring.length > 0) {
            let longestSprite;
            let longestSpriteSheet;
            for (let spriteSheetName in spriteSheets) {
                const spriteSheet = spriteSheets[spriteSheetName];
                spriteSheet.sprites.forEach((sprite) => {
                    if (lineSubstring.startsWith(sprite.name)) {
                        if (!longestSprite ||
                            sprite.name.length > longestSprite.name.length) {
                            longestSprite = sprite;
                            longestSpriteSheet = spriteSheet;
                        }
                    }
                });
            }
            if (requireAll) {
                _console$m.assertWithError(longestSprite, `couldn't find sprite with name prefixing "${lineSubstring}"`);
            }
            if (longestSprite && longestSpriteSheet) {
                const isSeparator = separators.length > 0
                    ? separators.includes(longestSprite.name)
                    : true;
                sprites[i].push({
                    sprite: longestSprite,
                    spriteSheet: longestSpriteSheet,
                });
                let newLineBreadth = lineBreadth;
                const longestSpriteBreadth = isSpritesDirectionHorizontal
                    ? longestSprite.width
                    : longestSprite.height;
                newLineBreadth += longestSpriteBreadth;
                newLineBreadth += contextState.spritesSpacing;
                if (newLineBreadth >= maxLineBreadth) {
                    if (isSeparator) {
                        if (longestSprite.name.trim().length == 0) {
                            sprites[i].pop();
                        }
                        spritesLineIndices[i].push(sprites[i].length);
                        lineBreadth = 0;
                    }
                    else {
                        if (latestSeparatorIndex != -1) {
                            if (latestSeparator.trim().length == 0) {
                                sprites[i].splice(latestSeparatorIndex, 1);
                                lineBreadth -= latestSeparatorBreadth;
                            }
                            spritesLineIndices[i].push(latestSeparatorIndex);
                            lineBreadth = newLineBreadth - latestSeparatorLineBreadth;
                        }
                        else {
                            spritesLineIndices[i].push(sprites[i].length - 1);
                            lineBreadth = 0;
                        }
                    }
                    latestSeparatorIndex = -1;
                    latestSeparator = undefined;
                }
                else {
                    lineBreadth = newLineBreadth;
                    if (isSeparator) {
                        latestSeparator = longestSprite.name;
                        latestSeparatorIndex = sprites[i].length - 1;
                        latestSeparatorLineBreadth = lineBreadth;
                        latestSeparatorBreadth = longestSpriteBreadth;
                    }
                }
                lineSubstring = lineSubstring.substring(longestSprite.name.length);
            }
            else {
                lineSubstring = lineSubstring.substring(1);
            }
        }
    });
    const spriteLines = [];
    sprites.forEach((_sprites, i) => {
        let spriteLine = [];
        spriteLines.push(spriteLine);
        let spriteSubLine;
        _sprites.forEach(({ sprite, spriteSheet }, index) => {
            if (spritesLineIndices[i].includes(index)) {
                spriteLine = [];
                spriteLines.push(spriteLine);
                spriteSubLine = undefined;
            }
            if (!spriteSubLine || spriteSubLine.spriteSheetName != spriteSheet.name) {
                spriteSubLine = {
                    spriteSheetName: spriteSheet.name,
                    spriteNames: [],
                };
                spriteLine.push(spriteSubLine);
            }
            spriteSubLine.spriteNames.push(sprite.name);
        });
    });
    _console$m.log(`spriteLines for "${string}"`, spriteLines);
    return spriteLines;
}
function getFontMaxHeight(font, fontSize) {
    const scale = (1 / font.unitsPerEm) * fontSize;
    const maxHeight = (font.ascender - font.descender) * scale;
    return maxHeight;
}
function getMaxSpriteSheetSize(spriteSheet) {
    const size = { width: 0, height: 0 };
    spriteSheet.sprites.forEach((sprite) => {
        size.width = Math.max(size.width, sprite.width);
        size.height = Math.max(size.height, sprite.height);
    });
    return size;
}
function assertValidSpriteLines(displayManager, spriteLines) {
    spriteLines.forEach((spriteLine) => {
        spriteLine.forEach((spriteSubLine) => {
            const { spriteSheetName, spriteNames } = spriteSubLine;
            displayManager.assertLoadedSpriteSheet(spriteSheetName);
            const spriteSheet = displayManager.spriteSheets[spriteSheetName];
            spriteNames.forEach((spriteName) => {
                const sprite = spriteSheet.sprites.find((sprite) => sprite.name == spriteName);
                _console$m.assertWithError(sprite, `no sprite with name "${spriteName}" found in spriteSheet "${spriteSheetName}"`);
            });
        });
    });
}
function getExpandedSpriteLines(spriteLines, spriteSheets) {
    const expandedSpritesLines = [];
    spriteLines.forEach((spriteLine) => {
        const _spritesLine = [];
        spriteLine.forEach(({ spriteSheetName, spriteNames }) => {
            const spriteSheet = spriteSheets[spriteSheetName];
            _console$m.assertWithError(spriteSheet, `no spriteSheet found with name "${spriteSheetName}"`);
            spriteNames.forEach((spriteName) => {
                const sprite = spriteSheet.sprites.find((sprite) => sprite.name == spriteName);
                _console$m.assertWithError(sprite, `no sprite found with name "${spriteName} in "${spriteSheetName}" spriteSheet`);
                _spritesLine.push(sprite);
            });
        });
        expandedSpritesLines.push(_spritesLine);
    });
    return expandedSpritesLines;
}
function getExpandedSpriteLinesSize(expandedSpritesLines, contextState) {
    const localSize = { width: 0, height: 0 };
    const isSpritesDirectionHorizontal = isDirectionHorizontal(contextState.spritesDirection);
    const isSpritesLineDirectionHorizontal = isDirectionHorizontal(contextState.spritesLineDirection);
    const areSpritesDirectionsOrthogonal = isSpritesDirectionHorizontal != isSpritesLineDirectionHorizontal;
    const breadthSizeKey = isSpritesDirectionHorizontal ? "width" : "height";
    const depthSizeKey = isSpritesLineDirectionHorizontal ? "width" : "height";
    if (!areSpritesDirectionsOrthogonal) {
        if (isSpritesDirectionHorizontal) {
            localSize.height += contextState.spritesLineHeight;
        }
        else {
            localSize.width += contextState.spritesLineHeight;
        }
    }
    const lineBreadths = [];
    expandedSpritesLines.forEach((expandedSpriteLine, lineIndex) => {
        let spritesLineBreadth = 0;
        expandedSpriteLine.forEach((sprite) => {
            spritesLineBreadth += isSpritesDirectionHorizontal
                ? sprite.width
                : sprite.height;
            spritesLineBreadth += contextState.spritesSpacing;
        });
        spritesLineBreadth -= contextState.spritesSpacing;
        if (areSpritesDirectionsOrthogonal) {
            localSize[breadthSizeKey] = Math.max(localSize[breadthSizeKey], spritesLineBreadth);
            localSize[depthSizeKey] += contextState.spritesLineHeight;
        }
        else {
            localSize[breadthSizeKey] += spritesLineBreadth;
        }
        localSize[depthSizeKey] += contextState.spritesLineSpacing;
        lineBreadths.push(spritesLineBreadth);
    });
    localSize[depthSizeKey] -= contextState.spritesLineSpacing;
    const spritesScaledWidth = localSize.width * Math.abs(contextState.spriteScaleX);
    const spritesScaledHeight = localSize.height * Math.abs(contextState.spriteScaleY);
    const size = {
        width: spritesScaledWidth,
        height: spritesScaledHeight,
    };
    return { localSize, size, lineBreadths };
}
function getSpriteLinesMetrics(spriteLines, spriteSheets, contextState) {
    const expandedSpritesLines = getExpandedSpriteLines(spriteLines, spriteSheets);
    return {
        expandedSpritesLines,
        numberOfLines: expandedSpritesLines.length,
        ...getExpandedSpriteLinesSize(expandedSpritesLines, contextState),
    };
}
function stringToSpriteLinesMetrics(string, spriteSheets, contextState, requireAll, maxLineBreadth, separators) {
    return getSpriteLinesMetrics(stringToSpriteLines(string, spriteSheets, contextState, requireAll, maxLineBreadth, separators), spriteSheets, contextState);
}
function spriteLinesToSerializedLines(displayManager, spriteLines) {
    const spriteSerializedLines = [];
    spriteLines.forEach((spriteLine) => {
        const serializedLine = [];
        spriteLine.forEach((spriteSubLine) => {
            displayManager.assertLoadedSpriteSheet(spriteSubLine.spriteSheetName);
            const spriteSheet = displayManager.spriteSheets[spriteSubLine.spriteSheetName];
            const spriteSheetIndex = displayManager.spriteSheetIndices[spriteSheet.name];
            const serializedSubLine = {
                spriteSheetIndex,
                spriteIndices: [],
                use2Bytes: spriteSheet.sprites.length > 255,
            };
            spriteSubLine.spriteNames.forEach((spriteName) => {
                let spriteIndex = spriteSheet.sprites.findIndex((sprite) => sprite.name == spriteName);
                _console$m.assertWithError(spriteIndex != -1, `sprite "${spriteName}" not found`);
                spriteIndex = spriteIndex;
                serializedSubLine.spriteIndices.push(spriteIndex);
            });
            serializedLine.push(serializedSubLine);
        });
        spriteSerializedLines.push(serializedLine);
    });
    _console$m.log("spriteSerializedLines", spriteSerializedLines);
    return spriteSerializedLines;
}

const _console$l = createConsole("DisplayBitmapUtils", { log: false });
const drawBitmapHeaderLength = 2 + 2 + 2 + 4 + 1 + 2;
function getBitmapData(bitmap) {
    const pixelDataLength = getBitmapNumberOfBytes(bitmap);
    const dataView = new DataView(new ArrayBuffer(pixelDataLength));
    const pixelDepth = numberOfColorsToPixelDepth(bitmap.numberOfColors);
    const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);
    bitmap.pixels.forEach((bitmapColorIndex, pixelIndex) => {
        const byteIndex = Math.floor(pixelIndex / pixelsPerByte);
        const byteSlot = pixelIndex % pixelsPerByte;
        const pixelBitWidth = pixelDepthToPixelBitWidth(pixelDepth);
        const bitOffset = pixelBitWidth * byteSlot;
        const shift = 8 - pixelBitWidth - bitOffset;
        let value = dataView.getUint8(byteIndex);
        value |= bitmapColorIndex << shift;
        dataView.setUint8(byteIndex, value);
    });
    _console$l.log("getBitmapData", bitmap, dataView);
    return dataView;
}
async function quantizeCanvas(canvas, numberOfColors, colors) {
    _console$l.assertWithError(numberOfColors > 1, "numberOfColors must be greater than 1");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    removeAlphaFromCanvas(canvas);
    const isSmall = canvas.width * canvas.height < 4;
    const quantOptions = {
        method: isSmall ? 1 : 2,
        colors: numberOfColors,
        dithKern: null,
        useCache: false,
        reIndex: true,
        orDist: "manhattan",
    };
    if (colors) {
        quantOptions.palette = colors.map((color) => {
            const rgb = hexToRGB(color);
            if (rgb) {
                const { r, g, b } = rgb;
                return [r, g, b];
            }
            else {
                _console$l.error(`invalid rgb hex "${color}"`);
            }
        });
    }
    const quantizer = new RGBQuant(quantOptions);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    quantizer.sample(imageData);
    const quantizedPixels = quantizer.reduce(imageData.data);
    const quantizedImageData = new ImageData(new Uint8ClampedArray(quantizedPixels.buffer), canvas.width, canvas.height);
    ctx.putImageData(quantizedImageData, 0, 0);
    const pixels = quantizedImageData.data;
    const quantizedPaletteData = quantizer.palette();
    const numberOfQuantizedPaletteColors = quantizedPaletteData.byteLength / 4;
    const quantizedPaletteColors = [];
    let closestColorIndexToBlack = 0;
    let closestColorDistanceToBlack = Infinity;
    const vector3 = { x: 0, y: 0, z: 0 };
    for (let colorIndex = 0; colorIndex < numberOfQuantizedPaletteColors; colorIndex++) {
        const rgb = {
            r: quantizedPaletteData[colorIndex * 4],
            g: quantizedPaletteData[colorIndex * 4 + 1],
            b: quantizedPaletteData[colorIndex * 4 + 2],
        };
        quantizedPaletteColors.push(rgb);
        vector3.x = rgb.r;
        vector3.y = rgb.g;
        vector3.z = rgb.b;
        const distanceToBlack = getVector3Length(vector3);
        if (distanceToBlack < closestColorDistanceToBlack) {
            closestColorDistanceToBlack = distanceToBlack;
            closestColorIndexToBlack = colorIndex;
        }
    }
    if (closestColorIndexToBlack != 0) {
        const [currentBlack, newBlack] = [
            quantizedPaletteColors[0],
            quantizedPaletteColors[closestColorIndexToBlack],
        ];
        quantizedPaletteColors[0] = newBlack;
        quantizedPaletteColors[closestColorIndexToBlack] = currentBlack;
    }
    const quantizedColors = quantizedPaletteColors.map((rgb, index) => {
        const hex = rgbToHex(rgb);
        return hex;
    });
    const quantizedColorIndices = [];
    for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        pixels[i + 3];
        const hex = rgbToHex({ r, g, b });
        quantizedColorIndices.push(quantizedColors.indexOf(hex));
    }
    const promise = new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            }
            else {
                reject();
            }
        }, "image/png");
    });
    const blob = await promise;
    return {
        blob,
        colors: quantizedColors,
        colorIndices: quantizedColorIndices,
    };
}
async function quantizeImage(image, width, height, numberOfColors, colors, canvas) {
    canvas = canvas || document.createElement("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    let { naturalWidth: imageWidth, naturalHeight: imageHeight } = image;
    _console$l.log({ imageWidth, imageHeight });
    canvas.width = width;
    canvas.height = height;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(image, 0, 0, width, height);
    return quantizeCanvas(canvas, numberOfColors, colors);
}
function resizeImage(image, width, height, canvas) {
    canvas = canvas || document.createElement("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    canvas.width = width;
    canvas.height = height;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(image, 0, 0, width, height);
    return canvas;
}
function cropCanvas(canvas, x, y, width, height, targetCanvas) {
    targetCanvas = targetCanvas || document.createElement("canvas");
    const ctx = targetCanvas.getContext("2d", { willReadFrequently: true });
    targetCanvas.width = width;
    targetCanvas.height = height;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
    return targetCanvas;
}
function removeAlphaFromCanvas(canvas) {
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
        const alpha = data[i + 3];
        if (alpha < 255) {
            data[i] = 0;
            data[i + 1] = 0;
            data[i + 2] = 0;
            data[i + 3] = 255;
        }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
}
async function resizeAndQuantizeImage(image, width, height, numberOfColors, colors, canvas) {
    canvas = canvas || document.createElement("canvas");
    resizeImage(image, width, height, canvas);
    removeAlphaFromCanvas(canvas);
    return quantizeCanvas(canvas, numberOfColors, colors);
}
async function imageToBitmap(image, width, height, colors, bitmapColorIndices, numberOfColors) {
    if (numberOfColors == undefined) {
        numberOfColors = colors.length;
    }
    const bitmapColors = bitmapColorIndices
        .map((bitmapColorIndex) => colors[bitmapColorIndex])
        .slice(0, numberOfColors);
    const { blob, colorIndices } = await resizeAndQuantizeImage(image, width, height, numberOfColors, bitmapColors);
    const bitmap = {
        numberOfColors,
        pixels: colorIndices,
        width,
        height,
    };
    return { blob, bitmap };
}
const drawSpriteBitmapCommandHeaderLength = 1 + 2 + 2 + 2 + 2 + 1 + 2;
async function canvasToBitmaps(canvas, numberOfColors, mtu) {
    const { blob, colors, colorIndices } = await quantizeCanvas(canvas, numberOfColors);
    const bitmapRows = [];
    const { width, height } = canvas;
    const numberOfPixels = width * height;
    const pixelDepth = DisplayPixelDepths.find((pixelDepth) => pixelDepthToNumberOfColors(pixelDepth) >= numberOfColors);
    _console$l.assertWithError(pixelDepth, `no pixelDepth found that covers ${numberOfColors} colors`);
    const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);
    const numberOfBytes = Math.ceil(numberOfPixels / pixelsPerByte);
    _console$l.log({
        width,
        height,
        numberOfPixels,
        pixelDepth,
        pixelsPerByte,
        numberOfBytes,
        mtu,
    });
    const maxPixelDataLength = mtu - (drawSpriteBitmapCommandHeaderLength + 5);
    const maxPixels = Math.floor(maxPixelDataLength / pixelsPerByte);
    const maxBitmapWidth = Math.min(maxPixels, width);
    let maxBitmapHeight = 1;
    if (maxBitmapWidth == width) {
        const bitmapRowPixelDataLength = Math.ceil(width / pixelsPerByte);
        maxBitmapHeight = Math.floor(maxPixelDataLength / bitmapRowPixelDataLength);
    }
    _console$l.log({
        maxPixelDataLength,
        maxPixels,
        maxBitmapHeight,
        maxBitmapWidth,
    });
    if (maxBitmapHeight >= height) {
        _console$l.log("image is small enough for a single bitmap");
        const bitmap = {
            numberOfColors,
            pixels: colorIndices,
            width,
            height,
        };
        bitmapRows.push([bitmap]);
    }
    else {
        let offsetX = 0;
        let offsetY = 0;
        const bitmapCanvas = document.createElement("canvas");
        const bitmapColorIndices = new Array(numberOfColors)
            .fill(0)
            .map((_, i) => i);
        while (offsetY < height) {
            const bitmapHeight = Math.min(maxBitmapHeight, height - offsetY);
            offsetX = 0;
            const bitmapRow = [];
            bitmapRows.push(bitmapRow);
            while (offsetX < width) {
                const bitmapWidth = Math.min(maxBitmapWidth, width - offsetX);
                cropCanvas(canvas, offsetX, offsetY, bitmapWidth, bitmapHeight, bitmapCanvas);
                const { bitmap } = await imageToBitmap(bitmapCanvas, bitmapWidth, bitmapHeight, colors, bitmapColorIndices, numberOfColors);
                bitmapRow.push(bitmap);
                offsetX += bitmapWidth;
            }
            offsetY += bitmapHeight;
        }
    }
    return { bitmapRows, colors };
}
async function imageToBitmaps(image, width, height, numberOfColors, mtu) {
    const canvas = resizeImage(image, width, height);
    return canvasToBitmaps(canvas, numberOfColors, mtu);
}
function getBitmapNumberOfBytes(bitmap) {
    const pixelDepth = numberOfColorsToPixelDepth(bitmap.numberOfColors);
    const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);
    const numberOfPixels = bitmap.pixels.length;
    const pixelDataLength = Math.ceil(numberOfPixels / pixelsPerByte);
    _console$l.log({
        pixelDepth,
        pixelsPerByte,
        numberOfPixels,
        pixelDataLength,
    });
    return pixelDataLength;
}
function assertValidBitmapPixels(bitmap) {
    _console$l.assertRangeWithError("bitmap.pixels.length", bitmap.pixels.length, bitmap.width * (bitmap.height - 1) + 1, bitmap.width * bitmap.height);
    bitmap.pixels.forEach((pixel, index) => {
        _console$l.assertRangeWithError(`bitmap.pixels[${index}]`, pixel, 0, bitmap.numberOfColors - 1);
    });
}
async function canvasToSprite(canvas, spriteName, numberOfColors, paletteName, overridePalette, spriteSheet, paletteOffset = 0) {
    const { width, height } = canvas;
    let palette = spriteSheet.palettes?.find((palette) => palette.name == paletteName);
    if (!palette) {
        palette = {
            name: paletteName,
            numberOfColors,
            colors: new Array(numberOfColors).fill("#000000"),
        };
        spriteSheet.palettes = spriteSheet.palettes || [];
        spriteSheet.palettes?.push(palette);
    }
    _console$l.log("pallete", palette);
    const sprite = {
        name: spriteName,
        width,
        height,
        paletteSwaps: [],
        commands: [],
    };
    const results = await quantizeCanvas(canvas, numberOfColors, !overridePalette ? palette.colors : undefined);
    const blob = results.blob;
    const colorIndices = results.colorIndices;
    if (overridePalette) {
        results.colors.forEach((color, index) => {
            palette.colors[index + paletteOffset] = color;
        });
    }
    sprite.commands.push({
        type: "selectBitmapColors",
        bitmapColorPairs: new Array(numberOfColors).fill(0).map((_, index) => ({
            bitmapColorIndex: index,
            colorIndex: index + paletteOffset,
        })),
    });
    const bitmap = {
        numberOfColors,
        pixels: colorIndices,
        width,
        height,
    };
    sprite.commands.push({ type: "drawBitmap", offsetX: 0, offsetY: 0, bitmap });
    const spriteIndex = spriteSheet.sprites.findIndex((sprite) => sprite.name == spriteName);
    if (spriteIndex == -1) {
        spriteSheet.sprites.push(sprite);
    }
    else {
        _console$l.log(`overwriting spriteIndex ${spriteIndex}`);
        spriteSheet.sprites[spriteIndex] = sprite;
    }
    return { sprite, blob };
}
async function imageToSprite(image, spriteName, width, height, numberOfColors, paletteName, overridePalette, spriteSheet, paletteOffset = 0) {
    const canvas = resizeImage(image, width, height);
    return canvasToSprite(canvas, spriteName, numberOfColors, paletteName, overridePalette, spriteSheet, paletteOffset);
}
const spriteSheetWithSingleBitmapCommandLength = calculateSpriteSheetHeaderLength(1) + drawSpriteBitmapCommandHeaderLength;
function spriteSheetWithBitmapCommandAndSelectBitmapColorsLength(numberOfColors) {
    return (spriteSheetWithSingleBitmapCommandLength + (1 + 1 + numberOfColors * 2));
}
async function canvasToSpriteSheet(canvas, spriteSheetName, spriteName, numberOfColors, paletteName, maxFileLength) {
    const spriteSheet = {
        name: spriteSheetName,
        palettes: [],
        paletteSwaps: [],
        sprites: [],
    };
    if (maxFileLength == undefined) {
        await canvasToSprite(canvas, spriteName, numberOfColors, paletteName, true, spriteSheet);
    }
    else {
        const { width, height } = canvas;
        const numberOfPixels = width * height;
        const pixelDepth = DisplayPixelDepths.find((pixelDepth) => pixelDepthToNumberOfColors(pixelDepth) >= numberOfColors);
        _console$l.assertWithError(pixelDepth, `no pixelDepth found that covers ${numberOfColors} colors`);
        const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);
        const numberOfBytes = Math.ceil(numberOfPixels / pixelsPerByte);
        _console$l.log({
            width,
            height,
            numberOfPixels,
            pixelDepth,
            pixelsPerByte,
            numberOfBytes,
            maxFileLength,
        });
        const maxPixelDataLength = maxFileLength -
            (spriteSheetWithBitmapCommandAndSelectBitmapColorsLength(numberOfColors) +
                5);
        const imageRowPixelDataLength = Math.ceil(width / pixelsPerByte);
        const maxSpriteHeight = Math.floor(maxPixelDataLength / imageRowPixelDataLength);
        if (maxSpriteHeight >= height) {
            _console$l.log("image is small enough for a single sprite");
            await canvasToSprite(canvas, spriteName, numberOfColors, paletteName, true, spriteSheet);
        }
        else {
            const { colors } = await quantizeCanvas(canvas, numberOfColors);
            spriteSheet.palettes?.push({ name: paletteName, numberOfColors, colors });
            let offsetY = 0;
            let imageIndex = 0;
            const spriteCanvas = document.createElement("canvas");
            while (offsetY < height) {
                const spriteHeight = Math.min(maxSpriteHeight, height - offsetY);
                cropCanvas(canvas, 0, offsetY, width, spriteHeight, spriteCanvas);
                offsetY += spriteHeight;
                _console$l.log(`cropping sprite ${imageIndex}`, {
                    offsetY,
                    width,
                    spriteHeight,
                });
                await canvasToSprite(spriteCanvas, `image${imageIndex}`, numberOfColors, paletteName, false, spriteSheet);
                imageIndex++;
            }
        }
    }
    return spriteSheet;
}
async function imageToSpriteSheet(image, spriteSheetName, spriteName, width, height, numberOfColors, paletteName, maxFileLength) {
    const canvas = resizeImage(image, width, height);
    return canvasToSpriteSheet(canvas, spriteSheetName, spriteName, numberOfColors, paletteName, maxFileLength);
}

const _console$k = createConsole("DisplayManagerInterface", { log: false });
async function runDisplayContextCommand(displayManager, command, sendImmediately) {
    if (command.hide) {
        return;
    }
    switch (command.type) {
        case "show":
            await displayManager.show(sendImmediately);
            break;
        case "clear":
            await displayManager.clear(sendImmediately);
            break;
        case "saveContext":
            break;
        case "restoreContext":
            break;
        case "clearRotation":
            await displayManager.clearRotation(sendImmediately);
            break;
        case "clearCrop":
            await displayManager.clearCrop(sendImmediately);
            break;
        case "clearRotationCrop":
            await displayManager.clearRotationCrop(sendImmediately);
            break;
        case "resetBitmapScale":
            await displayManager.resetBitmapScale(sendImmediately);
            break;
        case "resetSpriteScale":
            await displayManager.resetSpriteScale(sendImmediately);
            break;
        case "setColor":
            {
                const { colorIndex, color } = command;
                await displayManager.setColor(colorIndex, color, sendImmediately);
            }
            break;
        case "setColorOpacity":
            {
                const { colorIndex, opacity } = command;
                await displayManager.setColorOpacity(colorIndex, opacity, sendImmediately);
            }
            break;
        case "setOpacity":
            {
                const { opacity } = command;
                await displayManager.setOpacity(opacity, sendImmediately);
            }
            break;
        case "selectBackgroundColor":
            {
                const { backgroundColorIndex } = command;
                await displayManager.selectBackgroundColor(backgroundColorIndex, sendImmediately);
            }
            break;
        case "selectFillColor":
            {
                const { fillColorIndex } = command;
                await displayManager.selectFillColor(fillColorIndex, sendImmediately);
            }
            break;
        case "selectLineColor":
            {
                const { lineColorIndex } = command;
                await displayManager.selectLineColor(lineColorIndex, sendImmediately);
            }
            break;
        case "setIgnoreFill":
            {
                const { ignoreFill } = command;
                await displayManager.setIgnoreFill(ignoreFill, sendImmediately);
            }
            break;
        case "setIgnoreLine":
            {
                const { ignoreLine } = command;
                await displayManager.setIgnoreLine(ignoreLine, sendImmediately);
            }
            break;
        case "setFillBackground":
            {
                const { fillBackground } = command;
                await displayManager.setFillBackground(fillBackground, sendImmediately);
            }
            break;
        case "setLineWidth":
            {
                const { lineWidth } = command;
                await displayManager.setLineWidth(lineWidth, sendImmediately);
            }
            break;
        case "setRotation":
            {
                let { rotation, isRadians } = command;
                rotation = isRadians ? rotation : degToRad(rotation);
                await displayManager.setRotation(rotation, true, sendImmediately);
            }
            break;
        case "setSegmentStartCap":
            {
                const { segmentStartCap } = command;
                await displayManager.setSegmentStartCap(segmentStartCap, sendImmediately);
            }
            break;
        case "setSegmentEndCap":
            {
                const { segmentEndCap } = command;
                await displayManager.setSegmentEndCap(segmentEndCap, sendImmediately);
            }
            break;
        case "setSegmentCap":
            {
                const { segmentCap } = command;
                await displayManager.setSegmentCap(segmentCap, sendImmediately);
            }
            break;
        case "setSegmentStartRadius":
            {
                const { segmentStartRadius } = command;
                await displayManager.setSegmentStartRadius(segmentStartRadius, sendImmediately);
            }
            break;
        case "setSegmentEndRadius":
            {
                const { segmentEndRadius } = command;
                await displayManager.setSegmentEndRadius(segmentEndRadius, sendImmediately);
            }
            break;
        case "setSegmentRadius":
            {
                const { segmentRadius } = command;
                await displayManager.setSegmentRadius(segmentRadius, sendImmediately);
            }
            break;
        case "setHorizontalAlignment":
            {
                const { horizontalAlignment } = command;
                await displayManager.setHorizontalAlignment(horizontalAlignment, sendImmediately);
            }
            break;
        case "setVerticalAlignment":
            {
                const { verticalAlignment } = command;
                await displayManager.setVerticalAlignment(verticalAlignment, sendImmediately);
            }
            break;
        case "resetAlignment":
            {
                await displayManager.resetAlignment(sendImmediately);
            }
            break;
        case "setCropTop":
            {
                const { cropTop } = command;
                await displayManager.setCropTop(cropTop, sendImmediately);
            }
            break;
        case "setCropRight":
            {
                const { cropRight } = command;
                await displayManager.setCropRight(cropRight, sendImmediately);
            }
            break;
        case "setCropBottom":
            {
                const { cropBottom } = command;
                await displayManager.setCropBottom(cropBottom, sendImmediately);
            }
            break;
        case "setCropLeft":
            {
                const { cropLeft } = command;
                await displayManager.setCropLeft(cropLeft, sendImmediately);
            }
            break;
        case "setRotationCropTop":
            {
                const { rotationCropTop } = command;
                await displayManager.setRotationCropTop(rotationCropTop, sendImmediately);
            }
            break;
        case "setRotationCropRight":
            {
                const { rotationCropRight } = command;
                await displayManager.setRotationCropRight(rotationCropRight, sendImmediately);
            }
            break;
        case "setRotationCropBottom":
            {
                const { rotationCropBottom } = command;
                await displayManager.setRotationCropBottom(rotationCropBottom, sendImmediately);
            }
            break;
        case "setRotationCropLeft":
            {
                const { rotationCropLeft } = command;
                await displayManager.setRotationCropLeft(rotationCropLeft, sendImmediately);
            }
            break;
        case "selectBitmapColor":
            {
                const { bitmapColorIndex, colorIndex } = command;
                await displayManager.selectBitmapColor(bitmapColorIndex, colorIndex, sendImmediately);
            }
            break;
        case "selectBitmapColors":
            {
                const { bitmapColorPairs } = command;
                await displayManager.selectBitmapColors(bitmapColorPairs, sendImmediately);
            }
            break;
        case "setBitmapScaleX":
            {
                const { bitmapScaleX } = command;
                await displayManager.setBitmapScaleX(bitmapScaleX, sendImmediately);
            }
            break;
        case "setBitmapScaleY":
            {
                const { bitmapScaleY } = command;
                await displayManager.setBitmapScaleY(bitmapScaleY, sendImmediately);
            }
            break;
        case "setBitmapScale":
            {
                const { bitmapScale } = command;
                await displayManager.setBitmapScale(bitmapScale, sendImmediately);
            }
            break;
        case "selectSpriteColor":
            {
                const { spriteColorIndex, colorIndex } = command;
                await displayManager.selectSpriteColor(spriteColorIndex, colorIndex, sendImmediately);
            }
            break;
        case "selectSpriteColors":
            {
                const { spriteColorPairs } = command;
                await displayManager.selectSpriteColors(spriteColorPairs, sendImmediately);
            }
            break;
        case "setSpriteScaleX":
            {
                const { spriteScaleX } = command;
                await displayManager.setSpriteScaleX(spriteScaleX, sendImmediately);
            }
            break;
        case "setSpriteScaleY":
            {
                const { spriteScaleY } = command;
                await displayManager.setSpriteScaleY(spriteScaleY, sendImmediately);
            }
            break;
        case "setSpriteScale":
            {
                const { spriteScale } = command;
                await displayManager.setSpriteScale(spriteScale, sendImmediately);
            }
            break;
        case "clearRect":
            {
                const { x, y, width, height } = command;
                await displayManager.clearRect(x, y, width, height, sendImmediately);
            }
            break;
        case "drawRect":
            {
                const { offsetX, offsetY, width, height } = command;
                await displayManager.drawRect(offsetX, offsetY, width, height, sendImmediately);
            }
            break;
        case "drawRoundRect":
            {
                const { offsetX, offsetY, width, height, borderRadius } = command;
                await displayManager.drawRoundRect(offsetX, offsetY, width, height, borderRadius, sendImmediately);
            }
            break;
        case "drawCircle":
            {
                const { offsetX, offsetY, radius } = command;
                await displayManager.drawCircle(offsetX, offsetY, radius, sendImmediately);
            }
            break;
        case "drawEllipse":
            {
                const { offsetX, offsetY, radiusX, radiusY } = command;
                await displayManager.drawEllipse(offsetX, offsetY, radiusX, radiusY, sendImmediately);
            }
            break;
        case "drawPolygon":
            {
                const { points } = command;
                await displayManager.drawPolygon(points, sendImmediately);
            }
            break;
        case "drawRegularPolygon":
            {
                const { offsetX, offsetY, radius, numberOfSides } = command;
                await displayManager.drawRegularPolygon(offsetX, offsetY, radius, numberOfSides, sendImmediately);
            }
            break;
        case "drawWireframe":
            {
                const { wireframe } = command;
                await displayManager.drawWireframe(wireframe, sendImmediately);
            }
            break;
        case "drawSegment":
            {
                const { startX, startY, endX, endY } = command;
                await displayManager.drawSegment(startX, startY, endX, endY, sendImmediately);
            }
            break;
        case "drawSegments":
            {
                const { points } = command;
                await displayManager.drawSegments(points.map(({ x, y }) => ({ x: x, y: y })), sendImmediately);
            }
            break;
        case "drawArc":
            {
                let { offsetX, offsetY, radius, startAngle, angleOffset, isRadians } = command;
                startAngle = isRadians ? startAngle : degToRad(startAngle);
                angleOffset = isRadians ? angleOffset : degToRad(angleOffset);
                await displayManager.drawArc(offsetX, offsetY, radius, startAngle, angleOffset, true, sendImmediately);
            }
            break;
        case "drawArcEllipse":
            {
                let { offsetX, offsetY, radiusX, radiusY, startAngle, angleOffset, isRadians, } = command;
                startAngle = isRadians ? startAngle : degToRad(startAngle);
                angleOffset = isRadians ? angleOffset : degToRad(angleOffset);
                await displayManager.drawArcEllipse(offsetX, offsetY, radiusX, radiusY, startAngle, angleOffset, true, sendImmediately);
            }
            break;
        case "drawBitmap":
            {
                const { offsetX, offsetY, bitmap } = command;
                await displayManager.drawBitmap(offsetX, offsetY, bitmap, sendImmediately);
            }
            break;
        case "drawSprite":
            {
                const { offsetX, offsetY, spriteIndex } = command;
                const spriteName = displayManager.selectedSpriteSheet?.sprites[spriteIndex].name;
                await displayManager.drawSprite(offsetX, offsetY, spriteName, sendImmediately);
            }
            break;
        case "selectSpriteSheet":
            {
                const { spriteSheetIndex } = command;
                const spriteSheetName = Object.entries(displayManager.spriteSheetIndices).find((entry) => entry[1] == spriteSheetIndex)?.[0];
                await displayManager.selectSpriteSheet(spriteSheetName, sendImmediately);
            }
            break;
        case "resetSpriteColors":
            await displayManager.resetSpriteColors(sendImmediately);
            break;
        case "drawQuadraticBezierCurve":
            {
                const { controlPoints } = command;
                await displayManager.drawQuadraticBezierCurve(controlPoints, sendImmediately);
            }
            break;
        case "drawQuadraticBezierCurves":
            {
                const { controlPoints } = command;
                await displayManager.drawQuadraticBezierCurves(controlPoints, sendImmediately);
            }
            break;
        case "drawCubicBezierCurve":
            {
                const { controlPoints } = command;
                await displayManager.drawCubicBezierCurve(controlPoints, sendImmediately);
            }
            break;
        case "drawCubicBezierCurves":
            {
                const { controlPoints } = command;
                await displayManager.drawCubicBezierCurves(controlPoints, sendImmediately);
            }
            break;
        case "drawClosedPath":
            {
                const { curves } = command;
                await displayManager.drawClosedPath(curves, sendImmediately);
            }
            break;
        case "drawPath":
            {
                const { curves } = command;
                await displayManager.drawPath(curves, sendImmediately);
            }
            break;
        case "startSprite":
            {
                const { offsetX, offsetY, width, height } = command;
                await displayManager.startSprite(offsetX, offsetY, width, height, sendImmediately);
            }
            break;
        case "endSprite":
            await displayManager.endSprite(sendImmediately);
            break;
    }
}
async function runDisplayContextCommands(displayManager, commands, sendImmediately) {
    _console$k.log("runDisplayContextCommands", commands);
    commands
        .filter((command) => !command.hide)
        .forEach((command) => {
        runDisplayContextCommand(displayManager, command, false);
    });
    if (sendImmediately) {
        displayManager.flushContextCommands();
    }
}
function assertLoadedSpriteSheet(displayManager, spriteSheetName) {
    _console$k.assertWithError(displayManager.spriteSheets[spriteSheetName], `spriteSheet "${spriteSheetName}" not loaded`);
}
function assertSelectedSpriteSheet(displayManager, spriteSheetName) {
    displayManager.assertLoadedSpriteSheet(spriteSheetName);
    _console$k.assertWithError(displayManager.selectedSpriteSheetName == spriteSheetName, `spriteSheet "${spriteSheetName}" not selected`);
}
function assertAnySelectedSpriteSheet(displayManager) {
    _console$k.assertWithError(displayManager.selectedSpriteSheet, "no spriteSheet selected");
}
function getSprite(displayManager, spriteName) {
    displayManager.assertAnySelectedSpriteSheet();
    return displayManager.selectedSpriteSheet.sprites.find((sprite) => sprite.name == spriteName);
}
function assertSprite(displayManager, spriteName) {
    displayManager.assertAnySelectedSpriteSheet();
    const sprite = displayManager.getSprite(spriteName);
    _console$k.assertWithError(sprite, `no sprite found with name "${spriteName}"`);
}
function getSpriteSheetPalette(displayManager, paletteName) {
    return displayManager.selectedSpriteSheet?.palettes?.find((palette) => palette.name == paletteName);
}
function getSpriteSheetPaletteSwap(displayManager, paletteSwapName) {
    return displayManager.selectedSpriteSheet?.paletteSwaps?.find((paletteSwap) => paletteSwap.name == paletteSwapName);
}
function getSpritePaletteSwap(displayManager, spriteName, paletteSwapName) {
    return displayManager
        .getSprite(spriteName)
        ?.paletteSwaps?.find((paletteSwap) => paletteSwap.name == paletteSwapName);
}
function assertSpriteSheetPalette(displayManagerInterface, paletteName) {
    const spriteSheetPalette = displayManagerInterface.getSpriteSheetPalette(paletteName);
    _console$k.assertWithError(spriteSheetPalette, `no spriteSheetPalette found with name "${paletteName}"`);
}
function assertSpriteSheetPaletteSwap(displayManagerInterface, paletteSwapName) {
    const spriteSheetPaletteSwap = displayManagerInterface.getSpriteSheetPaletteSwap(paletteSwapName);
    _console$k.assertWithError(spriteSheetPaletteSwap, `no paletteSwapName found with name "${paletteSwapName}"`);
}
function assertSpritePaletteSwap(displayManagerInterface, spriteName, paletteSwapName) {
    const spritePaletteSwap = displayManagerInterface.getSpritePaletteSwap(spriteName, paletteSwapName);
    _console$k.assertWithError(spritePaletteSwap, `no spritePaletteSwap found for sprite "${spriteName}" name "${paletteSwapName}"`);
}
async function selectSpriteSheetPalette(displayManagerInterface, paletteName, offset, indicesOnly, sendImmediately) {
    offset = offset || 0;
    displayManagerInterface.assertAnySelectedSpriteSheet();
    displayManagerInterface.assertSpriteSheetPalette(paletteName);
    const palette = displayManagerInterface.getSpriteSheetPalette(paletteName);
    _console$k.assertWithError(palette.numberOfColors + offset <= displayManagerInterface.numberOfColors, `invalid offset ${offset} and palette.numberOfColors ${palette.numberOfColors} (max ${displayManagerInterface.numberOfColors})`);
    for (let index = 0; index < palette.numberOfColors; index++) {
        if (!indicesOnly) {
            const color = palette.colors[index];
            let opacity = palette.opacities?.[index];
            if (opacity == undefined) {
                opacity = 1;
            }
            displayManagerInterface.setColor(index + offset, color, false);
            displayManagerInterface.setColorOpacity(index + offset, opacity, false);
        }
        displayManagerInterface.selectSpriteColor(index, index + offset);
    }
    if (sendImmediately) {
        displayManagerInterface.flushContextCommands();
    }
}
async function selectSpriteSheetPaletteSwap(displayManagerInterface, paletteSwapName, offset, sendImmediately) {
    offset = offset || 0;
    displayManagerInterface.assertAnySelectedSpriteSheet();
    displayManagerInterface.assertSpriteSheetPaletteSwap(paletteSwapName);
    const paletteSwap = displayManagerInterface.getSpriteSheetPaletteSwap(paletteSwapName);
    const spriteColorPairs = [];
    for (let spriteColorIndex = 0; spriteColorIndex < paletteSwap.numberOfColors; spriteColorIndex++) {
        const colorIndex = paletteSwap.spriteColorIndices[spriteColorIndex];
        spriteColorPairs.push({
            spriteColorIndex: spriteColorIndex + offset,
            colorIndex,
        });
    }
    displayManagerInterface.selectSpriteColors(spriteColorPairs, false);
    if (sendImmediately) {
        displayManagerInterface.flushContextCommands();
    }
}
async function selectSpritePaletteSwap(displayManagerInterface, spriteName, paletteSwapName, offset, sendImmediately) {
    offset = offset || 0;
    displayManagerInterface.assertAnySelectedSpriteSheet();
    const paletteSwap = displayManagerInterface.getSpritePaletteSwap(spriteName, paletteSwapName);
    const spriteColorPairs = [];
    for (let spriteColorIndex = 0; spriteColorIndex < paletteSwap.numberOfColors; spriteColorIndex++) {
        const colorIndex = paletteSwap.spriteColorIndices[spriteColorIndex];
        spriteColorPairs.push({
            spriteColorIndex: spriteColorIndex + offset,
            colorIndex,
        });
    }
    displayManagerInterface.selectSpriteColors(spriteColorPairs, false);
    if (sendImmediately) {
        displayManagerInterface.flushContextCommands();
    }
}
async function drawSpriteFromSpriteSheet(displayManagerInterface, offsetX, offsetY, spriteName, spriteSheet, paletteName, sendImmediately) {
    const reducedSpriteSheet = reduceSpriteSheet(spriteSheet, [spriteName]);
    await displayManagerInterface.uploadSpriteSheet(reducedSpriteSheet);
    await displayManagerInterface.selectSpriteSheet(spriteSheet.name);
    await displayManagerInterface.drawSprite(offsetX, offsetY, spriteName, sendImmediately);
    if (paletteName != undefined) {
        await displayManagerInterface.selectSpriteSheetPalette(paletteName);
    }
}

const _console$j = createConsole("DisplayManager", { log: true });
const DefaultNumberOfDisplayColors = 16;
const DisplayCommands = ["sleep", "wake"];
const DisplayStatuses = ["awake", "asleep"];
const DisplayInformationTypes = [
    "type",
    "width",
    "height",
    "pixelDepth",
];
const DisplayTypes = [
    "none",
    "generic",
    "monocularLeft",
    "monocularRight",
    "binocular",
];
const DisplayPixelDepths = ["1", "2", "4"];
const DisplayBrightnesses = [
    "veryLow",
    "low",
    "medium",
    "high",
    "veryHigh",
];
const DisplayMessageTypes = [
    "isDisplayAvailable",
    "displayStatus",
    "displayInformation",
    "displayCommand",
    "getDisplayBrightness",
    "setDisplayBrightness",
    "displayContextCommands",
    "displayReady",
    "getSpriteSheetName",
    "setSpriteSheetName",
    "spriteSheetIndex",
];
const DisplayBezierCurveTypes = [
    "segment",
    "quadratic",
    "cubic",
];
const displayCurveTypeBitWidth = 2;
const displayCurveTypesPerByte = 8 / displayCurveTypeBitWidth;
const DisplayPointDataTypes = ["int8", "int16", "float"];
const displayPointDataTypeToSize = {
    int8: 1 * 2,
    int16: 2 * 2,
    float: 4 * 2,
};
const displayPointDataTypeToRange = {
    int8: { min: -128, max: 2 ** 7 - 1 },
    int16: { min: -32768, max: 2 ** 15 - 1 },
    float: { min: -Infinity, max: Infinity },
};
const DisplayInformationValues = {
    type: DisplayTypes,
    pixelDepth: DisplayPixelDepths,
};
const RequiredDisplayMessageTypes = [
    "isDisplayAvailable",
    "displayInformation",
    "displayStatus",
    "getDisplayBrightness",
];
const DisplayEventTypes = [
    ...DisplayMessageTypes,
    "displayContextState",
    "displayColor",
    "displayColorOpacity",
    "displayOpacity",
    "displaySpriteSheetUploadStart",
    "displaySpriteSheetUploadProgress",
    "displaySpriteSheetUploadComplete",
];
const MinSpriteSheetNameLength = 1;
const MaxSpriteSheetNameLength = 30;
class DisplayManager {
    constructor() {
        autoBind(this);
    }
    sendMessage;
    eventDispatcher;
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    requestRequiredInformation() {
        _console$j.log("requesting required display information");
        const messages = RequiredDisplayMessageTypes.map((messageType) => ({
            type: messageType,
        }));
        this.sendMessage(messages, false);
    }
    #isAvailable = false;
    get isAvailable() {
        return this.#isAvailable;
    }
    #assertDisplayIsAvailable() {
        _console$j.assertWithError(this.#isAvailable, "display is not available");
    }
    #parseIsDisplayAvailable(dataView) {
        const newIsDisplayAvailable = dataView.getUint8(0) == 1;
        this.#isAvailable = newIsDisplayAvailable;
        _console$j.log({ isDisplayAvailable: this.#isAvailable });
        this.#dispatchEvent("isDisplayAvailable", {
            isDisplayAvailable: this.#isAvailable,
        });
    }
    #contextStateHelper = new DisplayContextStateHelper();
    get contextState() {
        return this.#contextStateHelper.state;
    }
    #onContextStateUpdate(differences) {
        this.#dispatchEvent("displayContextState", {
            displayContextState: structuredClone(this.contextState),
            differences,
        });
    }
    async setContextState(newState, sendImmediately) {
        const differences = this.#contextStateHelper.diff(newState);
        if (differences.length == 0) {
            return;
        }
        differences.forEach((difference) => {
            switch (difference) {
                case "backgroundColorIndex":
                    this.selectBackgroundColor(newState.backgroundColorIndex);
                    break;
                case "fillBackground":
                    this.setFillBackground(newState.fillBackground);
                    break;
                case "ignoreFill":
                    this.setIgnoreFill(newState.ignoreFill);
                    break;
                case "ignoreLine":
                    this.setIgnoreLine(newState.ignoreLine);
                    break;
                case "fillColorIndex":
                    this.selectFillColor(newState.fillColorIndex);
                    break;
                case "lineColorIndex":
                    this.selectLineColor(newState.lineColorIndex);
                    break;
                case "lineWidth":
                    this.setLineWidth(newState.lineWidth);
                    break;
                case "horizontalAlignment":
                    this.setHorizontalAlignment(newState.horizontalAlignment);
                    break;
                case "verticalAlignment":
                    this.setVerticalAlignment(newState.verticalAlignment);
                    break;
                case "rotation":
                    this.setRotation(newState.rotation, true);
                    break;
                case "segmentStartCap":
                    this.setSegmentStartCap(newState.segmentStartCap);
                    break;
                case "segmentEndCap":
                    this.setSegmentEndCap(newState.segmentEndCap);
                    break;
                case "segmentStartRadius":
                    this.setSegmentStartRadius(newState.segmentStartRadius);
                    break;
                case "segmentEndRadius":
                    this.setSegmentEndRadius(newState.segmentEndRadius);
                    break;
                case "cropTop":
                    this.setCropTop(newState.cropTop);
                    break;
                case "cropRight":
                    this.setCropRight(newState.cropRight);
                    break;
                case "cropBottom":
                    this.setCropBottom(newState.cropBottom);
                    break;
                case "cropLeft":
                    this.setCropLeft(newState.cropLeft);
                    break;
                case "rotationCropTop":
                    this.setRotationCropTop(newState.rotationCropTop);
                    break;
                case "rotationCropRight":
                    this.setRotationCropRight(newState.rotationCropRight);
                    break;
                case "rotationCropBottom":
                    this.setRotationCropBottom(newState.rotationCropBottom);
                    break;
                case "rotationCropLeft":
                    this.setRotationCropLeft(newState.rotationCropLeft);
                    break;
                case "bitmapColorIndices":
                    const bitmapColors = [];
                    newState.bitmapColorIndices.forEach((colorIndex, bitmapColorIndex) => {
                        bitmapColors.push({ bitmapColorIndex, colorIndex });
                    });
                    this.selectBitmapColors(bitmapColors);
                    break;
                case "bitmapScaleX":
                    this.setBitmapScaleX(newState.bitmapScaleX);
                    break;
                case "bitmapScaleY":
                    this.setBitmapScaleY(newState.bitmapScaleY);
                    break;
                case "spriteColorIndices":
                    const spriteColors = [];
                    newState.spriteColorIndices.forEach((colorIndex, spriteColorIndex) => {
                        spriteColors.push({ spriteColorIndex, colorIndex });
                    });
                    this.selectSpriteColors(spriteColors);
                    break;
                case "spriteScaleX":
                    this.setSpriteScaleX(newState.spriteScaleX);
                    break;
                case "spriteScaleY":
                    this.setSpriteScaleY(newState.spriteScaleY);
                    break;
                case "spritesLineHeight":
                    this.setSpritesLineHeight(newState.spritesLineHeight);
                    break;
                case "spritesDirection":
                    this.setSpritesDirection(newState.spritesDirection);
                    break;
                case "spritesLineDirection":
                    this.setSpritesLineDirection(newState.spritesLineDirection);
                    break;
                case "spritesSpacing":
                    this.setSpritesSpacing(newState.spritesSpacing);
                    break;
                case "spritesLineSpacing":
                    this.setSpritesLineSpacing(newState.spritesLineSpacing);
                    break;
                case "spritesAlignment":
                    this.setSpritesAlignment(newState.spritesAlignment);
                    break;
                case "spritesLineAlignment":
                    this.setSpritesLineAlignment(newState.spritesLineAlignment);
                    break;
            }
        });
        if (sendImmediately) {
            await this.#sendContextCommands();
        }
    }
    #displayStatus;
    get displayStatus() {
        return this.#displayStatus;
    }
    get isDisplayAwake() {
        return this.#displayStatus == "awake";
    }
    #parseDisplayStatus(dataView) {
        const displayStatusIndex = dataView.getUint8(0);
        const newDisplayStatus = DisplayStatuses[displayStatusIndex];
        this.#updateDisplayStatus(newDisplayStatus);
    }
    #updateDisplayStatus(newDisplayStatus) {
        _console$j.assertEnumWithError(newDisplayStatus, DisplayStatuses);
        if (newDisplayStatus == this.#displayStatus) {
            _console$j.log(`redundant displayStatus ${newDisplayStatus}`);
            return;
        }
        const previousDisplayStatus = this.#displayStatus;
        this.#displayStatus = newDisplayStatus;
        _console$j.log(`updated displayStatus to "${this.displayStatus}"`);
        this.#dispatchEvent("displayStatus", {
            displayStatus: this.displayStatus,
            previousDisplayStatus,
        });
    }
    async #sendDisplayCommand(command, sendImmediately) {
        _console$j.assertEnumWithError(command, DisplayCommands);
        _console$j.log(`sending display command "${command}"`);
        const promise = this.waitForEvent("displayStatus");
        _console$j.log(`setting command "${command}"`);
        const commandEnum = DisplayCommands.indexOf(command);
        this.sendMessage([
            {
                type: "displayCommand",
                data: UInt8ByteBuffer(commandEnum),
            },
        ], sendImmediately);
        await promise;
    }
    #assertIsAwake() {
        _console$j.assertWithError(this.#displayStatus == "awake", `display is not awake - currently ${this.#displayStatus}`);
    }
    #assertIsNotAwake() {
        _console$j.assertWithError(this.#displayStatus != "awake", `display is awake`);
    }
    async wake() {
        this.#assertIsNotAwake();
        await this.#sendDisplayCommand("wake");
    }
    async sleep() {
        this.#assertIsAwake();
        await this.#sendDisplayCommand("sleep");
    }
    async toggle() {
        switch (this.displayStatus) {
            case "asleep":
                this.wake();
                break;
            case "awake":
                this.sleep();
                break;
        }
    }
    get numberOfColors() {
        return 2 ** Number(this.pixelDepth);
    }
    #displayInformation;
    get displayInformation() {
        return this.#displayInformation;
    }
    get pixelDepth() {
        return this.#displayInformation?.pixelDepth;
    }
    get width() {
        return this.#displayInformation?.width;
    }
    get height() {
        return this.#displayInformation?.width;
    }
    get size() {
        return {
            width: this.width,
            height: this.height,
        };
    }
    get type() {
        return this.#displayInformation?.type;
    }
    #parseDisplayInformation(dataView) {
        const parsedDisplayInformation = {};
        let byteOffset = 0;
        while (byteOffset < dataView.byteLength) {
            const displayInformationTypeIndex = dataView.getUint8(byteOffset++);
            const displayInformationType = DisplayInformationTypes[displayInformationTypeIndex];
            _console$j.assertWithError(displayInformationType, `invalid displayInformationTypeIndex ${displayInformationType}`);
            _console$j.log({ displayInformationType });
            switch (displayInformationType) {
                case "width":
                case "height":
                    {
                        const value = dataView.getUint16(byteOffset, true);
                        parsedDisplayInformation[displayInformationType] = value;
                        byteOffset += 2;
                    }
                    break;
                case "pixelDepth":
                case "type":
                    {
                        const values = DisplayInformationValues[displayInformationType];
                        let rawValue = dataView.getUint8(byteOffset++);
                        const value = values[rawValue];
                        _console$j.assertEnumWithError(value, values);
                        parsedDisplayInformation[displayInformationType] = value;
                    }
                    break;
            }
        }
        _console$j.log({ parsedDisplayInformation });
        const missingDisplayInformationType = DisplayInformationTypes.find((type) => !(type in parsedDisplayInformation));
        _console$j.assertWithError(!missingDisplayInformationType, `missingDisplayInformationType ${missingDisplayInformationType}`);
        this.#displayInformation = parsedDisplayInformation;
        this.#colors = new Array(this.numberOfColors).fill("#000000");
        this.#opacities = new Array(this.numberOfColors).fill(1);
        this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(0);
        this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(0);
        this.#dispatchEvent("displayInformation", {
            displayInformation: this.#displayInformation,
        });
    }
    #brightness;
    get brightness() {
        return this.#brightness;
    }
    #parseDisplayBrightness(dataView) {
        const newDisplayBrightnessEnum = dataView.getUint8(0);
        const newDisplayBrightness = DisplayBrightnesses[newDisplayBrightnessEnum];
        assertValidDisplayBrightness(newDisplayBrightness);
        this.#brightness = newDisplayBrightness;
        _console$j.log({ displayBrightness: this.#brightness });
        this.#dispatchEvent("getDisplayBrightness", {
            displayBrightness: this.#brightness,
        });
    }
    async setBrightness(newDisplayBrightness, sendImmediately) {
        this.#assertDisplayIsAvailable();
        assertValidDisplayBrightness(newDisplayBrightness);
        if (this.brightness == newDisplayBrightness) {
            _console$j.log(`redundant displayBrightness ${newDisplayBrightness}`);
            return;
        }
        const newDisplayBrightnessEnum = DisplayBrightnesses.indexOf(newDisplayBrightness);
        const newDisplayBrightnessData = UInt8ByteBuffer(newDisplayBrightnessEnum);
        const promise = this.waitForEvent("getDisplayBrightness");
        this.sendMessage([{ type: "setDisplayBrightness", data: newDisplayBrightnessData }], sendImmediately);
        await promise;
    }
    #assertValidDisplayContextCommandType(displayContextCommand) {
        _console$j.assertEnumWithError(displayContextCommand, DisplayContextCommandTypes);
    }
    get #maxCommandDataLength() {
        return this.mtu - 7;
    }
    #contextCommandBuffers = [];
    async #sendContextCommand(contextCommandType, arrayBuffer, sendImmediately) {
        this.#assertValidDisplayContextCommandType(contextCommandType);
        _console$j.log("sendContextCommand", { displayContextCommand: contextCommandType, sendImmediately }, arrayBuffer);
        const displayContextCommandEnum = DisplayContextCommandTypes.indexOf(contextCommandType);
        const _arrayBuffer = concatenateArrayBuffers(UInt8ByteBuffer(displayContextCommandEnum), arrayBuffer);
        const newLength = this.#contextCommandBuffers.reduce((sum, buffer) => sum + buffer.byteLength, _arrayBuffer.byteLength);
        if (newLength > this.#maxCommandDataLength) {
            _console$j.log("displayContextCommandBuffers too full - sending now");
            await this.#sendContextCommands();
        }
        this.#contextCommandBuffers.push(_arrayBuffer);
        if (sendImmediately) {
            await this.#sendContextCommands();
        }
    }
    async #sendContextCommands() {
        if (this.#contextCommandBuffers.length == 0) {
            return;
        }
        const data = concatenateArrayBuffers(this.#contextCommandBuffers);
        _console$j.log(`sending displayContextCommands`, this.#contextCommandBuffers.slice(), data);
        this.#contextCommandBuffers.length = 0;
        await this.sendMessage([{ type: "displayContextCommands", data }], true);
        this.#dispatchEvent("displayContextCommands", {});
    }
    async flushContextCommands() {
        await this.#sendContextCommands();
    }
    async show(sendImmediately = true) {
        _console$j.log("showDisplay");
        this.#isReady = false;
        this.#lastShowRequestTime = Date.now();
        await this.#sendContextCommand("show", undefined, sendImmediately);
    }
    async clear(sendImmediately = true) {
        _console$j.log("clearDisplay");
        this.#isReady = false;
        this.#lastShowRequestTime = Date.now();
        await this.#sendContextCommand("clear", undefined, sendImmediately);
    }
    assertValidColorIndex(colorIndex) {
        _console$j.assertRangeWithError("colorIndex", colorIndex, 0, this.numberOfColors);
    }
    #colors = [];
    get colors() {
        return this.#colors;
    }
    async setColor(colorIndex, color, sendImmediately) {
        let colorRGB;
        if (typeof color == "string") {
            colorRGB = stringToRGB(color);
        }
        else {
            colorRGB = color;
        }
        const colorHex = rgbToHex(colorRGB);
        if (this.colors[colorIndex] == colorHex) {
            _console$j.log(`redundant color #${colorIndex} ${colorHex}`);
            return;
        }
        this.assertValidColorIndex(colorIndex);
        assertValidColor(colorRGB);
        const dataView = new DataView(new ArrayBuffer(4));
        dataView.setUint8(0, colorIndex);
        dataView.setUint8(1, colorRGB.r);
        dataView.setUint8(2, colorRGB.g);
        dataView.setUint8(3, colorRGB.b);
        await this.#sendContextCommand("setColor", dataView.buffer, sendImmediately);
        this.colors[colorIndex] = colorHex;
        this.#dispatchEvent("displayColor", {
            colorIndex,
            colorRGB,
            colorHex,
        });
    }
    #opacities = [];
    get opacities() {
        return this.#opacities;
    }
    async setColorOpacity(colorIndex, opacity, sendImmediately) {
        const commandType = "setColorOpacity";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            colorIndex,
            opacity,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#opacities[colorIndex] = opacity;
        this.#dispatchEvent("displayColorOpacity", { colorIndex, opacity });
    }
    async setOpacity(opacity, sendImmediately) {
        const commandType = "setOpacity";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            opacity,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#opacities.fill(opacity);
        this.#dispatchEvent("displayOpacity", { opacity });
    }
    #contextStack = [];
    #saveContext(sendImmediately) {
        this.#contextStack.push(structuredClone(this.contextState));
    }
    #restoreContext(sendImmediately) {
        const contextState = this.#contextStack.pop();
        if (!contextState) {
            _console$j.warn("#contextStack empty");
            return;
        }
        this.setContextState(contextState, sendImmediately);
    }
    async saveContext(sendImmediately) {
        {
            this.#saveContext(sendImmediately);
        }
    }
    async restoreContext(sendImmediately) {
        {
            this.#restoreContext(sendImmediately);
        }
    }
    async selectFillColor(fillColorIndex, sendImmediately) {
        this.assertValidColorIndex(fillColorIndex);
        const differences = this.#contextStateHelper.update({
            fillColorIndex,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "selectFillColor";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            fillColorIndex,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async selectBackgroundColor(backgroundColorIndex, sendImmediately) {
        this.assertValidColorIndex(backgroundColorIndex);
        const differences = this.#contextStateHelper.update({
            backgroundColorIndex,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "selectBackgroundColor";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            backgroundColorIndex,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async selectLineColor(lineColorIndex, sendImmediately) {
        this.assertValidColorIndex(lineColorIndex);
        const differences = this.#contextStateHelper.update({
            lineColorIndex,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "selectLineColor";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            lineColorIndex,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setIgnoreFill(ignoreFill, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            ignoreFill,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setIgnoreFill";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            ignoreFill,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setIgnoreLine(ignoreLine, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            ignoreLine,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setIgnoreLine";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            ignoreLine,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setFillBackground(fillBackground, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            fillBackground,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setFillBackground";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            fillBackground,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    assertValidLineWidth(lineWidth) {
        _console$j.assertRangeWithError("lineWidth", lineWidth, 0, Math.max(this.width, this.height));
    }
    async setLineWidth(lineWidth, sendImmediately) {
        this.assertValidLineWidth(lineWidth);
        const differences = this.#contextStateHelper.update({
            lineWidth,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setLineWidth";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            lineWidth,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setAlignment(alignmentDirection, alignment, sendImmediately) {
        assertValidAlignmentDirection(alignmentDirection);
        const alignmentCommand = DisplayAlignmentDirectionToCommandType[alignmentDirection];
        const alignmentKey = DisplayAlignmentDirectionToStateKey[alignmentDirection];
        const differences = this.#contextStateHelper.update({
            [alignmentKey]: alignment,
        });
        _console$j.log({ alignmentKey, alignment, differences });
        if (differences.length == 0) {
            return;
        }
        const dataView = serializeContextCommand(this, {
            type: alignmentCommand,
            [alignmentKey]: alignment,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(alignmentCommand, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setHorizontalAlignment(horizontalAlignment, sendImmediately) {
        await this.setAlignment("horizontal", horizontalAlignment, sendImmediately);
    }
    async setVerticalAlignment(verticalAlignment, sendImmediately) {
        await this.setAlignment("vertical", verticalAlignment, sendImmediately);
    }
    async resetAlignment(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            verticalAlignment: DefaultDisplayContextState.verticalAlignment,
            horizontalAlignment: DefaultDisplayContextState.horizontalAlignment,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "resetAlignment";
        const dataView = serializeContextCommand(this, {
            type: commandType,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView?.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setRotation(rotation, isRadians, sendImmediately) {
        rotation = isRadians ? rotation : degToRad(rotation);
        rotation = normalizeRadians(rotation);
        isRadians = true;
        const differences = this.#contextStateHelper.update({
            rotation,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setRotation";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            rotation,
            isRadians,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async clearRotation(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            rotation: 0,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "clearRotation";
        const dataView = serializeContextCommand(this, { type: commandType });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSegmentStartCap(segmentStartCap, sendImmediately) {
        assertValidSegmentCap(segmentStartCap);
        const differences = this.#contextStateHelper.update({
            segmentStartCap,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setSegmentStartCap";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            segmentStartCap,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSegmentEndCap(segmentEndCap, sendImmediately) {
        assertValidSegmentCap(segmentEndCap);
        const differences = this.#contextStateHelper.update({
            segmentEndCap,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setSegmentEndCap";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            segmentEndCap,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSegmentCap(segmentCap, sendImmediately) {
        assertValidSegmentCap(segmentCap);
        const differences = this.#contextStateHelper.update({
            segmentStartCap: segmentCap,
            segmentEndCap: segmentCap,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setSegmentCap";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            segmentCap,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSegmentStartRadius(segmentStartRadius, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            segmentStartRadius,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setSegmentStartRadius";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            segmentStartRadius,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSegmentEndRadius(segmentEndRadius, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            segmentEndRadius,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setSegmentEndRadius";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            segmentEndRadius,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSegmentRadius(segmentRadius, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            segmentStartRadius: segmentRadius,
            segmentEndRadius: segmentRadius,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setSegmentRadius";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            segmentRadius,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setCrop(cropDirection, crop, sendImmediately) {
        _console$j.assertEnumWithError(cropDirection, DisplayCropDirections);
        crop = Math.max(0, crop);
        const cropCommand = DisplayCropDirectionToCommandType[cropDirection];
        const cropKey = DisplayCropDirectionToStateKey[cropDirection];
        const differences = this.#contextStateHelper.update({
            [cropKey]: crop,
        });
        if (differences.length == 0) {
            return;
        }
        const dataView = serializeContextCommand(this, {
            type: cropCommand,
            [cropKey]: crop,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(cropCommand, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setCropTop(cropTop, sendImmediately) {
        await this.setCrop("top", cropTop, sendImmediately);
    }
    async setCropRight(cropRight, sendImmediately) {
        await this.setCrop("right", cropRight, sendImmediately);
    }
    async setCropBottom(cropBottom, sendImmediately) {
        await this.setCrop("bottom", cropBottom, sendImmediately);
    }
    async setCropLeft(cropLeft, sendImmediately) {
        await this.setCrop("left", cropLeft, sendImmediately);
    }
    async clearCrop(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            cropTop: 0,
            cropRight: 0,
            cropBottom: 0,
            cropLeft: 0,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "clearCrop";
        const dataView = serializeContextCommand(this, { type: commandType });
        await this.#sendContextCommand(commandType, dataView?.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setRotationCrop(cropDirection, crop, sendImmediately) {
        _console$j.assertEnumWithError(cropDirection, DisplayCropDirections);
        const cropCommand = DisplayRotationCropDirectionToCommandType[cropDirection];
        const cropKey = DisplayRotationCropDirectionToStateKey[cropDirection];
        const differences = this.#contextStateHelper.update({
            [cropKey]: crop,
        });
        if (differences.length == 0) {
            return;
        }
        const dataView = serializeContextCommand(this, {
            type: cropCommand,
            [cropKey]: crop,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(cropCommand, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setRotationCropTop(rotationCropTop, sendImmediately) {
        await this.setRotationCrop("top", rotationCropTop, sendImmediately);
    }
    async setRotationCropRight(rotationCropRight, sendImmediately) {
        await this.setRotationCrop("right", rotationCropRight, sendImmediately);
    }
    async setRotationCropBottom(rotationCropBottom, sendImmediately) {
        await this.setRotationCrop("bottom", rotationCropBottom, sendImmediately);
    }
    async setRotationCropLeft(rotationCropLeft, sendImmediately) {
        await this.setRotationCrop("left", rotationCropLeft, sendImmediately);
    }
    async clearRotationCrop(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            rotationCropTop: 0,
            rotationCropRight: 0,
            rotationCropBottom: 0,
            rotationCropLeft: 0,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "clearRotationCrop";
        const dataView = serializeContextCommand(this, {
            type: commandType,
        });
        await this.#sendContextCommand(commandType, dataView?.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async selectBitmapColor(bitmapColorIndex, colorIndex, sendImmediately) {
        this.assertValidColorIndex(bitmapColorIndex);
        this.assertValidColorIndex(colorIndex);
        const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();
        bitmapColorIndices[bitmapColorIndex] = colorIndex;
        const differences = this.#contextStateHelper.update({
            bitmapColorIndices,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "selectBitmapColor";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            bitmapColorIndex,
            colorIndex,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    get bitmapColorIndices() {
        return this.contextState.bitmapColorIndices;
    }
    get bitmapColors() {
        return this.bitmapColorIndices.map((colorIndex) => this.colors[colorIndex]);
    }
    async selectBitmapColors(bitmapColorPairs, sendImmediately) {
        _console$j.assertRangeWithError("bitmapColors", bitmapColorPairs.length, 1, this.numberOfColors);
        const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();
        bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {
            this.assertValidColorIndex(bitmapColorIndex);
            this.assertValidColorIndex(colorIndex);
            bitmapColorIndices[bitmapColorIndex] = colorIndex;
        });
        const differences = this.#contextStateHelper.update({
            bitmapColorIndices,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "selectBitmapColors";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            bitmapColorPairs,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setBitmapColor(bitmapColorIndex, color, sendImmediately) {
        return this.setColor(this.bitmapColorIndices[bitmapColorIndex], color, sendImmediately);
    }
    async setBitmapColorOpacity(bitmapColorIndex, opacity, sendImmediately) {
        return this.setColorOpacity(this.bitmapColorIndices[bitmapColorIndex], opacity, sendImmediately);
    }
    async setBitmapScaleDirection(direction, bitmapScale, sendImmediately) {
        bitmapScale = clamp(bitmapScale, minDisplayScale, maxDisplayScale);
        bitmapScale = roundScale(bitmapScale);
        const commandType = DisplayBitmapScaleDirectionToCommandType[direction];
        _console$j.log({ [commandType]: bitmapScale });
        const newState = {};
        let command;
        switch (direction) {
            case "all":
                newState.bitmapScaleX = bitmapScale;
                newState.bitmapScaleY = bitmapScale;
                command = { type: "setBitmapScale", bitmapScale };
                break;
            case "x":
                newState.bitmapScaleX = bitmapScale;
                command = { type: "setBitmapScaleX", bitmapScaleX: bitmapScale };
                break;
            case "y":
                newState.bitmapScaleY = bitmapScale;
                command = { type: "setBitmapScaleY", bitmapScaleY: bitmapScale };
                break;
        }
        const differences = this.#contextStateHelper.update(newState);
        if (differences.length == 0) {
            return;
        }
        const dataView = serializeContextCommand(this, command);
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setBitmapScaleX(bitmapScaleX, sendImmediately) {
        return this.setBitmapScaleDirection("x", bitmapScaleX, sendImmediately);
    }
    async setBitmapScaleY(bitmapScaleY, sendImmediately) {
        return this.setBitmapScaleDirection("y", bitmapScaleY, sendImmediately);
    }
    async setBitmapScale(bitmapScale, sendImmediately) {
        return this.setBitmapScaleDirection("all", bitmapScale, sendImmediately);
    }
    async resetBitmapScale(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            bitmapScaleX: 1,
            bitmapScaleY: 1,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "resetBitmapScale";
        const dataView = serializeContextCommand(this, {
            type: commandType,
        });
        await this.#sendContextCommand(commandType, dataView?.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async selectSpriteColor(spriteColorIndex, colorIndex, sendImmediately) {
        this.assertValidColorIndex(spriteColorIndex);
        this.assertValidColorIndex(colorIndex);
        const spriteColorIndices = this.contextState.spriteColorIndices.slice();
        spriteColorIndices[spriteColorIndex] = colorIndex;
        const differences = this.#contextStateHelper.update({
            spriteColorIndices,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "selectSpriteColor";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            spriteColorIndex,
            colorIndex,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    get spriteColorIndices() {
        return this.contextState.spriteColorIndices;
    }
    get spriteColors() {
        return this.spriteColorIndices.map((colorIndex) => this.colors[colorIndex]);
    }
    async selectSpriteColors(spriteColorPairs, sendImmediately) {
        _console$j.assertRangeWithError("spriteColors", spriteColorPairs.length, 1, this.numberOfColors);
        const spriteColorIndices = this.contextState.spriteColorIndices.slice();
        spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {
            this.assertValidColorIndex(spriteColorIndex);
            this.assertValidColorIndex(colorIndex);
            spriteColorIndices[spriteColorIndex] = colorIndex;
        });
        const differences = this.#contextStateHelper.update({
            spriteColorIndices,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "selectSpriteColors";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            spriteColorPairs,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSpriteColor(spriteColorIndex, color, sendImmediately) {
        return this.setColor(this.spriteColorIndices[spriteColorIndex], color, sendImmediately);
    }
    async setSpriteColorOpacity(spriteColorIndex, opacity, sendImmediately) {
        return this.setColorOpacity(this.spriteColorIndices[spriteColorIndex], opacity, sendImmediately);
    }
    async resetSpriteColors(sendImmediately) {
        const spriteColorIndices = new Array(this.numberOfColors).fill(0);
        const differences = this.#contextStateHelper.update({
            spriteColorIndices,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "resetSpriteColors";
        const dataView = serializeContextCommand(this, {
            type: commandType,
        });
        await this.#sendContextCommand(commandType, dataView?.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSpriteScaleDirection(direction, spriteScale, sendImmediately) {
        spriteScale = clamp(spriteScale, minDisplayScale, maxDisplayScale);
        spriteScale = roundScale(spriteScale);
        const commandType = DisplaySpriteScaleDirectionToCommandType[direction];
        _console$j.log({ [commandType]: spriteScale });
        const newState = {};
        let command;
        switch (direction) {
            case "all":
                newState.spriteScaleX = spriteScale;
                newState.spriteScaleY = spriteScale;
                command = { type: "setSpriteScale", spriteScale };
                break;
            case "x":
                newState.spriteScaleX = spriteScale;
                command = { type: "setSpriteScaleX", spriteScaleX: spriteScale };
                break;
            case "y":
                newState.spriteScaleY = spriteScale;
                command = { type: "setSpriteScaleY", spriteScaleY: spriteScale };
                break;
        }
        const differences = this.#contextStateHelper.update(newState);
        if (differences.length == 0) {
            return;
        }
        const dataView = serializeContextCommand(this, command);
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSpriteScaleX(spriteScaleX, sendImmediately) {
        return this.setSpriteScaleDirection("x", spriteScaleX, sendImmediately);
    }
    async setSpriteScaleY(spriteScaleY, sendImmediately) {
        return this.setSpriteScaleDirection("y", spriteScaleY, sendImmediately);
    }
    async setSpriteScale(spriteScale, sendImmediately) {
        return this.setSpriteScaleDirection("all", spriteScale, sendImmediately);
    }
    async resetSpriteScale(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            spriteScaleX: 1,
            spriteScaleY: 1,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "resetSpriteScale";
        const dataView = serializeContextCommand(this, {
            type: commandType,
        });
        await this.#sendContextCommand(commandType, dataView?.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSpritesLineHeight(spritesLineHeight, sendImmediately) {
        this.assertValidLineWidth(spritesLineHeight);
        const differences = this.#contextStateHelper.update({
            spritesLineHeight,
        });
        if (differences.length == 0) {
            return;
        }
        const commandType = "setSpritesLineHeight";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            spritesLineHeight,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSpritesDirectionGeneric(direction, isOrthogonal, sendImmediately) {
        assertValidDirection(direction);
        const stateKey = isOrthogonal
            ? "spritesLineDirection"
            : "spritesDirection";
        const commandType = isOrthogonal
            ? "setSpritesLineDirection"
            : "setSpritesDirection";
        const differences = this.#contextStateHelper.update({
            [stateKey]: direction,
        });
        if (differences.length == 0) {
            return;
        }
        const dataView = serializeContextCommand(this, {
            type: commandType,
            [stateKey]: direction,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSpritesDirection(spritesDirection, sendImmediately) {
        await this.setSpritesDirectionGeneric(spritesDirection, false, sendImmediately);
    }
    async setSpritesLineDirection(spritesLineDirection, sendImmediately) {
        await this.setSpritesDirectionGeneric(spritesLineDirection, true, sendImmediately);
    }
    async setSpritesSpacingGeneric(spacing, isOrthogonal, sendImmediately) {
        const stateKey = isOrthogonal
            ? "spritesLineSpacing"
            : "spritesSpacing";
        const commandType = isOrthogonal
            ? "setSpritesLineSpacing"
            : "setSpritesSpacing";
        const differences = this.#contextStateHelper.update({
            [stateKey]: spacing,
        });
        if (differences.length == 0) {
            return;
        }
        const dataView = serializeContextCommand(this, {
            type: commandType,
            [stateKey]: spacing,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSpritesSpacing(spritesSpacing, sendImmediately) {
        await this.setSpritesSpacingGeneric(spritesSpacing, false, sendImmediately);
    }
    async setSpritesLineSpacing(spritesSpacing, sendImmediately) {
        await this.setSpritesSpacingGeneric(spritesSpacing, true, sendImmediately);
    }
    async setSpritesAlignmentGeneric(alignment, isOrthogonal, sendImmediately) {
        assertValidAlignment(alignment);
        const stateKey = isOrthogonal
            ? "spritesLineAlignment"
            : "spritesAlignment";
        const commandType = isOrthogonal
            ? "setSpritesLineAlignment"
            : "setSpritesAlignment";
        const differences = this.#contextStateHelper.update({
            [stateKey]: alignment,
        });
        if (differences.length == 0) {
            return;
        }
        const dataView = serializeContextCommand(this, {
            type: commandType,
            [stateKey]: alignment,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async setSpritesAlignment(spritesAlignment, sendImmediately) {
        await this.setSpritesAlignmentGeneric(spritesAlignment, false, sendImmediately);
    }
    async setSpritesLineAlignment(spritesLineAlignment, sendImmediately) {
        await this.setSpritesAlignmentGeneric(spritesLineAlignment, true, sendImmediately);
    }
    async clearRect(x, y, width, height, sendImmediately) {
        const commandType = "clearRect";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            x,
            y,
            width,
            height,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawRect(offsetX, offsetY, width, height, sendImmediately) {
        const commandType = "drawRect";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            width,
            height,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawRoundRect(offsetX, offsetY, width, height, borderRadius, sendImmediately) {
        const commandType = "drawRoundRect";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            width,
            height,
            borderRadius,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawCircle(offsetX, offsetY, radius, sendImmediately) {
        const commandType = "drawCircle";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            radius,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawEllipse(offsetX, offsetY, radiusX, radiusY, sendImmediately) {
        const commandType = "drawEllipse";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            radiusX,
            radiusY,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawRegularPolygon(offsetX, offsetY, radius, numberOfSides, sendImmediately) {
        const commandType = "drawRegularPolygon";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            radius,
            numberOfSides,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawPolygon(points, sendImmediately) {
        _console$j.assertRangeWithError("numberOfPoints", points.length, 2, 255);
        const commandType = "drawPolygon";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            points,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawWireframe(wireframe, sendImmediately) {
        wireframe = trimWireframe(wireframe);
        if (wireframe.points.length == 0) {
            return;
        }
        assertValidWireframe(wireframe);
        if (this.#contextStateHelper.isSegmentUniform) {
            const polygon = isWireframePolygon(wireframe);
            if (polygon) {
                return this.drawSegments(polygon, sendImmediately);
            }
        }
        const commandType = "drawWireframe";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            wireframe,
        });
        if (!dataView) {
            return;
        }
        if (dataView.byteLength > this.#maxCommandDataLength) {
            _console$j.error(`wireframe data ${dataView.byteLength} too large (max ${this.#maxCommandDataLength})`);
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawCurve(curveType, controlPoints, sendImmediately) {
        assertValidNumberOfControlPoints(curveType, controlPoints);
        const commandType = curveType == "cubic"
            ? "drawCubicBezierCurve"
            : "drawQuadraticBezierCurve";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            controlPoints,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawCurves(curveType, controlPoints, sendImmediately) {
        assertValidPathNumberOfControlPoints(curveType, controlPoints);
        const commandType = curveType == "cubic"
            ? "drawCubicBezierCurves"
            : "drawQuadraticBezierCurves";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            controlPoints,
        });
        if (!dataView) {
            return;
        }
        if (dataView.byteLength > this.#maxCommandDataLength) {
            _console$j.error(`curve data ${dataView.byteLength} too large (max ${this.#maxCommandDataLength})`);
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawQuadraticBezierCurve(controlPoints, sendImmediately) {
        await this.drawCurve("quadratic", controlPoints, sendImmediately);
    }
    async drawQuadraticBezierCurves(controlPoints, sendImmediately) {
        await this.drawCurves("quadratic", controlPoints, sendImmediately);
    }
    async drawCubicBezierCurve(controlPoints, sendImmediately) {
        await this.drawCurve("cubic", controlPoints, sendImmediately);
    }
    async drawCubicBezierCurves(controlPoints, sendImmediately) {
        await this.drawCurves("cubic", controlPoints, sendImmediately);
    }
    async _drawPath(isClosed, curves, sendImmediately) {
        assertValidPath(curves);
        const commandType = isClosed
            ? "drawClosedPath"
            : "drawPath";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            curves,
        });
        if (!dataView) {
            return;
        }
        if (dataView.byteLength > this.#maxCommandDataLength) {
            _console$j.error(`path data ${dataView.byteLength} too large (max ${this.#maxCommandDataLength})`);
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawPath(curves, sendImmediately) {
        await this._drawPath(false, curves, sendImmediately);
    }
    async drawClosedPath(curves, sendImmediately) {
        await this._drawPath(true, curves, sendImmediately);
    }
    async drawSegment(startX, startY, endX, endY, sendImmediately) {
        const commandType = "drawSegment";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            startX,
            startY,
            endX,
            endY,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawSegments(points, sendImmediately) {
        _console$j.assertRangeWithError("numberOfPoints", points.length, 2, 255);
        const commandType = "drawSegments";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            points,
        });
        if (!dataView) {
            return;
        }
        if (dataView.byteLength > this.#maxCommandDataLength) {
            const mid = Math.floor(points.length / 2);
            const firstHalf = points.slice(0, mid + 1);
            const secondHalf = points.slice(mid);
            _console$j.log({ firstHalf, secondHalf });
            _console$j.log("sending first half", firstHalf);
            await this.drawSegments(firstHalf, false);
            _console$j.log("sending second half", secondHalf);
            await this.drawSegments(secondHalf, sendImmediately);
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawArc(offsetX, offsetY, radius, startAngle, angleOffset, isRadians, sendImmediately) {
        const commandType = "drawArc";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            radius,
            startAngle,
            angleOffset,
            isRadians,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawArcEllipse(offsetX, offsetY, radiusX, radiusY, startAngle, angleOffset, isRadians, sendImmediately) {
        const commandType = "drawArcEllipse";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            radiusX,
            radiusY,
            startAngle,
            angleOffset,
            isRadians,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    assertValidNumberOfColors(numberOfColors) {
        _console$j.assertRangeWithError("numberOfColors", numberOfColors, 2, this.numberOfColors);
    }
    assertValidBitmap(bitmap, checkSize) {
        this.assertValidNumberOfColors(bitmap.numberOfColors);
        assertValidBitmapPixels(bitmap);
        if (checkSize) {
            this.#assertValidBitmapSize(bitmap);
        }
    }
    #assertValidBitmapSize(bitmap) {
        const pixelDataLength = getBitmapNumberOfBytes(bitmap);
        _console$j.assertRangeWithError("bitmap.pixels.length", pixelDataLength, 1, this.#maxCommandDataLength - drawBitmapHeaderLength);
    }
    async drawBitmap(offsetX, offsetY, bitmap, sendImmediately) {
        this.assertValidBitmap(bitmap, true);
        const commandType = "drawBitmap";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            bitmap,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async imageToBitmap(image, width, height, numberOfColors) {
        return imageToBitmap(image, width, height, this.colors, this.bitmapColorIndices, numberOfColors);
    }
    async quantizeImage(image, width, height, numberOfColors) {
        return quantizeImage(image, width, height, numberOfColors);
    }
    async resizeAndQuantizeImage(image, width, height, numberOfColors, colors) {
        return resizeAndQuantizeImage(image, width, height, numberOfColors, colors);
    }
    async runContextCommand(command, sendImmediately) {
        return runDisplayContextCommand(this, command, sendImmediately);
    }
    async runContextCommands(commands, sendImmediately) {
        return runDisplayContextCommands(this, commands, sendImmediately);
    }
    #isReady = true;
    get isReady() {
        return this.isAvailable && this.#isReady;
    }
    #lastReadyTime = 0;
    #lastShowRequestTime = 0;
    #minReadyInterval = 60;
    #waitBeforeReady = true;
    async #parseDisplayReady(dataView) {
        const now = Date.now();
        const timeSinceLastDraw = now - this.#lastShowRequestTime;
        const timeSinceLastReady = now - this.#lastReadyTime;
        _console$j.log(`${timeSinceLastDraw}ms draw time`);
        if (this.#waitBeforeReady && timeSinceLastReady < this.#minReadyInterval) {
            const timeToWait = this.#minReadyInterval - timeSinceLastReady;
            _console$j.log(`waiting ${timeToWait}ms`);
            await wait(timeToWait);
        }
        this.#isReady = true;
        this.#lastReadyTime = Date.now();
        this.#dispatchEvent("displayReady", {});
    }
    #spriteSheets = {};
    #spriteSheetIndices = {};
    get spriteSheets() {
        return this.#spriteSheets;
    }
    get spriteSheetIndices() {
        return this.#spriteSheetIndices;
    }
    async #setSpriteSheetName(spriteSheetName, sendImmediately) {
        if (typeof spriteSheetName == "number") {
            spriteSheetName = spriteSheetName.toString();
        }
        _console$j.assertTypeWithError(spriteSheetName, "string");
        _console$j.assertRangeWithError("newName", spriteSheetName.length, MinSpriteSheetNameLength, MaxSpriteSheetNameLength);
        const setSpriteSheetNameData = textEncoder.encode(spriteSheetName);
        _console$j.log({ setSpriteSheetNameData });
        const promise = this.waitForEvent("getSpriteSheetName");
        this.sendMessage([{ type: "setSpriteSheetName", data: setSpriteSheetNameData.buffer }], sendImmediately);
        await promise;
    }
    #pendingSpriteSheet;
    get pendingSpriteSheet() {
        return this.#pendingSpriteSheet;
    }
    #pendingSpriteSheetName;
    get pendingSpriteSheetName() {
        return this.#pendingSpriteSheetName;
    }
    #updateSpriteSheetName(updatedSpriteSheetName) {
        _console$j.assertTypeWithError(updatedSpriteSheetName, "string");
        this.#pendingSpriteSheetName = updatedSpriteSheetName;
        _console$j.log({ updatedSpriteSheetName: this.#pendingSpriteSheetName });
        this.#dispatchEvent("getSpriteSheetName", {
            spriteSheetName: this.#pendingSpriteSheetName,
        });
    }
    sendFile;
    serializeSpriteSheet(spriteSheet) {
        return serializeSpriteSheet(this, spriteSheet);
    }
    async uploadSpriteSheet(spriteSheet) {
        if (spriteSheet.sprites.length == 0) {
            _console$j.log("no sprites in spriteSheet");
            return;
        }
        if (this.#pendingSpriteSheet) {
            await this.waitForEvent("displaySpriteSheetUploadComplete");
            await this.uploadSpriteSheet(spriteSheet);
            return;
        }
        spriteSheet = structuredClone(spriteSheet);
        this.#pendingSpriteSheet = spriteSheet;
        const buffer = this.serializeSpriteSheet(this.#pendingSpriteSheet);
        await this.#setSpriteSheetName(this.#pendingSpriteSheet.name);
        const promise = this.waitForEvent("displaySpriteSheetUploadComplete");
        this.sendFile("spriteSheet", buffer, true);
        await promise;
    }
    async uploadSpriteSheets(spriteSheets) {
        for (const spriteSheet of spriteSheets) {
            await this.uploadSpriteSheet(spriteSheet);
        }
    }
    assertLoadedSpriteSheet(spriteSheetName) {
        assertLoadedSpriteSheet(this, spriteSheetName);
    }
    assertSelectedSpriteSheet(spriteSheetName) {
        assertSelectedSpriteSheet(this, spriteSheetName);
    }
    assertAnySelectedSpriteSheet() {
        assertAnySelectedSpriteSheet(this);
    }
    assertSprite(spriteName) {
        return assertSprite(this, spriteName);
    }
    getSprite(spriteName) {
        return getSprite(this, spriteName);
    }
    getSpriteSheetPalette(paletteName) {
        return getSpriteSheetPalette(this, paletteName);
    }
    getSpriteSheetPaletteSwap(paletteSwapName) {
        return getSpriteSheetPaletteSwap(this, paletteSwapName);
    }
    getSpritePaletteSwap(spriteName, paletteSwapName) {
        return getSpritePaletteSwap(this, spriteName, paletteSwapName);
    }
    get selectedSpriteSheet() {
        if (this.contextState.spriteSheetName) {
            return this.#spriteSheets[this.contextState.spriteSheetName];
        }
    }
    get selectedSpriteSheetName() {
        return this.selectedSpriteSheet?.name;
    }
    async selectSpriteSheet(spriteSheetName, sendImmediately) {
        this.assertLoadedSpriteSheet(spriteSheetName);
        const differences = this.#contextStateHelper.update({
            spriteSheetName,
        });
        if (differences.length == 0) {
            return;
        }
        const spriteSheetIndex = this.spriteSheetIndices[spriteSheetName];
        const commandType = "selectSpriteSheet";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            spriteSheetIndex,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
        this.#onContextStateUpdate(differences);
    }
    async drawSprite(offsetX, offsetY, spriteName, sendImmediately) {
        _console$j.assertWithError(this.selectedSpriteSheet, "no spriteSheet selected");
        _console$j.log(`drawing sprite "${spriteName}" in selectedSpriteSheet`, this.selectedSpriteSheet);
        let spriteIndex = this.selectedSpriteSheet.sprites.findIndex((sprite) => sprite.name == spriteName);
        _console$j.assertWithError(spriteIndex != -1, `sprite "${spriteName}" not found in spriteSheet`);
        spriteIndex = spriteIndex;
        const commandType = "drawSprite";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            spriteIndex,
            use2Bytes: this.selectedSpriteSheet.sprites.length > 255,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawSprites(offsetX, offsetY, spriteLines, sendImmediately) {
        _console$j.assertWithError(this.contextState.spritesLineHeight > 0, `spritesLineHeight must be >0`);
        const spriteSerializedLines = spriteLinesToSerializedLines(this, spriteLines);
        _console$j.log("spriteSerializedLines", spriteSerializedLines);
        const commandType = "drawSprites";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            spriteSerializedLines: spriteSerializedLines,
        });
        if (!dataView) {
            return;
        }
        if (dataView.byteLength > this.#maxCommandDataLength) {
            _console$j.log("breaking up sprites...");
            const mid = Math.floor(spriteLines.length / 2);
            const firstHalf = spriteLines.slice(0, mid);
            const secondHalf = spriteLines.slice(mid);
            let firstHalfOffsetX = offsetX;
            let firstHalfOffsetY = offsetY;
            let secondHalfOffsetX = offsetX;
            let secondHalfOffsetY = offsetY;
            let didStartSprite = false;
            if (!this.#isDrawingBlankSprite) {
                didStartSprite = true;
                const { localSize } = getSpriteLinesMetrics(spriteLines, this.spriteSheets, this.contextState);
                const { spritesLineHeight, spritesDirection, spritesLineDirection, spritesAlignment, spritesLineAlignment, spritesLineSpacing, spritesSpacing, horizontalAlignment, verticalAlignment, } = this.contextState;
                _console$j.log("starting sprites sprite...");
                await this.startSprite(offsetX, offsetY, localSize.width, localSize.height, false);
                await this.setSpritesLineHeight(spritesLineHeight, false);
                await this.setSpritesDirection(spritesDirection, false);
                await this.setSpritesLineDirection(spritesLineDirection, false);
                await this.setSpritesAlignment(spritesAlignment, false);
                await this.setSpritesLineAlignment(spritesLineAlignment, false);
                await this.setSpritesSpacing(spritesSpacing, false);
                await this.setSpritesLineSpacing(spritesLineSpacing, false);
                await this.setHorizontalAlignment(horizontalAlignment, false);
                await this.setVerticalAlignment(verticalAlignment, false);
                switch (horizontalAlignment) {
                    case "start":
                        firstHalfOffsetX = -localSize.width / 2;
                        break;
                    case "center":
                        firstHalfOffsetX = 0;
                        break;
                    case "end":
                        firstHalfOffsetX = localSize.width / 2;
                        break;
                }
                switch (verticalAlignment) {
                    case "start":
                        firstHalfOffsetY = -localSize.height / 2;
                        break;
                    case "center":
                        firstHalfOffsetY = -localSize.height / 4;
                        break;
                    case "end":
                        firstHalfOffsetY = 0;
                        break;
                }
                secondHalfOffsetX = firstHalfOffsetX;
                secondHalfOffsetY = firstHalfOffsetY;
            }
            _console$j.log("sending first half sprites", firstHalf);
            await this.drawSprites(firstHalfOffsetX, firstHalfOffsetY, firstHalf, false);
            const { localSize: firstHalfSize } = getSpriteLinesMetrics(firstHalf, this.#spriteSheets, this.contextState);
            const isSpritesLineDirectionPositive = isDirectionPositive(this.contextState.spritesLineDirection);
            const isSpritesLineDirectionHorizontal = isDirectionHorizontal(this.contextState.spritesLineDirection);
            const sign = isSpritesLineDirectionPositive ? 1 : -1;
            if (isSpritesLineDirectionHorizontal) {
                secondHalfOffsetX += firstHalfSize.width * sign;
            }
            else {
                secondHalfOffsetY += firstHalfSize.height * sign;
            }
            _console$j.log("sending second half sprites", secondHalf);
            await this.drawSprites(secondHalfOffsetX, secondHalfOffsetY, secondHalf, false);
            if (didStartSprite) {
                _console$j.log("ending sprites sprite...");
                await this.endSprite(sendImmediately);
            }
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async drawSpritesString(offsetX, offsetY, string, requireAll, maxLineBreadth, separators, sendImmediately) {
        const spriteLines = this.stringToSpriteLines(string, requireAll, maxLineBreadth, separators);
        await this.drawSprites(offsetX, offsetY, spriteLines, sendImmediately);
    }
    stringToSpriteLines(string, requireAll, maxLineBreadth, separators) {
        return stringToSpriteLines(string, this.spriteSheets, this.contextState, requireAll, maxLineBreadth, separators);
    }
    stringToSpriteLinesMetrics(string, requireAll, maxLineBreadth, separators) {
        return stringToSpriteLinesMetrics(string, this.spriteSheets, this.contextState, requireAll, maxLineBreadth, separators);
    }
    async drawSpriteFromSpriteSheet(offsetX, offsetY, spriteName, spriteSheet, paletteName, sendImmediately) {
        return drawSpriteFromSpriteSheet(this, offsetX, offsetY, spriteName, spriteSheet, paletteName, sendImmediately);
    }
    #parseSpriteSheetIndex(dataView) {
        const spriteSheetIndex = dataView.getUint8(0);
        _console$j.log({
            pendingSpriteSheet: this.#pendingSpriteSheet,
            spriteSheetName: this.#pendingSpriteSheetName,
            spriteSheetIndex,
        });
        if (this.isServerSide) {
            return;
        }
        _console$j.assertWithError(this.#pendingSpriteSheetName != undefined, "expected spriteSheetName when receiving spriteSheetIndex");
        _console$j.assertWithError(this.#pendingSpriteSheet != undefined, "expected pendingSpriteSheet when receiving spriteSheetIndex");
        this.#spriteSheets[this.#pendingSpriteSheetName] =
            this.#pendingSpriteSheet;
        this.#spriteSheetIndices[this.#pendingSpriteSheetName] = spriteSheetIndex;
        _console$j.log(`finished uploading "${this.#pendingSpriteSheetName}" spriteSheet`);
        this.#dispatchEvent("displaySpriteSheetUploadComplete", {
            spriteSheetName: this.#pendingSpriteSheetName,
            spriteSheet: this.#pendingSpriteSheet,
        });
        this.#pendingSpriteSheet = undefined;
    }
    parseMessage(messageType, dataView) {
        _console$j.log({ messageType, dataView });
        switch (messageType) {
            case "isDisplayAvailable":
                this.#parseIsDisplayAvailable(dataView);
                break;
            case "displayStatus":
                this.#parseDisplayStatus(dataView);
                break;
            case "displayInformation":
                this.#parseDisplayInformation(dataView);
                break;
            case "getDisplayBrightness":
            case "setDisplayBrightness":
                this.#parseDisplayBrightness(dataView);
                break;
            case "displayReady":
                this.#parseDisplayReady(dataView);
                break;
            case "getSpriteSheetName":
            case "setSpriteSheetName":
                const spriteSheetName = textDecoder.decode(dataView.buffer);
                _console$j.log({ spriteSheetName });
                this.#updateSpriteSheetName(spriteSheetName);
                break;
            case "spriteSheetIndex":
                this.#parseSpriteSheetIndex(dataView);
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
    assertSpriteSheetPalette(paletteName) {
        assertSpriteSheetPalette(this, paletteName);
    }
    assertSpriteSheetPaletteSwap(paletteSwapName) {
        assertSpriteSheetPaletteSwap(this, paletteSwapName);
    }
    assertSpritePaletteSwap(spriteName, paletteSwapName) {
        assertSpritePaletteSwap(this, spriteName, paletteSwapName);
    }
    async selectSpriteSheetPalette(paletteName, offset, indicesOnly, sendImmediately) {
        await selectSpriteSheetPalette(this, paletteName, offset, indicesOnly, sendImmediately);
    }
    async selectSpriteSheetPaletteSwap(paletteSwapName, offset, sendImmediately) {
        await selectSpriteSheetPaletteSwap(this, paletteSwapName, offset, sendImmediately);
    }
    async selectSpritePaletteSwap(spriteName, paletteSwapName, offset, sendImmediately) {
        await selectSpritePaletteSwap(this, spriteName, paletteSwapName, offset, sendImmediately);
    }
    #isDrawingBlankSprite = false;
    async startSprite(offsetX, offsetY, width, height, sendImmediately) {
        _console$j.assertWithError(!this.#isDrawingBlankSprite, `already drawing blank sprite`);
        this.#isDrawingBlankSprite = true;
        this.#saveContext(sendImmediately);
        this.#contextStateHelper.reset();
        this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(0);
        this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(0);
        const commandType = "startSprite";
        const dataView = serializeContextCommand(this, {
            type: commandType,
            offsetX,
            offsetY,
            width,
            height,
        });
        if (!dataView) {
            return;
        }
        await this.#sendContextCommand(commandType, dataView.buffer, sendImmediately);
    }
    async endSprite(sendImmediately) {
        this.#restoreContext(sendImmediately);
        _console$j.assertWithError(this.#isDrawingBlankSprite, `not drawing blank sprite`);
        this.#isDrawingBlankSprite = false;
        await this.#sendContextCommand("endSprite", undefined, sendImmediately);
    }
    reset() {
        _console$j.log("clearing displayManager");
        this.#displayStatus = undefined;
        this.#isAvailable = false;
        this.#displayInformation = undefined;
        this.#brightness = undefined;
        this.#contextCommandBuffers = [];
        this.#isAvailable = false;
        this.#contextStateHelper.reset();
        this.#colors.length = 0;
        this.#opacities.length = 0;
        this.#isReady = true;
        this.#pendingSpriteSheet = undefined;
        this.#pendingSpriteSheetName = undefined;
        this.isServerSide = false;
        this.#isDrawingBlankSprite = false;
        Object.keys(this.#spriteSheetIndices).forEach((spriteSheetName) => delete this.#spriteSheetIndices[spriteSheetName]);
        Object.keys(this.#spriteSheets).forEach((spriteSheetName) => delete this.#spriteSheets[spriteSheetName]);
    }
    #mtu;
    get mtu() {
        return this.#mtu;
    }
    set mtu(newMtu) {
        this.#mtu = newMtu;
    }
    #isServerSide = false;
    get isServerSide() {
        return this.#isServerSide;
    }
    set isServerSide(newIsServerSide) {
        if (this.#isServerSide == newIsServerSide) {
            return;
        }
        this.#isServerSide = newIsServerSide;
        _console$j.log({ isServerSide: this.isServerSide });
    }
}

const _console$i = createConsole("BaseConnectionManager", { log: false });
const ConnectionTypes = [
    "webBluetooth",
    "noble",
    "client",
    "webSocket",
    "udp",
];
const ConnectionStatuses = [
    "notConnected",
    "connecting",
    "connected",
    "disconnecting",
];
const ConnectionEventTypes = [
    ...ConnectionStatuses,
    "connectionStatus",
    "isConnected",
];
const TxRxMessageTypes = [
    ...InformationMessageTypes,
    ...SensorConfigurationMessageTypes,
    ...SensorDataMessageTypes,
    ...VibrationMessageTypes,
    ...FileTransferMessageTypes,
    ...TfliteMessageTypes,
    ...WifiMessageTypes,
    ...CameraMessageTypes,
    ...MicrophoneMessageTypes,
    ...DisplayMessageTypes,
];
const SMPMessageTypes = ["smp"];
const BatteryLevelMessageTypes = ["batteryLevel"];
const MetaConnectionMessageTypes = ["rx", "tx"];
const ConnectionMessageTypes = [
    ...BatteryLevelMessageTypes,
    ...DeviceInformationTypes,
    ...MetaConnectionMessageTypes,
    ...TxRxMessageTypes,
    ...SMPMessageTypes,
];
class BaseConnectionManager {
    static #AssertValidTxRxMessageType(messageType) {
        _console$i.assertEnumWithError(messageType, TxRxMessageTypes);
    }
    onStatusUpdated;
    onMessageReceived;
    onMessagesReceived;
    get baseConstructor() {
        return this.constructor;
    }
    static get isSupported() {
        return false;
    }
    get isSupported() {
        return this.baseConstructor.isSupported;
    }
    get canUpdateFirmware() {
        return false;
    }
    static type;
    get type() {
        return this.baseConstructor.type;
    }
    #assertIsSupported() {
        _console$i.assertWithError(this.isSupported, `${this.type} is not supported`);
    }
    constructor() {
        this.#assertIsSupported();
    }
    #status = "notConnected";
    get status() {
        return this.#status;
    }
    set status(newConnectionStatus) {
        _console$i.assertEnumWithError(newConnectionStatus, ConnectionStatuses);
        if (this.#status == newConnectionStatus) {
            _console$i.log(`tried to assign same connection status "${newConnectionStatus}"`);
            return;
        }
        _console$i.log(`new connection status "${newConnectionStatus}"`);
        this.#status = newConnectionStatus;
        this.onStatusUpdated(this.status);
        if (this.isConnected) {
            this.#timer.start();
        }
        else {
            this.#timer.stop();
        }
        if (this.#status == "notConnected") {
            this.mtu = this.defaultMtu;
        }
    }
    get isConnected() {
        return this.status == "connected";
    }
    get isAvailable() {
        return false;
    }
    assertIsNotConnected() {
        _console$i.assertWithError(!this.isConnected, "device is already connected");
    }
    #assertIsNotConnecting() {
        _console$i.assertWithError(this.status != "connecting", "device is already connecting");
    }
    assertIsConnected() {
        _console$i.assertWithError(this.isConnected, "device is not connected");
    }
    #assertIsNotDisconnecting() {
        _console$i.assertWithError(this.status != "disconnecting", "device is already disconnecting");
    }
    assertIsConnectedAndNotDisconnecting() {
        this.assertIsConnected();
        this.#assertIsNotDisconnecting();
    }
    async connect() {
        if (this.isConnected) {
            _console$i.log("already connected");
            return false;
        }
        if (this.#status == "connecting") {
            _console$i.log("already connecting");
            return false;
        }
        this.status = "connecting";
        return true;
    }
    get canReconnect() {
        return false;
    }
    async reconnect() {
        if (this.isConnected) {
            _console$i.log("already connected");
            return false;
        }
        if (this.#status == "connecting") {
            _console$i.log("already connecting");
            return false;
        }
        if (!this.canReconnect) {
            _console$i.warn("unable to reconnect");
            return false;
        }
        this.status = "connecting";
        _console$i.log("attempting to reconnect...");
        return true;
    }
    async disconnect() {
        if (!this.isConnected) {
            _console$i.log("already not connected");
            return false;
        }
        if (this.#status == "disconnecting") {
            _console$i.log("already disconnecting");
            return false;
        }
        this.status = "disconnecting";
        _console$i.log("disconnecting from device...");
        return true;
    }
    async sendSmpMessage(data) {
        this.assertIsConnectedAndNotDisconnecting();
        _console$i.log("sending smp message", data);
    }
    #pendingMessages = [];
    #isSendingMessages = false;
    async sendTxMessages(messages, sendImmediately = true) {
        this.assertIsConnectedAndNotDisconnecting();
        if (messages) {
            this.#pendingMessages.push(...messages);
            _console$i.log(`appended ${messages.length} messages`);
        }
        if (!sendImmediately) {
            _console$i.log("not sending immediately - waiting until later");
            return;
        }
        if (this.#isSendingMessages) {
            _console$i.log("already sending messages - waiting until later");
            return;
        }
        if (this.#pendingMessages.length == 0) {
            _console$i.log("no pendingMessages");
            return;
        }
        this.#isSendingMessages = true;
        _console$i.log("sendTxMessages", this.#pendingMessages.slice());
        const arrayBuffers = this.#pendingMessages.map((message) => {
            BaseConnectionManager.#AssertValidTxRxMessageType(message.type);
            const messageTypeEnum = TxRxMessageTypes.indexOf(message.type);
            const dataLength = new DataView(new ArrayBuffer(2));
            dataLength.setUint16(0, message.data?.byteLength || 0, true);
            return concatenateArrayBuffers(messageTypeEnum, dataLength, message.data);
        });
        this.#pendingMessages.length = 0;
        if (this.mtu) {
            while (arrayBuffers.length > 0) {
                if (arrayBuffers.every((arrayBuffer) => arrayBuffer.byteLength > this.mtu - 3)) {
                    _console$i.error("every arrayBuffer is too big to send");
                    break;
                }
                _console$i.log("remaining arrayBuffers.length", arrayBuffers.length);
                let arrayBufferByteLength = 0;
                let arrayBufferCount = 0;
                arrayBuffers.some((arrayBuffer) => {
                    if (arrayBufferByteLength + arrayBuffer.byteLength > this.mtu - 3) {
                        _console$i.log(`stopping appending arrayBuffers ( length ${arrayBuffer.byteLength} too much)`);
                        return true;
                    }
                    _console$i.log(`allowing arrayBuffer with length ${arrayBuffer.byteLength}`);
                    arrayBufferCount++;
                    arrayBufferByteLength += arrayBuffer.byteLength;
                });
                const arrayBuffersToSend = arrayBuffers.splice(0, arrayBufferCount);
                _console$i.log({ arrayBufferCount, arrayBuffersToSend });
                const arrayBuffer = concatenateArrayBuffers(...arrayBuffersToSend);
                _console$i.log("sending arrayBuffer (partitioned)", arrayBuffer);
                await this.sendTxData(arrayBuffer);
            }
        }
        else {
            const arrayBuffer = concatenateArrayBuffers(...arrayBuffers);
            _console$i.log("sending arrayBuffer (all)", arrayBuffer);
            await this.sendTxData(arrayBuffer);
        }
        this.#isSendingMessages = false;
        this.sendTxMessages(undefined, true);
    }
    defaultMtu = 23;
    mtu = this.defaultMtu;
    async sendTxData(data) {
        _console$i.log("sendTxData", data);
    }
    parseRxMessage(dataView) {
        parseMessage(dataView, TxRxMessageTypes, this.#onRxMessage.bind(this), null, true);
        this.onMessagesReceived();
    }
    #onRxMessage(messageType, dataView) {
        _console$i.log({ messageType, dataView });
        this.onMessageReceived(messageType, dataView);
    }
    #timer = new Timer(this.#checkConnection.bind(this), 5000);
    #checkConnection() {
        if (!this.isConnected) {
            _console$i.log("timer detected disconnection");
            this.status = "notConnected";
        }
    }
    clear() {
        this.#isSendingMessages = false;
        this.#pendingMessages.length = 0;
    }
    remove() {
        this.clear();
        this.onStatusUpdated = undefined;
        this.onMessageReceived = undefined;
        this.onMessagesReceived = undefined;
    }
}

const _console$h = createConsole("EventUtils", { log: false });
function addEventListeners(target, boundEventListeners) {
    let addEventListener = target.addEventListener || target.addListener || target.on || target.AddEventListener;
    _console$h.assertWithError(addEventListener, "no add listener function found for target");
    addEventListener = addEventListener.bind(target);
    Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {
        addEventListener(eventType, eventListener);
    });
}
function removeEventListeners(target, boundEventListeners) {
    let removeEventListener = target.removeEventListener || target.removeListener || target.RemoveEventListener;
    _console$h.assertWithError(removeEventListener, "no remove listener function found for target");
    removeEventListener = removeEventListener.bind(target);
    Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {
        removeEventListener(eventType, eventListener);
    });
}

const _console$g = createConsole("bluetoothUUIDs", { log: false });
if (isInBrowser) {
    var BluetoothUUID = window.BluetoothUUID;
}
function generateBluetoothUUID(value) {
    _console$g.assertTypeWithError(value, "string");
    _console$g.assertWithError(value.length == 4, "value must be 4 characters long");
    return `ea6d${value}-a725-4f9b-893d-c3913e33b39f`;
}
function stringToCharacteristicUUID(identifier) {
    return BluetoothUUID?.getCharacteristic?.(identifier);
}
function stringToServiceUUID(identifier) {
    return BluetoothUUID?.getService?.(identifier);
}
const bluetoothUUIDs = Object.freeze({
    services: {
        deviceInformation: {
            uuid: stringToServiceUUID("device_information"),
            characteristics: {
                manufacturerName: {
                    uuid: stringToCharacteristicUUID("manufacturer_name_string"),
                },
                modelNumber: {
                    uuid: stringToCharacteristicUUID("model_number_string"),
                },
                hardwareRevision: {
                    uuid: stringToCharacteristicUUID("hardware_revision_string"),
                },
                firmwareRevision: {
                    uuid: stringToCharacteristicUUID("firmware_revision_string"),
                },
                softwareRevision: {
                    uuid: stringToCharacteristicUUID("software_revision_string"),
                },
                pnpId: {
                    uuid: stringToCharacteristicUUID("pnp_id"),
                },
                serialNumber: {
                    uuid: stringToCharacteristicUUID("serial_number_string"),
                },
            },
        },
        battery: {
            uuid: stringToServiceUUID("battery_service"),
            characteristics: {
                batteryLevel: {
                    uuid: stringToCharacteristicUUID("battery_level"),
                },
            },
        },
        main: {
            uuid: generateBluetoothUUID("0000"),
            characteristics: {
                rx: { uuid: generateBluetoothUUID("1000") },
                tx: { uuid: generateBluetoothUUID("1001") },
            },
        },
        smp: {
            uuid: "8d53dc1d-1db7-4cd3-868b-8a527460aa84",
            characteristics: {
                smp: { uuid: "da2e7828-fbce-4e01-ae9e-261174997c48" },
            },
        },
    },
});
const serviceUUIDs = [bluetoothUUIDs.services.main.uuid];
const optionalServiceUUIDs = [
    bluetoothUUIDs.services.deviceInformation.uuid,
    bluetoothUUIDs.services.battery.uuid,
    bluetoothUUIDs.services.smp.uuid,
];
[...serviceUUIDs, ...optionalServiceUUIDs];
function getServiceNameFromUUID(serviceUUID) {
    serviceUUID = serviceUUID.toString().toLowerCase();
    const serviceNames = Object.keys(bluetoothUUIDs.services);
    return serviceNames.find((serviceName) => {
        const serviceInfo = bluetoothUUIDs.services[serviceName];
        let serviceInfoUUID = serviceInfo.uuid.toString();
        if (serviceUUID.length == 4) {
            serviceInfoUUID = serviceInfoUUID.slice(4, 8);
        }
        if (!serviceUUID.includes("-")) {
            serviceInfoUUID = serviceInfoUUID.replaceAll("-", "");
        }
        return serviceUUID == serviceInfoUUID;
    });
}
const characteristicUUIDs = [];
const allCharacteristicUUIDs = [];
Object.values(bluetoothUUIDs.services).forEach((serviceInfo) => {
    if (!serviceInfo.characteristics) {
        return;
    }
    const characteristicNames = Object.keys(serviceInfo.characteristics);
    characteristicNames.forEach((characteristicName) => {
        const characteristicInfo = serviceInfo.characteristics[characteristicName];
        if (serviceUUIDs.includes(serviceInfo.uuid)) {
            characteristicUUIDs.push(characteristicInfo.uuid);
            characteristicNames.push(characteristicName);
        }
        allCharacteristicUUIDs.push(characteristicInfo.uuid);
    });
}, []);
function getCharacteristicNameFromUUID(characteristicUUID) {
    characteristicUUID = characteristicUUID.toString().toLowerCase();
    var characteristicName;
    Object.values(bluetoothUUIDs.services).some((serviceInfo) => {
        const characteristicNames = Object.keys(serviceInfo.characteristics);
        characteristicName = characteristicNames.find((_characteristicName) => {
            const characteristicInfo = serviceInfo.characteristics[_characteristicName];
            let characteristicInfoUUID = characteristicInfo.uuid.toString();
            if (characteristicUUID.length == 4) {
                characteristicInfoUUID = characteristicInfoUUID.slice(4, 8);
            }
            if (!characteristicUUID.includes("-")) {
                characteristicInfoUUID = characteristicInfoUUID.replaceAll("-", "");
            }
            return characteristicUUID == characteristicInfoUUID;
        });
        return characteristicName;
    });
    return characteristicName;
}
function getCharacteristicProperties(characteristicName) {
    const properties = {
        broadcast: false,
        read: true,
        writeWithoutResponse: false,
        write: false,
        notify: false,
        indicate: false,
        authenticatedSignedWrites: false,
        reliableWrite: false,
        writableAuxiliaries: false,
    };
    switch (characteristicName) {
        case "rx":
        case "tx":
        case "smp":
            properties.read = false;
            break;
    }
    switch (characteristicName) {
        case "batteryLevel":
        case "rx":
        case "smp":
            properties.notify = true;
            break;
    }
    switch (characteristicName) {
        case "smp":
            properties.writeWithoutResponse = true;
            break;
    }
    switch (characteristicName) {
        case "tx":
            properties.write = true;
            break;
    }
    return properties;
}

const _console$f = createConsole("BluetoothConnectionManager", { log: false });
class BluetoothConnectionManager extends BaseConnectionManager {
    get isAvailable() {
        return true;
    }
    isInRange = true;
    onCharacteristicValueChanged(characteristicName, dataView) {
        if (characteristicName == "rx") {
            this.parseRxMessage(dataView);
        }
        else {
            this.onMessageReceived?.(characteristicName, dataView);
        }
    }
    async writeCharacteristic(characteristicName, data) {
        _console$f.log("writeCharacteristic", ...arguments);
    }
    async sendSmpMessage(data) {
        super.sendSmpMessage(data);
        await this.writeCharacteristic("smp", data);
    }
    async sendTxData(data) {
        super.sendTxData(data);
        if (data.byteLength == 0) {
            return;
        }
        await this.writeCharacteristic("tx", data);
    }
}

const _console$e = createConsole("WebBluetoothConnectionManager", { log: false });
var bluetooth;
if (isInBrowser) {
    bluetooth = window.navigator.bluetooth;
}
class WebBluetoothConnectionManager extends BluetoothConnectionManager {
    get bluetoothId() {
        return this.device.id;
    }
    get canUpdateFirmware() {
        return this.#characteristics.has("smp");
    }
    #boundBluetoothCharacteristicEventListeners = {
        characteristicvaluechanged: this.#onCharacteristicvaluechanged.bind(this),
    };
    #boundBluetoothDeviceEventListeners = {
        gattserverdisconnected: this.#onGattserverdisconnected.bind(this),
    };
    static get isSupported() {
        return Boolean(bluetooth);
    }
    static get type() {
        return "webBluetooth";
    }
    #device;
    get device() {
        return this.#device;
    }
    set device(newDevice) {
        if (this.#device == newDevice) {
            _console$e.log("tried to assign the same BluetoothDevice");
            return;
        }
        if (this.#device) {
            removeEventListeners(this.#device, this.#boundBluetoothDeviceEventListeners);
        }
        if (newDevice) {
            addEventListeners(newDevice, this.#boundBluetoothDeviceEventListeners);
        }
        this.#device = newDevice;
    }
    get server() {
        return this.#device?.gatt;
    }
    get isConnected() {
        return this.server?.connected || false;
    }
    #services = new Map();
    #characteristics = new Map();
    async connect() {
        const canContinue = super.connect();
        if (!canContinue) {
            return false;
        }
        try {
            const device = await bluetooth.requestDevice({
                filters: [{ services: serviceUUIDs }],
                optionalServices: isInBrowser ? optionalServiceUUIDs : [],
            });
            _console$e.log("got BluetoothDevice");
            this.device = device;
            _console$e.log("connecting to device...");
            const server = await this.server.connect();
            _console$e.log(`connected to device? ${server.connected}`);
            await this.#getServicesAndCharacteristics();
            _console$e.log("fully connected");
            this.status = "connected";
            return true;
        }
        catch (error) {
            _console$e.error(error);
            this.status = "notConnected";
            this.server?.disconnect();
            await this.#removeEventListeners();
            return false;
        }
    }
    async #getServicesAndCharacteristics() {
        this.#removeEventListeners();
        _console$e.log("getting services...");
        const services = await this.server.getPrimaryServices();
        _console$e.log("got services", services.length);
        _console$e.log("getting characteristics...");
        for (const serviceIndex in services) {
            const service = services[serviceIndex];
            _console$e.log({ service });
            const serviceName = getServiceNameFromUUID(service.uuid);
            _console$e.assertWithError(serviceName, `no name found for service uuid "${service.uuid}"`);
            _console$e.log(`got "${serviceName}" service`);
            service.name = serviceName;
            this.#services.set(serviceName, service);
            _console$e.log(`getting characteristics for "${serviceName}" service`);
            const characteristics = await service.getCharacteristics();
            _console$e.log(`got characteristics for "${serviceName}" service`);
            for (const characteristicIndex in characteristics) {
                const characteristic = characteristics[characteristicIndex];
                _console$e.log({ characteristic });
                const characteristicName = getCharacteristicNameFromUUID(characteristic.uuid);
                _console$e.assertWithError(Boolean(characteristicName), `no name found for characteristic uuid "${characteristic.uuid}" in "${serviceName}" service`);
                _console$e.log(`got "${characteristicName}" characteristic in "${serviceName}" service`);
                characteristic.name = characteristicName;
                this.#characteristics.set(characteristicName, characteristic);
                addEventListeners(characteristic, this.#boundBluetoothCharacteristicEventListeners);
                const characteristicProperties = characteristic.properties ||
                    getCharacteristicProperties(characteristicName);
                if (characteristicProperties.notify) {
                    _console$e.log(`starting notifications for "${characteristicName}" characteristic`);
                    await characteristic.startNotifications();
                }
                if (characteristicProperties.read) {
                    _console$e.log(`reading "${characteristicName}" characteristic...`);
                    await characteristic.readValue();
                    if (isInBluefy || isInWebBLE) {
                        this.#onCharacteristicValueChanged(characteristic);
                    }
                }
            }
        }
    }
    async #removeEventListeners() {
        if (this.device) {
            removeEventListeners(this.device, this.#boundBluetoothDeviceEventListeners);
        }
        const promises = Array.from(this.#characteristics.keys()).map((characteristicName) => {
            const characteristic = this.#characteristics.get(characteristicName);
            removeEventListeners(characteristic, this.#boundBluetoothCharacteristicEventListeners);
            const characteristicProperties = characteristic.properties ||
                getCharacteristicProperties(characteristicName);
            if (characteristicProperties.notify) {
                _console$e.log(`stopping notifications for "${characteristicName}" characteristic`);
                return characteristic.stopNotifications();
            }
        });
        return Promise.allSettled(promises);
    }
    async disconnect() {
        const canContinue = await super.disconnect();
        if (!canContinue) {
            return false;
        }
        await this.#removeEventListeners();
        this.server?.disconnect();
        this.status = "notConnected";
        return true;
    }
    #onCharacteristicvaluechanged(event) {
        _console$e.log("oncharacteristicvaluechanged");
        const characteristic = event.target;
        this.#onCharacteristicValueChanged(characteristic);
    }
    #onCharacteristicValueChanged(characteristic) {
        _console$e.log("onCharacteristicValue");
        const characteristicName = characteristic.name;
        _console$e.assertWithError(Boolean(characteristicName), `no name found for characteristic with uuid "${characteristic.uuid}"`);
        _console$e.log(`oncharacteristicvaluechanged for "${characteristicName}" characteristic`);
        const dataView = characteristic.value;
        _console$e.assertWithError(dataView, `no data found for "${characteristicName}" characteristic`);
        _console$e.log(`data for "${characteristicName}" characteristic`, Array.from(new Uint8Array(dataView.buffer)));
        try {
            this.onCharacteristicValueChanged(characteristicName, dataView);
        }
        catch (error) {
            _console$e.error(error);
        }
    }
    async writeCharacteristic(characteristicName, data) {
        super.writeCharacteristic(characteristicName, data);
        const characteristic = this.#characteristics.get(characteristicName);
        _console$e.assertWithError(characteristic, `${characteristicName} characteristic not found`);
        _console$e.log("writing characteristic", characteristic, data);
        const characteristicProperties = characteristic.properties ||
            getCharacteristicProperties(characteristicName);
        if (characteristicProperties.writeWithoutResponse) {
            _console$e.log("writing without response");
            await characteristic.writeValueWithoutResponse(data);
        }
        else {
            _console$e.log("writing with response");
            await characteristic.writeValueWithResponse(data);
        }
        _console$e.log("wrote characteristic");
        if (characteristicProperties.read && !characteristicProperties.notify) {
            _console$e.log("reading value after write...");
            await characteristic.readValue();
            if (isInBluefy || isInWebBLE) {
                this.#onCharacteristicValueChanged(characteristic);
            }
        }
    }
    #onGattserverdisconnected() {
        _console$e.log("gattserverdisconnected");
        this.status = "notConnected";
    }
    get canReconnect() {
        return Boolean(this.server && !this.server.connected && this.isInRange);
    }
    async reconnect() {
        const canContinue = await super.reconnect();
        if (!canContinue) {
            return false;
        }
        try {
            await this.server.connect();
        }
        catch (error) {
            _console$e.error(error);
            this.isInRange = false;
            return false;
        }
        if (this.isConnected) {
            _console$e.log("successfully reconnected!");
            await this.#getServicesAndCharacteristics();
            this.status = "connected";
            return true;
        }
        else {
            _console$e.log("unable to reconnect");
            this.status = "notConnected";
            return false;
        }
    }
    remove() {
        super.remove();
        this.device = undefined;
    }
}

const POW_2_24 = 5.960464477539063e-8;
const POW_2_32 = 4294967296;
const POW_2_53 = 9007199254740992;
function encode(value) {
  let data = new ArrayBuffer(256);
  let dataView = new DataView(data);
  let lastLength;
  let offset = 0;
  function prepareWrite(length) {
    let newByteLength = data.byteLength;
    const requiredLength = offset + length;
    while (newByteLength < requiredLength) {
      newByteLength <<= 1;
    }
    if (newByteLength !== data.byteLength) {
      const oldDataView = dataView;
      data = new ArrayBuffer(newByteLength);
      dataView = new DataView(data);
      const uint32count = (offset + 3) >> 2;
      for (let i = 0; i < uint32count; ++i) {
        dataView.setUint32(i << 2, oldDataView.getUint32(i << 2));
      }
    }
    lastLength = length;
    return dataView;
  }
  function commitWrite() {
    offset += lastLength;
  }
  function writeFloat64(value) {
    commitWrite(prepareWrite(8).setFloat64(offset, value));
  }
  function writeUint8(value) {
    commitWrite(prepareWrite(1).setUint8(offset, value));
  }
  function writeUint8Array(value) {
    const dataView = prepareWrite(value.length);
    for (let i = 0; i < value.length; ++i) {
      dataView.setUint8(offset + i, value[i]);
    }
    commitWrite();
  }
  function writeUint16(value) {
    commitWrite(prepareWrite(2).setUint16(offset, value));
  }
  function writeUint32(value) {
    commitWrite(prepareWrite(4).setUint32(offset, value));
  }
  function writeUint64(value) {
    const low = value % POW_2_32;
    const high = (value - low) / POW_2_32;
    const dataView = prepareWrite(8);
    dataView.setUint32(offset, high);
    dataView.setUint32(offset + 4, low);
    commitWrite();
  }
  function writeTypeAndLength(type, length) {
    if (length < 24) {
      writeUint8((type << 5) | length);
    } else if (length < 0x100) {
      writeUint8((type << 5) | 24);
      writeUint8(length);
    } else if (length < 0x10000) {
      writeUint8((type << 5) | 25);
      writeUint16(length);
    } else if (length < 0x100000000) {
      writeUint8((type << 5) | 26);
      writeUint32(length);
    } else {
      writeUint8((type << 5) | 27);
      writeUint64(length);
    }
  }
  function encodeItem(value) {
    let i;
    const utf8data = [];
    let length;
    if (value === false) {
      return writeUint8(0xf4);
    }
    if (value === true) {
      return writeUint8(0xf5);
    }
    if (value === null) {
      return writeUint8(0xf6);
    }
    if (value === undefined) {
      return writeUint8(0xf7);
    }
    switch (typeof value) {
      case "number":
        if (Math.floor(value) === value) {
          if (value >= 0 && value <= POW_2_53) {
            return writeTypeAndLength(0, value);
          }
          if (-POW_2_53 <= value && value < 0) {
            return writeTypeAndLength(1, -(value + 1));
          }
        }
        writeUint8(0xfb);
        return writeFloat64(value);
      case "string":
        for (i = 0; i < value.length; ++i) {
          let charCode = value.charCodeAt(i);
          if (charCode < 0x80) {
            utf8data.push(charCode);
          } else if (charCode < 0x800) {
            utf8data.push(0xc0 | (charCode >> 6));
            utf8data.push(0x80 | (charCode & 0x3f));
          } else if (charCode < 0xd800) {
            utf8data.push(0xe0 | (charCode >> 12));
            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));
            utf8data.push(0x80 | (charCode & 0x3f));
          } else {
            charCode = (charCode & 0x3ff) << 10;
            charCode |= value.charCodeAt(++i) & 0x3ff;
            charCode += 0x10000;
            utf8data.push(0xf0 | (charCode >> 18));
            utf8data.push(0x80 | ((charCode >> 12) & 0x3f));
            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));
            utf8data.push(0x80 | (charCode & 0x3f));
          }
        }
        writeTypeAndLength(3, utf8data.length);
        return writeUint8Array(utf8data);
      default:
        if (Array.isArray(value)) {
          length = value.length;
          writeTypeAndLength(4, length);
          for (i = 0; i < length; ++i) {
            encodeItem(value[i]);
          }
        } else if (value instanceof Uint8Array) {
          writeTypeAndLength(2, value.length);
          writeUint8Array(value);
        } else {
          const keys = Object.keys(value);
          length = keys.length;
          writeTypeAndLength(5, length);
          for (i = 0; i < length; ++i) {
            const key = keys[i];
            encodeItem(key);
            encodeItem(value[key]);
          }
        }
    }
  }
  encodeItem(value);
  if ("slice" in data) {
    return data.slice(0, offset);
  }
  const ret = new ArrayBuffer(offset);
  const retView = new DataView(ret);
  for (let i = 0; i < offset; ++i) {
    retView.setUint8(i, dataView.getUint8(i));
  }
  return ret;
}
function decode(data, tagger, simpleValue) {
  const dataView = new DataView(data);
  let offset = 0;
  if (typeof tagger !== "function") {
    tagger = function (value) {
      return value;
    };
  }
  if (typeof simpleValue !== "function") {
    simpleValue = function () {
      return undefined;
    };
  }
  function commitRead(length, value) {
    offset += length;
    return value;
  }
  function readArrayBuffer(length) {
    return commitRead(length, new Uint8Array(data, offset, length));
  }
  function readFloat16() {
    const tempArrayBuffer = new ArrayBuffer(4);
    const tempDataView = new DataView(tempArrayBuffer);
    const value = readUint16();
    const sign = value & 0x8000;
    let exponent = value & 0x7c00;
    const fraction = value & 0x03ff;
    if (exponent === 0x7c00) {
      exponent = 0xff << 10;
    } else if (exponent !== 0) {
      exponent += (127 - 15) << 10;
    } else if (fraction !== 0) {
      return (sign ? -1 : 1) * fraction * POW_2_24;
    }
    tempDataView.setUint32(0, (sign << 16) | (exponent << 13) | (fraction << 13));
    return tempDataView.getFloat32(0);
  }
  function readFloat32() {
    return commitRead(4, dataView.getFloat32(offset));
  }
  function readFloat64() {
    return commitRead(8, dataView.getFloat64(offset));
  }
  function readUint8() {
    return commitRead(1, dataView.getUint8(offset));
  }
  function readUint16() {
    return commitRead(2, dataView.getUint16(offset));
  }
  function readUint32() {
    return commitRead(4, dataView.getUint32(offset));
  }
  function readUint64() {
    return readUint32() * POW_2_32 + readUint32();
  }
  function readBreak() {
    if (dataView.getUint8(offset) !== 0xff) {
      return false;
    }
    offset += 1;
    return true;
  }
  function readLength(additionalInformation) {
    if (additionalInformation < 24) {
      return additionalInformation;
    }
    if (additionalInformation === 24) {
      return readUint8();
    }
    if (additionalInformation === 25) {
      return readUint16();
    }
    if (additionalInformation === 26) {
      return readUint32();
    }
    if (additionalInformation === 27) {
      return readUint64();
    }
    if (additionalInformation === 31) {
      return -1;
    }
    throw new Error("Invalid length encoding");
  }
  function readIndefiniteStringLength(majorType) {
    const initialByte = readUint8();
    if (initialByte === 0xff) {
      return -1;
    }
    const length = readLength(initialByte & 0x1f);
    if (length < 0 || initialByte >> 5 !== majorType) {
      throw new Error("Invalid indefinite length element");
    }
    return length;
  }
  function appendUtf16Data(utf16data, length) {
    for (let i = 0; i < length; ++i) {
      let value = readUint8();
      if (value & 0x80) {
        if (value < 0xe0) {
          value = ((value & 0x1f) << 6) | (readUint8() & 0x3f);
          length -= 1;
        } else if (value < 0xf0) {
          value = ((value & 0x0f) << 12) | ((readUint8() & 0x3f) << 6) | (readUint8() & 0x3f);
          length -= 2;
        } else {
          value =
            ((value & 0x0f) << 18) | ((readUint8() & 0x3f) << 12) | ((readUint8() & 0x3f) << 6) | (readUint8() & 0x3f);
          length -= 3;
        }
      }
      if (value < 0x10000) {
        utf16data.push(value);
      } else {
        value -= 0x10000;
        utf16data.push(0xd800 | (value >> 10));
        utf16data.push(0xdc00 | (value & 0x3ff));
      }
    }
  }
  function decodeItem() {
    const initialByte = readUint8();
    const majorType = initialByte >> 5;
    const additionalInformation = initialByte & 0x1f;
    let i;
    let length;
    if (majorType === 7) {
      switch (additionalInformation) {
        case 25:
          return readFloat16();
        case 26:
          return readFloat32();
        case 27:
          return readFloat64();
      }
    }
    length = readLength(additionalInformation);
    if (length < 0 && (majorType < 2 || majorType > 6)) {
      throw new Error("Invalid length");
    }
    const utf16data = [];
    let retArray;
    const retObject = {};
    switch (majorType) {
      case 0:
        return length;
      case 1:
        return -1 - length;
      case 2:
        if (length < 0) {
          const elements = [];
          let fullArrayLength = 0;
          while ((length = readIndefiniteStringLength(majorType)) >= 0) {
            fullArrayLength += length;
            elements.push(readArrayBuffer(length));
          }
          const fullArray = new Uint8Array(fullArrayLength);
          let fullArrayOffset = 0;
          for (i = 0; i < elements.length; ++i) {
            fullArray.set(elements[i], fullArrayOffset);
            fullArrayOffset += elements[i].length;
          }
          return fullArray;
        }
        return readArrayBuffer(length);
      case 3:
        if (length < 0) {
          while ((length = readIndefiniteStringLength(majorType)) >= 0) {
            appendUtf16Data(utf16data, length);
          }
        } else {
          appendUtf16Data(utf16data, length);
        }
        return String.fromCharCode.apply(null, utf16data);
      case 4:
        if (length < 0) {
          retArray = [];
          while (!readBreak()) {
            retArray.push(decodeItem());
          }
        } else {
          retArray = new Array(length);
          for (i = 0; i < length; ++i) {
            retArray[i] = decodeItem();
          }
        }
        return retArray;
      case 5:
        for (i = 0; i < length || (length < 0 && !readBreak()); ++i) {
          const key = decodeItem();
          retObject[key] = decodeItem();
        }
        return retObject;
      case 6:
        return tagger(decodeItem(), length);
      case 7:
        switch (length) {
          case 20:
            return false;
          case 21:
            return true;
          case 22:
            return null;
          case 23:
            return undefined;
          default:
            return simpleValue(length);
        }
    }
  }
  const ret = decodeItem();
  if (offset !== data.byteLength) {
    throw new Error("Remaining bytes");
  }
  return ret;
}
const CBOR = {
  encode,
  decode,
};

const _console$d = createConsole("mcumgr", { log: false });
const constants = {
  MGMT_OP_READ: 0,
  MGMT_OP_READ_RSP: 1,
  MGMT_OP_WRITE: 2,
  MGMT_OP_WRITE_RSP: 3,
  MGMT_GROUP_ID_OS: 0,
  MGMT_GROUP_ID_IMAGE: 1,
  MGMT_GROUP_ID_FS: 8,
  OS_MGMT_ID_ECHO: 0,
  OS_MGMT_ID_TASKSTAT: 2,
  OS_MGMT_ID_MPSTAT: 3,
  OS_MGMT_ID_RESET: 5,
  IMG_MGMT_ID_STATE: 0,
  IMG_MGMT_ID_UPLOAD: 1,
  IMG_MGMT_ID_ERASE: 5,
  FS_MGMT_ID_FILE: 0,
};
class MCUManager {
  constructor() {
    this._mtu = 256;
    this._messageCallback = null;
    this._imageUploadProgressCallback = null;
    this._imageUploadNextCallback = null;
    this._fileUploadProgressCallback = null;
    this._fileUploadNextCallback = null;
    this._uploadIsInProgress = false;
    this._downloadIsInProgress = false;
    this._buffer = new Uint8Array();
    this._seq = 0;
  }
  onMessage(callback) {
    this._messageCallback = callback;
    return this;
  }
  onImageUploadNext(callback) {
    this._imageUploadNextCallback = callback;
    return this;
  }
  onImageUploadProgress(callback) {
    this._imageUploadProgressCallback = callback;
    return this;
  }
  onImageUploadFinished(callback) {
    this._imageUploadFinishedCallback = callback;
    return this;
  }
  onFileUploadNext(callback) {
    this._fileUploadNextCallback = callback;
    return this;
  }
  onFileUploadProgress(callback) {
    this._fileUploadProgressCallback = callback;
    return this;
  }
  onFileUploadFinished(callback) {
    this._fileUploadFinishedCallback = callback;
    return this;
  }
  onFileDownloadNext(callback) {
    this._fileDownloadNextCallback = callback;
    return this;
  }
  onFileDownloadProgress(callback) {
    this._fileDownloadProgressCallback = callback;
    return this;
  }
  onFileDownloadFinished(callback) {
    this._fileDownloadFinishedCallback = callback;
    return this;
  }
  _getMessage(op, group, id, data) {
    const _flags = 0;
    let encodedData = [];
    if (typeof data !== "undefined") {
      encodedData = [...new Uint8Array(CBOR.encode(data))];
    }
    const lengthLo = encodedData.length & 255;
    const lengthHi = encodedData.length >> 8;
    const groupLo = group & 255;
    const groupHi = group >> 8;
    const message = [op, _flags, lengthHi, lengthLo, groupHi, groupLo, this._seq, id, ...encodedData];
    this._seq = (this._seq + 1) % 256;
    return message;
  }
  _notification(buffer) {
    _console$d.log("mcumgr - message received");
    const message = new Uint8Array(buffer);
    this._buffer = new Uint8Array([...this._buffer, ...message]);
    const messageLength = this._buffer[2] * 256 + this._buffer[3];
    if (this._buffer.length < messageLength + 8) return;
    this._processMessage(this._buffer.slice(0, messageLength + 8));
    this._buffer = this._buffer.slice(messageLength + 8);
  }
  _processMessage(message) {
    const [op, , lengthHi, lengthLo, groupHi, groupLo, , id] = message;
    const data = CBOR.decode(message.slice(8).buffer);
    const length = lengthHi * 256 + lengthLo;
    const group = groupHi * 256 + groupLo;
    _console$d.log("mcumgr - Process Message - Group: " + group + ", Id: " + id + ", Off: " + data.off);
    if (group === constants.MGMT_GROUP_ID_IMAGE && id === constants.IMG_MGMT_ID_UPLOAD && data.off) {
      this._uploadOffset = data.off;
      this._uploadNext();
      return;
    }
    if (
      op === constants.MGMT_OP_WRITE_RSP &&
      group === constants.MGMT_GROUP_ID_FS &&
      id === constants.FS_MGMT_ID_FILE &&
      data.off
    ) {
      this._uploadFileOffset = data.off;
      this._uploadFileNext();
      return;
    }
    if (op === constants.MGMT_OP_READ_RSP && group === constants.MGMT_GROUP_ID_FS && id === constants.FS_MGMT_ID_FILE) {
      this._downloadFileOffset += data.data.length;
      if (data.len != undefined) {
        this._downloadFileLength = data.len;
      }
      _console$d.log("downloaded " + this._downloadFileOffset + " bytes of " + this._downloadFileLength);
      if (this._downloadFileLength > 0) {
        this._fileDownloadProgressCallback({
          percentage: Math.floor((this._downloadFileOffset / this._downloadFileLength) * 100),
        });
      }
      if (this._messageCallback) this._messageCallback({ op, group, id, data, length });
      this._downloadFileNext();
      return;
    }
    if (this._messageCallback) this._messageCallback({ op, group, id, data, length });
  }
  cmdReset() {
    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_OS, constants.OS_MGMT_ID_RESET);
  }
  smpEcho(message) {
    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_OS, constants.OS_MGMT_ID_ECHO, {
      d: message,
    });
  }
  cmdImageState() {
    return this._getMessage(constants.MGMT_OP_READ, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE);
  }
  cmdImageErase() {
    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_ERASE, {});
  }
  cmdImageTest(hash) {
    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE, {
      hash,
      confirm: false,
    });
  }
  cmdImageConfirm(hash) {
    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE, {
      hash,
      confirm: true,
    });
  }
  _hash(image) {
    return crypto.subtle.digest("SHA-256", image);
  }
  async _uploadNext() {
    if (!this._uploadImage) {
      return;
    }
    if (this._uploadOffset >= this._uploadImage.byteLength) {
      this._uploadIsInProgress = false;
      this._imageUploadFinishedCallback();
      return;
    }
    const nmpOverhead = 8;
    const message = { data: new Uint8Array(), off: this._uploadOffset };
    if (this._uploadOffset === 0) {
      message.len = this._uploadImage.byteLength;
      message.sha = new Uint8Array(await this._hash(this._uploadImage));
    }
    this._imageUploadProgressCallback({
      percentage: Math.floor((this._uploadOffset / this._uploadImage.byteLength) * 100),
    });
    const length = this._mtu - CBOR.encode(message).byteLength - nmpOverhead - 3 - 5;
    message.data = new Uint8Array(this._uploadImage.slice(this._uploadOffset, this._uploadOffset + length));
    this._uploadOffset += length;
    const packet = this._getMessage(
      constants.MGMT_OP_WRITE,
      constants.MGMT_GROUP_ID_IMAGE,
      constants.IMG_MGMT_ID_UPLOAD,
      message
    );
    _console$d.log("mcumgr - _uploadNext: Message Length: " + packet.length);
    this._imageUploadNextCallback({ packet });
  }
  async reset() {
    this._messageCallback = null;
    this._imageUploadProgressCallback = null;
    this._imageUploadNextCallback = null;
    this._fileUploadProgressCallback = null;
    this._fileUploadNextCallback = null;
    this._uploadIsInProgress = false;
    this._downloadIsInProgress = false;
    this._buffer = new Uint8Array();
    this._seq = 0;
  }
  async cmdUpload(image, slot = 0) {
    if (this._uploadIsInProgress) {
      _console$d.error("Upload is already in progress.");
      return;
    }
    this._uploadIsInProgress = true;
    this._uploadOffset = 0;
    this._uploadImage = image;
    this._uploadSlot = slot;
    this._uploadNext();
  }
  async cmdUploadFile(filebuf, destFilename) {
    if (this._uploadIsInProgress) {
      _console$d.error("Upload is already in progress.");
      return;
    }
    this._uploadIsInProgress = true;
    this._uploadFileOffset = 0;
    this._uploadFile = filebuf;
    this._uploadFilename = destFilename;
    this._uploadFileNext();
  }
  async _uploadFileNext() {
    _console$d.log("uploadFileNext - offset: " + this._uploadFileOffset + ", length: " + this._uploadFile.byteLength);
    if (this._uploadFileOffset >= this._uploadFile.byteLength) {
      this._uploadIsInProgress = false;
      this._fileUploadFinishedCallback();
      return;
    }
    const nmpOverhead = 8;
    const message = { data: new Uint8Array(), off: this._uploadFileOffset };
    if (this._uploadFileOffset === 0) {
      message.len = this._uploadFile.byteLength;
    }
    message.name = this._uploadFilename;
    this._fileUploadProgressCallback({
      percentage: Math.floor((this._uploadFileOffset / this._uploadFile.byteLength) * 100),
    });
    const length = this._mtu - CBOR.encode(message).byteLength - nmpOverhead;
    message.data = new Uint8Array(this._uploadFile.slice(this._uploadFileOffset, this._uploadFileOffset + length));
    this._uploadFileOffset += length;
    const packet = this._getMessage(
      constants.MGMT_OP_WRITE,
      constants.MGMT_GROUP_ID_FS,
      constants.FS_MGMT_ID_FILE,
      message
    );
    _console$d.log("mcumgr - _uploadNext: Message Length: " + packet.length);
    this._fileUploadNextCallback({ packet });
  }
  async cmdDownloadFile(filename, destFilename) {
    if (this._downloadIsInProgress) {
      _console$d.error("Download is already in progress.");
      return;
    }
    this._downloadIsInProgress = true;
    this._downloadFileOffset = 0;
    this._downloadFileLength = 0;
    this._downloadRemoteFilename = filename;
    this._downloadLocalFilename = destFilename;
    this._downloadFileNext();
  }
  async _downloadFileNext() {
    if (this._downloadFileLength > 0) {
      if (this._downloadFileOffset >= this._downloadFileLength) {
        this._downloadIsInProgress = false;
        this._fileDownloadFinishedCallback();
        return;
      }
    }
    const message = { off: this._downloadFileOffset };
    if (this._downloadFileOffset === 0) {
      message.name = this._downloadRemoteFilename;
    }
    const packet = this._getMessage(
      constants.MGMT_OP_READ,
      constants.MGMT_GROUP_ID_FS,
      constants.FS_MGMT_ID_FILE,
      message
    );
    _console$d.log("mcumgr - _downloadNext: Message Length: " + packet.length);
    this._fileDownloadNextCallback({ packet });
  }
  async imageInfo(image) {
    const info = {};
    const view = new Uint8Array(image);
    if (view.length < 32) {
      throw new Error("Invalid image (too short file)");
    }
    if (view[0] !== 0x3d || view[1] !== 0xb8 || view[2] !== 0xf3 || view[3] !== 0x96) {
      throw new Error("Invalid image (wrong magic bytes)");
    }
    if (view[4] !== 0x00 || view[5] !== 0x00 || view[6] !== 0x00 || view[7] !== 0x00) {
      throw new Error("Invalid image (wrong load address)");
    }
    const headerSize = view[8] + view[9] * 2 ** 8;
    if (view[10] !== 0x00 || view[11] !== 0x00) {
      throw new Error("Invalid image (wrong protected TLV area size)");
    }
    const imageSize = view[12] + view[13] * 2 ** 8 + view[14] * 2 ** 16 + view[15] * 2 ** 24;
    info.imageSize = imageSize;
    if (view.length < imageSize + headerSize) {
      throw new Error("Invalid image (wrong image size)");
    }
    if (view[16] !== 0x00 || view[17] !== 0x00 || view[18] !== 0x00 || view[19] !== 0x00) {
      throw new Error("Invalid image (wrong flags)");
    }
    const version = `${view[20]}.${view[21]}.${view[22] + view[23] * 2 ** 8}`;
    info.version = version;
    info.hash = [...new Uint8Array(await this._hash(image.slice(0, imageSize + 32)))]
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
    return info;
  }
}

const _console$c = createConsole("FirmwareManager", { log: false });
const FirmwareMessageTypes = ["smp"];
const FirmwareEventTypes = [
    ...FirmwareMessageTypes,
    "firmwareImages",
    "firmwareUploadProgress",
    "firmwareStatus",
    "firmwareUploadComplete",
];
const FirmwareStatuses = ["idle", "uploading", "uploaded", "pending", "testing", "erasing"];
class FirmwareManager {
    sendMessage;
    constructor() {
        this.#assignMcuManagerCallbacks();
        autoBind(this);
    }
    eventDispatcher;
    get addEventListenter() {
        return this.eventDispatcher.addEventListener;
    }
    get #dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    get removeEventListener() {
        return this.eventDispatcher.removeEventListener;
    }
    get waitForEvent() {
        return this.eventDispatcher.waitForEvent;
    }
    parseMessage(messageType, dataView) {
        _console$c.log({ messageType });
        switch (messageType) {
            case "smp":
                this.#mcuManager._notification(Array.from(new Uint8Array(dataView.buffer)));
                this.#dispatchEvent("smp", { dataView });
                break;
            default:
                throw Error(`uncaught messageType ${messageType}`);
        }
    }
    async uploadFirmware(file) {
        _console$c.log("uploadFirmware", file);
        const promise = this.waitForEvent("firmwareUploadComplete");
        await this.getImages();
        const arrayBuffer = await getFileBuffer(file);
        const imageInfo = await this.#mcuManager.imageInfo(arrayBuffer);
        _console$c.log({ imageInfo });
        this.#mcuManager.cmdUpload(arrayBuffer, 1);
        this.#updateStatus("uploading");
        await promise;
    }
    #status = "idle";
    get status() {
        return this.#status;
    }
    #updateStatus(newStatus) {
        _console$c.assertEnumWithError(newStatus, FirmwareStatuses);
        if (this.#status == newStatus) {
            _console$c.log(`redundant firmwareStatus assignment "${newStatus}"`);
            return;
        }
        this.#status = newStatus;
        _console$c.log({ firmwareStatus: this.#status });
        this.#dispatchEvent("firmwareStatus", { firmwareStatus: this.#status });
    }
    #images;
    get images() {
        return this.#images;
    }
    #assertImages() {
        _console$c.assertWithError(this.#images, "didn't get imageState");
    }
    #assertValidImageIndex(imageIndex) {
        _console$c.assertTypeWithError(imageIndex, "number");
        _console$c.assertWithError(imageIndex == 0 || imageIndex == 1, "imageIndex must be 0 or 1");
    }
    async getImages() {
        const promise = this.waitForEvent("firmwareImages");
        _console$c.log("getting firmware image state...");
        this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageState()).buffer);
        await promise;
    }
    async testImage(imageIndex = 1) {
        this.#assertValidImageIndex(imageIndex);
        this.#assertImages();
        if (!this.#images[imageIndex]) {
            _console$c.log(`image ${imageIndex} not found`);
            return;
        }
        if (this.#images[imageIndex].pending == true) {
            _console$c.log(`image ${imageIndex} is already pending`);
            return;
        }
        if (this.#images[imageIndex].empty) {
            _console$c.log(`image ${imageIndex} is empty`);
            return;
        }
        const promise = this.waitForEvent("smp");
        _console$c.log("testing firmware image...");
        this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageTest(this.#images[imageIndex].hash)).buffer);
        await promise;
    }
    async eraseImage() {
        this.#assertImages();
        const promise = this.waitForEvent("smp");
        _console$c.log("erasing image...");
        this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageErase()).buffer);
        this.#updateStatus("erasing");
        await promise;
        await this.getImages();
    }
    async confirmImage(imageIndex = 0) {
        this.#assertValidImageIndex(imageIndex);
        this.#assertImages();
        if (this.#images[imageIndex].confirmed === true) {
            _console$c.log(`image ${imageIndex} is already confirmed`);
            return;
        }
        const promise = this.waitForEvent("smp");
        _console$c.log("confirming image...");
        this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageConfirm(this.#images[imageIndex].hash)).buffer);
        await promise;
    }
    async echo(string) {
        _console$c.assertTypeWithError(string, "string");
        const promise = this.waitForEvent("smp");
        _console$c.log("sending echo...");
        this.sendMessage(Uint8Array.from(this.#mcuManager.smpEcho(string)).buffer);
        await promise;
    }
    async reset() {
        const promise = this.waitForEvent("smp");
        _console$c.log("resetting...");
        this.sendMessage(Uint8Array.from(this.#mcuManager.cmdReset()).buffer);
        await promise;
    }
    #mtu;
    get mtu() {
        return this.#mtu;
    }
    set mtu(newMtu) {
        this.#mtu = newMtu;
        this.#mcuManager._mtu = newMtu;
    }
    #mcuManager = new MCUManager();
    #assignMcuManagerCallbacks() {
        this.#mcuManager.onMessage(this.#onMcuMessage.bind(this));
        this.#mcuManager.onFileDownloadNext(this.#onMcuFileDownloadNext);
        this.#mcuManager.onFileDownloadProgress(this.#onMcuFileDownloadProgress.bind(this));
        this.#mcuManager.onFileDownloadFinished(this.#onMcuFileDownloadFinished.bind(this));
        this.#mcuManager.onFileUploadNext(this.#onMcuFileUploadNext.bind(this));
        this.#mcuManager.onFileUploadProgress(this.#onMcuFileUploadProgress.bind(this));
        this.#mcuManager.onFileUploadFinished(this.#onMcuFileUploadFinished.bind(this));
        this.#mcuManager.onImageUploadNext(this.#onMcuImageUploadNext.bind(this));
        this.#mcuManager.onImageUploadProgress(this.#onMcuImageUploadProgress.bind(this));
        this.#mcuManager.onImageUploadFinished(this.#onMcuImageUploadFinished.bind(this));
    }
    #onMcuMessage({ op, group, id, data, length }) {
        _console$c.log("onMcuMessage", ...arguments);
        switch (group) {
            case constants.MGMT_GROUP_ID_OS:
                switch (id) {
                    case constants.OS_MGMT_ID_ECHO:
                        _console$c.log(`echo "${data.r}"`);
                        break;
                    case constants.OS_MGMT_ID_TASKSTAT:
                        _console$c.table(data.tasks);
                        break;
                    case constants.OS_MGMT_ID_MPSTAT:
                        _console$c.log(data);
                        break;
                }
                break;
            case constants.MGMT_GROUP_ID_IMAGE:
                switch (id) {
                    case constants.IMG_MGMT_ID_STATE:
                        this.#onMcuImageState(data);
                }
                break;
            default:
                throw Error(`uncaught mcuMessage group ${group}`);
        }
    }
    #onMcuFileDownloadNext() {
        _console$c.log("onMcuFileDownloadNext", ...arguments);
    }
    #onMcuFileDownloadProgress() {
        _console$c.log("onMcuFileDownloadProgress", ...arguments);
    }
    #onMcuFileDownloadFinished() {
        _console$c.log("onMcuFileDownloadFinished", ...arguments);
    }
    #onMcuFileUploadNext() {
        _console$c.log("onMcuFileUploadNext");
    }
    #onMcuFileUploadProgress() {
        _console$c.log("onMcuFileUploadProgress");
    }
    #onMcuFileUploadFinished() {
        _console$c.log("onMcuFileUploadFinished");
    }
    #onMcuImageUploadNext({ packet }) {
        _console$c.log("onMcuImageUploadNext");
        this.sendMessage(Uint8Array.from(packet).buffer);
    }
    #onMcuImageUploadProgress({ percentage }) {
        const progress = percentage / 100;
        _console$c.log("onMcuImageUploadProgress", ...arguments);
        this.#dispatchEvent("firmwareUploadProgress", { progress });
    }
    async #onMcuImageUploadFinished() {
        _console$c.log("onMcuImageUploadFinished", ...arguments);
        await this.getImages();
        this.#dispatchEvent("firmwareUploadProgress", { progress: 100 });
        this.#dispatchEvent("firmwareUploadComplete", {});
    }
    #onMcuImageState({ images }) {
        if (images) {
            this.#images = images;
            _console$c.log("images", this.#images);
        }
        else {
            _console$c.log("no images found");
            return;
        }
        let newStatus = "idle";
        if (this.#images.length == 2) {
            if (!this.#images[1].bootable) {
                _console$c.warn('Slot 1 has a invalid image. Click "Erase Image" to erase it or upload a different image');
            }
            else if (!this.#images[0].confirmed) {
                _console$c.log('Slot 0 has a valid image. Click "Confirm Image" to confirm it or wait and the device will swap images back.');
                newStatus = "testing";
            }
            else {
                if (this.#images[1].pending) {
                    _console$c.log("reset to upload to the new firmware image");
                    newStatus = "pending";
                }
                else {
                    _console$c.log("Slot 1 has a valid image. run testImage() to test it or upload a different image.");
                    newStatus = "uploaded";
                }
            }
        }
        if (this.#images.length == 1) {
            this.#images.push({
                slot: 1,
                empty: true,
                version: "Empty",
                pending: false,
                confirmed: false,
                bootable: false,
                active: false,
                permanent: false,
            });
            _console$c.log("Select a firmware upload image to upload to slot 1.");
        }
        this.#updateStatus(newStatus);
        this.#dispatchEvent("firmwareImages", { firmwareImages: this.#images });
    }
}

const _console$b = createConsole("DeviceManager", { log: false });
const DeviceManagerEventTypes = [
    "deviceConnected",
    "deviceDisconnected",
    "deviceIsConnected",
    "availableDevices",
    "connectedDevices",
];
class DeviceManager {
    static shared = new DeviceManager();
    constructor() {
        if (DeviceManager.shared && this != DeviceManager.shared) {
            throw Error("DeviceManager is a singleton - use DeviceManager.shared");
        }
        if (this.CanUseLocalStorage) {
            this.UseLocalStorage = true;
        }
    }
    #boundDeviceEventListeners = {
        getType: this.#onDeviceType.bind(this),
        isConnected: this.#OnDeviceIsConnected.bind(this),
    };
    onDevice(device) {
        addEventListeners(device, this.#boundDeviceEventListeners);
    }
    #onDeviceType(event) {
        if (this.#UseLocalStorage) {
            this.#UpdateLocalStorageConfigurationForDevice(event.target);
        }
    }
    OnDeviceConnectionStatusUpdated(device, connectionStatus) {
        if (connectionStatus == "notConnected" &&
            !device.canReconnect &&
            this.#AvailableDevices.includes(device)) {
            const deviceIndex = this.#AvailableDevices.indexOf(device);
            this.AvailableDevices.splice(deviceIndex, 1);
            this.#DispatchAvailableDevices();
        }
    }
    #ConnectedDevices = [];
    get ConnectedDevices() {
        return this.#ConnectedDevices;
    }
    #UseLocalStorage = false;
    get UseLocalStorage() {
        return this.#UseLocalStorage;
    }
    set UseLocalStorage(newUseLocalStorage) {
        this.#AssertLocalStorage();
        _console$b.assertTypeWithError(newUseLocalStorage, "boolean");
        this.#UseLocalStorage = newUseLocalStorage;
        if (this.#UseLocalStorage && !this.#LocalStorageConfiguration) {
            this.#LoadFromLocalStorage();
        }
    }
    #DefaultLocalStorageConfiguration = {
        devices: [],
    };
    #LocalStorageConfiguration;
    get CanUseLocalStorage() {
        return isInBrowser && window.localStorage;
    }
    #AssertLocalStorage() {
        _console$b.assertWithError(isInBrowser, "localStorage is only available in the browser");
        _console$b.assertWithError(window.localStorage, "localStorage not found");
    }
    #LocalStorageKey = "BS.Device";
    #SaveToLocalStorage() {
        this.#AssertLocalStorage();
        localStorage.setItem(this.#LocalStorageKey, JSON.stringify(this.#LocalStorageConfiguration));
    }
    async #LoadFromLocalStorage() {
        this.#AssertLocalStorage();
        let localStorageString = localStorage.getItem(this.#LocalStorageKey);
        if (typeof localStorageString != "string") {
            _console$b.log("no info found in localStorage");
            this.#LocalStorageConfiguration = Object.assign({}, this.#DefaultLocalStorageConfiguration);
            this.#SaveToLocalStorage();
            return;
        }
        try {
            const configuration = JSON.parse(localStorageString);
            _console$b.log({ configuration });
            this.#LocalStorageConfiguration = configuration;
            if (this.CanGetDevices) {
                await this.GetDevices();
            }
        }
        catch (error) {
            _console$b.error(error);
        }
    }
    #UpdateLocalStorageConfigurationForDevice(device) {
        if (device.connectionType != "webBluetooth") {
            _console$b.log("localStorage is only for webBluetooth devices");
            return;
        }
        this.#AssertLocalStorage();
        const deviceInformationIndex = this.#LocalStorageConfiguration.devices.findIndex((deviceInformation) => {
            return deviceInformation.bluetoothId == device.bluetoothId;
        });
        if (deviceInformationIndex == -1) {
            return;
        }
        this.#LocalStorageConfiguration.devices[deviceInformationIndex].type =
            device.type;
        this.#SaveToLocalStorage();
    }
    #AvailableDevices = [];
    get AvailableDevices() {
        return this.#AvailableDevices;
    }
    get CanGetDevices() {
        return isInBrowser && navigator.bluetooth?.getDevices;
    }
    async GetDevices() {
        if (!isInBrowser) {
            _console$b.warn("GetDevices is only available in the browser");
            return;
        }
        if (!navigator.bluetooth) {
            _console$b.warn("bluetooth is not available in this browser");
            return;
        }
        if (isInBluefy) {
            _console$b.warn("bluefy lists too many devices...");
            return;
        }
        if (!navigator.bluetooth.getDevices) {
            _console$b.warn("bluetooth.getDevices() is not available in this browser");
            return;
        }
        if (!this.CanGetDevices) {
            _console$b.log("CanGetDevices is false");
            return;
        }
        if (!this.#LocalStorageConfiguration) {
            this.#LoadFromLocalStorage();
        }
        const configuration = this.#LocalStorageConfiguration;
        if (!configuration.devices || configuration.devices.length == 0) {
            _console$b.log("no devices found in configuration");
            return;
        }
        const bluetoothDevices = await navigator.bluetooth.getDevices();
        _console$b.log({ bluetoothDevices });
        bluetoothDevices.forEach((bluetoothDevice) => {
            if (!bluetoothDevice.gatt) {
                return;
            }
            let deviceInformation = configuration.devices.find((deviceInformation) => bluetoothDevice.id == deviceInformation.bluetoothId);
            if (!deviceInformation) {
                return;
            }
            let existingConnectedDevice = this.ConnectedDevices.filter((device) => device.connectionType == "webBluetooth").find((device) => device.bluetoothId == bluetoothDevice.id);
            const existingAvailableDevice = this.AvailableDevices.filter((device) => device.connectionType == "webBluetooth").find((device) => device.bluetoothId == bluetoothDevice.id);
            if (existingAvailableDevice) {
                if (existingConnectedDevice &&
                    existingConnectedDevice?.bluetoothId ==
                        existingAvailableDevice.bluetoothId &&
                    existingConnectedDevice != existingAvailableDevice) {
                    this.AvailableDevices[this.#AvailableDevices.indexOf(existingAvailableDevice)] = existingConnectedDevice;
                }
                return;
            }
            if (existingConnectedDevice) {
                this.AvailableDevices.push(existingConnectedDevice);
                return;
            }
            const device = new Device();
            const connectionManager = new WebBluetoothConnectionManager();
            connectionManager.device = bluetoothDevice;
            if (bluetoothDevice.name) {
                device._informationManager.updateName(bluetoothDevice.name);
            }
            device._informationManager.updateType(deviceInformation.type);
            device.connectionManager = connectionManager;
            this.AvailableDevices.push(device);
        });
        this.#DispatchAvailableDevices();
        return this.AvailableDevices;
    }
    #EventDispatcher = new EventDispatcher(this, DeviceManagerEventTypes);
    get AddEventListener() {
        return this.#EventDispatcher.addEventListener;
    }
    get #DispatchEvent() {
        return this.#EventDispatcher.dispatchEvent;
    }
    get RemoveEventListener() {
        return this.#EventDispatcher.removeEventListener;
    }
    get RemoveEventListeners() {
        return this.#EventDispatcher.removeEventListeners;
    }
    get RemoveAllEventListeners() {
        return this.#EventDispatcher.removeAllEventListeners;
    }
    #OnDeviceIsConnected(event) {
        const { target: device } = event;
        if (device.isConnected) {
            if (!this.#ConnectedDevices.includes(device)) {
                _console$b.log("adding device", device);
                this.#ConnectedDevices.push(device);
                if (this.UseLocalStorage && device.connectionType == "webBluetooth") {
                    const deviceInformation = {
                        type: device.type,
                        bluetoothId: device.bluetoothId,
                        ipAddress: device.ipAddress,
                        isWifiSecure: device.isWifiSecure,
                    };
                    const deviceInformationIndex = this.#LocalStorageConfiguration.devices.findIndex((_deviceInformation) => _deviceInformation.bluetoothId == deviceInformation.bluetoothId);
                    if (deviceInformationIndex == -1) {
                        this.#LocalStorageConfiguration.devices.push(deviceInformation);
                    }
                    else {
                        this.#LocalStorageConfiguration.devices[deviceInformationIndex] =
                            deviceInformation;
                    }
                    this.#SaveToLocalStorage();
                }
                this.#DispatchEvent("deviceConnected", { device });
                this.#DispatchEvent("deviceIsConnected", { device });
                this.#DispatchConnectedDevices();
            }
            else {
                _console$b.log("device already included");
            }
        }
        else {
            if (this.#ConnectedDevices.includes(device)) {
                _console$b.log("removing device", device);
                this.#ConnectedDevices.splice(this.#ConnectedDevices.indexOf(device), 1);
                this.#DispatchEvent("deviceDisconnected", { device });
                this.#DispatchEvent("deviceIsConnected", { device });
                this.#DispatchConnectedDevices();
            }
            else {
                _console$b.log("device already not included");
            }
        }
        if (this.CanGetDevices) {
            this.GetDevices();
        }
        if (device.isConnected && !this.AvailableDevices.includes(device)) {
            const existingAvailableDevice = this.AvailableDevices.find((_device) => _device.bluetoothId == device.bluetoothId);
            _console$b.log({ existingAvailableDevice });
            if (existingAvailableDevice) {
                this.AvailableDevices[this.AvailableDevices.indexOf(existingAvailableDevice)] = device;
            }
            else {
                this.AvailableDevices.push(device);
            }
            this.#DispatchAvailableDevices();
        }
        this._CheckDeviceAvailability(device);
    }
    _CheckDeviceAvailability(device) {
        if (!device.isConnected &&
            !device.isAvailable &&
            this.#AvailableDevices.includes(device)) {
            _console$b.log("removing device from availableDevices...");
            this.#AvailableDevices.splice(this.#AvailableDevices.indexOf(device), 1);
            this.#DispatchAvailableDevices();
        }
    }
    #DispatchAvailableDevices() {
        _console$b.log({ AvailableDevices: this.AvailableDevices });
        this.#DispatchEvent("availableDevices", {
            availableDevices: this.AvailableDevices,
        });
    }
    #DispatchConnectedDevices() {
        _console$b.log({ ConnectedDevices: this.ConnectedDevices });
        this.#DispatchEvent("connectedDevices", {
            connectedDevices: this.ConnectedDevices,
        });
    }
}
var DeviceManager$1 = DeviceManager.shared;

const _console$a = createConsole("ServerUtils", { log: false });
const ServerMessageTypes = [
    "isScanningAvailable",
    "isScanning",
    "startScan",
    "stopScan",
    "discoveredDevice",
    "discoveredDevices",
    "expiredDiscoveredDevice",
    "connectToDevice",
    "disconnectFromDevice",
    "connectedDevices",
    "deviceMessage",
    "requiredDeviceInformation",
];
function createMessage(enumeration, ...messages) {
    _console$a.log("createMessage", ...messages);
    const messageBuffers = messages.map((message) => {
        if (typeof message == "string") {
            message = { type: message };
        }
        if (message.data != undefined) {
            if (!Array.isArray(message.data)) {
                message.data = [message.data];
            }
        }
        else {
            message.data = [];
        }
        const messageDataArrayBuffer = concatenateArrayBuffers(...message.data);
        const messageDataArrayBufferByteLength = messageDataArrayBuffer.byteLength;
        _console$a.assertEnumWithError(message.type, enumeration);
        const messageTypeEnum = enumeration.indexOf(message.type);
        const messageDataLengthDataView = new DataView(new ArrayBuffer(2));
        messageDataLengthDataView.setUint16(0, messageDataArrayBufferByteLength, true);
        return concatenateArrayBuffers(messageTypeEnum, messageDataLengthDataView, messageDataArrayBuffer);
    });
    _console$a.log("messageBuffers", ...messageBuffers);
    return concatenateArrayBuffers(...messageBuffers);
}
function createServerMessage(...messages) {
    _console$a.log("createServerMessage", ...messages);
    return createMessage(ServerMessageTypes, ...messages);
}
function createClientDeviceMessage(...messages) {
    _console$a.log("createClientDeviceMessage", ...messages);
    return createMessage(ConnectionMessageTypes, ...messages);
}
createServerMessage("isScanningAvailable");
createServerMessage("isScanning");
createServerMessage("startScan");
createServerMessage("stopScan");
createServerMessage("discoveredDevices");

const _console$9 = createConsole("WebSocketUtils", { log: false });
const webSocketPingTimeout = 30_000;
const webSocketReconnectTimeout = 3_000;
const WebSocketMessageTypes$1 = ["ping", "pong", "serverMessage"];
function createWebSocketMessage$1(...messages) {
    _console$9.log("createWebSocketMessage", ...messages);
    return createMessage(WebSocketMessageTypes$1, ...messages);
}
createWebSocketMessage$1("ping");
createWebSocketMessage$1("pong");

const _console$8 = createConsole("WebSocketConnectionManager", { log: false });
const WebSocketMessageTypes = [
    "ping",
    "pong",
    "batteryLevel",
    "deviceInformation",
    "message",
];
function createWebSocketMessage(...messages) {
    _console$8.log("createWebSocketMessage", ...messages);
    return createMessage(WebSocketMessageTypes, ...messages);
}
const WebSocketDeviceInformationMessageTypes = [
    "deviceInformation",
    "batteryLevel",
];
class WebSocketConnectionManager extends BaseConnectionManager {
    #bluetoothId;
    get bluetoothId() {
        return this.#bluetoothId ?? "";
    }
    defaultMtu = 2 ** 10;
    constructor(ipAddress, isSecure = false, bluetoothId) {
        super();
        this.ipAddress = ipAddress;
        this.isSecure = isSecure;
        this.mtu = this.defaultMtu;
        this.#bluetoothId = bluetoothId;
    }
    get isAvailable() {
        return true;
    }
    static get isSupported() {
        return true;
    }
    static get type() {
        return "webSocket";
    }
    #webSocket;
    get webSocket() {
        return this.#webSocket;
    }
    set webSocket(newWebSocket) {
        if (this.#webSocket == newWebSocket) {
            _console$8.log("redundant webSocket assignment");
            return;
        }
        _console$8.log("assigning webSocket", newWebSocket);
        if (this.#webSocket) {
            removeEventListeners(this.#webSocket, this.#boundWebSocketEventListeners);
            if (this.#webSocket.readyState == this.#webSocket.OPEN) {
                this.#webSocket.close();
            }
        }
        if (newWebSocket) {
            addEventListeners(newWebSocket, this.#boundWebSocketEventListeners);
        }
        this.#webSocket = newWebSocket;
        _console$8.log("assigned webSocket");
    }
    #ipAddress;
    get ipAddress() {
        return this.#ipAddress;
    }
    set ipAddress(newIpAddress) {
        this.assertIsNotConnected();
        if (this.#ipAddress == newIpAddress) {
            _console$8.log(`redundnant ipAddress assignment "${newIpAddress}"`);
            return;
        }
        this.#ipAddress = newIpAddress;
        _console$8.log(`updated ipAddress to "${this.ipAddress}"`);
    }
    #isSecure = false;
    get isSecure() {
        return this.#isSecure;
    }
    set isSecure(newIsSecure) {
        this.assertIsNotConnected();
        if (this.#isSecure == newIsSecure) {
            _console$8.log(`redundant isSecure assignment ${newIsSecure}`);
            return;
        }
        this.#isSecure = newIsSecure;
        _console$8.log(`updated isSecure to "${this.isSecure}"`);
    }
    get url() {
        return `${this.isSecure ? "wss" : "ws"}://${this.ipAddress}/ws`;
    }
    async connect() {
        const canContinue = await super.connect();
        if (!canContinue) {
            return false;
        }
        try {
            this.webSocket = new WebSocket(this.url);
            return true;
        }
        catch (error) {
            _console$8.error("error connecting to webSocket", error);
            this.status = "notConnected";
            return false;
        }
    }
    async disconnect() {
        const canContinue = await super.disconnect();
        if (!canContinue) {
            return false;
        }
        _console$8.log("closing websocket");
        this.#pingTimer.stop();
        this.#webSocket?.close();
        return true;
    }
    get canReconnect() {
        return Boolean(this.webSocket);
    }
    async reconnect() {
        const canContinue = await super.reconnect();
        if (!canContinue) {
            return false;
        }
        this.webSocket = new WebSocket(this.url);
        return true;
    }
    async sendSmpMessage(data) {
        super.sendSmpMessage(data);
        _console$8.error("smp not supported on webSockets");
    }
    async sendTxData(data) {
        await super.sendTxData(data);
        if (data.byteLength == 0) {
            return;
        }
        this.#sendWebSocketMessage({ type: "message", data });
    }
    #sendMessage(message) {
        this.assertIsConnected();
        _console$8.log("sending webSocket message", message);
        this.#webSocket.send(message);
        this.#pingTimer.restart();
    }
    #sendWebSocketMessage(...messages) {
        this.#sendMessage(createWebSocketMessage(...messages));
    }
    #boundWebSocketEventListeners = {
        open: this.#onWebSocketOpen.bind(this),
        message: this.#onWebSocketMessage.bind(this),
        close: this.#onWebSocketClose.bind(this),
        error: this.#onWebSocketError.bind(this),
    };
    #onWebSocketOpen(event) {
        _console$8.log("webSocket.open", event);
        this.#pingTimer.start();
        this.status = "connected";
        this.#requestDeviceInformation();
    }
    async #onWebSocketMessage(event) {
        const arrayBuffer = await event.data.arrayBuffer();
        const dataView = new DataView(arrayBuffer);
        _console$8.log(`webSocket.message (${dataView.byteLength} bytes)`);
        this.#parseWebSocketMessage(dataView);
    }
    #onWebSocketClose(event) {
        _console$8.log("webSocket.close", event);
        this.status = "notConnected";
        this.#pingTimer.stop();
    }
    #onWebSocketError(event) {
        _console$8.error("webSocket.error", event);
    }
    #parseWebSocketMessage(dataView) {
        parseMessage(dataView, WebSocketMessageTypes, this.#onMessage.bind(this), null, true);
    }
    #onMessage(messageType, dataView) {
        _console$8.log(`received "${messageType}" message (${dataView.byteLength} bytes)`);
        switch (messageType) {
            case "ping":
                this.#pong();
                break;
            case "pong":
                break;
            case "batteryLevel":
                this.onMessageReceived?.("batteryLevel", dataView);
                break;
            case "deviceInformation":
                parseMessage(dataView, DeviceInformationTypes, (deviceInformationType, dataView) => {
                    this.onMessageReceived(deviceInformationType, dataView);
                });
                break;
            case "message":
                this.parseRxMessage(dataView);
                break;
            default:
                _console$8.error(`uncaught messageType "${messageType}"`);
                break;
        }
    }
    #pingTimer = new Timer(this.#ping.bind(this), webSocketPingTimeout - 1_000);
    #ping() {
        _console$8.log("pinging");
        this.#sendWebSocketMessage("ping");
    }
    #pong() {
        _console$8.log("ponging");
        this.#sendWebSocketMessage("pong");
    }
    #requestDeviceInformation() {
        this.#sendWebSocketMessage(...WebSocketDeviceInformationMessageTypes);
    }
    remove() {
        super.remove();
        this.webSocket = undefined;
    }
}

var _a$1;
const _console$7 = createConsole("Device", { log: false });
const DeviceEventTypes = [
    "connectionMessage",
    ...ConnectionEventTypes,
    ...MetaConnectionMessageTypes,
    ...BatteryLevelMessageTypes,
    ...InformationEventTypes,
    ...DeviceInformationEventTypes,
    ...SensorConfigurationEventTypes,
    ...SensorDataEventTypes,
    ...VibrationEventTypes,
    ...FileTransferEventTypes,
    ...TfliteEventTypes,
    ...WifiEventTypes,
    ...CameraEventTypes,
    ...MicrophoneEventTypes,
    ...DisplayEventTypes,
    ...FirmwareEventTypes,
];
const RequiredInformationConnectionMessages = [
    "isCharging",
    "getBatteryCurrent",
    "getId",
    "getMtu",
    "getName",
    "getType",
    "getCurrentTime",
    "getSensorConfiguration",
    "getSensorScalars",
    "getVibrationLocations",
    "getFileTypes",
    "isWifiAvailable",
];
class Device {
    get bluetoothId() {
        return this.#connectionManager?.bluetoothId;
    }
    get isAvailable() {
        return this.#connectionManager?.isAvailable;
    }
    constructor() {
        this.#deviceInformationManager.eventDispatcher = this
            .#eventDispatcher;
        this._informationManager.sendMessage = this
            .sendTxMessages;
        this._informationManager.eventDispatcher = this
            .#eventDispatcher;
        this.#sensorConfigurationManager.sendMessage = this
            .sendTxMessages;
        this.#sensorConfigurationManager.eventDispatcher = this
            .#eventDispatcher;
        this.#sensorDataManager.eventDispatcher = this
            .#eventDispatcher;
        this.#vibrationManager.sendMessage = this
            .sendTxMessages;
        this.#vibrationManager.eventDispatcher = this
            .#eventDispatcher;
        this.#tfliteManager.sendMessage = this
            .sendTxMessages;
        this.#tfliteManager.eventDispatcher = this
            .#eventDispatcher;
        this.#fileTransferManager.sendMessage = this
            .sendTxMessages;
        this.#fileTransferManager.eventDispatcher = this
            .#eventDispatcher;
        this.#wifiManager.sendMessage = this
            .sendTxMessages;
        this.#wifiManager.eventDispatcher = this
            .#eventDispatcher;
        this.#cameraManager.sendMessage = this
            .sendTxMessages;
        this.#cameraManager.eventDispatcher = this
            .#eventDispatcher;
        this.#microphoneManager.sendMessage = this
            .sendTxMessages;
        this.#microphoneManager.eventDispatcher = this
            .#eventDispatcher;
        this.#displayManager.sendMessage = this
            .sendTxMessages;
        this.#displayManager.eventDispatcher = this
            .#eventDispatcher;
        this.#displayManager.sendFile = this.#fileTransferManager
            .send;
        this.#firmwareManager.sendMessage = this
            .sendSmpMessage;
        this.#firmwareManager.eventDispatcher = this
            .#eventDispatcher;
        this.addEventListener("getMtu", () => {
            _console$7.log("updating mtu...");
            this.#firmwareManager.mtu = this.mtu;
            this.#fileTransferManager.mtu = this.mtu;
            this.connectionManager.mtu = this.mtu;
            this.#displayManager.mtu = this.mtu;
        });
        this.addEventListener("getSensorConfiguration", () => {
            if (this.connectionStatus != "connecting") {
                return;
            }
            if (this.sensorTypes.includes("pressure")) {
                _console$7.log("requesting required pressure information");
                const messages = RequiredPressureMessageTypes.map((messageType) => ({
                    type: messageType,
                }));
                this.sendTxMessages(messages, false);
            }
            else {
                _console$7.log("don't need to request pressure infomration");
            }
            if (this.sensorTypes.includes("camera")) {
                _console$7.log("requesting required camera information");
                const messages = RequiredCameraMessageTypes.map((messageType) => ({
                    type: messageType,
                }));
                this.sendTxMessages(messages, false);
            }
            else {
                _console$7.log("don't need to request camera infomration");
            }
            if (this.sensorTypes.includes("microphone")) {
                _console$7.log("requesting required microphone information");
                const messages = RequiredMicrophoneMessageTypes.map((messageType) => ({
                    type: messageType,
                }));
                this.sendTxMessages(messages, false);
            }
            else {
                _console$7.log("don't need to request microphone infomration");
            }
        });
        this.addEventListener("getFileTypes", () => {
            if (this.connectionStatus != "connecting") {
                return;
            }
            if (this.fileTypes.length > 0) {
                this.#fileTransferManager.requestRequiredInformation();
            }
            if (this.fileTypes.includes("tflite")) {
                this.#tfliteManager.requestRequiredInformation();
            }
        });
        this.addEventListener("isWifiAvailable", () => {
            if (this.connectionStatus != "connecting") {
                return;
            }
            if (this.connectionType == "client" && !isInNode) {
                return;
            }
            if (this.isWifiAvailable) {
                if (this.connectionType != "client") {
                    this.#wifiManager.requestRequiredInformation();
                }
            }
        });
        this.addEventListener("getType", () => {
            if (this.connectionStatus != "connecting") {
                return;
            }
            if (this.type == "glasses") {
                this.#displayManager.requestRequiredInformation();
            }
        });
        this.addEventListener("fileTransferProgress", (event) => {
            const { fileType, progress } = event.message;
            switch (fileType) {
                case "spriteSheet":
                    this.#dispatchEvent("displaySpriteSheetUploadProgress", {
                        spriteSheet: this.#displayManager.pendingSpriteSheet,
                        spriteSheetName: this.#displayManager.pendingSpriteSheetName,
                        progress,
                    });
                    break;
            }
        });
        this.addEventListener("fileTransferStatus", (event) => {
            const { fileType, fileTransferStatus } = event.message;
            switch (fileType) {
                case "spriteSheet":
                    if (fileTransferStatus == "sending") {
                        this.#dispatchEvent("displaySpriteSheetUploadStart", {
                            spriteSheet: this.#displayManager.pendingSpriteSheet,
                            spriteSheetName: this.#displayManager.pendingSpriteSheetName,
                        });
                    }
                    break;
            }
        });
        DeviceManager$1.onDevice(this);
        if (isInBrowser) {
            window.addEventListener("beforeunload", () => {
                if (this.isConnected && this.clearSensorConfigurationOnLeave) {
                    this.clearSensorConfiguration();
                }
            });
        }
        if (isInNode) {
            process.on("exit", () => {
                if (this.isConnected && this.clearSensorConfigurationOnLeave) {
                    this.clearSensorConfiguration();
                }
            });
        }
    }
    static #DefaultConnectionManager() {
        return new WebBluetoothConnectionManager();
    }
    #eventDispatcher = new EventDispatcher(this, DeviceEventTypes);
    get addEventListener() {
        return this.#eventDispatcher.addEventListener;
    }
    get #dispatchEvent() {
        return this.#eventDispatcher.dispatchEvent;
    }
    get removeEventListener() {
        return this.#eventDispatcher.removeEventListener;
    }
    get waitForEvent() {
        return this.#eventDispatcher.waitForEvent;
    }
    get removeEventListeners() {
        return this.#eventDispatcher.removeEventListeners;
    }
    get removeAllEventListeners() {
        return this.#eventDispatcher.removeAllEventListeners;
    }
    #connectionManager;
    get connectionManager() {
        return this.#connectionManager;
    }
    set connectionManager(newConnectionManager) {
        if (this.connectionManager == newConnectionManager) {
            _console$7.log("same connectionManager is already assigned");
            return;
        }
        if (this.connectionManager) {
            this.connectionManager.remove();
        }
        if (newConnectionManager) {
            newConnectionManager.onStatusUpdated =
                this.#onConnectionStatusUpdated.bind(this);
            newConnectionManager.onMessageReceived =
                this.#onConnectionMessageReceived.bind(this);
            newConnectionManager.onMessagesReceived =
                this.#onConnectionMessagesReceived.bind(this);
        }
        this.#connectionManager = newConnectionManager;
        _console$7.log("assigned new connectionManager", this.#connectionManager);
        this._informationManager.connectionType = this.connectionType;
    }
    async #sendTxMessages(messages, sendImmediately) {
        await this.#connectionManager?.sendTxMessages(messages, sendImmediately);
    }
    sendTxMessages = this.#sendTxMessages.bind(this);
    async connect(options) {
        if (this.isConnected) {
            _console$7.log("already connected");
            return;
        }
        if (this.connectionStatus == "connecting") {
            _console$7.log("already connecting");
            return;
        }
        _console$7.log("connect options", options);
        if (options) {
            switch (options.type) {
                case "webBluetooth":
                    if (this.connectionType != "webBluetooth") {
                        this.connectionManager = new WebBluetoothConnectionManager();
                    }
                    break;
                case "webSocket":
                    {
                        let createConnectionManager = false;
                        if (this.connectionType == "webSocket") {
                            const connectionManager = this
                                .connectionManager;
                            if (connectionManager.ipAddress != options.ipAddress ||
                                connectionManager.isSecure != options.isWifiSecure) {
                                createConnectionManager = true;
                            }
                        }
                        else {
                            createConnectionManager = true;
                        }
                        if (createConnectionManager) {
                            this.connectionManager = new WebSocketConnectionManager(options.ipAddress, options.isWifiSecure, this.bluetoothId);
                        }
                    }
                    break;
                case "udp":
                    {
                        let createConnectionManager = false;
                        if (this.connectionType == "udp") {
                            const connectionManager = this
                                .connectionManager;
                            if (connectionManager.ipAddress != options.ipAddress) {
                                createConnectionManager = true;
                            }
                            this.reconnectOnDisconnection = true;
                        }
                        else {
                            createConnectionManager = true;
                        }
                        if (createConnectionManager) {
                            this.connectionManager = new UDPConnectionManager(options.ipAddress, this.bluetoothId);
                        }
                    }
                    break;
            }
        }
        if (!this.connectionManager) {
            this.connectionManager = _a$1.#DefaultConnectionManager();
        }
        this.#clear();
        if (options?.type == "client") {
            _console$7.assertWithError(this.connectionType == "client", "expected clientConnectionManager");
            const clientConnectionManager = this
                .connectionManager;
            clientConnectionManager.subType = options.subType;
            return clientConnectionManager.connect();
        }
        _console$7.log("connectionManager type", this.connectionManager.type);
        return this.connectionManager.connect();
    }
    #isConnected = false;
    get isConnected() {
        return this.#isConnected;
    }
    #assertIsConnected() {
        _console$7.assertWithError(this.isConnected, "notConnected");
    }
    #didReceiveMessageTypes(messageTypes) {
        return messageTypes.every((messageType) => {
            const hasConnectionMessage = this.latestConnectionMessages.has(messageType);
            if (!hasConnectionMessage) {
                _console$7.log(`didn't receive "${messageType}" message`);
            }
            return hasConnectionMessage;
        });
    }
    get #hasRequiredInformation() {
        let hasRequiredInformation = this.#didReceiveMessageTypes(RequiredInformationConnectionMessages);
        if (hasRequiredInformation && this.sensorTypes.includes("pressure")) {
            hasRequiredInformation = this.#didReceiveMessageTypes(RequiredPressureMessageTypes);
        }
        if (hasRequiredInformation && this.isWifiAvailable) {
            hasRequiredInformation = this.#didReceiveMessageTypes(RequiredWifiMessageTypes);
        }
        if (hasRequiredInformation && this.fileTypes.length > 0) {
            hasRequiredInformation = this.#didReceiveMessageTypes(RequiredFileTransferMessageTypes);
        }
        if (hasRequiredInformation && this.fileTypes.includes("tflite")) {
            hasRequiredInformation = this.#didReceiveMessageTypes(RequiredTfliteMessageTypes);
        }
        if (hasRequiredInformation && this.hasCamera) {
            hasRequiredInformation = this.#didReceiveMessageTypes(RequiredCameraMessageTypes);
        }
        if (hasRequiredInformation && this.hasMicrophone) {
            hasRequiredInformation = this.#didReceiveMessageTypes(RequiredMicrophoneMessageTypes);
        }
        if (hasRequiredInformation && this.isDisplayAvailable) {
            hasRequiredInformation = this.#didReceiveMessageTypes(RequiredDisplayMessageTypes);
        }
        return hasRequiredInformation;
    }
    #requestRequiredInformation() {
        _console$7.log("requesting required information");
        const messages = RequiredInformationConnectionMessages.map((messageType) => ({
            type: messageType,
        }));
        this.#sendTxMessages(messages);
    }
    get canReconnect() {
        return this.connectionManager?.canReconnect;
    }
    #assertCanReconnect() {
        _console$7.assertWithError(this.canReconnect, "cannot reconnect to device");
    }
    async reconnect() {
        if (this.isConnected) {
            _console$7.log("already connected");
            return;
        }
        if (this.connectionStatus == "connecting") {
            _console$7.log("already connecting");
            return;
        }
        if (!this.canReconnect) {
            _console$7.warn("cannot reconnect");
            return false;
        }
        _console$7.log("attempting to reconnect...");
        this.#clear();
        _console$7.log("reconnecting...");
        return this.connectionManager?.reconnect();
    }
    static async Connect() {
        const device = new _a$1();
        await device.connect();
        return device;
    }
    static #ReconnectOnDisconnection = false;
    static get ReconnectOnDisconnection() {
        return this.#ReconnectOnDisconnection;
    }
    static set ReconnectOnDisconnection(newReconnectOnDisconnection) {
        _console$7.assertTypeWithError(newReconnectOnDisconnection, "boolean");
        this.#ReconnectOnDisconnection = newReconnectOnDisconnection;
    }
    #reconnectOnDisconnection = _a$1.ReconnectOnDisconnection;
    get reconnectOnDisconnection() {
        return this.#reconnectOnDisconnection;
    }
    set reconnectOnDisconnection(newReconnectOnDisconnection) {
        _console$7.assertTypeWithError(newReconnectOnDisconnection, "boolean");
        this.#reconnectOnDisconnection = newReconnectOnDisconnection;
    }
    #reconnectIntervalId;
    get connectionType() {
        return this.connectionManager?.type;
    }
    async disconnect() {
        if (!this.isConnected) {
            _console$7.log("already not connected");
            return;
        }
        if (this.connectionStatus == "disconnecting") {
            _console$7.log("already disconnecting");
            return;
        }
        if (this.reconnectOnDisconnection) {
            this.reconnectOnDisconnection = false;
            this.addEventListener("isConnected", () => {
                this.reconnectOnDisconnection = true;
            }, { once: true });
        }
        return this.connectionManager.disconnect();
    }
    toggleConnection() {
        if (this.isConnected) {
            this.disconnect();
        }
        else if (this.canReconnect) {
            try {
                this.reconnect();
            }
            catch (error) {
                _console$7.error("error trying to reconnect", error);
                this.connect();
            }
        }
        else {
            this.connect();
        }
    }
    get connectionStatus() {
        switch (this.#connectionManager?.status) {
            case "connected":
                return this.isConnected ? "connected" : "connecting";
            case "notConnected":
            case "connecting":
            case "disconnecting":
                return this.#connectionManager.status;
            default:
                return "notConnected";
        }
    }
    get isConnectionBusy() {
        return (this.connectionStatus == "connecting" ||
            this.connectionStatus == "disconnecting");
    }
    #onConnectionStatusUpdated(connectionStatus) {
        _console$7.log({ connectionStatus });
        if (connectionStatus == "notConnected") {
            this.#clearConnection();
            if (this.canReconnect && this.reconnectOnDisconnection) {
                _console$7.log("starting reconnect interval...");
                this.#reconnectIntervalId = setInterval(() => {
                    _console$7.log("attempting reconnect...");
                    this.reconnect();
                }, 1000);
            }
        }
        else {
            if (this.#reconnectIntervalId != undefined) {
                _console$7.log("clearing reconnect interval");
                clearInterval(this.#reconnectIntervalId);
                this.#reconnectIntervalId = undefined;
            }
        }
        this.#checkConnection();
        if (connectionStatus == "connected" && !this.#isConnected) {
            if (this.connectionType != "client") {
                this.#requestRequiredInformation();
            }
        }
        DeviceManager$1.OnDeviceConnectionStatusUpdated(this, connectionStatus);
    }
    #dispatchConnectionEvents(includeIsConnected = false) {
        this.#dispatchEvent("connectionStatus", {
            connectionStatus: this.connectionStatus,
        });
        this.#dispatchEvent(this.connectionStatus, {});
        if (includeIsConnected) {
            this.#dispatchEvent("isConnected", { isConnected: this.isConnected });
        }
    }
    #checkConnection() {
        this.#isConnected =
            Boolean(this.connectionManager?.isConnected) &&
                this.#hasRequiredInformation &&
                this._informationManager.isCurrentTimeSet;
        switch (this.connectionStatus) {
            case "connected":
                if (this.#isConnected) {
                    this.#dispatchConnectionEvents(true);
                }
                break;
            case "notConnected":
                this.#dispatchConnectionEvents(true);
                break;
            default:
                this.#dispatchConnectionEvents(false);
                break;
        }
    }
    #clear() {
        this.#clearConnection();
        this._informationManager.clear();
        this.#deviceInformationManager.clear();
        this.#tfliteManager.clear();
        this.#fileTransferManager.clear();
        this.#wifiManager.clear();
        this.#cameraManager.clear();
        this.#microphoneManager.clear();
        this.#sensorConfigurationManager.clear();
        this.#displayManager.reset();
        this.#isServerSide = false;
    }
    #clearConnection() {
        this.connectionManager?.clear();
        this.latestConnectionMessages.clear();
    }
    #onConnectionMessageReceived(messageType, dataView) {
        _console$7.log({ messageType, dataView });
        switch (messageType) {
            case "batteryLevel":
                const batteryLevel = dataView.getUint8(0);
                _console$7.log("received battery level", { batteryLevel });
                this.#updateBatteryLevel(batteryLevel);
                break;
            default:
                if (FileTransferMessageTypes.includes(messageType)) {
                    this.#fileTransferManager.parseMessage(messageType, dataView);
                }
                else if (TfliteMessageTypes.includes(messageType)) {
                    this.#tfliteManager.parseMessage(messageType, dataView);
                }
                else if (SensorDataMessageTypes.includes(messageType)) {
                    this.#sensorDataManager.parseMessage(messageType, dataView);
                }
                else if (FirmwareMessageTypes.includes(messageType)) {
                    this.#firmwareManager.parseMessage(messageType, dataView);
                }
                else if (DeviceInformationTypes.includes(messageType)) {
                    this.#deviceInformationManager.parseMessage(messageType, dataView);
                }
                else if (InformationMessageTypes.includes(messageType)) {
                    this._informationManager.parseMessage(messageType, dataView);
                }
                else if (SensorConfigurationMessageTypes.includes(messageType)) {
                    this.#sensorConfigurationManager.parseMessage(messageType, dataView);
                }
                else if (VibrationMessageTypes.includes(messageType)) {
                    this.#vibrationManager.parseMessage(messageType, dataView);
                }
                else if (WifiMessageTypes.includes(messageType)) {
                    this.#wifiManager.parseMessage(messageType, dataView);
                }
                else if (CameraMessageTypes.includes(messageType)) {
                    this.#cameraManager.parseMessage(messageType, dataView);
                }
                else if (MicrophoneMessageTypes.includes(messageType)) {
                    this.#microphoneManager.parseMessage(messageType, dataView);
                }
                else if (DisplayMessageTypes.includes(messageType)) {
                    this.#displayManager.parseMessage(messageType, dataView);
                }
                else {
                    throw Error(`uncaught messageType ${messageType}`);
                }
        }
        this.latestConnectionMessages.set(messageType, dataView);
        if (messageType.startsWith("set")) {
            this.latestConnectionMessages.set(
            messageType.replace("set", "get"), dataView);
        }
        this.#dispatchEvent("connectionMessage", { messageType, dataView });
    }
    #onConnectionMessagesReceived() {
        if (!this.isConnected && this.#hasRequiredInformation) {
            this.#checkConnection();
        }
        if (this.connectionStatus == "notConnected" ||
            this.connectionStatus == "disconnecting") {
            return;
        }
        this.#sendTxMessages();
    }
    latestConnectionMessages = new Map();
    #deviceInformationManager = new DeviceInformationManager();
    get deviceInformation() {
        return this.#deviceInformationManager.information;
    }
    #batteryLevel = 0;
    get batteryLevel() {
        return this.#batteryLevel;
    }
    #updateBatteryLevel(updatedBatteryLevel) {
        _console$7.assertTypeWithError(updatedBatteryLevel, "number");
        if (this.#batteryLevel == updatedBatteryLevel) {
            _console$7.log(`duplicate batteryLevel assignment ${updatedBatteryLevel}`);
            return;
        }
        this.#batteryLevel = updatedBatteryLevel;
        _console$7.log({ updatedBatteryLevel: this.#batteryLevel });
        this.#dispatchEvent("batteryLevel", { batteryLevel: this.#batteryLevel });
    }
    _informationManager = new InformationManager();
    get id() {
        return this._informationManager.id;
    }
    get isCharging() {
        return this._informationManager.isCharging;
    }
    get batteryCurrent() {
        return this._informationManager.batteryCurrent;
    }
    get getBatteryCurrent() {
        return this._informationManager.getBatteryCurrent;
    }
    get name() {
        return this._informationManager.name;
    }
    get setName() {
        return this._informationManager.setName;
    }
    get type() {
        return this._informationManager.type;
    }
    get setType() {
        return this._informationManager.setType;
    }
    get isInsole() {
        return this._informationManager.isInsole;
    }
    get isGlove() {
        return this._informationManager.isGlove;
    }
    get side() {
        return this._informationManager.side;
    }
    get mtu() {
        return this._informationManager.mtu;
    }
    get sensorTypes() {
        return Object.keys(this.sensorConfiguration);
    }
    get continuousSensorTypes() {
        return ContinuousSensorTypes.filter((sensorType) => this.sensorTypes.includes(sensorType));
    }
    #sensorConfigurationManager = new SensorConfigurationManager();
    get sensorConfiguration() {
        return this.#sensorConfigurationManager.configuration;
    }
    get setSensorConfiguration() {
        return this.#sensorConfigurationManager.setConfiguration;
    }
    async clearSensorConfiguration() {
        return this.#sensorConfigurationManager.clearSensorConfiguration();
    }
    static #ClearSensorConfigurationOnLeave = true;
    static get ClearSensorConfigurationOnLeave() {
        return this.#ClearSensorConfigurationOnLeave;
    }
    static set ClearSensorConfigurationOnLeave(newClearSensorConfigurationOnLeave) {
        _console$7.assertTypeWithError(newClearSensorConfigurationOnLeave, "boolean");
        this.#ClearSensorConfigurationOnLeave = newClearSensorConfigurationOnLeave;
    }
    #clearSensorConfigurationOnLeave = _a$1.ClearSensorConfigurationOnLeave;
    get clearSensorConfigurationOnLeave() {
        return this.#clearSensorConfigurationOnLeave;
    }
    set clearSensorConfigurationOnLeave(newClearSensorConfigurationOnLeave) {
        _console$7.assertTypeWithError(newClearSensorConfigurationOnLeave, "boolean");
        this.#clearSensorConfigurationOnLeave = newClearSensorConfigurationOnLeave;
    }
    get numberOfPressureSensors() {
        return this.#sensorDataManager.pressureSensorDataManager.numberOfSensors;
    }
    #sensorDataManager = new SensorDataManager();
    resetPressureRange() {
        this.#sensorDataManager.pressureSensorDataManager.resetRange();
    }
    get vibrationLocations() {
        return this.#vibrationManager.vibrationLocations;
    }
    #vibrationManager = new VibrationManager();
    async triggerVibration(vibrationConfigurations, sendImmediately) {
        this.#vibrationManager.triggerVibration(vibrationConfigurations, sendImmediately);
    }
    #fileTransferManager = new FileTransferManager();
    get fileTypes() {
        return this.#fileTransferManager.fileTypes;
    }
    get maxFileLength() {
        return this.#fileTransferManager.maxLength;
    }
    get validFileTypes() {
        return FileTypes.filter((fileType) => {
            if (fileType.includes("wifi") && !this.isWifiAvailable) {
                return false;
            }
            return true;
        });
    }
    async sendFile(fileType, file) {
        _console$7.assertWithError(this.validFileTypes.includes(fileType), `invalid fileType ${fileType}`);
        const promise = this.waitForEvent("fileTransferComplete");
        this.#fileTransferManager.send(fileType, file);
        await promise;
    }
    async receiveFile(fileType) {
        const promise = this.waitForEvent("fileTransferComplete");
        this.#fileTransferManager.receive(fileType);
        await promise;
    }
    get fileTransferStatus() {
        return this.#fileTransferManager.status;
    }
    cancelFileTransfer() {
        this.#fileTransferManager.cancel();
    }
    #tfliteManager = new TfliteManager();
    get isTfliteAvailable() {
        return this.fileTypes.includes("tflite");
    }
    get tfliteName() {
        return this.#tfliteManager.name;
    }
    get setTfliteName() {
        return this.#tfliteManager.setName;
    }
    async sendTfliteConfiguration(configuration) {
        configuration.type = "tflite";
        this.#tfliteManager.sendConfiguration(configuration, false);
        const didSendFile = await this.#fileTransferManager.send(configuration.type, configuration.file);
        if (!didSendFile) {
            this.#sendTxMessages();
        }
    }
    get tfliteTask() {
        return this.#tfliteManager.task;
    }
    get setTfliteTask() {
        return this.#tfliteManager.setTask;
    }
    get tfliteSampleRate() {
        return this.#tfliteManager.sampleRate;
    }
    get setTfliteSampleRate() {
        return this.#tfliteManager.setSampleRate;
    }
    get tfliteSensorTypes() {
        return this.#tfliteManager.sensorTypes;
    }
    get allowedTfliteSensorTypes() {
        return this.sensorTypes.filter((sensorType) => TfliteSensorTypes.includes(sensorType));
    }
    get setTfliteSensorTypes() {
        return this.#tfliteManager.setSensorTypes;
    }
    get tfliteIsReady() {
        return this.#tfliteManager.isReady;
    }
    get tfliteInferencingEnabled() {
        return this.#tfliteManager.inferencingEnabled;
    }
    get setTfliteInferencingEnabled() {
        return this.#tfliteManager.setInferencingEnabled;
    }
    async enableTfliteInferencing() {
        return this.setTfliteInferencingEnabled(true);
    }
    async disableTfliteInferencing() {
        return this.setTfliteInferencingEnabled(false);
    }
    get toggleTfliteInferencing() {
        return this.#tfliteManager.toggleInferencingEnabled;
    }
    get tfliteCaptureDelay() {
        return this.#tfliteManager.captureDelay;
    }
    get setTfliteCaptureDelay() {
        return this.#tfliteManager.setCaptureDelay;
    }
    get tfliteThreshold() {
        return this.#tfliteManager.threshold;
    }
    get setTfliteThreshold() {
        return this.#tfliteManager.setThreshold;
    }
    #firmwareManager = new FirmwareManager();
    get canUpdateFirmware() {
        return this.#connectionManager?.canUpdateFirmware;
    }
    #assertCanUpdateFirmware() {
        _console$7.assertWithError(this.canUpdateFirmware, "can't update firmware");
    }
    #sendSmpMessage(data) {
        this.#assertCanUpdateFirmware();
        return this.#connectionManager.sendSmpMessage(data);
    }
    sendSmpMessage = this.#sendSmpMessage.bind(this);
    get uploadFirmware() {
        this.#assertCanUpdateFirmware();
        return this.#firmwareManager.uploadFirmware;
    }
    get canReset() {
        return this.canUpdateFirmware;
    }
    async reset() {
        _console$7.assertWithError(this.canReset, "reset is not enabled for this device");
        await this.#firmwareManager.reset();
        return this.#connectionManager.disconnect();
    }
    get firmwareStatus() {
        return this.#firmwareManager.status;
    }
    get getFirmwareImages() {
        this.#assertCanUpdateFirmware();
        return this.#firmwareManager.getImages;
    }
    get firmwareImages() {
        return this.#firmwareManager.images;
    }
    get eraseFirmwareImage() {
        this.#assertCanUpdateFirmware();
        return this.#firmwareManager.eraseImage;
    }
    get confirmFirmwareImage() {
        this.#assertCanUpdateFirmware();
        return this.#firmwareManager.confirmImage;
    }
    get testFirmwareImage() {
        this.#assertCanUpdateFirmware();
        return this.#firmwareManager.testImage;
    }
    #isServerSide = false;
    get isServerSide() {
        return this.#isServerSide;
    }
    set isServerSide(newIsServerSide) {
        if (this.#isServerSide == newIsServerSide) {
            _console$7.log("redundant isServerSide assignment");
            return;
        }
        _console$7.log({ newIsServerSide });
        this.#isServerSide = newIsServerSide;
        this.#fileTransferManager.isServerSide = this.isServerSide;
        this.#displayManager.isServerSide = this.isServerSide;
    }
    get isUkaton() {
        return this.deviceInformation.modelNumber.includes("Ukaton");
    }
    #wifiManager = new WifiManager();
    get isWifiAvailable() {
        return this.#wifiManager.isWifiAvailable;
    }
    get wifiSSID() {
        return this.#wifiManager.wifiSSID;
    }
    async setWifiSSID(newWifiSSID) {
        return this.#wifiManager.setWifiSSID(newWifiSSID);
    }
    get wifiPassword() {
        return this.#wifiManager.wifiPassword;
    }
    async setWifiPassword(newWifiPassword) {
        return this.#wifiManager.setWifiPassword(newWifiPassword);
    }
    get isWifiConnected() {
        return this.#wifiManager.isWifiConnected;
    }
    get ipAddress() {
        return this.#wifiManager.ipAddress;
    }
    get wifiConnectionEnabled() {
        return this.#wifiManager.wifiConnectionEnabled;
    }
    get enableWifiConnection() {
        return this.#wifiManager.enableWifiConnection;
    }
    get setWifiConnectionEnabled() {
        return this.#wifiManager.setWifiConnectionEnabled;
    }
    get disableWifiConnection() {
        return this.#wifiManager.disableWifiConnection;
    }
    get toggleWifiConnection() {
        return this.#wifiManager.toggleWifiConnection;
    }
    get isWifiSecure() {
        return this.#wifiManager.isWifiSecure;
    }
    async reconnectViaWebSockets() {
        _console$7.assertWithError(this.isWifiConnected, "wifi is not connected");
        _console$7.assertWithError(this.connectionType != "webSocket", "already connected via webSockets");
        _console$7.assertTypeWithError(this.ipAddress, "string");
        _console$7.log("reconnecting via websockets...");
        await this.disconnect();
        await this.connect({
            type: "webSocket",
            ipAddress: this.ipAddress,
            isWifiSecure: this.isWifiSecure,
        });
    }
    async reconnectViaUDP() {
        _console$7.assertWithError(isInNode, "udp is only available in node");
        _console$7.assertWithError(this.isWifiConnected, "wifi is not connected");
        _console$7.assertWithError(this.connectionType != "udp", "already connected via udp");
        _console$7.assertTypeWithError(this.ipAddress, "string");
        _console$7.log("reconnecting via udp...");
        await this.disconnect();
        await this.connect({
            type: "udp",
            ipAddress: this.ipAddress,
        });
    }
    #cameraManager = new CameraManager();
    get hasCamera() {
        return this.sensorTypes.includes("camera");
    }
    get cameraStatus() {
        return this.#cameraManager.cameraStatus;
    }
    #assertHasCamera() {
        _console$7.assertWithError(this.hasCamera, "camera not available");
    }
    async takePicture(sensorRate = 10) {
        this.#assertHasCamera();
        if (this.sensorConfiguration.camera != sensorRate) {
            this.setSensorConfiguration({ camera: sensorRate }, false, false);
        }
        await this.#cameraManager.takePicture();
    }
    async focusCamera(sensorRate = 10) {
        this.#assertHasCamera();
        if (this.sensorConfiguration.camera != sensorRate) {
            this.setSensorConfiguration({ camera: sensorRate }, false, false);
        }
        await this.#cameraManager.focus();
    }
    async stopCamera() {
        this.#assertHasCamera();
        await this.#cameraManager.stop();
    }
    async wakeCamera() {
        this.#assertHasCamera();
        await this.#cameraManager.wake();
    }
    async sleepCamera() {
        this.#assertHasCamera();
        await this.#cameraManager.sleep();
    }
    get cameraConfiguration() {
        return this.#cameraManager.cameraConfiguration;
    }
    get availableCameraConfigurationTypes() {
        return this.#cameraManager.availableCameraConfigurationTypes;
    }
    get cameraConfigurationRanges() {
        return this.#cameraManager.cameraConfigurationRanges;
    }
    get setCameraConfiguration() {
        return this.#cameraManager.setCameraConfiguration;
    }
    #microphoneManager = new MicrophoneManager();
    get hasMicrophone() {
        return this.sensorTypes.includes("microphone");
    }
    get microphoneStatus() {
        return this.#microphoneManager.microphoneStatus;
    }
    #assertHasMicrophone() {
        _console$7.assertWithError(this.hasMicrophone, "microphone not available");
    }
    async startMicrophone(sensorRate = 10) {
        this.#assertHasMicrophone();
        if (this.sensorConfiguration.microphone != sensorRate) {
            this.setSensorConfiguration({ microphone: sensorRate }, false, false);
        }
        await this.#microphoneManager.start();
    }
    async stopMicrophone() {
        this.#assertHasMicrophone();
        await this.#microphoneManager.stop();
    }
    async enableMicrophoneVad() {
        this.#assertHasMicrophone();
        await this.#microphoneManager.vad();
    }
    async toggleMicrophone(sensorRate = 10) {
        this.#assertHasMicrophone();
        if (this.sensorConfiguration.microphone == 0) {
            this.setSensorConfiguration({ microphone: sensorRate }, false, false);
        }
        await this.#microphoneManager.toggle();
    }
    get microphoneConfiguration() {
        return this.#microphoneManager.microphoneConfiguration;
    }
    get availableMicrophoneConfigurationTypes() {
        return this.#microphoneManager.availableMicrophoneConfigurationTypes;
    }
    get setMicrophoneConfiguration() {
        return this.#microphoneManager.setMicrophoneConfiguration;
    }
    #assertWebAudioSupport() {
        _console$7.assertWithError(AudioContext, "WebAudio is not supported");
    }
    get audioContext() {
        this.#assertWebAudioSupport();
        return this.#microphoneManager.audioContext;
    }
    set audioContext(newAudioContext) {
        this.#assertWebAudioSupport();
        this.#microphoneManager.audioContext = newAudioContext;
    }
    get microphoneMediaStreamDestination() {
        this.#assertWebAudioSupport();
        return this.#microphoneManager.mediaStreamDestination;
    }
    get microphoneGainNode() {
        this.#assertWebAudioSupport();
        return this.#microphoneManager.gainNode;
    }
    get isRecordingMicrophone() {
        return this.#microphoneManager.isRecording;
    }
    startRecordingMicrophone() {
        this.#microphoneManager.startRecording();
    }
    stopRecordingMicrophone() {
        this.#microphoneManager.stopRecording();
    }
    toggleMicrophoneRecording() {
        this.#microphoneManager.toggleRecording();
    }
    #displayManager = new DisplayManager();
    get isDisplayAvailable() {
        return this.#displayManager.isAvailable;
    }
    get isDisplayReady() {
        return this.#displayManager.isReady;
    }
    get displayContextState() {
        return this.#displayManager.contextState;
    }
    get displayColors() {
        return this.#displayManager.colors;
    }
    get displayBitmapColors() {
        return this.#displayManager.bitmapColors;
    }
    get displayBitmapColorIndices() {
        return this.#displayManager.bitmapColorIndices;
    }
    get displayColorOpacities() {
        return this.#displayManager.opacities;
    }
    #assertDisplayIsAvailable() {
        _console$7.assertWithError(this.isDisplayAvailable, "display not available");
    }
    get displayStatus() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.displayStatus;
    }
    get displayBrightness() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.brightness;
    }
    get setDisplayBrightness() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setBrightness;
    }
    get displayInformation() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.displayInformation;
    }
    get numberOfDisplayColors() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.numberOfColors;
    }
    get wakeDisplay() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.wake;
    }
    get sleepDisplay() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.sleep;
    }
    get toggleDisplay() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.toggle;
    }
    get isDisplayAwake() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.isDisplayAwake;
    }
    get showDisplay() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.show;
    }
    get clearDisplay() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.clear;
    }
    get setDisplayColor() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setColor;
    }
    get setDisplayColorOpacity() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setColorOpacity;
    }
    get setDisplayOpacity() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setOpacity;
    }
    get saveDisplayContext() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.saveContext;
    }
    get restoreDisplayContext() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.restoreContext;
    }
    get clearDisplayRect() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.clearRect;
    }
    get selectDisplayBackgroundColor() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.selectBackgroundColor;
    }
    get selectDisplayFillColor() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.selectFillColor;
    }
    get selectDisplayLineColor() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.selectLineColor;
    }
    get setDisplayIgnoreFill() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setIgnoreFill;
    }
    get setDisplayIgnoreLine() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setIgnoreLine;
    }
    get setDisplayFillBackground() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setFillBackground;
    }
    get setDisplayLineWidth() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setLineWidth;
    }
    get setDisplayRotation() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setRotation;
    }
    get clearDisplayRotation() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.clearRotation;
    }
    get setDisplaySegmentStartCap() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSegmentStartCap;
    }
    get setDisplaySegmentEndCap() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSegmentEndCap;
    }
    get setDisplaySegmentCap() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSegmentCap;
    }
    get setDisplaySegmentStartRadius() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSegmentStartRadius;
    }
    get setDisplaySegmentEndRadius() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSegmentEndRadius;
    }
    get setDisplaySegmentRadius() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSegmentRadius;
    }
    get setDisplayCropTop() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setCropTop;
    }
    get setDisplayCropRight() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setCropRight;
    }
    get setDisplayCropBottom() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setCropBottom;
    }
    get setDisplayCropLeft() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setCropLeft;
    }
    get setDisplayCrop() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setCrop;
    }
    get clearDisplayCrop() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.clearCrop;
    }
    get setDisplayRotationCropTop() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setRotationCropTop;
    }
    get setDisplayRotationCropRight() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setRotationCropRight;
    }
    get setDisplayRotationCropBottom() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setRotationCropBottom;
    }
    get setDisplayRotationCropLeft() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setRotationCropLeft;
    }
    get setDisplayRotationCrop() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setRotationCrop;
    }
    get clearDisplayRotationCrop() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.clearRotationCrop;
    }
    get flushDisplayContextCommands() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.flushContextCommands;
    }
    get drawDisplayRect() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawRect;
    }
    get drawDisplayCircle() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawCircle;
    }
    get drawDisplayEllipse() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawEllipse;
    }
    get drawDisplayRoundRect() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawRoundRect;
    }
    get drawDisplayRegularPolygon() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawRegularPolygon;
    }
    get drawDisplayPolygon() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawPolygon;
    }
    get drawDisplayWireframe() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawWireframe;
    }
    get drawDisplaySegment() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawSegment;
    }
    get drawDisplaySegments() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawSegments;
    }
    get drawDisplayArc() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawArc;
    }
    get drawDisplayArcEllipse() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawArcEllipse;
    }
    get drawDisplayBitmap() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawBitmap;
    }
    get imageToDisplayBitmap() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.imageToBitmap;
    }
    get quantizeDisplayImage() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.quantizeImage;
    }
    get resizeAndQuantizeDisplayImage() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.resizeAndQuantizeImage;
    }
    get setDisplayContextState() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setContextState;
    }
    get selectDisplayBitmapColor() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.selectBitmapColor;
    }
    get selectDisplayBitmapColors() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.selectBitmapColors;
    }
    get setDisplayBitmapColor() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setBitmapColor;
    }
    get setDisplayBitmapColorOpacity() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setBitmapColorOpacity;
    }
    get setDisplayBitmapScaleDirection() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setBitmapScaleDirection;
    }
    get setDisplayBitmapScaleX() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setBitmapScaleX;
    }
    get setDisplayBitmapScaleY() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setBitmapScaleY;
    }
    get setDisplayBitmapScale() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setBitmapScale;
    }
    get resetDisplayBitmapScale() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.resetBitmapScale;
    }
    get selectDisplaySpriteColor() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.selectSpriteColor;
    }
    get selectDisplaySpriteColors() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.selectSpriteColors;
    }
    get setDisplaySpriteColor() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSpriteColor;
    }
    get setDisplaySpriteColorOpacity() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSpriteColorOpacity;
    }
    get resetDisplaySpriteColors() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.resetSpriteColors;
    }
    get setDisplaySpriteScaleDirection() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSpriteScaleDirection;
    }
    get setDisplaySpriteScaleX() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSpriteScaleX;
    }
    get setDisplaySpriteScaleY() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSpriteScaleY;
    }
    get setDisplaySpriteScale() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.setSpriteScale;
    }
    get resetDisplaySpriteScale() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.resetSpriteScale;
    }
    get displayManager() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager;
    }
    get uploadDisplaySpriteSheet() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.uploadSpriteSheet;
    }
    get uploadDisplaySpriteSheets() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.uploadSpriteSheets;
    }
    get selectDisplaySpriteSheet() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.selectSpriteSheet;
    }
    get drawDisplaySprite() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.drawSprite;
    }
    get startDisplaySprite() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.startSprite;
    }
    get endDisplaySprite() {
        this.#assertDisplayIsAvailable();
        return this.#displayManager.endSprite;
    }
    get displaySpriteSheets() {
        return this.#displayManager.spriteSheets;
    }
    get serializeDisplaySpriteSheet() {
        return this.#displayManager.serializeSpriteSheet;
    }
    get setDisplayAlignment() {
        return this.#displayManager.setAlignment;
    }
    get setDisplayVerticalAlignment() {
        return this.#displayManager.setVerticalAlignment;
    }
    get setDisplayHorizontalAlignment() {
        return this.#displayManager.setHorizontalAlignment;
    }
    get resetDisplayAlignment() {
        return this.#displayManager.resetAlignment;
    }
    get setDisplaySpritesDirection() {
        return this.#displayManager.setSpritesDirection;
    }
    get setDisplaySpritesLineDirection() {
        return this.#displayManager.setSpritesLineDirection;
    }
    get setDisplaySpritesSpacing() {
        return this.#displayManager.setSpritesSpacing;
    }
    get setDisplaySpritesLineSpacing() {
        return this.#displayManager.setSpritesLineSpacing;
    }
    get setDisplaySpritesAlignment() {
        return this.#displayManager.setSpritesAlignment;
    }
    get drawDisplayQuadraticBezierCurve() {
        return this.#displayManager.drawQuadraticBezierCurve;
    }
    get drawDisplayQuadraticBezierCurves() {
        return this.#displayManager.drawQuadraticBezierCurves;
    }
    get drawDisplayCubicBezierCurve() {
        return this.#displayManager.drawCubicBezierCurve;
    }
    get drawDisplayCubicBezierCurves() {
        return this.#displayManager.drawCubicBezierCurves;
    }
    get drawDisplayPath() {
        return this.#displayManager.drawPath;
    }
    get drawDisplayClosedPath() {
        return this.#displayManager.drawClosedPath;
    }
}
_a$1 = Device;

const _console$6 = createConsole("DisplayCanvasHelper", { log: false });
const DisplayCanvasHelperEventTypes = [
    "contextState",
    "numberOfColors",
    "brightness",
    "color",
    "colorOpacity",
    "resize",
    "update",
    "ready",
    "device",
    "deviceIsConnected",
    "deviceConnected",
    "deviceNotConnected",
    "deviceSpriteSheetUploadStart",
    "deviceSpriteSheetUploadProgress",
    "deviceSpriteSheetUploadComplete",
    "deviceUpdated",
];
class DisplayCanvasHelper {
    constructor() {
        this.numberOfColors = 16;
        this.#bitmapContext = this.#bitmapCanvas.getContext("2d");
        this.#bitmapContext.imageSmoothingEnabled = false;
        this.addEventListener("ready", () => {
            this.#isReady = true;
            this.#onSentContextCommands();
            this.#drawFrontDrawStack();
        });
    }
    #eventDispatcher = new EventDispatcher(this, DisplayCanvasHelperEventTypes);
    get addEventListener() {
        return this.#eventDispatcher.addEventListener;
    }
    get #dispatchEvent() {
        return this.#eventDispatcher.dispatchEvent;
    }
    get removeEventListener() {
        return this.#eventDispatcher.removeEventListener;
    }
    get waitForEvent() {
        return this.#eventDispatcher.waitForEvent;
    }
    get removeEventListeners() {
        return this.#eventDispatcher.removeEventListeners;
    }
    get removeAllEventListeners() {
        return this.#eventDispatcher.removeAllEventListeners;
    }
    #canvas;
    get canvas() {
        return this.#canvas;
    }
    set canvas(newCanvas) {
        _console$6.assertWithError(newCanvas?.nodeName == "CANVAS", `assigned non-canvas type ${newCanvas?.nodeName}`);
        if (this.#canvas == newCanvas) {
            return;
        }
        this.#canvas = newCanvas;
        this.#context = this.#canvas?.getContext("2d", {
            willReadFrequently: true,
        });
        this.#updateCanvas();
    }
    #context;
    get context() {
        return this.#context;
    }
    get width() {
        return this.canvas?.width || 0;
    }
    get height() {
        return this.canvas?.height || 0;
    }
    get aspectRatio() {
        return this.width / this.height;
    }
    #updateCanvas() {
        if (!this.canvas) {
            return;
        }
        this.canvas.style.aspectRatio = `${this.aspectRatio}`;
        if (!this.device?.isConnected) {
            return;
        }
        const { width, height } = this.device.displayInformation;
        this.canvas.width = width;
        this.canvas.height = height;
        this.canvas.style.aspectRatio = `${width / height}`;
        this.#dispatchEvent("resize", { width: this.width, height: this.height });
        this.clear();
    }
    #frontDrawStack = [];
    #rearDrawStack = [];
    #drawFrontDrawStack() {
        if (!this.context) {
            return;
        }
        this.#context.imageSmoothingEnabled = false;
        this.#save();
        this.#context.resetTransform();
        this.#context.clearRect(0, 0, this.width, this.height);
        this.#restore();
        this.#drawBackground();
        this.#frontDrawStack.forEach((callback) => callback());
        if (this.#applyTransparency) {
            this.#applyTransparencyToCanvas();
        }
        this.#dispatchEvent("update", {});
    }
    #applyTransparencyToCanvas() {
        const ctx = this.context;
        const imageData = ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;
        const alphaBoost = 1.0;
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
            const alpha = Math.min(255, brightness * alphaBoost);
            const scale = alpha > 0 ? 255 / alpha : 0;
            data[i] = Math.min(255, r * scale);
            data[i + 1] = Math.min(255, g * scale);
            data[i + 2] = Math.min(255, b * scale);
            data[i + 3] = alpha;
        }
        ctx.putImageData(imageData, 0, 0);
    }
    #drawBackground() {
        this.#save();
        this.#context.resetTransform();
        this.#context.fillStyle = this.#colorIndexToRgbString(0);
        this.#context.fillRect(0, 0, this.width, this.height);
        this.#restore();
    }
    #applyTransparency = false;
    get applyTransparency() {
        return this.#applyTransparency;
    }
    set applyTransparency(newValue) {
        this.#applyTransparency = newValue;
        this.#drawFrontDrawStack();
    }
    #device;
    get device() {
        return this.#device;
    }
    get deviceDisplayManager() {
        return this.#device?.displayManager;
    }
    set device(newDevice) {
        if (this.#device == newDevice) {
            return;
        }
        if (newDevice) {
            _console$6.assertWithError(newDevice.isConnected, "device must be connected");
            _console$6.assertWithError(newDevice.isDisplayAvailable, "display must have a display");
        }
        if (this.#device) {
            removeEventListeners(this.device, this.#boundDeviceEventListeners);
            this.#isReady = true;
        }
        this.#device = newDevice;
        addEventListeners(this.#device, this.#boundDeviceEventListeners);
        _console$6.log("assigned device", this.device);
        if (this.device) {
            this.numberOfColors = this.device.numberOfDisplayColors;
            this.#updateCanvas();
            this.#updateDevice();
            this.#isReady = this.device.isDisplayReady;
            this.#dispatchEvent("deviceIsConnected", {
                device: this.device,
                isConnected: this.device.isConnected,
            });
            this.#dispatchEvent(this.device.isConnected ? "deviceConnected" : "deviceNotConnected", {
                device: this.device,
            });
        }
        this.#dispatchEvent("device", {
            device: this.device,
        });
    }
    async flushContextCommands() {
        if (this.#device?.isConnected) {
            await this.#device.flushDisplayContextCommands();
        }
        this.#onSentContextCommands();
    }
    #boundDeviceEventListeners = {
        isConnected: this.#onDeviceIsConnected.bind(this),
        connected: this.#onDeviceConnected.bind(this),
        notConnected: this.#onDeviceNotConnected.bind(this),
        displayReady: this.#onDeviceDisplayReady.bind(this),
        displaySpriteSheetUploadStart: this.#onDeviceDisplaySpriteSheetUploadStart.bind(this),
        displaySpriteSheetUploadProgress: this.#onDeviceDisplaySpriteSheetUploadProgress.bind(this),
        displaySpriteSheetUploadComplete: this.#onDeviceDisplaySpriteSheetUploadComplete.bind(this),
        displayContextCommands: this.#onDeviceDisplayContextCommands.bind(this),
    };
    #onDeviceIsConnected(event) {
        const { isConnected } = event.message;
        this.#dispatchEvent("deviceIsConnected", {
            device: this.device,
            isConnected,
        });
    }
    #onDeviceConnected(event) {
        this.#updateCanvas();
        this.#updateDevice();
        this.#dispatchEvent("deviceConnected", { device: this.device });
    }
    #onDeviceNotConnected(event) {
        this.#dispatchEvent("deviceNotConnected", { device: this.device });
    }
    async #onDeviceDisplayReady(event) {
        this.#dispatchEvent("ready", {});
    }
    #onDeviceDisplaySpriteSheetUploadStart(event) {
        const device = event.target;
        const { spriteSheet, spriteSheetName } = event.message;
        this.#dispatchEvent("deviceSpriteSheetUploadStart", {
            device,
            spriteSheet,
            spriteSheetName,
        });
    }
    #onDeviceDisplaySpriteSheetUploadProgress(event) {
        const device = event.target;
        const { spriteSheet, spriteSheetName, progress } = event.message;
        this.#dispatchEvent("deviceSpriteSheetUploadProgress", {
            device,
            spriteSheet,
            spriteSheetName,
            progress,
        });
    }
    #onDeviceDisplaySpriteSheetUploadComplete(event) {
        const device = event.target;
        const { spriteSheet, spriteSheetName } = event.message;
        this.#dispatchEvent("deviceSpriteSheetUploadComplete", {
            device,
            spriteSheet,
            spriteSheetName,
        });
    }
    #onDeviceDisplayContextCommands(event) {
        this.#onSentContextCommands();
    }
    #onSentContextCommands() {
        let redraw = false;
        redraw ||= this.#flushColors();
        redraw ||= this.#flushOpacities();
        redraw ||= this.#flushBrightness();
        _console$6.log("onSentContextCommands", { redraw });
        if (redraw) {
            this.#drawFrontDrawStack();
        }
    }
    async #updateDevice() {
        await this.#updateDeviceColors(true);
        await this.#updateDeviceOpacity(true);
        await this.#updateDeviceContextState(true);
        await this.#updateDeviceBrightness(true);
        await this.#updateDeviceSpriteSheets();
        await this.#updateDeviceSelectedSpriteSheet(true);
        this.#dispatchEvent("deviceUpdated", { device: this.device });
    }
    #numberOfColors = 0;
    get numberOfColors() {
        return this.#numberOfColors;
    }
    set numberOfColors(newNumberOfColors) {
        if (this.#numberOfColors == newNumberOfColors) {
            return;
        }
        this.#numberOfColors = newNumberOfColors;
        this.#colors = new Array(this.numberOfColors).fill("#000000");
        this.#opacities = new Array(this.numberOfColors).fill(1);
        this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(0);
        this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(0);
        this.#dispatchEvent("numberOfColors", {
            numberOfColors: this.numberOfColors,
        });
    }
    assertValidColorIndex(colorIndex) {
        _console$6.assertRangeWithError("colorIndex", colorIndex, 0, this.numberOfColors);
    }
    #pendingColors = [];
    #setColor(colorIndex, colorHex) {
        this.#pendingColors[colorIndex] = colorHex;
    }
    #colors = [];
    get colors() {
        return this.#colors;
    }
    #flushColors() {
        if (this.#pendingColors.length == 0) {
            return false;
        }
        this.#pendingColors.forEach((colorHex, colorIndex) => {
            this.#colors[colorIndex] = colorHex;
            const colorRGB = hexToRGB(colorHex);
            this.#dispatchEvent("color", { colorIndex, colorHex, colorRGB });
        });
        this.#pendingColors.length = 0;
        _console$6.log("flushColors");
        return true;
    }
    #resetColors() {
        this.#colors.length = 0;
        this.#pendingColors.length = 0;
    }
    async #updateDeviceColors(sendImmediately) {
        if (!this.device?.isConnected) {
            return;
        }
        for (const [index, color] of this.colors.entries()) {
            await this.device?.setDisplayColor(index, color, false);
        }
        if (sendImmediately) {
            await this.flushContextCommands();
        }
    }
    #opacities = [];
    get opacities() {
        return this.#opacities;
    }
    #pendingOpacities = [];
    #setColorOpacity(colorIndex, opacity) {
        this.#pendingOpacities[colorIndex] = opacity;
    }
    #flushOpacities() {
        if (this.#pendingOpacities.length == 0) {
            return false;
        }
        this.#pendingOpacities.forEach((opacity, colorIndex) => {
            this.#opacities[colorIndex] = opacity;
            this.#dispatchEvent("colorOpacity", { colorIndex, opacity });
        });
        this.#pendingOpacities.length = 0;
        _console$6.log("flushOpacities");
        return true;
    }
    #resetOpacities() {
        this.#opacities.length = 0;
        this.#pendingOpacities.length = 0;
    }
    async #updateDeviceOpacity(sendImmediately) {
        if (!this.device?.isConnected) {
            return;
        }
        for (const [index, opacity] of this.#opacities.entries()) {
            await this.device?.setDisplayColorOpacity(index, opacity, false);
        }
        if (sendImmediately) {
            await this.flushContextCommands();
        }
    }
    #contextStateHelper = new DisplayContextStateHelper();
    get contextState() {
        return this.#contextStateHelper.state;
    }
    #onContextStateUpdate(differences) {
        this.#dispatchEvent("contextState", {
            contextState: structuredClone(this.contextState),
            differences,
        });
    }
    #resetContextState() {
        this.#contextStateHelper.reset();
        this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(0);
        this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(0);
    }
    async #updateDeviceContextState(sendImmediately) {
        if (!this.device?.isConnected) {
            return;
        }
        await this.device?.setDisplayContextState(this.contextState, sendImmediately);
    }
    async show(sendImmediately = true) {
        this.#frontDrawStack = this.#rearDrawStack.slice();
        this.#rearDrawStack.length = 0;
        this.#isReady = false;
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.show(sendImmediately);
        }
        else {
            await wait(this.#interval);
            if (this.device) {
                return;
            }
            this.#dispatchEvent("ready", {});
        }
    }
    #interval = 50;
    get interval() {
        return this.#interval;
    }
    set interval(newInterval) {
        this.#interval = newInterval;
    }
    #isReady = true;
    get isReady() {
        return this.#isReady;
    }
    async clear(sendImmediately = true) {
        this.#frontDrawStack.length = 0;
        this.#rearDrawStack.length = 0;
        this.#isReady = false;
        this.#save();
        this.#context.resetTransform();
        this.#context.clearRect(0, 0, this.width, this.height);
        this.#restore();
        this.#drawBackground();
        this.#isDrawingBlankSprite = false;
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.clear(sendImmediately);
        }
        else {
            await wait(this.#interval);
            if (this.device) {
                return;
            }
            this.#dispatchEvent("ready", {});
        }
    }
    async setColor(colorIndex, color, sendImmediately) {
        let colorRGB;
        if (typeof color == "string") {
            colorRGB = stringToRGB(color);
        }
        else {
            colorRGB = color;
        }
        const colorHex = rgbToHex(colorRGB);
        if (this.colors[colorIndex] == colorHex) {
            return;
        }
        this.assertValidColorIndex(colorIndex);
        assertValidColor(colorRGB);
        this.#setColor(colorIndex, colorHex);
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setColor(colorIndex, color, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    async setColorOpacity(colorIndex, opacity, sendImmediately) {
        this.assertValidColorIndex(colorIndex);
        assertValidOpacity(opacity);
        if (Math.floor(255 * this.#opacities[colorIndex]) == Math.floor(255 * opacity)) {
            return;
        }
        this.#setColorOpacity(colorIndex, opacity);
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setColorOpacity(colorIndex, opacity, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    async setOpacity(opacity, sendImmediately) {
        assertValidOpacity(opacity);
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setOpacity(opacity, sendImmediately);
        }
        this.#opacities.forEach((_, colorIndex) => {
            this.#setColorOpacity(colorIndex, opacity);
        });
    }
    #contextStack = [];
    async #saveContext(sendImmediately) {
        this.#contextStack.push(structuredClone(this.contextState));
    }
    async #restoreContext(sendImmediately) {
        const contextState = this.#contextStack.pop();
        if (!contextState) {
            _console$6.warn("#contextStack empty");
            return;
        }
        this.#contextStateHelper.update(contextState);
        if (!this.#ignoreDevice) {
            await this.#updateDeviceContextState(sendImmediately);
        }
    }
    async saveContext(sendImmediately) {
        await this.#saveContext(sendImmediately);
    }
    async restoreContext(sendImmediately) {
        await this.#restoreContext(sendImmediately);
    }
    async selectBackgroundColor(backgroundColorIndex, sendImmediately) {
        this.assertValidColorIndex(backgroundColorIndex);
        const differences = this.#contextStateHelper.update({
            backgroundColorIndex,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.selectBackgroundColor(backgroundColorIndex, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async selectFillColor(fillColorIndex, sendImmediately) {
        this.assertValidColorIndex(fillColorIndex);
        const differences = this.#contextStateHelper.update({
            fillColorIndex,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.selectFillColor(fillColorIndex, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async selectLineColor(lineColorIndex, sendImmediately) {
        this.assertValidColorIndex(lineColorIndex);
        const differences = this.#contextStateHelper.update({
            lineColorIndex,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.selectLineColor(lineColorIndex, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setIgnoreFill(ignoreFill, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            ignoreFill,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setIgnoreFill(ignoreFill, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setIgnoreLine(ignoreLine, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            ignoreLine,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setIgnoreLine(ignoreLine, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setFillBackground(fillBackground, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            fillBackground,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setFillBackground(fillBackground, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    assertValidLineWidth(lineWidth) {
        _console$6.assertRangeWithError("lineWidth", lineWidth, 0, Math.max(this.width, this.height));
    }
    async setLineWidth(lineWidth, sendImmediately) {
        this.assertValidLineWidth(lineWidth);
        const differences = this.#contextStateHelper.update({
            lineWidth,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setLineWidth(lineWidth, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setAlignment(alignmentDirection, alignment, sendImmediately) {
        _console$6.assertEnumWithError(alignmentDirection, DisplayAlignmentDirections);
        const alignmentKey = DisplayAlignmentDirectionToStateKey[alignmentDirection];
        const differences = this.#contextStateHelper.update({
            [alignmentKey]: alignment,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setAlignment(alignmentDirection, alignment, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setHorizontalAlignment(horizontalAlignment, sendImmediately) {
        await this.setAlignment("horizontal", horizontalAlignment, sendImmediately);
    }
    async setVerticalAlignment(verticalAlignment, sendImmediately) {
        await this.setAlignment("vertical", verticalAlignment, sendImmediately);
    }
    async resetAlignment(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            verticalAlignment: DefaultDisplayContextState.verticalAlignment,
            horizontalAlignment: DefaultDisplayContextState.horizontalAlignment,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.resetAlignment(sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setRotation(rotation, isRadians, sendImmediately) {
        rotation = isRadians ? rotation : degToRad(rotation);
        rotation = normalizeRadians(rotation);
        const differences = this.#contextStateHelper.update({
            rotation,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setRotation(rotation, true, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async clearRotation(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            rotation: 0,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.clearRotation(sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSegmentStartCap(segmentStartCap, sendImmediately) {
        assertValidSegmentCap(segmentStartCap);
        const differences = this.#contextStateHelper.update({
            segmentStartCap,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setSegmentStartCap(segmentStartCap, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSegmentEndCap(segmentEndCap, sendImmediately) {
        assertValidSegmentCap(segmentEndCap);
        const differences = this.#contextStateHelper.update({
            segmentEndCap,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setSegmentEndCap(segmentEndCap, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSegmentCap(segmentCap, sendImmediately) {
        assertValidSegmentCap(segmentCap);
        const differences = this.#contextStateHelper.update({
            segmentStartCap: segmentCap,
            segmentEndCap: segmentCap,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setSegmentCap(segmentCap, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSegmentStartRadius(segmentStartRadius, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            segmentStartRadius,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setSegmentStartRadius(segmentStartRadius, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSegmentEndRadius(segmentEndRadius, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            segmentEndRadius,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setSegmentEndRadius(segmentEndRadius, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSegmentRadius(segmentRadius, sendImmediately) {
        const differences = this.#contextStateHelper.update({
            segmentStartRadius: segmentRadius,
            segmentEndRadius: segmentRadius,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setSegmentRadius(segmentRadius, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setCrop(cropDirection, crop, sendImmediately) {
        _console$6.assertEnumWithError(cropDirection, DisplayCropDirections);
        crop = Math.max(0, crop);
        const cropKey = DisplayCropDirectionToStateKey[cropDirection];
        const differences = this.#contextStateHelper.update({
            [cropKey]: crop,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setCrop(cropDirection, crop, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setCropTop(cropTop, sendImmediately) {
        await this.setCrop("top", cropTop, sendImmediately);
    }
    async setCropRight(cropRight, sendImmediately) {
        await this.setCrop("right", cropRight, sendImmediately);
    }
    async setCropBottom(cropBottom, sendImmediately) {
        await this.setCrop("bottom", cropBottom, sendImmediately);
    }
    async setCropLeft(cropLeft, sendImmediately) {
        await this.setCrop("left", cropLeft, sendImmediately);
    }
    async clearCrop(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            cropTop: 0,
            cropRight: 0,
            cropBottom: 0,
            cropLeft: 0,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.clearCrop(sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setRotationCrop(cropDirection, crop, sendImmediately) {
        _console$6.assertEnumWithError(cropDirection, DisplayCropDirections);
        const cropKey = DisplayRotationCropDirectionToStateKey[cropDirection];
        const differences = this.#contextStateHelper.update({
            [cropKey]: crop,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setRotationCrop(cropDirection, crop, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setRotationCropTop(rotationCropTop, sendImmediately) {
        await this.setRotationCrop("top", rotationCropTop, sendImmediately);
    }
    async setRotationCropRight(rotationCropRight, sendImmediately) {
        await this.setRotationCrop("right", rotationCropRight, sendImmediately);
    }
    async setRotationCropBottom(rotationCropBottom, sendImmediately) {
        await this.setRotationCrop("bottom", rotationCropBottom, sendImmediately);
    }
    async setRotationCropLeft(rotationCropLeft, sendImmediately) {
        await this.setRotationCrop("left", rotationCropLeft, sendImmediately);
    }
    async clearRotationCrop(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            rotationCropTop: 0,
            rotationCropRight: 0,
            rotationCropBottom: 0,
            rotationCropLeft: 0,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.clearRotationCrop(sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    get bitmapColorIndices() {
        return this.contextState.bitmapColorIndices;
    }
    get bitmapColors() {
        return this.bitmapColorIndices.map((colorIndex) => this.colors[colorIndex]);
    }
    async selectBitmapColor(bitmapColorIndex, colorIndex, sendImmediately) {
        this.assertValidColorIndex(bitmapColorIndex);
        const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();
        bitmapColorIndices[bitmapColorIndex] = colorIndex;
        const differences = this.#contextStateHelper.update({
            bitmapColorIndices,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.selectBitmapColor(bitmapColorIndex, colorIndex, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async selectBitmapColors(bitmapColorPairs, sendImmediately) {
        _console$6.assertRangeWithError("bitmapColors", bitmapColorPairs.length, 1, this.numberOfColors);
        const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();
        bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {
            this.assertValidColorIndex(bitmapColorIndex);
            this.assertValidColorIndex(colorIndex);
            bitmapColorIndices[bitmapColorIndex] = colorIndex;
        });
        const differences = this.#contextStateHelper.update({
            bitmapColorIndices,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.selectBitmapColors(bitmapColorPairs, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setBitmapColor(bitmapColorIndex, color, sendImmediately) {
        return this.setColor(this.bitmapColorIndices[bitmapColorIndex], color, sendImmediately);
    }
    async setBitmapColorOpacity(bitmapColorIndex, opacity, sendImmediately) {
        return this.setColorOpacity(this.bitmapColorIndices[bitmapColorIndex], opacity, sendImmediately);
    }
    async setBitmapScaleDirection(direction, bitmapScale, sendImmediately) {
        bitmapScale = clamp(bitmapScale, minDisplayScale, maxDisplayScale);
        bitmapScale = roundScale(bitmapScale);
        const newState = {};
        switch (direction) {
            case "all":
                newState.bitmapScaleX = bitmapScale;
                newState.bitmapScaleY = bitmapScale;
                break;
            case "x":
                newState.bitmapScaleX = bitmapScale;
                break;
            case "y":
                newState.bitmapScaleY = bitmapScale;
                break;
        }
        const differences = this.#contextStateHelper.update(newState);
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setBitmapScaleDirection(direction, bitmapScale, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setBitmapScaleX(bitmapScaleX, sendImmediately) {
        return this.setBitmapScaleDirection("x", bitmapScaleX, sendImmediately);
    }
    async setBitmapScaleY(bitmapScaleY, sendImmediately) {
        return this.setBitmapScaleDirection("y", bitmapScaleY, sendImmediately);
    }
    async setBitmapScale(bitmapScale, sendImmediately) {
        return this.setBitmapScaleDirection("all", bitmapScale, sendImmediately);
    }
    async resetBitmapScale(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            bitmapScaleX: 1,
            bitmapScaleY: 1,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.resetBitmapScale(sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    get spriteColorIndices() {
        return this.contextState.spriteColorIndices;
    }
    get spriteColors() {
        return this.spriteColorIndices.map((colorIndex) => this.colors[colorIndex]);
    }
    get spriteBitmapColorIndices() {
        return this.bitmapColorIndices.map((colorIndex) => this.spriteColorIndices[colorIndex]);
    }
    get spriteBitmapColors() {
        return this.spriteBitmapColorIndices.map((colorIndex) => this.colors[colorIndex]);
    }
    async selectSpriteColor(spriteColorIndex, colorIndex, sendImmediately) {
        this.assertValidColorIndex(spriteColorIndex);
        const spriteColorIndices = this.contextState.spriteColorIndices.slice();
        spriteColorIndices[spriteColorIndex] = colorIndex;
        const differences = this.#contextStateHelper.update({
            spriteColorIndices,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.selectSpriteColor(spriteColorIndex, colorIndex, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async selectSpriteColors(spriteColorPairs, sendImmediately) {
        _console$6.assertRangeWithError("spriteColors", spriteColorPairs.length, 1, this.numberOfColors);
        const spriteColorIndices = this.contextState.spriteColorIndices.slice();
        spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {
            this.assertValidColorIndex(spriteColorIndex);
            this.assertValidColorIndex(colorIndex);
            spriteColorIndices[spriteColorIndex] = colorIndex;
        });
        const differences = this.#contextStateHelper.update({
            spriteColorIndices,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.selectSpriteColors(spriteColorPairs, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSpriteColor(spriteColorIndex, color, sendImmediately) {
        return this.setColor(this.spriteColorIndices[spriteColorIndex], color, sendImmediately);
    }
    async setSpriteColorOpacity(spriteColorIndex, opacity, sendImmediately) {
        return this.setColorOpacity(this.spriteColorIndices[spriteColorIndex], opacity, sendImmediately);
    }
    async resetSpriteColors(sendImmediately) {
        const spriteColorIndices = new Array(this.numberOfColors).fill(0);
        const differences = this.#contextStateHelper.update({
            spriteColorIndices,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.resetSpriteColors(sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSpriteScaleDirection(direction, spriteScale, sendImmediately) {
        spriteScale = clamp(spriteScale, minDisplayScale, maxDisplayScale);
        spriteScale = roundScale(spriteScale);
        const newState = {};
        switch (direction) {
            case "all":
                newState.spriteScaleX = spriteScale;
                newState.spriteScaleY = spriteScale;
                break;
            case "x":
                newState.spriteScaleX = spriteScale;
                break;
            case "y":
                newState.spriteScaleY = spriteScale;
                break;
        }
        const differences = this.#contextStateHelper.update(newState);
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setSpriteScaleDirection(direction, spriteScale, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSpriteScaleX(spriteScaleX, sendImmediately) {
        return this.setSpriteScaleDirection("x", spriteScaleX, sendImmediately);
    }
    async setSpriteScaleY(spriteScaleY, sendImmediately) {
        return this.setSpriteScaleDirection("y", spriteScaleY, sendImmediately);
    }
    async setSpriteScale(spriteScale, sendImmediately) {
        return this.setSpriteScaleDirection("all", spriteScale, sendImmediately);
    }
    async resetSpriteScale(sendImmediately) {
        const differences = this.#contextStateHelper.update({
            spriteScaleX: 1,
            spriteScaleY: 1,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.resetSpriteScale(sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSpritesLineHeight(spritesLineHeight, sendImmediately) {
        this.assertValidLineWidth(spritesLineHeight);
        const differences = this.#contextStateHelper.update({
            spritesLineHeight,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setSpritesLineHeight(spritesLineHeight, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSpritesDirectionGeneric(direction, isOrthogonal, sendImmediately) {
        assertValidDirection(direction);
        const stateKey = isOrthogonal
            ? "spritesLineDirection"
            : "spritesDirection";
        const differences = this.#contextStateHelper.update({
            [stateKey]: direction,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            this.deviceDisplayManager.setSpritesDirectionGeneric(direction, isOrthogonal, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSpritesDirection(spritesDirection, sendImmediately) {
        await this.setSpritesDirectionGeneric(spritesDirection, false, sendImmediately);
    }
    async setSpritesLineDirection(spritesLineDirection, sendImmediately) {
        await this.setSpritesDirectionGeneric(spritesLineDirection, true, sendImmediately);
    }
    async setSpritesSpacingGeneric(spacing, isOrthogonal, sendImmediately) {
        const stateKey = isOrthogonal
            ? "spritesLineSpacing"
            : "spritesSpacing";
        const differences = this.#contextStateHelper.update({
            [stateKey]: spacing,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            this.deviceDisplayManager.setSpritesSpacingGeneric(spacing, isOrthogonal, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSpritesSpacing(spritesSpacing, sendImmediately) {
        await this.setSpritesSpacingGeneric(spritesSpacing, false, sendImmediately);
    }
    async setSpritesLineSpacing(spritesSpacing, sendImmediately) {
        await this.setSpritesSpacingGeneric(spritesSpacing, true, sendImmediately);
    }
    async setSpritesAlignmentGeneric(alignment, isOrthogonal, sendImmediately) {
        assertValidAlignment(alignment);
        const stateKey = isOrthogonal
            ? "spritesLineAlignment"
            : "spritesAlignment";
        const differences = this.#contextStateHelper.update({
            [stateKey]: alignment,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            this.deviceDisplayManager.setSpritesAlignmentGeneric(alignment, isOrthogonal, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    async setSpritesAlignment(spritesAlignment, sendImmediately) {
        await this.setSpritesAlignmentGeneric(spritesAlignment, false, sendImmediately);
    }
    async setSpritesLineAlignment(spritesLineAlignment, sendImmediately) {
        await this.setSpritesAlignmentGeneric(spritesLineAlignment, true, sendImmediately);
    }
    #clearRectToCanvas(x, y, width, height, { backgroundColorIndex, spriteColorIndices, fillBackground, }) {
        this.#save();
        if (this.#useSpriteColorIndices) {
            backgroundColorIndex = spriteColorIndices[backgroundColorIndex];
        }
        this.context.fillStyle = this.#colorIndexToRgbString(fillBackground ? backgroundColorIndex : 0);
        this.context.fillRect(x, y, width, height);
        this.#restore();
    }
    async clearRect(x, y, width, height, sendImmediately) {
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#clearRectToCanvas(x, y, width, height, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.clearRect(x, y, width, height, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #save() {
        const ctx = this.#context;
        ctx.save();
    }
    #restore() {
        const ctx = this.#context;
        ctx.restore();
    }
    #transformContext(offsetX, offsetY, rotation) {
        this.#translateContext(offsetX, offsetY);
        this.#rotateContext(rotation);
    }
    #translateContext(offsetX, offsetY) {
        const ctx = this.context;
        ctx.translate(offsetX, offsetY);
    }
    #rotateContext(rotation) {
        const ctx = this.context;
        ctx.rotate(rotation);
    }
    #scaleContext(scaleX, scaleY) {
        const ctx = this.context;
        ctx.scale(scaleX, scaleY);
    }
    #correctAlignmentTranslation({ width, height }, { verticalAlignment, horizontalAlignment }) {
        switch (horizontalAlignment) {
            case "start":
                this.#translateContext(width / 2, 0);
                break;
            case "center":
                break;
            case "end":
                this.#translateContext(-width / 2, 0);
                break;
        }
        switch (verticalAlignment) {
            case "start":
                this.#translateContext(0, height / 2);
                break;
            case "center":
                break;
            case "end":
                this.#translateContext(0, -height / 2);
                break;
        }
    }
    #rotateBoundingBox(box, rotation) {
        const cos = Math.cos(rotation);
        const sin = Math.sin(rotation);
        const corners = [
            { x: box.x, y: box.y },
            { x: box.x, y: box.height + box.y },
            { x: box.x + box.width, y: box.y },
            { x: box.x + box.width, y: box.height + box.y },
        ];
        const rotated = corners.map(({ x, y }) => ({
            x: x * cos - y * sin,
            y: x * sin + y * cos,
        }));
        const xs = rotated.map((p) => p.x);
        const ys = rotated.map((p) => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
        };
    }
    #offsetBoundingBox(box, offsetX, offsetY) {
        const offsetBoundingBox = structuredClone(box);
        offsetBoundingBox.x += offsetX;
        offsetBoundingBox.y += offsetY;
        return offsetBoundingBox;
    }
    #clearBoundingBoxOnDraw = true;
    #clearBoundingBox({ x, y, width, height }, contextState) {
        this.#clearRectToCanvas(x, y, width, height, contextState);
    }
    #getOuterPadding(lineWidth) {
        return Math.ceil(lineWidth / 2);
    }
    #getRectBoundingBox(width, height, { lineWidth, verticalAlignment, horizontalAlignment }, applyLineWidth = true) {
        const outerPadding = applyLineWidth ? this.#getOuterPadding(lineWidth) : 0;
        const boundingBox = {
            x: 0,
            y: 0,
            width: width + outerPadding * 2,
            height: height + outerPadding * 2,
        };
        assertValidAlignment(horizontalAlignment);
        assertValidAlignment(verticalAlignment);
        switch (horizontalAlignment) {
            case "start":
                break;
            case "center":
                boundingBox.x -= boundingBox.width / 2;
                break;
            case "end":
                boundingBox.x -= boundingBox.width;
                break;
        }
        switch (verticalAlignment) {
            case "start":
                break;
            case "center":
                boundingBox.y -= boundingBox.height / 2;
                break;
            case "end":
                boundingBox.y -= boundingBox.height;
                break;
        }
        return boundingBox;
    }
    #applyClip({ x, y, height, width }, { cropTop, cropRight, cropBottom, cropLeft }) {
        const ctx = this.context;
        ctx.beginPath();
        ctx.rect(x + cropLeft, y + cropTop, width - cropRight, height - cropBottom);
        ctx.clip();
    }
    #applyRotationClip({ x, y, height, width }, { rotationCropTop, rotationCropRight, rotationCropBottom, rotationCropLeft, }) {
        const ctx = this.context;
        ctx.beginPath();
        ctx.rect(x + rotationCropLeft, y + rotationCropTop, width - rotationCropRight, height - rotationCropBottom);
        ctx.clip();
    }
    #hexToRgbWithOpacity(hex, opacity) {
        if (hex.length === 4) {
            hex = "#" + [...hex.slice(1)].map((c) => c + c).join("");
        }
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        const darken = (c) => Math.round(c * opacity);
        const dr = darken(r);
        const dg = darken(g);
        const db = darken(b);
        return { r: dr, g: dg, b: db };
    }
    #hexToRgbStringWithOpacity(hex, opacity) {
        const { r, g, b } = this.#hexToRgbWithOpacity(hex, opacity);
        return `rgb(${r}, ${g}, ${b})`;
    }
    #getColorOpacity(colorIndex, includeBrightness = false) {
        return (this.opacities[colorIndex] *
            (includeBrightness ? this.#brightnessOpacity : 1));
    }
    #colorIndexToRgbString(colorIndex) {
        return this.#hexToRgbStringWithOpacity(this.colors[colorIndex], this.#getColorOpacity(colorIndex));
    }
    #colorIndexToRgb(colorIndex) {
        return this.#hexToRgbWithOpacity(this.colors[colorIndex], this.#getColorOpacity(colorIndex));
    }
    #ignoreCanvasContextStyle = "rgba(0,0,0,0)";
    #updateContext({ lineWidth, fillColorIndex, lineColorIndex, spriteColorIndices, ignoreFill, ignoreLine, }) {
        if (this.#useSpriteColorIndices) {
            fillColorIndex = spriteColorIndices[fillColorIndex];
            lineColorIndex = spriteColorIndices[lineColorIndex];
        }
        this.context.fillStyle = ignoreFill
            ? this.#ignoreCanvasContextStyle
            : this.#colorIndexToRgbString(fillColorIndex);
        this.context.strokeStyle = ignoreLine
            ? this.#ignoreCanvasContextStyle
            : this.#colorIndexToRgbString(lineColorIndex);
        this.context.lineWidth = lineWidth;
    }
    #drawRectToCanvas(offsetX, offsetY, width, height, contextState) {
        this.#updateContext(contextState);
        this.#save();
        const localBox = this.#getRectBoundingBox(width, height, contextState);
        const rotatedLocalBox = this.#rotateBoundingBox(localBox, contextState.rotation);
        const rotatedBox = this.#offsetBoundingBox(rotatedLocalBox, offsetX, offsetY);
        this.#applyClip(rotatedBox, contextState);
        if (this.#clearBoundingBoxOnDraw) {
            this.#clearBoundingBox(rotatedBox, contextState);
        }
        this.#transformContext(offsetX, offsetY, contextState.rotation);
        this.#applyRotationClip(localBox, contextState);
        const outerPadding = this.#getOuterPadding(contextState.lineWidth);
        const startX = localBox.x + outerPadding;
        const startY = localBox.y + outerPadding;
        this.context.fillRect(startX, startY, width, height);
        if (contextState.lineWidth > 0) {
            this.context.strokeRect(startX, startY, width, height);
        }
        this.#restore();
    }
    async drawRect(offsetX, offsetY, width, height, sendImmediately) {
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawRectToCanvas(offsetX, offsetY, width, height, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawRect(offsetX, offsetY, width, height, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #drawRoundRectToCanvas(offsetX, offsetY, width, height, borderRadius, contextState) {
        this.#updateContext(contextState);
        const maxBorderRadius = Math.min(width, height) / 2;
        borderRadius = Math.min(borderRadius, maxBorderRadius);
        this.#save();
        const localBox = this.#getRectBoundingBox(width, height, contextState);
        const rotatedLocalBox = this.#rotateBoundingBox(localBox, contextState.rotation);
        const rotatedBox = this.#offsetBoundingBox(rotatedLocalBox, offsetX, offsetY);
        this.#applyClip(rotatedBox, contextState);
        if (this.#clearBoundingBoxOnDraw) {
            this.#clearBoundingBox(rotatedBox, contextState);
        }
        this.#transformContext(offsetX, offsetY, contextState.rotation);
        this.#applyRotationClip(localBox, contextState);
        const outerPadding = this.#getOuterPadding(contextState.lineWidth);
        const startX = localBox.x + outerPadding;
        const startY = localBox.y + outerPadding;
        this.context.beginPath();
        this.context.roundRect(startX, startY, width, height, borderRadius);
        this.context.fill();
        if (contextState.lineWidth > 0) {
            this.context.stroke();
        }
        this.#restore();
    }
    async drawRoundRect(offsetX, offsetY, width, height, borderRadius, sendImmediately) {
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawRoundRectToCanvas(offsetX, offsetY, width, height, borderRadius, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawRoundRect(offsetX, offsetY, width, height, borderRadius, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #getCircleBoundingBox(radius, contextState) {
        const diameter = radius * 2;
        return this.#getRectBoundingBox(diameter, diameter, contextState);
    }
    #drawCircleToCanvas(offsetX, offsetY, radius, contextState) {
        this.#drawArcEllipseToCanvas(offsetX, offsetY, radius, radius, 0, 360, false, contextState);
    }
    async drawCircle(offsetX, offsetY, radius, sendImmediately) {
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawCircleToCanvas(offsetX, offsetY, radius, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawCircle(offsetX, offsetY, radius, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #drawEllipseToCanvas(offsetX, offsetY, radiusX, radiusY, contextState) {
        this.#drawArcEllipseToCanvas(offsetX, offsetY, radiusX, radiusY, 0, 360, false, contextState);
    }
    async drawEllipse(offsetX, offsetY, radiusX, radiusY, sendImmediately) {
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawEllipseToCanvas(offsetX, offsetY, radiusX, radiusY, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawEllipse(offsetX, offsetY, radiusX, radiusY, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #getRegularPolygonBoundingBox(radius, numberOfSides, { lineWidth }) {
        let outerPadding = Math.ceil(lineWidth / 2);
        const shapeFactor = 1 / Math.cos(Math.PI / numberOfSides);
        outerPadding = Math.ceil(outerPadding * shapeFactor);
        const diameter = radius * 2;
        const regularPolygonBoundingBox = {
            x: -radius - outerPadding,
            y: -radius - outerPadding,
            width: diameter + outerPadding * 2,
            height: diameter + outerPadding * 2,
        };
        return regularPolygonBoundingBox;
    }
    #drawRegularPolygonToCanvas(offsetX, offsetY, radius, numberOfSides, contextState) {
        this.#updateContext(contextState);
        this.#save();
        const localBox = this.#getRegularPolygonBoundingBox(radius, numberOfSides, contextState);
        const rotatedLocalBox = this.#rotateBoundingBox(localBox, contextState.rotation);
        const rotatedBox = this.#offsetBoundingBox(rotatedLocalBox, offsetX, offsetY);
        this.#applyClip(rotatedBox, contextState);
        if (this.#clearBoundingBoxOnDraw) {
            this.#clearBoundingBox(rotatedBox, contextState);
        }
        this.#transformContext(offsetX, offsetY, contextState.rotation);
        this.#applyRotationClip(localBox, contextState);
        this.context.beginPath();
        const angleStep = (Math.PI * 2) / numberOfSides;
        for (let i = 0; i < numberOfSides; i++) {
            const angle = i * angleStep;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            if (i === 0) {
                this.context.moveTo(x, y);
            }
            else {
                this.context.lineTo(x, y);
            }
        }
        this.context.closePath();
        this.context.fill();
        if (contextState.lineWidth > 0) {
            this.context.stroke();
        }
        this.#restore();
    }
    async drawRegularPolygon(offsetX, offsetY, radius, numberOfSides, sendImmediately) {
        if (numberOfSides < 3) {
            _console$6.error(`invalid numberOfSides ${numberOfSides}`);
            return;
        }
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawRegularPolygonToCanvas(offsetX, offsetY, radius, numberOfSides, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawRegularPolygon(offsetX, offsetY, radius, numberOfSides, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #getPointsBoundingBox(points, { lineWidth, verticalAlignment, horizontalAlignment }, applyLineWidth = true, applyAlignment = false) {
        const outerPadding = applyLineWidth ? this.#getOuterPadding(lineWidth) : 0;
        let minX = 0;
        let maxX = 0;
        let minY = 0;
        let maxY = 0;
        points.forEach((point, index) => {
            if (index == 0) {
                minX = maxX = point.x;
                minY = maxY = point.y;
            }
            else {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            }
        });
        const pointsBoundingBox = {
            x: minX - outerPadding,
            y: minY - outerPadding,
            width: maxX - minX + outerPadding * 2,
            height: maxY - minY + outerPadding * 2,
        };
        if (applyAlignment) {
            assertValidAlignment(horizontalAlignment);
            assertValidAlignment(verticalAlignment);
            switch (horizontalAlignment) {
                case "start":
                    pointsBoundingBox.x = 0;
                    break;
                case "center":
                    break;
                case "end":
                    pointsBoundingBox.x = -pointsBoundingBox.width;
                    break;
            }
            switch (verticalAlignment) {
                case "start":
                    pointsBoundingBox.y = 0;
                    break;
                case "center":
                    break;
                case "end":
                    pointsBoundingBox.y = -pointsBoundingBox.height;
                    break;
            }
        }
        return pointsBoundingBox;
    }
    #alignBoundingBox(boundingBox, { verticalAlignment, horizontalAlignment }) {
        const alignedBoundingBox = structuredClone(boundingBox);
        assertValidAlignment(horizontalAlignment);
        assertValidAlignment(verticalAlignment);
        switch (horizontalAlignment) {
            case "start":
                alignedBoundingBox.x = 0;
                break;
            case "center":
                break;
            case "end":
                alignedBoundingBox.x = -alignedBoundingBox.width;
                break;
        }
        switch (verticalAlignment) {
            case "start":
                alignedBoundingBox.y = 0;
                break;
            case "center":
                break;
            case "end":
                alignedBoundingBox.y = -alignedBoundingBox.height;
                break;
        }
        return alignedBoundingBox;
    }
    #drawPolygonToCanvas(offsetX, offsetY, points, contextState) {
        this.#updateContext(contextState);
        this.#save();
        const centeredLocalBox = this.#getPointsBoundingBox(points, contextState, true, false);
        const localBox = this.#alignBoundingBox(centeredLocalBox, contextState);
        const rotatedLocalBox = this.#rotateBoundingBox(localBox, contextState.rotation);
        const rotatedBox = this.#offsetBoundingBox(rotatedLocalBox, offsetX, offsetY);
        this.#applyClip(rotatedBox, contextState);
        if (this.#clearBoundingBoxOnDraw) {
            this.#clearBoundingBox(rotatedBox, contextState);
        }
        this.#transformContext(offsetX, offsetY, contextState.rotation);
        this.#applyRotationClip(localBox, contextState);
        this.context.translate(localBox.x - centeredLocalBox.x, localBox.y - centeredLocalBox.y);
        this.context.beginPath();
        points.forEach((point, index) => {
            if (index == 0) {
                this.context.moveTo(point.x, point.y);
            }
            else {
                this.context.lineTo(point.x, point.y);
            }
        });
        this.context.closePath();
        this.context.fill();
        if (contextState.lineWidth > 0) {
            this.context.stroke();
        }
        this.#restore();
    }
    async drawPolygon(points, sendImmediately) {
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawPolygonToCanvas(0, 0, points, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawPolygon(points, sendImmediately);
        }
    }
    #getWireframeBoundingBox({ edges, points }, contextState) {
        const segments = [];
        edges.forEach((edge) => {
            const { startIndex, endIndex } = edge;
            const point = points[startIndex];
            const nextPoint = points[endIndex];
            segments.push({ start: point, end: nextPoint });
        });
        return this.#_getSegmentsBoundingBox(segments, contextState);
    }
    #drawWireframeToCanvas(wireframe, contextState) {
        _console$6.log("drawWireframeToCanvas", wireframe);
        this.#updateContext(contextState);
        this.#save();
        const box = this.#getWireframeBoundingBox(wireframe, contextState);
        if (this.#clearBoundingBoxOnDraw) {
            this.#clearBoundingBox(box, contextState);
        }
        const { points, edges } = wireframe;
        this.#clearBoundingBoxOnDraw = false;
        edges.forEach((edge) => {
            const { startIndex, endIndex } = edge;
            const startPoint = points[startIndex];
            const endPoint = points[endIndex];
            this.#drawSegmentToCanvas(startPoint.x, startPoint.y, endPoint.x, endPoint.y, contextState, false);
        });
        this.#clearBoundingBoxOnDraw = true;
        this.#restore();
    }
    async drawWireframe(wireframe, sendImmediately) {
        wireframe = trimWireframe(wireframe);
        if (wireframe.points.length == 0) {
            return;
        }
        assertValidWireframe(wireframe);
        if (this.#contextStateHelper.isSegmentUniform) {
            const polygon = isWireframePolygon(wireframe);
            if (polygon) {
                return this.drawSegments(polygon, sendImmediately);
            }
        }
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawWireframeToCanvas(wireframe, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawWireframe(wireframe, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #appendCurvePoint(curvePoints, curvePoint) {
        if (curvePoints.length >= maxNumberOfDisplayCurvePoints) {
            _console$6.warn(`numberOfDisplayCurvePoints ${curvePoints.length} exceeded (max ${maxNumberOfDisplayCurvePoints})`);
        }
        else {
            curvePoints.push(curvePoint);
        }
    }
    #appendCurvePoints(curvePoints, _curvePoints) {
        _curvePoints.forEach((curvePoint) => {
            this.#appendCurvePoint(curvePoints, curvePoint);
        });
    }
    #generateQuadraticCurvePoints(controlPoints) {
        assertValidNumberOfControlPoints("quadratic", controlPoints);
        const [p0, p1, p2] = controlPoints;
        {
            const curvePoints = [];
            const p01 = getVector2Midpoint(p0, p1);
            const p12 = getVector2Midpoint(p1, p2);
            const mid = getVector2Midpoint(p01, p12);
            const d2 = getVector2DistanceSquared(p1, mid);
            if (d2 <= displayCurveToleranceSquared) {
                curvePoints.push(p2);
            }
            else {
                curvePoints.push(...this.#generateQuadraticCurvePoints([p0, p01, mid]));
                curvePoints.push(...this.#generateQuadraticCurvePoints([mid, p12, p2]));
            }
            return curvePoints;
        }
    }
    #appendQuadraticCurvePoints(curvePoints, controlPoints) {
        this.#appendCurvePoints(curvePoints, this.#generateQuadraticCurvePoints(controlPoints));
    }
    #generateCubicCurvePoints(controlPoints) {
        assertValidNumberOfControlPoints("cubic", controlPoints);
        const [p0, p1, p2, p3] = controlPoints;
        const curvePoints = [];
        const p01 = getVector2Midpoint(p0, p1);
        const p12 = getVector2Midpoint(p1, p2);
        const p23 = getVector2Midpoint(p2, p3);
        const p012 = getVector2Midpoint(p01, p12);
        const p123 = getVector2Midpoint(p12, p23);
        const mid = getVector2Midpoint(p012, p123);
        const d2a = getVector2DistanceSquared(p1, mid);
        const d2b = getVector2DistanceSquared(p2, mid);
        if (d2a <= displayCurveToleranceSquared &&
            d2b <= displayCurveToleranceSquared) {
            curvePoints.push(p3);
        }
        else {
            curvePoints.push(...this.#generateCubicCurvePoints([p0, p01, p012, mid]));
            curvePoints.push(...this.#generateCubicCurvePoints([mid, p123, p23, p3]));
        }
        return curvePoints;
    }
    #appendCubicCurvePoints(curvePoints, controlPoints) {
        this.#appendCurvePoints(curvePoints, this.#generateCubicCurvePoints(controlPoints));
    }
    #generateGenericCurvePoints(curveType, controlPoints, isStart) {
        assertValidNumberOfControlPoints(curveType, controlPoints);
        let curvePoints = [];
        if (isStart) {
            this.#appendCurvePoint(curvePoints, controlPoints[0]);
        }
        switch (curveType) {
            case "segment":
                this.#appendCurvePoint(curvePoints, controlPoints[1]);
                break;
            case "quadratic":
                this.#appendQuadraticCurvePoints(curvePoints, controlPoints);
                break;
            case "cubic":
                this.#appendCubicCurvePoints(curvePoints, controlPoints);
                break;
        }
        return curvePoints;
    }
    #appendGenericCurvePoints(curvePoints, curveType, controlPoints, isStart) {
        const _curvePoints = this.#generateGenericCurvePoints(curveType, controlPoints, isStart);
        this.#appendCurvePoints(curvePoints, _curvePoints);
    }
    #drawCurveToCanvas(curveType, controlPoints, contextState) {
        const curvePoints = this.#generateGenericCurvePoints(curveType, controlPoints, true);
        this.#drawSegmentsToCanvas(curvePoints, contextState);
    }
    async drawCurve(curveType, controlPoints, sendImmediately) {
        assertValidNumberOfControlPoints(curveType, controlPoints);
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawCurveToCanvas(curveType, controlPoints, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawCurve(curveType, controlPoints, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #drawCurvesToCanvas(curveType, controlPoints, contextState) {
        assertValidPathNumberOfControlPoints(curveType, controlPoints);
        const numberOfControlPoints = displayCurveTypeToNumberOfControlPoints[curveType];
        const curvePointsJump = numberOfControlPoints - 1;
        const numberOfCurves = (controlPoints.length - 1) / (numberOfControlPoints - 1);
        const curvePoints = [];
        let curvePointOffset = 0;
        for (let i = 0; i < numberOfCurves; i++) {
            const isStart = i == 0;
            this.#appendGenericCurvePoints(curvePoints, curveType, controlPoints.slice(curvePointOffset, curvePointOffset + numberOfControlPoints), isStart);
            curvePointOffset += curvePointsJump;
        }
        this.#drawSegmentsToCanvas(curvePoints, contextState);
    }
    async drawCurves(curveType, controlPoints, sendImmediately) {
        assertValidPathNumberOfControlPoints(curveType, controlPoints);
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawCurvesToCanvas(curveType, controlPoints, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawCurves(curveType, controlPoints, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    async drawQuadraticBezierCurve(controlPoints, sendImmediately) {
        await this.drawCurve("quadratic", controlPoints, sendImmediately);
    }
    async drawQuadraticBezierCurves(controlPoints, sendImmediately) {
        await this.drawCurves("quadratic", controlPoints, sendImmediately);
    }
    async drawCubicBezierCurve(controlPoints, sendImmediately) {
        await this.drawCurve("cubic", controlPoints, sendImmediately);
    }
    async drawCubicBezierCurves(controlPoints, sendImmediately) {
        await this.drawCurves("cubic", controlPoints, sendImmediately);
    }
    #drawPathToCanvas(isClosed, curves, contextState) {
        const curvePoints = [];
        let _controlPoints;
        curves.forEach((curve, index) => {
            const isStart = index == 0;
            const { type, controlPoints } = curve;
            if (isStart) {
                _controlPoints = controlPoints;
            }
            else {
                _controlPoints = [_controlPoints.at(-1), ...controlPoints];
            }
            this.#appendGenericCurvePoints(curvePoints, type, _controlPoints, isStart);
        });
        contextState.verticalAlignment = "center";
        contextState.horizontalAlignment = "center";
        if (isClosed) {
            this.#drawPolygonToCanvas(0, 0, curvePoints, contextState);
        }
        else {
            this.#drawSegmentsToCanvas(curvePoints, contextState);
        }
    }
    async _drawPath(isClosed, curves, sendImmediately) {
        assertValidPath(curves);
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawPathToCanvas(isClosed, curves, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager._drawPath(isClosed, curves, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    async drawPath(curves, sendImmediately) {
        await this._drawPath(false, curves, sendImmediately);
    }
    async drawClosedPath(curves, sendImmediately) {
        await this._drawPath(true, curves, sendImmediately);
    }
    #getLocalSegmentBoundingBox(startX, startY, endX, endY, { lineWidth, segmentStartRadius, segmentEndRadius, segmentStartCap, segmentEndCap, }) {
        const outerPadding = this.#getOuterPadding(lineWidth);
        const dx = endX - startX;
        const dy = endY - startY;
        const length = Math.sqrt(dx * dx + dy * dy);
        const maxRadius = Math.max(segmentStartRadius, segmentEndRadius) + outerPadding;
        const width = maxRadius * 2;
        let height = length;
        height += outerPadding * 2;
        if (segmentStartCap == "round") {
            height += segmentStartRadius;
        }
        if (segmentEndCap == "round") {
            height += segmentEndRadius;
        }
        let y = -outerPadding;
        if (segmentStartCap == "round") {
            y -= segmentStartRadius;
        }
        const box = {
            x: -maxRadius,
            y,
            height,
            width,
        };
        return box;
    }
    #getSegmentBoundingBox(startX, startY, endX, endY, contextState) {
        const localBox = this.#getLocalSegmentBoundingBox(startX, startY, endX, endY, contextState);
        const dx = endX - startX;
        const dy = endY - startY;
        const angle = Math.atan2(dy, dx) - Math.PI / 2;
        const rotatedBox = this.#rotateBoundingBox(localBox, angle);
        const offsetBox = this.#offsetBoundingBox(rotatedBox, startX, startY);
        return offsetBox;
    }
    #drawSegmentToCanvas(startX, startY, endX, endY, contextState, clearBoundingBox = true) {
        this.#updateContext(contextState);
        const dx = endX - startX;
        const dy = endY - startY;
        const length = Math.sqrt(dx * dx + dy * dy);
        const rotation = Math.atan2(dy, dx) - Math.PI / 2;
        if (length == 0) {
            return;
        }
        this.#save();
        const localBox = this.#getLocalSegmentBoundingBox(startX, startY, endX, endY, contextState);
        const rotatedLocalBox = this.#rotateBoundingBox(localBox, rotation);
        const rotatedBox = this.#offsetBoundingBox(rotatedLocalBox, startX, startY);
        this.#applyClip(rotatedBox, contextState);
        if (this.#clearBoundingBoxOnDraw && clearBoundingBox) {
            this.#clearBoundingBox(rotatedBox, contextState);
        }
        this.#translateContext(startX, startY);
        this.#rotateContext(rotation);
        this.#applyRotationClip(localBox, contextState);
        const x0 = 0;
        const x1 = 0;
        const y0 = 0;
        const y1 = length;
        const r0 = contextState.segmentStartRadius;
        const r1 = contextState.segmentEndRadius;
        if (contextState.segmentStartCap == "round") {
            this.context.beginPath();
            this.context.arc(x0, y0, r0, 0, Math.PI * 2);
            this.context.closePath();
            this.context.fill();
            if (contextState.lineWidth > 0) {
                this.context.stroke();
            }
        }
        if (contextState.segmentEndCap == "round") {
            this.context.beginPath();
            this.context.arc(x1, y1, r1, 0, Math.PI * 2);
            this.context.closePath();
            this.context.fill();
            if (contextState.lineWidth > 0) {
                this.context.stroke();
            }
        }
        this.context.beginPath();
        this.context.moveTo(r0, 0);
        this.context.lineTo(-r0, 0);
        this.context.lineTo(-r1, length);
        this.context.lineTo(r1, length);
        this.context.closePath();
        this.context.fill();
        if (contextState.lineWidth > 0) {
            this.context.beginPath();
            this.context.moveTo(r0, 0);
            if (contextState.segmentStartCap === "flat") {
                this.context.lineTo(-r0, 0);
            }
            else {
                this.context.moveTo(-r0, 0);
            }
            this.context.lineTo(-r1, length);
            if (contextState.segmentEndCap === "flat") {
                this.context.lineTo(r1, length);
            }
            else {
                this.context.moveTo(r1, length);
            }
            this.context.lineTo(r0, 0);
            if (contextState.segmentStartCap === "flat") {
                this.context.closePath();
            }
            this.context.stroke();
        }
        this.#restore();
    }
    async drawSegment(startX, startY, endX, endY, sendImmediately) {
        if (startX == endX && startY == endY) {
            _console$6.error(`cannot draw segment of length 0`);
            return;
        }
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawSegmentToCanvas(startX, startY, endX, endY, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawSegment(startX, startY, endX, endY, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #getSegmentsBoundingBox(points, contextState) {
        const segments = [];
        points.forEach((point, index) => {
            if (index == points.length - 1) {
                return;
            }
            const nextPoint = points[index + 1];
            segments.push({ start: point, end: nextPoint });
        });
        return this.#_getSegmentsBoundingBox(segments, contextState);
    }
    #_getSegmentsBoundingBox(segments, { lineWidth, segmentStartRadius, segmentEndRadius }) {
        const outerPadding = Math.ceil(lineWidth / 2);
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        segments.forEach((segment, index) => {
            const startX = segment.start.x;
            const startY = segment.start.y;
            const endX = segment.end.x;
            const endY = segment.end.y;
            if (index == 0) {
                minX = Math.min(startX - segmentStartRadius, endX - segmentEndRadius);
                maxX = Math.max(startX + segmentStartRadius, endX + segmentEndRadius);
                minY = Math.min(startY - segmentStartRadius, endY - segmentEndRadius);
                maxY = Math.max(endY + segmentStartRadius, endY + segmentEndRadius);
            }
            else {
                minX = Math.min(minX, Math.min(startX - segmentStartRadius, endX - segmentEndRadius));
                maxX = Math.max(maxX, Math.max(startX + segmentStartRadius, endX + segmentEndRadius));
                minY = Math.min(minY, Math.min(startY - segmentStartRadius, endY - segmentEndRadius));
                maxY = Math.max(maxY, Math.max(endY + segmentStartRadius, endY + segmentEndRadius));
            }
        });
        const segmentsBoundingBox = {
            x: minX - outerPadding,
            y: minY - outerPadding,
            width: maxX - minX + outerPadding * 2,
            height: maxY - minY + outerPadding * 2,
        };
        return segmentsBoundingBox;
    }
    #drawSegmentsToCanvas(points, contextState) {
        this.#updateContext(contextState);
        this.#save();
        const box = this.#getSegmentsBoundingBox(points, contextState);
        if (this.#clearBoundingBoxOnDraw) {
            this.#clearBoundingBox(box, contextState);
        }
        const clearBoundingBoxOnDraw = this.#clearBoundingBoxOnDraw;
        this.#clearBoundingBoxOnDraw = false;
        points.forEach((point, index) => {
            if (index > 0) {
                const previousPoint = points[index - 1];
                const startX = previousPoint.x;
                const startY = previousPoint.y;
                const endX = point.x;
                const endY = point.y;
                this.#drawSegmentToCanvas(startX, startY, endX, endY, contextState, false);
            }
        });
        this.#clearBoundingBoxOnDraw = clearBoundingBoxOnDraw;
        this.#restore();
    }
    async drawSegments(points, sendImmediately) {
        _console$6.assertRangeWithError("numberOfPoints", points.length, 2, 255);
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawSegmentsToCanvas(points, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawSegments(points, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #drawArcToCanvas(offsetX, offsetY, radius, startAngle, angleOffset, isRadians, contextState) {
        this.#drawArcEllipseToCanvas(offsetX, offsetY, radius, radius, startAngle, angleOffset, isRadians, contextState);
    }
    async drawArc(offsetX, offsetY, radius, startAngle, angleOffset, isRadians, sendImmediately) {
        startAngle = isRadians ? startAngle : degToRad(startAngle);
        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawArcToCanvas(offsetX, offsetY, radius, startAngle, angleOffset, true, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawArc(offsetX, offsetY, radius, startAngle, angleOffset, true, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #drawArcEllipseToCanvas(offsetX, offsetY, radiusX, radiusY, startAngle, angleOffset, isRadians, contextState) {
        startAngle = isRadians ? startAngle : degToRad(startAngle);
        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);
        isRadians = true;
        this.#updateContext(contextState);
        this.#save();
        const localBox = this.#getRectBoundingBox(radiusX * 2, radiusY * 2, contextState);
        const rotatedLocalBox = this.#rotateBoundingBox(localBox, contextState.rotation);
        const rotatedBox = this.#offsetBoundingBox(rotatedLocalBox, offsetX, offsetY);
        this.#applyClip(rotatedBox, contextState);
        if (this.#clearBoundingBoxOnDraw) {
            this.#clearBoundingBox(rotatedBox, contextState);
        }
        this.#transformContext(offsetX, offsetY, contextState.rotation);
        this.#applyRotationClip(localBox, contextState);
        const outerPadding = this.#getOuterPadding(contextState.lineWidth);
        const startX = localBox.x + outerPadding;
        const startY = localBox.y + outerPadding;
        const centerX = startX + radiusX;
        const centerY = startY + radiusY;
        this.context.beginPath();
        this.context.moveTo(centerX, centerY);
        const clockwise = angleOffset > 0;
        const endAngle = startAngle + angleOffset;
        this.context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle, !clockwise);
        this.context.closePath();
        this.context.fill();
        if (contextState.lineWidth > 0) {
            this.context.beginPath();
            this.context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle, !clockwise);
            this.context.stroke();
        }
        this.#restore();
    }
    async drawArcEllipse(offsetX, offsetY, radiusX, radiusY, startAngle, angleOffset, isRadians, sendImmediately) {
        startAngle = isRadians ? startAngle : degToRad(startAngle);
        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);
        isRadians = true;
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawArcEllipseToCanvas(offsetX, offsetY, radiusX, radiusY, startAngle, angleOffset, true, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawArcEllipse(offsetX, offsetY, radiusX, radiusY, startAngle, angleOffset, true, sendImmediately);
        }
    }
    #bitmapCanvas = document.createElement("canvas");
    #bitmapContext;
    async #drawBitmapToCanvas(offsetX, offsetY, bitmap, contextState) {
        this.#updateContext(contextState);
        const { bitmapScaleX, bitmapScaleY } = contextState;
        const width = bitmap.width * Math.abs(bitmapScaleX);
        const height = bitmap.height * Math.abs(bitmapScaleY);
        this.#save();
        const localBox = this.#getRectBoundingBox(width, height, contextState, false);
        const rotatedLocalBox = this.#rotateBoundingBox(localBox, contextState.rotation);
        const rotatedBox = this.#offsetBoundingBox(rotatedLocalBox, offsetX, offsetY);
        this.#applyClip(rotatedBox, contextState);
        if (this.#clearBoundingBoxOnDraw) {
            this.#clearBoundingBox(rotatedBox, contextState);
        }
        this.#transformContext(offsetX, offsetY, contextState.rotation);
        this.#applyRotationClip(localBox, contextState);
        this.#bitmapCanvas.width = bitmap.width;
        this.#bitmapCanvas.height = bitmap.height;
        const bitmapImageData = this.#bitmapContext.createImageData(bitmap.width, bitmap.height);
        const rawBitmapImageData = bitmapImageData.data;
        const startX = localBox.x;
        const startY = localBox.y;
        bitmap.pixels.forEach((pixel, pixelIndex) => {
            let colorIndex = contextState.bitmapColorIndices[pixel];
            if (this.#useSpriteColorIndices) {
                colorIndex = contextState.spriteColorIndices[colorIndex];
            }
            const color = hexToRGB(this.colors[colorIndex]);
            const opacity = this.#getColorOpacity(colorIndex);
            const imageDataOffset = pixelIndex * 4;
            rawBitmapImageData[imageDataOffset + 0] = color.r;
            rawBitmapImageData[imageDataOffset + 1] = color.g;
            rawBitmapImageData[imageDataOffset + 2] = color.b;
            rawBitmapImageData[imageDataOffset + 3] = Math.floor(opacity * 255);
        });
        this.#bitmapContext.putImageData(bitmapImageData, 0, 0);
        this.#context.scale(Math.sign(bitmapScaleX), Math.sign(bitmapScaleY));
        this.#context.drawImage(this.#bitmapCanvas, startX, startY, width, height);
        this.#restore();
    }
    assertValidNumberOfColors(numberOfColors) {
        _console$6.assertRangeWithError("numberOfColors", numberOfColors, 2, this.numberOfColors);
    }
    assertValidBitmap(bitmap) {
        this.assertValidNumberOfColors(bitmap.numberOfColors);
        assertValidBitmapPixels(bitmap);
    }
    async drawBitmap(offsetX, offsetY, bitmap, sendImmediately) {
        this.assertValidBitmap(bitmap);
        const contextState = structuredClone(this.contextState);
        this.#rearDrawStack.push(() => this.#drawBitmapToCanvas(offsetX, offsetY, bitmap, contextState));
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawBitmap(offsetX, offsetY, bitmap, sendImmediately);
        }
    }
    #spriteSheets = {};
    #spriteSheetIndices = {};
    get spriteSheets() {
        return this.#spriteSheets;
    }
    get spriteSheetIndices() {
        return this.#spriteSheetIndices;
    }
    async uploadSpriteSheet(spriteSheet) {
        spriteSheet = structuredClone(spriteSheet);
        if (!this.#spriteSheets[spriteSheet.name]) {
            this.#spriteSheetIndices[spriteSheet.name] = Object.keys(this.#spriteSheets).length;
        }
        this.#spriteSheets[spriteSheet.name] = spriteSheet;
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.uploadSpriteSheet(spriteSheet);
        }
    }
    async uploadSpriteSheets(spriteSheets) {
        for (const spriteSheet of spriteSheets) {
            _console$6.log(`uploading spriteSheet "${spriteSheet.name}"...`);
            await this.uploadSpriteSheet(spriteSheet);
        }
    }
    assertLoadedSpriteSheet(spriteSheetName) {
        assertLoadedSpriteSheet(this, spriteSheetName);
    }
    assertSelectedSpriteSheet(spriteSheetName) {
        assertSelectedSpriteSheet(this, spriteSheetName);
    }
    assertAnySelectedSpriteSheet() {
        assertAnySelectedSpriteSheet(this);
    }
    assertSprite(spriteName) {
        return assertSprite(this, spriteName);
    }
    getSprite(spriteName) {
        return getSprite(this, spriteName);
    }
    getSpriteSheetPalette(paletteName) {
        return getSpriteSheetPalette(this, paletteName);
    }
    getSpriteSheetPaletteSwap(paletteSwapName) {
        return getSpriteSheetPaletteSwap(this, paletteSwapName);
    }
    getSpritePaletteSwap(spriteName, paletteSwapName) {
        return getSpritePaletteSwap(this, spriteName, paletteSwapName);
    }
    get selectedSpriteSheet() {
        if (this.contextState.spriteSheetName) {
            return this.#spriteSheets[this.contextState.spriteSheetName];
        }
    }
    get selectedSpriteSheetName() {
        return this.selectedSpriteSheet?.name;
    }
    async selectSpriteSheet(spriteSheetName, sendImmediately) {
        this.assertLoadedSpriteSheet(spriteSheetName);
        const differences = this.#contextStateHelper.update({
            spriteSheetName,
        });
        if (this.device?.isConnected && !this.#ignoreDevice) {
            this.deviceDisplayManager.selectSpriteSheet(spriteSheetName, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#onContextStateUpdate(differences);
    }
    #runSpriteCommand(command, contextState) {
        if (command.type == "drawSprite") {
            const spriteSheet = this.spriteSheets[contextState.spriteSheetName];
            const sprite = spriteSheet.sprites[command.spriteIndex];
            if (sprite) {
                _console$6.log("drawing sub sprite", sprite);
                const _contextState = structuredClone(this.contextState);
                this.#saveContextForSprite(command.offsetX, command.offsetY, sprite, _contextState);
                sprite.commands.forEach((command) => {
                    this.#runSpriteCommand(command, _contextState);
                });
                this.#restoreContextForSprite();
            }
            else {
                _console$6.error(`sprite index ${command.spriteIndex} not found in spriteSheet`);
            }
        }
        else {
            this.runContextCommand(command);
        }
    }
    #drawSpriteToCanvas(offsetX, offsetY, sprite, contextState) {
        this.#setIgnoreDevice(true);
        this.#saveContextForSprite(offsetX, offsetY, sprite, contextState);
        this.#setUseSpriteColorIndices(true);
        this.#setClearCanvasBoundingBoxOnDraw(false);
        sprite.commands.forEach((command) => {
            this.#runSpriteCommand(command, contextState);
        });
        this.#setIgnoreDevice(false);
        this.#restoreContextForSprite();
        this.#setUseSpriteColorIndices(false);
        this.#setClearCanvasBoundingBoxOnDraw(true);
    }
    async drawSprite(offsetX, offsetY, spriteName, sendImmediately) {
        _console$6.assertWithError(this.selectedSpriteSheet, "no spriteSheet selected");
        let sprite = this.selectedSpriteSheet?.sprites.find((sprite) => sprite.name == spriteName);
        _console$6.assertWithError(sprite, `sprite "${spriteName}" not found`);
        _console$6.assertWithError("width" in sprite, "sprite has no width");
        _console$6.assertWithError("height" in sprite, "sprite has no height");
        const contextState = structuredClone(this.contextState);
        this.#drawSpriteToCanvas(offsetX, offsetY, sprite, contextState);
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawSprite(offsetX, offsetY, spriteName, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #drawSpritesToCanvas(offsetX, offsetY, spriteLines, contextState) {
        const { expandedSpritesLines, lineBreadths, localSize, size } = getSpriteLinesMetrics(spriteLines, this.#spriteSheets, contextState);
        const isSpritesDirectionPositive = isDirectionPositive(contextState.spritesDirection);
        const isSpritesLineDirectionPositive = isDirectionPositive(contextState.spritesLineDirection);
        const isSpritesDirectionHorizontal = isDirectionHorizontal(contextState.spritesDirection);
        const isSpritesLineDirectionHorizontal = isDirectionHorizontal(contextState.spritesLineDirection);
        const areSpritesDirectionsOrthogonal = isSpritesDirectionHorizontal != isSpritesLineDirectionHorizontal;
        const breadthSizeKey = isSpritesDirectionHorizontal ? "width" : "height";
        const spritesBreadthSign = isSpritesDirectionPositive ? 1 : -1;
        const spritesDepthSign = isSpritesLineDirectionPositive ? 1 : -1;
        this.#setIgnoreDevice(true);
        this.#setCanvasContextTransform(offsetX, offsetY, localSize.width, localSize.height, contextState);
        this.#setUseSpriteColorIndices(true);
        this.#setClearCanvasBoundingBoxOnDraw(false);
        this.#saveContext();
        this.clearCrop();
        this.clearRotation();
        this.clearRotationCrop();
        this.resetSpriteScale();
        if (isSpritesDirectionHorizontal) {
            if (isSpritesDirectionPositive) {
                this.setHorizontalAlignment("start");
            }
            else {
                this.setHorizontalAlignment("end");
            }
        }
        else {
            if (isSpritesDirectionPositive) {
                this.setVerticalAlignment("start");
            }
            else {
                this.setVerticalAlignment("end");
            }
        }
        if (areSpritesDirectionsOrthogonal) {
            if (isSpritesLineDirectionHorizontal) {
                if (isSpritesLineDirectionPositive) {
                    this.setHorizontalAlignment("start");
                }
                else {
                    this.setHorizontalAlignment("end");
                }
            }
            else {
                if (isSpritesLineDirectionPositive) {
                    this.setVerticalAlignment("start");
                }
                else {
                    this.setVerticalAlignment("end");
                }
            }
        }
        else {
            if (isSpritesDirectionHorizontal) {
                this.setVerticalAlignment("start");
            }
            else {
                this.setHorizontalAlignment("start");
            }
        }
        let spritesBreadthStart = 0;
        switch (contextState.spritesDirection) {
            case "right":
                spritesBreadthStart = -localSize.width / 2;
                break;
            case "left":
                spritesBreadthStart = localSize.width / 2;
                break;
            case "up":
                spritesBreadthStart = localSize.height / 2;
                break;
            case "down":
                spritesBreadthStart = -localSize.height / 2;
                break;
        }
        const spriteOffset = {
            x: 0,
            y: 0,
        };
        const breadthOffsetKey = isSpritesDirectionHorizontal ? "x" : "y";
        const depthOffsetKey = isSpritesLineDirectionHorizontal ? "x" : "y";
        const signedSpritesSpacing = spritesBreadthSign * contextState.spritesSpacing;
        const signedSpriteLineSpacing = spritesDepthSign * contextState.spritesLineSpacing;
        const signedSpriteLineHeight = spritesDepthSign * contextState.spritesLineHeight;
        if (!areSpritesDirectionsOrthogonal) {
            spriteOffset[breadthOffsetKey] = spritesBreadthStart;
        }
        if (areSpritesDirectionsOrthogonal) {
            switch (contextState.spritesLineDirection) {
                case "right":
                    spriteOffset[depthOffsetKey] = -localSize.width / 2;
                    break;
                case "left":
                    spriteOffset[depthOffsetKey] = localSize.width / 2;
                    break;
                case "up":
                    spriteOffset[depthOffsetKey] = localSize.height / 2;
                    break;
                case "down":
                    spriteOffset[depthOffsetKey] = -localSize.height / 2;
                    break;
            }
        }
        else {
            switch (contextState.spritesDirection) {
                case "right":
                case "left":
                    spriteOffset.y = -localSize.height / 2;
                    break;
                case "up":
                case "down":
                    spriteOffset.x = -localSize.width / 2;
                    break;
            }
        }
        expandedSpritesLines.forEach((_spritesLine, lineIndex) => {
            const spritesLineBreadth = lineBreadths[lineIndex];
            if (areSpritesDirectionsOrthogonal) {
                switch (contextState.spritesLineAlignment) {
                    case "start":
                        spriteOffset[breadthOffsetKey] = spritesBreadthStart;
                        break;
                    case "center":
                        spriteOffset[breadthOffsetKey] =
                            spritesBreadthStart +
                                spritesBreadthSign *
                                    ((localSize[breadthSizeKey] - spritesLineBreadth) / 2);
                        break;
                    case "end":
                        spriteOffset[breadthOffsetKey] =
                            spritesBreadthStart +
                                spritesBreadthSign *
                                    (localSize[breadthSizeKey] - spritesLineBreadth);
                        break;
                }
            }
            _spritesLine.forEach((sprite) => {
                const _spriteOffset = {
                    x: spriteOffset.x,
                    y: spriteOffset.y,
                };
                const spriteAlignmentOffsetKey = isSpritesDirectionHorizontal
                    ? "y"
                    : "x";
                const spriteDepth = isSpritesDirectionHorizontal
                    ? sprite.height
                    : sprite.width;
                switch (contextState.spritesAlignment) {
                    case "start":
                        break;
                    case "center":
                        _spriteOffset[spriteAlignmentOffsetKey] +=
                            spritesDepthSign *
                                ((contextState.spritesLineHeight - spriteDepth) / 2);
                        break;
                    case "end":
                        _spriteOffset[spriteAlignmentOffsetKey] +=
                            spritesDepthSign * (contextState.spritesLineHeight - spriteDepth);
                        break;
                }
                const spriteContextState = structuredClone(this.contextState);
                this.#saveContextForSprite(_spriteOffset.x, _spriteOffset.y, sprite, spriteContextState);
                sprite.commands.forEach((command) => {
                    this.#runSpriteCommand(command, spriteContextState);
                });
                this.#restoreContextForSprite();
                spriteOffset[breadthOffsetKey] +=
                    spritesBreadthSign *
                        (isSpritesDirectionHorizontal ? sprite.width : sprite.height);
                spriteOffset[breadthOffsetKey] += signedSpritesSpacing;
            });
            spriteOffset[breadthOffsetKey] -= signedSpritesSpacing;
            if (areSpritesDirectionsOrthogonal) {
                spriteOffset[depthOffsetKey] += signedSpriteLineHeight;
            }
            spriteOffset[depthOffsetKey] += signedSpriteLineSpacing;
        });
        this.#resetCanvasContextTransform();
        this.#restoreContext();
        this.#setIgnoreDevice(false);
        this.#setUseSpriteColorIndices(false);
        this.#setClearCanvasBoundingBoxOnDraw(true);
    }
    async drawSprites(offsetX, offsetY, spriteLines, sendImmediately) {
        _console$6.assertWithError(this.contextState.spritesLineHeight > 0, `spritesLineHeight must be >0`);
        assertValidSpriteLines(this, spriteLines);
        const contextState = structuredClone(this.contextState);
        this.#drawSpritesToCanvas(offsetX, offsetY, spriteLines, contextState);
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.drawSprites(offsetX, offsetY, spriteLines, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    async drawSpriteFromSpriteSheet(offsetX, offsetY, spriteName, spriteSheet, paletteName, sendImmediately) {
        return drawSpriteFromSpriteSheet(this, offsetX, offsetY, spriteName, spriteSheet, paletteName, sendImmediately);
    }
    async drawSpritesString(offsetX, offsetY, string, requireAll, maxLineBreadth, separators, sendImmediately) {
        const spriteLines = this.stringToSpriteLines(string, requireAll, maxLineBreadth, separators);
        await this.drawSprites(offsetX, offsetY, spriteLines, sendImmediately);
    }
    stringToSpriteLines(string, requireAll, maxLineBreadth, separators) {
        return stringToSpriteLines(string, this.spriteSheets, this.contextState, requireAll, maxLineBreadth, separators);
    }
    stringToSpriteLinesMetrics(string, requireAll, maxLineBreadth, separators) {
        return stringToSpriteLinesMetrics(string, this.spriteSheets, this.contextState, requireAll, maxLineBreadth, separators);
    }
    #brightness = "medium";
    get brightness() {
        return this.#brightness;
    }
    #brightnessOpacities = {
        veryLow: 0.5,
        low: 0.7,
        medium: 0.9,
        high: 0.95,
        veryHigh: 1,
    };
    get #brightnessOpacity() {
        return this.#brightnessOpacities[this.brightness];
    }
    #didSetBrightness = false;
    #flushBrightness() {
        if (!this.#didSetBrightness) {
            return false;
        }
        _console$6.log("flushBrightness");
        this.#didSetBrightness = false;
        return true;
    }
    async setBrightness(newBrightness, sendImmediately) {
        if (this.#brightness == newBrightness) {
            return;
        }
        this.#brightness = newBrightness;
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.setBrightness(newBrightness, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
        this.#didSetBrightness = true;
        this.#dispatchEvent("brightness", { brightness: this.brightness });
    }
    async #resetBrightness() {
        await this.setBrightness("medium");
    }
    async #updateDeviceBrightness(sendImmediately) {
        if (!this.device?.isConnected) {
            return;
        }
        await this.device?.setDisplayBrightness(this.brightness, sendImmediately);
    }
    async #updateDeviceSpriteSheets() {
        if (!this.device?.isConnected) {
            return;
        }
        await this.uploadSpriteSheets(Object.values(this.spriteSheets));
    }
    async #updateDeviceSelectedSpriteSheet(sendImmediately) {
        if (!this.device?.isConnected) {
            return;
        }
        if (!this.selectedSpriteSheetName) {
            return;
        }
        _console$6.log("updateDeviceSelectedSpriteSheet");
        await this.device?.selectDisplaySpriteSheet(this.selectedSpriteSheetName, sendImmediately);
    }
    async runContextCommand(command, sendImmediately) {
        return runDisplayContextCommand(this, command, sendImmediately);
    }
    async runContextCommands(commands, sendImmediately) {
        return runDisplayContextCommands(this, commands, sendImmediately);
    }
    get #contextScale() {
        const transform = this.#context.getTransform();
        const scaleX = transform.a;
        const scaleY = transform.d;
        return { x: scaleX, y: scaleY };
    }
    #setCanvasContextTransform(offsetX, offsetY, width, height, contextState) {
        this.#rearDrawStack.push(() => {
            const scaledWidth = width * Math.abs(contextState.spriteScaleX);
            const scaledHeight = height * Math.abs(contextState.spriteScaleY);
            this.#save();
            const localBox = this.#getRectBoundingBox(scaledWidth, scaledHeight, contextState, false);
            const rotatedLocalBox = this.#rotateBoundingBox(localBox, contextState.rotation);
            const rotatedBox = this.#offsetBoundingBox(rotatedLocalBox, offsetX, offsetY);
            this.#applyClip(rotatedBox, contextState);
            if (this.#clearBoundingBoxOnDraw) {
                this.#clearBoundingBox(rotatedBox, contextState);
            }
            this.#transformContext(offsetX, offsetY, contextState.rotation);
            this.#applyRotationClip(localBox, contextState);
            this.#correctAlignmentTranslation(localBox, contextState);
            this.#scaleContext(contextState.spriteScaleX, contextState.spriteScaleY);
        });
    }
    #resetCanvasContextTransform() {
        this.#rearDrawStack.push(() => {
            this.#restore();
        });
    }
    #setClearCanvasBoundingBoxOnDraw(clearBoundingBoxOnDraw, override = false) {
        if (!override && this.#isDrawingBlankSprite) {
            return;
        }
        this.#clearBoundingBoxOnDraw = clearBoundingBoxOnDraw;
        this.#rearDrawStack.push(() => {
            this.#clearBoundingBoxOnDraw = clearBoundingBoxOnDraw;
        });
    }
    #ignoreDevice = false;
    #setIgnoreDevice(ignoreDevice) {
        this.#ignoreDevice = ignoreDevice;
        this.#rearDrawStack.push(() => {
            this.#ignoreDevice = ignoreDevice;
        });
    }
    #useSpriteColorIndices = false;
    #setUseSpriteColorIndices(useSpriteColorIndices, override = false) {
        if (!override && this.#useSpriteColorIndices) {
            return;
        }
        this.#rearDrawStack.push(() => {
            this.#useSpriteColorIndices = useSpriteColorIndices;
        });
    }
    #spriteContextStack = [];
    #spriteStack = [];
    #saveContextForSprite(offsetX, offsetY, sprite, contextState) {
        this.#setCanvasContextTransform(offsetX, offsetY, sprite.width, sprite.height, contextState);
        if ("name" in sprite) {
            _console$6.assertWithError(!this.#spriteStack.includes(sprite), `cyclical sprite ${sprite.name} found in stack`);
        }
        const spriteColorIndices = contextState.spriteColorIndices.slice();
        this.#spriteContextStack.push(contextState);
        this.#resetContextState();
        this.contextState.spriteColorIndices = spriteColorIndices;
    }
    #restoreContextForSprite() {
        this.#resetCanvasContextTransform();
        const contextState = this.#spriteContextStack.pop();
        if (!contextState) {
            _console$6.warn("#spriteContextStack empty");
            return;
        }
        this.#contextStateHelper.update(contextState);
    }
    #runPreviewSpriteCommand(command, spriteSheet) {
        if (command.type == "drawSprite") {
            const sprite = spriteSheet.sprites[command.spriteIndex];
            if (sprite) {
                _console$6.log("drawing sub sprite", sprite);
                const contextState = structuredClone(this.contextState);
                this.#saveContextForSprite(command.offsetX, command.offsetY, sprite, contextState);
                sprite.commands.forEach((command) => {
                    this.#runPreviewSpriteCommand(command, spriteSheet);
                });
                this.#restoreContextForSprite();
            }
            else {
                _console$6.error(`spriteIndex ${command.spriteIndex} not found in spriteSheet`);
            }
        }
        else {
            this.runContextCommand(command);
        }
    }
    previewSprite(offsetX, offsetY, sprite, spriteSheet) {
        this.#setIgnoreDevice(true);
        this.#setUseSpriteColorIndices(true);
        const contextState = structuredClone(this.contextState);
        this.#saveContextForSprite(offsetX, offsetY, sprite, contextState);
        this.#setClearCanvasBoundingBoxOnDraw(false);
        sprite.commands.forEach((command) => {
            this.#runPreviewSpriteCommand(command, spriteSheet);
        });
        this.#setIgnoreDevice(false);
        this.#restoreContextForSprite();
        this.#setUseSpriteColorIndices(false);
        this.#setClearCanvasBoundingBoxOnDraw(true);
    }
    previewSpriteCommands(commands) {
        this.#setIgnoreDevice(true);
        this.#setClearCanvasBoundingBoxOnDraw(false);
        commands.forEach((command) => {
            this.runContextCommand(command);
        });
        this.#setIgnoreDevice(false);
        this.#setClearCanvasBoundingBoxOnDraw(true);
    }
    assertSpriteSheetPalette(paletteName) {
        assertSpriteSheetPalette(this, paletteName);
    }
    assertSpriteSheetPaletteSwap(paletteSwapName) {
        assertSpriteSheetPaletteSwap(this, paletteSwapName);
    }
    assertSpritePaletteSwap(spriteName, paletteSwapName) {
        assertSpritePaletteSwap(this, spriteName, paletteSwapName);
    }
    async selectSpriteSheetPalette(paletteName, offset, indicesOnly, sendImmediately) {
        await selectSpriteSheetPalette(this, paletteName, offset, indicesOnly, sendImmediately);
    }
    async selectSpriteSheetPaletteSwap(paletteSwapName, offset, sendImmediately) {
        await selectSpriteSheetPaletteSwap(this, paletteSwapName, offset, sendImmediately);
    }
    async selectSpritePaletteSwap(spriteName, paletteSwapName, offset, sendImmediately) {
        await selectSpritePaletteSwap(this, spriteName, paletteSwapName, offset, sendImmediately);
    }
    #reset() {
        this.#useSpriteColorIndices = false;
        this.#clearBoundingBoxOnDraw = true;
        this.#ignoreDevice = false;
        this.#resetColors();
        this.#resetOpacities();
        this.#resetContextState();
        this.#resetBrightness();
        Object.keys(this.#spriteSheets).forEach((spriteSheetName) => delete this.#spriteSheets[spriteSheetName]);
        Object.keys(this.#spriteSheetIndices).forEach((spriteSheetName) => delete this.#spriteSheetIndices[spriteSheetName]);
        this.#isDrawingBlankSprite = false;
    }
    async imageToBitmap(image, width, height, numberOfColors) {
        return imageToBitmap(image, width, height, this.colors, this.bitmapColorIndices, numberOfColors);
    }
    async quantizeImage(image, width, height, numberOfColors) {
        return quantizeImage(image, width, height, numberOfColors);
    }
    async resizeAndQuantizeImage(image, width, height, numberOfColors, colors) {
        return resizeAndQuantizeImage(image, width, height, numberOfColors, colors);
    }
    serializeSpriteSheet(spriteSheet) {
        return serializeSpriteSheet(this, spriteSheet);
    }
    #startSprite(offsetX, offsetY, width, height, contextState) {
        this.#saveContextForSprite(offsetX, offsetY, { width, height }, contextState);
        this.#setUseSpriteColorIndices(true, true);
        this.#setClearCanvasBoundingBoxOnDraw(false, true);
    }
    #isDrawingBlankSprite = false;
    async startSprite(offsetX, offsetY, width, height, sendImmediately) {
        _console$6.assertWithError(!this.#isDrawingBlankSprite, `already drawing blank sprite`);
        this.#isDrawingBlankSprite = true;
        const contextState = structuredClone(this.contextState);
        this.#startSprite(offsetX, offsetY, width, height, contextState);
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.startSprite(offsetX, offsetY, width, height, sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
    #endSprite() {
        this.#restoreContextForSprite();
        this.#setUseSpriteColorIndices(false, true);
        this.#setClearCanvasBoundingBoxOnDraw(true, true);
    }
    async endSprite(sendImmediately) {
        _console$6.assertWithError(this.#isDrawingBlankSprite, `not drawing blank sprite`);
        this.#isDrawingBlankSprite = false;
        this.#endSprite();
        if (this.device?.isConnected && !this.#ignoreDevice) {
            await this.deviceDisplayManager.endSprite(sendImmediately);
        }
        else {
            if (sendImmediately) {
                this.#onSentContextCommands();
            }
        }
    }
}

const _console$5 = createConsole("DevicePairPressureSensorDataManager", {
    log: false,
});
class DevicePairPressureSensorDataManager {
    #rawPressure = {};
    #centerOfPressureHelper = new CenterOfPressureHelper();
    #normalizedSumRangeHelper = new RangeHelper();
    constructor() {
        this.resetPressureRange();
    }
    resetPressureRange() {
        this.#centerOfPressureHelper.reset();
        this.#normalizedSumRangeHelper.reset();
    }
    onDevicePressureData(event) {
        const { pressure } = event.message;
        const { side } = event.target;
        _console$5.log({ pressure, side });
        this.#rawPressure[side] = pressure;
        if (this.#hasAllPressureData) {
            return this.#updatePressureData();
        }
        else {
            _console$5.log("doesn't have all pressure data yet...");
        }
    }
    get #hasAllPressureData() {
        return Sides.every((side) => side in this.#rawPressure);
    }
    #updatePressureData() {
        const pressure = {
            scaledSum: 0,
            normalizedSum: 0,
            sensors: { left: [], right: [] },
        };
        Sides.forEach((side) => {
            const sidePressure = this.#rawPressure[side];
            pressure.scaledSum += sidePressure.scaledSum;
        });
        pressure.normalizedSum +=
            this.#normalizedSumRangeHelper.updateAndGetNormalization(pressure.scaledSum, false);
        if (pressure.scaledSum > 0) {
            pressure.center = { x: 0, y: 0 };
            Sides.forEach((side) => {
                const sidePressure = this.#rawPressure[side];
                {
                    sidePressure.sensors.forEach((sensor) => {
                        const _sensor = structuredClone(sensor);
                        _sensor.weightedValue = sensor.scaledValue / pressure.scaledSum;
                        let { x, y } = sensor.position;
                        x /= 2;
                        if (side == "right") {
                            x += 0.5;
                        }
                        _sensor.position = { x, y };
                        pressure.center.x += _sensor.position.x * _sensor.weightedValue;
                        pressure.center.y += _sensor.position.y * _sensor.weightedValue;
                        pressure.sensors[side].push(_sensor);
                    });
                }
            });
            pressure.normalizedCenter =
                this.#centerOfPressureHelper.updateAndGetNormalization(pressure.center, false);
        }
        _console$5.log({ devicePairPressure: pressure });
        return pressure;
    }
}

const _console$4 = createConsole("DevicePairSensorDataManager", { log: false });
const DevicePairSensorTypes = ["pressure", "sensorData"];
const DevicePairSensorDataEventTypes = DevicePairSensorTypes;
class DevicePairSensorDataManager {
    eventDispatcher;
    get dispatchEvent() {
        return this.eventDispatcher.dispatchEvent;
    }
    #timestamps = {};
    pressureSensorDataManager = new DevicePairPressureSensorDataManager();
    resetPressureRange() {
        this.pressureSensorDataManager.resetPressureRange();
    }
    onDeviceSensorData(event) {
        const { timestamp, sensorType } = event.message;
        _console$4.log({ sensorType, timestamp, event });
        if (!this.#timestamps[sensorType]) {
            this.#timestamps[sensorType] = {};
        }
        this.#timestamps[sensorType][event.target.side] = timestamp;
        let value;
        switch (sensorType) {
            case "pressure":
                value = this.pressureSensorDataManager.onDevicePressureData(event);
                break;
            default:
                _console$4.log(`uncaught sensorType "${sensorType}"`);
                break;
        }
        if (value) {
            const timestamps = Object.assign({}, this.#timestamps[sensorType]);
            this.dispatchEvent(sensorType, { sensorType, timestamps, [sensorType]: value });
            this.dispatchEvent("sensorData", { sensorType, timestamps, [sensorType]: value });
        }
        else {
            _console$4.log("no value received");
        }
    }
}

const _console$3 = createConsole("DevicePair", { log: false });
function getDevicePairDeviceEventType(deviceEventType) {
    return `device${capitalizeFirstCharacter(deviceEventType)}`;
}
const DevicePairDeviceEventTypes = DeviceEventTypes.map((eventType) => getDevicePairDeviceEventType(eventType));
const DevicePairConnectionEventTypes = ["isConnected"];
const DevicePairEventTypes = [
    ...DevicePairConnectionEventTypes,
    ...DevicePairSensorDataEventTypes,
    ...DevicePairDeviceEventTypes,
];
const DevicePairTypes = ["insoles", "gloves"];
class DevicePair {
    constructor(type) {
        this.#type = type;
        this.#sensorDataManager.eventDispatcher = this
            .#eventDispatcher;
    }
    get sides() {
        return Sides;
    }
    #type;
    get type() {
        return this.#type;
    }
    #eventDispatcher = new EventDispatcher(this, DevicePairEventTypes);
    get addEventListener() {
        return this.#eventDispatcher.addEventListener;
    }
    get #dispatchEvent() {
        return this.#eventDispatcher.dispatchEvent;
    }
    get removeEventListener() {
        return this.#eventDispatcher.removeEventListener;
    }
    get waitForEvent() {
        return this.#eventDispatcher.waitForEvent;
    }
    get removeEventListeners() {
        return this.#eventDispatcher.removeEventListeners;
    }
    get removeAllEventListeners() {
        return this.#eventDispatcher.removeAllEventListeners;
    }
    #left;
    get left() {
        return this.#left;
    }
    #right;
    get right() {
        return this.#right;
    }
    get isConnected() {
        return Sides.every((side) => this[side]?.isConnected);
    }
    get isPartiallyConnected() {
        return Sides.some((side) => this[side]?.isConnected);
    }
    get isHalfConnected() {
        return this.isPartiallyConnected && !this.isConnected;
    }
    #assertIsConnected() {
        _console$3.assertWithError(this.isConnected, "devicePair must be connected");
    }
    #isDeviceCorrectType(device) {
        switch (this.type) {
            case "insoles":
                return device.isInsole;
            case "gloves":
                return device.isGlove;
        }
    }
    assignDevice(device) {
        if (!this.#isDeviceCorrectType(device)) {
            _console$3.log(`device is incorrect type ${device.type} for ${this.type} devicePair`);
            return;
        }
        const side = device.side;
        const currentDevice = this[side];
        if (device == currentDevice) {
            _console$3.log("device already assigned");
            return;
        }
        if (currentDevice) {
            this.#removeDeviceEventListeners(currentDevice);
        }
        this.#addDeviceEventListeners(device);
        switch (side) {
            case "left":
                this.#left = device;
                break;
            case "right":
                this.#right = device;
                break;
        }
        _console$3.log(`assigned ${side} ${this.type} device`, device);
        this.resetPressureRange();
        this.#dispatchEvent("isConnected", { isConnected: this.isConnected });
        this.#dispatchEvent("deviceIsConnected", {
            device,
            isConnected: device.isConnected,
            side,
        });
        return currentDevice;
    }
    #addDeviceEventListeners(device) {
        addEventListeners(device, this.#boundDeviceEventListeners);
        DeviceEventTypes.forEach((deviceEventType) => {
            device.addEventListener(
            deviceEventType, this.#redispatchDeviceEvent.bind(this));
        });
    }
    #removeDeviceEventListeners(device) {
        removeEventListeners(device, this.#boundDeviceEventListeners);
        DeviceEventTypes.forEach((deviceEventType) => {
            device.removeEventListener(
            deviceEventType, this.#redispatchDeviceEvent.bind(this));
        });
    }
    #removeDevice(device) {
        const foundDevice = Sides.some((side) => {
            if (this[side] != device) {
                return false;
            }
            _console$3.log(`removing ${side} ${this.type} device`, device);
            removeEventListeners(device, this.#boundDeviceEventListeners);
            switch (side) {
                case "left":
                    this.#left = undefined;
                    break;
                case "right":
                    this.#right = undefined;
                    break;
            }
            return true;
        });
        if (foundDevice) {
            this.#dispatchEvent("isConnected", { isConnected: this.isConnected });
        }
        return foundDevice;
    }
    #boundDeviceEventListeners = {
        isConnected: this.#onDeviceIsConnected.bind(this),
        sensorData: this.#onDeviceSensorData.bind(this),
        getType: this.#onDeviceType.bind(this),
    };
    #redispatchDeviceEvent(deviceEvent) {
        const { type, target: device, message } = deviceEvent;
        this.#dispatchEvent(getDevicePairDeviceEventType(type), {
            ...message,
            device,
            side: device.side,
        });
    }
    #onDeviceIsConnected(deviceEvent) {
        this.#dispatchEvent("isConnected", { isConnected: this.isConnected });
    }
    #onDeviceType(deviceEvent) {
        const { target: device } = deviceEvent;
        if (this[device.side] == device) {
            return;
        }
        const foundDevice = this.#removeDevice(device);
        if (!foundDevice) {
            return;
        }
        this.assignDevice(device);
    }
    async setSensorConfiguration(sensorConfiguration) {
        for (let i = 0; i < Sides.length; i++) {
            const side = Sides[i];
            if (this[side]?.isConnected) {
                await this[side].setSensorConfiguration(sensorConfiguration);
            }
        }
    }
    #sensorDataManager = new DevicePairSensorDataManager();
    #onDeviceSensorData(deviceEvent) {
        if (this.isConnected) {
            this.#sensorDataManager.onDeviceSensorData(deviceEvent);
        }
    }
    resetPressureRange() {
        Sides.forEach((side) => this[side]?.resetPressureRange());
        this.#sensorDataManager.resetPressureRange();
    }
    async triggerVibration(vibrationConfigurations, sendImmediately) {
        const promises = Sides.map((side) => {
            return this[side]?.triggerVibration(vibrationConfigurations, sendImmediately);
        }).filter(Boolean);
        return Promise.allSettled(promises);
    }
    static #insoles = new DevicePair("insoles");
    static get insoles() {
        return this.#insoles;
    }
    static #gloves = new DevicePair("gloves");
    static get gloves() {
        return this.#gloves;
    }
    static {
        DeviceManager$1.AddEventListener("deviceConnected", (event) => {
            const { device } = event.message;
            if (device.isInsole) {
                this.#insoles.assignDevice(device);
            }
            if (device.isGlove) {
                this.#gloves.assignDevice(device);
            }
        });
    }
}

function throttle(fn, interval, trailing = false) {
    let lastTime = 0;
    let timeout = null;
    let lastArgs = null;
    return function (...args) {
        const now = Date.now();
        const remaining = interval - (now - lastTime);
        if (remaining <= 0) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            lastTime = now;
            fn(...args);
        }
        else if (trailing) {
            lastArgs = args;
            if (!timeout) {
                timeout = setTimeout(() => {
                    lastTime = Date.now();
                    timeout = null;
                    if (lastArgs) {
                        fn(...lastArgs);
                        lastArgs = null;
                    }
                }, remaining);
            }
        }
    };
}
function debounce(fn, interval, callImmediately = false) {
    let timeout = null;
    return function (...args) {
        const callNow = callImmediately && !timeout;
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            timeout = null;
            if (!callImmediately) {
                fn(...args);
            }
        }, interval);
        if (callNow) {
            fn(...args);
        }
    };
}

const _console$2 = createConsole("ClientConnectionManager", { log: false });
[
    ...DeviceInformationTypes,
    "batteryLevel",
];
class ClientConnectionManager extends BaseConnectionManager {
    static get isSupported() {
        return isInBrowser;
    }
    static get type() {
        return "client";
    }
    subType;
    get canUpdateFirmware() {
        return false;
    }
    client;
    discoveredDevice;
    #bluetoothId;
    get bluetoothId() {
        return this.#bluetoothId;
    }
    set bluetoothId(newBluetoothId) {
        _console$2.assertTypeWithError(newBluetoothId, "string");
        if (this.#bluetoothId == newBluetoothId) {
            _console$2.log("redundant bluetoothId assignment");
            return;
        }
        this.#bluetoothId = newBluetoothId;
    }
    #isConnected = false;
    get isConnected() {
        return this.#isConnected;
    }
    set isConnected(newIsConnected) {
        _console$2.assertTypeWithError(newIsConnected, "boolean");
        if (this.#isConnected == newIsConnected) {
            _console$2.log("redundant newIsConnected assignment", newIsConnected);
            return;
        }
        this.#isConnected = newIsConnected;
        this.status = this.#isConnected ? "connected" : "notConnected";
        if (this.isConnected) {
            this.#requestDeviceInformation();
        }
    }
    get isAvailable() {
        return this.client.isConnected;
    }
    async connect() {
        const canContinue = await super.connect();
        if (!canContinue) {
            return false;
        }
        this.sendClientConnectMessage(this.subType);
        return true;
    }
    async disconnect() {
        const canContinue = await super.disconnect();
        if (!canContinue) {
            return false;
        }
        this.sendClientDisconnectMessage();
        return true;
    }
    get canReconnect() {
        return true;
    }
    async reconnect() {
        const canContinue = await super.reconnect();
        if (!canContinue) {
            return false;
        }
        this.sendClientConnectMessage();
        return true;
    }
    sendClientMessage;
    sendClientConnectMessage;
    sendClientDisconnectMessage;
    sendRequiredDeviceInformationMessage;
    async sendSmpMessage(data) {
        super.sendSmpMessage(data);
        this.sendClientMessage({ type: "smp", data });
    }
    async sendTxData(data) {
        super.sendTxData(data);
        if (data.byteLength == 0) {
            return;
        }
        this.sendClientMessage({ type: "tx", data });
    }
    #requestDeviceInformation() {
        this.sendRequiredDeviceInformationMessage();
    }
    onClientMessage(dataView) {
        _console$2.log({ dataView });
        parseMessage(dataView, DeviceEventTypes, this.#onClientMessageCallback.bind(this), null, true);
        this.onMessagesReceived();
    }
    #onClientMessageCallback(messageType, dataView) {
        let byteOffset = 0;
        _console$2.log({ messageType }, dataView);
        switch (messageType) {
            case "isConnected":
                const isConnected = Boolean(dataView.getUint8(byteOffset++));
                _console$2.log({ isConnected });
                this.isConnected = isConnected;
                break;
            case "rx":
                this.parseRxMessage(dataView);
                break;
            default:
                this.onMessageReceived(messageType, dataView);
                break;
        }
    }
}

var _a;
const _console$1 = createConsole("BaseClient", { log: false });
const ClientConnectionStatuses = [
    "notConnected",
    "connecting",
    "connected",
    "disconnecting",
];
const ClientEventTypes = [
    ...ClientConnectionStatuses,
    "connectionStatus",
    "isConnected",
    "isScanningAvailable",
    "isScanning",
    "discoveredDevice",
    "expiredDiscoveredDevice",
];
class BaseClient {
    get baseConstructor() {
        return this.constructor;
    }
    #reset() {
        this.#isScanningAvailable = false;
        this.#isScanning = false;
        for (const id in this.#devices) {
            const device = this.#devices[id];
            const connectionManager = device.connectionManager;
            connectionManager.isConnected = false;
        }
        this.#receivedMessageTypes.length = 0;
    }
    #devices = {};
    get devices() {
        return this.#devices;
    }
    #eventDispatcher = new EventDispatcher(this, ClientEventTypes);
    get addEventListener() {
        return this.#eventDispatcher.addEventListener;
    }
    get dispatchEvent() {
        return this.#eventDispatcher.dispatchEvent;
    }
    get removeEventListener() {
        return this.#eventDispatcher.removeEventListener;
    }
    get waitForEvent() {
        return this.#eventDispatcher.waitForEvent;
    }
    assertConnection() {
        _console$1.assertWithError(this.isConnected, "notConnected");
    }
    assertDisconnection() {
        _console$1.assertWithError(this.isDisconnected, "not disconnected");
    }
    static _reconnectOnDisconnection = true;
    static get ReconnectOnDisconnection() {
        return this._reconnectOnDisconnection;
    }
    static set ReconnectOnDisconnection(newReconnectOnDisconnection) {
        _console$1.assertTypeWithError(newReconnectOnDisconnection, "boolean");
        this._reconnectOnDisconnection = newReconnectOnDisconnection;
    }
    _reconnectOnDisconnection = this.baseConstructor.ReconnectOnDisconnection;
    get reconnectOnDisconnection() {
        return this._reconnectOnDisconnection;
    }
    set reconnectOnDisconnection(newReconnectOnDisconnection) {
        _console$1.assertTypeWithError(newReconnectOnDisconnection, "boolean");
        this._reconnectOnDisconnection = newReconnectOnDisconnection;
    }
    #_connectionStatus = "notConnected";
    get _connectionStatus() {
        return this.#_connectionStatus;
    }
    set _connectionStatus(newConnectionStatus) {
        _console$1.assertTypeWithError(newConnectionStatus, "string");
        _console$1.log({ newConnectionStatus });
        this.#_connectionStatus = newConnectionStatus;
        this.dispatchEvent("connectionStatus", {
            connectionStatus: this.connectionStatus,
        });
        this.dispatchEvent(this.connectionStatus, {});
        switch (newConnectionStatus) {
            case "connected":
            case "notConnected":
                this.dispatchEvent("isConnected", { isConnected: this.isConnected });
                if (this.isConnected) ;
                else {
                    this.#reset();
                }
                break;
        }
    }
    get connectionStatus() {
        return this._connectionStatus;
    }
    static #RequiredMessageTypes = [
        "isScanningAvailable",
        "discoveredDevices",
        "connectedDevices",
    ];
    get #requiredMessageTypes() {
        return _a.#RequiredMessageTypes;
    }
    _sendRequiredMessages() {
        _console$1.log("sending required messages", this.#receivedMessageTypes);
        this.sendServerMessage(...this.#requiredMessageTypes);
    }
    #receivedMessageTypes = [];
    #checkIfFullyConnected() {
        if (this.connectionStatus != "connecting") {
            return;
        }
        _console$1.log("checking if fully connected...");
        if (!this.#receivedMessageTypes.includes("isScanningAvailable")) {
            _console$1.log("not fully connected - didn't receive isScanningAvailable");
            return;
        }
        if (this.isScanningAvailable) {
            if (!this.#receivedMessageTypes.includes("isScanning")) {
                _console$1.log("not fully connected - didn't receive isScanning");
                return;
            }
        }
        _console$1.log("fully connected");
        this._connectionStatus = "connected";
    }
    parseMessage(dataView) {
        _console$1.log("parseMessage", { dataView });
        parseMessage(dataView, ServerMessageTypes, this.#parseMessageCallback.bind(this), null, true);
        this.#checkIfFullyConnected();
    }
    #parseMessageCallback(messageType, dataView) {
        let byteOffset = 0;
        _console$1.log({ messageType }, dataView);
        switch (messageType) {
            case "isScanningAvailable":
                {
                    const isScanningAvailable = Boolean(dataView.getUint8(byteOffset++));
                    _console$1.log({ isScanningAvailable });
                    this.#isScanningAvailable = isScanningAvailable;
                }
                break;
            case "isScanning":
                {
                    const isScanning = Boolean(dataView.getUint8(byteOffset++));
                    _console$1.log({ isScanning });
                    this.#isScanning = isScanning;
                }
                break;
            case "discoveredDevice":
                {
                    const { string: discoveredDeviceString } = parseStringFromDataView(dataView, byteOffset);
                    _console$1.log({ discoveredDeviceString });
                    const discoveredDevice = JSON.parse(discoveredDeviceString);
                    _console$1.log({ discoveredDevice });
                    this.onDiscoveredDevice(discoveredDevice);
                }
                break;
            case "expiredDiscoveredDevice":
                {
                    const { string: bluetoothId } = parseStringFromDataView(dataView, byteOffset);
                    this.#onExpiredDiscoveredDevice(bluetoothId);
                }
                break;
            case "connectedDevices":
                {
                    if (dataView.byteLength == 0) {
                        break;
                    }
                    const { string: connectedBluetoothDeviceIdStrings } = parseStringFromDataView(dataView, byteOffset);
                    _console$1.log({ connectedBluetoothDeviceIdStrings });
                    const connectedBluetoothDeviceIds = JSON.parse(connectedBluetoothDeviceIdStrings).connectedDevices;
                    _console$1.log({ connectedBluetoothDeviceIds });
                    this.onConnectedBluetoothDeviceIds(connectedBluetoothDeviceIds);
                }
                break;
            case "deviceMessage":
                {
                    const { string: bluetoothId, byteOffset: _byteOffset } = parseStringFromDataView(dataView, byteOffset);
                    byteOffset = _byteOffset;
                    const device = this.#devices[bluetoothId];
                    _console$1.assertWithError(device, `no device found for id ${bluetoothId}`);
                    const connectionManager = device.connectionManager;
                    const _dataView = sliceDataView(dataView, byteOffset);
                    connectionManager.onClientMessage(_dataView);
                }
                break;
            default:
                _console$1.error(`uncaught messageType "${messageType}"`);
                break;
        }
        if (this.connectionStatus == "connecting") {
            this.#receivedMessageTypes.push(messageType);
        }
    }
    #_isScanningAvailable = false;
    get #isScanningAvailable() {
        return this.#_isScanningAvailable;
    }
    set #isScanningAvailable(newIsAvailable) {
        _console$1.assertTypeWithError(newIsAvailable, "boolean");
        this.#_isScanningAvailable = newIsAvailable;
        this.dispatchEvent("isScanningAvailable", {
            isScanningAvailable: this.isScanningAvailable,
        });
        if (this.isScanningAvailable) {
            this.#requestIsScanning();
        }
    }
    get isScanningAvailable() {
        return this.#isScanningAvailable;
    }
    #assertIsScanningAvailable() {
        this.assertConnection();
        _console$1.assertWithError(this.isScanningAvailable, "scanning is not available");
    }
    requestIsScanningAvailable() {
        this.sendServerMessage("isScanningAvailable");
    }
    #_isScanning = false;
    get #isScanning() {
        return this.#_isScanning;
    }
    set #isScanning(newIsScanning) {
        _console$1.assertTypeWithError(newIsScanning, "boolean");
        this.#_isScanning = newIsScanning;
        this.dispatchEvent("isScanning", { isScanning: this.isScanning });
    }
    get isScanning() {
        return this.#isScanning;
    }
    #requestIsScanning() {
        this.sendServerMessage("isScanning");
    }
    #assertIsScanning() {
        _console$1.assertWithError(this.isScanning, "is not scanning");
    }
    #assertIsNotScanning() {
        _console$1.assertWithError(!this.isScanning, "is already scanning");
    }
    startScan() {
        this.#assertIsNotScanning();
        this.sendServerMessage("startScan");
    }
    stopScan() {
        this.#assertIsScanning();
        this.sendServerMessage("stopScan");
    }
    toggleScan() {
        this.#assertIsScanningAvailable();
        if (this.isScanning) {
            this.stopScan();
        }
        else {
            this.startScan();
        }
    }
    #discoveredDevices = {};
    get discoveredDevices() {
        return this.#discoveredDevices;
    }
    onDiscoveredDevice(discoveredDevice) {
        _console$1.log({ discoveredDevice });
        this.#discoveredDevices[discoveredDevice.bluetoothId] = discoveredDevice;
        this.dispatchEvent("discoveredDevice", { discoveredDevice });
    }
    requestDiscoveredDevices() {
        this.sendServerMessage({ type: "discoveredDevices" });
    }
    #onExpiredDiscoveredDevice(bluetoothId) {
        _console$1.log({ expiredBluetoothDeviceId: bluetoothId });
        const discoveredDevice = this.#discoveredDevices[bluetoothId];
        if (!discoveredDevice) {
            _console$1.warn(`no discoveredDevice found with id "${bluetoothId}"`);
            return;
        }
        _console$1.log({ expiredDiscoveredDevice: discoveredDevice });
        delete this.#discoveredDevices[bluetoothId];
        this.dispatchEvent("expiredDiscoveredDevice", { discoveredDevice });
    }
    connectToDevice(bluetoothId, connectionType) {
        return this.requestConnectionToDevice(bluetoothId, connectionType);
    }
    requestConnectionToDevice(bluetoothId, connectionType) {
        this.assertConnection();
        _console$1.assertTypeWithError(bluetoothId, "string");
        const device = this.#getOrCreateDevice(bluetoothId);
        if (connectionType) {
            device.connect({ type: "client", subType: connectionType });
        }
        else {
            device.connect();
        }
        return device;
    }
    sendConnectToDeviceMessage(bluetoothId, connectionType) {
        if (connectionType) {
            this.sendServerMessage({
                type: "connectToDevice",
                data: concatenateArrayBuffers(stringToArrayBuffer(bluetoothId), ConnectionTypes.indexOf(connectionType)),
            });
        }
        else {
            this.sendServerMessage({ type: "connectToDevice", data: bluetoothId });
        }
    }
    createDevice(bluetoothId) {
        const device = new Device();
        const discoveredDevice = this.#discoveredDevices[bluetoothId];
        const clientConnectionManager = new ClientConnectionManager();
        clientConnectionManager.discoveredDevice = Object.assign({}, discoveredDevice);
        clientConnectionManager.client = this;
        clientConnectionManager.bluetoothId = bluetoothId;
        clientConnectionManager.sendClientMessage = this.sendDeviceMessage.bind(this, bluetoothId);
        clientConnectionManager.sendRequiredDeviceInformationMessage =
            this.sendRequiredDeviceInformationMessage.bind(this, bluetoothId);
        clientConnectionManager.sendClientConnectMessage =
            this.sendConnectToDeviceMessage.bind(this, bluetoothId);
        clientConnectionManager.sendClientDisconnectMessage =
            this.sendDisconnectFromDeviceMessage.bind(this, bluetoothId);
        device.connectionManager = clientConnectionManager;
        return device;
    }
    #getOrCreateDevice(bluetoothId) {
        let device = this.#devices[bluetoothId];
        if (!device) {
            device = this.createDevice(bluetoothId);
            this.#devices[bluetoothId] = device;
        }
        return device;
    }
    onConnectedBluetoothDeviceIds(bluetoothIds) {
        _console$1.log({ bluetoothIds });
        bluetoothIds.forEach((bluetoothId) => {
            const device = this.#getOrCreateDevice(bluetoothId);
            const connectionManager = device.connectionManager;
            connectionManager.isConnected = true;
            DeviceManager$1._CheckDeviceAvailability(device);
        });
    }
    disconnectFromDevice(bluetoothId) {
        this.requestDisconnectionFromDevice(bluetoothId);
    }
    requestDisconnectionFromDevice(bluetoothId) {
        this.assertConnection();
        _console$1.assertTypeWithError(bluetoothId, "string");
        const device = this.devices[bluetoothId];
        _console$1.assertWithError(device, `no device found with id ${bluetoothId}`);
        device.disconnect();
        return device;
    }
    sendDisconnectFromDeviceMessage(bluetoothId) {
        this.sendServerMessage({ type: "disconnectFromDevice", data: bluetoothId });
    }
    sendDeviceMessage(bluetoothId, ...messages) {
        this.sendServerMessage({
            type: "deviceMessage",
            data: [bluetoothId, createClientDeviceMessage(...messages)],
        });
    }
    sendRequiredDeviceInformationMessage(bluetoothId) {
        this.sendServerMessage({
            type: "requiredDeviceInformation",
            data: [bluetoothId],
        });
    }
}
_a = BaseClient;

const _console = createConsole("WebSocketClient", { log: false });
class WebSocketClient extends BaseClient {
    #webSocket;
    get webSocket() {
        return this.#webSocket;
    }
    set webSocket(newWebSocket) {
        if (this.#webSocket == newWebSocket) {
            _console.log("redundant webSocket assignment");
            return;
        }
        _console.log("assigning webSocket", newWebSocket);
        if (this.#webSocket) {
            removeEventListeners(this.#webSocket, this.#boundWebSocketEventListeners);
        }
        addEventListeners(newWebSocket, this.#boundWebSocketEventListeners);
        this.#webSocket = newWebSocket;
        _console.log("assigned webSocket");
    }
    get readyState() {
        return this.webSocket?.readyState;
    }
    get isConnected() {
        return this.readyState == WebSocket.OPEN;
    }
    get isDisconnected() {
        return this.readyState == WebSocket.CLOSED;
    }
    connect(url = `${location.protocol.includes("https") ? "wss" : "ws"}://${location.host}`) {
        if (this.webSocket) {
            this.assertDisconnection();
        }
        this._connectionStatus = "connecting";
        if (isInLensStudio) ;
        else {
            this.webSocket = new WebSocket(url);
        }
    }
    disconnect() {
        this.assertConnection();
        if (this.reconnectOnDisconnection) {
            this.reconnectOnDisconnection = false;
            this.webSocket.addEventListener("close", () => {
                this.reconnectOnDisconnection = true;
            }, { once: true });
        }
        this._connectionStatus = "disconnecting";
        this.webSocket.close();
    }
    reconnect() {
        this.assertDisconnection();
        this.connect(this.webSocket.url);
    }
    toggleConnection(url) {
        if (this.isConnected) {
            this.disconnect();
        }
        else if (url && this.webSocket?.url == url) {
            this.reconnect();
        }
        else {
            this.connect(url);
        }
    }
    sendMessage(message) {
        this.assertConnection();
        this.#webSocket.send(message);
        this.#pingTimer.restart();
    }
    sendServerMessage(...messages) {
        this.sendMessage(createWebSocketMessage$1({
            type: "serverMessage",
            data: createServerMessage(...messages),
        }));
    }
    #sendWebSocketMessage(...messages) {
        this.sendMessage(createWebSocketMessage$1(...messages));
    }
    #boundWebSocketEventListeners = {
        open: this.#onWebSocketOpen.bind(this),
        message: this.#onWebSocketMessage.bind(this),
        close: this.#onWebSocketClose.bind(this),
        error: this.#onWebSocketError.bind(this),
    };
    #onWebSocketOpen(event) {
        _console.log("webSocket.open", event);
        this.#pingTimer.start();
        this._sendRequiredMessages();
    }
    async #onWebSocketMessage(event) {
        _console.log("webSocket.message", event);
        const arrayBuffer = await event.data.arrayBuffer();
        const dataView = new DataView(arrayBuffer);
        this.#parseWebSocketMessage(dataView);
    }
    #onWebSocketClose(event) {
        _console.log("webSocket.close", event);
        this._connectionStatus = "notConnected";
        Object.entries(this.devices).forEach(([id, device]) => {
            const connectionManager = device.connectionManager;
            connectionManager.isConnected = false;
        });
        this.#pingTimer.stop();
        if (this.reconnectOnDisconnection) {
            setTimeout(() => {
                this.reconnect();
            }, webSocketReconnectTimeout);
        }
    }
    #onWebSocketError(event) {
        _console.error("webSocket.error", event);
    }
    #parseWebSocketMessage(dataView) {
        parseMessage(dataView, WebSocketMessageTypes$1, this.#onServerMessage.bind(this), null, true);
    }
    #onServerMessage(messageType, dataView) {
        switch (messageType) {
            case "ping":
                this.#pong();
                break;
            case "pong":
                break;
            case "serverMessage":
                this.parseMessage(dataView);
                break;
            default:
                _console.error(`uncaught messageType "${messageType}"`);
                break;
        }
    }
    #pingTimer = new Timer(this.#ping.bind(this), webSocketPingTimeout);
    #ping() {
        this.#sendWebSocketMessage("ping");
    }
    #pong() {
        this.#sendWebSocketMessage("pong");
    }
}

const EventUtils = {
    addEventListeners,
    removeEventListeners,
};
const ThrottleUtils = {
    throttle,
    debounce,
};

export { CameraCommands, CameraConfigurationTypes, ContinuousSensorTypes, DefaultNumberOfDisplayColors, DefaultNumberOfPressureSensors, Device, DeviceManager$1 as DeviceManager, DevicePair, DevicePairTypes, DeviceTypes, DisplayAlignments, DisplayBezierCurveTypes, DisplayBrightnesses, DisplayCanvasHelper, DisplayContextCommandTypes, DisplayDirections, DisplayPixelDepths, DisplaySegmentCaps, DisplaySpriteContextCommandTypes, environment as Environment, EventUtils, FileTransferDirections, FileTypes, Font, Glyph, MaxNameLength, MaxNumberOfVibrationWaveformEffectSegments, MaxNumberOfVibrationWaveformSegments, MaxSensorRate, MaxSpriteSheetNameLength, MaxVibrationWaveformEffectSegmentDelay, MaxVibrationWaveformEffectSegmentLoopCount, MaxVibrationWaveformEffectSequenceLoopCount, MaxVibrationWaveformSegmentDuration, MaxWifiPasswordLength, MaxWifiSSIDLength, MicrophoneCommands, MicrophoneConfigurationTypes, MicrophoneConfigurationValues, MinNameLength, MinSpriteSheetNameLength, MinWifiPasswordLength, MinWifiSSIDLength, RangeHelper, SensorRateStep, SensorTypes, Sides, TfliteSensorTypes, TfliteTasks, ThrottleUtils, Timer, VibrationLocations, VibrationTypes, VibrationWaveformEffects, WebSocketClient, canvasToBitmaps, canvasToSprite, canvasToSpriteSheet, displayCurveTypeToNumberOfControlPoints, englishRegex, fontToSpriteSheet, getFontMaxHeight, getFontMetrics, getFontUnicodeRange, getMaxSpriteSheetSize, getSvgStringFromDataUrl, hexToRGB, imageToBitmaps, imageToSprite, imageToSpriteSheet, intersectWireframes, isValidSVG, isWireframePolygon, maxDisplayScale, mergeWireframes, parseFont, pixelDepthToNumberOfColors, quantizeImage, resizeAndQuantizeImage, resizeImage, rgbToHex, setAllConsoleLevelFlags, setConsoleLevelFlagsForType, simplifyCurves, simplifyPoints, simplifyPointsAsCubicCurveControlPoints, stringToSprites, svgToDisplayContextCommands, svgToSprite, svgToSpriteSheet, wait };
//# sourceMappingURL=brilliantsole.module.js.map
