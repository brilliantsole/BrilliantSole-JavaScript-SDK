{"version":3,"file":"brilliantsole.module.min.js","sources":["../brilliantsole/utils/environment.ts","../brilliantsole/utils/Console.ts","../brilliantsole/utils/EventDispatcher.ts","../brilliantsole/utils/Timer.ts","../brilliantsole/utils/checksum.ts","../brilliantsole/utils/Text.ts","../brilliantsole/utils/ArrayBufferUtils.ts","../node_modules/auto-bind/index.js","../brilliantsole/FileTransferManager.ts","../brilliantsole/utils/MathUtils.ts","../brilliantsole/utils/RangeHelper.ts","../brilliantsole/utils/CenterOfPressureHelper.ts","../brilliantsole/sensor/PressureSensorDataManager.ts","../brilliantsole/utils/ArrayUtils.ts","../brilliantsole/sensor/MotionSensorDataManager.ts","../brilliantsole/sensor/BarometerSensorDataManager.ts","../brilliantsole/utils/ParseUtils.ts","../brilliantsole/CameraManager.ts","../brilliantsole/utils/AudioUtils.ts","../node_modules/alawmulaw/lib/alaw.js","../node_modules/alawmulaw/lib/mulaw.js","../brilliantsole/MicrophoneManager.ts","../brilliantsole/sensor/SensorDataManager.ts","../brilliantsole/sensor/SensorConfigurationManager.ts","../brilliantsole/TfliteManager.ts","../brilliantsole/DeviceInformationManager.ts","../brilliantsole/InformationManager.ts","../brilliantsole/vibration/VibrationWaveformEffects.ts","../brilliantsole/vibration/VibrationManager.ts","../brilliantsole/WifiManager.ts","../brilliantsole/utils/ColorUtils.ts","../brilliantsole/utils/DisplayContextState.ts","../brilliantsole/utils/ObjectUtils.ts","../brilliantsole/utils/DisplayContextStateHelper.ts","../brilliantsole/utils/DisplayUtils.ts","../node_modules/rgbquant/src/rgbquant.js","../brilliantsole/utils/DisplayContextCommand.ts","../brilliantsole/utils/DisplayBitmapUtils.ts","../node_modules/opentype.js/dist/opentype.module.js","../node_modules/woff2-encoder/dist/index.js","../node_modules/simplify-js/simplify.js","../node_modules/fit-curve/lib/fit-curve.js","../brilliantsole/utils/PathUtils.ts","../node_modules/svgson/dist/svgson.umd.js","../node_modules/svg-pathdata/dist/SVGPathDataEncoder.js","../node_modules/svg-pathdata/dist/mathUtils.js","../node_modules/svg-pathdata/dist/transformers/reverse_path.js","../node_modules/svg-pathdata/dist/SVGPathDataTransformer.js","../node_modules/svg-pathdata/dist/transformers/remove_collinear.js","../node_modules/svg-pathdata/dist/TransformableSVG.js","../node_modules/svg-pathdata/dist/SVGPathDataParser.js","../node_modules/svg-pathdata/dist/SVGPathData.js","../brilliantsole/utils/SvgUtils.ts","../brilliantsole/utils/stringUtils.ts","../brilliantsole/utils/DisplaySpriteSheetUtils.ts","../brilliantsole/utils/DisplayManagerInterface.ts","../brilliantsole/DisplayManager.ts","../brilliantsole/connection/BaseConnectionManager.ts","../brilliantsole/utils/EventUtils.ts","../brilliantsole/connection/bluetooth/bluetoothUUIDs.ts","../brilliantsole/connection/bluetooth/BluetoothConnectionManager.ts","../brilliantsole/connection/bluetooth/WebBluetoothConnectionManager.ts","../brilliantsole/utils/cbor.js","../brilliantsole/utils/mcumgr.js","../brilliantsole/FirmwareManager.ts","../brilliantsole/DeviceManager.ts","../brilliantsole/server/ServerUtils.ts","../brilliantsole/server/websocket/WebSocketUtils.ts","../brilliantsole/connection/websocket/WebSocketConnectionManager.ts","../brilliantsole/Device.ts","../brilliantsole/utils/DisplayCanvasHelper.ts","../brilliantsole/devicePair/DevicePairPressureSensorDataManager.ts","../brilliantsole/devicePair/DevicePairSensorDataManager.ts","../brilliantsole/devicePair/DevicePair.ts","../brilliantsole/connection/ClientConnectionManager.ts","../brilliantsole/server/BaseClient.ts","../brilliantsole/server/websocket/WebSocketClient.ts","../brilliantsole/BS.ts","../brilliantsole/utils/ThrottleUtils.ts"],"sourcesContent":["type ENVIRONMENT_FLAG = \"__BRILLIANTSOLE__DEV__\" | \"__BRILLIANTSOLE__PROD__\";\nconst __BRILLIANTSOLE__ENVIRONMENT__: ENVIRONMENT_FLAG =\n  \"__BRILLIANTSOLE__DEV__\";\n\nconst isInProduction =\n  // @ts-expect-error\n  __BRILLIANTSOLE__ENVIRONMENT__ == \"__BRILLIANTSOLE__PROD__\";\nconst isInDev = __BRILLIANTSOLE__ENVIRONMENT__ == \"__BRILLIANTSOLE__DEV__\";\n\n// https://github.com/flexdinesh/browser-or-node/blob/master/src/index.ts\nconst isInBrowser =\n  typeof window !== \"undefined\" && typeof window?.document !== \"undefined\";\nconst isInNode =\n  typeof process !== \"undefined\" && process?.versions?.node != null;\n\nconst userAgent = (isInBrowser && navigator.userAgent) || \"\";\n\nlet isBluetoothSupported = false;\nif (isInBrowser) {\n  isBluetoothSupported = Boolean(navigator.bluetooth);\n} else if (isInNode) {\n  isBluetoothSupported = true;\n}\n\nconst isInBluefy = isInBrowser && /Bluefy/i.test(userAgent);\nconst isInWebBLE = isInBrowser && /WebBLE/i.test(userAgent);\n\nconst isAndroid = isInBrowser && /Android/i.test(userAgent);\nconst isSafari =\n  isInBrowser && /Safari/i.test(userAgent) && !/Chrome/i.test(userAgent);\n\nconst isIOS = isInBrowser && /iPad|iPhone|iPod/i.test(userAgent);\nconst isMac = isInBrowser && /Macintosh/i.test(userAgent);\n\nconst isInLensStudio =\n  !isInBrowser &&\n  !isInNode &&\n  typeof global !== \"undefined\" &&\n  // @ts-expect-error\n  typeof Studio !== \"undefined\";\n\nexport {\n  isInDev,\n  isInProduction,\n  isInBrowser,\n  isInNode,\n  isAndroid,\n  isInBluefy,\n  isInWebBLE,\n  isSafari,\n  isInLensStudio,\n  isIOS,\n  isMac,\n  isBluetoothSupported,\n};\n","import { isInDev, isInLensStudio, isInNode } from \"./environment.ts\";\n\ndeclare var Studio: any | undefined;\n\nexport type LogFunction = (...data: any[]) => void;\nexport type AssertLogFunction = (condition: boolean, ...data: any[]) => void;\n\nexport interface ConsoleLevelFlags {\n  log?: boolean;\n  warn?: boolean;\n  error?: boolean;\n  assert?: boolean;\n  table?: boolean;\n}\n\ninterface ConsoleLike {\n  log?: LogFunction;\n  warn?: LogFunction;\n  error?: LogFunction;\n  assert?: AssertLogFunction;\n  table?: LogFunction;\n}\n\nvar __console: ConsoleLike;\nif (isInLensStudio) {\n  const log = function (...args: any[]) {\n    Studio.log(args.map((value) => new String(value)).join(\",\"));\n  };\n  __console = {};\n  __console.log = log;\n  __console.warn = log.bind(__console, \"WARNING\");\n  __console.error = log.bind(__console, \"ERROR\");\n} else {\n  __console = console;\n}\n\nfunction getCallerFunctionPath(): string {\n  const stack = new Error().stack;\n  if (!stack) return \"\";\n\n  const lines = stack.split(\"\\n\");\n  const callerLine = lines[3] || lines[2];\n\n  const match = callerLine.match(/at (.*?) \\(/) || callerLine.match(/at (.*)/);\n  if (!match) return \"\";\n\n  const fullFn = match[1].trim();\n  return `[${fullFn}]`;\n}\n\nfunction wrapWithLocation(fn: LogFunction): LogFunction {\n  return (...args: any[]) => {\n    if (isInNode) {\n      const functionPath = getCallerFunctionPath();\n      fn(functionPath, ...args);\n    } else {\n      fn(...args);\n    }\n  };\n}\n\n// console.assert not supported in WebBLE\nif (!__console.assert) {\n  const assert: AssertLogFunction = (condition, ...data) => {\n    if (!condition) {\n      __console.warn!(...data);\n    }\n  };\n  __console.assert = assert;\n}\n\n// console.table not supported in WebBLE\nif (!__console.table) {\n  const table: LogFunction = (...data) => {\n    __console.log!(...data);\n  };\n  __console.table = table;\n}\n\nfunction emptyFunction() {}\n\nconst log: LogFunction = isInNode\n  ? wrapWithLocation(__console.log!.bind(__console))\n  : __console.log!.bind(__console);\nconst warn: LogFunction = isInNode\n  ? wrapWithLocation(__console.warn!.bind(__console))\n  : __console.warn!.bind(__console);\nconst error: LogFunction = isInNode\n  ? wrapWithLocation(__console.error!.bind(__console))\n  : __console.error!.bind(__console);\nconst table: LogFunction = isInNode\n  ? wrapWithLocation(__console.table!.bind(__console))\n  : __console.table!.bind(__console);\nconst assert: AssertLogFunction = __console.assert.bind(__console);\n\nclass Console {\n  static #consoles: { [type: string]: Console } = {};\n\n  constructor(type: string) {\n    if (Console.#consoles[type]) {\n      throw new Error(`\"${type}\" console already exists`);\n    }\n    Console.#consoles[type] = this;\n  }\n\n  #levelFlags: ConsoleLevelFlags = {\n    log: isInDev,\n    warn: isInDev,\n    assert: true,\n    error: true,\n    table: true,\n  };\n\n  setLevelFlags(levelFlags: ConsoleLevelFlags) {\n    Object.assign(this.#levelFlags, levelFlags);\n  }\n\n  /** @throws {Error} if no console with type \"type\" is found */\n  static setLevelFlagsForType(type: string, levelFlags: ConsoleLevelFlags) {\n    if (!this.#consoles[type]) {\n      throw new Error(`no console found with type \"${type}\"`);\n    }\n    this.#consoles[type].setLevelFlags(levelFlags);\n  }\n\n  static setAllLevelFlags(levelFlags: ConsoleLevelFlags) {\n    for (const type in this.#consoles) {\n      this.#consoles[type].setLevelFlags(levelFlags);\n    }\n  }\n\n  static create(type: string, levelFlags?: ConsoleLevelFlags): Console {\n    const console = this.#consoles[type] || new Console(type);\n    if (isInDev && levelFlags) {\n      console.setLevelFlags(levelFlags);\n    }\n    return console;\n  }\n\n  get log() {\n    return this.#levelFlags.log ? log : emptyFunction;\n  }\n\n  get warn() {\n    return this.#levelFlags.warn ? warn : emptyFunction;\n  }\n\n  get error() {\n    return this.#levelFlags.error ? error : emptyFunction;\n  }\n\n  get assert() {\n    return this.#levelFlags.assert ? assert : emptyFunction;\n  }\n\n  get table() {\n    return this.#levelFlags.table ? table : emptyFunction;\n  }\n\n  /** @throws {Error} if condition is not met */\n  assertWithError(condition: any, message: string) {\n    if (!Boolean(condition)) {\n      throw new Error(message);\n    }\n  }\n\n  /** @throws {Error} if value's type doesn't match */\n  assertTypeWithError(value: any, type: string) {\n    this.assertWithError(\n      typeof value == type,\n      `value ${value} of type \"${typeof value}\" not of type \"${type}\"`\n    );\n  }\n\n  /** @throws {Error} if value's type doesn't match */\n  assertEnumWithError(value: string, enumeration: readonly string[]) {\n    this.assertWithError(\n      enumeration.includes(value),\n      `invalid enum \"${value}\"`\n    );\n  }\n\n  /** @throws {Error} if value is not within some range */\n  assertRangeWithError(name: string, value: number, min: number, max: number) {\n    this.assertWithError(\n      value >= min && value <= max,\n      `${name} ${value} must be within ${min}-${max}`\n    );\n  }\n}\n\nexport function createConsole(\n  type: string,\n  levelFlags?: ConsoleLevelFlags\n): Console {\n  return Console.create(type, levelFlags);\n}\n\n/** @throws {Error} if no console with type is found */\nexport function setConsoleLevelFlagsForType(\n  type: string,\n  levelFlags: ConsoleLevelFlags\n) {\n  Console.setLevelFlagsForType(type, levelFlags);\n}\n\nexport function setAllConsoleLevelFlags(levelFlags: ConsoleLevelFlags) {\n  Console.setAllLevelFlags(levelFlags);\n}\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"EventDispatcher\", { log: false });\n\nexport type EventMap<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [T in keyof EventMessages]: {\n    type: T;\n    target: Target;\n    message: EventMessages[T];\n  };\n};\nexport type EventListenerMap<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [T in keyof EventMessages]: (event: {\n    type: T;\n    target: Target;\n    message: EventMessages[T];\n  }) => void;\n};\n\nexport type Event<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = EventMap<Target, EventType, EventMessages>[keyof EventMessages];\n\ntype SpecificEvent<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>,\n  SpecificEventType extends EventType\n> = {\n  type: SpecificEventType;\n  target: Target;\n  message: EventMessages[SpecificEventType];\n};\n\nexport type BoundEventListeners<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [SpecificEventType in keyof EventMessages]?: (\n    // @ts-expect-error\n    event: SpecificEvent<Target, EventType, EventMessages, SpecificEventType>\n  ) => void;\n};\n\nclass EventDispatcher<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> {\n  private listeners: {\n    [T in EventType]?: {\n      listener: (event: {\n        type: T;\n        target: Target;\n        message: EventMessages[T];\n      }) => void;\n      once?: boolean;\n      shouldRemove?: boolean;\n    }[];\n  } = {};\n\n  constructor(\n    private target: Target,\n    private validEventTypes: readonly EventType[]\n  ) {\n    this.addEventListener = this.addEventListener.bind(this);\n    this.removeEventListener = this.removeEventListener.bind(this);\n    this.removeEventListeners = this.removeEventListeners.bind(this);\n    this.removeAllEventListeners = this.removeAllEventListeners.bind(this);\n    this.dispatchEvent = this.dispatchEvent.bind(this);\n    this.waitForEvent = this.waitForEvent.bind(this);\n  }\n\n  private isValidEventType(type: any): type is EventType {\n    return this.validEventTypes.includes(type);\n  }\n\n  private updateEventListeners(type: EventType) {\n    if (!this.listeners[type]) return;\n    this.listeners[type] = this.listeners[type]!.filter((listenerObj) => {\n      if (listenerObj.shouldRemove) {\n        _console.log(`removing \"${type}\" eventListener`, listenerObj);\n      }\n      return !listenerObj.shouldRemove;\n    });\n  }\n\n  addEventListener<T extends EventType>(\n    type: T,\n    listener: (event: {\n      type: T;\n      target: Target;\n      message: EventMessages[T];\n    }) => void,\n    options: { once?: boolean } = { once: false }\n  ): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n      _console.log(`creating \"${type}\" listeners array`, this.listeners[type]!);\n    }\n    const alreadyAdded = this.listeners[type].find((listenerObject) => {\n      return (\n        listenerObject.listener == listener &&\n        listenerObject.once == options.once\n      );\n    });\n    if (alreadyAdded) {\n      _console.log(\"already added listener\");\n      return;\n    }\n    _console.log(`adding \"${type}\" listener`, listener, options);\n    this.listeners[type]!.push({ listener, once: options.once });\n\n    _console.log(\n      `currently have ${this.listeners[type]!.length} \"${type}\" listeners`\n    );\n  }\n\n  removeEventListener<T extends EventType>(\n    type: T,\n    listener: (event: {\n      type: T;\n      target: Target;\n      message: EventMessages[T];\n    }) => void\n  ): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    _console.log(`removing \"${type}\" listener...`, listener);\n    this.listeners[type]!.forEach((listenerObj) => {\n      const isListenerToRemove = listenerObj.listener === listener;\n      if (isListenerToRemove) {\n        _console.log(`flagging \"${type}\" listener`, listener);\n        listenerObj.shouldRemove = true;\n      }\n    });\n\n    this.updateEventListeners(type);\n  }\n\n  removeEventListeners<T extends EventType>(type: T): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    _console.log(`removing \"${type}\" listeners...`);\n    this.listeners[type] = [];\n  }\n\n  removeAllEventListeners(): void {\n    _console.log(`removing listeners...`);\n    this.listeners = {};\n  }\n\n  dispatchEvent<T extends EventType>(type: T, message: EventMessages[T]): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    // Take a snapshot of listeners at this moment\n    const listenersSnapshot = [...this.listeners[type]!];\n\n    listenersSnapshot.forEach((listenerObj) => {\n      if (listenerObj.shouldRemove) {\n        return;\n      }\n\n      _console.log(`dispatching \"${type}\" listener`, listenerObj);\n      try {\n        listenerObj.listener({ type, target: this.target, message });\n      } catch (error) {\n        console.error(error);\n      }\n\n      if (listenerObj.once) {\n        _console.log(`flagging \"${type}\" listener`, listenerObj);\n        listenerObj.shouldRemove = true;\n      }\n    });\n\n    this.updateEventListeners(type);\n  }\n\n  waitForEvent<T extends EventType>(\n    type: T\n  ): Promise<{ type: T; target: Target; message: EventMessages[T] }> {\n    return new Promise((resolve) => {\n      const onceListener = (event: {\n        type: T;\n        target: Target;\n        message: EventMessages[T];\n      }) => {\n        resolve(event);\n      };\n\n      this.addEventListener(type, onceListener, { once: true });\n    });\n  }\n}\n\nexport default EventDispatcher;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"Timer\", { log: false });\n\nexport async function wait(delay: number): Promise<void> {\n  _console.log(`waiting for ${delay}ms`);\n  return new Promise((resolve: Function) => {\n    setTimeout(() => resolve(), delay);\n  });\n}\n\nexport class Timer {\n  #callback!: Function;\n  get callback() {\n    return this.#callback;\n  }\n  set callback(newCallback) {\n    _console.assertTypeWithError(newCallback, \"function\");\n    _console.log({ newCallback });\n    this.#callback = newCallback;\n    if (this.isRunning) {\n      this.restart();\n    }\n  }\n\n  #interval!: number;\n  get interval() {\n    return this.#interval;\n  }\n  set interval(newInterval) {\n    _console.assertTypeWithError(newInterval, \"number\");\n    _console.assertWithError(newInterval > 0, \"interval must be above 0\");\n    _console.log({ newInterval });\n    this.#interval = newInterval;\n    if (this.isRunning) {\n      this.restart();\n    }\n  }\n\n  constructor(callback: Function, interval: number) {\n    this.interval = interval;\n    this.callback = callback;\n  }\n\n  #intervalId: number | undefined;\n  get isRunning() {\n    return this.#intervalId != undefined;\n  }\n\n  start(immediately = false) {\n    if (this.isRunning) {\n      _console.log(\"interval already running\");\n      return;\n    }\n    _console.log(`starting interval every ${this.#interval}ms`);\n    this.#intervalId = setInterval(this.#callback, this.#interval);\n    if (immediately) {\n      this.#callback();\n    }\n  }\n  stop() {\n    if (!this.isRunning) {\n      _console.log(\"interval already not running\");\n      return;\n    }\n    _console.log(\"stopping interval\");\n    clearInterval(this.#intervalId);\n    this.#intervalId = undefined;\n  }\n  restart(startImmediately = false) {\n    this.stop();\n    this.start(startImmediately);\n  }\n}\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"checksum\", { log: false });\n\n// https://github.com/googlecreativelab/tiny-motion-trainer/blob/5fceb49f018ae0c403bf9f0ccc437309c2acb507/frontend/src/tf4micro-motion-kit/modules/bleFileTransfer#L195\n\n// See http://home.thep.lu.se/~bjorn/crc/ for more information on simple CRC32 calculations.\nexport function crc32ForByte(r: number) {\n  for (let j = 0; j < 8; ++j) {\n    r = (r & 1 ? 0 : 0xedb88320) ^ (r >>> 1);\n  }\n  return r ^ 0xff000000;\n}\n\nconst tableSize = 256;\nconst crc32Table = new Uint32Array(tableSize);\nfor (let i = 0; i < tableSize; ++i) {\n  crc32Table[i] = crc32ForByte(i);\n}\n\nexport function crc32(dataIterable: ArrayBuffer | number[]) {\n  let dataBytes = new Uint8Array(dataIterable);\n  let crc = 0;\n  for (let i = 0; i < dataBytes.byteLength; ++i) {\n    const crcLowByte = crc & 0x000000ff;\n    const dataByte = dataBytes[i];\n    const tableIndex = crcLowByte ^ dataByte;\n    // The last >>> is to convert this into an unsigned 32-bit integer.\n    crc = (crc32Table[tableIndex] ^ (crc >>> 8)) >>> 0;\n  }\n  return crc;\n}\n\n// This is a small test function for the CRC32 implementation, not normally called but left in\n// for debugging purposes. We know the expected CRC32 of [97, 98, 99, 100, 101] is 2240272485,\n// or 0x8587d865, so if anything else is output we know there's an error in the implementation.\nexport function testCrc32() {\n  const testArray = [97, 98, 99, 100, 101];\n  const testArrayCrc32 = crc32(testArray);\n  _console.log(\"CRC32 for [97, 98, 99, 100, 101] is 0x\" + testArrayCrc32.toString(16) + \" (\" + testArrayCrc32 + \")\");\n}\n","var _TextEncoder;\nif (typeof TextEncoder == \"undefined\") {\n  _TextEncoder = class {\n    encode(string: string) {\n      const encoding = Array.from(string).map((char) => char.charCodeAt(0));\n      return Uint8Array.from(encoding);\n    }\n  };\n} else {\n  _TextEncoder = TextEncoder;\n}\n\nvar _TextDecoder;\nif (typeof TextDecoder == \"undefined\") {\n  _TextDecoder = class {\n    decode(data: ArrayBuffer) {\n      const byteArray = Array.from(new Uint8Array(data));\n      return byteArray\n        .map((value) => {\n          return String.fromCharCode(value);\n        })\n        .join(\"\");\n    }\n  };\n} else {\n  _TextDecoder = TextDecoder;\n}\n\nexport const textEncoder = new _TextEncoder();\nexport const textDecoder = new _TextDecoder();\n","import { createConsole } from \"./Console.ts\";\nimport { textEncoder } from \"./Text.ts\";\n\nconst _console = createConsole(\"ArrayBufferUtils\", { log: false });\n\nexport function concatenateArrayBuffers(...arrayBuffers: any[]): ArrayBuffer {\n  arrayBuffers = arrayBuffers.filter(\n    (arrayBuffer) => arrayBuffer != undefined || arrayBuffer != null\n  );\n  arrayBuffers = arrayBuffers.map((arrayBuffer) => {\n    if (typeof arrayBuffer == \"number\") {\n      const number = arrayBuffer;\n      return Uint8Array.from([Math.floor(number)]);\n    } else if (typeof arrayBuffer == \"boolean\") {\n      const boolean = arrayBuffer;\n      return Uint8Array.from([boolean ? 1 : 0]);\n    } else if (typeof arrayBuffer == \"string\") {\n      const string = arrayBuffer;\n      return stringToArrayBuffer(string);\n    } else if (arrayBuffer instanceof Array) {\n      const array = arrayBuffer;\n      return concatenateArrayBuffers(...array);\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      return arrayBuffer;\n    } else if (\n      \"buffer\" in arrayBuffer &&\n      arrayBuffer.buffer instanceof ArrayBuffer\n    ) {\n      const bufferContainer = arrayBuffer;\n      return bufferContainer.buffer;\n    } else if (arrayBuffer instanceof DataView) {\n      const dataView = arrayBuffer;\n      return dataView.buffer;\n    } else if (typeof arrayBuffer == \"object\") {\n      const object = arrayBuffer;\n      return objectToArrayBuffer(object);\n    } else {\n      return arrayBuffer;\n    }\n  });\n  arrayBuffers = arrayBuffers.filter(\n    (arrayBuffer) => arrayBuffer && \"byteLength\" in arrayBuffer\n  );\n  const length = arrayBuffers.reduce(\n    (length, arrayBuffer) => length + arrayBuffer.byteLength,\n    0\n  );\n  const uint8Array = new Uint8Array(length);\n  let byteOffset = 0;\n  arrayBuffers.forEach((arrayBuffer) => {\n    uint8Array.set(new Uint8Array(arrayBuffer), byteOffset);\n    byteOffset += arrayBuffer.byteLength;\n  });\n  return uint8Array.buffer;\n}\n\nexport function dataToArrayBuffer(data: Buffer) {\n  return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n}\n\nexport function stringToArrayBuffer(string: string) {\n  const encoding = textEncoder.encode(string);\n  return concatenateArrayBuffers(encoding.byteLength, encoding);\n}\n\nexport function objectToArrayBuffer(object: object) {\n  return stringToArrayBuffer(JSON.stringify(object));\n}\n\nexport function sliceDataView(\n  dataView: DataView<ArrayBuffer>,\n  begin: number,\n  length?: number\n) {\n  let end;\n  if (length != undefined) {\n    end = dataView.byteOffset + begin + length;\n  }\n  _console.log({ dataView, begin, end, length });\n  return new DataView(dataView.buffer.slice(dataView.byteOffset + begin, end));\n}\n\nexport type FileLike =\n  | number[]\n  | ArrayBuffer\n  | DataView\n  | URL\n  | string\n  | File\n  | Buffer;\n\nexport async function getFileBuffer(file: FileLike) {\n  let fileBuffer;\n  if (file instanceof Array) {\n    fileBuffer = Uint8Array.from(file);\n  } else if (file instanceof DataView) {\n    fileBuffer = file.buffer;\n  } else if (typeof file == \"string\" || file instanceof URL) {\n    const response = await fetch(file);\n    fileBuffer = await response.arrayBuffer();\n  } else if (file instanceof File) {\n    fileBuffer = await file.arrayBuffer();\n  } else if (file instanceof ArrayBuffer) {\n    fileBuffer = file;\n  } else if (file.buffer instanceof ArrayBuffer) {\n    fileBuffer = file.buffer;\n  } else {\n    throw { error: \"invalid file type\", file };\n  }\n  return fileBuffer;\n}\n\nexport function UInt8ByteBuffer(value: number) {\n  return Uint8Array.from([value]).buffer;\n}\n","// Gets all non-builtin properties up the prototype chain.\nconst getAllProperties = object => {\n\tconst properties = new Set();\n\n\tdo {\n\t\tfor (const key of Reflect.ownKeys(object)) {\n\t\t\tproperties.add([object, key]);\n\t\t}\n\t} while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);\n\n\treturn properties;\n};\n\nexport default function autoBind(self, {include, exclude} = {}) {\n\tconst filter = key => {\n\t\tconst match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\n\t\tif (include) {\n\t\t\treturn include.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\tif (exclude) {\n\t\t\treturn !exclude.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tfor (const [object, key] of getAllProperties(self.constructor.prototype)) {\n\t\tif (key === 'constructor' || !filter(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(object, key);\n\t\tif (descriptor && typeof descriptor.value === 'function') {\n\t\t\tself[key] = self[key].bind(self);\n\t\t}\n\t}\n\n\treturn self;\n}\n","import { createConsole } from \"./utils/Console.ts\";\nimport { crc32 } from \"./utils/checksum.ts\";\nimport { getFileBuffer, UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { FileLike } from \"./utils/ArrayBufferUtils.ts\";\nimport Device, { SendMessageCallback } from \"./Device.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"FileTransferManager\", { log: false });\n\nexport const FileTransferMessageTypes = [\n  \"getFileTypes\",\n  \"maxFileLength\",\n  \"getFileType\",\n  \"setFileType\",\n  \"getFileLength\",\n  \"setFileLength\",\n  \"getFileChecksum\",\n  \"setFileChecksum\",\n  \"setFileTransferCommand\",\n  \"fileTransferStatus\",\n  \"getFileBlock\",\n  \"setFileBlock\",\n  \"fileBytesTransferred\",\n] as const;\nexport type FileTransferMessageType = (typeof FileTransferMessageTypes)[number];\n\nexport const FileTypes = [\n  \"tflite\",\n  \"wifiServerCert\",\n  \"wifiServerKey\",\n  \"spriteSheet\",\n  \"cameraImage\",\n] as const;\nexport type FileType = (typeof FileTypes)[number];\n\nexport const FileTransferStatuses = [\"idle\", \"sending\", \"receiving\"] as const;\nexport type FileTransferStatus = (typeof FileTransferStatuses)[number];\n\nexport const FileTransferCommands = [\n  \"startSend\",\n  \"startReceive\",\n  \"cancel\",\n] as const;\nexport type FileTransferCommand = (typeof FileTransferCommands)[number];\n\nexport const FileTransferDirections = [\"sending\", \"receiving\"] as const;\nexport type FileTransferDirection = (typeof FileTransferDirections)[number];\n\nexport const FileTransferEventTypes = [\n  ...FileTransferMessageTypes,\n  \"fileTransferProgress\",\n  \"fileTransferComplete\",\n  \"fileReceived\",\n] as const;\nexport type FileTransferEventType = (typeof FileTransferEventTypes)[number];\n\nexport const RequiredFileTransferMessageTypes: FileTransferMessageType[] = [\n  \"maxFileLength\",\n  \"getFileLength\",\n  \"getFileChecksum\",\n  \"getFileType\",\n  \"fileTransferStatus\",\n];\n\nexport interface FileConfiguration {\n  file: FileLike;\n  type: FileType;\n}\n\nexport interface FileTransferEventMessages {\n  getFileTypes: { fileTypes: FileType[] };\n  maxFileLength: { maxFileLength: number };\n  getFileType: { fileType: FileType };\n  getFileLength: { fileLength: number };\n  getFileChecksum: { fileChecksum: number };\n  fileTransferStatus: {\n    fileType: FileType;\n    fileTransferStatus: FileTransferStatus;\n  };\n  getFileBlock: { fileTransferBlock: DataView };\n  fileTransferProgress: { fileType: FileType; progress: number };\n  fileTransferComplete: {\n    fileType: FileType;\n    direction: FileTransferDirection;\n  };\n  fileReceived: { fileType: FileType; file: File | Blob };\n}\n\nexport type FileTransferEventDispatcher = EventDispatcher<\n  Device,\n  FileTransferEventType,\n  FileTransferEventMessages\n>;\nexport type SendFileTransferMessageCallback =\n  SendMessageCallback<FileTransferMessageType>;\n\nexport type SendFileCallback = (\n  type: FileType,\n  file: FileLike,\n  override?: boolean\n) => Promise<boolean>;\n\nclass FileTransferManager {\n  constructor() {\n    autoBind(this);\n  }\n  sendMessage!: SendFileTransferMessageCallback;\n\n  eventDispatcher!: FileTransferEventDispatcher;\n  get addEventListener() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  #assertValidType(type: FileType) {\n    _console.assertEnumWithError(type, FileTypes);\n  }\n  #isValidType(type: FileType) {\n    return FileTypes.includes(type);\n  }\n  #assertValidTypeEnum(typeEnum: number) {\n    _console.assertWithError(\n      typeEnum in FileTypes,\n      `invalid typeEnum ${typeEnum}`\n    );\n  }\n\n  #assertValidStatusEnum(statusEnum: number) {\n    _console.assertWithError(\n      statusEnum in FileTransferStatuses,\n      `invalid statusEnum ${statusEnum}`\n    );\n  }\n  #assertValidCommand(command: FileTransferCommand) {\n    _console.assertEnumWithError(command, FileTransferCommands);\n  }\n\n  #fileTypes: FileType[] = [];\n  get fileTypes() {\n    return this.#fileTypes;\n  }\n  #parseFileTypes(dataView: DataView<ArrayBuffer>) {\n    const fileTypes = Array.from(new Uint8Array(dataView.buffer))\n      .map((index) => FileTypes[index])\n      .filter(Boolean);\n    this.#fileTypes = fileTypes;\n    _console.log(\"fileTypes\", fileTypes);\n    this.#dispatchEvent(\"getFileTypes\", {\n      fileTypes: this.#fileTypes,\n    });\n  }\n\n  static #MaxLength = 0; // kB\n  static get MaxLength() {\n    return this.#MaxLength;\n  }\n  #maxLength = FileTransferManager.MaxLength;\n  /** kB */\n  get maxLength() {\n    return this.#maxLength;\n  }\n  #parseMaxLength(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseFileMaxLength\", dataView);\n    const maxLength = dataView.getUint32(0, true);\n    _console.log(`maxLength: ${maxLength / 1024}kB`);\n    this.#updateMaxLength(maxLength);\n  }\n  #updateMaxLength(maxLength: number) {\n    _console.log({ maxLength });\n    this.#maxLength = maxLength;\n    this.#dispatchEvent(\"maxFileLength\", { maxFileLength: maxLength });\n  }\n  #assertValidLength(length: number) {\n    _console.assertWithError(\n      length <= this.maxLength,\n      `file length ${length}kB too large - must be ${this.maxLength}kB or less`\n    );\n  }\n\n  #type: FileType | undefined;\n  get type() {\n    return this.#type;\n  }\n  #parseType(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseFileType\", dataView);\n    const typeEnum = dataView.getUint8(0);\n    this.#assertValidTypeEnum(typeEnum);\n    const type = FileTypes[typeEnum];\n    this.#updateType(type);\n  }\n  #updateType(type: FileType) {\n    _console.log({ fileTransferType: type });\n    this.#type = type;\n    this.#dispatchEvent(\"getFileType\", { fileType: type });\n  }\n  async #setType(newType: FileType, sendImmediately?: boolean) {\n    this.#assertValidType(newType);\n    if (this.type == newType) {\n      _console.log(`redundant type assignment ${newType}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getFileType\");\n\n    const typeEnum = FileTypes.indexOf(newType);\n\n    this.sendMessage(\n      [{ type: \"setFileType\", data: UInt8ByteBuffer(typeEnum) }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #length = 0;\n  get length() {\n    return this.#length;\n  }\n  #parseLength(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseFileLength\", dataView);\n    const length = dataView.getUint32(0, true);\n\n    this.#updateLength(length);\n  }\n  #updateLength(length: number) {\n    _console.log(`length: ${length / 1024}kB (${length} bytes)`);\n    this.#length = length;\n    this.#dispatchEvent(\"getFileLength\", { fileLength: length });\n  }\n  async #setLength(newLength: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newLength, \"number\");\n    this.#assertValidLength(newLength);\n    if (this.length == newLength) {\n      _console.log(`redundant length assignment ${newLength}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getFileLength\");\n\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setUint32(0, newLength, true);\n    this.sendMessage(\n      [{ type: \"setFileLength\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #checksum = 0;\n  get checksum() {\n    return this.#checksum;\n  }\n  #parseChecksum(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"checksum\", dataView);\n    const checksum = dataView.getUint32(0, true);\n    this.#updateChecksum(checksum);\n  }\n  #updateChecksum(checksum: number) {\n    _console.log({ checksum });\n    this.#checksum = checksum;\n    this.#dispatchEvent(\"getFileChecksum\", { fileChecksum: checksum });\n  }\n  async #setChecksum(newChecksum: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newChecksum, \"number\");\n    if (this.checksum == newChecksum) {\n      _console.log(`redundant checksum assignment ${newChecksum}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getFileChecksum\");\n\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setUint32(0, newChecksum, true);\n    this.sendMessage(\n      [{ type: \"setFileChecksum\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  async #setCommand(command: FileTransferCommand, sendImmediately?: boolean) {\n    this.#assertValidCommand(command);\n\n    const promise = this.waitForEvent(\"fileTransferStatus\");\n    _console.log(`setting command ${command}`);\n    const commandEnum = FileTransferCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"setFileTransferCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #status: FileTransferStatus = \"idle\";\n  get status() {\n    return this.#status;\n  }\n  #parseStatus(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseFileStatus\", dataView);\n    const statusEnum = dataView.getUint8(0);\n    this.#assertValidStatusEnum(statusEnum);\n    const status = FileTransferStatuses[statusEnum];\n    this.#updateStatus(status);\n  }\n  #updateStatus(status: FileTransferStatus) {\n    _console.log({ status });\n    this.#status = status;\n    this.#receivedBlocks.length = 0;\n    this.#isCancelling = false;\n    this.#buffer = undefined;\n    this.#bytesTransferred = 0;\n    this.#dispatchEvent(\"fileTransferStatus\", {\n      fileTransferStatus: status,\n      fileType: this.type!,\n    });\n  }\n  #assertIsIdle() {\n    _console.assertWithError(this.#status == \"idle\", \"status is not idle\");\n  }\n  #assertIsNotIdle() {\n    _console.assertWithError(this.#status != \"idle\", \"status is idle\");\n  }\n\n  // BLOCK\n\n  #receivedBlocks: ArrayBuffer[] = [];\n\n  async #parseBlock(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseFileBlock\", dataView);\n    this.#receivedBlocks.push(dataView.buffer);\n\n    const bytesReceived = this.#receivedBlocks.reduce(\n      (sum, arrayBuffer) => (sum += arrayBuffer.byteLength),\n      0\n    );\n    const progress = bytesReceived / this.#length;\n\n    _console.log(\n      `received ${bytesReceived}/${this.#length} bytes (${progress * 100}%) - ${\n        this.#length - bytesReceived\n      } bytes remaining`\n    );\n\n    this.#dispatchEvent(\"fileTransferProgress\", {\n      progress,\n      fileType: this.type!,\n    });\n\n    if (bytesReceived != this.#length) {\n      const dataView = new DataView(new ArrayBuffer(4));\n      dataView.setUint32(0, bytesReceived, true);\n\n      if (this.isServerSide) {\n        return;\n      }\n      await this.sendMessage([\n        { type: \"fileBytesTransferred\", data: dataView.buffer },\n      ]);\n      return;\n    }\n\n    _console.log(\"file transfer complete\");\n\n    let fileName = new Date().toLocaleString();\n    switch (this.type) {\n      case \"tflite\":\n        fileName += \".tflite\";\n        break;\n      case \"wifiServerCert\":\n        fileName += \"_server.crt\";\n        break;\n      case \"wifiServerKey\":\n        fileName += \"_server.key\";\n        break;\n    }\n\n    let file: File | Blob;\n    if (typeof File !== \"undefined\") {\n      file = new File(this.#receivedBlocks, fileName);\n    } else {\n      file = new Blob(this.#receivedBlocks);\n    }\n\n    const arrayBuffer = await file.arrayBuffer();\n    const checksum = crc32(arrayBuffer);\n    _console.log({ checksum });\n\n    if (checksum != this.#checksum) {\n      _console.error(\n        `wrong checksum - expected ${this.#checksum}, got ${checksum}`\n      );\n      return;\n    }\n\n    _console.log(\"received file\", file);\n\n    this.#dispatchEvent(\"getFileBlock\", { fileTransferBlock: dataView });\n    this.#dispatchEvent(\"fileTransferComplete\", {\n      direction: \"receiving\",\n      fileType: this.type!,\n    });\n    this.#dispatchEvent(\"fileReceived\", { file, fileType: this.type! });\n  }\n\n  parseMessage(\n    messageType: FileTransferMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getFileTypes\":\n        this.#parseFileTypes(dataView);\n        break;\n      case \"maxFileLength\":\n        this.#parseMaxLength(dataView);\n        break;\n      case \"getFileType\":\n      case \"setFileType\":\n        this.#parseType(dataView);\n        break;\n      case \"getFileLength\":\n      case \"setFileLength\":\n        this.#parseLength(dataView);\n        break;\n      case \"getFileChecksum\":\n      case \"setFileChecksum\":\n        this.#parseChecksum(dataView);\n        break;\n      case \"fileTransferStatus\":\n        this.#parseStatus(dataView);\n        break;\n      case \"getFileBlock\":\n        this.#parseBlock(dataView);\n        break;\n      case \"fileBytesTransferred\":\n        this.#parseBytesTransferred(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  async send(type: FileType, file: FileLike, override?: boolean) {\n    if (true) {\n      this.#assertIsIdle();\n      this.#assertValidType(type);\n    } else {\n      if (this.status != \"idle\") {\n        _console.warn(`cannot send file - status is ${this.status}`);\n        return false;\n      }\n      if (!this.#isValidType(type)) {\n        _console.warn(`invalid fileType ${type}`);\n        return false;\n      }\n    }\n\n    const fileBuffer = await getFileBuffer(file);\n    const fileLength = fileBuffer.byteLength;\n    // @ts-expect-error\n    const checksum = crc32(fileBuffer);\n    this.#assertValidLength(fileLength);\n\n    if (!override) {\n      if (type != this.type) {\n        _console.log(\"different fileTypes - sending\");\n      } else if (fileLength != this.length) {\n        _console.log(\"different fileLengths - sending\");\n      } else if (checksum != this.checksum) {\n        _console.log(\"different fileChecksums - sending\");\n      } else {\n        _console.log(\"already sent file\");\n        return false;\n      }\n    }\n\n    const promises: Promise<any>[] = [];\n\n    promises.push(this.#setType(type, false));\n    promises.push(this.#setLength(fileLength, false));\n    promises.push(this.#setChecksum(checksum, false));\n    promises.push(this.#setCommand(\"startSend\", false));\n\n    this.sendMessage();\n\n    await Promise.all(promises);\n\n    if (this.#buffer) {\n      return false;\n    }\n    if (this.#length != fileLength) {\n      return false;\n    }\n    if (this.#checksum != checksum) {\n      return false;\n    }\n\n    // @ts-expect-error\n    await this.#send(fileBuffer);\n\n    return true;\n  }\n\n  #buffer?: ArrayBuffer;\n  #bytesTransferred = 0;\n  async #send(buffer: ArrayBuffer) {\n    this.#buffer = buffer;\n    return this.#sendBlock();\n  }\n\n  mtu!: number;\n  async #sendBlock(): Promise<void> {\n    if (this.status != \"sending\") {\n      return;\n    }\n    if (this.#isCancelling) {\n      _console.error(\"not sending block - busy cancelling\");\n      return;\n    }\n    if (!this.#buffer) {\n      if (!this.isServerSide) {\n        _console.error(\"no buffer defined\");\n      }\n      return;\n    }\n\n    const buffer = this.#buffer;\n    let offset = this.#bytesTransferred;\n\n    _console.log(\"sending block\", { buffer, offset, mtu: this.mtu });\n\n    const slicedBuffer = buffer.slice(offset, offset + (this.mtu - 3 - 3));\n    _console.log(\"slicedBuffer\", slicedBuffer);\n    const bytesLeft = buffer.byteLength - offset;\n\n    const progress = 1 - bytesLeft / buffer.byteLength;\n    _console.log(\n      `sending bytes ${offset}-${offset + slicedBuffer.byteLength} of ${\n        buffer.byteLength\n      } bytes (${progress * 100}%)`\n    );\n    this.#dispatchEvent(\"fileTransferProgress\", {\n      progress,\n      fileType: this.type!,\n    });\n    if (slicedBuffer.byteLength == 0) {\n      _console.log(\"finished sending buffer\");\n      this.#dispatchEvent(\"fileTransferComplete\", {\n        direction: \"sending\",\n        fileType: this.type!,\n      });\n    } else {\n      this.#bytesTransferred = offset + slicedBuffer.byteLength;\n      await this.sendMessage([{ type: \"setFileBlock\", data: slicedBuffer }]);\n      //return this.#sendBlock(buffer, offset + slicedBuffer.byteLength);\n    }\n  }\n\n  async #parseBytesTransferred(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseBytesTransferred\", dataView);\n    const bytesTransferred = dataView.getUint32(0, true);\n    _console.log({ bytesTransferred });\n    if (this.status != \"sending\") {\n      _console.error(`not currently sending file`);\n      return;\n    }\n    if (!this.isServerSide && this.#bytesTransferred != bytesTransferred) {\n      _console.error(\n        `bytesTransferred are not equal - got ${bytesTransferred}, expected ${\n          this.#bytesTransferred\n        }`\n      );\n      this.cancel();\n      return;\n    }\n    this.#sendBlock();\n  }\n\n  async receive(type: FileType) {\n    this.#assertIsIdle();\n\n    this.#assertValidType(type);\n\n    await this.#setType(type);\n    await this.#setCommand(\"startReceive\");\n  }\n\n  #isCancelling = false;\n  async cancel() {\n    this.#assertIsNotIdle();\n    _console.log(\"cancelling file transfer...\");\n    this.#isCancelling = true;\n    await this.#setCommand(\"cancel\");\n  }\n\n  // SERVER SIDE\n  #isServerSide = false;\n  get isServerSide() {\n    return this.#isServerSide;\n  }\n  set isServerSide(newIsServerSide) {\n    if (this.#isServerSide == newIsServerSide) {\n      _console.log(\"redundant isServerSide assignment\");\n      return;\n    }\n    _console.log({ newIsServerSide });\n    this.#isServerSide = newIsServerSide;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required fileTransfer information\");\n    const messages = RequiredFileTransferMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  clear() {\n    this.#receivedBlocks.length = 0;\n    this.#isCancelling = false;\n    this.#buffer = undefined;\n    this.#bytesTransferred = 0;\n    this.#isServerSide = false;\n    this.#checksum = 0;\n    this.#fileTypes.length = 0;\n    this.#type = undefined;\n    this.#length = 0;\n    this.#checksum = 0;\n    this.#status = \"idle\";\n    // @ts-expect-error\n    this.mtu = undefined;\n  }\n}\n\nexport default FileTransferManager;\n","import { PressureSensorPosition } from \"../sensor/PressureSensorDataManager.ts\";\nimport { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"MathUtils\", { log: false });\n\nexport function getInterpolation(\n  value: number,\n  min: number,\n  max: number,\n  span: number\n) {\n  if (span == undefined) {\n    span = max - min;\n  }\n  return (value - min) / span;\n}\n\nexport const Uint16Max = 2 ** 16;\nexport const Int16Max = 2 ** 15;\nexport const Int16Min = -(2 ** 15) - 1;\n\nfunction removeLower2Bytes(number: number) {\n  const lower2Bytes = number % Uint16Max;\n  return number - lower2Bytes;\n}\n\nconst timestampThreshold = 60_000;\n\nexport function parseTimestamp(\n  dataView: DataView<ArrayBuffer>,\n  byteOffset: number\n) {\n  const now = Date.now();\n  const nowWithoutLower2Bytes = removeLower2Bytes(now);\n  const lower2Bytes = dataView.getUint16(byteOffset, true);\n  let timestamp = nowWithoutLower2Bytes + lower2Bytes;\n  const timestampDifference = Math.abs(now - timestamp);\n  if (timestampDifference > timestampThreshold) {\n    _console.log(\"correcting timestamp delta\");\n    timestamp += Uint16Max * Math.sign(now - timestamp);\n  }\n  _console.log({\n    now,\n    nowWithoutLower2Bytes,\n    lower2Bytes,\n    timestamp,\n    timestampDifference,\n  });\n  return timestamp;\n}\n\nexport interface Vector2 {\n  x: number;\n  y: number;\n}\n\nexport function getVector2Length(vector: Vector2) {\n  const { x, y } = vector;\n  return Math.sqrt(x ** 2 + y ** 2);\n}\n\nexport function getVector2Distance(a: Vector2, b: Vector2) {\n  return Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);\n}\n\nexport function getVector2DistanceSquared(a: Vector2, b: Vector2) {\n  return (b.x - a.x) ** 2 + (b.y - a.y) ** 2;\n}\n\nexport function getVector2Angle(vector: Vector2) {\n  const { x, y } = vector;\n  return Math.atan2(y, x);\n}\n\nexport function getVector2Midpoint(a: Vector2, b: Vector2): Vector2 {\n  return {\n    x: (a.x + b.x) / 2,\n    y: (a.y + b.y) / 2,\n  };\n}\n\nexport function multiplyVector2ByScalar(\n  vector: Vector2,\n  scalar: number\n): Vector2 {\n  let { x, y } = vector;\n  x *= scalar;\n  y *= scalar;\n  return { x, y };\n}\nexport function normalizedVector2(vector: Vector2): Vector2 {\n  return multiplyVector2ByScalar(vector, 1 / getVector2Length(vector));\n}\n\nexport interface Vector3 extends Vector2 {\n  z: number;\n}\n\nexport interface Quaternion {\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\nexport interface Euler {\n  heading: number;\n  pitch: number;\n  roll: number;\n}\n\nexport function computeVoronoiWeights(\n  points: PressureSensorPosition[],\n  sampleCount = 100000\n) {\n  const n = points.length;\n  const counts = new Array(n).fill(0);\n\n  for (let i = 0; i < sampleCount; i++) {\n    const x = Math.random();\n    const y = Math.random();\n\n    // Find the closest input point\n    let minDist = Infinity;\n    let closestIndex = -1;\n\n    for (let j = 0; j < n; j++) {\n      const { x: px, y: py } = points[j];\n      const dist = (px - x) ** 2 + (py - y) ** 2; // Squared Euclidean distance\n      if (dist < minDist) {\n        minDist = dist;\n        closestIndex = j;\n      }\n    }\n\n    // Increment count for the closest point\n    counts[closestIndex]++;\n  }\n\n  // Convert counts to weights (sum to 1)\n  return counts.map((c) => c / sampleCount);\n}\n\nexport function getVector3Length(vector: Vector3) {\n  const { x, y, z } = vector;\n  return Math.sqrt(x ** 2 + y ** 2 + z ** 2);\n}\n\nexport function clamp(value: number, min: number = 0, max: number = 1) {\n  return Math.min(Math.max(value, min), max);\n}\n\nexport function degToRad(deg: number) {\n  return deg * (Math.PI / 180);\n}\n\nexport function radToDeg(rad: number) {\n  return rad * (180 / Math.PI);\n}\n\nexport const twoPi = Math.PI * 2;\nexport function normalizeRadians(rad: number): number {\n  return ((rad % twoPi) + twoPi) % twoPi;\n}\n\nexport function pointInPolygon(pt: Vector2, polygon: Vector2[]): boolean {\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x,\n      yi = polygon[i].y;\n    const xj = polygon[j].x,\n      yj = polygon[j].y;\n\n    const intersect =\n      yi > pt.y !== yj > pt.y &&\n      pt.x < ((xj - xi) * (pt.y - yi)) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\n","import { getInterpolation } from \"./MathUtils.ts\";\n\nexport interface Range {\n  min: number;\n  max: number;\n  span: number;\n}\n\nconst initialRange: Range = { min: Infinity, max: -Infinity, span: 0 };\n\nclass RangeHelper {\n  #range: Range = structuredClone(initialRange);\n  get min() {\n    return this.#range.min;\n  }\n  get max() {\n    return this.#range.max;\n  }\n  get span() {\n    return this.#range.span;\n  }\n\n  get range() {\n    return structuredClone(this.#range);\n  }\n\n  set min(newMin) {\n    this.#range.min = newMin;\n    this.#range.max = Math.max(newMin, this.#range.max);\n    this.#updateSpan();\n  }\n  set max(newMax) {\n    this.#range.max = newMax;\n    this.#range.min = Math.min(newMax, this.#range.min);\n    this.#updateSpan();\n  }\n\n  #updateSpan() {\n    this.#range.span = this.#range.max - this.#range.min;\n  }\n\n  reset() {\n    Object.assign(this.#range, initialRange);\n  }\n\n  update(value: number) {\n    this.#range.min = Math.min(value, this.#range.min);\n    this.#range.max = Math.max(value, this.#range.max);\n    this.#updateSpan();\n  }\n\n  getNormalization(value: number, weightByRange: boolean) {\n    let normalization = getInterpolation(\n      value,\n      this.#range.min,\n      this.#range.max,\n      this.#range.span\n    );\n    if (weightByRange) {\n      normalization *= this.#range.span;\n    }\n    return normalization || 0;\n  }\n\n  updateAndGetNormalization(value: number, weightByRange: boolean) {\n    this.update(value);\n    return this.getNormalization(value, weightByRange);\n  }\n}\n\nexport default RangeHelper;\n","import RangeHelper from \"./RangeHelper.ts\";\n\nimport { Vector2 } from \"./MathUtils.ts\";\n\nexport type CenterOfPressure = Vector2;\n\nexport interface CenterOfPressureRange {\n  x: RangeHelper;\n  y: RangeHelper;\n}\n\nclass CenterOfPressureHelper {\n  #range: CenterOfPressureRange = {\n    x: new RangeHelper(),\n    y: new RangeHelper(),\n  };\n  reset() {\n    this.#range.x.reset();\n    this.#range.y.reset();\n  }\n\n  update(centerOfPressure: CenterOfPressure) {\n    this.#range.x.update(centerOfPressure.x);\n    this.#range.y.update(centerOfPressure.y);\n  }\n  getNormalization(centerOfPressure: CenterOfPressure, weightByRange: boolean): CenterOfPressure {\n    return {\n      x: this.#range.x.getNormalization(centerOfPressure.x, weightByRange),\n      y: this.#range.y.getNormalization(centerOfPressure.y, weightByRange),\n    };\n  }\n\n  updateAndGetNormalization(centerOfPressure: CenterOfPressure, weightByRange: boolean) {\n    this.update(centerOfPressure);\n    return this.getNormalization(centerOfPressure, weightByRange);\n  }\n}\n\nexport default CenterOfPressureHelper;\n","import { createConsole } from \"../utils/Console.ts\";\nimport CenterOfPressureHelper from \"../utils/CenterOfPressureHelper.ts\";\nimport RangeHelper from \"../utils/RangeHelper.ts\";\nimport { createArray } from \"../utils/ArrayUtils.ts\";\n\nconst _console = createConsole(\"PressureDataManager\", { log: false });\n\nexport const PressureSensorTypes = [\"pressure\"] as const;\nexport type PressureSensorType = (typeof PressureSensorTypes)[number];\n\nexport const ContinuousPressureSensorTypes = PressureSensorTypes;\nexport type ContinuousPressureSensorType =\n  (typeof ContinuousPressureSensorTypes)[number];\n\nimport { computeVoronoiWeights, Vector2 } from \"../utils/MathUtils.ts\";\nexport type PressureSensorPosition = Vector2;\n\nimport { CenterOfPressure } from \"../utils/CenterOfPressureHelper.ts\";\n\nexport interface PressureSensorValue {\n  position: PressureSensorPosition;\n  rawValue: number;\n  scaledValue: number;\n  normalizedValue: number;\n  weightedValue: number;\n}\n\nexport interface PressureData {\n  sensors: PressureSensorValue[];\n  scaledSum: number;\n  normalizedSum: number;\n  center?: CenterOfPressure;\n  normalizedCenter?: CenterOfPressure;\n}\n\nexport interface PressureDataEventMessages {\n  pressure: { pressure: PressureData };\n}\n\nexport const DefaultNumberOfPressureSensors = 8;\n\nclass PressureSensorDataManager {\n  #positions: PressureSensorPosition[] = [];\n  get positions() {\n    return this.#positions;\n  }\n\n  get numberOfSensors() {\n    return this.positions.length;\n  }\n\n  parsePositions(dataView: DataView<ArrayBuffer>) {\n    const positions: PressureSensorPosition[] = [];\n\n    for (\n      let pressureSensorIndex = 0, byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      pressureSensorIndex++, byteOffset += 2\n    ) {\n      positions.push({\n        x: dataView.getUint8(byteOffset) / 2 ** 8,\n        y: dataView.getUint8(byteOffset + 1) / 2 ** 8,\n      });\n    }\n\n    _console.log({ positions });\n\n    this.#positions = positions;\n\n    this.#sensorRangeHelpers = createArray(\n      this.numberOfSensors,\n      () => new RangeHelper()\n    );\n\n    this.resetRange();\n  }\n\n  #sensorRangeHelpers!: RangeHelper[];\n  #normalizedSumRangeHelper = new RangeHelper();\n\n  #centerOfPressureHelper = new CenterOfPressureHelper();\n\n  resetRange() {\n    this.#sensorRangeHelpers?.forEach((rangeHelper) => rangeHelper.reset());\n    this.#centerOfPressureHelper.reset();\n    this.#normalizedSumRangeHelper.reset();\n  }\n\n  parseData(dataView: DataView<ArrayBuffer>, scalar: number) {\n    const pressure: PressureData = {\n      sensors: [],\n      scaledSum: 0,\n      normalizedSum: 0,\n    };\n    for (\n      let index = 0, byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      index++, byteOffset += 2\n    ) {\n      const rawValue = dataView.getUint16(byteOffset, true);\n      let scaledValue = (rawValue * scalar) / this.numberOfSensors;\n      const rangeHelper = this.#sensorRangeHelpers[index];\n      const normalizedValue = rangeHelper.updateAndGetNormalization(\n        scaledValue,\n        false\n      );\n      //scaledValue -= rangeHelper.min;\n\n      const position = this.positions[index];\n      pressure.sensors[index] = {\n        rawValue,\n        scaledValue,\n        normalizedValue,\n        position,\n        weightedValue: 0,\n      };\n\n      pressure.scaledSum += scaledValue;\n      //pressure.normalizedSum += normalizedValue;\n    }\n    pressure.normalizedSum =\n      this.#normalizedSumRangeHelper.updateAndGetNormalization(\n        pressure.scaledSum,\n        false\n      );\n\n    if (pressure.scaledSum > 0) {\n      pressure.center = { x: 0, y: 0 };\n      pressure.sensors.forEach((sensor) => {\n        sensor.weightedValue = sensor.scaledValue / pressure.scaledSum;\n        pressure.center!.x += sensor.position.x * sensor.weightedValue;\n        pressure.center!.y += sensor.position.y * sensor.weightedValue;\n      });\n      pressure.normalizedCenter =\n        this.#centerOfPressureHelper.updateAndGetNormalization(\n          pressure.center,\n          false\n        );\n    }\n\n    _console.log({ pressure });\n    return pressure;\n  }\n}\n\nexport default PressureSensorDataManager;\n","export function createArray(arrayLength: number, objectOrCallback: ((index: number) => any) | object) {\n  return new Array(arrayLength).fill(1).map((_, index) => {\n    if (typeof objectOrCallback == \"function\") {\n      const callback = objectOrCallback;\n      return callback(index);\n    } else {\n      const object = objectOrCallback;\n      return Object.assign({}, object);\n    }\n  });\n}\n\nexport function arrayWithoutDuplicates(array: any[]) {\n  return array.filter((value, index) => array.indexOf(value) == index);\n}\n","import { createConsole } from \"../utils/Console.ts\";\n\nconst _console = createConsole(\"MotionSensorDataManager\", { log: false });\n\nexport const MotionSensorTypes = [\n  \"acceleration\",\n  \"gravity\",\n  \"linearAcceleration\",\n  \"gyroscope\",\n  \"magnetometer\",\n  \"gameRotation\",\n  \"rotation\",\n  \"orientation\",\n  \"activity\",\n  \"stepCounter\",\n  \"stepDetector\",\n  \"deviceOrientation\",\n  \"tapDetector\",\n] as const;\nexport type MotionSensorType = (typeof MotionSensorTypes)[number];\n\nexport const ContinuousMotionTypes = [\n  \"acceleration\",\n  \"gravity\",\n  \"linearAcceleration\",\n  \"gyroscope\",\n  \"magnetometer\",\n  \"gameRotation\",\n  \"rotation\",\n  \"orientation\",\n] as const;\nexport type ContinuousMotionType = (typeof ContinuousMotionTypes)[number];\n\nimport { Vector3, Quaternion, Euler } from \"../utils/MathUtils.ts\";\nimport { ValueOf } from \"../utils/TypeScriptUtils.ts\";\n\nexport const Vector2Size = 2 * 2;\nexport const Vector3Size = 3 * 2;\nexport const QuaternionSize = 4 * 2;\n\nexport const ActivityTypes = [\n  \"still\",\n  \"walking\",\n  \"running\",\n  \"bicycle\",\n  \"vehicle\",\n  \"tilting\",\n] as const;\nexport type ActivityType = (typeof ActivityTypes)[number];\n\nexport interface Activity {\n  still: boolean;\n  walking: boolean;\n  running: boolean;\n  bicycle: boolean;\n  vehicle: boolean;\n  tilting: boolean;\n}\n\nexport const DeviceOrientations = [\n  \"portraitUpright\",\n  \"landscapeLeft\",\n  \"portraitUpsideDown\",\n  \"landscapeRight\",\n  \"unknown\",\n] as const;\nexport type DeviceOrientation = (typeof DeviceOrientations)[number];\n\nexport interface MotionSensorDataEventMessages {\n  acceleration: { acceleration: Vector3 };\n  gravity: { gravity: Vector3 };\n  linearAcceleration: { linearAcceleration: Vector3 };\n  gyroscope: { gyroscope: Vector3 };\n  magnetometer: { magnetometer: Vector3 };\n  gameRotation: { gameRotation: Quaternion };\n  rotation: { rotation: Quaternion };\n  orientation: { orientation: Euler };\n  stepDetector: { stepDetector: Object };\n  stepCounter: { stepCounter: number };\n  activity: { activity: Activity };\n  deviceOrientation: { deviceOrientation: DeviceOrientation };\n  tapDetector: { tapDetector: Object };\n}\n\nexport type MotionSensorDataEventMessage =\n  ValueOf<MotionSensorDataEventMessages>;\n\nclass MotionSensorDataManager {\n  parseVector3(dataView: DataView<ArrayBuffer>, scalar: number): Vector3 {\n    let [x, y, z] = [\n      dataView.getInt16(0, true),\n      dataView.getInt16(2, true),\n      dataView.getInt16(4, true),\n    ].map((value) => value * scalar);\n\n    const vector: Vector3 = { x, y, z };\n\n    _console.log({ vector });\n    return vector;\n  }\n\n  parseQuaternion(dataView: DataView<ArrayBuffer>, scalar: number): Quaternion {\n    let [x, y, z, w] = [\n      dataView.getInt16(0, true),\n      dataView.getInt16(2, true),\n      dataView.getInt16(4, true),\n      dataView.getInt16(6, true),\n    ].map((value) => value * scalar);\n\n    const quaternion: Quaternion = { x, y, z, w };\n\n    _console.log({ quaternion });\n    return quaternion;\n  }\n\n  parseEuler(dataView: DataView<ArrayBuffer>, scalar: number): Euler {\n    let [heading, pitch, roll] = [\n      dataView.getInt16(0, true),\n      dataView.getInt16(2, true),\n      dataView.getInt16(4, true),\n    ].map((value) => value * scalar);\n\n    pitch *= -1;\n    heading *= -1;\n    if (heading < 0) {\n      heading += 360;\n    }\n\n    const euler: Euler = { heading, pitch, roll };\n\n    _console.log({ euler });\n    return euler;\n  }\n\n  parseStepCounter(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseStepCounter\", dataView);\n    const stepCount = dataView.getUint32(0, true);\n    _console.log({ stepCount });\n    return stepCount;\n  }\n\n  parseActivity(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseActivity\", dataView);\n    const activity: Partial<Activity> = {};\n\n    const activityBitfield = dataView.getUint8(0);\n    _console.log(\"activityBitfield\", activityBitfield.toString(2));\n    ActivityTypes.forEach((activityType, index) => {\n      activity[activityType] = Boolean(activityBitfield & (1 << index));\n    });\n\n    _console.log(\"activity\", activity);\n\n    return activity as Activity;\n  }\n\n  parseDeviceOrientation(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseDeviceOrientation\", dataView);\n    const index = dataView.getUint8(0);\n    const deviceOrientation = DeviceOrientations[index];\n    _console.assertWithError(deviceOrientation, \"undefined deviceOrientation\");\n    _console.log({ deviceOrientation });\n    return deviceOrientation;\n  }\n}\n\nexport default MotionSensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\n\nexport const BarometerSensorTypes = [\"barometer\"] as const;\nexport type BarometerSensorType = (typeof BarometerSensorTypes)[number];\n\nexport const ContinuousBarometerSensorTypes = BarometerSensorTypes;\nexport type ContinuousBarometerSensorType =\n  (typeof ContinuousBarometerSensorTypes)[number];\n\nexport interface BarometerSensorDataEventMessages {\n  barometer: {\n    barometer: number;\n    //altitude: number;\n  };\n}\n\nconst _console = createConsole(\"BarometerSensorDataManager\", { log: false });\n\nclass BarometerSensorDataManager {\n  #calculcateAltitude(pressure: number) {\n    const P0 = 101325; // Standard atmospheric pressure at sea level in Pascals\n    const T0 = 288.15; // Standard temperature at sea level in Kelvin\n    const L = 0.0065; // Temperature lapse rate in K/m\n    const R = 8.3144598; // Universal gas constant in J/(molK)\n    const g = 9.80665; // Acceleration due to gravity in m/s\n    const M = 0.0289644; // Molar mass of Earth's air in kg/mol\n\n    const exponent = (R * L) / (g * M);\n    const h = (T0 / L) * (1 - Math.pow(pressure / P0, exponent));\n\n    return h;\n  }\n\n  parseData(dataView: DataView<ArrayBuffer>, scalar: number) {\n    const pressure = dataView.getUint32(0, true) * scalar;\n    const altitude = this.#calculcateAltitude(pressure);\n    _console.log({ pressure, altitude });\n    return { pressure };\n  }\n}\n\nexport default BarometerSensorDataManager;\n","import { sliceDataView } from \"./ArrayBufferUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { textDecoder } from \"./Text.ts\";\n\nconst _console = createConsole(\"ParseUtils\", { log: false });\n\nexport function parseStringFromDataView(\n  dataView: DataView<ArrayBuffer>,\n  byteOffset: number = 0\n) {\n  const stringLength = dataView.getUint8(byteOffset++);\n  const string = textDecoder.decode(\n    dataView.buffer.slice(\n      dataView.byteOffset + byteOffset,\n      dataView.byteOffset + byteOffset + stringLength\n    )\n  );\n  byteOffset += stringLength;\n  return { string, byteOffset };\n}\n\nexport function parseMessage<MessageType extends string>(\n  dataView: DataView<ArrayBuffer>,\n  messageTypes: readonly MessageType[],\n  callback: (\n    messageType: MessageType,\n    dataView: DataView<ArrayBuffer>,\n    context?: any,\n    isLast?: boolean\n  ) => void,\n  context?: any,\n  parseMessageLengthAsUint16: boolean = false\n) {\n  let byteOffset = 0;\n  while (byteOffset < dataView.byteLength) {\n    const messageTypeEnum = dataView.getUint8(byteOffset++);\n    _console.assertWithError(\n      messageTypeEnum in messageTypes,\n      `invalid messageTypeEnum ${messageTypeEnum}`\n    );\n    const messageType = messageTypes[messageTypeEnum];\n\n    let messageLength: number;\n    if (parseMessageLengthAsUint16) {\n      messageLength = dataView.getUint16(byteOffset, true);\n      byteOffset += 2;\n    } else {\n      messageLength = dataView.getUint8(byteOffset++);\n    }\n\n    _console.log({\n      messageTypeEnum,\n      messageType,\n      messageLength,\n      dataView,\n      byteOffset,\n    });\n\n    const _dataView = sliceDataView(dataView, byteOffset, messageLength);\n    _console.log({ _dataView });\n\n    byteOffset += messageLength;\n    const isLast = byteOffset >= dataView.byteLength;\n    callback(messageType, _dataView, context, isLast);\n  }\n}\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInBrowser, isInNode } from \"./utils/environment.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\nimport { parseMessage } from \"./utils/ParseUtils.ts\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./utils/ArrayBufferUtils.ts\";\n\nconst _console = createConsole(\"CameraManager\", { log: false });\n\nexport const CameraSensorTypes = [\"camera\"] as const;\nexport type CameraSensorType = (typeof CameraSensorTypes)[number];\n\nexport const CameraCommands = [\n  \"focus\",\n  \"takePicture\",\n  \"stop\",\n  \"sleep\",\n  \"wake\",\n] as const;\nexport type CameraCommand = (typeof CameraCommands)[number];\n\nexport const CameraStatuses = [\n  \"idle\",\n  \"focusing\",\n  \"takingPicture\",\n  \"asleep\",\n] as const;\nexport type CameraStatus = (typeof CameraStatuses)[number];\n\nexport const CameraDataTypes = [\n  \"headerSize\",\n  \"header\",\n  \"imageSize\",\n  \"image\",\n  \"footerSize\",\n  \"footer\",\n] as const;\nexport type CameraDataType = (typeof CameraDataTypes)[number];\n\nexport const CameraConfigurationTypes = [\n  \"resolution\",\n  \"qualityFactor\",\n  \"shutter\",\n  \"gain\",\n  \"redGain\",\n  \"greenGain\",\n  \"blueGain\",\n  \"autoWhiteBalanceEnabled\",\n  \"autoGainEnabled\",\n  \"exposure\",\n  \"autoExposureEnabled\",\n  \"autoExposureLevel\",\n  \"brightness\",\n  \"saturation\",\n  \"contrast\",\n  \"sharpness\",\n] as const;\nexport type CameraConfigurationType = (typeof CameraConfigurationTypes)[number];\n\nexport const CameraMessageTypes = [\n  \"cameraStatus\",\n  \"cameraCommand\",\n  \"getCameraConfiguration\",\n  \"setCameraConfiguration\",\n  \"cameraData\",\n] as const;\nexport type CameraMessageType = (typeof CameraMessageTypes)[number];\n\nexport type CameraConfiguration = {\n  [cameraConfigurationType in CameraConfigurationType]?: number;\n};\nexport type CameraConfigurationRanges = {\n  [cameraConfigurationType in CameraConfigurationType]: {\n    min: number;\n    max: number;\n  };\n};\n\nexport const RequiredCameraMessageTypes: CameraMessageType[] = [\n  \"getCameraConfiguration\",\n  \"cameraStatus\",\n] as const;\n\nexport const CameraEventTypes = [\n  ...CameraMessageTypes,\n  \"cameraImageProgress\",\n  \"cameraImage\",\n  \"isRecordingCamera\",\n  \"cameraRecording\",\n  \"autoPicture\",\n] as const;\nexport type CameraEventType = (typeof CameraEventTypes)[number];\n\nexport interface CameraImage {\n  blob: Blob;\n  url: string;\n  timestamp: number;\n  latency: number;\n}\nexport interface CameraEventMessages {\n  cameraStatus: {\n    cameraStatus: CameraStatus;\n    previousCameraStatus: CameraStatus;\n  };\n  getCameraConfiguration: { cameraConfiguration: CameraConfiguration };\n  cameraImageProgress: { progress: number; type: CameraDataType };\n  cameraImage: CameraImage;\n  isRecordingCamera: {\n    isRecordingCamera: boolean;\n  };\n  cameraRecording: {\n    images: CameraImage[];\n    configuration: CameraConfiguration;\n    blob: Blob;\n    url: string;\n  };\n  autoPicture: {\n    autoPicture: boolean;\n  };\n}\n\nexport type CameraEventDispatcher = EventDispatcher<\n  Device,\n  CameraEventType,\n  CameraEventMessages\n>;\nexport type SendCameraMessageCallback = SendMessageCallback<CameraMessageType>;\n\nclass CameraManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendCameraMessageCallback;\n\n  eventDispatcher!: CameraEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required camera information\");\n    const messages = RequiredCameraMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // CAMERA STATUS\n  #cameraStatus!: CameraStatus;\n  get cameraStatus() {\n    return this.#cameraStatus;\n  }\n  #parseCameraStatus(dataView: DataView<ArrayBuffer>) {\n    const cameraStatusIndex = dataView.getUint8(0);\n    const newCameraStatus = CameraStatuses[cameraStatusIndex];\n    this.#updateCameraStatus(newCameraStatus);\n  }\n  #latestTakingPictureTimestamp = 0;\n  #updateCameraStatus(newCameraStatus: CameraStatus) {\n    _console.assertEnumWithError(newCameraStatus, CameraStatuses);\n    if (newCameraStatus == this.#cameraStatus) {\n      _console.log(`redundant cameraStatus ${newCameraStatus}`);\n      return;\n    }\n    const previousCameraStatus = this.#cameraStatus;\n    this.#cameraStatus = newCameraStatus;\n    _console.log(`updated cameraStatus to \"${this.cameraStatus}\"`);\n    this.#dispatchEvent(\"cameraStatus\", {\n      cameraStatus: this.cameraStatus,\n      previousCameraStatus,\n    });\n\n    if (this.cameraStatus == \"takingPicture\") {\n      this.#latestTakingPictureTimestamp = Date.now();\n    }\n\n    if (\n      this.#cameraStatus != \"takingPicture\" &&\n      this.#imageProgress > 0 &&\n      !this.#didBuildImage\n    ) {\n      this.#buildImage();\n    }\n  }\n\n  // CAMERA COMMAND\n  async #sendCameraCommand(command: CameraCommand, sendImmediately?: boolean) {\n    _console.assertEnumWithError(command, CameraCommands);\n    _console.log(`sending camera command \"${command}\"`);\n\n    const promise = this.waitForEvent(\"cameraStatus\");\n    _console.log(`setting command \"${command}\"`);\n    const commandEnum = CameraCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"cameraCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  #assertIsAsleep() {\n    _console.assertWithError(\n      this.#cameraStatus == \"asleep\",\n      `camera is not asleep - currently ${this.#cameraStatus}`\n    );\n  }\n  #assertIsAwake() {\n    _console.assertWithError(\n      this.#cameraStatus != \"asleep\",\n      `camera is not awake - currently ${this.#cameraStatus}`\n    );\n  }\n  async focus() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"focus\");\n  }\n  async takePicture() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"takePicture\");\n  }\n  async stop() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"stop\");\n  }\n  async sleep() {\n    this.#assertIsAwake();\n    await this.#sendCameraCommand(\"sleep\");\n  }\n  async wake() {\n    this.#assertIsAsleep();\n    await this.#sendCameraCommand(\"wake\");\n  }\n\n  // CAMERA DATA\n  #parseCameraData(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parsing camera data\", dataView);\n    parseMessage(\n      dataView,\n      CameraDataTypes,\n      this.#onCameraData.bind(this),\n      null,\n      true\n    );\n  }\n  #onCameraData(\n    cameraDataType: CameraDataType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ cameraDataType, dataView });\n    switch (cameraDataType) {\n      case \"headerSize\":\n        this.#headerSize = dataView.getUint16(0, true);\n        _console.log({ headerSize: this.#headerSize });\n        this.#headerData = undefined;\n        this.#headerProgress == 0;\n        break;\n      case \"header\":\n        this.#headerData = concatenateArrayBuffers(this.#headerData, dataView);\n        _console.log({ headerData: this.#headerData });\n        this.#headerProgress = this.#headerData?.byteLength / this.#headerSize;\n        _console.log({ headerProgress: this.#headerProgress });\n        this.#dispatchEvent(\"cameraImageProgress\", {\n          progress: this.#headerProgress,\n          type: \"header\",\n        });\n        if (this.#headerProgress == 1) {\n          _console.log(\"finished getting header data\");\n        }\n        break;\n      case \"imageSize\":\n        this.#imageSize = dataView.getUint32(0, true);\n        _console.log({ imageSize: this.#imageSize });\n        this.#imageData = undefined;\n        this.#imageProgress == 0;\n        this.#didBuildImage = false;\n        break;\n      case \"image\":\n        this.#imageData = concatenateArrayBuffers(this.#imageData, dataView);\n        _console.log({ imageData: this.#imageData });\n        this.#imageProgress = this.#imageData?.byteLength / this.#imageSize;\n        _console.log({ imageProgress: this.#imageProgress });\n        this.#dispatchEvent(\"cameraImageProgress\", {\n          progress: this.#imageProgress,\n          type: \"image\",\n        });\n        if (this.#imageProgress == 1) {\n          _console.log(\"finished getting image data\");\n          if (this.#headerProgress == 1 && this.#footerProgress == 1) {\n            this.#buildImage();\n          }\n        }\n        break;\n      case \"footerSize\":\n        this.#footerSize = dataView.getUint16(0, true);\n        _console.log({ footerSize: this.#footerSize });\n        this.#footerData = undefined;\n        this.#footerProgress == 0;\n        break;\n      case \"footer\":\n        this.#footerData = concatenateArrayBuffers(this.#footerData, dataView);\n        _console.log({ footerData: this.#footerData });\n        this.#footerProgress = this.#footerData?.byteLength / this.#footerSize;\n        _console.log({ footerProgress: this.#footerProgress });\n        this.#dispatchEvent(\"cameraImageProgress\", {\n          progress: this.#footerProgress,\n          type: \"footer\",\n        });\n        if (this.#footerProgress == 1) {\n          _console.log(\"finished getting footer data\");\n          if (this.#imageProgress == 1) {\n            this.#buildImage();\n          }\n        }\n        break;\n    }\n  }\n\n  #headerSize: number = 0;\n  #headerData?: ArrayBuffer;\n  #headerProgress: number = 0;\n\n  #imageSize: number = 0;\n  #imageData?: ArrayBuffer;\n  #imageProgress: number = 0;\n\n  #footerSize: number = 0;\n  #footerData?: ArrayBuffer;\n  #footerProgress: number = 0;\n\n  #didBuildImage: boolean = false;\n  async #buildImage() {\n    _console.log(\"building image...\");\n    const now = Date.now();\n    const imageData = concatenateArrayBuffers(\n      this.#headerData,\n      this.#imageData,\n      this.#footerData\n    );\n    _console.log({ imageData });\n\n    let blob = new Blob([imageData], { type: \"image/jpeg\" });\n    _console.log(\"created blob\", blob);\n\n    const url = URL.createObjectURL(blob);\n    _console.log(\"created url\", url);\n\n    const cameraImage: CameraImage = {\n      url,\n      blob,\n      timestamp: this.#latestTakingPictureTimestamp,\n      latency: now - this.#latestTakingPictureTimestamp,\n    };\n\n    this.#dispatchEvent(\"cameraImage\", cameraImage);\n\n    if (this.#isRecording) {\n      this.#cameraRecordingData!.push(cameraImage);\n      if (isInBrowser) {\n        if (\n          this.#recordingImage &&\n          this.#recordingCanvasContext &&\n          this.#recordingCanvas\n        ) {\n          const promise = new Promise<void>((resolve) => {\n            this.#recordingImage!.onload = () => resolve();\n          });\n          this.#recordingImage.src = cameraImage.url;\n          await promise;\n          const { width, height } = this.#recordingImage;\n          if (this.#recordingCanvas.width != width) {\n            this.#recordingCanvas.width = width;\n          }\n          if (this.#recordingCanvas.height != height) {\n            this.#recordingCanvas.height = height;\n          }\n          this.#recordingCanvasContext!.drawImage(\n            this.#recordingImage!,\n            0,\n            0,\n            width,\n            height\n          );\n        } else {\n          _console.error(\n            \"camera recording failed - recording image/canvas/context not found\"\n          );\n          this.stopRecording();\n        }\n      }\n    }\n\n    this.#didBuildImage = true;\n\n    if (this.autoPicture) {\n      this.takePicture();\n    }\n  }\n\n  #buildHeaderCameraData() {\n    if (this.#headerSize && this.#headerProgress == 1 && this.#headerData) {\n      const headerDataView = new DataView(new ArrayBuffer(8));\n      headerDataView.setUint8(0, CameraDataTypes.indexOf(\"headerSize\"));\n      headerDataView.setUint16(1, 2, true);\n      headerDataView.setUint16(3, this.#headerSize, true);\n      headerDataView.setUint8(5, CameraDataTypes.indexOf(\"header\"));\n      headerDataView.setUint16(6, this.#headerSize, true);\n      return concatenateArrayBuffers(headerDataView, this.#headerData);\n    }\n  }\n  #buildFooterCameraData() {\n    if (this.#footerSize && this.#footerProgress == 1 && this.#footerData) {\n      const footerDataView = new DataView(new ArrayBuffer(8));\n      footerDataView.setUint8(0, CameraDataTypes.indexOf(\"footerSize\"));\n      footerDataView.setUint16(1, 2, true);\n      footerDataView.setUint16(3, this.#footerSize, true);\n      footerDataView.setUint8(5, CameraDataTypes.indexOf(\"footer\"));\n      footerDataView.setUint16(6, this.#footerSize, true);\n      return concatenateArrayBuffers(footerDataView, this.#footerData);\n    }\n  }\n  buildCameraData() {\n    const cameraData = [\n      this.#buildHeaderCameraData(),\n      this.#buildFooterCameraData(),\n    ];\n    return concatenateArrayBuffers(cameraData);\n  }\n\n  // CONFIG\n  #cameraConfiguration: CameraConfiguration = {};\n  get cameraConfiguration() {\n    return this.#cameraConfiguration;\n  }\n  #availableCameraConfigurationTypes!: CameraConfigurationType[];\n  get availableCameraConfigurationTypes() {\n    return this.#availableCameraConfigurationTypes;\n  }\n\n  #cameraConfigurationRanges: CameraConfigurationRanges = {\n    resolution: { min: 96, max: 2560 },\n    qualityFactor: { min: 0, max: 100 },\n\n    shutter: { min: 4, max: 16383 },\n    gain: { min: 0, max: 248 },\n    redGain: { min: 0, max: 2047 },\n    greenGain: { min: 0, max: 2047 },\n    blueGain: { min: 0, max: 2047 },\n\n    autoWhiteBalanceEnabled: { min: 0, max: 1 },\n    autoGainEnabled: { min: 0, max: 1 },\n\n    exposure: { min: 0, max: 1200 },\n    autoExposureEnabled: { min: 0, max: 1 },\n    autoExposureLevel: { min: -4, max: 4 },\n\n    brightness: { min: -3, max: 3 },\n    saturation: { min: -4, max: 4 },\n    contrast: { min: -3, max: 3 },\n    sharpness: { min: -3, max: 3 },\n  };\n  get cameraConfigurationRanges() {\n    return this.#cameraConfigurationRanges;\n  }\n\n  #parseCameraConfiguration(dataView: DataView<ArrayBuffer>) {\n    const parsedCameraConfiguration: CameraConfiguration = {};\n\n    let byteOffset = 0;\n    const size = 2;\n    while (byteOffset < dataView.byteLength) {\n      const cameraConfigurationTypeIndex = dataView.getUint8(byteOffset++);\n      const cameraConfigurationType =\n        CameraConfigurationTypes[cameraConfigurationTypeIndex];\n      _console.assertWithError(\n        cameraConfigurationType,\n        `invalid cameraConfigurationTypeIndex ${cameraConfigurationTypeIndex}`\n      );\n\n      _console.log({ cameraConfigurationType });\n\n      let value: number | undefined;\n      switch (cameraConfigurationType) {\n        // FILL\n        case \"autoExposureLevel\":\n        case \"brightness\":\n        case \"saturation\":\n        case \"contrast\":\n        case \"sharpness\":\n          value = dataView.getInt16(byteOffset, true);\n          break;\n        default:\n          value = dataView.getUint16(byteOffset, true);\n          break;\n      }\n\n      _console.log({ [cameraConfigurationType]: value });\n      _console.assertTypeWithError(value, \"number\");\n      parsedCameraConfiguration[cameraConfigurationType] = value;\n      byteOffset += size;\n    }\n\n    _console.log({ parsedCameraConfiguration });\n    this.#availableCameraConfigurationTypes = Object.keys(\n      parsedCameraConfiguration\n    ) as CameraConfigurationType[];\n    this.#cameraConfiguration = parsedCameraConfiguration;\n    this.#dispatchEvent(\"getCameraConfiguration\", {\n      cameraConfiguration: this.#cameraConfiguration,\n    });\n  }\n\n  #isCameraConfigurationRedundant(cameraConfiguration: CameraConfiguration) {\n    let cameraConfigurationTypes = Object.keys(\n      cameraConfiguration\n    ) as CameraConfigurationType[];\n    return cameraConfigurationTypes.every((cameraConfigurationType) => {\n      return (\n        this.cameraConfiguration[cameraConfigurationType] ==\n        cameraConfiguration[cameraConfigurationType]\n      );\n    });\n  }\n  async setCameraConfiguration(newCameraConfiguration: CameraConfiguration) {\n    _console.log({ newCameraConfiguration });\n    if (this.#isCameraConfigurationRedundant(newCameraConfiguration)) {\n      _console.log(\"redundant camera configuration\");\n      return;\n    }\n    const setCameraConfigurationData = this.#createData(newCameraConfiguration);\n    _console.log({ setCameraConfigurationData });\n\n    const promise = this.waitForEvent(\"getCameraConfiguration\");\n    this.sendMessage([\n      {\n        type: \"setCameraConfiguration\",\n        data: setCameraConfigurationData.buffer,\n      },\n    ]);\n    await promise;\n  }\n\n  #assertAvailableCameraConfigurationType(\n    cameraConfigurationType: CameraConfigurationType\n  ) {\n    _console.assertWithError(\n      this.#availableCameraConfigurationTypes,\n      \"must get initial cameraConfiguration\"\n    );\n    const isCameraConfigurationTypeAvailable =\n      this.#availableCameraConfigurationTypes?.includes(\n        cameraConfigurationType\n      );\n    _console.assertWithError(\n      isCameraConfigurationTypeAvailable,\n      `unavailable camera configuration type \"${cameraConfigurationType}\"`\n    );\n    return isCameraConfigurationTypeAvailable;\n  }\n\n  static AssertValidCameraConfigurationType(\n    cameraConfigurationType: CameraConfigurationType\n  ) {\n    _console.assertEnumWithError(\n      cameraConfigurationType,\n      CameraConfigurationTypes\n    );\n  }\n  static AssertValidCameraConfigurationTypeEnum(\n    cameraConfigurationTypeEnum: number\n  ) {\n    _console.assertTypeWithError(cameraConfigurationTypeEnum, \"number\");\n    _console.assertWithError(\n      cameraConfigurationTypeEnum in CameraConfigurationTypes,\n      `invalid cameraConfigurationTypeEnum ${cameraConfigurationTypeEnum}`\n    );\n  }\n\n  #createData(cameraConfiguration: CameraConfiguration) {\n    let cameraConfigurationTypes = Object.keys(\n      cameraConfiguration\n    ) as CameraConfigurationType[];\n    cameraConfigurationTypes = cameraConfigurationTypes.filter(\n      (cameraConfigurationType) =>\n        this.#assertAvailableCameraConfigurationType(cameraConfigurationType)\n    );\n\n    const dataView = new DataView(\n      new ArrayBuffer(cameraConfigurationTypes.length * 3)\n    );\n    cameraConfigurationTypes.forEach((cameraConfigurationType, index) => {\n      CameraManager.AssertValidCameraConfigurationType(cameraConfigurationType);\n      const cameraConfigurationTypeEnum = CameraConfigurationTypes.indexOf(\n        cameraConfigurationType\n      );\n      dataView.setUint8(index * 3, cameraConfigurationTypeEnum);\n\n      const value = cameraConfiguration[cameraConfigurationType]!;\n      //this.#assertValidCameraConfigurationValue(cameraConfigurationType, value);\n      const offset = index * 3 + 1;\n      switch (cameraConfigurationType) {\n        // FILL\n        case \"autoExposureLevel\":\n          dataView.setInt16(offset, value, true);\n          break;\n        default:\n          dataView.setUint16(offset, value, true);\n          break;\n      }\n    });\n    _console.log({ sensorConfigurationData: dataView });\n    return dataView;\n  }\n\n  // RECORDING\n  #isRecording = false;\n  get isRecording() {\n    return this.#isRecording;\n  }\n  #cameraRecordingData?: CameraImage[];\n  get isRecordingAvailable() {\n    return Boolean((isInBrowser && window.MediaRecorder) || isInNode);\n  }\n  #recordingCanvas?: HTMLCanvasElement;\n  #recordingImage?: HTMLImageElement;\n  #recordingCanvasContext?: CanvasRenderingContext2D;\n  #recordingCanvasStream?: MediaStream;\n  #recordingMediaRecorder?: MediaRecorder;\n  #recordingChunks?: Blob[];\n  startRecording() {\n    if (!this.isRecordingAvailable) {\n      _console.error(\"camera recording is not available\");\n      return;\n    }\n    if (this.isRecording) {\n      _console.log(\"already recording camera\");\n      return;\n    }\n    this.#cameraRecordingData = [];\n    if (isInBrowser) {\n      this.#recordingCanvas = document.createElement(\"canvas\");\n      this.#recordingCanvasContext = this.#recordingCanvas.getContext(\"2d\")!;\n      this.#recordingImage = document.createElement(\"img\");\n      this.#recordingCanvasStream = this.#recordingCanvas.captureStream(30);\n      this.#recordingMediaRecorder = new MediaRecorder(\n        this.#recordingCanvasStream,\n        {\n          mimeType: \"video/webm\",\n        }\n      );\n      this.#recordingChunks = [];\n      this.#recordingMediaRecorder.ondataavailable = (e) => {\n        _console.log(\"adding chunk\", e.data);\n        this.#recordingChunks!.push(e.data);\n      };\n      this.#recordingMediaRecorder.start();\n    }\n    this.#isRecording = true;\n    this.#dispatchEvent(\"isRecordingCamera\", {\n      isRecordingCamera: this.isRecording,\n    });\n  }\n  stopRecording() {\n    if (!this.isRecording) {\n      _console.log(\"already not recording\");\n      return;\n    }\n    if (this.#cameraRecordingData && this.#cameraRecordingData.length > 0) {\n      const images = this.#cameraRecordingData;\n      if (isInBrowser) {\n        this.#recordingMediaRecorder!.onstop = () => {\n          _console.log(\"recordingMediaRecorder onstop\");\n          if (!images || images.length == 0) {\n            return;\n          }\n          const blob = new Blob(this.#recordingChunks, { type: \"video/webm\" });\n          const url = URL.createObjectURL(blob);\n          this.#dispatchEvent(\"cameraRecording\", {\n            images,\n            configuration: structuredClone(this.cameraConfiguration),\n            blob,\n            url,\n          });\n        };\n        this.#recordingMediaRecorder?.stop();\n      } else if (isInNode) {\n        // FILL\n      }\n    }\n    this.#isRecording = false;\n    this.#cameraRecordingData = undefined;\n    this.#dispatchEvent(\"isRecordingCamera\", {\n      isRecordingCamera: this.isRecording,\n    });\n  }\n  toggleRecording() {\n    if (this.#isRecording) {\n      this.stopRecording();\n    } else {\n      this.startRecording();\n    }\n  }\n\n  // AUTO\n  #autoPicture = false;\n  get autoPicture() {\n    return this.#autoPicture;\n  }\n  set autoPicture(newAutoPicture) {\n    if (this.#autoPicture == newAutoPicture) {\n      return;\n    }\n    this.#autoPicture = newAutoPicture;\n    _console.log({ autoPicture: this.#autoPicture });\n    this.#dispatchEvent(\"autoPicture\", { autoPicture: this.autoPicture });\n  }\n\n  // MESSAGE\n  parseMessage(\n    messageType: CameraMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType, dataView });\n\n    switch (messageType) {\n      case \"cameraStatus\":\n        this.#parseCameraStatus(dataView);\n        break;\n      case \"getCameraConfiguration\":\n      case \"setCameraConfiguration\":\n        this.#parseCameraConfiguration(dataView);\n        break;\n      case \"cameraData\":\n        this.#parseCameraData(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    // @ts-ignore\n    this.#cameraStatus = undefined;\n    this.#cameraConfiguration = {};\n    this.#headerProgress = 0;\n    this.#imageProgress = 0;\n    this.#footerProgress = 0;\n    this.autoPicture = false;\n    if (this.isRecording) {\n      this.stopRecording();\n    }\n  }\n}\n\nexport default CameraManager;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"AudioUtils\", { log: false });\n\nexport function float32ArrayToWav(\n  audioData: Float32Array,\n  sampleRate: number,\n  numChannels: number\n): Blob {\n  const wavBuffer = encodeWAV(audioData, sampleRate, numChannels);\n  return new Blob([wavBuffer], { type: \"audio/wav\" });\n}\n\nfunction encodeWAV(\n  interleaved: Float32Array,\n  sampleRate: number,\n  numChannels: number\n): ArrayBuffer {\n  const buffer = new ArrayBuffer(44 + interleaved.length * 2); // 44 bytes for WAV header\n  const view = new DataView(buffer);\n\n  // RIFF identifier\n  writeString(view, 0, \"RIFF\");\n  // File length minus RIFF identifier length and file description length\n  view.setUint32(4, 36 + interleaved.length * 2, true);\n  // RIFF type\n  writeString(view, 8, \"WAVE\");\n  // Format chunk identifier\n  writeString(view, 12, \"fmt \");\n  // Format chunk length\n  view.setUint32(16, 16, true);\n  // Sample format (raw)\n  view.setUint16(20, 1, true);\n  // Channel count\n  view.setUint16(22, numChannels, true);\n  // Sample rate\n  view.setUint32(24, sampleRate, true);\n  // Byte rate (sample rate * block align)\n  view.setUint32(28, sampleRate * numChannels * 2, true);\n  // Block align (channel count * bytes per sample)\n  view.setUint16(32, numChannels * 2, true);\n  // Bits per sample\n  view.setUint16(34, 16, true);\n  // Data chunk identifier\n  writeString(view, 36, \"data\");\n  // Data chunk length\n  view.setUint32(40, interleaved.length * 2, true);\n\n  // Write interleaved audio data\n  for (let i = 0; i < interleaved.length; i++) {\n    view.setInt16(44 + i * 2, interleaved[i] * 0x7fff, true); // Convert float [-1, 1] to int16\n  }\n\n  return buffer;\n}\n\nexport function writeString(\n  view: DataView,\n  offset: number,\n  string: string\n): void {\n  for (let i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}\n","/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A-Law codec.\r\n */\r\n\r\n/** @module alawmulaw/alaw */\r\n\r\n/** @type {!Array<number>} */\r\nconst LOG_TABLE = [\r\n  1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5, \r\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6, \r\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, \r\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 \r\n];\r\n\r\n/**\r\n * Encode a 16-bit linear PCM sample as 8-bit A-Law.\r\n * @param {number} sample A 16-bit PCM sample\r\n * @return {number}\r\n */\r\nexport function encodeSample(sample) {\r\n  /** @type {number} */\r\n  let compandedValue; \r\n  sample = (sample ==-32768) ? -32767 : sample;\r\n  /** @type {number} */\r\n  let sign = ((~sample) >> 8) & 0x80; \r\n  if (!sign) {\r\n    sample = sample * -1; \r\n  }\r\n  if (sample > 32635) {\r\n    sample = 32635; \r\n  }\r\n  if (sample >= 256)  {\r\n    /** @type {number} */\r\n    let exponent = LOG_TABLE[(sample >> 8) & 0x7F];\r\n    /** @type {number} */\r\n    let mantissa = (sample >> (exponent + 3) ) & 0x0F; \r\n    compandedValue = ((exponent << 4) | mantissa); \r\n  } else {\r\n    compandedValue = sample >> 4; \r\n  } \r\n  return compandedValue ^ (sign ^ 0x55);\r\n}\r\n\r\n/**\r\n * Decode a 8-bit A-Law sample as 16-bit PCM.\r\n * @param {number} aLawSample The 8-bit A-Law sample\r\n * @return {number}\r\n */\r\nexport function decodeSample(aLawSample) {\r\n  /** @type {number} */\r\n  let sign = 0;\r\n  aLawSample ^= 0x55;\r\n  if (aLawSample & 0x80) {\r\n    aLawSample &= ~(1 << 7);\r\n    sign = -1;\r\n  }\r\n  /** @type {number} */\r\n  let position = ((aLawSample & 0xF0) >> 4) + 4;\r\n  /** @type {number} */\r\n  let decoded = 0;\r\n  if (position != 4) {\r\n    decoded = ((1 << position) |\r\n      ((aLawSample & 0x0F) << (position - 4)) |\r\n      (1 << (position - 5)));\r\n  } else {\r\n    decoded = (aLawSample << 1)|1;\r\n  }\r\n  decoded = (sign === 0) ? (decoded) : (-decoded);\r\n  return (decoded * 8) * -1;\r\n}\r\n\r\n/**\r\n * Encode 16-bit linear PCM samples as 8-bit A-Law samples.\r\n * @param {!Int16Array} samples A array of 16-bit PCM samples.\r\n * @return {!Uint8Array}\r\n */\r\nexport function encode(samples) {\r\n  /** @type {!Uint8Array} */\r\n  let aLawSamples = new Uint8Array(samples.length);\r\n  for (let i=0; i<samples.length; i++) {\r\n    aLawSamples[i] = encodeSample(samples[i]);\r\n  }\r\n  return aLawSamples;\r\n}\r\n\r\n/**\r\n * Decode 8-bit A-Law samples into 16-bit linear PCM samples.\r\n * @param {!Uint8Array} samples A array of 8-bit A-Law samples.\r\n * @return {!Int16Array}\r\n */\r\nexport function decode(samples) {\r\n  /** @type {!Int16Array} */\r\n  let pcmSamples = new Int16Array(samples.length);\r\n  for (let i=0; i<samples.length; i++) {\r\n    pcmSamples[i] = decodeSample(samples[i]);\r\n  }\r\n  return pcmSamples;\r\n}\r\n","/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview mu-Law codec.\r\n */\r\n\r\n/** @module alawmulaw/mulaw */\r\n\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nconst BIAS = 0x84;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nconst CLIP = 32635;\r\n/**\r\n * @type {Array<number>}\r\n * @private\r\n */\r\nconst encodeTable = [\r\n    0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\r\n    4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\r\n    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\r\n    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\r\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\r\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\r\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\r\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7];\r\n/**\r\n * @type {Array<number>}\r\n * @private\r\n */\r\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\r\n\r\n/**\r\n * Encode a 16-bit linear PCM sample as 8-bit mu-Law.\r\n * @param {number} sample A 16-bit PCM sample\r\n * @return {number}\r\n */\r\nexport function encodeSample(sample) {\r\n  /** @type {number} */\r\n  let sign;\r\n  /** @type {number} */\r\n  let exponent;\r\n  /** @type {number} */\r\n  let mantissa;\r\n  /** @type {number} */\r\n  let muLawSample;\r\n  /** get the sample into sign-magnitude **/\r\n  sign = (sample >> 8) & 0x80;\r\n  if (sign != 0) sample = -sample;\r\n  /** convert from 16 bit linear to ulaw **/\r\n  sample = sample + BIAS;\r\n  if (sample > CLIP) sample = CLIP;\r\n  exponent = encodeTable[(sample>>7) & 0xFF];\r\n  mantissa = (sample >> (exponent+3)) & 0x0F;\r\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\r\n  /** return the result **/\r\n  return muLawSample;\r\n}\r\n\r\n/**\r\n * Decode a 8-bit mu-Law sample as 16-bit PCM.\r\n * @param {number} muLawSample The 8-bit mu-Law sample\r\n * @return {number}\r\n */\r\nexport function decodeSample(muLawSample) {\r\n  /** @type {number} */\r\n  let sign;\r\n  /** @type {number} */\r\n  let exponent;\r\n  /** @type {number} */\r\n  let mantissa;\r\n  /** @type {number} */\r\n  let sample;\r\n  muLawSample = ~muLawSample;\r\n  sign = (muLawSample & 0x80);\r\n  exponent = (muLawSample >> 4) & 0x07;\r\n  mantissa = muLawSample & 0x0F;\r\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\r\n  if (sign != 0) sample = -sample;\r\n  return sample;\r\n}\r\n\r\n/**\r\n * Encode 16-bit linear PCM samples into 8-bit mu-Law samples.\r\n * @param {!Int16Array} samples A array of 16-bit PCM samples.\r\n * @return {!Uint8Array}\r\n */\r\nexport function encode(samples) {\r\n  /** @type {!Uint8Array} */\r\n  let muLawSamples = new Uint8Array(samples.length);\r\n  for (let i=0; i<samples.length; i++) {\r\n    muLawSamples[i] = encodeSample(samples[i]);\r\n  }\r\n  return muLawSamples;\r\n}\r\n\r\n/**\r\n * Decode 8-bit mu-Law samples into 16-bit PCM samples.\r\n * @param {!Uint8Array} samples A array of 8-bit mu-Law samples.\r\n * @return {!Int16Array}\r\n */\r\nexport function decode(samples) {\r\n  /** @type {!Int16Array} */\r\n  let pcmSamples = new Int16Array(samples.length);\r\n  for (let i=0; i<samples.length; i++) {\r\n    pcmSamples[i] = decodeSample(samples[i]);\r\n  }\r\n  return pcmSamples;\r\n}\r\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./utils/ArrayBufferUtils.ts\";\nimport { float32ArrayToWav } from \"./utils/AudioUtils.ts\";\n\nimport * as _alawmulaw from \"alawmulaw\";\nconst alawmulaw = (_alawmulaw as any).default ?? _alawmulaw;\nconst { mulaw } = alawmulaw;\n\nconst _console = createConsole(\"MicrophoneManager\", { log: false });\n\nexport const MicrophoneSensorTypes = [\"microphone\"] as const;\nexport type MicrophoneSensorType = (typeof MicrophoneSensorTypes)[number];\n\nexport const MicrophoneCommands = [\"start\", \"stop\", \"vad\"] as const;\nexport type MicrophoneCommand = (typeof MicrophoneCommands)[number];\n\nexport const MicrophoneStatuses = [\"idle\", \"streaming\", \"vad\"] as const;\nexport type MicrophoneStatus = (typeof MicrophoneStatuses)[number];\n\nexport const MicrophoneConfigurationTypes = [\"sampleRate\", \"bitDepth\"] as const;\nexport type MicrophoneConfigurationType =\n  (typeof MicrophoneConfigurationTypes)[number];\n\nexport const MicrophoneSampleRates = [\"8000\", \"16000\"] as const;\nexport type MicrophoneSampleRate = (typeof MicrophoneSampleRates)[number];\n\nexport const MicrophoneBitDepths = [\"8\", \"16\"] as const;\nexport type MicrophoneBitDepth = (typeof MicrophoneBitDepths)[number];\n\nexport const MicrophoneMessageTypes = [\n  \"microphoneStatus\",\n  \"microphoneCommand\",\n  \"getMicrophoneConfiguration\",\n  \"setMicrophoneConfiguration\",\n  \"microphoneData\",\n] as const;\nexport type MicrophoneMessageType = (typeof MicrophoneMessageTypes)[number];\n\nexport type MicrophoneConfiguration = {\n  sampleRate?: MicrophoneSampleRate;\n  bitDepth?: MicrophoneBitDepth;\n};\n\nexport const MicrophoneConfigurationValues = {\n  sampleRate: MicrophoneSampleRates,\n  bitDepth: MicrophoneBitDepths,\n};\n\nexport const RequiredMicrophoneMessageTypes: MicrophoneMessageType[] = [\n  \"getMicrophoneConfiguration\",\n  \"microphoneStatus\",\n] as const;\n\nexport const MicrophoneEventTypes = [\n  ...MicrophoneMessageTypes,\n  \"isRecordingMicrophone\",\n  \"microphoneRecording\",\n] as const;\nexport type MicrophoneEventType = (typeof MicrophoneEventTypes)[number];\n\nexport interface MicrophoneEventMessages {\n  microphoneStatus: {\n    microphoneStatus: MicrophoneStatus;\n    previousMicrophoneStatus: MicrophoneStatus;\n  };\n  getMicrophoneConfiguration: {\n    microphoneConfiguration: MicrophoneConfiguration;\n  };\n  microphoneData: {\n    samples: Float32Array;\n    sampleRate: MicrophoneSampleRate;\n    bitDepth: MicrophoneBitDepth;\n  };\n  isRecordingMicrophone: {\n    isRecordingMicrophone: boolean;\n  };\n  microphoneRecording: {\n    samples: Float32Array;\n    configuration: MicrophoneConfiguration;\n    blob: Blob;\n    url: string;\n  };\n}\n\nexport type MicrophoneEventDispatcher = EventDispatcher<\n  Device,\n  MicrophoneEventType,\n  MicrophoneEventMessages\n>;\nexport type SendMicrophoneMessageCallback =\n  SendMessageCallback<MicrophoneMessageType>;\n\nclass MicrophoneManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendMicrophoneMessageCallback;\n\n  eventDispatcher!: MicrophoneEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required microphone information\");\n    const messages = RequiredMicrophoneMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // MICROPHONE STATUS\n  #microphoneStatus!: MicrophoneStatus;\n  get microphoneStatus() {\n    return this.#microphoneStatus;\n  }\n  #parseMicrophoneStatus(dataView: DataView<ArrayBuffer>) {\n    const microphoneStatusIndex = dataView.getUint8(0);\n    const newMicrophoneStatus = MicrophoneStatuses[microphoneStatusIndex];\n    this.#updateMicrophoneStatus(newMicrophoneStatus);\n  }\n  #updateMicrophoneStatus(newMicrophoneStatus: MicrophoneStatus) {\n    _console.assertEnumWithError(newMicrophoneStatus, MicrophoneStatuses);\n    if (newMicrophoneStatus == this.#microphoneStatus) {\n      _console.log(`redundant microphoneStatus ${newMicrophoneStatus}`);\n      return;\n    }\n    const previousMicrophoneStatus = this.#microphoneStatus;\n    this.#microphoneStatus = newMicrophoneStatus;\n    _console.log(`updated microphoneStatus to \"${this.microphoneStatus}\"`);\n    this.#dispatchEvent(\"microphoneStatus\", {\n      microphoneStatus: this.microphoneStatus,\n      previousMicrophoneStatus,\n    });\n  }\n\n  // MICROPHONE COMMAND\n  async #sendMicrophoneCommand(\n    command: MicrophoneCommand,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(command, MicrophoneCommands);\n    _console.log(`sending microphone command \"${command}\"`);\n\n    const promise = this.waitForEvent(\"microphoneStatus\");\n    _console.log(`setting command \"${command}\"`);\n    const commandEnum = MicrophoneCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"microphoneCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  #assertIsIdle() {\n    _console.assertWithError(\n      this.#microphoneStatus == \"idle\",\n      `microphone is not idle - currently ${this.#microphoneStatus}`\n    );\n  }\n  #assertIsNotIdle() {\n    _console.assertWithError(\n      this.#microphoneStatus != \"idle\",\n      `microphone is idle`\n    );\n  }\n  #assertIsStreaming() {\n    _console.assertWithError(\n      this.#microphoneStatus == \"streaming\",\n      `microphone is not recording - currently ${this.#microphoneStatus}`\n    );\n  }\n\n  async start() {\n    await this.#sendMicrophoneCommand(\"start\");\n  }\n  async stop() {\n    if (this.microphoneStatus == \"idle\") {\n      _console.log(\"microphone is already idle\");\n      return;\n    }\n    await this.#sendMicrophoneCommand(\"stop\");\n  }\n  async vad() {\n    await this.#sendMicrophoneCommand(\"vad\");\n  }\n  async toggle() {\n    switch (this.microphoneStatus) {\n      case \"idle\":\n        this.start();\n        break;\n      case \"streaming\":\n        this.stop();\n        break;\n    }\n  }\n\n  // MICROPHONE DATA\n  #assertValidBitDepth() {\n    _console.assertEnumWithError(this.bitDepth!, MicrophoneBitDepths);\n  }\n  #fadeDuration = 0.01;\n  #playbackTime = 0;\n  #parseMicrophoneData(dataView: DataView<ArrayBuffer>) {\n    this.#assertValidBitDepth();\n\n    _console.log(\"parsing microphone data\", dataView);\n\n    const numberOfSamples = dataView.byteLength / this.#bytesPerSample!;\n    const samples = new Float32Array(numberOfSamples);\n\n    for (let i = 0; i < numberOfSamples; i++) {\n      let sample;\n      switch (this.bitDepth) {\n        case \"16\":\n          sample = dataView.getInt16(i * 2, true);\n          samples[i] = sample / 2 ** 15; // Normalize to [-1, 1]\n          break;\n        case \"8\":\n          if (true) {\n            // mu-law compression\n            sample = dataView.getUint8(i);\n            sample = mulaw.decodeSample(sample);\n            sample = sample / 2 ** 15; // Normalize to [-1, 1]\n          } else {\n            sample = dataView.getInt8(i);\n            sample = sample / 2 ** 7; // Normalize to [-1, 1]\n          }\n          samples[i] = sample;\n          break;\n      }\n    }\n\n    _console.log(\"samples\", samples);\n\n    if (this.#isRecording && this.#microphoneRecordingData) {\n      this.#microphoneRecordingData!.push(samples);\n    }\n\n    if (this.#audioContext) {\n      if (this.#gainNode) {\n        const audioBuffer = this.#audioContext.createBuffer(\n          1,\n          samples.length,\n          Number(this.sampleRate!)\n        );\n        audioBuffer.getChannelData(0).set(samples);\n\n        const bufferSource = this.#audioContext.createBufferSource();\n        bufferSource.buffer = audioBuffer;\n\n        const channelData = audioBuffer.getChannelData(0);\n        const sampleRate = Number(this.sampleRate!);\n\n        for (let i = 0; i < this.#fadeDuration * sampleRate; i++) {\n          channelData[i] *= i / (this.#fadeDuration * sampleRate);\n        }\n\n        for (\n          let i = channelData.length - 1;\n          i >= channelData.length - this.#fadeDuration * sampleRate;\n          i--\n        ) {\n          channelData[i] *=\n            (channelData.length - i) / (this.#fadeDuration * sampleRate);\n        }\n\n        bufferSource.connect(this.#gainNode!);\n\n        if (this.#playbackTime < this.#audioContext.currentTime) {\n          this.#playbackTime = this.#audioContext.currentTime;\n        }\n        bufferSource.start(this.#playbackTime);\n        this.#playbackTime += audioBuffer.duration;\n      }\n    }\n\n    this.#dispatchEvent(\"microphoneData\", {\n      samples,\n      sampleRate: this.sampleRate!,\n      bitDepth: this.bitDepth!,\n    });\n  }\n  get #bytesPerSample() {\n    switch (this.bitDepth) {\n      case \"8\":\n        return 1;\n      case \"16\":\n        return 2;\n    }\n  }\n\n  // CONFIG\n  #microphoneConfiguration: MicrophoneConfiguration = {};\n  get microphoneConfiguration() {\n    return this.#microphoneConfiguration;\n  }\n  #availableMicrophoneConfigurationTypes!: MicrophoneConfigurationType[];\n  get availableMicrophoneConfigurationTypes() {\n    return this.#availableMicrophoneConfigurationTypes;\n  }\n\n  get bitDepth() {\n    return this.#microphoneConfiguration.bitDepth;\n  }\n  get sampleRate() {\n    return this.#microphoneConfiguration.sampleRate;\n  }\n\n  #parseMicrophoneConfiguration(dataView: DataView<ArrayBuffer>) {\n    const parsedMicrophoneConfiguration: MicrophoneConfiguration = {};\n\n    let byteOffset = 0;\n    while (byteOffset < dataView.byteLength) {\n      const microphoneConfigurationTypeIndex = dataView.getUint8(byteOffset++);\n      const microphoneConfigurationType =\n        MicrophoneConfigurationTypes[microphoneConfigurationTypeIndex];\n      _console.assertWithError(\n        microphoneConfigurationType,\n        `invalid microphoneConfigurationTypeIndex ${microphoneConfigurationTypeIndex}`\n      );\n      let rawValue = dataView.getUint8(byteOffset++);\n      const values = MicrophoneConfigurationValues[microphoneConfigurationType];\n      const value = values[rawValue];\n      _console.assertEnumWithError(value, values);\n      _console.log({ microphoneConfigurationType, value });\n      // @ts-expect-error\n      parsedMicrophoneConfiguration[microphoneConfigurationType] = value;\n    }\n\n    _console.log({ parsedMicrophoneConfiguration });\n    this.#availableMicrophoneConfigurationTypes = Object.keys(\n      parsedMicrophoneConfiguration\n    ) as MicrophoneConfigurationType[];\n    this.#microphoneConfiguration = parsedMicrophoneConfiguration;\n    this.#dispatchEvent(\"getMicrophoneConfiguration\", {\n      microphoneConfiguration: this.#microphoneConfiguration,\n    });\n  }\n\n  #isMicrophoneConfigurationRedundant(\n    microphoneConfiguration: MicrophoneConfiguration\n  ) {\n    let microphoneConfigurationTypes = Object.keys(\n      microphoneConfiguration\n    ) as MicrophoneConfigurationType[];\n    return microphoneConfigurationTypes.every((microphoneConfigurationType) => {\n      return (\n        this.microphoneConfiguration[microphoneConfigurationType] ==\n        microphoneConfiguration[microphoneConfigurationType]\n      );\n    });\n  }\n  async setMicrophoneConfiguration(\n    newMicrophoneConfiguration: MicrophoneConfiguration\n  ) {\n    _console.log({ newMicrophoneConfiguration });\n    if (this.#isMicrophoneConfigurationRedundant(newMicrophoneConfiguration)) {\n      _console.log(\"redundant microphone configuration\");\n      return;\n    }\n    const setMicrophoneConfigurationData = this.#createData(\n      newMicrophoneConfiguration\n    );\n    _console.log({ setMicrophoneConfigurationData });\n\n    const promise = this.waitForEvent(\"getMicrophoneConfiguration\");\n    this.sendMessage([\n      {\n        type: \"setMicrophoneConfiguration\",\n        data: setMicrophoneConfigurationData.buffer,\n      },\n    ]);\n    await promise;\n  }\n\n  #assertAvailableMicrophoneConfigurationType(\n    microphoneConfigurationType: MicrophoneConfigurationType\n  ) {\n    _console.assertWithError(\n      this.#availableMicrophoneConfigurationTypes,\n      \"must get initial microphoneConfiguration\"\n    );\n    const isMicrophoneConfigurationTypeAvailable =\n      this.#availableMicrophoneConfigurationTypes?.includes(\n        microphoneConfigurationType\n      );\n    _console.assertWithError(\n      isMicrophoneConfigurationTypeAvailable,\n      `unavailable microphone configuration type \"${microphoneConfigurationType}\"`\n    );\n    return isMicrophoneConfigurationTypeAvailable;\n  }\n\n  static AssertValidMicrophoneConfigurationType(\n    microphoneConfigurationType: MicrophoneConfigurationType\n  ) {\n    _console.assertEnumWithError(\n      microphoneConfigurationType,\n      MicrophoneConfigurationTypes\n    );\n  }\n  static AssertValidMicrophoneConfigurationTypeEnum(\n    microphoneConfigurationTypeEnum: number\n  ) {\n    _console.assertTypeWithError(microphoneConfigurationTypeEnum, \"number\");\n    _console.assertWithError(\n      microphoneConfigurationTypeEnum in MicrophoneConfigurationTypes,\n      `invalid microphoneConfigurationTypeEnum ${microphoneConfigurationTypeEnum}`\n    );\n  }\n\n  #createData(microphoneConfiguration: MicrophoneConfiguration) {\n    let microphoneConfigurationTypes = Object.keys(\n      microphoneConfiguration\n    ) as MicrophoneConfigurationType[];\n    microphoneConfigurationTypes = microphoneConfigurationTypes.filter(\n      (microphoneConfigurationType) =>\n        this.#assertAvailableMicrophoneConfigurationType(\n          microphoneConfigurationType\n        )\n    );\n\n    const dataView = new DataView(\n      new ArrayBuffer(microphoneConfigurationTypes.length * 2)\n    );\n    microphoneConfigurationTypes.forEach(\n      (microphoneConfigurationType, index) => {\n        MicrophoneManager.AssertValidMicrophoneConfigurationType(\n          microphoneConfigurationType\n        );\n        const microphoneConfigurationTypeEnum =\n          MicrophoneConfigurationTypes.indexOf(microphoneConfigurationType);\n        dataView.setUint8(index * 2, microphoneConfigurationTypeEnum);\n\n        let value = microphoneConfiguration[microphoneConfigurationType]!;\n        if (typeof value == \"number\") {\n          // @ts-ignore\n          value = value.toString();\n        }\n        const values =\n          MicrophoneConfigurationValues[microphoneConfigurationType];\n        _console.assertEnumWithError(value, values);\n        // @ts-expect-error\n        const rawValue = values.indexOf(value);\n        dataView.setUint8(index * 2 + 1, rawValue);\n      }\n    );\n    _console.log({ sensorConfigurationData: dataView });\n    return dataView;\n  }\n\n  // MESSAGE\n  parseMessage(\n    messageType: MicrophoneMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType, dataView });\n\n    switch (messageType) {\n      case \"microphoneStatus\":\n        this.#parseMicrophoneStatus(dataView);\n        break;\n      case \"getMicrophoneConfiguration\":\n      case \"setMicrophoneConfiguration\":\n        this.#parseMicrophoneConfiguration(dataView);\n        break;\n      case \"microphoneData\":\n        this.#parseMicrophoneData(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  #audioContext?: AudioContext;\n  get audioContext() {\n    return this.#audioContext;\n  }\n  set audioContext(newAudioContext) {\n    if (this.#audioContext == newAudioContext) {\n      _console.log(\"redundant audioContext assignment\", this.#audioContext);\n      return;\n    }\n\n    this.#audioContext = newAudioContext;\n\n    _console.log(\"assigned new audioContext\", this.#audioContext);\n    if (this.#audioContext) {\n      this.#playbackTime = this.#audioContext.currentTime;\n    } else {\n      if (this.#mediaStreamDestination) {\n        this.#mediaStreamDestination.disconnect();\n        this.#mediaStreamDestination = undefined;\n      }\n      if (this.#gainNode) {\n        this.#gainNode.disconnect();\n        this.#gainNode = undefined;\n      }\n    }\n  }\n\n  #gainNode?: GainNode;\n  get gainNode() {\n    _console.assertWithError(\n      this.#audioContext,\n      \"audioContext assignment required for gainNode\"\n    );\n    if (!this.#gainNode) {\n      _console.log(\"creating gainNode...\");\n      this.#gainNode = this.#audioContext!.createGain();\n      _console.log(\"created gainNode\", this.#gainNode);\n    }\n    return this.#gainNode;\n  }\n\n  #mediaStreamDestination?: MediaStreamAudioDestinationNode;\n  get mediaStreamDestination() {\n    _console.assertWithError(\n      this.#audioContext,\n      \"audioContext assignment required for mediaStreamDestination\"\n    );\n    if (!this.#mediaStreamDestination) {\n      _console.log(\"creating mediaStreamDestination...\");\n      this.#mediaStreamDestination =\n        this.#audioContext!.createMediaStreamDestination();\n      this.gainNode?.connect(this.#mediaStreamDestination);\n      _console.log(\n        \"created mediaStreamDestination\",\n        this.#mediaStreamDestination\n      );\n    }\n    return this.#mediaStreamDestination;\n  }\n\n  #isRecording = false;\n  get isRecording() {\n    return this.#isRecording;\n  }\n  #microphoneRecordingData?: Float32Array[];\n  startRecording() {\n    if (this.isRecording) {\n      _console.log(\"already recording microphone\");\n      return;\n    }\n    this.#microphoneRecordingData = [];\n    this.#isRecording = true;\n    this.#dispatchEvent(\"isRecordingMicrophone\", {\n      isRecordingMicrophone: this.isRecording,\n    });\n  }\n  stopRecording() {\n    if (!this.isRecording) {\n      _console.log(\"already not recording\");\n      return;\n    }\n    this.#isRecording = false;\n    if (\n      this.#microphoneRecordingData &&\n      this.#microphoneRecordingData.length > 0\n    ) {\n      _console.log(\n        \"parsing microphone data...\",\n        this.#microphoneRecordingData.length\n      );\n      const arrayBuffer = concatenateArrayBuffers(\n        ...this.#microphoneRecordingData\n      );\n      const samples = new Float32Array(arrayBuffer);\n\n      const blob = float32ArrayToWav(samples, Number(this.sampleRate)!, 1);\n      const url = URL.createObjectURL(blob);\n      this.#dispatchEvent(\"microphoneRecording\", {\n        samples,\n        configuration: structuredClone(this.microphoneConfiguration),\n        blob,\n        url,\n      });\n    }\n    this.#microphoneRecordingData = undefined;\n    this.#dispatchEvent(\"isRecordingMicrophone\", {\n      isRecordingMicrophone: this.isRecording,\n    });\n  }\n  toggleRecording() {\n    if (this.#isRecording) {\n      this.stopRecording();\n    } else {\n      this.startRecording();\n    }\n  }\n\n  clear() {\n    // @ts-ignore\n    this.#microphoneStatus = undefined;\n    this.#microphoneConfiguration = {};\n    if (this.isRecording) {\n      this.stopRecording();\n    }\n  }\n}\n\nexport default MicrophoneManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport { parseTimestamp } from \"../utils/MathUtils.ts\";\nimport PressureSensorDataManager, {\n  PressureDataEventMessages,\n} from \"./PressureSensorDataManager.ts\";\nimport MotionSensorDataManager, {\n  MotionSensorDataEventMessages,\n} from \"./MotionSensorDataManager.ts\";\nimport BarometerSensorDataManager, {\n  BarometerSensorDataEventMessages,\n} from \"./BarometerSensorDataManager.ts\";\nimport { parseMessage } from \"../utils/ParseUtils.ts\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\nimport {\n  MotionSensorTypes,\n  ContinuousMotionTypes,\n} from \"./MotionSensorDataManager.ts\";\nimport {\n  PressureSensorTypes,\n  ContinuousPressureSensorTypes,\n} from \"./PressureSensorDataManager.ts\";\nimport {\n  BarometerSensorTypes,\n  ContinuousBarometerSensorTypes,\n} from \"./BarometerSensorDataManager.ts\";\nimport Device from \"../Device.ts\";\nimport {\n  AddKeysAsPropertyToInterface,\n  ExtendInterfaceValues,\n  ValueOf,\n} from \"../utils/TypeScriptUtils.ts\";\nimport { CameraSensorTypes } from \"../CameraManager.ts\";\nimport { MicrophoneSensorTypes } from \"../MicrophoneManager.ts\";\n\nconst _console = createConsole(\"SensorDataManager\", { log: false });\n\nexport const SensorTypes = [\n  ...PressureSensorTypes,\n  ...MotionSensorTypes,\n  ...BarometerSensorTypes,\n  ...CameraSensorTypes,\n  ...MicrophoneSensorTypes,\n] as const;\nexport type SensorType = (typeof SensorTypes)[number];\n\nexport const ContinuousSensorTypes = [\n  ...ContinuousPressureSensorTypes,\n  ...ContinuousMotionTypes,\n  ...ContinuousBarometerSensorTypes,\n] as const;\nexport type ContinuousSensorType = (typeof ContinuousSensorTypes)[number];\n\nexport const SensorDataMessageTypes = [\n  \"getPressurePositions\",\n  \"getSensorScalars\",\n  \"sensorData\",\n] as const;\nexport type SensorDataMessageType = (typeof SensorDataMessageTypes)[number];\n\nexport const RequiredPressureMessageTypes: SensorDataMessageType[] = [\n  \"getPressurePositions\",\n] as const;\n\nexport const SensorDataEventTypes = [\n  ...SensorDataMessageTypes,\n  ...SensorTypes,\n] as const;\nexport type SensorDataEventType = (typeof SensorDataEventTypes)[number];\n\ninterface BaseSensorDataEventMessage {\n  timestamp: number;\n  isLast: boolean;\n}\n\ntype BaseSensorDataEventMessages = BarometerSensorDataEventMessages &\n  MotionSensorDataEventMessages &\n  PressureDataEventMessages;\ntype _SensorDataEventMessages = ExtendInterfaceValues<\n  AddKeysAsPropertyToInterface<BaseSensorDataEventMessages, \"sensorType\">,\n  BaseSensorDataEventMessage\n>;\nexport type SensorDataEventMessage = ValueOf<_SensorDataEventMessages>;\ninterface AnySensorDataEventMessages {\n  sensorData: SensorDataEventMessage;\n  isLast: boolean;\n}\nexport type SensorDataEventMessages = _SensorDataEventMessages &\n  AnySensorDataEventMessages;\n\nexport type SensorDataEventDispatcher = EventDispatcher<\n  Device,\n  SensorDataEventType,\n  SensorDataEventMessages\n>;\n\nclass SensorDataManager {\n  pressureSensorDataManager = new PressureSensorDataManager();\n  motionSensorDataManager = new MotionSensorDataManager();\n  barometerSensorDataManager = new BarometerSensorDataManager();\n\n  #scalars: Map<SensorType, number> = new Map();\n\n  static AssertValidSensorType(sensorType: SensorType) {\n    _console.assertEnumWithError(sensorType, SensorTypes);\n  }\n  static AssertValidSensorTypeEnum(sensorTypeEnum: number) {\n    _console.assertTypeWithError(sensorTypeEnum, \"number\");\n    _console.assertWithError(\n      sensorTypeEnum in SensorTypes,\n      `invalid sensorTypeEnum ${sensorTypeEnum}`\n    );\n  }\n\n  eventDispatcher!: SensorDataEventDispatcher;\n  get dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  parseMessage(\n    messageType: SensorDataMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getSensorScalars\":\n        this.parseScalars(dataView);\n        break;\n      case \"getPressurePositions\":\n        this.pressureSensorDataManager.parsePositions(dataView);\n        break;\n      case \"sensorData\":\n        this.parseData(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  parseScalars(dataView: DataView<ArrayBuffer>) {\n    for (\n      let byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      byteOffset += 5\n    ) {\n      const sensorTypeIndex = dataView.getUint8(byteOffset);\n      const sensorType = SensorTypes[sensorTypeIndex];\n      if (!sensorType) {\n        _console.warn(`unknown sensorType index ${sensorTypeIndex}`);\n        continue;\n      }\n      const sensorScalar = dataView.getFloat32(byteOffset + 1, true);\n      _console.log({ sensorType, sensorScalar });\n      this.#scalars.set(sensorType, sensorScalar);\n    }\n  }\n\n  private parseData(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"sensorData\", Array.from(new Uint8Array(dataView.buffer)));\n\n    let byteOffset = 0;\n    const timestamp = parseTimestamp(dataView, byteOffset);\n    byteOffset += 2;\n\n    const _dataView = new DataView(dataView.buffer, byteOffset);\n\n    parseMessage(_dataView, SensorTypes, this.parseDataCallback.bind(this), {\n      timestamp,\n    });\n  }\n\n  private parseDataCallback(\n    sensorType: SensorType,\n    dataView: DataView<ArrayBuffer>,\n    { timestamp }: { timestamp: number },\n    isLast?: boolean\n  ) {\n    const scalar = this.#scalars.get(sensorType) || 1;\n\n    let sensorData = null;\n    switch (sensorType) {\n      case \"pressure\":\n        sensorData = this.pressureSensorDataManager.parseData(dataView, scalar);\n        break;\n      case \"acceleration\":\n      case \"gravity\":\n      case \"linearAcceleration\":\n      case \"gyroscope\":\n      case \"magnetometer\":\n        sensorData = this.motionSensorDataManager.parseVector3(\n          dataView,\n          scalar\n        );\n        break;\n      case \"gameRotation\":\n      case \"rotation\":\n        sensorData = this.motionSensorDataManager.parseQuaternion(\n          dataView,\n          scalar\n        );\n        break;\n      case \"orientation\":\n        sensorData = this.motionSensorDataManager.parseEuler(dataView, scalar);\n        break;\n      case \"stepCounter\":\n        sensorData = this.motionSensorDataManager.parseStepCounter(dataView);\n        break;\n      case \"stepDetector\":\n        sensorData = {};\n        break;\n      case \"activity\":\n        sensorData = this.motionSensorDataManager.parseActivity(dataView);\n        break;\n      case \"deviceOrientation\":\n        sensorData =\n          this.motionSensorDataManager.parseDeviceOrientation(dataView);\n        break;\n      case \"tapDetector\":\n        sensorData = {};\n        break;\n      case \"barometer\":\n        sensorData = this.barometerSensorDataManager.parseData(\n          dataView,\n          scalar\n        );\n        break;\n      case \"camera\":\n        // we parse camera data using CameraManager\n        return;\n      case \"microphone\":\n        // we parse microphone data using MicrophoneManager\n        return;\n      default:\n        _console.error(`uncaught sensorType \"${sensorType}\"`);\n    }\n\n    _console.assertWithError(\n      sensorData != null,\n      `no sensorData defined for sensorType \"${sensorType}\"`\n    );\n\n    _console.log({ sensorType, sensorData });\n\n    // @ts-expect-error\n    this.dispatchEvent(sensorType, {\n      sensorType,\n      [sensorType]: sensorData,\n      timestamp,\n      isLast: isLast!,\n    });\n    // @ts-expect-error\n    this.dispatchEvent(\"sensorData\", {\n      sensorType,\n      [sensorType]: sensorData,\n      timestamp,\n      isLast: isLast!,\n    });\n  }\n}\n\nexport default SensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport SensorDataManager, {\n  SensorTypes,\n  SensorType,\n} from \"./SensorDataManager.ts\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\nimport Device, { SendMessageCallback } from \"../Device.ts\";\nimport autoBind from \"../../node_modules/auto-bind/index.js\";\n\nconst _console = createConsole(\"SensorConfigurationManager\", { log: false });\n\nexport type SensorConfiguration = { [sensorType in SensorType]?: number };\n\nexport const MaxSensorRate = 2 ** 16 - 1;\nexport const SensorRateStep = 5;\n\nexport const SensorConfigurationMessageTypes = [\n  \"getSensorConfiguration\",\n  \"setSensorConfiguration\",\n] as const;\nexport type SensorConfigurationMessageType =\n  (typeof SensorConfigurationMessageTypes)[number];\n\nexport const SensorConfigurationEventTypes = SensorConfigurationMessageTypes;\nexport type SensorConfigurationEventType =\n  (typeof SensorConfigurationEventTypes)[number];\n\nexport interface SensorConfigurationEventMessages {\n  getSensorConfiguration: { sensorConfiguration: SensorConfiguration };\n}\n\nexport type SensorConfigurationEventDispatcher = EventDispatcher<\n  Device,\n  SensorConfigurationEventType,\n  SensorConfigurationEventMessages\n>;\n\nexport type SendSensorConfigurationMessageCallback =\n  SendMessageCallback<SensorConfigurationMessageType>;\n\nclass SensorConfigurationManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendSensorConfigurationMessageCallback;\n\n  eventDispatcher!: SensorConfigurationEventDispatcher;\n  get addEventListener() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  #availableSensorTypes!: SensorType[];\n  get availableSensorTypes() {\n    return this.#availableSensorTypes || [];\n  }\n  #assertAvailableSensorType(sensorType: SensorType) {\n    _console.assertWithError(\n      this.#availableSensorTypes,\n      \"must get initial sensorConfiguration\"\n    );\n    const isSensorTypeAvailable = this.hasSensorType(sensorType);\n    _console.log({ sensorType, isSensorTypeAvailable });\n    return isSensorTypeAvailable;\n  }\n\n  hasSensorType(sensorType: SensorType) {\n    return this.availableSensorTypes.includes(sensorType);\n  }\n\n  #configuration: SensorConfiguration = {};\n  get configuration() {\n    return this.#configuration;\n  }\n\n  #updateConfiguration(updatedConfiguration: SensorConfiguration) {\n    this.#configuration = updatedConfiguration;\n    _console.log({ updatedConfiguration: this.#configuration });\n    this.#dispatchEvent(\"getSensorConfiguration\", {\n      sensorConfiguration: this.configuration,\n    });\n  }\n\n  clear() {\n    this.#updateConfiguration({});\n  }\n\n  #isRedundant(sensorConfiguration: SensorConfiguration) {\n    let sensorTypes = Object.keys(sensorConfiguration) as SensorType[];\n    return sensorTypes.every((sensorType) => {\n      return this.configuration[sensorType] == sensorConfiguration[sensorType];\n    });\n  }\n\n  async setConfiguration(\n    newSensorConfiguration: SensorConfiguration,\n    clearRest?: boolean,\n    sendImmediately?: boolean\n  ) {\n    if (clearRest) {\n      newSensorConfiguration = Object.assign(\n        structuredClone(this.zeroSensorConfiguration),\n        newSensorConfiguration\n      );\n    }\n    _console.log({ newSensorConfiguration });\n    if (this.#isRedundant(newSensorConfiguration)) {\n      _console.log(\"redundant sensor configuration\");\n      return;\n    }\n    const setSensorConfigurationData = this.#createData(newSensorConfiguration);\n    _console.log({ setSensorConfigurationData });\n\n    const promise = this.waitForEvent(\"getSensorConfiguration\");\n    this.sendMessage(\n      [\n        {\n          type: \"setSensorConfiguration\",\n          data: setSensorConfigurationData.buffer,\n        },\n      ],\n      sendImmediately\n    );\n    await promise;\n  }\n\n  #parse(dataView: DataView<ArrayBuffer>) {\n    const parsedSensorConfiguration: SensorConfiguration = {};\n    for (\n      let byteOffset = 0;\n      byteOffset < dataView.byteLength;\n      byteOffset += 3\n    ) {\n      const sensorTypeIndex = dataView.getUint8(byteOffset);\n      const sensorType = SensorTypes[sensorTypeIndex];\n\n      const sensorRate = dataView.getUint16(byteOffset + 1, true);\n      _console.log({ sensorType, sensorRate });\n\n      if (!sensorType) {\n        _console.warn(`unknown sensorType index ${sensorTypeIndex}`);\n        continue;\n      }\n      parsedSensorConfiguration[sensorType] = sensorRate;\n    }\n    _console.log({ parsedSensorConfiguration });\n    this.#availableSensorTypes = Object.keys(\n      parsedSensorConfiguration\n    ) as SensorType[];\n    _console.log(\"availableSensorTypes\", this.#availableSensorTypes);\n    return parsedSensorConfiguration;\n  }\n\n  static #AssertValidSensorRate(sensorRate: number) {\n    _console.assertTypeWithError(sensorRate, \"number\");\n    _console.assertWithError(\n      sensorRate >= 0,\n      `sensorRate must be 0 or greater (got ${sensorRate})`\n    );\n    _console.assertWithError(\n      sensorRate < MaxSensorRate,\n      `sensorRate must be 0 or greater (got ${sensorRate})`\n    );\n    _console.assertWithError(\n      sensorRate % SensorRateStep == 0,\n      `sensorRate must be multiple of ${SensorRateStep}`\n    );\n  }\n\n  #assertValidSensorRate(sensorRate: number) {\n    SensorConfigurationManager.#AssertValidSensorRate(sensorRate);\n  }\n\n  #createData(sensorConfiguration: SensorConfiguration) {\n    let sensorTypes = Object.keys(sensorConfiguration) as SensorType[];\n    sensorTypes = sensorTypes.filter((sensorType) =>\n      this.#assertAvailableSensorType(sensorType)\n    );\n\n    const dataView = new DataView(new ArrayBuffer(sensorTypes.length * 3));\n    sensorTypes.forEach((sensorType, index) => {\n      SensorDataManager.AssertValidSensorType(sensorType);\n      const sensorTypeEnum = SensorTypes.indexOf(sensorType);\n      dataView.setUint8(index * 3, sensorTypeEnum);\n\n      const sensorRate = sensorConfiguration[sensorType]!;\n      this.#assertValidSensorRate(sensorRate);\n      dataView.setUint16(index * 3 + 1, sensorRate, true);\n    });\n    _console.log({ sensorConfigurationData: dataView });\n    return dataView;\n  }\n\n  // ZERO\n  static #ZeroSensorConfiguration: SensorConfiguration = {};\n  static get ZeroSensorConfiguration() {\n    return this.#ZeroSensorConfiguration;\n  }\n  static {\n    SensorTypes.forEach((sensorType) => {\n      this.#ZeroSensorConfiguration[sensorType] = 0;\n    });\n  }\n  get zeroSensorConfiguration() {\n    const zeroSensorConfiguration: SensorConfiguration = {};\n    this.#availableSensorTypes.forEach((sensorType) => {\n      zeroSensorConfiguration[sensorType] = 0;\n    });\n    return zeroSensorConfiguration;\n  }\n  async clearSensorConfiguration() {\n    return this.setConfiguration(this.zeroSensorConfiguration);\n  }\n\n  // MESSAGE\n  parseMessage(\n    messageType: SensorConfigurationMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getSensorConfiguration\":\n      case \"setSensorConfiguration\":\n        const newSensorConfiguration = this.#parse(dataView);\n        this.#updateConfiguration(newSensorConfiguration);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default SensorConfigurationManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport SensorDataManager, { SensorTypes } from \"./sensor/SensorDataManager.ts\";\nimport { arrayWithoutDuplicates } from \"./utils/ArrayUtils.ts\";\nimport { SensorRateStep } from \"./sensor/SensorConfigurationManager.ts\";\nimport { parseTimestamp } from \"./utils/MathUtils.ts\";\nimport { SensorType } from \"./sensor/SensorDataManager.ts\";\nimport Device, { SendMessageCallback } from \"./Device.ts\";\nimport autoBind from \"auto-bind\";\nimport { FileConfiguration as BaseFileConfiguration } from \"./FileTransferManager.ts\";\nimport { UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\n\nconst _console = createConsole(\"TfliteManager\", { log: false });\n\nexport const TfliteMessageTypes = [\n  \"getTfliteName\",\n  \"setTfliteName\",\n  \"getTfliteTask\",\n  \"setTfliteTask\",\n  \"getTfliteSampleRate\",\n  \"setTfliteSampleRate\",\n  \"getTfliteSensorTypes\",\n  \"setTfliteSensorTypes\",\n  \"tfliteIsReady\",\n  \"getTfliteCaptureDelay\",\n  \"setTfliteCaptureDelay\",\n  \"getTfliteThreshold\",\n  \"setTfliteThreshold\",\n  \"getTfliteInferencingEnabled\",\n  \"setTfliteInferencingEnabled\",\n  \"tfliteInference\",\n] as const;\nexport type TfliteMessageType = (typeof TfliteMessageTypes)[number];\n\nexport const TfliteEventTypes = TfliteMessageTypes;\nexport type TfliteEventType = (typeof TfliteEventTypes)[number];\n\nexport const RequiredTfliteMessageTypes: TfliteMessageType[] = [\n  \"getTfliteName\",\n  \"getTfliteTask\",\n  \"getTfliteSampleRate\",\n  \"getTfliteSensorTypes\",\n  \"tfliteIsReady\",\n  \"getTfliteCaptureDelay\",\n  \"getTfliteThreshold\",\n  \"getTfliteInferencingEnabled\",\n];\n\nexport const TfliteTasks = [\"classification\", \"regression\"] as const;\nexport type TfliteTask = (typeof TfliteTasks)[number];\n\nexport interface TfliteEventMessages {\n  getTfliteName: { tfliteName: string };\n  getTfliteTask: { tfliteTask: TfliteTask };\n  getTfliteSampleRate: { tfliteSampleRate: number };\n  getTfliteSensorTypes: { tfliteSensorTypes: SensorType[] };\n  tfliteIsReady: { tfliteIsReady: boolean };\n  getTfliteCaptureDelay: { tfliteCaptureDelay: number };\n  getTfliteThreshold: { tfliteThreshold: number };\n  getTfliteInferencingEnabled: { tfliteInferencingEnabled: boolean };\n  tfliteInference: { tfliteInference: TfliteInference };\n}\n\nexport interface TfliteInference {\n  timestamp: number;\n  values: number[];\n  maxValue?: number;\n  maxIndex?: number;\n  maxClass?: string;\n  classValues?: { [key: string]: number };\n}\n\nexport type TfliteEventDispatcher = EventDispatcher<\n  Device,\n  TfliteEventType,\n  TfliteEventMessages\n>;\nexport type SendTfliteMessageCallback = SendMessageCallback<TfliteMessageType>;\n\nexport const TfliteSensorTypes = [\n  \"pressure\",\n  \"linearAcceleration\",\n  \"gyroscope\",\n  \"magnetometer\",\n] as const satisfies readonly SensorType[];\nexport type TfliteSensorType = (typeof TfliteSensorTypes)[number];\n\nexport interface TfliteFileConfiguration extends BaseFileConfiguration {\n  type: \"tflite\";\n  name: string;\n  sensorTypes: TfliteSensorType[];\n  task: TfliteTask;\n  sampleRate: number;\n  captureDelay?: number;\n  threshold?: number;\n  classes?: string[];\n}\n\nclass TfliteManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendTfliteMessageCallback;\n\n  #assertValidTask(task: TfliteTask) {\n    _console.assertEnumWithError(task, TfliteTasks);\n  }\n  #assertValidTaskEnum(taskEnum: number) {\n    _console.assertWithError(\n      taskEnum in TfliteTasks,\n      `invalid taskEnum ${taskEnum}`\n    );\n  }\n\n  eventDispatcher!: TfliteEventDispatcher;\n  get addEventListenter() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  // PROPERTIES\n\n  #classes?: string[];\n  get classes() {\n    return this.#classes;\n  }\n  setClasses(newClasses?: string[]) {\n    this.#classes = newClasses?.slice();\n    _console.log(\"classes\", this.classes);\n  }\n\n  #name!: string;\n  get name() {\n    return this.#name;\n  }\n  #parseName(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseName\", dataView);\n    const name = textDecoder.decode(dataView.buffer);\n    this.#updateName(name);\n  }\n  #updateName(name: string) {\n    _console.log({ name });\n    this.#name = name;\n    this.#dispatchEvent(\"getTfliteName\", { tfliteName: name });\n  }\n  async setName(newName: string, sendImmediately?: boolean) {\n    _console.assertTypeWithError(newName, \"string\");\n    if (this.name == newName) {\n      _console.log(`redundant name assignment ${newName}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteName\");\n\n    const setNameData = textEncoder.encode(newName);\n    this.sendMessage(\n      [{ type: \"setTfliteName\", data: setNameData.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #task!: TfliteTask;\n  get task() {\n    return this.#task;\n  }\n  #parseTask(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseTask\", dataView);\n    const taskEnum = dataView.getUint8(0);\n    this.#assertValidTaskEnum(taskEnum);\n    const task = TfliteTasks[taskEnum];\n    this.#updateTask(task);\n  }\n  #updateTask(task: TfliteTask) {\n    _console.log({ task });\n    this.#task = task;\n    this.#dispatchEvent(\"getTfliteTask\", { tfliteTask: task });\n  }\n  async setTask(newTask: TfliteTask, sendImmediately?: boolean) {\n    this.#assertValidTask(newTask);\n    if (this.task == newTask) {\n      _console.log(`redundant task assignment ${newTask}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteTask\");\n\n    const taskEnum = TfliteTasks.indexOf(newTask);\n    this.sendMessage(\n      [{ type: \"setTfliteTask\", data: UInt8ByteBuffer(taskEnum) }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #sampleRate!: number;\n  get sampleRate() {\n    return this.#sampleRate;\n  }\n  #parseSampleRate(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseSampleRate\", dataView);\n    const sampleRate = dataView.getUint16(0, true);\n    this.#updateSampleRate(sampleRate);\n  }\n  #updateSampleRate(sampleRate: number) {\n    _console.log({ sampleRate });\n    this.#sampleRate = sampleRate;\n    this.#dispatchEvent(\"getTfliteSampleRate\", {\n      tfliteSampleRate: sampleRate,\n    });\n  }\n  async setSampleRate(newSampleRate: number, sendImmediately?: boolean) {\n    _console.assertTypeWithError(newSampleRate, \"number\");\n    newSampleRate -= newSampleRate % SensorRateStep;\n    _console.assertWithError(\n      newSampleRate >= SensorRateStep,\n      `sampleRate must be multiple of ${SensorRateStep} greater than 0 (got ${newSampleRate})`\n    );\n    if (this.#sampleRate == newSampleRate) {\n      _console.log(`redundant sampleRate assignment ${newSampleRate}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteSampleRate\");\n\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, newSampleRate, true);\n    this.sendMessage(\n      [{ type: \"setTfliteSampleRate\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  static AssertValidSensorType(sensorType: SensorType) {\n    SensorDataManager.AssertValidSensorType(sensorType);\n    const tfliteSensorType = sensorType as TfliteSensorType;\n    _console.assertWithError(\n      TfliteSensorTypes.includes(tfliteSensorType),\n      `invalid tflite sensorType \"${sensorType}\"`\n    );\n  }\n\n  #sensorTypes: TfliteSensorType[] = [];\n  get sensorTypes() {\n    return this.#sensorTypes.slice();\n  }\n  #parseSensorTypes(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseSensorTypes\", dataView);\n    const sensorTypes: TfliteSensorType[] = [];\n    for (let index = 0; index < dataView.byteLength; index++) {\n      const sensorTypeEnum = dataView.getUint8(index);\n      const sensorType = SensorTypes[sensorTypeEnum] as TfliteSensorType;\n      if (sensorType) {\n        if (TfliteSensorTypes.includes(sensorType)) {\n          sensorTypes.push(sensorType);\n        } else {\n          _console.error(`invalid tfliteSensorType ${sensorType}`);\n        }\n      } else {\n        _console.error(`invalid sensorTypeEnum ${sensorTypeEnum}`);\n      }\n    }\n    this.#updateSensorTypes(sensorTypes);\n  }\n  #updateSensorTypes(sensorTypes: TfliteSensorType[]) {\n    _console.log({ sensorTypes });\n    this.#sensorTypes = sensorTypes;\n    this.#dispatchEvent(\"getTfliteSensorTypes\", {\n      tfliteSensorTypes: sensorTypes,\n    });\n  }\n  async setSensorTypes(\n    newSensorTypes: SensorType[],\n    sendImmediately?: boolean\n  ) {\n    newSensorTypes.forEach((sensorType) => {\n      TfliteManager.AssertValidSensorType(sensorType);\n    });\n\n    const promise = this.waitForEvent(\"getTfliteSensorTypes\");\n\n    newSensorTypes = arrayWithoutDuplicates(newSensorTypes);\n    const newSensorTypeEnums = newSensorTypes\n      .map((sensorType) => SensorTypes.indexOf(sensorType))\n      .sort();\n    _console.log(newSensorTypes, newSensorTypeEnums);\n    this.sendMessage(\n      [\n        {\n          type: \"setTfliteSensorTypes\",\n          data: Uint8Array.from(newSensorTypeEnums).buffer,\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #isReady!: boolean;\n  get isReady() {\n    return this.#isReady;\n  }\n  #parseIsReady(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseIsReady\", dataView);\n    const isReady = Boolean(dataView.getUint8(0));\n    this.#updateIsReady(isReady);\n  }\n  #updateIsReady(isReady: boolean) {\n    _console.log({ isReady });\n    this.#isReady = isReady;\n    this.#dispatchEvent(\"tfliteIsReady\", { tfliteIsReady: isReady });\n  }\n  #assertIsReady() {\n    _console.assertWithError(this.isReady, `tflite is not ready`);\n  }\n\n  #captureDelay!: number;\n  get captureDelay() {\n    return this.#captureDelay;\n  }\n  #parseCaptureDelay(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseCaptureDelay\", dataView);\n    const captureDelay = dataView.getUint16(0, true);\n    this.#updateCaptueDelay(captureDelay);\n  }\n  #updateCaptueDelay(captureDelay: number) {\n    _console.log({ captureDelay });\n    this.#captureDelay = captureDelay;\n    this.#dispatchEvent(\"getTfliteCaptureDelay\", {\n      tfliteCaptureDelay: captureDelay,\n    });\n  }\n  async setCaptureDelay(newCaptureDelay: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newCaptureDelay, \"number\");\n    if (this.#captureDelay == newCaptureDelay) {\n      _console.log(`redundant captureDelay assignment ${newCaptureDelay}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteCaptureDelay\");\n\n    const dataView = new DataView(new ArrayBuffer(2));\n    dataView.setUint16(0, newCaptureDelay, true);\n    this.sendMessage(\n      [{ type: \"setTfliteCaptureDelay\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #threshold!: number;\n  get threshold() {\n    return this.#threshold;\n  }\n  #parseThreshold(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseThreshold\", dataView);\n    const threshold = dataView.getFloat32(0, true);\n    this.#updateThreshold(threshold);\n  }\n  #updateThreshold(threshold: number) {\n    _console.log({ threshold });\n    this.#threshold = threshold;\n    this.#dispatchEvent(\"getTfliteThreshold\", { tfliteThreshold: threshold });\n  }\n  async setThreshold(newThreshold: number, sendImmediately: boolean) {\n    _console.assertTypeWithError(newThreshold, \"number\");\n    _console.assertWithError(\n      newThreshold >= 0,\n      `threshold must be positive (got ${newThreshold})`\n    );\n    if (this.#threshold == newThreshold) {\n      _console.log(`redundant threshold assignment ${newThreshold}`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteThreshold\");\n\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setFloat32(0, newThreshold, true);\n    this.sendMessage(\n      [{ type: \"setTfliteThreshold\", data: dataView.buffer }],\n      sendImmediately\n    );\n\n    await promise;\n  }\n\n  #inferencingEnabled!: boolean;\n  get inferencingEnabled() {\n    return this.#inferencingEnabled;\n  }\n  #parseInferencingEnabled(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseInferencingEnabled\", dataView);\n    const inferencingEnabled = Boolean(dataView.getUint8(0));\n    this.#updateInferencingEnabled(inferencingEnabled);\n  }\n  #updateInferencingEnabled(inferencingEnabled: boolean) {\n    _console.log({ inferencingEnabled });\n    this.#inferencingEnabled = inferencingEnabled;\n    this.#dispatchEvent(\"getTfliteInferencingEnabled\", {\n      tfliteInferencingEnabled: inferencingEnabled,\n    });\n  }\n  async setInferencingEnabled(\n    newInferencingEnabled: boolean,\n    sendImmediately: boolean = true\n  ) {\n    _console.assertTypeWithError(newInferencingEnabled, \"boolean\");\n    if (!newInferencingEnabled && !this.isReady) {\n      return;\n    }\n    this.#assertIsReady();\n    if (this.#inferencingEnabled == newInferencingEnabled) {\n      _console.log(\n        `redundant inferencingEnabled assignment ${newInferencingEnabled}`\n      );\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getTfliteInferencingEnabled\");\n\n    this.sendMessage(\n      [\n        {\n          type: \"setTfliteInferencingEnabled\",\n\n          data: UInt8ByteBuffer(Number(newInferencingEnabled)),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  async toggleInferencingEnabled() {\n    return this.setInferencingEnabled(!this.inferencingEnabled);\n  }\n\n  async enableInferencing() {\n    if (this.inferencingEnabled) {\n      return;\n    }\n    this.setInferencingEnabled(true);\n  }\n  async disableInferencing() {\n    if (!this.inferencingEnabled) {\n      return;\n    }\n    this.setInferencingEnabled(false);\n  }\n\n  #parseInference(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseInference\", dataView);\n\n    const timestamp = parseTimestamp(dataView, 0);\n    _console.log({ timestamp });\n\n    const values: number[] = [];\n    for (\n      let index = 0, byteOffset = 2;\n      byteOffset < dataView.byteLength;\n      index++, byteOffset += 4\n    ) {\n      const value = dataView.getFloat32(byteOffset, true);\n      values.push(value);\n    }\n    _console.log(\"values\", values);\n\n    const inference: TfliteInference = {\n      timestamp,\n      values,\n    };\n\n    if (this.task == \"classification\") {\n      let maxValue = 0;\n      let maxIndex = 0;\n      values.forEach((value, index) => {\n        if (value > maxValue) {\n          maxValue = value;\n          maxIndex = index;\n        }\n      });\n      _console.log({ maxIndex, maxValue });\n      inference.maxIndex = maxIndex;\n      inference.maxValue = maxValue;\n      if (this.classes) {\n        const { classes } = this;\n        inference.maxClass = classes[maxIndex];\n        inference.classValues = {};\n        values.forEach((value, index) => {\n          const key = classes[index];\n          inference.classValues![key] = value;\n        });\n      }\n    }\n\n    this.#dispatchEvent(\"tfliteInference\", { tfliteInference: inference });\n  }\n\n  parseMessage(\n    messageType: TfliteMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getTfliteName\":\n      case \"setTfliteName\":\n        this.#parseName(dataView);\n        break;\n      case \"getTfliteTask\":\n      case \"setTfliteTask\":\n        this.#parseTask(dataView);\n        break;\n      case \"getTfliteSampleRate\":\n      case \"setTfliteSampleRate\":\n        this.#parseSampleRate(dataView);\n        break;\n      case \"getTfliteSensorTypes\":\n      case \"setTfliteSensorTypes\":\n        this.#parseSensorTypes(dataView);\n        break;\n      case \"tfliteIsReady\":\n        this.#parseIsReady(dataView);\n        break;\n      case \"getTfliteCaptureDelay\":\n      case \"setTfliteCaptureDelay\":\n        this.#parseCaptureDelay(dataView);\n        break;\n      case \"getTfliteThreshold\":\n      case \"setTfliteThreshold\":\n        this.#parseThreshold(dataView);\n        break;\n      case \"getTfliteInferencingEnabled\":\n      case \"setTfliteInferencingEnabled\":\n        this.#parseInferencingEnabled(dataView);\n        break;\n      case \"tfliteInference\":\n        this.#parseInference(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  #configuration?: TfliteFileConfiguration;\n  get configuration() {\n    return this.#configuration;\n  }\n  sendConfiguration(\n    configuration: TfliteFileConfiguration,\n    sendImmediately?: boolean\n  ) {\n    if (configuration == this.#configuration) {\n      _console.log(\"redundant tflite configuration assignment\");\n      return;\n    }\n    this.#configuration = configuration;\n    _console.log(\"assigned new tflite configuration\", this.configuration);\n    if (!this.configuration) {\n      return;\n    }\n    const {\n      name,\n      task,\n      captureDelay,\n      sampleRate,\n      threshold,\n      sensorTypes,\n      classes,\n    } = this.configuration;\n    this.setClasses(classes);\n    this.setName(name, false);\n    this.setTask(task, false);\n    if (captureDelay != undefined) {\n      this.setCaptureDelay(captureDelay, false);\n    }\n    this.setSampleRate(sampleRate, false);\n    if (threshold != undefined) {\n      this.setThreshold(threshold, false);\n    }\n    this.setSensorTypes(sensorTypes, sendImmediately);\n  }\n\n  clear() {\n    this.#classes = undefined;\n    this.#inferencingEnabled = false;\n    this.#sensorTypes = [];\n    this.#sampleRate = 0;\n    this.#isReady = false;\n    // @ts-expect-error\n    this.#name = undefined;\n    // @ts-expect-error\n    this.#task = undefined;\n    // @ts-expect-error\n    this.#sampleRate = undefined;\n    this.#sensorTypes.length = 0;\n    // @ts-expect-error\n    this.#isReady = undefined;\n    // @ts-expect-error\n    this.#captureDelay = undefined;\n    // @ts-expect-error\n    this.#threshold = undefined;\n    // @ts-expect-error\n    this.#inferencingEnabled = undefined;\n    this.#configuration = undefined;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required tflite information\");\n    const messages = RequiredTfliteMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n}\n\nexport default TfliteManager;\n","import Device from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder } from \"./utils/Text.ts\";\n\nconst _console = createConsole(\"DeviceInformationManager\", { log: false });\n\nexport interface PnpId {\n  source: \"Bluetooth\" | \"USB\";\n  vendorId: number;\n  productId: number;\n  productVersion: number;\n}\n\nexport interface DeviceInformation {\n  manufacturerName: string;\n  modelNumber: string;\n  softwareRevision: string;\n  hardwareRevision: string;\n  firmwareRevision: string;\n  pnpId: PnpId;\n  serialNumber: string;\n}\n\nexport const DeviceInformationTypes = [\n  \"manufacturerName\",\n  \"modelNumber\",\n  \"hardwareRevision\",\n  \"firmwareRevision\",\n  \"softwareRevision\",\n  \"pnpId\",\n  \"serialNumber\",\n] as const;\nexport type DeviceInformationType = (typeof DeviceInformationTypes)[number];\n\nexport const DeviceInformationEventTypes = [\n  ...DeviceInformationTypes,\n  \"deviceInformation\",\n] as const;\nexport type DeviceInformationEventType =\n  (typeof DeviceInformationEventTypes)[number];\n\nexport interface DeviceInformationEventMessages {\n  manufacturerName: { manufacturerName: string };\n  modelNumber: { modelNumber: string };\n  softwareRevision: { softwareRevision: string };\n  hardwareRevision: { hardwareRevision: string };\n  firmwareRevision: { firmwareRevision: string };\n  pnpId: { pnpId: PnpId };\n  serialNumber: { serialNumber: string };\n  deviceInformation: { deviceInformation: DeviceInformation };\n}\n\nexport type DeviceInformationEventDispatcher = EventDispatcher<\n  Device,\n  DeviceInformationEventType,\n  DeviceInformationEventMessages\n>;\n\nclass DeviceInformationManager {\n  eventDispatcher!: DeviceInformationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  #information: Partial<DeviceInformation> = {};\n  get information() {\n    return this.#information as DeviceInformation;\n  }\n  clear() {\n    this.#information = {};\n  }\n  get #isComplete() {\n    return DeviceInformationTypes.filter((key) => key != \"serialNumber\").every(\n      (key) => key in this.#information\n    );\n  }\n\n  #update(partialDeviceInformation: Partial<DeviceInformation>) {\n    _console.log({ partialDeviceInformation });\n    const deviceInformationNames = Object.keys(\n      partialDeviceInformation\n    ) as (keyof DeviceInformation)[];\n    deviceInformationNames.forEach((deviceInformationName) => {\n      // @ts-expect-error\n      this.#dispatchEvent(deviceInformationName, {\n        [deviceInformationName]:\n          partialDeviceInformation[deviceInformationName],\n      });\n    });\n\n    Object.assign(this.#information, partialDeviceInformation);\n    _console.log({ deviceInformation: this.#information });\n    if (this.#isComplete) {\n      _console.log(\"completed deviceInformation\");\n      this.#dispatchEvent(\"deviceInformation\", {\n        deviceInformation: this.information,\n      });\n    }\n  }\n\n  parseMessage(\n    messageType: DeviceInformationType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"manufacturerName\":\n        const manufacturerName = textDecoder.decode(dataView.buffer);\n        _console.log({ manufacturerName });\n        this.#update({ manufacturerName });\n        break;\n      case \"modelNumber\":\n        const modelNumber = textDecoder.decode(dataView.buffer);\n        _console.log({ modelNumber });\n        this.#update({ modelNumber });\n        break;\n      case \"softwareRevision\":\n        const softwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ softwareRevision });\n        this.#update({ softwareRevision });\n        break;\n      case \"hardwareRevision\":\n        const hardwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ hardwareRevision });\n        this.#update({ hardwareRevision });\n        break;\n      case \"firmwareRevision\":\n        const firmwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ firmwareRevision });\n        this.#update({ firmwareRevision });\n        break;\n      case \"pnpId\":\n        const pnpId: PnpId = {\n          source: dataView.getUint8(0) === 1 ? \"Bluetooth\" : \"USB\",\n          productId: dataView.getUint16(3, true),\n          productVersion: dataView.getUint16(5, true),\n          vendorId: 0,\n        };\n        if (pnpId.source == \"Bluetooth\") {\n          pnpId.vendorId = dataView.getUint16(1, true);\n        } else {\n          // no need to implement\n        }\n        _console.log({ pnpId });\n        this.#update({ pnpId });\n        break;\n      case \"serialNumber\":\n        const serialNumber = textDecoder.decode(dataView.buffer);\n        _console.log({ serialNumber });\n        // will only be used for node\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default DeviceInformationManager;\n","import { ConnectionType } from \"./connection/BaseConnectionManager.ts\";\nimport Device, { SendMessageCallback } from \"./Device.ts\";\nimport { UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"InformationManager\", { log: false });\n\nexport const DeviceTypes = [\n  \"leftInsole\",\n  \"rightInsole\",\n  \"leftGlove\",\n  \"rightGlove\",\n  \"glasses\",\n  \"generic\",\n] as const;\nexport type DeviceType = (typeof DeviceTypes)[number];\n\nexport const Sides = [\"left\", \"right\"] as const;\nexport type Side = (typeof Sides)[number];\n\nexport const MinNameLength = 2;\nexport const MaxNameLength = 30;\n\nexport const InformationMessageTypes = [\n  \"isCharging\",\n  \"getBatteryCurrent\",\n  \"getMtu\",\n  \"getId\",\n  \"getName\",\n  \"setName\",\n  \"getType\",\n  \"setType\",\n  \"getCurrentTime\",\n  \"setCurrentTime\",\n] as const;\nexport type InformationMessageType = (typeof InformationMessageTypes)[number];\n\nexport const InformationEventTypes = InformationMessageTypes;\nexport type InformationEventType = (typeof InformationEventTypes)[number];\n\nexport interface InformationEventMessages {\n  isCharging: { isCharging: boolean };\n  getBatteryCurrent: { batteryCurrent: number };\n  getMtu: { mtu: number };\n  getId: { id: string };\n  getName: { name: string };\n  getType: { type: DeviceType };\n  getCurrentTime: { currentTime: number };\n}\n\nexport type InformationEventDispatcher = EventDispatcher<\n  Device,\n  InformationEventType,\n  InformationEventMessages\n>;\nexport type SendInformationMessageCallback =\n  SendMessageCallback<InformationMessageType>;\n\nclass InformationManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendInformationMessageCallback;\n\n  eventDispatcher!: InformationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  // PROPERTIES\n\n  #isCharging = false;\n  get isCharging() {\n    return this.#isCharging;\n  }\n  #updateIsCharging(updatedIsCharging: boolean) {\n    _console.assertTypeWithError(updatedIsCharging, \"boolean\");\n    this.#isCharging = updatedIsCharging;\n    _console.log({ isCharging: this.#isCharging });\n    this.#dispatchEvent(\"isCharging\", { isCharging: this.#isCharging });\n  }\n\n  #batteryCurrent!: number;\n  get batteryCurrent() {\n    return this.#batteryCurrent;\n  }\n  async getBatteryCurrent() {\n    _console.log(\"getting battery current...\");\n    const promise = this.waitForEvent(\"getBatteryCurrent\");\n    this.sendMessage([{ type: \"getBatteryCurrent\" }]);\n    await promise;\n  }\n  #updateBatteryCurrent(updatedBatteryCurrent: number) {\n    _console.assertTypeWithError(updatedBatteryCurrent, \"number\");\n    this.#batteryCurrent = updatedBatteryCurrent;\n    _console.log({ batteryCurrent: this.#batteryCurrent });\n    this.#dispatchEvent(\"getBatteryCurrent\", {\n      batteryCurrent: this.#batteryCurrent,\n    });\n  }\n\n  #id!: string;\n  get id() {\n    return this.#id;\n  }\n  #updateId(updatedId: string) {\n    _console.assertTypeWithError(updatedId, \"string\");\n    this.#id = updatedId;\n    _console.log({ id: this.#id });\n    this.#dispatchEvent(\"getId\", { id: this.#id });\n  }\n\n  #name = \"\";\n  get name() {\n    return this.#name;\n  }\n\n  updateName(updatedName: string) {\n    _console.assertTypeWithError(updatedName, \"string\");\n    this.#name = updatedName;\n    _console.log({ updatedName: this.#name });\n    this.#dispatchEvent(\"getName\", { name: this.#name });\n  }\n  async setName(newName: string) {\n    _console.assertTypeWithError(newName, \"string\");\n    _console.assertRangeWithError(\n      \"newName\",\n      newName.length,\n      MinNameLength,\n      MaxNameLength\n    );\n    const setNameData = textEncoder.encode(newName);\n    _console.log({ setNameData });\n\n    const promise = this.waitForEvent(\"getName\");\n    this.sendMessage([{ type: \"setName\", data: setNameData.buffer }]);\n    await promise;\n  }\n\n  // TYPE\n  #type!: DeviceType;\n  get type() {\n    return this.#type;\n  }\n  get typeEnum() {\n    return DeviceTypes.indexOf(this.type);\n  }\n  #assertValidDeviceType(type: DeviceType) {\n    _console.assertEnumWithError(type, DeviceTypes);\n  }\n  #assertValidDeviceTypeEnum(typeEnum: number) {\n    _console.assertTypeWithError(typeEnum, \"number\");\n    _console.assertWithError(\n      typeEnum in DeviceTypes,\n      `invalid typeEnum ${typeEnum}`\n    );\n  }\n  updateType(updatedType: DeviceType) {\n    this.#assertValidDeviceType(updatedType);\n    // if (updatedType == this.type) {\n    //   _console.log(\"redundant type assignment\");\n    //   return;\n    // }\n    this.#type = updatedType;\n    _console.log({ updatedType: this.#type });\n\n    this.#dispatchEvent(\"getType\", { type: this.#type });\n  }\n  async #setTypeEnum(newTypeEnum: number) {\n    this.#assertValidDeviceTypeEnum(newTypeEnum);\n\n    const setTypeData = UInt8ByteBuffer(newTypeEnum);\n    _console.log({ setTypeData });\n    const promise = this.waitForEvent(\"getType\");\n    this.sendMessage([{ type: \"setType\", data: setTypeData }]);\n    await promise;\n  }\n  async setType(newType: DeviceType) {\n    this.#assertValidDeviceType(newType);\n    const newTypeEnum = DeviceTypes.indexOf(newType);\n    this.#setTypeEnum(newTypeEnum);\n  }\n\n  get isInsole() {\n    switch (this.type) {\n      case \"leftInsole\":\n      case \"rightInsole\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  get isGlove() {\n    switch (this.type) {\n      case \"leftGlove\":\n      case \"rightGlove\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  get side(): Side {\n    switch (this.type) {\n      case \"leftInsole\":\n      case \"leftGlove\":\n        return \"left\";\n      case \"rightInsole\":\n      case \"rightGlove\":\n        return \"right\";\n      default:\n        return \"left\";\n    }\n  }\n\n  #mtu = 0;\n  get mtu() {\n    return this.#mtu;\n  }\n  #updateMtu(newMtu: number) {\n    _console.assertTypeWithError(newMtu, \"number\");\n    if (this.#mtu == newMtu) {\n      _console.log(\"redundant mtu assignment\", newMtu);\n      return;\n    }\n    this.#mtu = newMtu;\n\n    this.#dispatchEvent(\"getMtu\", { mtu: this.#mtu });\n  }\n\n  #isCurrentTimeSet = false;\n  get isCurrentTimeSet() {\n    return this.#isCurrentTimeSet;\n  }\n\n  #currentTimeThreshold = 10_000;\n  #onCurrentTime(currentTime: number) {\n    _console.log({ currentTime });\n    const timeDifference = Date.now() - currentTime;\n    const absTimeDifference = Math.abs(timeDifference);\n    _console.log({ timeDifference, absTimeDifference });\n    this.#isCurrentTimeSet = currentTime != 0;\n    if (false) {\n      this.#isCurrentTimeSet &&= absTimeDifference < this.#currentTimeThreshold;\n    }\n    _console.log(\"isCurrentTimeSet\", this.#isCurrentTimeSet);\n    if (!this.#isCurrentTimeSet) {\n      this.#setCurrentTime(false);\n    }\n  }\n  async #setCurrentTime(sendImmediately?: boolean) {\n    const now = Date.now();\n    _console.log(\"setting current time...\", { now });\n    const dataView = new DataView(new ArrayBuffer(8));\n    dataView.setBigUint64(0, BigInt(now), true);\n    const promise = this.waitForEvent(\"getCurrentTime\");\n    this.sendMessage(\n      [{ type: \"setCurrentTime\", data: dataView.buffer }],\n      sendImmediately\n    );\n    await promise;\n  }\n\n  // MESSAGE\n  parseMessage(\n    messageType: InformationMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"isCharging\":\n        const isCharging = Boolean(dataView.getUint8(0));\n        _console.log({ isCharging });\n        this.#updateIsCharging(isCharging);\n        break;\n      case \"getBatteryCurrent\":\n        const batteryCurrent = dataView.getFloat32(0, true);\n        _console.log({ batteryCurrent });\n        this.#updateBatteryCurrent(batteryCurrent);\n        break;\n      case \"getId\":\n        const id = textDecoder.decode(dataView.buffer);\n        _console.log({ id });\n        this.#updateId(id);\n        break;\n      case \"getName\":\n      case \"setName\":\n        const name = textDecoder.decode(dataView.buffer);\n        _console.log({ name });\n        this.updateName(name);\n        break;\n      case \"getType\":\n      case \"setType\":\n        const typeEnum = dataView.getUint8(0);\n        const type = DeviceTypes[typeEnum];\n        _console.log({ typeEnum, type });\n        this.updateType(type);\n        break;\n      case \"getMtu\":\n        let mtu = dataView.getUint16(0, true);\n        if (\n          this.connectionType != \"webSocket\" &&\n          this.connectionType != \"udp\"\n        ) {\n          mtu = Math.min(mtu, 512);\n        }\n        _console.log({ mtu });\n        this.#updateMtu(mtu);\n        break;\n      case \"getCurrentTime\":\n      case \"setCurrentTime\":\n        const currentTime = Number(dataView.getBigUint64(0, true));\n        this.#onCurrentTime(currentTime);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    this.#isCurrentTimeSet = false;\n    this.#mtu = 0;\n  }\n\n  connectionType?: ConnectionType;\n}\n\nexport default InformationManager;\n","export const VibrationWaveformEffects = [\n  \"none\",\n  \"strongClick100\",\n  \"strongClick60\",\n  \"strongClick30\",\n  \"sharpClick100\",\n  \"sharpClick60\",\n  \"sharpClick30\",\n  \"softBump100\",\n  \"softBump60\",\n  \"softBump30\",\n  \"doubleClick100\",\n  \"doubleClick60\",\n  \"tripleClick100\",\n  \"softFuzz60\",\n  \"strongBuzz100\",\n  \"alert750ms\",\n  \"alert1000ms\",\n  \"strongClick1_100\",\n  \"strongClick2_80\",\n  \"strongClick3_60\",\n  \"strongClick4_30\",\n  \"mediumClick100\",\n  \"mediumClick80\",\n  \"mediumClick60\",\n  \"sharpTick100\",\n  \"sharpTick80\",\n  \"sharpTick60\",\n  \"shortDoubleClickStrong100\",\n  \"shortDoubleClickStrong80\",\n  \"shortDoubleClickStrong60\",\n  \"shortDoubleClickStrong30\",\n  \"shortDoubleClickMedium100\",\n  \"shortDoubleClickMedium80\",\n  \"shortDoubleClickMedium60\",\n  \"shortDoubleSharpTick100\",\n  \"shortDoubleSharpTick80\",\n  \"shortDoubleSharpTick60\",\n  \"longDoubleSharpClickStrong100\",\n  \"longDoubleSharpClickStrong80\",\n  \"longDoubleSharpClickStrong60\",\n  \"longDoubleSharpClickStrong30\",\n  \"longDoubleSharpClickMedium100\",\n  \"longDoubleSharpClickMedium80\",\n  \"longDoubleSharpClickMedium60\",\n  \"longDoubleSharpTick100\",\n  \"longDoubleSharpTick80\",\n  \"longDoubleSharpTick60\",\n  \"buzz100\",\n  \"buzz80\",\n  \"buzz60\",\n  \"buzz40\",\n  \"buzz20\",\n  \"pulsingStrong100\",\n  \"pulsingStrong60\",\n  \"pulsingMedium100\",\n  \"pulsingMedium60\",\n  \"pulsingSharp100\",\n  \"pulsingSharp60\",\n  \"transitionClick100\",\n  \"transitionClick80\",\n  \"transitionClick60\",\n  \"transitionClick40\",\n  \"transitionClick20\",\n  \"transitionClick10\",\n  \"transitionHum100\",\n  \"transitionHum80\",\n  \"transitionHum60\",\n  \"transitionHum40\",\n  \"transitionHum20\",\n  \"transitionHum10\",\n  \"transitionRampDownLongSmooth2_100\",\n  \"transitionRampDownLongSmooth1_100\",\n  \"transitionRampDownMediumSmooth1_100\",\n  \"transitionRampDownMediumSmooth2_100\",\n  \"transitionRampDownShortSmooth1_100\",\n  \"transitionRampDownShortSmooth2_100\",\n  \"transitionRampDownLongSharp1_100\",\n  \"transitionRampDownLongSharp2_100\",\n  \"transitionRampDownMediumSharp1_100\",\n  \"transitionRampDownMediumSharp2_100\",\n  \"transitionRampDownShortSharp1_100\",\n  \"transitionRampDownShortSharp2_100\",\n  \"transitionRampUpLongSmooth1_100\",\n  \"transitionRampUpLongSmooth2_100\",\n  \"transitionRampUpMediumSmooth1_100\",\n  \"transitionRampUpMediumSmooth2_100\",\n  \"transitionRampUpShortSmooth1_100\",\n  \"transitionRampUpShortSmooth2_100\",\n  \"transitionRampUpLongSharp1_100\",\n  \"transitionRampUpLongSharp2_100\",\n  \"transitionRampUpMediumSharp1_100\",\n  \"transitionRampUpMediumSharp2_100\",\n  \"transitionRampUpShortSharp1_100\",\n  \"transitionRampUpShortSharp2_100\",\n  \"transitionRampDownLongSmooth1_50\",\n  \"transitionRampDownLongSmooth2_50\",\n  \"transitionRampDownMediumSmooth1_50\",\n  \"transitionRampDownMediumSmooth2_50\",\n  \"transitionRampDownShortSmooth1_50\",\n  \"transitionRampDownShortSmooth2_50\",\n  \"transitionRampDownLongSharp1_50\",\n  \"transitionRampDownLongSharp2_50\",\n  \"transitionRampDownMediumSharp1_50\",\n  \"transitionRampDownMediumSharp2_50\",\n  \"transitionRampDownShortSharp1_50\",\n  \"transitionRampDownShortSharp2_50\",\n  \"transitionRampUpLongSmooth1_50\",\n  \"transitionRampUpLongSmooth2_50\",\n  \"transitionRampUpMediumSmooth1_50\",\n  \"transitionRampUpMediumSmooth2_50\",\n  \"transitionRampUpShortSmooth1_50\",\n  \"transitionRampUpShortSmooth2_50\",\n  \"transitionRampUpLongSharp1_50\",\n  \"transitionRampUpLongSharp2_50\",\n  \"transitionRampUpMediumSharp1_50\",\n  \"transitionRampUpMediumSharp2_50\",\n  \"transitionRampUpShortSharp1_50\",\n  \"transitionRampUpShortSharp2_50\",\n  \"longBuzz100\",\n  \"smoothHum50\",\n  \"smoothHum40\",\n  \"smoothHum30\",\n  \"smoothHum20\",\n  \"smoothHum10\",\n] as const;\n\nexport type VibrationWaveformEffect = (typeof VibrationWaveformEffects)[number];\n","import { createConsole } from \"../utils/Console.ts\";\nimport {\n  VibrationWaveformEffect,\n  VibrationWaveformEffects,\n} from \"./VibrationWaveformEffects.ts\";\nimport { concatenateArrayBuffers } from \"../utils/ArrayBufferUtils.ts\";\nimport Device, { SendMessageCallback } from \"../Device.ts\";\nimport autoBind from \"auto-bind\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\n\nconst _console = createConsole(\"VibrationManager\", { log: false });\n\nexport const VibrationLocations = [\"front\", \"rear\"] as const;\nexport type VibrationLocation = (typeof VibrationLocations)[number];\n\nexport const VibrationTypes = [\"waveformEffect\", \"waveform\"] as const;\nexport type VibrationType = (typeof VibrationTypes)[number];\n\nexport interface VibrationWaveformEffectSegment {\n  effect?: VibrationWaveformEffect;\n  delay?: number;\n  loopCount?: number;\n}\n\nexport interface VibrationWaveformSegment {\n  duration: number;\n  amplitude: number;\n}\n\nexport const VibrationMessageTypes = [\n  \"getVibrationLocations\",\n  \"triggerVibration\",\n] as const;\nexport type VibrationMessageType = (typeof VibrationMessageTypes)[number];\n\nexport const VibrationEventTypes = VibrationMessageTypes;\nexport type VibrationEventType = (typeof VibrationEventTypes)[number];\n\nexport interface VibrationEventMessages {\n  getVibrationLocations: { vibrationLocations: VibrationLocation[] };\n}\n\nexport const MaxNumberOfVibrationWaveformEffectSegments = 8;\nexport const MaxVibrationWaveformSegmentDuration = 2550;\nexport const MaxVibrationWaveformEffectSegmentDelay = 1270;\nexport const MaxVibrationWaveformEffectSegmentLoopCount = 3;\nexport const MaxNumberOfVibrationWaveformSegments = 20;\nexport const MaxVibrationWaveformEffectSequenceLoopCount = 6;\n\ninterface BaseVibrationConfiguration {\n  type: VibrationType;\n  locations?: VibrationLocation[];\n}\n\nexport interface VibrationWaveformEffectConfiguration\n  extends BaseVibrationConfiguration {\n  type: \"waveformEffect\";\n  segments: VibrationWaveformEffectSegment[];\n  loopCount?: number;\n}\n\nexport interface VibrationWaveformConfiguration\n  extends BaseVibrationConfiguration {\n  type: \"waveform\";\n  segments: VibrationWaveformSegment[];\n}\n\nexport type VibrationConfiguration =\n  | VibrationWaveformEffectConfiguration\n  | VibrationWaveformConfiguration;\n\nexport type SendVibrationMessageCallback =\n  SendMessageCallback<VibrationMessageType>;\n\nexport type VibrationEventDispatcher = EventDispatcher<\n  Device,\n  VibrationEventType,\n  VibrationEventMessages\n>;\n\nclass VibrationManager {\n  constructor() {\n    autoBind(this);\n  }\n  sendMessage!: SendVibrationMessageCallback;\n\n  eventDispatcher!: VibrationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  #verifyLocation(location: VibrationLocation) {\n    _console.assertTypeWithError(location, \"string\");\n    _console.assertWithError(\n      VibrationLocations.includes(location),\n      `invalid location \"${location}\"`\n    );\n  }\n  #verifyLocations(locations: VibrationLocation[]) {\n    this.#assertNonEmptyArray(locations);\n    locations.forEach((location) => {\n      this.#verifyLocation(location);\n    });\n  }\n  #createLocationsBitmask(locations: VibrationLocation[]) {\n    this.#verifyLocations(locations);\n\n    let locationsBitmask = 0;\n    locations.forEach((location) => {\n      const locationIndex = VibrationLocations.indexOf(location);\n      locationsBitmask |= 1 << locationIndex;\n    });\n    _console.log({ locationsBitmask });\n    _console.assertWithError(\n      locationsBitmask > 0,\n      `locationsBitmask must not be zero`\n    );\n    return locationsBitmask;\n  }\n\n  #assertNonEmptyArray(array: any[]) {\n    _console.assertWithError(Array.isArray(array), \"passed non-array\");\n    _console.assertWithError(array.length > 0, \"passed empty array\");\n  }\n\n  #verifyWaveformEffect(waveformEffect: VibrationWaveformEffect) {\n    _console.assertWithError(\n      VibrationWaveformEffects.includes(waveformEffect),\n      `invalid waveformEffect \"${waveformEffect}\"`\n    );\n  }\n\n  #verifyWaveformEffectSegment(\n    waveformEffectSegment: VibrationWaveformEffectSegment\n  ) {\n    if (waveformEffectSegment.effect != undefined) {\n      const waveformEffect = waveformEffectSegment.effect;\n      this.#verifyWaveformEffect(waveformEffect);\n    } else if (waveformEffectSegment.delay != undefined) {\n      const { delay } = waveformEffectSegment;\n      _console.assertWithError(\n        delay >= 0,\n        `delay must be 0ms or greater (got ${delay})`\n      );\n      _console.assertWithError(\n        delay <= MaxVibrationWaveformEffectSegmentDelay,\n        `delay must be ${MaxVibrationWaveformEffectSegmentDelay}ms or less (got ${delay})`\n      );\n    } else {\n      throw Error(\"no effect or delay found in waveformEffectSegment\");\n    }\n\n    if (waveformEffectSegment.loopCount != undefined) {\n      const { loopCount } = waveformEffectSegment;\n      this.#verifyWaveformEffectSegmentLoopCount(loopCount);\n    }\n  }\n\n  #verifyWaveformEffectSegmentLoopCount(\n    waveformEffectSegmentLoopCount: number\n  ) {\n    _console.assertTypeWithError(waveformEffectSegmentLoopCount, \"number\");\n    _console.assertWithError(\n      waveformEffectSegmentLoopCount >= 0,\n      `waveformEffectSegmentLoopCount must be 0 or greater (got ${waveformEffectSegmentLoopCount})`\n    );\n    _console.assertWithError(\n      waveformEffectSegmentLoopCount <=\n        MaxVibrationWaveformEffectSegmentLoopCount,\n      `waveformEffectSegmentLoopCount must be ${MaxVibrationWaveformEffectSegmentLoopCount} or fewer (got ${waveformEffectSegmentLoopCount})`\n    );\n  }\n\n  #verifyWaveformEffectSegments(\n    waveformEffectSegments: VibrationWaveformEffectSegment[]\n  ) {\n    this.#assertNonEmptyArray(waveformEffectSegments);\n    _console.assertWithError(\n      waveformEffectSegments.length <=\n        MaxNumberOfVibrationWaveformEffectSegments,\n      `must have ${MaxNumberOfVibrationWaveformEffectSegments} waveformEffectSegments or fewer (got ${waveformEffectSegments.length})`\n    );\n    waveformEffectSegments.forEach((waveformEffectSegment) => {\n      this.#verifyWaveformEffectSegment(waveformEffectSegment);\n    });\n  }\n\n  #verifyWaveformEffectSequenceLoopCount(\n    waveformEffectSequenceLoopCount: number\n  ) {\n    _console.assertTypeWithError(waveformEffectSequenceLoopCount, \"number\");\n    _console.assertWithError(\n      waveformEffectSequenceLoopCount >= 0,\n      `waveformEffectSequenceLoopCount must be 0 or greater (got ${waveformEffectSequenceLoopCount})`\n    );\n    _console.assertWithError(\n      waveformEffectSequenceLoopCount <=\n        MaxVibrationWaveformEffectSequenceLoopCount,\n      `waveformEffectSequenceLoopCount must be ${MaxVibrationWaveformEffectSequenceLoopCount} or fewer (got ${waveformEffectSequenceLoopCount})`\n    );\n  }\n\n  #verifyWaveformSegment(waveformSegment: VibrationWaveformSegment) {\n    _console.assertTypeWithError(waveformSegment.amplitude, \"number\");\n    _console.assertWithError(\n      waveformSegment.amplitude >= 0,\n      `amplitude must be 0 or greater (got ${waveformSegment.amplitude})`\n    );\n    _console.assertWithError(\n      waveformSegment.amplitude <= 1,\n      `amplitude must be 1 or less (got ${waveformSegment.amplitude})`\n    );\n\n    _console.assertTypeWithError(waveformSegment.duration, \"number\");\n    _console.assertWithError(\n      waveformSegment.duration > 0,\n      `duration must be greater than 0ms (got ${waveformSegment.duration}ms)`\n    );\n    _console.assertWithError(\n      waveformSegment.duration <= MaxVibrationWaveformSegmentDuration,\n      `duration must be ${MaxVibrationWaveformSegmentDuration}ms or less (got ${waveformSegment.duration}ms)`\n    );\n  }\n\n  #verifyWaveformSegments(waveformSegments: VibrationWaveformSegment[]) {\n    this.#assertNonEmptyArray(waveformSegments);\n    _console.assertWithError(\n      waveformSegments.length <= MaxNumberOfVibrationWaveformSegments,\n      `must have ${MaxNumberOfVibrationWaveformSegments} waveformSegments or fewer (got ${waveformSegments.length})`\n    );\n    waveformSegments.forEach((waveformSegment) => {\n      this.#verifyWaveformSegment(waveformSegment);\n    });\n  }\n\n  #createWaveformEffectsData(\n    locations: VibrationLocation[],\n    waveformEffectSegments: VibrationWaveformEffectSegment[],\n    waveformEffectSequenceLoopCount: number = 0\n  ) {\n    this.#verifyWaveformEffectSegments(waveformEffectSegments);\n    this.#verifyWaveformEffectSequenceLoopCount(\n      waveformEffectSequenceLoopCount\n    );\n\n    let dataArray = [];\n    let byteOffset = 0;\n\n    const hasAtLeast1WaveformEffectWithANonzeroLoopCount =\n      waveformEffectSegments.some((waveformEffectSegment) => {\n        const { loopCount } = waveformEffectSegment;\n        return loopCount != undefined && loopCount > 0;\n      });\n\n    const includeAllWaveformEffectSegments =\n      hasAtLeast1WaveformEffectWithANonzeroLoopCount ||\n      waveformEffectSequenceLoopCount != 0;\n\n    for (\n      let index = 0;\n      index < waveformEffectSegments.length ||\n      (includeAllWaveformEffectSegments &&\n        index < MaxNumberOfVibrationWaveformEffectSegments);\n      index++\n    ) {\n      const waveformEffectSegment = waveformEffectSegments[index] || {\n        effect: \"none\",\n      };\n      if (waveformEffectSegment.effect != undefined) {\n        const waveformEffect = waveformEffectSegment.effect;\n        dataArray[byteOffset++] =\n          VibrationWaveformEffects.indexOf(waveformEffect);\n      } else if (waveformEffectSegment.delay != undefined) {\n        const { delay } = waveformEffectSegment;\n        dataArray[byteOffset++] = (1 << 7) | Math.floor(delay / 10); // set most significant bit to 1\n      } else {\n        throw Error(\"invalid waveformEffectSegment\");\n      }\n    }\n\n    const includeAllWaveformEffectSegmentLoopCounts =\n      waveformEffectSequenceLoopCount != 0;\n    for (\n      let index = 0;\n      index < waveformEffectSegments.length ||\n      (includeAllWaveformEffectSegmentLoopCounts &&\n        index < MaxNumberOfVibrationWaveformEffectSegments);\n      index++\n    ) {\n      const waveformEffectSegmentLoopCount =\n        waveformEffectSegments[index]?.loopCount || 0;\n      if (index == 0 || index == 4) {\n        dataArray[byteOffset] = 0;\n      }\n      const bitOffset = 2 * (index % 4);\n      dataArray[byteOffset] |= waveformEffectSegmentLoopCount << bitOffset;\n      if (index == 3 || index == 7) {\n        byteOffset++;\n      }\n    }\n\n    if (waveformEffectSequenceLoopCount != 0) {\n      dataArray[byteOffset++] = waveformEffectSequenceLoopCount;\n    }\n    const dataView = new DataView(Uint8Array.from(dataArray).buffer);\n    _console.log({ dataArray, dataView });\n    return this.#createData(locations, \"waveformEffect\", dataView);\n  }\n  #createWaveformData(\n    locations: VibrationLocation[],\n    waveformSegments: VibrationWaveformSegment[]\n  ) {\n    this.#verifyWaveformSegments(waveformSegments);\n    const dataView = new DataView(new ArrayBuffer(waveformSegments.length * 2));\n    waveformSegments.forEach((waveformSegment, index) => {\n      dataView.setUint8(index * 2, Math.floor(waveformSegment.amplitude * 127));\n      dataView.setUint8(\n        index * 2 + 1,\n        Math.floor(waveformSegment.duration / 10)\n      );\n    });\n    _console.log({ dataView });\n    return this.#createData(locations, \"waveform\", dataView);\n  }\n\n  #verifyVibrationType(vibrationType: VibrationType) {\n    _console.assertTypeWithError(vibrationType, \"string\");\n    _console.assertWithError(\n      VibrationTypes.includes(vibrationType),\n      `invalid vibrationType \"${vibrationType}\"`\n    );\n  }\n\n  #createData(\n    locations: VibrationLocation[],\n    vibrationType: VibrationType,\n    dataView: DataView\n  ) {\n    _console.assertWithError(dataView?.byteLength > 0, \"no data received\");\n    const locationsBitmask = this.#createLocationsBitmask(locations);\n    this.#verifyVibrationType(vibrationType);\n    const vibrationTypeIndex = VibrationTypes.indexOf(vibrationType);\n    _console.log({ locationsBitmask, vibrationTypeIndex, dataView });\n    const data = concatenateArrayBuffers(\n      locationsBitmask,\n      vibrationTypeIndex,\n      dataView.byteLength,\n      dataView\n    );\n    _console.log({ data });\n    return data;\n  }\n\n  async triggerVibration(\n    vibrationConfigurations: VibrationConfiguration[],\n    sendImmediately: boolean = true\n  ) {\n    let triggerVibrationData!: ArrayBuffer;\n    vibrationConfigurations.forEach((vibrationConfiguration) => {\n      const { type } = vibrationConfiguration;\n\n      let { locations } = vibrationConfiguration;\n      locations = locations || this.vibrationLocations.slice();\n      locations = locations.filter((location) =>\n        this.vibrationLocations.includes(location)\n      );\n\n      let arrayBuffer: ArrayBuffer;\n\n      switch (type) {\n        case \"waveformEffect\":\n          {\n            const { segments, loopCount } = vibrationConfiguration;\n            arrayBuffer = this.#createWaveformEffectsData(\n              locations,\n              segments,\n              loopCount\n            );\n          }\n          break;\n        case \"waveform\":\n          {\n            const { segments } = vibrationConfiguration;\n            arrayBuffer = this.#createWaveformData(locations, segments);\n          }\n          break;\n        default:\n          throw Error(`invalid vibration type \"${type}\"`);\n      }\n      _console.log({ type, arrayBuffer });\n      triggerVibrationData = concatenateArrayBuffers(\n        triggerVibrationData,\n        arrayBuffer\n      );\n    });\n    await this.sendMessage(\n      [{ type: \"triggerVibration\", data: triggerVibrationData }],\n      sendImmediately\n    );\n  }\n\n  #vibrationLocations: VibrationLocation[] = [];\n  get vibrationLocations() {\n    return this.#vibrationLocations;\n  }\n  #onVibrationLocations(vibrationLocations: VibrationLocation[]) {\n    this.#vibrationLocations = vibrationLocations;\n    _console.log(\"vibrationLocations\", vibrationLocations);\n    this.#dispatchEvent(\"getVibrationLocations\", {\n      vibrationLocations: this.#vibrationLocations,\n    });\n  }\n\n  // MESSAGE\n  parseMessage(\n    messageType: VibrationMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"getVibrationLocations\":\n        const vibrationLocations = Array.from(new Uint8Array(dataView.buffer))\n          .map((index) => VibrationLocations[index])\n          .filter(Boolean);\n        this.#onVibrationLocations(vibrationLocations);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default VibrationManager;\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport { UInt8ByteBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInNode } from \"./utils/environment.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"WifiManager\", { log: false });\n\nexport const MinWifiSSIDLength = 1;\nexport const MaxWifiSSIDLength = 32;\n\nexport const MinWifiPasswordLength = 8;\nexport const MaxWifiPasswordLength = 64;\n\nexport const WifiMessageTypes = [\n  \"isWifiAvailable\",\n  \"getWifiSSID\",\n  \"setWifiSSID\",\n  \"getWifiPassword\",\n  \"setWifiPassword\",\n  \"getWifiConnectionEnabled\",\n  \"setWifiConnectionEnabled\",\n  \"isWifiConnected\",\n  \"ipAddress\",\n  \"isWifiSecure\",\n] as const;\nexport type WifiMessageType = (typeof WifiMessageTypes)[number];\n\nexport const RequiredWifiMessageTypes: WifiMessageType[] = [\n  \"getWifiSSID\",\n  \"getWifiPassword\",\n  \"getWifiConnectionEnabled\",\n  \"isWifiConnected\",\n  \"ipAddress\",\n  \"isWifiSecure\",\n] as const;\n\nexport const WifiEventTypes = WifiMessageTypes;\nexport type WifiEventType = (typeof WifiEventTypes)[number];\n\nexport interface WifiEventMessages {\n  isWifiAvailable: { isWifiAvailable: boolean };\n  getWifiSSID: { wifiSSID: string };\n  getWifiPassword: { wifiPassword: string };\n  getEnableWifiConnection: { wifiConnectionEnabled: boolean };\n  isWifiConnected: { isWifiConnected: boolean };\n  ipAddress: { ipAddress?: string };\n}\n\nexport type WifiEventDispatcher = EventDispatcher<\n  Device,\n  WifiEventType,\n  WifiEventMessages\n>;\nexport type SendWifiMessageCallback = SendMessageCallback<WifiMessageType>;\n\nclass WifiManager {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendWifiMessageCallback;\n\n  eventDispatcher!: WifiEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required wifi information\");\n    const messages = RequiredWifiMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // PROPERTIES\n\n  #isWifiAvailable = false;\n  get isWifiAvailable() {\n    return this.#isWifiAvailable;\n  }\n  #updateIsWifiAvailable(updatedIsWifiAvailable: boolean) {\n    _console.assertTypeWithError(updatedIsWifiAvailable, \"boolean\");\n    this.#isWifiAvailable = updatedIsWifiAvailable;\n    _console.log({ isWifiAvailable: this.#isWifiAvailable });\n    this.#dispatchEvent(\"isWifiAvailable\", {\n      isWifiAvailable: this.#isWifiAvailable,\n    });\n  }\n\n  #assertWifiIsAvailable() {\n    _console.assertWithError(this.#isWifiAvailable, \"wifi is not available\");\n  }\n\n  // WIFI SSID\n  #wifiSSID = \"\";\n  get wifiSSID() {\n    return this.#wifiSSID;\n  }\n\n  #updateWifiSSID(updatedWifiSSID: string) {\n    _console.assertTypeWithError(updatedWifiSSID, \"string\");\n    this.#wifiSSID = updatedWifiSSID;\n    _console.log({ wifiSSID: this.#wifiSSID });\n    this.#dispatchEvent(\"getWifiSSID\", { wifiSSID: this.#wifiSSID });\n  }\n  async setWifiSSID(newWifiSSID: string) {\n    this.#assertWifiIsAvailable();\n    if (this.#wifiConnectionEnabled) {\n      _console.error(\"cannot change ssid while wifi connection is enabled\");\n      return;\n    }\n    _console.assertTypeWithError(newWifiSSID, \"string\");\n    _console.assertRangeWithError(\n      \"wifiSSID\",\n      newWifiSSID.length,\n      MinWifiSSIDLength,\n      MaxWifiSSIDLength\n    );\n\n    const setWifiSSIDData = textEncoder.encode(newWifiSSID);\n    _console.log({ setWifiSSIDData });\n\n    const promise = this.waitForEvent(\"getWifiSSID\");\n    this.sendMessage([{ type: \"setWifiSSID\", data: setWifiSSIDData.buffer }]);\n    await promise;\n  }\n\n  // WIFI PASSWORD\n  #wifiPassword = \"\";\n  get wifiPassword() {\n    return this.#wifiPassword;\n  }\n\n  #updateWifiPassword(updatedWifiPassword: string) {\n    _console.assertTypeWithError(updatedWifiPassword, \"string\");\n    this.#wifiPassword = updatedWifiPassword;\n    _console.log({ wifiPassword: this.#wifiPassword });\n    this.#dispatchEvent(\"getWifiPassword\", {\n      wifiPassword: this.#wifiPassword,\n    });\n  }\n  async setWifiPassword(newWifiPassword: string) {\n    this.#assertWifiIsAvailable();\n    if (this.#wifiConnectionEnabled) {\n      _console.error(\"cannot change password while wifi connection is enabled\");\n      return;\n    }\n    _console.assertTypeWithError(newWifiPassword, \"string\");\n    if (newWifiPassword.length > 0) {\n      _console.assertRangeWithError(\n        \"wifiPassword\",\n        newWifiPassword.length,\n        MinWifiPasswordLength,\n        MaxWifiPasswordLength\n      );\n    }\n\n    const setWifiPasswordData = textEncoder.encode(newWifiPassword);\n    _console.log({ setWifiPasswordData });\n\n    const promise = this.waitForEvent(\"getWifiPassword\");\n    this.sendMessage([\n      { type: \"setWifiPassword\", data: setWifiPasswordData.buffer },\n    ]);\n    await promise;\n  }\n\n  // ENABLE WIFI CONNECTION\n  #wifiConnectionEnabled!: boolean;\n  get wifiConnectionEnabled() {\n    return this.#wifiConnectionEnabled;\n  }\n  #updateWifiConnectionEnabled(wifiConnectionEnabled: boolean) {\n    _console.log({ wifiConnectionEnabled });\n    this.#wifiConnectionEnabled = wifiConnectionEnabled;\n    this.#dispatchEvent(\"getWifiConnectionEnabled\", {\n      wifiConnectionEnabled: wifiConnectionEnabled,\n    });\n  }\n  async setWifiConnectionEnabled(\n    newWifiConnectionEnabled: boolean,\n    sendImmediately: boolean = true\n  ) {\n    this.#assertWifiIsAvailable();\n    _console.assertTypeWithError(newWifiConnectionEnabled, \"boolean\");\n    if (this.#wifiConnectionEnabled == newWifiConnectionEnabled) {\n      _console.log(\n        `redundant wifiConnectionEnabled assignment ${newWifiConnectionEnabled}`\n      );\n      return;\n    }\n\n    const promise = this.waitForEvent(\"getWifiConnectionEnabled\");\n\n    this.sendMessage(\n      [\n        {\n          type: \"setWifiConnectionEnabled\",\n\n          data: UInt8ByteBuffer(Number(newWifiConnectionEnabled)),\n        },\n      ],\n      sendImmediately\n    );\n    await promise;\n  }\n  async toggleWifiConnection() {\n    return this.setWifiConnectionEnabled(!this.wifiConnectionEnabled);\n  }\n  async enableWifiConnection() {\n    return this.setWifiConnectionEnabled(true);\n  }\n  async disableWifiConnection() {\n    return this.setWifiConnectionEnabled(false);\n  }\n\n  // IS WIFI CONNECTED\n  #isWifiConnected = false;\n  get isWifiConnected() {\n    return this.#isWifiConnected;\n  }\n  #updateIsWifiConnected(updatedIsWifiConnected: boolean) {\n    _console.assertTypeWithError(updatedIsWifiConnected, \"boolean\");\n    this.#isWifiConnected = updatedIsWifiConnected;\n    _console.log({ isWifiConnected: this.#isWifiConnected });\n    this.#dispatchEvent(\"isWifiConnected\", {\n      isWifiConnected: this.#isWifiConnected,\n    });\n  }\n\n  // IP ADDRESS\n  #ipAddress?: string;\n  get ipAddress() {\n    return this.#ipAddress;\n  }\n\n  #updateIpAddress(updatedIpAddress?: string) {\n    this.#ipAddress = updatedIpAddress;\n    _console.log({ ipAddress: this.#ipAddress });\n    this.#dispatchEvent(\"ipAddress\", {\n      ipAddress: this.#ipAddress,\n    });\n  }\n\n  // IS WIFI SECURE\n  #isWifiSecure = false;\n  get isWifiSecure() {\n    return this.#isWifiSecure;\n  }\n  #updateIsWifiSecure(updatedIsWifiSecure: boolean) {\n    _console.assertTypeWithError(updatedIsWifiSecure, \"boolean\");\n    this.#isWifiSecure = updatedIsWifiSecure;\n    _console.log({ isWifiSecure: this.#isWifiSecure });\n    this.#dispatchEvent(\"isWifiSecure\", {\n      isWifiSecure: this.#isWifiSecure,\n    });\n  }\n\n  // MESSAGE\n  parseMessage(messageType: WifiMessageType, dataView: DataView<ArrayBuffer>) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"isWifiAvailable\":\n        const isWifiAvailable = Boolean(dataView.getUint8(0));\n        _console.log({ isWifiAvailable });\n        this.#updateIsWifiAvailable(isWifiAvailable);\n        break;\n      case \"getWifiSSID\":\n      case \"setWifiSSID\":\n        const ssid = textDecoder.decode(dataView.buffer);\n        _console.log({ ssid });\n        this.#updateWifiSSID(ssid);\n        break;\n      case \"getWifiPassword\":\n      case \"setWifiPassword\":\n        const password = textDecoder.decode(dataView.buffer);\n        _console.log({ password });\n        this.#updateWifiPassword(password);\n        break;\n      case \"getWifiConnectionEnabled\":\n      case \"setWifiConnectionEnabled\":\n        const enableWifiConnection = Boolean(dataView.getUint8(0));\n        _console.log({ enableWifiConnection });\n        this.#updateWifiConnectionEnabled(enableWifiConnection);\n        break;\n      case \"isWifiConnected\":\n        const isWifiConnected = Boolean(dataView.getUint8(0));\n        _console.log({ isWifiConnected });\n        this.#updateIsWifiConnected(isWifiConnected);\n        break;\n      case \"ipAddress\":\n        let ipAddress: string | undefined = undefined;\n        if (dataView.byteLength == 4) {\n          ipAddress = new Uint8Array(dataView.buffer.slice(0, 4)).join(\".\");\n        }\n        _console.log({ ipAddress });\n        this.#updateIpAddress(ipAddress);\n        break;\n      case \"isWifiSecure\":\n        const isWifiSecure = Boolean(dataView.getUint8(0));\n        _console.log({ isWifiSecure });\n        this.#updateIsWifiSecure(isWifiSecure);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  clear() {\n    this.#wifiSSID = \"\";\n    this.#wifiPassword = \"\";\n    this.#ipAddress = \"\";\n    this.#isWifiConnected = false;\n    this.#isWifiAvailable = false;\n  }\n}\n\nexport default WifiManager;\n","import { createConsole } from \"./Console.ts\";\nimport { DisplayColorRGB } from \"./DisplayUtils.ts\";\n\nconst _console = createConsole(\"ColorUtils\", { log: false });\n\nexport function hexToRGB(hex: string): DisplayColorRGB {\n  hex = hex.replace(/^#/, \"\");\n\n  if (hex.length == 3) {\n    hex = hex\n      .split(\"\")\n      .map((char) => char + char)\n      .join(\"\");\n  }\n\n  _console.assertWithError(\n    hex.length == 6,\n    `hex length must be 6 (got ${hex.length})`\n  );\n\n  const r = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n\n  return { r, g, b };\n}\n\nexport const blackColor: DisplayColorRGB = { r: 0, g: 0, b: 0 };\nexport function colorNameToRGB(colorName: string): DisplayColorRGB {\n  const temp = document.createElement(\"div\");\n  temp.style.color = colorName;\n  document.body.appendChild(temp);\n\n  const computedColor = getComputedStyle(temp).color;\n  document.body.removeChild(temp);\n\n  // Match \"rgb(r, g, b)\" or \"rgba(r, g, b, a)\"\n  const match = computedColor.match(/^rgba?\\((\\d+), (\\d+), (\\d+)/);\n  if (!match) return blackColor;\n\n  return {\n    r: parseInt(match[1], 10),\n    g: parseInt(match[2], 10),\n    b: parseInt(match[3], 10),\n  };\n}\n\nexport function stringToRGB(string: string): DisplayColorRGB {\n  if (string.startsWith(\"#\")) {\n    return hexToRGB(string);\n  } else {\n    return colorNameToRGB(string);\n  }\n}\n\nexport function rgbToHex({ r, g, b }: DisplayColorRGB): string {\n  const toHex = (value: number) =>\n    value.toString(16).padStart(2, \"0\").toLowerCase();\n\n  _console.assertWithError(\n    [r, g, b].every((v) => v >= 0 && v <= 255),\n    `RGB values must be between 0 and 255 (got r=${r}, g=${g}, b=${b})`\n  );\n\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n}\n\nexport function colorDistanceSq(\n  a: DisplayColorRGB,\n  b: DisplayColorRGB\n): number {\n  return (a.r - b.r) ** 2 + (a.g - b.g) ** 2 + (a.b - b.b) ** 2;\n}\n\nexport interface KMeansOptions {\n  useInputColors?: boolean; // pick nearest input or average\n  maxIterations?: number;\n}\nexport const defaultKMeansOptions: KMeansOptions = {\n  useInputColors: true,\n  maxIterations: 20,\n};\n\nexport interface KMeansResult {\n  palette: string[]; // reduced colors\n  mapping: Record<string, number>; // original -> palette index\n}\n\nexport function kMeansColors(\n  colors: string[],\n  k: number,\n  options?: KMeansOptions\n): KMeansResult {\n  _console.assertTypeWithError(k, \"number\");\n  _console.assertWithError(k > 0, `invalid k ${k}`);\n  options = { ...defaultKMeansOptions, ...options };\n  const maxIter = options.maxIterations!;\n  const useInputColors = options.useInputColors!;\n\n  // cache parsed colors\n  const colorMap = new Map<string, DisplayColorRGB>();\n  for (const c of colors) {\n    if (!colorMap.has(c)) {\n      colorMap.set(c, stringToRGB(c));\n    }\n  }\n\n  const uniqueColors = Array.from(colorMap.values());\n  const uniqueKeys = Array.from(colorMap.keys());\n\n  //_console.log({ uniqueColors, uniqueKeys });\n\n  if (uniqueColors.length <= k) {\n    const mapping: Record<string, number> = {};\n    uniqueKeys.forEach((key, idx) => (mapping[key] = idx));\n    return { palette: uniqueKeys, mapping };\n  }\n\n  // Initialize centroids\n  let centroids: DisplayColorRGB[] = uniqueColors.slice(0, k);\n\n  for (let iter = 0; iter < maxIter; iter++) {\n    const clusters: number[][] = Array.from({ length: k }, () => []);\n    //_console.log({ clusters, k });\n    uniqueColors.forEach((p, idx) => {\n      let best = 0;\n      let bestDist = Infinity;\n      centroids.forEach((c, ci) => {\n        const d = colorDistanceSq(p, c);\n        if (d < bestDist) {\n          bestDist = d;\n          best = ci;\n        }\n      });\n      clusters[best].push(idx);\n    });\n\n    centroids = clusters.map((cluster) => {\n      if (cluster.length === 0) return { ...blackColor };\n      if (useInputColors) {\n        let bestIdx = cluster[0];\n        let bestDist = Infinity;\n        cluster.forEach((idx) => {\n          const d = colorDistanceSq(uniqueColors[idx], centroids[0]);\n          if (d < bestDist) {\n            bestDist = d;\n            bestIdx = idx;\n          }\n        });\n        return uniqueColors[bestIdx];\n      } else {\n        const sum = cluster.reduce(\n          (acc, idx) => {\n            const p = uniqueColors[idx];\n            return {\n              r: acc.r + p.r,\n              g: acc.g + p.g,\n              b: acc.b + p.b,\n            } as DisplayColorRGB;\n          },\n          { ...blackColor }\n        );\n        return {\n          r: sum.r / cluster.length,\n          g: sum.g / cluster.length,\n          b: sum.b / cluster.length,\n        };\n      }\n    });\n  }\n\n  const palette = centroids.map((c) => rgbToHex(c));\n\n  // Build mapping: original color -> palette index\n  const mapping: Record<string, number> = {};\n  for (const [orig, DisplayColorRGB] of colorMap.entries()) {\n    let bestIdx = 0;\n    let bestDist = Infinity;\n    centroids.forEach((c, ci) => {\n      const d = colorDistanceSq(c, DisplayColorRGB);\n      if (d < bestDist) {\n        bestDist = d;\n        bestIdx = ci;\n      }\n    });\n    mapping[orig] = bestIdx;\n  }\n\n  return { palette, mapping };\n}\n\nexport function mapToClosestPaletteIndex(\n  colors: string[],\n  palette: string[]\n): Record<string, number> {\n  const paletteRGB: DisplayColorRGB[] = palette.map(stringToRGB);\n  const mapping: Record<string, number> = {};\n\n  for (const color of colors) {\n    const rgb = stringToRGB(color);\n    let bestIdx = 0;\n    let bestDist = Infinity;\n\n    paletteRGB.forEach((p, idx) => {\n      const d = colorDistanceSq(rgb, p);\n      if (d < bestDist) {\n        bestDist = d;\n        bestIdx = idx;\n      }\n    });\n\n    mapping[color] = bestIdx;\n  }\n\n  return mapping;\n}\n","export const DisplaySegmentCaps = [\"flat\", \"round\"] as const;\nexport type DisplaySegmentCap = (typeof DisplaySegmentCaps)[number];\n\nexport const DisplayAlignments = [\"start\", \"center\", \"end\"] as const;\nexport type DisplayAlignment = (typeof DisplayAlignments)[number];\n\nexport const DisplayAlignmentDirections = [\"horizontal\", \"vertical\"] as const;\nexport type DisplayAlignmentDirection =\n  (typeof DisplayAlignmentDirections)[number];\n\nexport const DisplayDirections = [\"right\", \"left\", \"up\", \"down\"] as const;\nexport type DisplayDirection = (typeof DisplayDirections)[number];\n\nexport type DisplayContextState = {\n  backgroundColorIndex: number;\n  fillColorIndex: number;\n  lineColorIndex: number;\n\n  ignoreFill: boolean;\n  ignoreLine: boolean;\n  fillBackground: boolean;\n\n  lineWidth: number;\n  rotation: number;\n\n  horizontalAlignment: DisplayAlignment;\n  verticalAlignment: DisplayAlignment;\n\n  segmentStartCap: DisplaySegmentCap;\n  segmentEndCap: DisplaySegmentCap;\n\n  segmentStartRadius: number;\n  segmentEndRadius: number;\n\n  cropTop: number;\n  cropRight: number;\n  cropBottom: number;\n  cropLeft: number;\n\n  rotationCropTop: number;\n  rotationCropRight: number;\n  rotationCropBottom: number;\n  rotationCropLeft: number;\n\n  bitmapColorIndices: number[];\n  bitmapScaleX: number;\n  bitmapScaleY: number;\n\n  spriteColorIndices: number[];\n  spriteScaleX: number;\n  spriteScaleY: number;\n\n  spriteSheetName?: string;\n\n  spritesLineHeight: number;\n  spritesDirection: DisplayDirection;\n  spritesLineDirection: DisplayDirection;\n  spritesSpacing: number;\n  spritesLineSpacing: number;\n  spritesAlignment: DisplayAlignment;\n  spritesLineAlignment: DisplayAlignment;\n};\nexport type DisplayContextStateKey = keyof DisplayContextState;\nexport type PartialDisplayContextState = Partial<DisplayContextState>;\n\nexport const DefaultDisplayContextState: DisplayContextState = {\n  backgroundColorIndex: 0,\n  fillColorIndex: 1,\n  lineColorIndex: 1,\n\n  ignoreFill: false,\n  ignoreLine: false,\n  fillBackground: false,\n\n  lineWidth: 0,\n  rotation: 0,\n\n  horizontalAlignment: \"center\",\n  verticalAlignment: \"center\",\n\n  segmentStartCap: \"flat\",\n  segmentEndCap: \"flat\",\n\n  segmentStartRadius: 1,\n  segmentEndRadius: 1,\n\n  cropTop: 0,\n  cropRight: 0,\n  cropBottom: 0,\n  cropLeft: 0,\n\n  rotationCropTop: 0,\n  rotationCropRight: 0,\n  rotationCropBottom: 0,\n  rotationCropLeft: 0,\n\n  bitmapColorIndices: new Array(0).fill(0),\n  bitmapScaleX: 1,\n  bitmapScaleY: 1,\n\n  spriteColorIndices: new Array(0).fill(0),\n  spriteScaleX: 1,\n  spriteScaleY: 1,\n\n  spriteSheetName: undefined,\n\n  spritesLineHeight: 0,\n\n  spritesDirection: \"right\",\n  spritesLineDirection: \"down\",\n\n  spritesSpacing: 0,\n  spritesLineSpacing: 0,\n\n  spritesAlignment: \"end\",\n  spritesLineAlignment: \"start\",\n};\n\nexport function isDirectionPositive(direction: DisplayDirection) {\n  switch (direction) {\n    case \"right\":\n    case \"down\":\n      return true;\n    case \"left\":\n    case \"up\":\n      return false;\n  }\n}\nexport function isDirectionHorizontal(direction: DisplayDirection) {\n  switch (direction) {\n    case \"right\":\n    case \"left\":\n      return true;\n    case \"down\":\n    case \"up\":\n      return false;\n  }\n}\n","export function deepEqual(obj1: any, obj2: any): boolean {\n  if (obj1 === obj2) {\n    return true;\n  }\n\n  if (\n    typeof obj1 !== \"object\" ||\n    obj1 === null ||\n    typeof obj2 !== \"object\" ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  if (keys1.length !== keys2.length) return false;\n\n  for (let key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function removeRedundancies(array: any[]) {\n  return Array.from(new Set(array));\n}\n","import { createConsole } from \"./Console.ts\";\nimport {\n  DefaultDisplayContextState,\n  DisplayContextState,\n  DisplayContextStateKey,\n  PartialDisplayContextState,\n} from \"./DisplayContextState.ts\";\nimport { deepEqual } from \"./ObjectUtils.ts\";\n\nconst _console = createConsole(\"DisplayContextStateHelper\", { log: false });\n\nclass DisplayContextStateHelper {\n  #state: DisplayContextState = Object.assign({}, DefaultDisplayContextState);\n  get state() {\n    return this.#state;\n  }\n\n  get isSegmentUniform() {\n    return (\n      this.state.segmentStartRadius == this.state.segmentEndRadius &&\n      this.state.segmentStartCap == this.state.segmentEndCap\n    );\n  }\n\n  diff(other: PartialDisplayContextState) {\n    let differences: DisplayContextStateKey[] = [];\n    const keys = Object.keys(other) as DisplayContextStateKey[];\n    keys.forEach((key) => {\n      const value = other[key]!;\n\n      if (!deepEqual(this.#state[key], value)) {\n        differences.push(key);\n      }\n    });\n    _console.log(\"diff\", other, differences);\n    return differences;\n  }\n  update(newState: PartialDisplayContextState) {\n    let differences = this.diff(newState);\n    if (differences.length == 0) {\n      _console.log(\"redundant contextState\", newState);\n    } else {\n      _console.log(\"found contextState differences\", newState);\n    }\n    differences.forEach((key) => {\n      const value = newState[key]!;\n      // @ts-expect-error\n      this.#state[key] = value;\n    });\n    return differences;\n  }\n  reset() {\n    Object.assign(this.#state, DefaultDisplayContextState);\n  }\n}\n\nexport default DisplayContextStateHelper;\n","import {\n  DisplayBezierCurve,\n  DisplayBezierCurveType,\n  DisplayBrightness,\n  DisplayBrightnesses,\n  DisplayPixelDepth,\n  DisplayPixelDepths,\n  DisplayPointDataType,\n  DisplayPointDataTypes,\n  displayPointDataTypeToRange,\n  displayPointDataTypeToSize,\n  DisplayWireframe,\n  DisplayWireframeEdge,\n} from \"../DisplayManager.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { DisplayContextCommandType } from \"./DisplayContextCommand.ts\";\nimport {\n  DisplayAlignment,\n  DisplayAlignmentDirection,\n  DisplayAlignmentDirections,\n  DisplayAlignments,\n  DisplayContextStateKey,\n  DisplayDirection,\n  DisplayDirections,\n  DisplaySegmentCap,\n  DisplaySegmentCaps,\n} from \"./DisplayContextState.ts\";\nimport {\n  getVector2Distance,\n  Int16Max,\n  Uint16Max,\n  Vector2,\n} from \"./MathUtils.ts\";\nimport RangeHelper from \"./RangeHelper.ts\";\n\nconst _console = createConsole(\"DisplayUtils\", { log: false });\n\nexport function formatRotation(\n  rotation: number,\n  isRadians?: boolean,\n  isSigned?: boolean\n) {\n  if (isRadians) {\n    const rotationRad = rotation;\n    _console.log({ rotationRad });\n    rotation %= 2 * Math.PI;\n    rotation /= 2 * Math.PI;\n  } else {\n    const rotationDeg = rotation;\n    _console.log({ rotationDeg });\n    rotation %= 360;\n    rotation /= 360;\n  }\n  if (isSigned) {\n    rotation *= Int16Max;\n  } else {\n    rotation *= Uint16Max;\n  }\n  rotation = Math.floor(rotation);\n  _console.log({ formattedRotation: rotation });\n  return rotation;\n}\n\nexport function roundToStep(value: number, step: number) {\n  const roundedValue = Math.round(value / step) * step;\n  //_console.log(value, step, roundedValue);\n  return roundedValue;\n}\n\nexport const minDisplayScale = -50;\nexport const maxDisplayScale = 50;\nexport const displayScaleStep = 0.002;\nexport function formatScale(bitmapScale: number) {\n  bitmapScale /= displayScaleStep;\n  //_console.log({ formattedBitmapScale: bitmapScale });\n  return bitmapScale;\n}\nexport function roundScale(bitmapScale: number) {\n  return roundToStep(bitmapScale, displayScaleStep);\n}\n\nexport function assertValidSegmentCap(segmentCap: DisplaySegmentCap) {\n  _console.assertEnumWithError(segmentCap, DisplaySegmentCaps);\n}\n\nexport function assertValidDisplayBrightness(\n  displayBrightness: DisplayBrightness\n) {\n  _console.assertEnumWithError(displayBrightness, DisplayBrightnesses);\n}\n\nexport function assertValidColorValue(name: string, value: number) {\n  _console.assertRangeWithError(name, value, 0, 255);\n}\nexport function assertValidColor(color: DisplayColorRGB) {\n  assertValidColorValue(\"red\", color.r);\n  assertValidColorValue(\"green\", color.g);\n  assertValidColorValue(\"blue\", color.b);\n}\n\nexport function assertValidOpacity(value: number) {\n  _console.assertRangeWithError(\"opacity\", value, 0, 1);\n}\n\nexport const DisplayCropDirections = [\n  \"top\",\n  \"right\",\n  \"bottom\",\n  \"left\",\n] as const;\nexport type DisplayCropDirection = (typeof DisplayCropDirections)[number];\n\nexport const DisplayContextCropStateKeys = [\n  \"cropTop\",\n  \"cropRight\",\n  \"cropBottom\",\n  \"cropLeft\",\n] as const satisfies readonly DisplayContextStateKey[];\nexport type DisplayContextCropStateKey =\n  (typeof DisplayContextCropStateKeys)[number];\n\nexport const DisplayCropDirectionToStateKey: Record<\n  DisplayCropDirection,\n  DisplayContextCropStateKey\n> = {\n  top: \"cropTop\",\n  right: \"cropRight\",\n  bottom: \"cropBottom\",\n  left: \"cropLeft\",\n};\n\nexport const DisplayContextCropCommandTypes = [\n  \"setCropTop\",\n  \"setCropRight\",\n  \"setCropBottom\",\n  \"setCropLeft\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type DisplayContextCropCommandType =\n  (typeof DisplayContextCropCommandTypes)[number];\n\nexport const DisplayCropDirectionToCommandType: Record<\n  DisplayCropDirection,\n  DisplayContextCropCommandType\n> = {\n  top: \"setCropTop\",\n  right: \"setCropRight\",\n  bottom: \"setCropBottom\",\n  left: \"setCropLeft\",\n};\n\nexport const DisplayContextRotationCropStateKeys = [\n  \"rotationCropTop\",\n  \"rotationCropRight\",\n  \"rotationCropBottom\",\n  \"rotationCropLeft\",\n] as const satisfies readonly DisplayContextStateKey[];\nexport type DisplayContextRotationCropStateKey =\n  (typeof DisplayContextRotationCropStateKeys)[number];\n\nexport const DisplayRotationCropDirectionToStateKey: Record<\n  DisplayCropDirection,\n  DisplayContextRotationCropStateKey\n> = {\n  top: \"rotationCropTop\",\n  right: \"rotationCropRight\",\n  bottom: \"rotationCropBottom\",\n  left: \"rotationCropLeft\",\n};\n\nexport const DisplayContextRotationCropCommandTypes = [\n  \"setRotationCropTop\",\n  \"setRotationCropRight\",\n  \"setRotationCropBottom\",\n  \"setRotationCropLeft\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type DisplayContextRotationCropCommandType =\n  (typeof DisplayContextRotationCropCommandTypes)[number];\n\nexport const DisplayRotationCropDirectionToCommandType: Record<\n  DisplayCropDirection,\n  DisplayContextRotationCropCommandType\n> = {\n  top: \"setRotationCropTop\",\n  right: \"setRotationCropRight\",\n  bottom: \"setRotationCropBottom\",\n  left: \"setRotationCropLeft\",\n};\n\nexport const DisplayContextAlignmentCommandTypes = [\n  \"setVerticalAlignment\",\n  \"setHorizontalAlignment\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type DisplayContextAlignmentCommandType =\n  (typeof DisplayContextAlignmentCommandTypes)[number];\nexport const DisplayAlignmentDirectionToCommandType: Record<\n  DisplayAlignmentDirection,\n  DisplayContextAlignmentCommandType\n> = {\n  horizontal: \"setHorizontalAlignment\",\n  vertical: \"setVerticalAlignment\",\n};\n\nexport const DisplayContextAlignmentStateKeys = [\n  \"verticalAlignment\",\n  \"horizontalAlignment\",\n] as const satisfies readonly DisplayContextStateKey[];\nexport type DisplayContextAlignmentStateKey =\n  (typeof DisplayContextAlignmentStateKeys)[number];\n\nexport const DisplayAlignmentDirectionToStateKey: Record<\n  DisplayAlignmentDirection,\n  DisplayContextAlignmentStateKey\n> = {\n  horizontal: \"horizontalAlignment\",\n  vertical: \"verticalAlignment\",\n};\n\nexport function pixelDepthToNumberOfColors(pixelDepth: DisplayPixelDepth) {\n  return 2 ** Number(pixelDepth);\n}\nexport function pixelDepthToPixelsPerByte(pixelDepth: DisplayPixelDepth) {\n  return 8 / Number(pixelDepth);\n}\nexport function pixelDepthToPixelBitWidth(pixelDepth: DisplayPixelDepth) {\n  return Number(pixelDepth);\n}\nexport function numberOfColorsToPixelDepth(numberOfColors: number) {\n  return DisplayPixelDepths.find(\n    (pixelDepth) => numberOfColors <= pixelDepthToNumberOfColors(pixelDepth)\n  );\n}\n\nexport const DisplayScaleDirections = [\"x\", \"y\", \"all\"] as const;\nexport type DisplayScaleDirection = (typeof DisplayScaleDirections)[number];\n\nexport const DisplayBitmapScaleDirectionToCommandType: Record<\n  DisplayScaleDirection,\n  DisplayContextCommandType\n> = {\n  x: \"setBitmapScaleX\",\n  y: \"setBitmapScaleY\",\n  all: \"setBitmapScale\",\n};\n\nexport const DisplaySpriteScaleDirectionToCommandType: Record<\n  DisplayScaleDirection,\n  DisplayContextCommandType\n> = {\n  x: \"setSpriteScaleX\",\n  y: \"setSpriteScaleY\",\n  all: \"setSpriteScale\",\n};\n\nexport type DisplayColorRGB = {\n  r: number;\n  g: number;\n  b: number;\n};\nexport type DisplayColorYCbCr = {\n  y: number;\n  cb: number;\n  cr: number;\n};\n\nexport function assertValidAlignment(alignment: DisplayAlignment) {\n  _console.assertEnumWithError(alignment, DisplayAlignments);\n}\n\nexport function assertValidDirection(direction: DisplayDirection) {\n  _console.assertEnumWithError(direction, DisplayDirections);\n}\n\nexport function assertValidAlignmentDirection(\n  direction: DisplayAlignmentDirection\n) {\n  _console.assertEnumWithError(direction, DisplayAlignmentDirections);\n}\n\nexport const displayCurveTypeToNumberOfControlPoints: Record<\n  DisplayBezierCurveType,\n  number\n> = {\n  segment: 2,\n  quadratic: 3,\n  cubic: 4,\n};\nexport const displayCurveTolerance = 2.0;\nexport const displayCurveToleranceSquared = displayCurveTolerance ** 2;\n\nexport const maxNumberOfDisplayCurvePoints = 200;\nexport function assertValidNumberOfControlPoints(\n  curveType: DisplayBezierCurveType,\n  controlPoints: Vector2[],\n  isPath = false\n) {\n  let numberOfControlPoints =\n    displayCurveTypeToNumberOfControlPoints[curveType];\n  if (isPath) {\n    numberOfControlPoints -= 1;\n  }\n  _console.assertWithError(\n    controlPoints.length == numberOfControlPoints,\n    `invalid number of control points ${controlPoints.length}, expected ${numberOfControlPoints}`\n  );\n}\nexport function assertValidPathNumberOfControlPoints(\n  curveType: DisplayBezierCurveType,\n  controlPoints: Vector2[]\n) {\n  const numberOfControlPoints =\n    displayCurveTypeToNumberOfControlPoints[curveType];\n  _console.assertWithError(\n    (controlPoints.length - 1) % (numberOfControlPoints - 1) == 0,\n    `invalid number of path control points ${controlPoints.length} for path \"${curveType}\"`\n  );\n}\n\nexport function assertValidPath(curves: DisplayBezierCurve[]) {\n  curves.forEach((curve, index) => {\n    const { type, controlPoints } = curve;\n    assertValidNumberOfControlPoints(type, controlPoints, index > 0);\n  });\n}\n\nexport function assertValidWireframe({ points, edges }: DisplayWireframe) {\n  _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n  _console.assertRangeWithError(\"numberOfEdges\", edges.length, 1, 255);\n\n  edges.forEach((edge, index) => {\n    _console.assertRangeWithError(\n      `edgeStartIndex.${index}`,\n      edge.startIndex,\n      0,\n      points.length\n    );\n    _console.assertRangeWithError(\n      `edgeEndIndex.${index}`,\n      edge.endIndex,\n      0,\n      points.length\n    );\n  });\n}\nexport function isWireframePolygon({\n  points,\n  edges,\n}: DisplayWireframe): Vector2[] | undefined {\n  _console.log(\"isWireframePolygon?\", points, edges);\n  if (points.length != edges.length) {\n    return;\n  }\n  const _edges = edges.slice();\n  let pointIndices: number[] = [];\n  for (let i = 0; i < points.length; i++) {\n    if (i == 0) {\n      const { startIndex, endIndex } = _edges.shift()!;\n      pointIndices.push(startIndex);\n      pointIndices.push(endIndex);\n    } else {\n      const startIndex = pointIndices.at(-1);\n      const edge = _edges.find(\n        (edge) => edge.startIndex == startIndex || edge.endIndex == startIndex\n      );\n      _console.log(i, \"edge\", edge);\n      if (edge) {\n        _edges.splice(_edges.indexOf(edge), 1);\n        const endIndex =\n          edge.startIndex == startIndex ? edge.endIndex : edge.startIndex;\n        if (i == points.length - 1) {\n          if (endIndex != pointIndices[0]) {\n            return;\n          }\n        } else if (pointIndices.includes(endIndex)) {\n          _console.log(\"duplicate endIndex\", endIndex);\n          return;\n        }\n        pointIndices.push(endIndex);\n      } else {\n        _console.log(\"no edge found\");\n        return;\n      }\n    }\n    _console.log(\"remaining edges\", _edges);\n  }\n  _console.log(\"pointIndices\", pointIndices);\n  const polygon = pointIndices\n    .map((pointIndex) => points[pointIndex])\n    .filter((point, index, polygon) => polygon.indexOf(point) == index);\n\n  if (polygon.length == points.length) {\n    polygon.push(polygon[0]);\n    _console.log(\"polygon\", polygon);\n    return polygon;\n  }\n}\n\nexport function mergeWireframes(a: DisplayWireframe, b: DisplayWireframe) {\n  const wireframe: DisplayWireframe = structuredClone(a);\n  const pointIndexOffset = a.points.length;\n  b.points.forEach((point) => {\n    wireframe.points.push(point);\n  });\n  b.edges.forEach(({ startIndex, endIndex }) => {\n    wireframe.edges.push({\n      startIndex: startIndex + pointIndexOffset,\n      endIndex: endIndex + pointIndexOffset,\n    });\n  });\n  return trimWireframe(wireframe);\n}\n\nexport function intersectWireframes(\n  a: DisplayWireframe,\n  b: DisplayWireframe,\n  ignoreDirection = true\n) {\n  a = trimWireframe(a);\n  b = trimWireframe(b);\n  //_console.log(\"intersectWireframes\", a, b);\n  const wireframe: DisplayWireframe = { points: [], edges: [] };\n  const pointIndices: { a: number; b: number }[] = [];\n  const aPointIndices: number[] = [];\n  const bPointIndices: number[] = [];\n  a.points.forEach((point, aPointIndex) => {\n    const bPointIndex = b.points.findIndex((_point) => {\n      const distance = getVector2Distance(point, _point);\n      return distance == 0;\n    });\n    if (bPointIndex != -1) {\n      pointIndices.push({ a: aPointIndex, b: bPointIndex });\n      aPointIndices.push(aPointIndex);\n      bPointIndices.push(bPointIndex);\n      wireframe.points.push(structuredClone(point));\n    }\n  });\n  a.edges.forEach((aEdge) => {\n    if (\n      !aPointIndices.includes(aEdge.startIndex) ||\n      !aPointIndices.includes(aEdge.endIndex)\n    ) {\n      return;\n    }\n    const startIndex = aPointIndices.indexOf(aEdge.startIndex);\n    const endIndex = aPointIndices.indexOf(aEdge.endIndex);\n\n    const bEdge = b.edges.find((bEdge) => {\n      if (\n        !bPointIndices.includes(bEdge.startIndex) ||\n        !bPointIndices.includes(bEdge.endIndex)\n      ) {\n        return false;\n      }\n      const bStartIndex = bPointIndices.indexOf(bEdge.startIndex);\n      const bEndIndex = bPointIndices.indexOf(bEdge.endIndex);\n      if (ignoreDirection) {\n        return (\n          (startIndex == bStartIndex && endIndex == bEndIndex) ||\n          (startIndex == bEndIndex && endIndex == bStartIndex)\n        );\n      } else {\n        return startIndex == bStartIndex && endIndex == bEndIndex;\n      }\n    });\n\n    if (!bEdge) {\n      return;\n    }\n\n    wireframe.edges.push({\n      startIndex,\n      endIndex,\n    });\n  });\n  //_console.log(\"intersectedWireframe\", wireframe);\n  return wireframe;\n}\n\nexport function trimWireframe(wireframe: DisplayWireframe): DisplayWireframe {\n  _console.log(\"trimming wireframe\", wireframe);\n  const { points, edges } = wireframe;\n  const trimmedPoints: Vector2[] = [];\n  const trimmedEdges: DisplayWireframeEdge[] = [];\n  edges.forEach((edge) => {\n    const { startIndex, endIndex } = edge;\n    let startPoint = points[startIndex];\n    let endPoint = points[endIndex];\n\n    let trimmedStartIndex = trimmedPoints.findIndex(\n      ({ x, y }) => startPoint.x == x && startPoint.y == y\n    );\n    if (trimmedStartIndex == -1) {\n      //_console.log(\"adding startPoint\", startPoint);\n      trimmedPoints.push(startPoint);\n      trimmedStartIndex = trimmedPoints.length - 1;\n    }\n\n    let trimmedEndIndex = trimmedPoints.findIndex(\n      ({ x, y }) => endPoint.x == x && endPoint.y == y\n    );\n    if (trimmedEndIndex == -1) {\n      //_console.log(\"adding endPoint\", endPoint);\n      trimmedPoints.push(endPoint);\n      trimmedEndIndex = trimmedPoints.length - 1;\n    }\n\n    const trimmedEdge: DisplayWireframeEdge = {\n      startIndex: trimmedStartIndex,\n      endIndex: trimmedEndIndex,\n    };\n    let trimmedEdgeIndex = trimmedEdges.findIndex(\n      ({ startIndex, endIndex }) =>\n        startIndex == trimmedEdge.startIndex && endIndex == trimmedEdge.endIndex\n    );\n    if (trimmedEdgeIndex == -1) {\n      //_console.log(\"adding edge\", trimmedEdge);\n      trimmedEdges.push(trimmedEdge);\n      trimmedEdgeIndex = trimmedEdges.length - 1;\n    }\n  });\n  _console.log(\"trimmedWireframe\", trimmedPoints, trimmedEdges);\n  return { points: trimmedPoints, edges: trimmedEdges };\n}\n\nexport function getPointDataType(points: Vector2[]): DisplayPointDataType {\n  const range = new RangeHelper();\n  points.forEach(({ x, y }) => {\n    range.update(x);\n    range.update(y);\n  });\n  const pointDataType = DisplayPointDataTypes.find((pointDataType) => {\n    const { min, max } = displayPointDataTypeToRange[pointDataType];\n    return range.min >= min && range.max <= max;\n  })!;\n  _console.log(\"pointDataType\", pointDataType, points);\n  return pointDataType!;\n}\nexport function serializePoints(\n  points: Vector2[],\n  pointDataType?: DisplayPointDataType,\n  isPath = false\n) {\n  pointDataType = pointDataType || getPointDataType(points);\n  _console.assertEnumWithError(pointDataType, DisplayPointDataTypes);\n  const pointDataSize = displayPointDataTypeToSize[pointDataType];\n  let dataViewLength = points.length * pointDataSize;\n  if (!isPath) {\n    dataViewLength += 2; // pointDataType + points.length\n  }\n  const dataView = new DataView(new ArrayBuffer(dataViewLength));\n  _console.log(\n    `serializing ${points.length} ${pointDataType} points (${dataView.byteLength} bytes)...`\n  );\n  let offset = 0;\n  if (!isPath) {\n    dataView.setUint8(offset++, DisplayPointDataTypes.indexOf(pointDataType));\n    dataView.setUint8(offset++, points.length);\n  }\n  points.forEach(({ x, y }) => {\n    switch (pointDataType) {\n      case \"int8\":\n        dataView.setInt8(offset, x);\n        offset += 1;\n        dataView.setInt8(offset, y);\n        offset += 1;\n        break;\n      case \"int16\":\n        dataView.setInt16(offset, x, true);\n        offset += 2;\n        dataView.setInt16(offset, y, true);\n        offset += 2;\n        break;\n      case \"float\":\n        dataView.setFloat32(offset, x, true);\n        offset += 4;\n        dataView.setFloat32(offset, y, true);\n        offset += 4;\n        break;\n    }\n  });\n  return dataView;\n}\n","/*\n* Copyright (c) 2015, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* RgbQuant.js - an image quantization lib\n*/\n\n(function(){\n\tfunction RgbQuant(opts) {\n\t\topts = opts || {};\n\n\t\t// 1 = by global population, 2 = subregion population threshold\n\t\tthis.method = opts.method || 2;\n\t\t// desired final palette size\n\t\tthis.colors = opts.colors || 256;\n\t\t// # of highest-frequency colors to start with for palette reduction\n\t\tthis.initColors = opts.initColors || 4096;\n\t\t// color-distance threshold for initial reduction pass\n\t\tthis.initDist = opts.initDist || 0.01;\n\t\t// subsequent passes threshold\n\t\tthis.distIncr = opts.distIncr || 0.005;\n\t\t// palette grouping\n\t\tthis.hueGroups = opts.hueGroups || 10;\n\t\tthis.satGroups = opts.satGroups || 10;\n\t\tthis.lumGroups = opts.lumGroups || 10;\n\t\t// if > 0, enables hues stats and min-color retention per group\n\t\tthis.minHueCols = opts.minHueCols || 0;\n\t\t// HueStats instance\n\t\tthis.hueStats = this.minHueCols ? new HueStats(this.hueGroups, this.minHueCols) : null;\n\n\t\t// subregion partitioning box size\n\t\tthis.boxSize = opts.boxSize || [64,64];\n\t\t// number of same pixels required within box for histogram inclusion\n\t\tthis.boxPxls = opts.boxPxls || 2;\n\t\t// palette locked indicator\n\t\tthis.palLocked = false;\n\t\t// palette sort order\n//\t\tthis.sortPal = ['hue-','lum-','sat-'];\n\n\t\t// dithering/error diffusion kernel name\n\t\tthis.dithKern = opts.dithKern || null;\n\t\t// dither serpentine pattern\n\t\tthis.dithSerp = opts.dithSerp || false;\n\t\t// minimum color difference (0-1) needed to dither\n\t\tthis.dithDelta = opts.dithDelta || 0;\n\n\t\t// accumulated histogram\n\t\tthis.histogram = {};\n\t\t// palette - rgb triplets\n\t\tthis.idxrgb = opts.palette ? opts.palette.slice(0) : [];\n\t\t// palette - int32 vals\n\t\tthis.idxi32 = [];\n\t\t// reverse lookup {i32:idx}\n\t\tthis.i32idx = {};\n\t\t// {i32:rgb}\n\t\tthis.i32rgb = {};\n\t\t// enable color caching (also incurs overhead of cache misses and cache building)\n\t\tthis.useCache = opts.useCache !== false;\n\t\t// min color occurance count needed to qualify for caching\n\t\tthis.cacheFreq = opts.cacheFreq || 10;\n\t\t// allows pre-defined palettes to be re-indexed (enabling palette compacting and sorting)\n\t\tthis.reIndex = opts.reIndex || this.idxrgb.length == 0;\n\t\t// selection of color-distance equation\n\t\tthis.colorDist = opts.colorDist == \"manhattan\" ? distManhattan : distEuclidean;\n\n\t\t// if pre-defined palette, build lookups\n\t\tif (this.idxrgb.length > 0) {\n\t\t\tvar self = this;\n\t\t\tthis.idxrgb.forEach(function(rgb, i) {\n\t\t\t\tvar i32 = (\n\t\t\t\t\t(255    << 24) |\t// alpha\n\t\t\t\t\t(rgb[2] << 16) |\t// blue\n\t\t\t\t\t(rgb[1] <<  8) |\t// green\n\t\t\t\t\t rgb[0]\t\t\t\t// red\n\t\t\t\t) >>> 0;\n\n\t\t\t\tself.idxi32[i]\t\t= i32;\n\t\t\t\tself.i32idx[i32]\t= i;\n\t\t\t\tself.i32rgb[i32]\t= rgb;\n\t\t\t});\n\t\t}\n\t}\n\n\t// gathers histogram info\n\tRgbQuant.prototype.sample = function sample(img, width) {\n\t\tif (this.palLocked)\n\t\t\tthrow \"Cannot sample additional images, palette already assembled.\";\n\n\t\tvar data = getImageData(img, width);\n\n\t\tswitch (this.method) {\n\t\t\tcase 1: this.colorStats1D(data.buf32); break;\n\t\t\tcase 2: this.colorStats2D(data.buf32, data.width); break;\n\t\t}\n\t};\n\n\t// image quantizer\n\t// todo: memoize colors here also\n\t// @retType: 1 - Uint8Array (default), 2 - Indexed array, 3 - Match @img type (unimplemented, todo)\n\tRgbQuant.prototype.reduce = function reduce(img, retType, dithKern, dithSerp) {\n\t\tif (!this.palLocked)\n\t\t\tthis.buildPal();\n\n\t\tdithKern = dithKern || this.dithKern;\n\t\tdithSerp = typeof dithSerp != \"undefined\" ? dithSerp : this.dithSerp;\n\n\t\tretType = retType || 1;\n\n\t\t// reduce w/dither\n\t\tif (dithKern)\n\t\t\tvar out32 = this.dither(img, dithKern, dithSerp);\n\t\telse {\n\t\t\tvar data = getImageData(img),\n\t\t\t\tbuf32 = data.buf32,\n\t\t\t\tlen = buf32.length,\n\t\t\t\tout32 = new Uint32Array(len);\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar i32 = buf32[i];\n\t\t\t\tout32[i] = this.nearestColor(i32);\n\t\t\t}\n\t\t}\n\n\t\tif (retType == 1)\n\t\t\treturn new Uint8Array(out32.buffer);\n\n\t\tif (retType == 2) {\n\t\t\tvar out = [],\n\t\t\t\tlen = out32.length;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar i32 = out32[i];\n\t\t\t\tout[i] = this.i32idx[i32];\n\t\t\t}\n\n\t\t\treturn out;\n\t\t}\n\t};\n\n\t// adapted from http://jsbin.com/iXofIji/2/edit by PAEz\n\tRgbQuant.prototype.dither = function(img, kernel, serpentine) {\n\t\t// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\n\t\tvar kernels = {\n\t\t\tFloydSteinberg: [\n\t\t\t\t[7 / 16, 1, 0],\n\t\t\t\t[3 / 16, -1, 1],\n\t\t\t\t[5 / 16, 0, 1],\n\t\t\t\t[1 / 16, 1, 1]\n\t\t\t],\n\t\t\tFalseFloydSteinberg: [\n\t\t\t\t[3 / 8, 1, 0],\n\t\t\t\t[3 / 8, 0, 1],\n\t\t\t\t[2 / 8, 1, 1]\n\t\t\t],\n\t\t\tStucki: [\n\t\t\t\t[8 / 42, 1, 0],\n\t\t\t\t[4 / 42, 2, 0],\n\t\t\t\t[2 / 42, -2, 1],\n\t\t\t\t[4 / 42, -1, 1],\n\t\t\t\t[8 / 42, 0, 1],\n\t\t\t\t[4 / 42, 1, 1],\n\t\t\t\t[2 / 42, 2, 1],\n\t\t\t\t[1 / 42, -2, 2],\n\t\t\t\t[2 / 42, -1, 2],\n\t\t\t\t[4 / 42, 0, 2],\n\t\t\t\t[2 / 42, 1, 2],\n\t\t\t\t[1 / 42, 2, 2]\n\t\t\t],\n\t\t\tAtkinson: [\n\t\t\t\t[1 / 8, 1, 0],\n\t\t\t\t[1 / 8, 2, 0],\n\t\t\t\t[1 / 8, -1, 1],\n\t\t\t\t[1 / 8, 0, 1],\n\t\t\t\t[1 / 8, 1, 1],\n\t\t\t\t[1 / 8, 0, 2]\n\t\t\t],\n\t\t\tJarvis: [\t\t\t// Jarvis, Judice, and Ninke / JJN?\n\t\t\t\t[7 / 48, 1, 0],\n\t\t\t\t[5 / 48, 2, 0],\n\t\t\t\t[3 / 48, -2, 1],\n\t\t\t\t[5 / 48, -1, 1],\n\t\t\t\t[7 / 48, 0, 1],\n\t\t\t\t[5 / 48, 1, 1],\n\t\t\t\t[3 / 48, 2, 1],\n\t\t\t\t[1 / 48, -2, 2],\n\t\t\t\t[3 / 48, -1, 2],\n\t\t\t\t[5 / 48, 0, 2],\n\t\t\t\t[3 / 48, 1, 2],\n\t\t\t\t[1 / 48, 2, 2]\n\t\t\t],\n\t\t\tBurkes: [\n\t\t\t\t[8 / 32, 1, 0],\n\t\t\t\t[4 / 32, 2, 0],\n\t\t\t\t[2 / 32, -2, 1],\n\t\t\t\t[4 / 32, -1, 1],\n\t\t\t\t[8 / 32, 0, 1],\n\t\t\t\t[4 / 32, 1, 1],\n\t\t\t\t[2 / 32, 2, 1],\n\t\t\t],\n\t\t\tSierra: [\n\t\t\t\t[5 / 32, 1, 0],\n\t\t\t\t[3 / 32, 2, 0],\n\t\t\t\t[2 / 32, -2, 1],\n\t\t\t\t[4 / 32, -1, 1],\n\t\t\t\t[5 / 32, 0, 1],\n\t\t\t\t[4 / 32, 1, 1],\n\t\t\t\t[2 / 32, 2, 1],\n\t\t\t\t[2 / 32, -1, 2],\n\t\t\t\t[3 / 32, 0, 2],\n\t\t\t\t[2 / 32, 1, 2],\n\t\t\t],\n\t\t\tTwoSierra: [\n\t\t\t\t[4 / 16, 1, 0],\n\t\t\t\t[3 / 16, 2, 0],\n\t\t\t\t[1 / 16, -2, 1],\n\t\t\t\t[2 / 16, -1, 1],\n\t\t\t\t[3 / 16, 0, 1],\n\t\t\t\t[2 / 16, 1, 1],\n\t\t\t\t[1 / 16, 2, 1],\n\t\t\t],\n\t\t\tSierraLite: [\n\t\t\t\t[2 / 4, 1, 0],\n\t\t\t\t[1 / 4, -1, 1],\n\t\t\t\t[1 / 4, 0, 1],\n\t\t\t],\n\t\t};\n\n\t\tif (!kernel || !kernels[kernel]) {\n\t\t\tthrow 'Unknown dithering kernel: ' + kernel;\n\t\t}\n\n\t\tvar ds = kernels[kernel];\n\n\t\tvar data = getImageData(img),\n//\t\t\tbuf8 = data.buf8,\n\t\t\tbuf32 = data.buf32,\n\t\t\twidth = data.width,\n\t\t\theight = data.height,\n\t\t\tlen = buf32.length;\n\n\t\tvar dir = serpentine ? -1 : 1;\n\n\t\tfor (var y = 0; y < height; y++) {\n\t\t\tif (serpentine)\n\t\t\t\tdir = dir * -1;\n\n\t\t\tvar lni = y * width;\n\n\t\t\tfor (var x = (dir == 1 ? 0 : width - 1), xend = (dir == 1 ? width : 0); x !== xend; x += dir) {\n\t\t\t\t// Image pixel\n\t\t\t\tvar idx = lni + x,\n\t\t\t\t\ti32 = buf32[idx],\n\t\t\t\t\tr1 = (i32 & 0xff),\n\t\t\t\t\tg1 = (i32 & 0xff00) >> 8,\n\t\t\t\t\tb1 = (i32 & 0xff0000) >> 16;\n\n\t\t\t\t// Reduced pixel\n\t\t\t\tvar i32x = this.nearestColor(i32),\n\t\t\t\t\tr2 = (i32x & 0xff),\n\t\t\t\t\tg2 = (i32x & 0xff00) >> 8,\n\t\t\t\t\tb2 = (i32x & 0xff0000) >> 16;\n\n\t\t\t\tbuf32[idx] =\n\t\t\t\t\t(255 << 24)\t|\t// alpha\n\t\t\t\t\t(b2  << 16)\t|\t// blue\n\t\t\t\t\t(g2  <<  8)\t|\t// green\n\t\t\t\t\t r2;\n\n\t\t\t\t// dithering strength\n\t\t\t\tif (this.dithDelta) {\n\t\t\t\t\tvar dist = this.colorDist([r1, g1, b1], [r2, g2, b2]);\n\t\t\t\t\tif (dist < this.dithDelta)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Component distance\n\t\t\t\tvar er = r1 - r2,\n\t\t\t\t\teg = g1 - g2,\n\t\t\t\t\teb = b1 - b2;\n\n\t\t\t\tfor (var i = (dir == 1 ? 0 : ds.length - 1), end = (dir == 1 ? ds.length : 0); i !== end; i += dir) {\n\t\t\t\t\tvar x1 = ds[i][1] * dir,\n\t\t\t\t\t\ty1 = ds[i][2];\n\n\t\t\t\t\tvar lni2 = y1 * width;\n\n\t\t\t\t\tif (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n\t\t\t\t\t\tvar d = ds[i][0];\n\t\t\t\t\t\tvar idx2 = idx + (lni2 + x1);\n\n\t\t\t\t\t\tvar r3 = (buf32[idx2] & 0xff),\n\t\t\t\t\t\t\tg3 = (buf32[idx2] & 0xff00) >> 8,\n\t\t\t\t\t\t\tb3 = (buf32[idx2] & 0xff0000) >> 16;\n\n\t\t\t\t\t\tvar r4 = Math.max(0, Math.min(255, r3 + er * d)),\n\t\t\t\t\t\t\tg4 = Math.max(0, Math.min(255, g3 + eg * d)),\n\t\t\t\t\t\t\tb4 = Math.max(0, Math.min(255, b3 + eb * d));\n\n\t\t\t\t\t\tbuf32[idx2] =\n\t\t\t\t\t\t\t(255 << 24)\t|\t// alpha\n\t\t\t\t\t\t\t(b4  << 16)\t|\t// blue\n\t\t\t\t\t\t\t(g4  <<  8)\t|\t// green\n\t\t\t\t\t\t\t r4;\t\t\t// red\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn buf32;\n\t};\n\n\t// reduces histogram to palette, remaps & memoizes reduced colors\n\tRgbQuant.prototype.buildPal = function buildPal(noSort) {\n\t\tif (this.palLocked || this.idxrgb.length > 0 && this.idxrgb.length <= this.colors) return;\n\n\t\tvar histG  = this.histogram,\n\t\t\tsorted = sortedHashKeys(histG, true);\n\n\t\tif (sorted.length == 0)\n\t\t\tthrow \"Nothing has been sampled, palette cannot be built.\";\n\n\t\tswitch (this.method) {\n\t\t\tcase 1:\n\t\t\t\tvar cols = this.initColors,\n\t\t\t\t\tlast = sorted[cols - 1],\n\t\t\t\t\tfreq = histG[last];\n\n\t\t\t\tvar idxi32 = sorted.slice(0, cols);\n\n\t\t\t\t// add any cut off colors with same freq as last\n\t\t\t\tvar pos = cols, len = sorted.length;\n\t\t\t\twhile (pos < len && histG[sorted[pos]] == freq)\n\t\t\t\t\tidxi32.push(sorted[pos++]);\n\n\t\t\t\t// inject min huegroup colors\n\t\t\t\tif (this.hueStats)\n\t\t\t\t\tthis.hueStats.inject(idxi32);\n\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tvar idxi32 = sorted;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// int32-ify values\n\t\tidxi32 = idxi32.map(function(v){return +v;});\n\n\t\tthis.reducePal(idxi32);\n\n\t\tif (!noSort && this.reIndex)\n\t\t\tthis.sortPal();\n\n\t\t// build cache of top histogram colors\n\t\tif (this.useCache)\n\t\t\tthis.cacheHistogram(idxi32);\n\n\t\tthis.palLocked = true;\n\t};\n\n\tRgbQuant.prototype.palette = function palette(tuples, noSort) {\n\t\tthis.buildPal(noSort);\n\t\treturn tuples ? this.idxrgb : new Uint8Array((new Uint32Array(this.idxi32)).buffer);\n\t};\n\n\tRgbQuant.prototype.prunePal = function prunePal(keep) {\n\t\tvar i32;\n\n\t\tfor (var j = 0; j < this.idxrgb.length; j++) {\n\t\t\tif (!keep[j]) {\n\t\t\t\ti32 = this.idxi32[j];\n\t\t\t\tthis.idxrgb[j] = null;\n\t\t\t\tthis.idxi32[j] = null;\n\t\t\t\tdelete this.i32idx[i32];\n\t\t\t}\n\t\t}\n\n\t\t// compact\n\t\tif (this.reIndex) {\n\t\t\tvar idxrgb = [],\n\t\t\t\tidxi32 = [],\n\t\t\t\ti32idx = {};\n\n\t\t\tfor (var j = 0, i = 0; j < this.idxrgb.length; j++) {\n\t\t\t\tif (this.idxrgb[j]) {\n\t\t\t\t\ti32 = this.idxi32[j];\n\t\t\t\t\tidxrgb[i] = this.idxrgb[j];\n\t\t\t\t\ti32idx[i32] = i;\n\t\t\t\t\tidxi32[i] = i32;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.idxrgb = idxrgb;\n\t\t\tthis.idxi32 = idxi32;\n\t\t\tthis.i32idx = i32idx;\n\t\t}\n\t};\n\n\t// reduces similar colors from an importance-sorted Uint32 rgba array\n\tRgbQuant.prototype.reducePal = function reducePal(idxi32) {\n\t\t// if pre-defined palette's length exceeds target\n\t\tif (this.idxrgb.length > this.colors) {\n\t\t\t// quantize histogram to existing palette\n\t\t\tvar len = idxi32.length, keep = {}, uniques = 0, idx, pruned = false;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\t// palette length reached, unset all remaining colors (sparse palette)\n\t\t\t\tif (uniques == this.colors && !pruned) {\n\t\t\t\t\tthis.prunePal(keep);\n\t\t\t\t\tpruned = true;\n\t\t\t\t}\n\n\t\t\t\tidx = this.nearestIndex(idxi32[i]);\n\n\t\t\t\tif (uniques < this.colors && !keep[idx]) {\n\t\t\t\t\tkeep[idx] = true;\n\t\t\t\t\tuniques++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pruned) {\n\t\t\t\tthis.prunePal(keep);\n\t\t\t\tpruned = true;\n\t\t\t}\n\t\t}\n\t\t// reduce histogram to create initial palette\n\t\telse {\n\t\t\t// build full rgb palette\n\t\t\tvar idxrgb = idxi32.map(function(i32) {\n\t\t\t\treturn [\n\t\t\t\t\t(i32 & 0xff),\n\t\t\t\t\t(i32 & 0xff00) >> 8,\n\t\t\t\t\t(i32 & 0xff0000) >> 16,\n\t\t\t\t];\n\t\t\t});\n\n\t\t\tvar len = idxrgb.length,\n\t\t\t\tpalLen = len,\n\t\t\t\tthold = this.initDist;\n\n\t\t\t// palette already at or below desired length\n\t\t\tif (palLen > this.colors) {\n\t\t\t\twhile (palLen > this.colors) {\n\t\t\t\t\tvar memDist = [];\n\n\t\t\t\t\t// iterate palette\n\t\t\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\t\t\tvar pxi = idxrgb[i], i32i = idxi32[i];\n\t\t\t\t\t\tif (!pxi) continue;\n\n\t\t\t\t\t\tfor (var j = i + 1; j < len; j++) {\n\t\t\t\t\t\t\tvar pxj = idxrgb[j], i32j = idxi32[j];\n\t\t\t\t\t\t\tif (!pxj) continue;\n\n\t\t\t\t\t\t\tvar dist = this.colorDist(pxi, pxj);\n\n\t\t\t\t\t\t\tif (dist < thold) {\n\t\t\t\t\t\t\t\t// store index,rgb,dist\n\t\t\t\t\t\t\t\tmemDist.push([j, pxj, i32j, dist]);\n\n\t\t\t\t\t\t\t\t// kill squashed value\n\t\t\t\t\t\t\t\tdelete(idxrgb[j]);\n\t\t\t\t\t\t\t\tpalLen--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// palette reduction pass\n\t\t\t\t\t// console.log(\"palette length: \" + palLen);\n\n\t\t\t\t\t// if palette is still much larger than target, increment by larger initDist\n\t\t\t\t\tthold += (palLen > this.colors * 3) ? this.initDist : this.distIncr;\n\t\t\t\t}\n\n\t\t\t\t// if palette is over-reduced, re-add removed colors with largest distances from last round\n\t\t\t\tif (palLen < this.colors) {\n\t\t\t\t\t// sort descending\n\t\t\t\t\tsort.call(memDist, function(a,b) {\n\t\t\t\t\t\treturn b[3] - a[3];\n\t\t\t\t\t});\n\n\t\t\t\t\tvar k = 0;\n\t\t\t\t\twhile (palLen < this.colors) {\n\t\t\t\t\t\t// re-inject rgb into final palette\n\t\t\t\t\t\tidxrgb[memDist[k][0]] = memDist[k][1];\n\n\t\t\t\t\t\tpalLen++;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar len = idxrgb.length;\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tif (!idxrgb[i]) continue;\n\n\t\t\t\tthis.idxrgb.push(idxrgb[i]);\n\t\t\t\tthis.idxi32.push(idxi32[i]);\n\n\t\t\t\tthis.i32idx[idxi32[i]] = this.idxi32.length - 1;\n\t\t\t\tthis.i32rgb[idxi32[i]] = idxrgb[i];\n\t\t\t}\n\t\t}\n\t};\n\n\t// global top-population\n\tRgbQuant.prototype.colorStats1D = function colorStats1D(buf32) {\n\t\tvar histG = this.histogram,\n\t\t\tnum = 0, col,\n\t\t\tlen = buf32.length;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tcol = buf32[i];\n\n\t\t\t// skip transparent\n\t\t\tif ((col & 0xff000000) >> 24 == 0) continue;\n\n\t\t\t// collect hue stats\n\t\t\tif (this.hueStats)\n\t\t\t\tthis.hueStats.check(col);\n\n\t\t\tif (col in histG)\n\t\t\t\thistG[col]++;\n\t\t\telse\n\t\t\t\thistG[col] = 1;\n\t\t}\n\t};\n\n\t// population threshold within subregions\n\t// FIXME: this can over-reduce (few/no colors same?), need a way to keep\n\t// important colors that dont ever reach local thresholds (gradients?)\n\tRgbQuant.prototype.colorStats2D = function colorStats2D(buf32, width) {\n\t\tvar boxW = this.boxSize[0],\n\t\t\tboxH = this.boxSize[1],\n\t\t\tarea = boxW * boxH,\n\t\t\tboxes = makeBoxes(width, buf32.length / width, boxW, boxH),\n\t\t\thistG = this.histogram,\n\t\t\tself = this;\n\n\t\tboxes.forEach(function(box) {\n\t\t\tvar effc = Math.max(Math.round((box.w * box.h) / area) * self.boxPxls, 2),\n\t\t\t\thistL = {}, col;\n\n\t\t\titerBox(box, width, function(i) {\n\t\t\t\tcol = buf32[i];\n\n\t\t\t\t// skip transparent\n\t\t\t\tif ((col & 0xff000000) >> 24 == 0) return;\n\n\t\t\t\t// collect hue stats\n\t\t\t\tif (self.hueStats)\n\t\t\t\t\tself.hueStats.check(col);\n\n\t\t\t\tif (col in histG)\n\t\t\t\t\thistG[col]++;\n\t\t\t\telse if (col in histL) {\n\t\t\t\t\tif (++histL[col] >= effc)\n\t\t\t\t\t\thistG[col] = histL[col];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thistL[col] = 1;\n\t\t\t});\n\t\t});\n\n\t\tif (this.hueStats)\n\t\t\tthis.hueStats.inject(histG);\n\t};\n\n\t// TODO: group very low lum and very high lum colors\n\t// TODO: pass custom sort order\n\tRgbQuant.prototype.sortPal = function sortPal() {\n\t\tvar self = this;\n\n\t\tthis.idxi32.sort(function(a,b) {\n\t\t\tvar idxA = self.i32idx[a],\n\t\t\t\tidxB = self.i32idx[b],\n\t\t\t\trgbA = self.idxrgb[idxA],\n\t\t\t\trgbB = self.idxrgb[idxB];\n\n\t\t\tvar hslA = rgb2hsl(rgbA[0],rgbA[1],rgbA[2]),\n\t\t\t\thslB = rgb2hsl(rgbB[0],rgbB[1],rgbB[2]);\n\n\t\t\t// sort all grays + whites together\n\t\t\tvar hueA = (rgbA[0] == rgbA[1] && rgbA[1] == rgbA[2]) ? -1 : hueGroup(hslA.h, self.hueGroups);\n\t\t\tvar hueB = (rgbB[0] == rgbB[1] && rgbB[1] == rgbB[2]) ? -1 : hueGroup(hslB.h, self.hueGroups);\n\n\t\t\tvar hueDiff = hueB - hueA;\n\t\t\tif (hueDiff) return -hueDiff;\n\n\t\t\tvar lumDiff = lumGroup(+hslB.l.toFixed(2)) - lumGroup(+hslA.l.toFixed(2));\n\t\t\tif (lumDiff) return -lumDiff;\n\n\t\t\tvar satDiff = satGroup(+hslB.s.toFixed(2)) - satGroup(+hslA.s.toFixed(2));\n\t\t\tif (satDiff) return -satDiff;\n\t\t});\n\n\t\t// sync idxrgb & i32idx\n\t\tthis.idxi32.forEach(function(i32, i) {\n\t\t\tself.idxrgb[i] = self.i32rgb[i32];\n\t\t\tself.i32idx[i32] = i;\n\t\t});\n\t};\n\n\t// TOTRY: use HUSL - http://boronine.com/husl/\n\tRgbQuant.prototype.nearestColor = function nearestColor(i32) {\n\t\tvar idx = this.nearestIndex(i32);\n\t\treturn idx === null ? 0 : this.idxi32[idx];\n\t};\n\n\t// TOTRY: use HUSL - http://boronine.com/husl/\n\tRgbQuant.prototype.nearestIndex = function nearestIndex(i32) {\n\t\t// alpha 0 returns null index\n\t\tif ((i32 & 0xff000000) >> 24 == 0)\n\t\t\treturn null;\n\n\t\tif (this.useCache && (\"\"+i32) in this.i32idx)\n\t\t\treturn this.i32idx[i32];\n\n\t\tvar min = 1000,\n\t\t\tidx,\n\t\t\trgb = [\n\t\t\t\t(i32 & 0xff),\n\t\t\t\t(i32 & 0xff00) >> 8,\n\t\t\t\t(i32 & 0xff0000) >> 16,\n\t\t\t],\n\t\t\tlen = this.idxrgb.length;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tif (!this.idxrgb[i]) continue;\t\t// sparse palettes\n\n\t\t\tvar dist = this.colorDist(rgb, this.idxrgb[i]);\n\n\t\t\tif (dist < min) {\n\t\t\t\tmin = dist;\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t}\n\n\t\treturn idx;\n\t};\n\n\tRgbQuant.prototype.cacheHistogram = function cacheHistogram(idxi32) {\n\t\tfor (var i = 0, i32 = idxi32[i]; i < idxi32.length && this.histogram[i32] >= this.cacheFreq; i32 = idxi32[i++])\n\t\t\tthis.i32idx[i32] = this.nearestIndex(i32);\n\t};\n\n\tfunction HueStats(numGroups, minCols) {\n\t\tthis.numGroups = numGroups;\n\t\tthis.minCols = minCols;\n\t\tthis.stats = {};\n\n\t\tfor (var i = -1; i < numGroups; i++)\n\t\t\tthis.stats[i] = {num: 0, cols: []};\n\n\t\tthis.groupsFull = 0;\n\t}\n\n\tHueStats.prototype.check = function checkHue(i32) {\n\t\tif (this.groupsFull == this.numGroups + 1)\n\t\t\tthis.check = function() {return;};\n\n\t\tvar r = (i32 & 0xff),\n\t\t\tg = (i32 & 0xff00) >> 8,\n\t\t\tb = (i32 & 0xff0000) >> 16,\n\t\t\thg = (r == g && g == b) ? -1 : hueGroup(rgb2hsl(r,g,b).h, this.numGroups),\n\t\t\tgr = this.stats[hg],\n\t\t\tmin = this.minCols;\n\n\t\tgr.num++;\n\n\t\tif (gr.num > min)\n\t\t\treturn;\n\t\tif (gr.num == min)\n\t\t\tthis.groupsFull++;\n\n\t\tif (gr.num <= min)\n\t\t\tthis.stats[hg].cols.push(i32);\n\t};\n\n\tHueStats.prototype.inject = function injectHues(histG) {\n\t\tfor (var i = -1; i < this.numGroups; i++) {\n\t\t\tif (this.stats[i].num <= this.minCols) {\n\t\t\t\tswitch (typeOf(histG)) {\n\t\t\t\t\tcase \"Array\":\n\t\t\t\t\t\tthis.stats[i].cols.forEach(function(col){\n\t\t\t\t\t\t\tif (histG.indexOf(col) == -1)\n\t\t\t\t\t\t\t\thistG.push(col);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"Object\":\n\t\t\t\t\t\tthis.stats[i].cols.forEach(function(col){\n\t\t\t\t\t\t\tif (!histG[col])\n\t\t\t\t\t\t\t\thistG[col] = 1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\thistG[col]++;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Rec. 709 (sRGB) luma coef\n\tvar Pr = .2126,\n\t\tPg = .7152,\n\t\tPb = .0722;\n\n\t// http://alienryderflex.com/hsp.html\n\tfunction rgb2lum(r,g,b) {\n\t\treturn Math.sqrt(\n\t\t\tPr * r*r +\n\t\t\tPg * g*g +\n\t\t\tPb * b*b\n\t\t);\n\t}\n\n\tvar rd = 255,\n\t\tgd = 255,\n\t\tbd = 255;\n\n\tvar euclMax = Math.sqrt(Pr*rd*rd + Pg*gd*gd + Pb*bd*bd);\n\t// perceptual Euclidean color distance\n\tfunction distEuclidean(rgb0, rgb1) {\n\t\tvar rd = rgb1[0]-rgb0[0],\n\t\t\tgd = rgb1[1]-rgb0[1],\n\t\t\tbd = rgb1[2]-rgb0[2];\n\n\t\treturn Math.sqrt(Pr*rd*rd + Pg*gd*gd + Pb*bd*bd) / euclMax;\n\t}\n\n\tvar manhMax = Pr*rd + Pg*gd + Pb*bd;\n\t// perceptual Manhattan color distance\n\tfunction distManhattan(rgb0, rgb1) {\n\t\tvar rd = Math.abs(rgb1[0]-rgb0[0]),\n\t\t\tgd = Math.abs(rgb1[1]-rgb0[1]),\n\t\t\tbd = Math.abs(rgb1[2]-rgb0[2]);\n\n\t\treturn (Pr*rd + Pg*gd + Pb*bd) / manhMax;\n\t}\n\n\t// http://rgb2hsl.nichabi.com/javascript-function.php\n\tfunction rgb2hsl(r, g, b) {\n\t\tvar max, min, h, s, l, d;\n\t\tr /= 255;\n\t\tg /= 255;\n\t\tb /= 255;\n\t\tmax = Math.max(r, g, b);\n\t\tmin = Math.min(r, g, b);\n\t\tl = (max + min) / 2;\n\t\tif (max == min) {\n\t\t\th = s = 0;\n\t\t} else {\n\t\t\td = max - min;\n\t\t\ts = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\t\t\tswitch (max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g:\th = (b - r) / d + 2; break;\n\t\t\t\tcase b:\th = (r - g) / d + 4; break\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n//\t\th = Math.floor(h * 360)\n//\t\ts = Math.floor(s * 100)\n//\t\tl = Math.floor(l * 100)\n\t\treturn {\n\t\t\th: h,\n\t\t\ts: s,\n\t\t\tl: rgb2lum(r,g,b),\n\t\t};\n\t}\n\n\tfunction hueGroup(hue, segs) {\n\t\tvar seg = 1/segs,\n\t\t\thaf = seg/2;\n\n\t\tif (hue >= 1 - haf || hue <= haf)\n\t\t\treturn 0;\n\n\t\tfor (var i = 1; i < segs; i++) {\n\t\t\tvar mid = i*seg;\n\t\t\tif (hue >= mid - haf && hue <= mid + haf)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\tfunction satGroup(sat) {\n\t\treturn sat;\n\t}\n\n\tfunction lumGroup(lum) {\n\t\treturn lum;\n\t}\n\n\tfunction typeOf(val) {\n\t\treturn Object.prototype.toString.call(val).slice(8,-1);\n\t}\n\n\tvar sort = isArrSortStable() ? Array.prototype.sort : stableSort;\n\n\t// must be used via stableSort.call(arr, fn)\n\tfunction stableSort(fn) {\n\t\tvar type = typeOf(this[0]);\n\n\t\tif (type == \"Number\" || type == \"String\") {\n\t\t\tvar ord = {}, len = this.length, val;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tval = this[i];\n\t\t\t\tif (ord[val] || ord[val] === 0) continue;\n\t\t\t\tord[val] = i;\n\t\t\t}\n\n\t\t\treturn this.sort(function(a,b) {\n\t\t\t\treturn fn(a,b) || ord[a] - ord[b];\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tvar ord = this.map(function(v){return v});\n\n\t\t\treturn this.sort(function(a,b) {\n\t\t\t\treturn fn(a,b) || ord.indexOf(a) - ord.indexOf(b);\n\t\t\t});\n\t\t}\n\t}\n\n\t// test if js engine's Array#sort implementation is stable\n\tfunction isArrSortStable() {\n\t\tvar str = \"abcdefghijklmnopqrstuvwxyz\";\n\n\t\treturn \"xyzvwtursopqmnklhijfgdeabc\" == str.split(\"\").sort(function(a,b) {\n\t\t\treturn ~~(str.indexOf(b)/2.3) - ~~(str.indexOf(a)/2.3);\n\t\t}).join(\"\");\n\t}\n\n\t// returns uniform pixel data from various img\n\t// TODO?: if array is passed, createimagedata, createlement canvas? take a pxlen?\n\tfunction getImageData(img, width) {\n\t\tvar can, ctx, imgd, buf8, buf32, height;\n\n\t\tswitch (typeOf(img)) {\n\t\t\tcase \"HTMLImageElement\":\n\t\t\t\tcan = document.createElement(\"canvas\");\n\t\t\t\tcan.width = img.naturalWidth;\n\t\t\t\tcan.height = img.naturalHeight;\n\t\t\t\tctx = can.getContext(\"2d\");\n\t\t\t\tctx.drawImage(img,0,0);\n\t\t\tcase \"Canvas\":\n\t\t\tcase \"HTMLCanvasElement\":\n\t\t\t\tcan = can || img;\n\t\t\t\tctx = ctx || can.getContext(\"2d\");\n\t\t\tcase \"CanvasRenderingContext2D\":\n\t\t\t\tctx = ctx || img;\n\t\t\t\tcan = can || ctx.canvas;\n\t\t\t\timgd = ctx.getImageData(0, 0, can.width, can.height);\n\t\t\tcase \"ImageData\":\n\t\t\t\timgd = imgd || img;\n\t\t\t\twidth = imgd.width;\n\t\t\t\tif (typeOf(imgd.data) == \"CanvasPixelArray\")\n\t\t\t\t\tbuf8 = new Uint8Array(imgd.data);\n\t\t\t\telse\n\t\t\t\t\tbuf8 = imgd.data;\n\t\t\tcase \"Array\":\n\t\t\tcase \"CanvasPixelArray\":\n\t\t\t\tbuf8 = buf8 || new Uint8Array(img);\n\t\t\tcase \"Uint8Array\":\n\t\t\tcase \"Uint8ClampedArray\":\n\t\t\t\tbuf8 = buf8 || img;\n\t\t\t\tbuf32 = new Uint32Array(buf8.buffer);\n\t\t\tcase \"Uint32Array\":\n\t\t\t\tbuf32 = buf32 || img;\n\t\t\t\tbuf8 = buf8 || new Uint8Array(buf32.buffer);\n\t\t\t\twidth = width || buf32.length;\n\t\t\t\theight = buf32.length / width;\n\t\t}\n\n\t\treturn {\n\t\t\tcan: can,\n\t\t\tctx: ctx,\n\t\t\timgd: imgd,\n\t\t\tbuf8: buf8,\n\t\t\tbuf32: buf32,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t};\n\t}\n\n\t// partitions a rect of wid x hgt into\n\t// array of bboxes of w0 x h0 (or less)\n\tfunction makeBoxes(wid, hgt, w0, h0) {\n\t\tvar wnum = ~~(wid/w0), wrem = wid%w0,\n\t\t\thnum = ~~(hgt/h0), hrem = hgt%h0,\n\t\t\txend = wid-wrem, yend = hgt-hrem;\n\n\t\tvar bxs = [];\n\t\tfor (var y = 0; y < hgt; y += h0)\n\t\t\tfor (var x = 0; x < wid; x += w0)\n\t\t\t\tbxs.push({x:x, y:y, w:(x==xend?wrem:w0), h:(y==yend?hrem:h0)});\n\n\t\treturn bxs;\n\t}\n\n\t// iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\n\tfunction iterBox(bbox, wid, fn) {\n\t\tvar b = bbox,\n\t\t\ti0 = b.y * wid + b.x,\n\t\t\ti1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1),\n\t\t\tcnt = 0, incr = wid - b.w + 1, i = i0;\n\n\t\tdo {\n\t\t\tfn.call(this, i);\n\t\t\ti += (++cnt % b.w == 0) ? incr : 1;\n\t\t} while (i <= i1);\n\t}\n\n\t// returns array of hash keys sorted by their values\n\tfunction sortedHashKeys(obj, desc) {\n\t\tvar keys = [];\n\n\t\tfor (var key in obj)\n\t\t\tkeys.push(key);\n\n\t\treturn sort.call(keys, function(a,b) {\n\t\t\treturn desc ? obj[b] - obj[a] : obj[a] - obj[b];\n\t\t});\n\t}\n\n\t// expose\n\tthis.RgbQuant = RgbQuant;\n\n\t// expose to commonJS\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = RgbQuant;\n\t}\n\n}).call(this);","import {\n  DisplayBezierCurve,\n  DisplayBezierCurveType,\n  DisplayBezierCurveTypes,\n  DisplayBitmap,\n  DisplayBitmapColorPair,\n  displayCurveTypeBitWidth,\n  DisplayPointDataTypes,\n  displayCurveTypesPerByte,\n  DisplaySpriteColorPair,\n  DisplayWireframe,\n} from \"../DisplayManager.ts\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./ArrayBufferUtils.ts\";\nimport { rgbToHex, stringToRGB } from \"./ColorUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { drawBitmapHeaderLength, getBitmapData } from \"./DisplayBitmapUtils.ts\";\nimport {\n  DisplayAlignment,\n  DisplayAlignments,\n  DisplayDirection,\n  DisplayDirections,\n  DisplaySegmentCap,\n  DisplaySegmentCaps,\n} from \"./DisplayContextState.ts\";\nimport { DisplayManagerInterface } from \"./DisplayManagerInterface.ts\";\nimport { DisplaySpriteSerializedLines } from \"./DisplaySpriteSheetUtils.ts\";\nimport {\n  assertValidAlignment,\n  assertValidColor,\n  assertValidDirection,\n  assertValidPathNumberOfControlPoints,\n  assertValidNumberOfControlPoints,\n  assertValidOpacity,\n  assertValidPath,\n  assertValidSegmentCap,\n  assertValidWireframe,\n  DisplayColorRGB,\n  formatRotation,\n  formatScale,\n  maxDisplayScale,\n  minDisplayScale,\n  roundScale,\n  serializePoints,\n  getPointDataType,\n} from \"./DisplayUtils.ts\";\nimport {\n  clamp,\n  degToRad,\n  Int16Max,\n  Int16Min,\n  normalizeRadians,\n  twoPi,\n  Vector2,\n} from \"./MathUtils.ts\";\nimport { deepEqual } from \"./ObjectUtils.ts\";\n\nconst _console = createConsole(\"DisplayContextCommand\", { log: false });\n\nexport const DisplayContextCommandTypes = [\n  \"show\",\n  \"clear\",\n\n  \"setColor\",\n  \"setColorOpacity\",\n  \"setOpacity\",\n\n  \"saveContext\",\n  \"restoreContext\",\n\n  \"selectBackgroundColor\",\n  \"selectFillColor\",\n  \"selectLineColor\",\n\n  \"setIgnoreFill\",\n  \"setIgnoreLine\",\n  \"setFillBackground\",\n\n  \"setLineWidth\",\n  \"setRotation\",\n  \"clearRotation\",\n\n  \"setHorizontalAlignment\",\n  \"setVerticalAlignment\",\n  \"resetAlignment\",\n\n  \"setSegmentStartCap\",\n  \"setSegmentEndCap\",\n  \"setSegmentCap\",\n\n  \"setSegmentStartRadius\",\n  \"setSegmentEndRadius\",\n  \"setSegmentRadius\",\n\n  \"setCropTop\",\n  \"setCropRight\",\n  \"setCropBottom\",\n  \"setCropLeft\",\n  \"clearCrop\",\n\n  \"setRotationCropTop\",\n  \"setRotationCropRight\",\n  \"setRotationCropBottom\",\n  \"setRotationCropLeft\",\n  \"clearRotationCrop\",\n\n  \"selectBitmapColor\",\n  \"selectBitmapColors\",\n  \"setBitmapScaleX\",\n  \"setBitmapScaleY\",\n  \"setBitmapScale\",\n  \"resetBitmapScale\",\n\n  \"selectSpriteColor\",\n  \"selectSpriteColors\",\n  \"resetSpriteColors\",\n  \"setSpriteScaleX\",\n  \"setSpriteScaleY\",\n  \"setSpriteScale\",\n  \"resetSpriteScale\",\n\n  \"setSpritesLineHeight\",\n  \"setSpritesDirection\",\n  \"setSpritesLineDirection\",\n  \"setSpritesSpacing\",\n  \"setSpritesLineSpacing\",\n  \"setSpritesAlignment\",\n  \"setSpritesLineAlignment\",\n\n  \"clearRect\",\n\n  \"drawRect\",\n  \"drawRoundRect\",\n\n  \"drawCircle\",\n  \"drawArc\",\n\n  \"drawEllipse\",\n  \"drawArcEllipse\",\n\n  \"drawSegment\",\n  \"drawSegments\",\n\n  \"drawRegularPolygon\",\n  \"drawPolygon\",\n\n  \"drawWireframe\",\n\n  \"drawQuadraticBezierCurve\",\n  \"drawQuadraticBezierCurves\",\n  \"drawCubicBezierCurve\",\n  \"drawCubicBezierCurves\",\n\n  \"drawPath\",\n  \"drawClosedPath\",\n\n  \"drawBitmap\",\n\n  \"selectSpriteSheet\",\n  \"drawSprite\",\n  \"drawSprites\",\n\n  \"startSprite\",\n  \"endSprite\",\n] as const;\nexport type DisplayContextCommandType =\n  (typeof DisplayContextCommandTypes)[number];\n\nexport const DisplaySpriteContextCommandTypes = [\n  \"selectFillColor\",\n  \"selectLineColor\",\n  // \"selectBackgroundColor\",\n\n  \"setIgnoreFill\",\n  \"setIgnoreLine\",\n  // \"setFillBackground\",\n\n  \"setLineWidth\",\n  \"setRotation\",\n  \"clearRotation\",\n\n  \"setVerticalAlignment\",\n  \"setHorizontalAlignment\",\n  \"resetAlignment\",\n\n  \"setSegmentStartCap\",\n  \"setSegmentEndCap\",\n  \"setSegmentCap\",\n\n  \"setSegmentStartRadius\",\n  \"setSegmentEndRadius\",\n  \"setSegmentRadius\",\n\n  \"setCropTop\",\n  \"setCropRight\",\n  \"setCropBottom\",\n  \"setCropLeft\",\n  \"clearCrop\",\n\n  \"setRotationCropTop\",\n  \"setRotationCropRight\",\n  \"setRotationCropBottom\",\n  \"setRotationCropLeft\",\n  \"clearRotationCrop\",\n\n  \"selectBitmapColor\",\n  \"selectBitmapColors\",\n  \"setBitmapScaleX\",\n  \"setBitmapScaleY\",\n  \"setBitmapScale\",\n  \"resetBitmapScale\",\n\n  \"selectSpriteColor\",\n  \"selectSpriteColors\",\n  \"resetSpriteColors\",\n  \"setSpriteScaleX\",\n  \"setSpriteScaleY\",\n  \"setSpriteScale\",\n  \"resetSpriteScale\",\n\n  \"clearRect\",\n\n  \"drawRect\",\n  \"drawRoundRect\",\n  \"drawCircle\",\n  \"drawEllipse\",\n\n  \"drawRegularPolygon\",\n  \"drawPolygon\",\n\n  \"drawWireframe\",\n\n  \"drawQuadraticBezierCurve\",\n  \"drawQuadraticBezierCurves\",\n  \"drawCubicBezierCurve\",\n  \"drawCubicBezierCurves\",\n\n  \"drawPath\",\n  \"drawClosedPath\",\n\n  \"drawSegment\",\n  \"drawSegments\",\n\n  \"drawArc\",\n  \"drawArcEllipse\",\n\n  \"drawBitmap\",\n  \"drawSprite\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type DisplaySpriteContextCommandType =\n  (typeof DisplaySpriteContextCommandTypes)[number];\n\nexport interface BaseDisplayContextCommand {\n  type: DisplayContextCommandType | \"runDisplayContextCommands\";\n  hide?: boolean;\n}\n\nexport interface SimpleDisplayCommand extends BaseDisplayContextCommand {\n  type:\n    | \"show\"\n    | \"clear\"\n    | \"saveContext\"\n    | \"restoreContext\"\n    | \"clearRotation\"\n    | \"clearCrop\"\n    | \"clearRotationCrop\"\n    | \"resetBitmapScale\"\n    | \"resetSpriteColors\"\n    | \"resetSpriteScale\"\n    | \"resetAlignment\"\n    | \"endSprite\";\n}\n\nexport interface SetDisplayColorCommand extends BaseDisplayContextCommand {\n  type: \"setColor\";\n  colorIndex: number;\n  color: DisplayColorRGB | string;\n}\nexport interface SetDisplayColorOpacityCommand\n  extends BaseDisplayContextCommand {\n  type: \"setColorOpacity\";\n  colorIndex: number;\n  opacity: number;\n}\nexport interface SetDisplayOpacityCommand extends BaseDisplayContextCommand {\n  type: \"setOpacity\";\n  opacity: number;\n}\n\nexport interface SetDisplayHorizontalAlignmentCommand\n  extends BaseDisplayContextCommand {\n  type: \"setHorizontalAlignment\";\n  horizontalAlignment: DisplayAlignment;\n}\nexport interface SetDisplayVerticalAlignmentCommand\n  extends BaseDisplayContextCommand {\n  type: \"setVerticalAlignment\";\n  verticalAlignment: DisplayAlignment;\n}\n\nexport interface SelectDisplayBackgroundColorCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectBackgroundColor\";\n  backgroundColorIndex: number;\n}\nexport interface SelectDisplayFillColorCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectFillColor\";\n  fillColorIndex: number;\n}\nexport interface SelectDisplayLineColorCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectLineColor\";\n  lineColorIndex: number;\n}\nexport interface SelectDisplayIgnoreFillCommand\n  extends BaseDisplayContextCommand {\n  type: \"setIgnoreFill\";\n  ignoreFill: boolean;\n}\nexport interface SelectDisplayIgnoreLineCommand\n  extends BaseDisplayContextCommand {\n  type: \"setIgnoreLine\";\n  ignoreLine: boolean;\n}\nexport interface SelectDisplayFillBackgroundCommand\n  extends BaseDisplayContextCommand {\n  type: \"setFillBackground\";\n  fillBackground: boolean;\n}\nexport interface SetDisplayLineWidthCommand extends BaseDisplayContextCommand {\n  type: \"setLineWidth\";\n  lineWidth: number;\n}\nexport interface SetDisplayRotationCommand extends BaseDisplayContextCommand {\n  type: \"setRotation\";\n  rotation: number;\n  isRadians?: boolean;\n}\n\nexport interface SetDisplaySegmentStartCapCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentStartCap\";\n  segmentStartCap: DisplaySegmentCap;\n}\nexport interface SetDisplaySegmentEndCapCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentEndCap\";\n  segmentEndCap: DisplaySegmentCap;\n}\nexport interface SetDisplaySegmentCapCommand extends BaseDisplayContextCommand {\n  type: \"setSegmentCap\";\n  segmentCap: DisplaySegmentCap;\n}\n\nexport interface SetDisplaySegmentStartRadiusCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentStartRadius\";\n  segmentStartRadius: number;\n}\nexport interface SetDisplaySegmentEndRadiusCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentEndRadius\";\n  segmentEndRadius: number;\n}\nexport interface SetDisplaySegmentRadiusCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSegmentRadius\";\n  segmentRadius: number;\n}\n\nexport interface SetDisplayCropTopCommand extends BaseDisplayContextCommand {\n  type: \"setCropTop\";\n  cropTop: number;\n}\nexport interface SetDisplayCropRightCommand extends BaseDisplayContextCommand {\n  type: \"setCropRight\";\n  cropRight: number;\n}\nexport interface SetDisplayCropBottomCommand extends BaseDisplayContextCommand {\n  type: \"setCropBottom\";\n  cropBottom: number;\n}\nexport interface SetDisplayCropLeftCommand extends BaseDisplayContextCommand {\n  type: \"setCropLeft\";\n  cropLeft: number;\n}\n\nexport interface SetDisplayRotationCropTopCommand\n  extends BaseDisplayContextCommand {\n  type: \"setRotationCropTop\";\n  rotationCropTop: number;\n}\nexport interface SetDisplayRotationCropRightCommand\n  extends BaseDisplayContextCommand {\n  type: \"setRotationCropRight\";\n  rotationCropRight: number;\n}\nexport interface SetDisplayRotationCropBottomCommand\n  extends BaseDisplayContextCommand {\n  type: \"setRotationCropBottom\";\n  rotationCropBottom: number;\n}\nexport interface SetDisplayRotationCropLeftCommand\n  extends BaseDisplayContextCommand {\n  type: \"setRotationCropLeft\";\n  rotationCropLeft: number;\n}\n\nexport interface SelectDisplayBitmapColorIndexCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectBitmapColor\";\n  bitmapColorIndex: number;\n  colorIndex: number;\n}\nexport interface SelectDisplayBitmapColorIndicesCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectBitmapColors\";\n  bitmapColorPairs: DisplayBitmapColorPair[];\n}\n\nexport interface SetDisplayBitmapScaleXCommand\n  extends BaseDisplayContextCommand {\n  type: \"setBitmapScaleX\";\n  bitmapScaleX: number;\n}\nexport interface SetDisplayBitmapScaleYCommand\n  extends BaseDisplayContextCommand {\n  type: \"setBitmapScaleY\";\n  bitmapScaleY: number;\n}\nexport interface SetDisplayBitmapScaleCommand\n  extends BaseDisplayContextCommand {\n  type: \"setBitmapScale\";\n  bitmapScale: number;\n}\n\nexport interface SelectDisplaySpriteColorIndexCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectSpriteColor\";\n  spriteColorIndex: number;\n  colorIndex: number;\n}\nexport interface SelectDisplaySpriteColorIndicesCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectSpriteColors\";\n  spriteColorPairs: DisplaySpriteColorPair[];\n}\n\nexport interface SetDisplaySpriteScaleXCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpriteScaleX\";\n  spriteScaleX: number;\n}\nexport interface SetDisplaySpriteScaleYCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpriteScaleY\";\n  spriteScaleY: number;\n}\nexport interface SetDisplaySpriteScaleCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpriteScale\";\n  spriteScale: number;\n}\n\nexport interface SetDisplaySpritesLineHeightCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpritesLineHeight\";\n  spritesLineHeight: number;\n}\n\nexport interface SetDisplaySpritesDirectionCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpritesDirection\";\n  spritesDirection: DisplayDirection;\n}\nexport interface SetDisplaySpritesLineDirectionCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpritesLineDirection\";\n  spritesLineDirection: DisplayDirection;\n}\n\nexport interface SetDisplaySpritesSpacingCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpritesSpacing\";\n  spritesSpacing: number;\n}\nexport interface SetDisplaySpritesLineSpacingCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpritesLineSpacing\";\n  spritesLineSpacing: number;\n}\n\nexport interface SetDisplaySpritesAlignmentCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpritesAlignment\";\n  spritesAlignment: DisplayAlignment;\n}\nexport interface SetDisplaySpritesLineAlignmentCommand\n  extends BaseDisplayContextCommand {\n  type: \"setSpritesLineAlignment\";\n  spritesLineAlignment: DisplayAlignment;\n}\n\nexport interface BasePositionDisplayContextCommand\n  extends BaseDisplayContextCommand {\n  x: number;\n  y: number;\n}\nexport interface BaseOffsetPositionDisplayContextCommand\n  extends BaseDisplayContextCommand {\n  offsetX: number;\n  offsetY: number;\n}\nexport interface BaseSizeDisplayContextCommand\n  extends BaseDisplayContextCommand {\n  width: number;\n  height: number;\n}\n\nexport interface BaseDisplayRectCommand\n  extends BasePositionDisplayContextCommand,\n    BaseSizeDisplayContextCommand {}\nexport interface BaseDisplayCenterRectCommand\n  extends BaseOffsetPositionDisplayContextCommand,\n    BaseSizeDisplayContextCommand {}\n\nexport interface ClearDisplayRectCommand extends BaseDisplayRectCommand {\n  type: \"clearRect\";\n}\nexport interface DrawDisplayRectCommand extends BaseDisplayCenterRectCommand {\n  type: \"drawRect\";\n}\n\nexport interface DrawDisplayRoundedRectCommand\n  extends BaseOffsetPositionDisplayContextCommand,\n    BaseSizeDisplayContextCommand {\n  type: \"drawRoundRect\";\n  borderRadius: number;\n}\n\nexport interface DrawDisplayCircleCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawCircle\";\n  radius: number;\n}\nexport interface DrawDisplayEllipseCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawEllipse\";\n  radiusX: number;\n  radiusY: number;\n}\n\nexport interface DrawDisplayRegularPolygonCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawRegularPolygon\";\n  radius: number;\n  numberOfSides: number;\n}\nexport interface DrawDisplayPolygonCommand extends BaseDisplayContextCommand {\n  type: \"drawPolygon\";\n  points: Vector2[];\n}\nexport interface DrawDisplaySegmentCommand extends BaseDisplayContextCommand {\n  type: \"drawSegment\";\n  startX: number;\n  startY: number;\n  endX: number;\n  endY: number;\n}\nexport interface DrawDisplaySegmentsCommand extends BaseDisplayContextCommand {\n  type: \"drawSegments\";\n  points: Vector2[];\n}\n\nexport interface DrawDisplayBezierCurveCommand\n  extends BaseDisplayContextCommand {\n  type:\n    | \"drawQuadraticBezierCurve\"\n    | \"drawQuadraticBezierCurves\"\n    | \"drawCubicBezierCurve\"\n    | \"drawCubicBezierCurves\";\n  controlPoints: Vector2[];\n}\n\nexport interface DrawDisplayPathCommand extends BaseDisplayContextCommand {\n  type: \"drawPath\" | \"drawClosedPath\";\n  curves: DisplayBezierCurve[];\n}\n\nexport interface DrawDisplayWireframeCommand extends BaseDisplayContextCommand {\n  type: \"drawWireframe\";\n  wireframe: DisplayWireframe;\n}\n\nexport interface DrawDisplayArcCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawArc\";\n  radius: number;\n  startAngle: number;\n  angleOffset: number;\n  isRadians?: boolean;\n}\nexport interface DrawDisplayArcEllipseCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawArcEllipse\";\n  radiusX: number;\n  radiusY: number;\n  startAngle: number;\n  angleOffset: number;\n  isRadians?: boolean;\n}\n\nexport interface DrawDisplayBitmapCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawBitmap\";\n  bitmap: DisplayBitmap;\n}\n\nexport interface SelectDisplaySpriteSheetCommand\n  extends BaseDisplayContextCommand {\n  type: \"selectSpriteSheet\";\n  spriteSheetIndex: number;\n}\n\nexport interface DrawDisplaySpriteCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawSprite\";\n  spriteIndex: number;\n  use2Bytes: boolean;\n}\n\nexport interface DrawDisplaySpritesCommand\n  extends BaseOffsetPositionDisplayContextCommand {\n  type: \"drawSprites\";\n  spriteSerializedLines: DisplaySpriteSerializedLines;\n}\n\nexport interface StartDisplaySpriteCommand\n  extends BaseDisplayCenterRectCommand {\n  type: \"startSprite\";\n}\n\nexport type DisplayContextCommand =\n  | SimpleDisplayCommand\n  | SetDisplayColorCommand\n  | SetDisplayColorOpacityCommand\n  | SetDisplayOpacityCommand\n  | SelectDisplayBackgroundColorCommand\n  | SelectDisplayFillColorCommand\n  | SelectDisplayLineColorCommand\n  | SetDisplayLineWidthCommand\n  | SetDisplayRotationCommand\n  | SetDisplaySegmentStartCapCommand\n  | SetDisplaySegmentEndCapCommand\n  | SetDisplaySegmentCapCommand\n  | SetDisplaySegmentStartRadiusCommand\n  | SetDisplaySegmentEndRadiusCommand\n  | SetDisplaySegmentRadiusCommand\n  | SetDisplayCropTopCommand\n  | SetDisplayCropRightCommand\n  | SetDisplayCropBottomCommand\n  | SetDisplayCropLeftCommand\n  | SetDisplayRotationCropTopCommand\n  | SetDisplayRotationCropRightCommand\n  | SetDisplayRotationCropBottomCommand\n  | SetDisplayRotationCropLeftCommand\n  | SelectDisplayBitmapColorIndexCommand\n  | SelectDisplayBitmapColorIndicesCommand\n  | SetDisplayBitmapScaleXCommand\n  | SetDisplayBitmapScaleYCommand\n  | SetDisplayBitmapScaleCommand\n  | SelectDisplaySpriteColorIndexCommand\n  | SelectDisplaySpriteColorIndicesCommand\n  | SetDisplaySpriteScaleXCommand\n  | SetDisplaySpriteScaleYCommand\n  | SetDisplaySpriteScaleCommand\n  | ClearDisplayRectCommand\n  | DrawDisplayRectCommand\n  | DrawDisplayRoundedRectCommand\n  | DrawDisplayCircleCommand\n  | DrawDisplayEllipseCommand\n  | DrawDisplayRegularPolygonCommand\n  | DrawDisplayPolygonCommand\n  | DrawDisplaySegmentCommand\n  | DrawDisplaySegmentsCommand\n  | DrawDisplayArcCommand\n  | DrawDisplayArcEllipseCommand\n  | DrawDisplayBitmapCommand\n  | DrawDisplaySpriteCommand\n  | DrawDisplaySpritesCommand\n  | SelectDisplaySpriteSheetCommand\n  | SetDisplayHorizontalAlignmentCommand\n  | SetDisplayVerticalAlignmentCommand\n  | SetDisplaySpritesDirectionCommand\n  | SetDisplaySpritesLineDirectionCommand\n  | SetDisplaySpritesSpacingCommand\n  | SetDisplaySpritesLineSpacingCommand\n  | SetDisplaySpritesAlignmentCommand\n  | SetDisplaySpritesLineAlignmentCommand\n  | SetDisplaySpritesLineHeightCommand\n  | DrawDisplayWireframeCommand\n  | DrawDisplayBezierCurveCommand\n  | DrawDisplayPathCommand\n  | SelectDisplayIgnoreFillCommand\n  | SelectDisplayIgnoreLineCommand\n  | SelectDisplayFillBackgroundCommand\n  | StartDisplaySpriteCommand;\n\nexport function serializeContextCommand(\n  displayManager: DisplayManagerInterface,\n  command: DisplayContextCommand\n) {\n  let dataView: DataView<ArrayBuffer> | undefined;\n\n  switch (command.type) {\n    case \"show\":\n    case \"clear\":\n    case \"saveContext\":\n    case \"restoreContext\":\n    case \"clearRotation\":\n    case \"clearCrop\":\n    case \"clearRotationCrop\":\n    case \"resetBitmapScale\":\n    case \"resetSpriteColors\":\n    case \"resetSpriteScale\":\n    case \"resetAlignment\":\n    case \"endSprite\":\n      break;\n    case \"setColor\":\n      {\n        const { color, colorIndex } = command;\n\n        let colorRGB: DisplayColorRGB;\n        if (typeof color == \"string\") {\n          colorRGB = stringToRGB(color);\n        } else {\n          colorRGB = color;\n        }\n        const colorHex = rgbToHex(colorRGB);\n        if (displayManager.colors[colorIndex] == colorHex) {\n          _console.log(`redundant color #${colorIndex} ${colorHex}`);\n          return;\n        }\n\n        //_console.log(`setting color #${colorIndex}`, colorRGB);\n        displayManager.assertValidColorIndex(colorIndex);\n        assertValidColor(colorRGB);\n        dataView = new DataView(new ArrayBuffer(4));\n        dataView.setUint8(0, colorIndex);\n        dataView.setUint8(1, colorRGB.r);\n        dataView.setUint8(2, colorRGB.g);\n        dataView.setUint8(3, colorRGB.b);\n      }\n      break;\n    case \"setColorOpacity\":\n      {\n        const { colorIndex, opacity } = command;\n        displayManager.assertValidColorIndex(colorIndex);\n        assertValidOpacity(opacity);\n        if (\n          Math.floor(255 * displayManager.opacities[colorIndex]) ==\n          Math.floor(255 * opacity)\n        ) {\n          _console.log(`redundant opacity #${colorIndex} ${opacity}`);\n          return;\n        }\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint8(0, colorIndex);\n        dataView.setUint8(1, opacity * 255);\n      }\n      break;\n    case \"setOpacity\":\n      {\n        const { opacity } = command;\n        assertValidOpacity(opacity);\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, Math.round(opacity * 255));\n      }\n      break;\n    case \"selectFillColor\":\n      {\n        const { fillColorIndex } = command;\n        displayManager.assertValidColorIndex(fillColorIndex);\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, fillColorIndex);\n      }\n      break;\n    case \"selectBackgroundColor\":\n      {\n        const { backgroundColorIndex } = command;\n        displayManager.assertValidColorIndex(backgroundColorIndex);\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, backgroundColorIndex);\n      }\n      break;\n    case \"selectLineColor\":\n      {\n        const { lineColorIndex } = command;\n        displayManager.assertValidColorIndex(lineColorIndex);\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, lineColorIndex);\n      }\n      break;\n    case \"setIgnoreFill\":\n      {\n        const { ignoreFill } = command;\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, ignoreFill ? 1 : 0);\n      }\n      break;\n    case \"setIgnoreLine\":\n      {\n        const { ignoreLine } = command;\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, ignoreLine ? 1 : 0);\n      }\n      break;\n    case \"setFillBackground\":\n      {\n        const { fillBackground } = command;\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, fillBackground ? 1 : 0);\n      }\n      break;\n    case \"setLineWidth\":\n      {\n        const { lineWidth } = command;\n        displayManager.assertValidLineWidth(lineWidth);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, lineWidth, true);\n      }\n      break;\n    case \"setHorizontalAlignment\":\n      {\n        const { horizontalAlignment } = command;\n        assertValidAlignment(horizontalAlignment);\n        //_console.log({ horizontalAlignment });\n        dataView = new DataView(new ArrayBuffer(1));\n        const alignmentEnum = DisplayAlignments.indexOf(horizontalAlignment);\n        dataView.setUint8(0, alignmentEnum);\n      }\n      break;\n    case \"setVerticalAlignment\":\n      {\n        const { verticalAlignment } = command;\n        assertValidAlignment(verticalAlignment);\n        //_console.log({ verticalAlignment });\n        dataView = new DataView(new ArrayBuffer(1));\n        const alignmentEnum = DisplayAlignments.indexOf(verticalAlignment);\n        dataView.setUint8(0, alignmentEnum);\n      }\n      break;\n    case \"setRotation\":\n      {\n        let { rotation, isRadians } = command;\n        rotation = isRadians ? rotation : degToRad(rotation);\n        rotation = normalizeRadians(rotation);\n        isRadians = true;\n        // _console.log({ rotation, isRadians });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, formatRotation(rotation, isRadians), true);\n      }\n      break;\n    case \"setSegmentStartCap\":\n      {\n        const { segmentStartCap } = command;\n        assertValidSegmentCap(segmentStartCap);\n        //_console.log({ segmentStartCap });\n        dataView = new DataView(new ArrayBuffer(1));\n        const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentStartCap);\n        dataView.setUint8(0, segmentCapEnum);\n      }\n      break;\n    case \"setSegmentEndCap\":\n      {\n        const { segmentEndCap } = command;\n        assertValidSegmentCap(segmentEndCap);\n        //_console.log({ segmentEndCap });\n        dataView = new DataView(new ArrayBuffer(1));\n        const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentEndCap);\n        dataView.setUint8(0, segmentCapEnum);\n      }\n      break;\n    case \"setSegmentCap\":\n      {\n        const { segmentCap } = command;\n        assertValidSegmentCap(segmentCap);\n        //_console.log({ segmentCap });\n        dataView = new DataView(new ArrayBuffer(1));\n        const segmentCapEnum = DisplaySegmentCaps.indexOf(segmentCap);\n        dataView.setUint8(0, segmentCapEnum);\n      }\n      break;\n    case \"setSegmentStartRadius\":\n      {\n        const { segmentStartRadius } = command;\n        //_console.log({ segmentStartRadius });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, segmentStartRadius, true);\n      }\n      break;\n    case \"setSegmentEndRadius\":\n      {\n        const { segmentEndRadius } = command;\n        //_console.log({ segmentEndRadius });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, segmentEndRadius, true);\n      }\n      break;\n    case \"setSegmentRadius\":\n      {\n        const { segmentRadius } = command;\n        //_console.log({ segmentRadius });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, segmentRadius, true);\n      }\n      break;\n    case \"setCropTop\":\n      {\n        const { cropTop } = command;\n        //_console.log({ cropTop });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, cropTop, true);\n      }\n      break;\n    case \"setCropRight\":\n      {\n        const { cropRight } = command;\n        //_console.log({ cropRight });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, cropRight, true);\n      }\n      break;\n    case \"setCropBottom\":\n      {\n        const { cropBottom } = command;\n        //_console.log({ cropBottom });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, cropBottom, true);\n      }\n      break;\n    case \"setCropLeft\":\n      {\n        const { cropLeft } = command;\n        //_console.log({ cropLeft });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, cropLeft, true);\n      }\n      break;\n    case \"setRotationCropTop\":\n      {\n        const { rotationCropTop } = command;\n        // _console.log({ rotationCropTop });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, rotationCropTop, true);\n      }\n      break;\n    case \"setRotationCropRight\":\n      {\n        const { rotationCropRight } = command;\n        //_console.log({ rotationCropRight });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, rotationCropRight, true);\n      }\n      break;\n    case \"setRotationCropBottom\":\n      {\n        const { rotationCropBottom } = command;\n        //_console.log({ rotationCropBottom });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, rotationCropBottom, true);\n      }\n      break;\n    case \"setRotationCropLeft\":\n      {\n        const { rotationCropLeft } = command;\n        //_console.log({ rotationCropLeft });\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, rotationCropLeft, true);\n      }\n      break;\n    case \"selectBitmapColor\":\n      {\n        const { bitmapColorIndex, colorIndex } = command;\n        displayManager.assertValidColorIndex(bitmapColorIndex);\n        displayManager.assertValidColorIndex(colorIndex);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint8(0, bitmapColorIndex);\n        dataView.setUint8(1, colorIndex);\n      }\n      break;\n    case \"selectBitmapColors\":\n      {\n        const { bitmapColorPairs } = command;\n\n        _console.assertRangeWithError(\n          \"bitmapColors\",\n          bitmapColorPairs.length,\n          1,\n          displayManager.numberOfColors\n        );\n        const bitmapColorIndices =\n          displayManager.contextState.bitmapColorIndices.slice();\n        bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n          displayManager.assertValidColorIndex(bitmapColorIndex);\n          displayManager.assertValidColorIndex(colorIndex);\n          bitmapColorIndices[bitmapColorIndex] = colorIndex;\n        });\n\n        dataView = new DataView(\n          new ArrayBuffer(bitmapColorPairs.length * 2 + 1)\n        );\n        let offset = 0;\n        dataView.setUint8(offset++, bitmapColorPairs.length);\n        bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n          dataView!.setUint8(offset, bitmapColorIndex);\n          dataView!.setUint8(offset + 1, colorIndex);\n          offset += 2;\n        });\n      }\n      break;\n    case \"setBitmapScaleX\":\n      {\n        let { bitmapScaleX } = command;\n        bitmapScaleX = clamp(bitmapScaleX, minDisplayScale, maxDisplayScale);\n        bitmapScaleX = roundScale(bitmapScaleX);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(bitmapScaleX), true);\n      }\n      break;\n    case \"setBitmapScaleY\":\n      {\n        let { bitmapScaleY } = command;\n        bitmapScaleY = clamp(bitmapScaleY, minDisplayScale, maxDisplayScale);\n        bitmapScaleY = roundScale(bitmapScaleY);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(bitmapScaleY), true);\n      }\n      break;\n    case \"setBitmapScale\":\n      {\n        let { bitmapScale } = command;\n        bitmapScale = clamp(bitmapScale, minDisplayScale, maxDisplayScale);\n        bitmapScale = roundScale(bitmapScale);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(bitmapScale), true);\n      }\n      break;\n    case \"selectSpriteColor\":\n      {\n        const { spriteColorIndex, colorIndex } = command;\n        displayManager.assertValidColorIndex(spriteColorIndex);\n        displayManager.assertValidColorIndex(colorIndex);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint8(0, spriteColorIndex);\n        dataView.setUint8(1, colorIndex);\n      }\n      break;\n    case \"selectSpriteColors\":\n      {\n        const { spriteColorPairs } = command;\n        _console.assertRangeWithError(\n          \"spriteColors\",\n          spriteColorPairs.length,\n          1,\n          displayManager.numberOfColors\n        );\n        const spriteColorIndices =\n          displayManager.contextState.spriteColorIndices.slice();\n        spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {\n          displayManager.assertValidColorIndex(spriteColorIndex);\n          displayManager.assertValidColorIndex(colorIndex);\n          spriteColorIndices[spriteColorIndex] = colorIndex;\n        });\n\n        dataView = new DataView(\n          new ArrayBuffer(spriteColorPairs.length * 2 + 1)\n        );\n        let offset = 0;\n        dataView.setUint8(offset++, spriteColorPairs.length);\n        spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {\n          dataView!.setUint8(offset, spriteColorIndex);\n          dataView!.setUint8(offset + 1, colorIndex);\n          offset += 2;\n        });\n      }\n      break;\n    case \"setSpriteScaleX\":\n      {\n        let { spriteScaleX } = command;\n        spriteScaleX = clamp(spriteScaleX, minDisplayScale, maxDisplayScale);\n        spriteScaleX = roundScale(spriteScaleX);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(spriteScaleX), true);\n      }\n      break;\n    case \"setSpriteScaleY\":\n      {\n        let { spriteScaleY } = command;\n        spriteScaleY = clamp(spriteScaleY, minDisplayScale, maxDisplayScale);\n        spriteScaleY = roundScale(spriteScaleY);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(spriteScaleY), true);\n      }\n      break;\n    case \"setSpriteScale\":\n      {\n        let { spriteScale } = command;\n        spriteScale = clamp(spriteScale, minDisplayScale, maxDisplayScale);\n        spriteScale = roundScale(spriteScale);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, formatScale(spriteScale), true);\n      }\n      break;\n    case \"setSpritesLineHeight\":\n      {\n        const { spritesLineHeight } = command;\n        displayManager.assertValidLineWidth(spritesLineHeight);\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setUint16(0, spritesLineHeight, true);\n      }\n      break;\n    case \"setSpritesDirection\":\n      {\n        const { spritesDirection } = command;\n        assertValidDirection(spritesDirection);\n        _console.log({ spritesDirection });\n        dataView = new DataView(new ArrayBuffer(1));\n        const alignmentEnum = DisplayDirections.indexOf(spritesDirection);\n        dataView.setUint8(0, alignmentEnum);\n      }\n      break;\n    case \"setSpritesLineDirection\":\n      {\n        const { spritesLineDirection } = command;\n        assertValidDirection(spritesLineDirection);\n        _console.log({ spritesLineDirection });\n        dataView = new DataView(new ArrayBuffer(1));\n        const alignmentEnum = DisplayDirections.indexOf(spritesLineDirection);\n        dataView.setUint8(0, alignmentEnum);\n      }\n      break;\n    case \"setSpritesSpacing\":\n      {\n        const { spritesSpacing } = command;\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, spritesSpacing, true);\n      }\n      break;\n    case \"setSpritesLineSpacing\":\n      {\n        const { spritesLineSpacing } = command;\n        dataView = new DataView(new ArrayBuffer(2));\n        dataView.setInt16(0, spritesLineSpacing, true);\n      }\n      break;\n    case \"setSpritesAlignment\":\n      {\n        const { spritesAlignment } = command;\n        assertValidAlignment(spritesAlignment);\n        _console.log({ spritesAlignment });\n        dataView = new DataView(new ArrayBuffer(1));\n        const alignmentEnum = DisplayAlignments.indexOf(spritesAlignment);\n        dataView.setUint8(0, alignmentEnum);\n      }\n      break;\n    case \"setSpritesLineAlignment\":\n      {\n        const { spritesLineAlignment } = command;\n        assertValidAlignment(spritesLineAlignment);\n        _console.log({ spritesLineAlignment });\n        dataView = new DataView(new ArrayBuffer(1));\n        const alignmentEnum = DisplayAlignments.indexOf(spritesLineAlignment);\n        dataView.setUint8(0, alignmentEnum);\n      }\n      break;\n    case \"clearRect\":\n      {\n        const { x, y, width, height } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4));\n        dataView.setInt16(0, x, true);\n        dataView.setInt16(2, y, true);\n        dataView.setInt16(4, width, true);\n        dataView.setInt16(6, height, true);\n      }\n      break;\n    case \"drawRect\":\n      {\n        const { offsetX, offsetY, width, height } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, width, true);\n        dataView.setUint16(6, height, true);\n      }\n      break;\n    case \"drawRoundRect\":\n      {\n        const { offsetX, offsetY, width, height, borderRadius } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4 + 1));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, width, true);\n        dataView.setUint16(6, height, true);\n        dataView.setUint8(8, borderRadius);\n      }\n      break;\n    case \"drawCircle\":\n      {\n        const { offsetX, offsetY, radius } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 3));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radius, true);\n      }\n      break;\n    case \"drawEllipse\":\n      {\n        const { offsetX, offsetY, radiusX, radiusY } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radiusX, true);\n        dataView.setUint16(6, radiusY, true);\n      }\n      break;\n    case \"drawRegularPolygon\":\n      {\n        const { offsetX, offsetY, radius, numberOfSides } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 3 + 1));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radius, true);\n        dataView.setUint8(6, numberOfSides);\n      }\n      break;\n    case \"drawPolygon\":\n      {\n        const { points } = command;\n        _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n        dataView = serializePoints(points);\n      }\n      break;\n    case \"drawWireframe\":\n      {\n        const { wireframe } = command;\n        const { points, edges } = wireframe;\n        if (wireframe.points.length == 0) {\n          return;\n        }\n        assertValidWireframe(wireframe);\n        // [pointDataType, numberOfPoints, ...points, numberOfEdges, ...edges]\n        const pointsDataView = serializePoints(points);\n\n        const edgesDataView = new DataView(\n          new ArrayBuffer(1 + 2 * edges.length)\n        );\n        let edgesDataOffset = 0;\n        edgesDataView.setUint8(edgesDataOffset++, edges.length);\n        edges.forEach((edge) => {\n          edgesDataView.setUint8(edgesDataOffset++, edge.startIndex);\n          edgesDataView.setUint8(edgesDataOffset++, edge.endIndex);\n        });\n\n        dataView = new DataView(\n          concatenateArrayBuffers(pointsDataView, edgesDataView)\n        );\n      }\n      break;\n    case \"drawQuadraticBezierCurve\":\n    case \"drawCubicBezierCurve\":\n      {\n        const { controlPoints } = command;\n        const curveType: DisplayBezierCurveType =\n          command.type == \"drawCubicBezierCurve\" ? \"cubic\" : \"quadratic\";\n        assertValidNumberOfControlPoints(curveType, controlPoints);\n        dataView = new DataView(new ArrayBuffer(4 * controlPoints.length));\n        let offset = 0;\n        controlPoints.forEach((controlPoint) => {\n          dataView!.setInt16(offset, controlPoint.x, true);\n          offset += 2;\n          dataView!.setInt16(offset, controlPoint.y, true);\n          offset += 2;\n        });\n      }\n      break;\n    case \"drawQuadraticBezierCurves\":\n    case \"drawCubicBezierCurves\":\n      {\n        const { controlPoints } = command;\n        const curveType: DisplayBezierCurveType =\n          command.type == \"drawCubicBezierCurves\" ? \"cubic\" : \"quadratic\";\n        assertValidPathNumberOfControlPoints(curveType, controlPoints);\n        dataView = serializePoints(controlPoints);\n      }\n      break;\n    case \"drawPath\":\n    case \"drawClosedPath\":\n      {\n        const { curves } = command;\n        // _console.log(\"curves\", curves);\n        assertValidPath(curves);\n        const typesDataView = new DataView(\n          new ArrayBuffer(Math.ceil(curves.length / displayCurveTypesPerByte))\n        );\n        // _console.log({ \"curves.length\": curves.length, typesDataView });\n        const controlPointsDataViews: DataView[] = [];\n\n        // [pointDataType, numberOfCurves, numberOfPoints, ...curveTypes, ...points]\n\n        const allControlPoints: Vector2[] = [];\n        curves.forEach((curve) => {\n          allControlPoints.push(...curve.controlPoints);\n        });\n        const pointDataType = getPointDataType(allControlPoints);\n        const numberOfControlPoints = allControlPoints.length;\n        //_console.log({ numberOfControlPoints });\n\n        curves.forEach((curve, index) => {\n          const { type, controlPoints } = curve;\n          const typeByteIndex = Math.floor(index / displayCurveTypesPerByte);\n          const typeBitShift =\n            (index % displayCurveTypesPerByte) * displayCurveTypeBitWidth;\n          // _console.log({ type, typeByteIndex, typeBitShift });\n          let typeValue = typesDataView.getUint8(typeByteIndex) || 0;\n          typeValue |= DisplayBezierCurveTypes.indexOf(type) << typeBitShift;\n          typesDataView.setUint8(typeByteIndex, typeValue);\n\n          const controlPointsDataView = serializePoints(\n            controlPoints,\n            pointDataType,\n            true\n          );\n          controlPointsDataViews.push(controlPointsDataView);\n        });\n\n        const controlPointsBuffer = concatenateArrayBuffers(\n          ...controlPointsDataViews\n        );\n        const headerDataView = new DataView(new ArrayBuffer(3));\n        headerDataView.setUint8(\n          0,\n          DisplayPointDataTypes.indexOf(pointDataType)\n        );\n        headerDataView.setUint8(1, curves.length);\n        headerDataView.setUint8(2, numberOfControlPoints);\n        dataView = new DataView(\n          concatenateArrayBuffers(\n            headerDataView,\n            typesDataView,\n            controlPointsBuffer\n          )\n        );\n      }\n      break;\n    case \"drawSegment\":\n      {\n        const { startX, startY, endX, endY } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4));\n        dataView.setInt16(0, startX, true);\n        dataView.setInt16(2, startY, true);\n        dataView.setInt16(4, endX, true);\n        dataView.setInt16(6, endY, true);\n      }\n      break;\n    case \"drawSegments\":\n      {\n        const { points } = command;\n        _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n        dataView = serializePoints(points);\n      }\n      break;\n    case \"drawArc\":\n      {\n        let { offsetX, offsetY, radius, isRadians, startAngle, angleOffset } =\n          command;\n\n        startAngle = isRadians ? startAngle : degToRad(startAngle);\n        startAngle = normalizeRadians(startAngle);\n\n        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n        angleOffset = clamp(angleOffset, -twoPi, twoPi);\n\n        angleOffset /= twoPi;\n        angleOffset *= (angleOffset > 0 ? Int16Max - 1 : -Int16Min) - 1;\n\n        isRadians = true;\n\n        dataView = new DataView(new ArrayBuffer(2 * 5));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radius, true);\n        dataView.setUint16(6, formatRotation(startAngle, isRadians), true);\n        dataView.setInt16(8, angleOffset, true);\n      }\n      break;\n    case \"drawArcEllipse\":\n      {\n        let {\n          offsetX,\n          offsetY,\n          radiusX,\n          radiusY,\n          isRadians,\n          startAngle,\n          angleOffset,\n        } = command;\n\n        startAngle = isRadians ? startAngle : degToRad(startAngle);\n        startAngle = normalizeRadians(startAngle);\n\n        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n        angleOffset = clamp(angleOffset, -twoPi, twoPi);\n\n        angleOffset /= twoPi;\n        angleOffset *= (angleOffset > 0 ? Int16Max : -Int16Min) - 1;\n\n        isRadians = true;\n\n        dataView = new DataView(new ArrayBuffer(2 * 6));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, radiusX, true);\n        dataView.setUint16(6, radiusY, true);\n        dataView.setUint16(8, formatRotation(startAngle, isRadians), true);\n        dataView.setUint16(10, angleOffset, true);\n      }\n      break;\n    case \"drawBitmap\":\n      {\n        const { bitmap, offsetX, offsetY } = command;\n        displayManager.assertValidBitmap(bitmap, false);\n        dataView = new DataView(new ArrayBuffer(drawBitmapHeaderLength));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, bitmap.width, true);\n        dataView.setUint32(6, bitmap.pixels.length, true);\n        dataView.setUint8(10, bitmap.numberOfColors);\n\n        const bitmapData = getBitmapData(bitmap);\n        dataView.setUint16(11, bitmapData.byteLength, true);\n        const buffer = concatenateArrayBuffers(dataView, bitmapData);\n        dataView = new DataView(buffer);\n      }\n      break;\n    case \"selectSpriteSheet\":\n      {\n        const { spriteSheetIndex } = command;\n        dataView = new DataView(new ArrayBuffer(1));\n        dataView.setUint8(0, spriteSheetIndex);\n      }\n      break;\n    case \"drawSprite\":\n      {\n        const { offsetX, offsetY, spriteIndex, use2Bytes } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 2 + (use2Bytes ? 2 : 1)));\n        let offset = 0;\n        dataView.setInt16(offset, offsetX, true);\n        offset += 2;\n        dataView.setInt16(offset, offsetY, true);\n        offset += 2;\n        if (use2Bytes) {\n          dataView.setUint16(offset, spriteIndex, true);\n          offset += 2;\n        } else {\n          dataView.setUint8(offset++, spriteIndex!);\n        }\n      }\n      break;\n    case \"drawSprites\":\n      {\n        const { offsetX, offsetY, spriteSerializedLines } = command;\n        const lineArrayBuffers: ArrayBuffer[] = [];\n        spriteSerializedLines.forEach((spriteLines) => {\n          const subLineArrayBuffers: ArrayBuffer[] = [];\n          spriteLines.forEach((subSpriteLine) => {\n            const { spriteSheetIndex, spriteIndices, use2Bytes } =\n              subSpriteLine;\n            const subLineSpriteIndicesDataView = new DataView(\n              new ArrayBuffer(spriteIndices.length * (use2Bytes ? 2 : 1))\n            );\n            spriteIndices.forEach((spriteIndex, i) => {\n              if (use2Bytes) {\n                subLineSpriteIndicesDataView.setUint16(\n                  i * 2,\n                  spriteIndex,\n                  true\n                );\n              } else {\n                subLineSpriteIndicesDataView.setUint8(i, spriteIndex);\n              }\n            });\n            const subLineHeaderDataView = new DataView(new ArrayBuffer(2));\n            subLineHeaderDataView.setUint8(0, spriteSheetIndex);\n            subLineHeaderDataView.setUint8(1, spriteIndices.length);\n            subLineArrayBuffers.push(\n              concatenateArrayBuffers(\n                subLineHeaderDataView,\n                subLineSpriteIndicesDataView\n              )\n            );\n          });\n          const lineArrayHeaderDataView = new DataView(new ArrayBuffer(2));\n          const concatenatedSubLineArrayBuffers = concatenateArrayBuffers(\n            ...subLineArrayBuffers\n          );\n          lineArrayHeaderDataView.setUint16(\n            0,\n            concatenatedSubLineArrayBuffers.byteLength,\n            true\n          );\n          lineArrayBuffers.push(\n            concatenateArrayBuffers(\n              lineArrayHeaderDataView,\n              concatenatedSubLineArrayBuffers\n            )\n          );\n        });\n\n        const concatenatedLineArrayBuffers = concatenateArrayBuffers(\n          ...lineArrayBuffers\n        );\n\n        dataView = new DataView(new ArrayBuffer(2 * 3));\n        let offset = 0;\n        dataView.setInt16(offset, offsetX, true);\n        offset += 2;\n        dataView.setInt16(offset, offsetY, true);\n        offset += 2;\n        dataView.setUint16(\n          offset,\n          concatenatedLineArrayBuffers.byteLength,\n          true\n        );\n        offset += 2;\n\n        const buffer = concatenateArrayBuffers(\n          dataView,\n          concatenatedLineArrayBuffers\n        );\n        dataView = new DataView(buffer);\n      }\n      break;\n    case \"startSprite\":\n      {\n        const { offsetX, offsetY, width, height } = command;\n        dataView = new DataView(new ArrayBuffer(2 * 4));\n        dataView.setInt16(0, offsetX, true);\n        dataView.setInt16(2, offsetY, true);\n        dataView.setUint16(4, width, true);\n        dataView.setUint16(6, height, true);\n      }\n      break;\n  }\n\n  return dataView;\n}\nexport function serializeContextCommands(\n  displayManager: DisplayManagerInterface,\n  commands: DisplayContextCommand[]\n) {\n  const serializedContextCommandArray = commands\n    .filter((command) => !command.hide)\n    .map((command) => {\n      const displayContextCommandEnum = DisplayContextCommandTypes.indexOf(\n        command.type\n      );\n      const serializedContextCommand = serializeContextCommand(\n        displayManager,\n        command\n      );\n      return concatenateArrayBuffers(\n        UInt8ByteBuffer(displayContextCommandEnum),\n        serializedContextCommand\n      );\n    });\n  const serializedContextCommands = concatenateArrayBuffers(\n    serializedContextCommandArray\n  );\n  _console.log(\n    \"serializedContextCommands\",\n    commands,\n    serializedContextCommandArray,\n    serializedContextCommands\n  );\n  return serializedContextCommands;\n}\n\nconst DrawDisplayContextCommandTypes = [\n  \"drawRect\",\n  \"drawRoundRect\",\n\n  \"drawCircle\",\n  \"drawArc\",\n\n  \"drawEllipse\",\n  \"drawArcEllipse\",\n\n  \"drawSegment\",\n  \"drawSegments\",\n\n  \"drawRegularPolygon\",\n  \"drawPolygon\",\n\n  \"drawWireframe\",\n\n  \"drawQuadraticBezierCurve\",\n  \"drawQuadraticBezierCurves\",\n  \"drawCubicBezierCurve\",\n  \"drawCubicBezierCurves\",\n\n  \"drawPath\",\n  \"drawClosedPath\",\n\n  \"drawBitmap\",\n\n  \"drawSprite\",\n  \"drawSprites\",\n] as const satisfies readonly DisplayContextCommandType[];\ntype DrawDisplayContextCommandType =\n  (typeof DrawDisplayContextCommandTypes)[number];\n\nconst StateDisplayContextCommandTypes = [\n  \"setColor\",\n  \"setColorOpacity\",\n  \"setOpacity\",\n\n  \"saveContext\",\n  \"restoreContext\",\n\n  \"selectBackgroundColor\",\n  \"selectFillColor\",\n  \"selectLineColor\",\n\n  \"setIgnoreFill\",\n  \"setIgnoreLine\",\n  \"setFillBackground\",\n\n  \"setLineWidth\",\n  \"setRotation\",\n  \"clearRotation\",\n\n  \"setHorizontalAlignment\",\n  \"setVerticalAlignment\",\n  \"resetAlignment\",\n\n  \"setSegmentStartCap\",\n  \"setSegmentEndCap\",\n  \"setSegmentCap\",\n\n  \"setSegmentStartRadius\",\n  \"setSegmentEndRadius\",\n  \"setSegmentRadius\",\n\n  \"setCropTop\",\n  \"setCropRight\",\n  \"setCropBottom\",\n  \"setCropLeft\",\n  \"clearCrop\",\n\n  \"setRotationCropTop\",\n  \"setRotationCropRight\",\n  \"setRotationCropBottom\",\n  \"setRotationCropLeft\",\n  \"clearRotationCrop\",\n\n  \"selectBitmapColor\",\n  \"selectBitmapColors\",\n  \"setBitmapScaleX\",\n  \"setBitmapScaleY\",\n  \"setBitmapScale\",\n  \"resetBitmapScale\",\n\n  \"selectSpriteColor\",\n  \"selectSpriteColors\",\n  \"resetSpriteColors\",\n  \"setSpriteScaleX\",\n  \"setSpriteScaleY\",\n  \"setSpriteScale\",\n  \"resetSpriteScale\",\n\n  \"setSpritesLineHeight\",\n  \"setSpritesDirection\",\n  \"setSpritesLineDirection\",\n  \"setSpritesSpacing\",\n  \"setSpritesLineSpacing\",\n  \"setSpritesAlignment\",\n  \"setSpritesLineAlignment\",\n\n  \"selectSpriteSheet\",\n] as const satisfies readonly DisplayContextCommandType[];\ntype StateDisplayContextCommandType =\n  (typeof StateDisplayContextCommandTypes)[number];\n\nconst SpritesDisplayContextCommandTypes = [\n  \"selectSpriteColor\",\n  \"selectSpriteColors\",\n  \"resetSpriteColors\",\n  \"setSpriteScaleX\",\n  \"setSpriteScaleY\",\n  \"setSpriteScale\",\n  \"resetSpriteScale\",\n\n  \"setSpritesLineHeight\",\n  \"setSpritesDirection\",\n  \"setSpritesLineDirection\",\n  \"setSpritesSpacing\",\n  \"setSpritesLineSpacing\",\n  \"setSpritesAlignment\",\n  \"setSpritesLineAlignment\",\n\n  \"selectSpriteSheet\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type SpritesDisplayContextCommandType =\n  (typeof SpritesDisplayContextCommandTypes)[number];\n\nconst PathDrawDisplayContextCommandTypes = [\n  \"drawSegment\",\n  \"drawSegments\",\n  \"drawQuadraticBezierCurve\",\n  \"drawQuadraticBezierCurves\",\n  \"drawCubicBezierCurve\",\n  \"drawCubicBezierCurves\",\n  \"drawPath\",\n  \"drawWireframe\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type PathDrawDisplayContextCommandType =\n  (typeof PathDrawDisplayContextCommandTypes)[number];\n\nconst PathStateDisplayContextCommandTypes = [\n  \"setSegmentRadius\",\n  \"setSegmentEndRadius\",\n  \"setSegmentStartRadius\",\n  \"setSegmentCap\",\n  \"setSegmentStartCap\",\n  \"setSegmentEndCap\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type PathStateDisplayContextCommandType =\n  (typeof PathStateDisplayContextCommandTypes)[number];\n\nconst BitmapDisplayContextCommandTypes = [\n  \"selectBitmapColor\",\n  \"selectBitmapColors\",\n  \"setBitmapScaleX\",\n  \"setBitmapScaleY\",\n  \"setBitmapScale\",\n  \"resetBitmapScale\",\n] as const satisfies readonly DisplayContextCommandType[];\nexport type BitmapDisplayContextCommandType =\n  (typeof BitmapDisplayContextCommandTypes)[number];\n\nconst contextCommandDependencies: Map<\n  Set<DisplayContextCommandType>,\n  Set<DisplayContextCommandType>\n> = new Map();\nfunction appendContextCommandDependencyPair(\n  key: DisplayContextCommandType[],\n  value: DisplayContextCommandType[]\n) {\n  contextCommandDependencies.set(new Set(key), new Set(value));\n}\nappendContextCommandDependencyPair(\n  [...PathStateDisplayContextCommandTypes],\n  [...PathDrawDisplayContextCommandTypes]\n);\nappendContextCommandDependencyPair(\n  [...StateDisplayContextCommandTypes],\n  [...DrawDisplayContextCommandTypes]\n);\nappendContextCommandDependencyPair(\n  [...SpritesDisplayContextCommandTypes],\n  [\"drawSprite\", \"drawSprites\"]\n);\nappendContextCommandDependencyPair(\n  [...BitmapDisplayContextCommandTypes],\n  [\"drawBitmap\"]\n);\n\n// TODO - can refine more (e.g. if ignoreLine, then skip setLineWidth, or skip if a set value is already default, etc)\n\nexport function trimContextCommands(commands: DisplayContextCommand[]) {\n  _console.log(\"trimming commands\", commands);\n  const trimmedCommands: DisplayContextCommand[] = [];\n\n  commands\n    .slice()\n    .reverse()\n    .forEach((command) => {\n      let include = true;\n\n      let dependencies: Set<DisplayContextCommandType> | undefined;\n      for (const [keys, values] of contextCommandDependencies) {\n        if (keys.has(command.type)) {\n          dependencies = values;\n          break;\n        }\n      }\n\n      _console.log(\"command\", command, \"dependencies\", dependencies);\n\n      let similarCommandIndex = -1;\n      let dependentCommandIndex = -1;\n      if (dependencies) {\n        similarCommandIndex = trimmedCommands.findIndex((trimmedCommand) => {\n          // FILL - expand, e.g. clearRotation is similar to setRotation\n          return trimmedCommand.type == command.type;\n        });\n        dependentCommandIndex = trimmedCommands.findIndex((trimmedCommand) =>\n          dependencies.has(trimmedCommand.type)\n        );\n\n        _console.log({ similarCommandIndex, dependentCommandIndex });\n\n        if (dependentCommandIndex == -1) {\n          include = false;\n        } else if (similarCommandIndex != -1) {\n          include = similarCommandIndex > dependentCommandIndex;\n        }\n      }\n      if (include) {\n        if (\n          similarCommandIndex != -1 &&\n          deepEqual(command, trimmedCommands[similarCommandIndex])\n        ) {\n          // FILL - replace deepEqual with \"isSimilarCommand\"\n          trimmedCommands.splice(similarCommandIndex, 1);\n        }\n        trimmedCommands.unshift(command);\n      } else {\n        _console.log(\"skipping command\", command);\n      }\n    });\n\n  _console.log(\"trimmedCommands\", trimmedCommands);\n  return trimmedCommands;\n}\n","// @ts-expect-error\nimport RGBQuant from \"rgbquant\";\nimport { createConsole } from \"./Console.ts\";\nimport { hexToRGB, rgbToHex } from \"./ColorUtils.ts\";\nimport { getVector3Length, Vector3 } from \"./MathUtils.ts\";\nimport {\n  DisplayColorRGB,\n  numberOfColorsToPixelDepth,\n  pixelDepthToNumberOfColors,\n  pixelDepthToPixelBitWidth,\n  pixelDepthToPixelsPerByte,\n} from \"./DisplayUtils.ts\";\nimport { DisplayBitmap, DisplayPixelDepths } from \"../DisplayManager.ts\";\nimport {\n  calculateSpriteSheetHeaderLength,\n  DisplaySprite,\n  DisplaySpriteSheet,\n} from \"./DisplaySpriteSheetUtils.ts\";\n\nconst _console = createConsole(\"DisplayBitmapUtils\", { log: false });\n\nexport const drawBitmapHeaderLength = 2 + 2 + 2 + 4 + 1 + 2; // x, y, width, numberOfPixels, numberOfColors, dataLength\n\nexport function getBitmapData(bitmap: DisplayBitmap) {\n  const pixelDataLength = getBitmapNumberOfBytes(bitmap);\n  const dataView = new DataView(new ArrayBuffer(pixelDataLength));\n  const pixelDepth = numberOfColorsToPixelDepth(bitmap.numberOfColors)!;\n  const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);\n  bitmap.pixels.forEach((bitmapColorIndex, pixelIndex) => {\n    const byteIndex = Math.floor(pixelIndex / pixelsPerByte);\n    const byteSlot = pixelIndex % pixelsPerByte;\n    const pixelBitWidth = pixelDepthToPixelBitWidth(pixelDepth);\n    const bitOffset = pixelBitWidth * byteSlot;\n    const shift = 8 - pixelBitWidth - bitOffset;\n    let value = dataView.getUint8(byteIndex);\n    value |= bitmapColorIndex << shift;\n    dataView.setUint8(byteIndex, value);\n  });\n  _console.log(\"getBitmapData\", bitmap, dataView);\n  return dataView;\n}\n\nexport async function quantizeCanvas(\n  canvas: HTMLCanvasElement,\n  numberOfColors: number,\n  colors?: string[]\n) {\n  _console.assertWithError(\n    numberOfColors > 1,\n    \"numberOfColors must be greater than 1\"\n  );\n\n  const ctx = canvas.getContext(\"2d\", { willReadFrequently: true })!;\n  removeAlphaFromCanvas(canvas);\n\n  const isSmall = canvas.width * canvas.height < 4;\n\n  const quantOptions = {\n    method: isSmall ? 1 : 2,\n    colors: numberOfColors,\n    dithKern: null, // Disable dithering\n    useCache: false, // Disable color caching to force exact matches\n    reIndex: true, // Ensure strict re-indexing to the palette\n    orDist: \"manhattan\",\n  };\n\n  if (colors) {\n    // @ts-ignore\n    quantOptions.palette = colors.map((color) => {\n      const rgb = hexToRGB(color);\n      if (rgb) {\n        const { r, g, b } = rgb;\n        return [r, g, b];\n      } else {\n        _console.error(`invalid rgb hex \"${color}\"`);\n      }\n    });\n  }\n  //_console.log(\"quantizeImage options\", quantOptions);\n  const quantizer = new RGBQuant(quantOptions);\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  quantizer.sample(imageData);\n\n  const quantizedPixels = quantizer.reduce(imageData.data);\n  const quantizedImageData = new ImageData(\n    new Uint8ClampedArray(quantizedPixels.buffer),\n    canvas.width,\n    canvas.height\n  );\n  ctx.putImageData(quantizedImageData, 0, 0);\n\n  const pixels = quantizedImageData.data;\n\n  const quantizedPaletteData: Uint8Array = quantizer.palette();\n  const numberOfQuantizedPaletteColors = quantizedPaletteData.byteLength / 4;\n  //_console.log(\"quantizedPaletteData\", quantizedPaletteData);\n  const quantizedPaletteColors: DisplayColorRGB[] = [];\n  let closestColorIndexToBlack = 0;\n  let closestColorDistanceToBlack = Infinity;\n  const vector3: Vector3 = { x: 0, y: 0, z: 0 };\n  for (\n    let colorIndex = 0;\n    colorIndex < numberOfQuantizedPaletteColors;\n    colorIndex++\n  ) {\n    const rgb: DisplayColorRGB = {\n      r: quantizedPaletteData[colorIndex * 4],\n      g: quantizedPaletteData[colorIndex * 4 + 1],\n      b: quantizedPaletteData[colorIndex * 4 + 2],\n    };\n    quantizedPaletteColors.push(rgb);\n    vector3.x = rgb.r;\n    vector3.y = rgb.g;\n    vector3.z = rgb.b;\n\n    const distanceToBlack = getVector3Length(vector3);\n    if (distanceToBlack < closestColorDistanceToBlack) {\n      closestColorDistanceToBlack = distanceToBlack;\n      closestColorIndexToBlack = colorIndex;\n    }\n  }\n  //_console.log({ closestColorIndexToBlack, closestColorDistanceToBlack });\n  if (closestColorIndexToBlack != 0) {\n    const [currentBlack, newBlack] = [\n      quantizedPaletteColors[0],\n      quantizedPaletteColors[closestColorIndexToBlack],\n    ];\n    quantizedPaletteColors[0] = newBlack;\n    quantizedPaletteColors[closestColorIndexToBlack] = currentBlack;\n  }\n  //_console.log(\"quantizedPaletteColors\", quantizedPaletteColors);\n  const quantizedColors = quantizedPaletteColors.map((rgb, index) => {\n    const hex = rgbToHex(rgb);\n    return hex;\n  });\n  //_console.log(\"quantizedColors\", quantizedColors);\n\n  const quantizedColorIndices: number[] = [];\n  for (let i = 0; i < pixels.length; i += 4) {\n    const r = pixels[i];\n    const g = pixels[i + 1];\n    const b = pixels[i + 2];\n    const a = pixels[i + 3];\n\n    const hex = rgbToHex({ r, g, b });\n    quantizedColorIndices.push(quantizedColors.indexOf(hex));\n  }\n  //_console.log(\"quantizedColorIndices\", quantizedColorIndices);\n\n  const promise = new Promise<Blob>((resolve, reject) => {\n    canvas.toBlob((blob) => {\n      if (blob) {\n        resolve(blob);\n      } else {\n        reject();\n      }\n    }, \"image/png\");\n  });\n\n  const blob = await promise;\n  return {\n    blob,\n    colors: quantizedColors,\n    colorIndices: quantizedColorIndices,\n  };\n}\n\nexport async function quantizeImage(\n  image: HTMLImageElement,\n  width: number,\n  height: number,\n  numberOfColors: number,\n  colors?: string[],\n  canvas?: HTMLCanvasElement\n) {\n  canvas = canvas || document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\", { willReadFrequently: true })!;\n\n  let { naturalWidth: imageWidth, naturalHeight: imageHeight } = image;\n  _console.log({ imageWidth, imageHeight });\n\n  canvas.width = width;\n  canvas.height = height;\n\n  ctx.imageSmoothingEnabled = false;\n\n  ctx.drawImage(image, 0, 0, width, height);\n\n  return quantizeCanvas(canvas, numberOfColors, colors);\n}\n\nexport function resizeImage(\n  image: CanvasImageSource,\n  width: number,\n  height: number,\n  canvas?: HTMLCanvasElement\n) {\n  canvas = canvas || document.createElement(\"canvas\");\n\n  const ctx = canvas.getContext(\"2d\", { willReadFrequently: true })!;\n\n  canvas.width = width;\n  canvas.height = height;\n\n  ctx.imageSmoothingEnabled = false;\n\n  ctx.drawImage(image, 0, 0, width, height);\n\n  return canvas;\n}\nexport function cropCanvas(\n  canvas: HTMLCanvasElement,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  targetCanvas?: HTMLCanvasElement\n) {\n  targetCanvas = targetCanvas || document.createElement(\"canvas\");\n  const ctx = targetCanvas.getContext(\"2d\", { willReadFrequently: true })!;\n\n  targetCanvas.width = width;\n  targetCanvas.height = height;\n\n  ctx.imageSmoothingEnabled = false;\n  ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);\n\n  return targetCanvas;\n}\nexport function removeAlphaFromCanvas(canvas: HTMLCanvasElement) {\n  const ctx = canvas.getContext(\"2d\", { willReadFrequently: true })!;\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n\n  // turn any non-opaque pixel to black\n  for (let i = 0; i < data.length; i += 4) {\n    const alpha = data[i + 3];\n\n    if (alpha < 255) {\n      data[i] = 0;\n      data[i + 1] = 0;\n      data[i + 2] = 0;\n      data[i + 3] = 255;\n    }\n  }\n\n  ctx.putImageData(imageData, 0, 0);\n\n  return canvas;\n}\n\nexport async function canvasToBlob(\n  canvas: HTMLCanvasElement,\n  type: \"image/png\" | \"image/jpeg\" = \"image/jpeg\",\n  quality: number = 1\n) {\n  const promise = new Promise<Blob>((resolve, reject) => {\n    canvas.toBlob(\n      (blob) => {\n        if (blob) {\n          resolve(blob);\n        } else {\n          reject();\n        }\n      },\n      type,\n      quality\n    );\n  });\n  const blob = await promise;\n  return blob;\n}\n\nexport async function resizeAndQuantizeImage(\n  image: CanvasImageSource,\n  width: number,\n  height: number,\n  numberOfColors: number,\n  colors?: string[],\n  canvas?: HTMLCanvasElement\n) {\n  canvas = canvas || document.createElement(\"canvas\");\n  resizeImage(image, width, height, canvas);\n  removeAlphaFromCanvas(canvas);\n  return quantizeCanvas(canvas, numberOfColors, colors);\n}\n\nexport async function imageToBitmap(\n  image: CanvasImageSource,\n  width: number,\n  height: number,\n  colors: string[],\n  bitmapColorIndices: number[],\n  numberOfColors?: number\n) {\n  if (numberOfColors == undefined) {\n    numberOfColors = colors.length;\n  }\n  const bitmapColors = bitmapColorIndices\n    .map((bitmapColorIndex) => colors[bitmapColorIndex])\n    .slice(0, numberOfColors);\n  const { blob, colorIndices } = await resizeAndQuantizeImage(\n    image,\n    width,\n    height,\n    numberOfColors,\n    bitmapColors\n  );\n  const bitmap: DisplayBitmap = {\n    numberOfColors,\n    pixels: colorIndices,\n    width,\n    height,\n  };\n  return { blob, bitmap };\n}\n\nconst drawSpriteBitmapCommandHeaderLength = 1 + 2 + 2 + 2 + 2 + 1 + 2; // command, offetXY, width, numberOfPixels, numberOfColors, pixelDataLength\nexport async function canvasToBitmaps(\n  canvas: HTMLCanvasElement,\n  numberOfColors: number,\n  mtu: number\n) {\n  const { blob, colors, colorIndices } = await quantizeCanvas(\n    canvas,\n    numberOfColors\n  );\n  const bitmapRows: DisplayBitmap[][] = [];\n\n  const { width, height } = canvas;\n\n  const numberOfPixels = width * height;\n  const pixelDepth = DisplayPixelDepths.find(\n    (pixelDepth) => pixelDepthToNumberOfColors(pixelDepth) >= numberOfColors\n  )!;\n  _console.assertWithError(\n    pixelDepth,\n    `no pixelDepth found that covers ${numberOfColors} colors`\n  );\n  const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);\n  const numberOfBytes = Math.ceil(numberOfPixels / pixelsPerByte);\n  _console.log({\n    width,\n    height,\n    numberOfPixels,\n    pixelDepth,\n    pixelsPerByte,\n    numberOfBytes,\n    mtu,\n  });\n\n  const maxPixelDataLength = mtu - (drawSpriteBitmapCommandHeaderLength + 5);\n  const maxPixels = Math.floor(maxPixelDataLength / pixelsPerByte);\n  const maxBitmapWidth = Math.min(maxPixels, width);\n  let maxBitmapHeight = 1;\n  if (maxBitmapWidth == width) {\n    const bitmapRowPixelDataLength = Math.ceil(width / pixelsPerByte);\n    maxBitmapHeight = Math.floor(maxPixelDataLength / bitmapRowPixelDataLength);\n  }\n  _console.log({\n    maxPixelDataLength,\n    maxPixels,\n    maxBitmapHeight,\n    maxBitmapWidth,\n  });\n\n  if (maxBitmapHeight >= height) {\n    _console.log(\"image is small enough for a single bitmap\");\n\n    const bitmap: DisplayBitmap = {\n      numberOfColors,\n      pixels: colorIndices,\n      width,\n      height,\n    };\n    bitmapRows.push([bitmap]);\n  } else {\n    let offsetX = 0;\n    let offsetY = 0;\n    const bitmapCanvas: HTMLCanvasElement = document.createElement(\"canvas\");\n    const bitmapColorIndices: number[] = new Array(numberOfColors)\n      .fill(0)\n      .map((_, i) => i);\n    while (offsetY < height) {\n      const bitmapHeight = Math.min(maxBitmapHeight, height - offsetY);\n      offsetX = 0;\n      const bitmapRow: DisplayBitmap[] = [];\n      bitmapRows.push(bitmapRow);\n\n      while (offsetX < width) {\n        const bitmapWidth = Math.min(maxBitmapWidth, width - offsetX);\n        cropCanvas(\n          canvas,\n          offsetX,\n          offsetY,\n          bitmapWidth,\n          bitmapHeight,\n          bitmapCanvas\n        );\n        // _console.log(`cropping bitmap`, {\n        //   bitmapWidth,\n        //   bitmapHeight,\n        //   offsetX,\n        //   offsetY,\n        // });\n        const { bitmap } = await imageToBitmap(\n          bitmapCanvas,\n          bitmapWidth,\n          bitmapHeight,\n          colors,\n          bitmapColorIndices,\n          numberOfColors\n        );\n        // _console.log(\"bitmap\", bitmap);\n        bitmapRow.push(bitmap);\n        offsetX += bitmapWidth;\n      }\n      offsetY += bitmapHeight;\n    }\n  }\n\n  return { bitmapRows, colors };\n}\nexport async function imageToBitmaps(\n  image: HTMLImageElement,\n  width: number,\n  height: number,\n  numberOfColors: number,\n  mtu: number\n) {\n  const canvas = resizeImage(image, width, height);\n  return canvasToBitmaps(canvas, numberOfColors, mtu);\n}\n\nexport function getBitmapNumberOfBytes(bitmap: DisplayBitmap) {\n  const pixelDepth = numberOfColorsToPixelDepth(bitmap.numberOfColors)!;\n  const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);\n  const numberOfPixels = bitmap.pixels.length;\n  const pixelDataLength = Math.ceil(numberOfPixels / pixelsPerByte);\n  _console.log({\n    pixelDepth,\n    pixelsPerByte,\n    numberOfPixels,\n    pixelDataLength,\n  });\n  return pixelDataLength;\n}\nexport function assertValidBitmapPixels(bitmap: DisplayBitmap) {\n  _console.assertRangeWithError(\n    \"bitmap.pixels.length\",\n    bitmap.pixels.length,\n    bitmap.width * (bitmap.height - 1) + 1,\n    bitmap.width * bitmap.height\n  );\n  bitmap.pixels.forEach((pixel, index) => {\n    _console.assertRangeWithError(\n      `bitmap.pixels[${index}]`,\n      pixel,\n      0,\n      bitmap.numberOfColors - 1\n    );\n  });\n}\n\nexport async function canvasToSprite(\n  canvas: HTMLCanvasElement,\n  spriteName: string,\n  numberOfColors: number,\n  paletteName: string,\n  overridePalette: boolean,\n  spriteSheet: DisplaySpriteSheet,\n  paletteOffset = 0\n) {\n  const { width, height } = canvas;\n\n  let palette = spriteSheet.palettes?.find(\n    (palette) => palette.name == paletteName\n  );\n  if (!palette) {\n    palette = {\n      name: paletteName,\n      numberOfColors,\n      colors: new Array(numberOfColors).fill(\"#000000\"),\n    };\n    spriteSheet.palettes = spriteSheet.palettes || [];\n    spriteSheet.palettes?.push(palette);\n  }\n  _console.log(\"pallete\", palette);\n\n  // _console.assertWithError(\n  //   numberOfColors + paletteOffset <= palette.numberOfColors,\n  //   `invalid numberOfColors ${numberOfColors} + offset ${paletteOffset} (max ${palette.numberOfColors})`\n  // );\n\n  const sprite: DisplaySprite = {\n    name: spriteName,\n    width,\n    height,\n    paletteSwaps: [],\n    commands: [],\n  };\n\n  const results = await quantizeCanvas(\n    canvas,\n    numberOfColors,\n    !overridePalette ? palette.colors : undefined\n  );\n  const blob = results.blob;\n  const colorIndices = results.colorIndices;\n  if (overridePalette) {\n    results.colors.forEach((color, index) => {\n      palette.colors[index + paletteOffset] = color;\n    });\n  }\n\n  sprite.commands.push({\n    type: \"selectBitmapColors\",\n    bitmapColorPairs: new Array(numberOfColors).fill(0).map((_, index) => ({\n      bitmapColorIndex: index,\n      colorIndex: index + paletteOffset,\n    })),\n  });\n  const bitmap: DisplayBitmap = {\n    numberOfColors,\n    pixels: colorIndices,\n    width,\n    height,\n  };\n  sprite.commands.push({ type: \"drawBitmap\", offsetX: 0, offsetY: 0, bitmap });\n\n  const spriteIndex = spriteSheet.sprites.findIndex(\n    (sprite) => sprite.name == spriteName\n  );\n  if (spriteIndex == -1) {\n    spriteSheet.sprites.push(sprite);\n  } else {\n    _console.log(`overwriting spriteIndex ${spriteIndex}`);\n    spriteSheet.sprites[spriteIndex] = sprite;\n  }\n\n  return { sprite, blob };\n}\nexport async function imageToSprite(\n  image: HTMLImageElement,\n  spriteName: string,\n  width: number,\n  height: number,\n  numberOfColors: number,\n  paletteName: string,\n  overridePalette: boolean,\n  spriteSheet: DisplaySpriteSheet,\n  paletteOffset = 0\n) {\n  const canvas = resizeImage(image, width, height);\n  return canvasToSprite(\n    canvas,\n    spriteName,\n    numberOfColors,\n    paletteName,\n    overridePalette,\n    spriteSheet,\n    paletteOffset\n  );\n}\n\nconst spriteSheetWithSingleBitmapCommandLength =\n  calculateSpriteSheetHeaderLength(1) + drawSpriteBitmapCommandHeaderLength;\nfunction spriteSheetWithBitmapCommandAndSelectBitmapColorsLength(\n  numberOfColors: number\n) {\n  return (\n    spriteSheetWithSingleBitmapCommandLength + (1 + 1 + numberOfColors * 2)\n  ); // command, numberOfPairs, ...pairs\n}\n\nexport async function canvasToSpriteSheet(\n  canvas: HTMLCanvasElement,\n  spriteSheetName: string,\n  spriteName: string,\n  numberOfColors: number,\n  paletteName: string,\n  maxFileLength?: number\n) {\n  const spriteSheet: DisplaySpriteSheet = {\n    name: spriteSheetName,\n    palettes: [],\n    paletteSwaps: [],\n    sprites: [],\n  };\n\n  if (maxFileLength == undefined) {\n    await canvasToSprite(\n      canvas,\n      spriteName,\n      numberOfColors,\n      paletteName,\n      true,\n      spriteSheet\n    );\n  } else {\n    const { width, height } = canvas;\n    const numberOfPixels = width * height;\n    const pixelDepth = DisplayPixelDepths.find(\n      (pixelDepth) => pixelDepthToNumberOfColors(pixelDepth) >= numberOfColors\n    )!;\n    _console.assertWithError(\n      pixelDepth,\n      `no pixelDepth found that covers ${numberOfColors} colors`\n    );\n    const pixelsPerByte = pixelDepthToPixelsPerByte(pixelDepth);\n    const numberOfBytes = Math.ceil(numberOfPixels / pixelsPerByte);\n    _console.log({\n      width,\n      height,\n      numberOfPixels,\n      pixelDepth,\n      pixelsPerByte,\n      numberOfBytes,\n      maxFileLength,\n    });\n\n    const maxPixelDataLength =\n      maxFileLength -\n      (spriteSheetWithBitmapCommandAndSelectBitmapColorsLength(numberOfColors) +\n        5);\n    const imageRowPixelDataLength = Math.ceil(width / pixelsPerByte);\n    const maxSpriteHeight = Math.floor(\n      maxPixelDataLength / imageRowPixelDataLength\n    );\n    // _console.log({\n    //   maxPixelDataLength,\n    //   imageRowPixelDataLength,\n    //   maxSpriteHeight,\n    // });\n\n    if (maxSpriteHeight >= height) {\n      _console.log(\"image is small enough for a single sprite\");\n      await canvasToSprite(\n        canvas,\n        spriteName,\n        numberOfColors,\n        paletteName,\n        true,\n        spriteSheet\n      );\n    } else {\n      const { colors } = await quantizeCanvas(canvas, numberOfColors);\n      spriteSheet.palettes?.push({ name: paletteName, numberOfColors, colors });\n\n      let offsetY = 0;\n      let imageIndex = 0;\n      const spriteCanvas: HTMLCanvasElement = document.createElement(\"canvas\");\n\n      while (offsetY < height) {\n        const spriteHeight = Math.min(maxSpriteHeight, height - offsetY);\n        cropCanvas(canvas, 0, offsetY, width, spriteHeight, spriteCanvas);\n        offsetY += spriteHeight;\n        _console.log(`cropping sprite ${imageIndex}`, {\n          offsetY,\n          width,\n          spriteHeight,\n        });\n        await canvasToSprite(\n          spriteCanvas,\n          `image${imageIndex}`,\n          numberOfColors,\n          paletteName,\n          false,\n          spriteSheet\n        );\n        imageIndex++;\n      }\n    }\n  }\n\n  return spriteSheet;\n}\n\nexport async function imageToSpriteSheet(\n  image: HTMLImageElement,\n  spriteSheetName: string,\n  spriteName: string,\n  width: number,\n  height: number,\n  numberOfColors: number,\n  paletteName: string,\n  maxFileLength?: number\n) {\n  const canvas = resizeImage(image, width, height);\n  return canvasToSpriteSheet(\n    canvas,\n    spriteSheetName,\n    spriteName,\n    numberOfColors,\n    paletteName,\n    maxFileLength\n  );\n}\n","/**\n * https://opentype.js.org v1.3.4 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens\n */\n\n/*! https://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tvar string = String(this);\n\t\t\tvar size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tvar index = position ? Number(position) : 0;\n\t\t\tif (index != index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tvar first = string.charCodeAt(index);\n\t\t\tvar second;\n\t\t\tif ( // check if its the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n\nvar TINF_OK = 0;\nvar TINF_DATA_ERROR = -3;\n\nfunction Tree() {\n  this.table = new Uint16Array(16);   /* table of code length counts */\n  this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n}\n\nfunction Data(source, dest) {\n  this.source = source;\n  this.sourceIndex = 0;\n  this.tag = 0;\n  this.bitcount = 0;\n  \n  this.dest = dest;\n  this.destLen = 0;\n  \n  this.ltree = new Tree();  /* dynamic length/symbol tree */\n  this.dtree = new Tree();  /* dynamic distance tree */\n}\n\n/* --------------------------------------------------- *\n * -- uninitialized global data (static structures) -- *\n * --------------------------------------------------- */\n\nvar sltree = new Tree();\nvar sdtree = new Tree();\n\n/* extra bits and base tables for length codes */\nvar length_bits = new Uint8Array(30);\nvar length_base = new Uint16Array(30);\n\n/* extra bits and base tables for distance codes */\nvar dist_bits = new Uint8Array(30);\nvar dist_base = new Uint16Array(30);\n\n/* special ordering of code length codes */\nvar clcidx = new Uint8Array([\n  16, 17, 18, 0, 8, 7, 9, 6,\n  10, 5, 11, 4, 12, 3, 13, 2,\n  14, 1, 15\n]);\n\n/* used by tinf_decode_trees, avoids allocations every call */\nvar code_tree = new Tree();\nvar lengths = new Uint8Array(288 + 32);\n\n/* ----------------------- *\n * -- utility functions -- *\n * ----------------------- */\n\n/* build extra bits and base tables */\nfunction tinf_build_bits_base(bits, base, delta, first) {\n  var i, sum;\n\n  /* build bits table */\n  for (i = 0; i < delta; ++i) { bits[i] = 0; }\n  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }\n\n  /* build base table */\n  for (sum = first, i = 0; i < 30; ++i) {\n    base[i] = sum;\n    sum += 1 << bits[i];\n  }\n}\n\n/* build the fixed huffman trees */\nfunction tinf_build_fixed_trees(lt, dt) {\n  var i;\n\n  /* build fixed length tree */\n  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }\n\n  lt.table[7] = 24;\n  lt.table[8] = 152;\n  lt.table[9] = 112;\n\n  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }\n  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }\n  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }\n  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }\n\n  /* build fixed distance tree */\n  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }\n\n  dt.table[5] = 32;\n\n  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }\n}\n\n/* given an array of code lengths, build a tree */\nvar offs = new Uint16Array(16);\n\nfunction tinf_build_tree(t, lengths, off, num) {\n  var i, sum;\n\n  /* clear code length count table */\n  for (i = 0; i < 16; ++i) { t.table[i] = 0; }\n\n  /* scan symbol lengths, and sum code length counts */\n  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }\n\n  t.table[0] = 0;\n\n  /* compute offset table for distribution sort */\n  for (sum = 0, i = 0; i < 16; ++i) {\n    offs[i] = sum;\n    sum += t.table[i];\n  }\n\n  /* create code->symbol translation table (symbols sorted by code) */\n  for (i = 0; i < num; ++i) {\n    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }\n  }\n}\n\n/* ---------------------- *\n * -- decode functions -- *\n * ---------------------- */\n\n/* get one bit from source stream */\nfunction tinf_getbit(d) {\n  /* check if tag is empty */\n  if (!d.bitcount--) {\n    /* load next tag */\n    d.tag = d.source[d.sourceIndex++];\n    d.bitcount = 7;\n  }\n\n  /* shift bit out of tag */\n  var bit = d.tag & 1;\n  d.tag >>>= 1;\n\n  return bit;\n}\n\n/* read a num bit value from a stream and add base */\nfunction tinf_read_bits(d, num, base) {\n  if (!num)\n    { return base; }\n\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n\n  var val = d.tag & (0xffff >>> (16 - num));\n  d.tag >>>= num;\n  d.bitcount -= num;\n  return val + base;\n}\n\n/* given a data stream and a tree, decode a symbol */\nfunction tinf_decode_symbol(d, t) {\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n  \n  var sum = 0, cur = 0, len = 0;\n  var tag = d.tag;\n\n  /* get more bits while code value is above sum */\n  do {\n    cur = 2 * cur + (tag & 1);\n    tag >>>= 1;\n    ++len;\n\n    sum += t.table[len];\n    cur -= t.table[len];\n  } while (cur >= 0);\n  \n  d.tag = tag;\n  d.bitcount -= len;\n\n  return t.trans[sum + cur];\n}\n\n/* given a data stream, decode dynamic trees from it */\nfunction tinf_decode_trees(d, lt, dt) {\n  var hlit, hdist, hclen;\n  var i, num, length;\n\n  /* get 5 bits HLIT (257-286) */\n  hlit = tinf_read_bits(d, 5, 257);\n\n  /* get 5 bits HDIST (1-32) */\n  hdist = tinf_read_bits(d, 5, 1);\n\n  /* get 4 bits HCLEN (4-19) */\n  hclen = tinf_read_bits(d, 4, 4);\n\n  for (i = 0; i < 19; ++i) { lengths[i] = 0; }\n\n  /* read code lengths for code length alphabet */\n  for (i = 0; i < hclen; ++i) {\n    /* get 3 bits code length (0-7) */\n    var clen = tinf_read_bits(d, 3, 0);\n    lengths[clcidx[i]] = clen;\n  }\n\n  /* build code length tree */\n  tinf_build_tree(code_tree, lengths, 0, 19);\n\n  /* decode code lengths for the dynamic trees */\n  for (num = 0; num < hlit + hdist;) {\n    var sym = tinf_decode_symbol(d, code_tree);\n\n    switch (sym) {\n      case 16:\n        /* copy previous code length 3-6 times (read 2 bits) */\n        var prev = lengths[num - 1];\n        for (length = tinf_read_bits(d, 2, 3); length; --length) {\n          lengths[num++] = prev;\n        }\n        break;\n      case 17:\n        /* repeat code length 0 for 3-10 times (read 3 bits) */\n        for (length = tinf_read_bits(d, 3, 3); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      case 18:\n        /* repeat code length 0 for 11-138 times (read 7 bits) */\n        for (length = tinf_read_bits(d, 7, 11); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      default:\n        /* values 0-15 represent the actual code lengths */\n        lengths[num++] = sym;\n        break;\n    }\n  }\n\n  /* build dynamic trees */\n  tinf_build_tree(lt, lengths, 0, hlit);\n  tinf_build_tree(dt, lengths, hlit, hdist);\n}\n\n/* ----------------------------- *\n * -- block inflate functions -- *\n * ----------------------------- */\n\n/* given a stream and two trees, inflate a block of data */\nfunction tinf_inflate_block_data(d, lt, dt) {\n  while (1) {\n    var sym = tinf_decode_symbol(d, lt);\n\n    /* check for end of block */\n    if (sym === 256) {\n      return TINF_OK;\n    }\n\n    if (sym < 256) {\n      d.dest[d.destLen++] = sym;\n    } else {\n      var length, dist, offs;\n      var i;\n\n      sym -= 257;\n\n      /* possibly get more bits from length code */\n      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n      dist = tinf_decode_symbol(d, dt);\n\n      /* possibly get more bits from distance code */\n      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n      /* copy match */\n      for (i = offs; i < offs + length; ++i) {\n        d.dest[d.destLen++] = d.dest[i];\n      }\n    }\n  }\n}\n\n/* inflate an uncompressed block of data */\nfunction tinf_inflate_uncompressed_block(d) {\n  var length, invlength;\n  var i;\n  \n  /* unread from bitbuffer */\n  while (d.bitcount > 8) {\n    d.sourceIndex--;\n    d.bitcount -= 8;\n  }\n\n  /* get length */\n  length = d.source[d.sourceIndex + 1];\n  length = 256 * length + d.source[d.sourceIndex];\n\n  /* get one's complement of length */\n  invlength = d.source[d.sourceIndex + 3];\n  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n  /* check length */\n  if (length !== (~invlength & 0x0000ffff))\n    { return TINF_DATA_ERROR; }\n\n  d.sourceIndex += 4;\n\n  /* copy block */\n  for (i = length; i; --i)\n    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }\n\n  /* make sure we start next block on a byte boundary */\n  d.bitcount = 0;\n\n  return TINF_OK;\n}\n\n/* inflate stream from source to dest */\nfunction tinf_uncompress(source, dest) {\n  var d = new Data(source, dest);\n  var bfinal, btype, res;\n\n  do {\n    /* read final block flag */\n    bfinal = tinf_getbit(d);\n\n    /* read block type (2 bits) */\n    btype = tinf_read_bits(d, 2, 0);\n\n    /* decompress block */\n    switch (btype) {\n      case 0:\n        /* decompress uncompressed block */\n        res = tinf_inflate_uncompressed_block(d);\n        break;\n      case 1:\n        /* decompress block with fixed huffman trees */\n        res = tinf_inflate_block_data(d, sltree, sdtree);\n        break;\n      case 2:\n        /* decompress block with dynamic huffman trees */\n        tinf_decode_trees(d, d.ltree, d.dtree);\n        res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n        break;\n      default:\n        res = TINF_DATA_ERROR;\n    }\n\n    if (res !== TINF_OK)\n      { throw new Error('Data error'); }\n\n  } while (!bfinal);\n\n  if (d.destLen < d.dest.length) {\n    if (typeof d.dest.slice === 'function')\n      { return d.dest.slice(0, d.destLen); }\n    else\n      { return d.dest.subarray(0, d.destLen); }\n  }\n  \n  return d.dest;\n}\n\n/* -------------------- *\n * -- initialization -- *\n * -------------------- */\n\n/* build fixed huffman trees */\ntinf_build_fixed_trees(sltree, sdtree);\n\n/* build extra bits and base tables */\ntinf_build_bits_base(length_bits, length_base, 4, 3);\ntinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n/* fix a special case */\nlength_bits[28] = 0;\nlength_base[28] = 258;\n\nvar tinyInflate = tinf_uncompress;\n\n// The Bounding Box object\n\nfunction derive(v0, v1, v2, v3, t) {\n    return Math.pow(1 - t, 3) * v0 +\n        3 * Math.pow(1 - t, 2) * t * v1 +\n        3 * (1 - t) * Math.pow(t, 2) * v2 +\n        Math.pow(t, 3) * v3;\n}\n/**\n * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.\n * It is used to calculate the bounding box of a glyph or text path.\n *\n * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.\n *\n * @exports opentype.BoundingBox\n * @class\n * @constructor\n */\nfunction BoundingBox() {\n    this.x1 = Number.NaN;\n    this.y1 = Number.NaN;\n    this.x2 = Number.NaN;\n    this.y2 = Number.NaN;\n}\n\n/**\n * Returns true if the bounding box is empty, that is, no points have been added to the box yet.\n */\nBoundingBox.prototype.isEmpty = function() {\n    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);\n};\n\n/**\n * Add the point to the bounding box.\n * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.\n * @param {number} x - The X coordinate of the point.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addPoint = function(x, y) {\n    if (typeof x === 'number') {\n        if (isNaN(this.x1) || isNaN(this.x2)) {\n            this.x1 = x;\n            this.x2 = x;\n        }\n        if (x < this.x1) {\n            this.x1 = x;\n        }\n        if (x > this.x2) {\n            this.x2 = x;\n        }\n    }\n    if (typeof y === 'number') {\n        if (isNaN(this.y1) || isNaN(this.y2)) {\n            this.y1 = y;\n            this.y2 = y;\n        }\n        if (y < this.y1) {\n            this.y1 = y;\n        }\n        if (y > this.y2) {\n            this.y2 = y;\n        }\n    }\n};\n\n/**\n * Add a X coordinate to the bounding box.\n * This extends the bounding box to include the X coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} x - The X coordinate of the point.\n */\nBoundingBox.prototype.addX = function(x) {\n    this.addPoint(x, null);\n};\n\n/**\n * Add a Y coordinate to the bounding box.\n * This extends the bounding box to include the Y coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addY = function(y) {\n    this.addPoint(null, y);\n};\n\n/**\n * Add a Bzier curve to the bounding box.\n * This extends the bounding box to include the entire Bzier.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the first control point.\n * @param {number} y1 - The Y coordinate of the first control point.\n * @param {number} x2 - The X coordinate of the second control point.\n * @param {number} y2 - The Y coordinate of the second control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {\n    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // and https://github.com/icons8/svg-path-bounding-box\n\n    var p0 = [x0, y0];\n    var p1 = [x1, y1];\n    var p2 = [x2, y2];\n    var p3 = [x, y];\n\n    this.addPoint(x0, y0);\n    this.addPoint(x, y);\n\n    for (var i = 0; i <= 1; i++) {\n        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n        var c = 3 * p1[i] - 3 * p0[i];\n\n        if (a === 0) {\n            if (b === 0) { continue; }\n            var t = -c / b;\n            if (0 < t && t < 1) {\n                if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n                if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n            }\n            continue;\n        }\n\n        var b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) { continue; }\n        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n        }\n        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n        }\n    }\n};\n\n/**\n * Add a quadratic curve to the bounding box.\n * This extends the bounding box to include the entire quadratic curve.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the control point.\n * @param {number} y1 - The Y coordinate of the control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {\n    var cp1x = x0 + 2 / 3 * (x1 - x0);\n    var cp1y = y0 + 2 / 3 * (y1 - y0);\n    var cp2x = cp1x + 1 / 3 * (x - x0);\n    var cp2y = cp1y + 1 / 3 * (y - y0);\n    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);\n};\n\n// Geometric objects\n\n/**\n * A bzier path containing a set of path commands similar to a SVG path.\n * Paths can be drawn on a context using `draw`.\n * @exports opentype.Path\n * @class\n * @constructor\n */\nfunction Path() {\n    this.commands = [];\n    this.fill = 'black';\n    this.stroke = null;\n    this.strokeWidth = 1;\n}\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.moveTo = function(x, y) {\n    this.commands.push({\n        type: 'M',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.lineTo = function(x, y) {\n    this.commands.push({\n        type: 'L',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws cubic curve\n * @function\n * curveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws cubic curve\n * @function\n * bezierCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n * @see curveTo\n */\nPath.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {\n    this.commands.push({\n        type: 'C',\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws quadratic curve\n * @function\n * quadraticCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws quadratic curve\n * @function\n * quadTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\nPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {\n    this.commands.push({\n        type: 'Q',\n        x1: x1,\n        y1: y1,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Closes the path\n * @function closePath\n * @memberof opentype.Path.prototype\n */\n\n/**\n * Close the path\n * @function close\n * @memberof opentype.Path.prototype\n */\nPath.prototype.close = Path.prototype.closePath = function() {\n    this.commands.push({\n        type: 'Z'\n    });\n};\n\n/**\n * Add the given path or list of commands to the commands of this path.\n * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n */\nPath.prototype.extend = function(pathOrCommands) {\n    if (pathOrCommands.commands) {\n        pathOrCommands = pathOrCommands.commands;\n    } else if (pathOrCommands instanceof BoundingBox) {\n        var box = pathOrCommands;\n        this.moveTo(box.x1, box.y1);\n        this.lineTo(box.x2, box.y1);\n        this.lineTo(box.x2, box.y2);\n        this.lineTo(box.x1, box.y2);\n        this.close();\n        return;\n    }\n\n    Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n\n/**\n * Calculate the bounding box of the path.\n * @returns {opentype.BoundingBox}\n */\nPath.prototype.getBoundingBox = function() {\n    var box = new BoundingBox();\n\n    var startX = 0;\n    var startY = 0;\n    var prevX = 0;\n    var prevY = 0;\n    for (var i = 0; i < this.commands.length; i++) {\n        var cmd = this.commands[i];\n        switch (cmd.type) {\n            case 'M':\n                box.addPoint(cmd.x, cmd.y);\n                startX = prevX = cmd.x;\n                startY = prevY = cmd.y;\n                break;\n            case 'L':\n                box.addPoint(cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Q':\n                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'C':\n                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Z':\n                prevX = startX;\n                prevY = startY;\n                break;\n            default:\n                throw new Error('Unexpected path command ' + cmd.type);\n        }\n    }\n    if (box.isEmpty()) {\n        box.addPoint(0, 0);\n    }\n    return box;\n};\n\n/**\n * Draw the path to a 2D context.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.\n */\nPath.prototype.draw = function(ctx) {\n    ctx.beginPath();\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            ctx.moveTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            ctx.lineTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            ctx.closePath();\n        }\n    }\n\n    if (this.fill) {\n        ctx.fillStyle = this.fill;\n        ctx.fill();\n    }\n\n    if (this.stroke) {\n        ctx.strokeStyle = this.stroke;\n        ctx.lineWidth = this.strokeWidth;\n        ctx.stroke();\n    }\n};\n\n/**\n * Convert the Path to a string of path data instructions\n * See http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toPathData = function(decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n    function floatToString(v) {\n        if (Math.round(v) === v) {\n            return '' + Math.round(v);\n        } else {\n            return v.toFixed(decimalPlaces);\n        }\n    }\n\n    function packValues() {\n        var arguments$1 = arguments;\n\n        var s = '';\n        for (var i = 0; i < arguments.length; i += 1) {\n            var v = arguments$1[i];\n            if (v >= 0 && i > 0) {\n                s += ' ';\n            }\n\n            s += floatToString(v);\n        }\n\n        return s;\n    }\n\n    var d = '';\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            d += 'M' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            d += 'L' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            d += 'Z';\n        }\n    }\n\n    return d;\n};\n\n/**\n * Convert the path to an SVG <path> element, as a string.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toSVG = function(decimalPlaces) {\n    var svg = '<path d=\"';\n    svg += this.toPathData(decimalPlaces);\n    svg += '\"';\n    if (this.fill && this.fill !== 'black') {\n        if (this.fill === null) {\n            svg += ' fill=\"none\"';\n        } else {\n            svg += ' fill=\"' + this.fill + '\"';\n        }\n    }\n\n    if (this.stroke) {\n        svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n    }\n\n    svg += '/>';\n    return svg;\n};\n\n/**\n * Convert the path to a DOM element.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {SVGPathElement}\n */\nPath.prototype.toDOMElement = function(decimalPlaces) {\n    var temporaryPath = this.toPathData(decimalPlaces);\n    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n    newPath.setAttribute('d', temporaryPath);\n\n    return newPath;\n};\n\n// Run-time checking of preconditions.\n\nfunction fail(message) {\n    throw new Error(message);\n}\n\n// Precondition function that checks if the given predicate is true.\n// If not, it will throw an error.\nfunction argument(predicate, message) {\n    if (!predicate) {\n        fail(message);\n    }\n}\nvar check = { fail: fail, argument: argument, assert: argument };\n\n// Data types used in the OpenType font file.\n\nvar LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\nvar LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n/**\n * @exports opentype.decode\n * @class\n */\nvar decode = {};\n/**\n * @exports opentype.encode\n * @class\n */\nvar encode = {};\n/**\n * @exports opentype.sizeOf\n * @class\n */\nvar sizeOf = {};\n\n// Return a function that always returns the same value.\nfunction constant(v) {\n    return function() {\n        return v;\n    };\n}\n\n// OpenType data types //////////////////////////////////////////////////////\n\n/**\n * Convert an 8-bit unsigned integer to a list of 1 byte.\n * @param {number}\n * @returns {Array}\n */\nencode.BYTE = function(v) {\n    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n    return [v];\n};\n/**\n * @constant\n * @type {number}\n */\nsizeOf.BYTE = constant(1);\n\n/**\n * Convert a 8-bit signed integer to a list of 1 byte.\n * @param {string}\n * @returns {Array}\n */\nencode.CHAR = function(v) {\n    return [v.charCodeAt(0)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.CHAR = constant(1);\n\n/**\n * Convert an ASCII string to a list of bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.CHARARRAY = function(v) {\n    if (typeof v === 'undefined') {\n        v = '';\n        console.warn('Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.');\n    }\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        b[i] = v.charCodeAt(i);\n    }\n\n    return b;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARARRAY = function(v) {\n    if (typeof v === 'undefined') {\n        return 0;\n    }\n    return v.length;\n};\n\n/**\n * Convert a 16-bit unsigned integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.USHORT = function(v) {\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.USHORT = constant(2);\n\n/**\n * Convert a 16-bit signed integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.SHORT = function(v) {\n    // Two's complement\n    if (v >= LIMIT16) {\n        v = -(2 * LIMIT16 - v);\n    }\n\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.SHORT = constant(2);\n\n/**\n * Convert a 24-bit unsigned integer to a list of 3 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.UINT24 = function(v) {\n    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.UINT24 = constant(3);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.ULONG = function(v) {\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.ULONG = constant(4);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.LONG = function(v) {\n    // Two's complement\n    if (v >= LIMIT32) {\n        v = -(2 * LIMIT32 - v);\n    }\n\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONG = constant(4);\n\nencode.FIXED = encode.ULONG;\nsizeOf.FIXED = sizeOf.ULONG;\n\nencode.FWORD = encode.SHORT;\nsizeOf.FWORD = sizeOf.SHORT;\n\nencode.UFWORD = encode.USHORT;\nsizeOf.UFWORD = sizeOf.USHORT;\n\n/**\n * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n * @param {number}\n * @returns {Array}\n */\nencode.LONGDATETIME = function(v) {\n    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONGDATETIME = constant(8);\n\n/**\n * Convert a 4-char tag to a list of 4 bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.TAG = function(v) {\n    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n    return [v.charCodeAt(0),\n            v.charCodeAt(1),\n            v.charCodeAt(2),\n            v.charCodeAt(3)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.TAG = constant(4);\n\n// CFF data types ///////////////////////////////////////////////////////////\n\nencode.Card8 = encode.BYTE;\nsizeOf.Card8 = sizeOf.BYTE;\n\nencode.Card16 = encode.USHORT;\nsizeOf.Card16 = sizeOf.USHORT;\n\nencode.OffSize = encode.BYTE;\nsizeOf.OffSize = sizeOf.BYTE;\n\nencode.SID = encode.USHORT;\nsizeOf.SID = sizeOf.USHORT;\n\n// Convert a numeric operand or charstring number to a variable-size list of bytes.\n/**\n * Convert a numeric operand or charstring number to a variable-size list of bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER = function(v) {\n    if (v >= -107 && v <= 107) {\n        return [v + 139];\n    } else if (v >= 108 && v <= 1131) {\n        v = v - 108;\n        return [(v >> 8) + 247, v & 0xFF];\n    } else if (v >= -1131 && v <= -108) {\n        v = -v - 108;\n        return [(v >> 8) + 251, v & 0xFF];\n    } else if (v >= -32768 && v <= 32767) {\n        return encode.NUMBER16(v);\n    } else {\n        return encode.NUMBER32(v);\n    }\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.NUMBER = function(v) {\n    return encode.NUMBER(v).length;\n};\n\n/**\n * Convert a signed number between -32768 and +32767 to a three-byte value.\n * This ensures we always use three bytes, but is not the most compact format.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER16 = function(v) {\n    return [28, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER16 = constant(3);\n\n/**\n * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n * This is useful if you want to be sure you always use four bytes,\n * at the expense of wasting a few bytes for smaller numbers.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER32 = function(v) {\n    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER32 = constant(5);\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.REAL = function(v) {\n    var value = v.toString();\n\n    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n    // This code converts it back to a number without the epsilon.\n    var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n    if (m) {\n        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n        value = (Math.round(v * epsilon) / epsilon).toString();\n    }\n\n    var nibbles = '';\n    for (var i = 0, ii = value.length; i < ii; i += 1) {\n        var c = value[i];\n        if (c === 'e') {\n            nibbles += value[++i] === '-' ? 'c' : 'b';\n        } else if (c === '.') {\n            nibbles += 'a';\n        } else if (c === '-') {\n            nibbles += 'e';\n        } else {\n            nibbles += c;\n        }\n    }\n\n    nibbles += (nibbles.length & 1) ? 'f' : 'ff';\n    var out = [30];\n    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {\n        out.push(parseInt(nibbles.substr(i$1, 2), 16));\n    }\n\n    return out;\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.REAL = function(v) {\n    return encode.REAL(v).length;\n};\n\nencode.NAME = encode.CHARARRAY;\nsizeOf.NAME = sizeOf.CHARARRAY;\n\nencode.STRING = encode.CHARARRAY;\nsizeOf.STRING = sizeOf.CHARARRAY;\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF8 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes;\n    for (var j = 0; j < numChars; j++, offset += 1) {\n        codePoints[j] = data.getUint8(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF16 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes / 2;\n    for (var j = 0; j < numChars; j++, offset += 2) {\n        codePoints[j] = data.getUint16(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * Convert a JavaScript string to UTF16-BE.\n * @param {string}\n * @returns {Array}\n */\nencode.UTF16 = function(v) {\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        var codepoint = v.charCodeAt(i);\n        b[b.length] = (codepoint >> 8) & 0xFF;\n        b[b.length] = codepoint & 0xFF;\n    }\n\n    return b;\n};\n\n/**\n * @param {string}\n * @returns {number}\n */\nsizeOf.UTF16 = function(v) {\n    return v.length * 2;\n};\n\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */\nvar eightBitMacEncodings = {\n    'x-mac-croatian':  // Python: 'mac_croatian'\n    '' +\n    '',\n    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n    '' +\n    '',\n    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n    '' +\n    '',\n    'x-mac-greek':  // Python: 'mac_greek'\n    '' +\n    '\\u00AD',\n    'x-mac-icelandic':  // Python: 'mac_iceland'\n    '' +\n    '',\n    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n    '' +\n    '',\n    'x-mac-ce':  // Python: 'mac_latin2'\n    '' +\n    '',\n    macintosh:  // Python: 'mac_roman'\n    '' +\n    '',\n    'x-mac-romanian':  // Python: 'mac_romanian'\n    '' +\n    '',\n    'x-mac-turkish':  // Python: 'mac_turkish'\n    '' +\n    ''\n};\n\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\ndecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n    var table = eightBitMacEncodings[encoding];\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = '';\n    for (var i = 0; i < dataLength; i++) {\n        var c = dataView.getUint8(offset + i);\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c <= 0x7F) {\n            result += String.fromCharCode(c);\n        } else {\n            result += table[c & 0x7F];\n        }\n    }\n\n    return result;\n};\n\n// Helper function for encode.MACSTRING. Returns a dictionary for mapping\n// Unicode character codes to their 8-bit MacOS equivalent. This table\n// is not exactly a super cheap data structure, but we do not care because\n// encoding Macintosh strings is only rarely needed in typical applications.\nvar macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\nvar macEncodingCacheKeys;\nvar getMacEncodingTable = function (encoding) {\n    // Since we use encoding as a cache key for WeakMap, it has to be\n    // a String object and not a literal. And at least on NodeJS 2.10.1,\n    // WeakMap requires that the same String instance is passed for cache hits.\n    if (!macEncodingCacheKeys) {\n        macEncodingCacheKeys = {};\n        for (var e in eightBitMacEncodings) {\n            /*jshint -W053 */  // Suppress \"Do not use String as a constructor.\"\n            macEncodingCacheKeys[e] = new String(e);\n        }\n    }\n\n    var cacheKey = macEncodingCacheKeys[encoding];\n    if (cacheKey === undefined) {\n        return undefined;\n    }\n\n    // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n    // since garbage collection may run at any time, it could also kick in\n    // between the calls to cache.has() and cache.get(). In that case,\n    // we would return 'undefined' even though we do support the encoding.\n    if (macEncodingTableCache) {\n        var cachedTable = macEncodingTableCache.get(cacheKey);\n        if (cachedTable !== undefined) {\n            return cachedTable;\n        }\n    }\n\n    var decodingTable = eightBitMacEncodings[encoding];\n    if (decodingTable === undefined) {\n        return undefined;\n    }\n\n    var encodingTable = {};\n    for (var i = 0; i < decodingTable.length; i++) {\n        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n    }\n\n    if (macEncodingTableCache) {\n        macEncodingTableCache.set(cacheKey, encodingTable);\n    }\n\n    return encodingTable;\n};\n\n/**\n * Encodes an old-style Macintosh string. Returns a byte array upon success.\n * If the requested encoding is unsupported, or if the input string contains\n * a character that cannot be expressed in the encoding, the function returns\n * 'undefined'.\n * @param {string} str\n * @param {string} encoding\n * @returns {Array}\n */\nencode.MACSTRING = function(str, encoding) {\n    var table = getMacEncodingTable(encoding);\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c >= 0x80) {\n            c = table[c];\n            if (c === undefined) {\n                // str contains a Unicode character that cannot be encoded\n                // in the requested encoding.\n                return undefined;\n            }\n        }\n        result[i] = c;\n        // result.push(c);\n    }\n\n    return result;\n};\n\n/**\n * @param {string} str\n * @param {string} encoding\n * @returns {number}\n */\nsizeOf.MACSTRING = function(str, encoding) {\n    var b = encode.MACSTRING(str, encoding);\n    if (b !== undefined) {\n        return b.length;\n    } else {\n        return 0;\n    }\n};\n\n// Helper for encode.VARDELTAS\nfunction isByteEncodable(value) {\n    return value >= -128 && value <= 127;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x80 | (runLength - 1));\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    var pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        var value = deltas[pos];\n        if (!isByteEncodable(value)) {\n            break;\n        }\n\n        // Within a byte-encoded run of deltas, a single zero is best\n        // stored literally as 0x00 value. However, if we have two or\n        // more zeroes in a sequence, it is better to start a new run.\n        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n        // when starting a new run.\n        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(runLength - 1);\n    for (var i = offset; i < pos; ++i) {\n        result.push((deltas[i] + 256) & 0xff);\n    }\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    var pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        var value = deltas[pos];\n\n        // Within a word-encoded run of deltas, it is easiest to start\n        // a new run (with a different encoding) whenever we encounter\n        // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n        // needs 7 bytes when storing the zero inside the current run\n        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n        // new run (40 66 66 80 40 77 77).\n        if (value === 0) {\n            break;\n        }\n\n        // Within a word-encoded run of deltas, a single value in the\n        // range (-128..127) should be encoded within the current run\n        // because it is more compact. For example, the sequence\n        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n        // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n        // a new run (40 66 66 00 02 40 77 77).\n        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x40 | (runLength - 1));\n    for (var i = offset; i < pos; ++i) {\n        var val = deltas[i];\n        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);\n    }\n    return pos;\n}\n\n/**\n * Encode a list of variation adjustment deltas.\n *\n * Variation adjustment deltas are used in gvar and cvar tables.\n * They indicate how points (in gvar) or values (in cvar) get adjusted\n * when generating instances of variation fonts.\n *\n * @see https://www.microsoft.com/typography/otspec/gvar.htm\n * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n * @param {Array}\n * @return {Array}\n */\nencode.VARDELTAS = function(deltas) {\n    var pos = 0;\n    var result = [];\n    while (pos < deltas.length) {\n        var value = deltas[pos];\n        if (value === 0) {\n            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n        } else if (value >= -128 && value <= 127) {\n            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n        } else {\n            pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n        }\n    }\n    return result;\n};\n\n// Convert a list of values to a CFF INDEX structure.\n// The values should be objects containing name / type / value.\n/**\n * @param {Array} l\n * @returns {Array}\n */\nencode.INDEX = function(l) {\n    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n    //    i, v;\n    // Because we have to know which data type to use to encode the offsets,\n    // we have to go through the values twice: once to encode the data and\n    // calculate the offsets, then again to encode the offsets using the fitting data type.\n    var offset = 1; // First offset is always 1.\n    var offsets = [offset];\n    var data = [];\n    for (var i = 0; i < l.length; i += 1) {\n        var v = encode.OBJECT(l[i]);\n        Array.prototype.push.apply(data, v);\n        offset += v.length;\n        offsets.push(offset);\n    }\n\n    if (data.length === 0) {\n        return [0, 0];\n    }\n\n    var encodedOffsets = [];\n    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;\n    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {\n        var encodedOffset = offsetEncoder(offsets[i$1]);\n        Array.prototype.push.apply(encodedOffsets, encodedOffset);\n    }\n\n    return Array.prototype.concat(encode.Card16(l.length),\n                           encode.OffSize(offSize),\n                           encodedOffsets,\n                           data);\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.INDEX = function(v) {\n    return encode.INDEX(v).length;\n};\n\n/**\n * Convert an object to a CFF DICT structure.\n * The keys should be numeric.\n * The values should be objects containing name / type / value.\n * @param {Object} m\n * @returns {Array}\n */\nencode.DICT = function(m) {\n    var d = [];\n    var keys = Object.keys(m);\n    var length = keys.length;\n\n    for (var i = 0; i < length; i += 1) {\n        // Object.keys() return string keys, but our keys are always numeric.\n        var k = parseInt(keys[i], 0);\n        var v = m[k];\n        // Value comes before the key.\n        d = d.concat(encode.OPERAND(v.value, v.type));\n        d = d.concat(encode.OPERATOR(k));\n    }\n\n    return d;\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.DICT = function(m) {\n    return encode.DICT(m).length;\n};\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.OPERATOR = function(v) {\n    if (v < 1200) {\n        return [v];\n    } else {\n        return [12, v - 1200];\n    }\n};\n\n/**\n * @param {Array} v\n * @param {string}\n * @returns {Array}\n */\nencode.OPERAND = function(v, type) {\n    var d = [];\n    if (Array.isArray(type)) {\n        for (var i = 0; i < type.length; i += 1) {\n            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n            d = d.concat(encode.OPERAND(v[i], type[i]));\n        }\n    } else {\n        if (type === 'SID') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'offset') {\n            // We make it easy for ourselves and always encode offsets as\n            // 4 bytes. This makes offset calculation for the top dict easier.\n            d = d.concat(encode.NUMBER32(v));\n        } else if (type === 'number') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'real') {\n            d = d.concat(encode.REAL(v));\n        } else {\n            throw new Error('Unknown operand type ' + type);\n            // FIXME Add support for booleans\n        }\n    }\n\n    return d;\n};\n\nencode.OP = encode.BYTE;\nsizeOf.OP = sizeOf.BYTE;\n\n// memoize charstring encoding using WeakMap if available\nvar wmm = typeof WeakMap === 'function' && new WeakMap();\n\n/**\n * Convert a list of CharString operations to bytes.\n * @param {Array}\n * @returns {Array}\n */\nencode.CHARSTRING = function(ops) {\n    // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n    if (wmm) {\n        var cachedValue = wmm.get(ops);\n        if (cachedValue !== undefined) {\n            return cachedValue;\n        }\n    }\n\n    var d = [];\n    var length = ops.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var op = ops[i];\n        d = d.concat(encode[op.type](op.value));\n    }\n\n    if (wmm) {\n        wmm.set(ops, d);\n    }\n\n    return d;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARSTRING = function(ops) {\n    return encode.CHARSTRING(ops).length;\n};\n\n// Utility functions ////////////////////////////////////////////////////////\n\n/**\n * Convert an object containing name / type / value to bytes.\n * @param {Object}\n * @returns {Array}\n */\nencode.OBJECT = function(v) {\n    var encodingFunction = encode[v.type];\n    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n    return encodingFunction(v.value);\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.OBJECT = function(v) {\n    var sizeOfFunction = sizeOf[v.type];\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n    return sizeOfFunction(v.value);\n};\n\n/**\n * Convert a table object to bytes.\n * A table contains a list of fields containing the metadata (name, type and default value).\n * The table itself has the field values set as attributes.\n * @param {opentype.Table}\n * @returns {Array}\n */\nencode.TABLE = function(table) {\n    var d = [];\n    var length = table.fields.length;\n    var subtables = [];\n    var subtableOffsets = [];\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var encodingFunction = encode[field.type];\n        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        var bytes = encodingFunction(value);\n\n        if (field.type === 'TABLE') {\n            subtableOffsets.push(d.length);\n            d = d.concat([0, 0]);\n            subtables.push(bytes);\n        } else {\n            d = d.concat(bytes);\n        }\n    }\n\n    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {\n        var o = subtableOffsets[i$1];\n        var offset = d.length;\n        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n        d[o] = offset >> 8;\n        d[o + 1] = offset & 0xff;\n        d = d.concat(subtables[i$1]);\n    }\n\n    return d;\n};\n\n/**\n * @param {opentype.Table}\n * @returns {number}\n */\nsizeOf.TABLE = function(table) {\n    var numBytes = 0;\n    var length = table.fields.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var sizeOfFunction = sizeOf[field.type];\n        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        numBytes += sizeOfFunction(value);\n\n        // Subtables take 2 more bytes for offsets.\n        if (field.type === 'TABLE') {\n            numBytes += 2;\n        }\n    }\n\n    return numBytes;\n};\n\nencode.RECORD = encode.TABLE;\nsizeOf.RECORD = sizeOf.TABLE;\n\n// Merge in a list of bytes.\nencode.LITERAL = function(v) {\n    return v;\n};\n\nsizeOf.LITERAL = function(v) {\n    return v.length;\n};\n\n// Table metadata\n\n/**\n * @exports opentype.Table\n * @class\n * @param {string} tableName\n * @param {Array} fields\n * @param {Object} options\n * @constructor\n */\nfunction Table(tableName, fields, options) {\n    // For coverage tables with coverage format 2, we do not want to add the coverage data directly to the table object,\n    // as this will result in wrong encoding order of the coverage data on serialization to bytes.\n    // The fallback of using the field values directly when not present on the table is handled in types.encode.TABLE() already.\n    if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {\n        for (var i = 0; i < fields.length; i += 1) {\n            var field = fields[i];\n            this[field.name] = field.value;\n        }\n    }\n\n    this.tableName = tableName;\n    this.fields = fields;\n    if (options) {\n        var optionKeys = Object.keys(options);\n        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {\n            var k = optionKeys[i$1];\n            var v = options[k];\n            if (this[k] !== undefined) {\n                this[k] = v;\n            }\n        }\n    }\n}\n\n/**\n * Encodes the table and returns an array of bytes\n * @return {Array}\n */\nTable.prototype.encode = function() {\n    return encode.TABLE(this);\n};\n\n/**\n * Get the size of the table.\n * @return {number}\n */\nTable.prototype.sizeOf = function() {\n    return sizeOf.TABLE(this);\n};\n\n/**\n * @private\n */\nfunction ushortList(itemName, list, count) {\n    if (count === undefined) {\n        count = list.length;\n    }\n    var fields = new Array(list.length + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < list.length; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction tableList(itemName, records, itemCallback) {\n    var count = records.length;\n    var fields = new Array(count + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < count; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction recordList(itemName, records, itemCallback) {\n    var count = records.length;\n    var fields = [];\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < count; i++) {\n        fields = fields.concat(itemCallback(records[i], i));\n    }\n    return fields;\n}\n\n// Common Layout Tables\n\n/**\n * @exports opentype.Coverage\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction Coverage(coverageTable) {\n    if (coverageTable.format === 1) {\n        Table.call(this, 'coverageTable',\n            [{name: 'coverageFormat', type: 'USHORT', value: 1}]\n            .concat(ushortList('glyph', coverageTable.glyphs))\n        );\n    } else if (coverageTable.format === 2) {\n        Table.call(this, 'coverageTable',\n            [{name: 'coverageFormat', type: 'USHORT', value: 2}]\n            .concat(recordList('rangeRecord', coverageTable.ranges, function(RangeRecord) {\n                return [\n                    {name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start},\n                    {name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end},\n                    {name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index} ];\n            }))\n        );\n    } else {\n        check.assert(false, 'Coverage format must be 1 or 2.');\n    }\n}\nCoverage.prototype = Object.create(Table.prototype);\nCoverage.prototype.constructor = Coverage;\n\nfunction ScriptList(scriptListTable) {\n    Table.call(this, 'scriptListTable',\n        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {\n            var script = scriptRecord.script;\n            var defaultLangSys = script.defaultLangSys;\n            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');\n            return [\n                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},\n                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [\n                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [\n                        {name: 'lookupOrder', type: 'USHORT', value: 0},\n                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]\n                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}\n                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {\n                        var langSys = langSysRecord.langSys;\n                        return [\n                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},\n                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [\n                                {name: 'lookupOrder', type: 'USHORT', value: 0},\n                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}\n                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}\n                        ];\n                    })))}\n            ];\n        })\n    );\n}\nScriptList.prototype = Object.create(Table.prototype);\nScriptList.prototype.constructor = ScriptList;\n\n/**\n * @exports opentype.FeatureList\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction FeatureList(featureListTable) {\n    Table.call(this, 'featureListTable',\n        recordList('featureRecord', featureListTable, function(featureRecord, i) {\n            var feature = featureRecord.feature;\n            return [\n                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},\n                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [\n                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}\n            ];\n        })\n    );\n}\nFeatureList.prototype = Object.create(Table.prototype);\nFeatureList.prototype.constructor = FeatureList;\n\n/**\n * @exports opentype.LookupList\n * @class\n * @param {opentype.Table}\n * @param {Object}\n * @constructor\n * @extends opentype.Table\n */\nfunction LookupList(lookupListTable, subtableMakers) {\n    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {\n        var subtableCallback = subtableMakers[lookupTable.lookupType];\n        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');\n        return new Table('lookupTable', [\n            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},\n            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}\n        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));\n    }));\n}\nLookupList.prototype = Object.create(Table.prototype);\nLookupList.prototype.constructor = LookupList;\n\n// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)\n// Don't use offsets inside Records (probable bug), only in Tables.\nvar table = {\n    Table: Table,\n    Record: Table,\n    Coverage: Coverage,\n    ScriptList: ScriptList,\n    FeatureList: FeatureList,\n    LookupList: LookupList,\n    ushortList: ushortList,\n    tableList: tableList,\n    recordList: recordList,\n};\n\n// Parsing utility functions\n\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false);\n}\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n    return dataView.getInt16(offset, false);\n}\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n    return dataView.getUint32(offset, false);\n}\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n    var decimal = dataView.getInt16(offset, false);\n    var fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n}\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n    var tag = '';\n    for (var i = offset; i < offset + 4; i += 1) {\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n\n    return tag;\n}\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n    var v = 0;\n    for (var i = 0; i < offSize; i += 1) {\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n\n    return v;\n}\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n    var bytes = [];\n    for (var i = startOffset; i < endOffset; i += 1) {\n        bytes.push(dataView.getUint8(i));\n    }\n\n    return bytes;\n}\n\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n    var s = '';\n    for (var i = 0; i < bytes.length; i += 1) {\n        s += String.fromCharCode(bytes[i]);\n    }\n\n    return s;\n}\n\nvar typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function() {\n    var v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseChar = function() {\n    var v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function() {\n    var v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseF2Dot14 = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseULong = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\nParser.prototype.parseFixed = function() {\n    var v = getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseString = function(length) {\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    var string = '';\n    this.relativeOffset += length;\n    for (var i = 0; i < length; i++) {\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n\n    return string;\n};\n\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800;\n    this.relativeOffset += 8;\n    return v;\n};\n\nParser.prototype.parseVersion = function(minorBase) {\n    var major = getUShort(this.data, this.offset + this.relativeOffset);\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // Default returns the correct number if minor = 0xN000 where N is 0-9\n    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    if (minorBase === undefined) { minorBase = 0x1000; }\n    return major + minor / minorBase / 10;\n};\n\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n\n///// Parsing lists and records ///////////////////////////////\n\n// Parse a list of 32 bit unsigned integers.\nParser.prototype.parseULongList = function(count) {\n    if (count === undefined) { count = this.parseULong(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint32(offset);\n        offset += 4;\n    }\n\n    this.relativeOffset += count * 4;\n    return offsets;\n};\n\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List =\nParser.prototype.parseUShortList = function(count) {\n    if (count === undefined) { count = this.parseUShort(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getInt16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return list;\n};\n\n// Parses a list of bytes.\nParser.prototype.parseByteList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getUint8(offset++);\n    }\n\n    this.relativeOffset += count;\n    return list;\n};\n\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\nParser.prototype.parseList = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseUShort();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\nParser.prototype.parseList32 = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseULong();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\nParser.prototype.parseRecordList = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseUShort();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\nParser.prototype.parseRecordList32 = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseULong();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function(description) {\n    if (typeof description === 'function') {\n        return description.call(this);\n    } else {\n        var fields = Object.keys(description);\n        var struct = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = description[fieldName];\n            struct[fieldName] = fieldType.call(this);\n        }\n        return struct;\n    }\n};\n\n/**\n * Parse a GPOS valueRecord\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat is optional, if omitted it is read from the stream.\n */\nParser.prototype.parseValueRecord = function(valueFormat) {\n    if (valueFormat === undefined) {\n        valueFormat = this.parseUShort();\n    }\n    if (valueFormat === 0) {\n        // valueFormat2 in kerning pairs is most often 0\n        // in this case return undefined instead of an empty object, to save space\n        return;\n    }\n    var valueRecord = {};\n\n    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }\n    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }\n    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }\n    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }\n\n    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }\n\n    return valueRecord;\n};\n\n/**\n * Parse a list of GPOS valueRecords\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat and valueCount are read from the stream.\n */\nParser.prototype.parseValueRecordList = function() {\n    var valueFormat = this.parseUShort();\n    var valueCount = this.parseUShort();\n    var values = new Array(valueCount);\n    for (var i = 0; i < valueCount; i++) {\n        values[i] = this.parseValueRecord(valueFormat);\n    }\n    return values;\n};\n\nParser.prototype.parsePointer = function(description) {\n    var structOffset = this.parseOffset16();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\nParser.prototype.parsePointer32 = function(description) {\n    var structOffset = this.parseOffset32();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\nParser.prototype.parseListOfLists = function(itemCallback) {\n    var offsets = this.parseOffset16List();\n    var count = offsets.length;\n    var relativeOffset = this.relativeOffset;\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        var start = offsets[i];\n        if (start === 0) {\n            // NULL offset\n            // Add i as owned property to list. Convenient with assert.\n            list[i] = undefined;\n            continue;\n        }\n        this.relativeOffset = start;\n        if (itemCallback) {\n            var subOffsets = this.parseOffset16List();\n            var subList = new Array(subOffsets.length);\n            for (var j = 0; j < subOffsets.length; j++) {\n                this.relativeOffset = start + subOffsets[j];\n                subList[j] = itemCallback.call(this);\n            }\n            list[i] = subList;\n        } else {\n            list[i] = this.parseUShortList();\n        }\n    }\n    this.relativeOffset = relativeOffset;\n    return list;\n};\n\n///// Complex tables parsing //////////////////////////////////\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    var count = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            glyphs: this.parseUShortList(count)\n        };\n    } else if (format === 2) {\n        var ranges = new Array(count);\n        for (var i = 0; i < count; i++) {\n            ranges[i] = {\n                start: this.parseUShort(),\n                end: this.parseUShort(),\n                index: this.parseUShort()\n            };\n        }\n        return {\n            format: 2,\n            ranges: ranges\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n};\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            startGlyph: this.parseUShort(),\n            classes: this.parseUShortList()\n        };\n    } else if (format === 2) {\n        return {\n            format: 2,\n            ranges: this.parseRecordList({\n                start: Parser.uShort,\n                end: Parser.uShort,\n                classId: Parser.uShort\n            })\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n};\n\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\nParser.list = function(count, itemCallback) {\n    return function() {\n        return this.parseList(count, itemCallback);\n    };\n};\n\nParser.list32 = function(count, itemCallback) {\n    return function() {\n        return this.parseList32(count, itemCallback);\n    };\n};\n\nParser.recordList = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList(count, recordDescription);\n    };\n};\n\nParser.recordList32 = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList32(count, recordDescription);\n    };\n};\n\nParser.pointer = function(description) {\n    return function() {\n        return this.parsePointer(description);\n    };\n};\n\nParser.pointer32 = function(description) {\n    return function() {\n        return this.parsePointer32(description);\n    };\n};\n\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\nParser.uLongList = Parser.prototype.parseULongList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nvar langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList\n};\n\nParser.prototype.parseScriptList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n                tag: Parser.tag,\n                langSys: Parser.pointer(langSysTable)\n            })\n        })\n    })) || [];\n};\n\nParser.prototype.parseFeatureList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n        })\n    })) || [];\n};\n\nParser.prototype.parseLookupList = function(lookupTableParsers) {\n    return this.parsePointer(Parser.list(Parser.pointer(function() {\n        var lookupType = this.parseUShort();\n        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n        var lookupFlag = this.parseUShort();\n        var useMarkFilteringSet = lookupFlag & 0x10;\n        return {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n        };\n    }))) || [];\n};\n\nParser.prototype.parseFeatureVariationsList = function() {\n    return this.parsePointer32(function() {\n        var majorVersion = this.parseUShort();\n        var minorVersion = this.parseUShort();\n        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n        var featureVariations = this.parseRecordList32({\n            conditionSetOffset: Parser.offset32,\n            featureTableSubstitutionOffset: Parser.offset32\n        });\n        return featureVariations;\n    }) || [];\n};\n\nvar parse = {\n    getByte: getByte,\n    getCard8: getByte,\n    getUShort: getUShort,\n    getCard16: getUShort,\n    getShort: getShort,\n    getULong: getULong,\n    getFixed: getFixed,\n    getTag: getTag,\n    getOffset: getOffset,\n    getBytes: getBytes,\n    bytesToString: bytesToString,\n    Parser: Parser,\n};\n\n// The `cmap` table stores the mappings from characters to glyphs.\n\nfunction parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort();\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong();\n    cmap.language = p.parseULong();\n\n    var groupCount;\n    cmap.groupCount = groupCount = p.parseULong();\n    cmap.glyphIndexMap = {};\n\n    for (var i = 0; i < groupCount; i += 1) {\n        var startCharCode = p.parseULong();\n        var endCharCode = p.parseULong();\n        var startGlyphId = p.parseULong();\n\n        for (var c = startCharCode; c <= endCharCode; c += 1) {\n            cmap.glyphIndexMap[c] = startGlyphId;\n            startGlyphId++;\n        }\n    }\n}\n\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n\n    // segCount is stored x 2.\n    var segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n    var endCountParser = new parse.Parser(data, start + offset + 14);\n    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for (var i = 0; i < segCount - 1; i += 1) {\n        var glyphIndex = (void 0);\n        var endCount = endCountParser.parseUShort();\n        var startCount = startCountParser.parseUShort();\n        var idDelta = idDeltaParser.parseShort();\n        var idRangeOffset = idRangeOffsetParser.parseUShort();\n        for (var c = startCount; c <= endCount; c += 1) {\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);\n\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;\n                }\n            } else {\n                glyphIndex = (c + idDelta) & 0xFFFF;\n            }\n\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n}\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    var cmap = {};\n    cmap.version = parse.getUShort(data, start);\n    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n    cmap.numTables = parse.getUShort(data, start + 2);\n    var offset = -1;\n    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n        var platformId = parse.getUShort(data, start + 4 + (i * 8));\n        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);\n        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {\n            offset = parse.getULong(data, start + 4 + (i * 8) + 4);\n            break;\n        }\n    }\n\n    if (offset === -1) {\n        // There is no cmap table in the font that we support.\n        throw new Error('No valid cmap sub-tables found.');\n    }\n\n    var p = new parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n\n    if (cmap.format === 12) {\n        parseCmapTableFormat12(cmap, p);\n    } else if (cmap.format === 4) {\n        parseCmapTableFormat4(cmap, p, data, start, offset);\n    } else {\n        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n    }\n\n    return cmap;\n}\n\nfunction addSegment(t, code, glyphIndex) {\n    t.segments.push({\n        end: code,\n        start: code,\n        delta: -(code - glyphIndex),\n        offset: 0,\n        glyphIndex: glyphIndex\n    });\n}\n\nfunction addTerminatorSegment(t) {\n    t.segments.push({\n        end: 0xFFFF,\n        start: 0xFFFF,\n        delta: 1,\n        offset: 0\n    });\n}\n\n// Make cmap table, format 4 by default, 12 if needed only\nfunction makeCmapTable(glyphs) {\n    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)\n    var isPlan0Only = true;\n    var i;\n\n    // Check if we need to add cmap format 12 or if format 4 only is fine\n    for (i = glyphs.length - 1; i > 0; i -= 1) {\n        var g = glyphs.get(i);\n        if (g.unicode > 65535) {\n            console.log('Adding CMAP format 12 (needed!)');\n            isPlan0Only = false;\n            break;\n        }\n    }\n\n    var cmapTable = [\n        {name: 'version', type: 'USHORT', value: 0},\n        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},\n\n        // CMAP 4 header\n        {name: 'platformID', type: 'USHORT', value: 3},\n        {name: 'encodingID', type: 'USHORT', value: 1},\n        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}\n    ];\n\n    if (!isPlan0Only)\n        { cmapTable = cmapTable.concat([\n            // CMAP 12 header\n            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere\n            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},\n            {name: 'cmap12Offset', type: 'ULONG', value: 0}\n        ]); }\n\n    cmapTable = cmapTable.concat([\n        // CMAP 4 Subtable\n        {name: 'format', type: 'USHORT', value: 4},\n        {name: 'cmap4Length', type: 'USHORT', value: 0},\n        {name: 'language', type: 'USHORT', value: 0},\n        {name: 'segCountX2', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n\n    var t = new table.Table('cmap', cmapTable);\n\n    t.segments = [];\n    for (i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        for (var j = 0; j < glyph.unicodes.length; j += 1) {\n            addSegment(t, glyph.unicodes[j], i);\n        }\n\n        t.segments = t.segments.sort(function (a, b) {\n            return a.start - b.start;\n        });\n    }\n\n    addTerminatorSegment(t);\n\n    var segCount = t.segments.length;\n    var segCountToRemove = 0;\n\n    // CMAP 4\n    // Set up parallel segment arrays.\n    var endCounts = [];\n    var startCounts = [];\n    var idDeltas = [];\n    var idRangeOffsets = [];\n    var glyphIds = [];\n\n    // CMAP 12\n    var cmap12Groups = [];\n\n    // Reminder this loop is not following the specification at 100%\n    // The specification -> find suites of characters and make a group\n    // Here we're doing one group for each letter\n    // Doing as the spec can save 8 times (or more) space\n    for (i = 0; i < segCount; i += 1) {\n        var segment = t.segments[i];\n\n        // CMAP 4\n        if (segment.end <= 65535 && segment.start <= 65535) {\n            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});\n            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});\n            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});\n            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});\n            if (segment.glyphId !== undefined) {\n                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});\n            }\n        } else {\n            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12\n            segCountToRemove += 1;\n        }\n\n        // CMAP 12\n        // Skip Terminator Segment\n        if (!isPlan0Only && segment.glyphIndex !== undefined) {\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});\n        }\n    }\n\n    // CMAP 4 Subtable\n    t.segCountX2 = (segCount - segCountToRemove) * 2;\n    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;\n    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n    t.rangeShift = t.segCountX2 - t.searchRange;\n\n    t.fields = t.fields.concat(endCounts);\n    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});\n    t.fields = t.fields.concat(startCounts);\n    t.fields = t.fields.concat(idDeltas);\n    t.fields = t.fields.concat(idRangeOffsets);\n    t.fields = t.fields.concat(glyphIds);\n\n    t.cmap4Length = 14 + // Subtable header\n        endCounts.length * 2 +\n        2 + // reservedPad\n        startCounts.length * 2 +\n        idDeltas.length * 2 +\n        idRangeOffsets.length * 2 +\n        glyphIds.length * 2;\n\n    if (!isPlan0Only) {\n        // CMAP 12 Subtable\n        var cmap12Length = 16 + // Subtable header\n            cmap12Groups.length * 4;\n\n        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;\n        t.fields = t.fields.concat([\n            {name: 'cmap12Format', type: 'USHORT', value: 12},\n            {name: 'cmap12Reserved', type: 'USHORT', value: 0},\n            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},\n            {name: 'cmap12Language', type: 'ULONG', value: 0},\n            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}\n        ]);\n\n        t.fields = t.fields.concat(cmap12Groups);\n    }\n\n    return t;\n}\n\nvar cmap = { parse: parseCmapTable, make: makeCmapTable };\n\n// Glyph encoding\n\nvar cffStandardStrings = [\n    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',\n    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',\n    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',\n    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',\n    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',\n    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',\n    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',\n    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',\n    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',\n    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',\n    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',\n    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',\n    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',\n    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',\n    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',\n    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',\n    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',\n    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',\n    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',\n    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',\n    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',\n    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',\n    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',\n    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',\n    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',\n    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',\n    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];\n\nvar cffStandardEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n    'lslash', 'oslash', 'oe', 'germandbls'];\n\nvar cffExpertEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\n\nvar standardNames = [\n    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\n\n/**\n * This is the encoding used for fonts created from scratch.\n * It loops through all glyphs and finds the appropriate unicode value.\n * Since it's linear time, other encodings will be faster.\n * @exports opentype.DefaultEncoding\n * @class\n * @constructor\n * @param {opentype.Font}\n */\nfunction DefaultEncoding(font) {\n    this.font = font;\n}\n\nDefaultEncoding.prototype.charToGlyphIndex = function(c) {\n    var code = c.codePointAt(0);\n    var glyphs = this.font.glyphs;\n    if (glyphs) {\n        for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n                if (glyph.unicodes[j] === code) {\n                    return i;\n                }\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @exports opentype.CmapEncoding\n * @class\n * @constructor\n * @param {Object} cmap - a object with the cmap encoded data\n */\nfunction CmapEncoding(cmap) {\n    this.cmap = cmap;\n}\n\n/**\n * @param  {string} c - the character\n * @return {number} The glyph index.\n */\nCmapEncoding.prototype.charToGlyphIndex = function(c) {\n    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n};\n\n/**\n * @exports opentype.CffEncoding\n * @class\n * @constructor\n * @param {string} encoding - The encoding\n * @param {Array} charset - The character set.\n */\nfunction CffEncoding(encoding, charset) {\n    this.encoding = encoding;\n    this.charset = charset;\n}\n\n/**\n * @param  {string} s - The character\n * @return {number} The index.\n */\nCffEncoding.prototype.charToGlyphIndex = function(s) {\n    var code = s.codePointAt(0);\n    var charName = this.encoding[code];\n    return this.charset.indexOf(charName);\n};\n\n/**\n * @exports opentype.GlyphNames\n * @class\n * @constructor\n * @param {Object} post\n */\nfunction GlyphNames(post) {\n    switch (post.version) {\n        case 1:\n            this.names = standardNames.slice();\n            break;\n        case 2:\n            this.names = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                if (post.glyphNameIndex[i] < standardNames.length) {\n                    this.names[i] = standardNames[post.glyphNameIndex[i]];\n                } else {\n                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];\n                }\n            }\n\n            break;\n        case 2.5:\n            this.names = new Array(post.numberOfGlyphs);\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];\n            }\n\n            break;\n        case 3:\n            this.names = [];\n            break;\n        default:\n            this.names = [];\n            break;\n    }\n}\n\n/**\n * Gets the index of a glyph by name.\n * @param  {string} name - The glyph name\n * @return {number} The index\n */\nGlyphNames.prototype.nameToGlyphIndex = function(name) {\n    return this.names.indexOf(name);\n};\n\n/**\n * @param  {number} gid\n * @return {string}\n */\nGlyphNames.prototype.glyphIndexToName = function(gid) {\n    return this.names[gid];\n};\n\nfunction addGlyphNamesAll(font) {\n    var glyph;\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        glyph = font.glyphs.get(glyphIndex);\n        glyph.addUnicode(parseInt(c));\n    }\n\n    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {\n        glyph = font.glyphs.get(i$1);\n        if (font.cffEncoding) {\n            if (font.isCIDFont) {\n                glyph.name = 'gid' + i$1;\n            } else {\n                glyph.name = font.cffEncoding.charset[i$1];\n            }\n        } else if (font.glyphNames.names) {\n            glyph.name = font.glyphNames.glyphIndexToName(i$1);\n        }\n    }\n}\n\nfunction addGlyphNamesToUnicodeMap(font) {\n    font._IndexToUnicodeMap = {};\n\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n            font._IndexToUnicodeMap[glyphIndex] = {\n                unicodes: [parseInt(c)]\n            };\n        } else {\n            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));\n        }\n    }\n}\n\n/**\n * @alias opentype.addGlyphNames\n * @param {opentype.Font}\n * @param {Object}\n */\nfunction addGlyphNames(font, opt) {\n    if (opt.lowMemory) {\n        addGlyphNamesToUnicodeMap(font);\n    } else {\n        addGlyphNamesAll(font);\n    }\n}\n\n// Drawing utility functions.\n\n// Draw a line on the given context from point `x1,y1` to point `x2,y2`.\nfunction line(ctx, x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\n\nvar draw = { line: line };\n\n// The Glyph object\n// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\nfunction getPathDefinition(glyph, path) {\n    var _path = path || new Path();\n    return {\n        configurable: true,\n\n        get: function() {\n            if (typeof _path === 'function') {\n                _path = _path();\n            }\n\n            return _path;\n        },\n\n        set: function(p) {\n            _path = p;\n        }\n    };\n}\n/**\n * @typedef GlyphOptions\n * @type Object\n * @property {string} [name] - The glyph name\n * @property {number} [unicode]\n * @property {Array} [unicodes]\n * @property {number} [xMin]\n * @property {number} [yMin]\n * @property {number} [xMax]\n * @property {number} [yMax]\n * @property {number} [advanceWidth]\n */\n\n// A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\n/**\n * @exports opentype.Glyph\n * @class\n * @param {GlyphOptions}\n * @constructor\n */\nfunction Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options);\n}\n\n/**\n * @param  {GlyphOptions}\n */\nGlyph.prototype.bindConstructorValues = function(options) {\n    this.index = options.index || 0;\n\n    // These three values cannot be deferred for memory optimization:\n    this.name = options.name || null;\n    this.unicode = options.unicode || undefined;\n    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];\n\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if ('xMin' in options) {\n        this.xMin = options.xMin;\n    }\n\n    if ('yMin' in options) {\n        this.yMin = options.yMin;\n    }\n\n    if ('xMax' in options) {\n        this.xMax = options.xMax;\n    }\n\n    if ('yMax' in options) {\n        this.yMax = options.yMax;\n    }\n\n    if ('advanceWidth' in options) {\n        this.advanceWidth = options.advanceWidth;\n    }\n\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n};\n\n/**\n * @param {number}\n */\nGlyph.prototype.addUnicode = function(unicode) {\n    if (this.unicodes.length === 0) {\n        this.unicode = unicode;\n    }\n\n    this.unicodes.push(unicode);\n};\n\n/**\n * Calculate the minimum bounding box for this glyph.\n * @return {opentype.BoundingBox}\n */\nGlyph.prototype.getBoundingBox = function() {\n    return this.path.getBoundingBox();\n};\n\n/**\n * Convert the glyph to a Path we can draw on a drawing context.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n * @param  {opentype.Font} if hinting is to be used, the font\n * @return {opentype.Path}\n */\nGlyph.prototype.getPath = function(x, y, fontSize, options, font) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    var commands;\n    var hPoints;\n    if (!options) { options = { }; }\n    var xScale = options.xScale;\n    var yScale = options.yScale;\n\n    if (options.hinting && font && font.hinting) {\n        // in case of hinting, the hinting engine takes care\n        // of scaling the points (not the path) before hinting.\n        hPoints = this.path && font.hinting.exec(this, fontSize);\n        // in case the hinting engine failed hPoints is undefined\n        // and thus reverts to plain rending\n    }\n\n    if (hPoints) {\n        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n        commands = font.hinting.getCommands(hPoints);\n        x = Math.round(x);\n        y = Math.round(y);\n        // TODO in case of hinting xyScaling is not yet supported\n        xScale = yScale = 1;\n    } else {\n        commands = this.path.commands;\n        var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;\n        if (xScale === undefined) { xScale = scale; }\n        if (yScale === undefined) { yScale = scale; }\n    }\n\n    var p = new Path();\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type === 'M') {\n            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'L') {\n            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Q') {\n            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                               x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'C') {\n            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),\n                      x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Z') {\n            p.closePath();\n        }\n    }\n\n    return p;\n};\n\n/**\n * Split the glyph into contours.\n * This function is here for backwards compatibility, and to\n * provide raw access to the TrueType glyph outlines.\n * @return {Array}\n */\nGlyph.prototype.getContours = function() {\n    if (this.points === undefined) {\n        return [];\n    }\n\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < this.points.length; i += 1) {\n        var pt = this.points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n};\n\n/**\n * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n * @return {Object}\n */\nGlyph.prototype.getMetrics = function() {\n    var commands = this.path.commands;\n    var xCoords = [];\n    var yCoords = [];\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type !== 'Z') {\n            xCoords.push(cmd.x);\n            yCoords.push(cmd.y);\n        }\n\n        if (cmd.type === 'Q' || cmd.type === 'C') {\n            xCoords.push(cmd.x1);\n            yCoords.push(cmd.y1);\n        }\n\n        if (cmd.type === 'C') {\n            xCoords.push(cmd.x2);\n            yCoords.push(cmd.y2);\n        }\n    }\n\n    var metrics = {\n        xMin: Math.min.apply(null, xCoords),\n        yMin: Math.min.apply(null, yCoords),\n        xMax: Math.max.apply(null, xCoords),\n        yMax: Math.max.apply(null, yCoords),\n        leftSideBearing: this.leftSideBearing\n    };\n\n    if (!isFinite(metrics.xMin)) {\n        metrics.xMin = 0;\n    }\n\n    if (!isFinite(metrics.xMax)) {\n        metrics.xMax = this.advanceWidth;\n    }\n\n    if (!isFinite(metrics.yMin)) {\n        metrics.yMin = 0;\n    }\n\n    if (!isFinite(metrics.yMax)) {\n        metrics.yMax = 0;\n    }\n\n    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n    return metrics;\n};\n\n/**\n * Draw the glyph on the given context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n */\nGlyph.prototype.draw = function(ctx, x, y, fontSize, options) {\n    this.getPath(x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of the glyph.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawPoints = function(ctx, x, y, fontSize) {\n    function drawCircles(l, x, y, scale) {\n        ctx.beginPath();\n        for (var j = 0; j < l.length; j += 1) {\n            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));\n            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, Math.PI * 2, false);\n        }\n\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    var scale = 1 / this.path.unitsPerEm * fontSize;\n\n    var blueCircles = [];\n    var redCircles = [];\n    var path = this.path;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var cmd = path.commands[i];\n        if (cmd.x !== undefined) {\n            blueCircles.push({x: cmd.x, y: -cmd.y});\n        }\n\n        if (cmd.x1 !== undefined) {\n            redCircles.push({x: cmd.x1, y: -cmd.y1});\n        }\n\n        if (cmd.x2 !== undefined) {\n            redCircles.push({x: cmd.x2, y: -cmd.y2});\n        }\n    }\n\n    ctx.fillStyle = 'blue';\n    drawCircles(blueCircles, x, y, scale);\n    ctx.fillStyle = 'red';\n    drawCircles(redCircles, x, y, scale);\n};\n\n/**\n * Draw lines indicating important font measurements.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {\n    var scale;\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    scale = 1 / this.path.unitsPerEm * fontSize;\n    ctx.lineWidth = 1;\n\n    // Draw the origin\n    ctx.strokeStyle = 'black';\n    draw.line(ctx, x, -10000, x, 10000);\n    draw.line(ctx, -10000, y, 10000, y);\n\n    // This code is here due to memory optimization: by not using\n    // defaults in the constructor, we save a notable amount of memory.\n    var xMin = this.xMin || 0;\n    var yMin = this.yMin || 0;\n    var xMax = this.xMax || 0;\n    var yMax = this.yMax || 0;\n    var advanceWidth = this.advanceWidth || 0;\n\n    // Draw the glyph box\n    ctx.strokeStyle = 'blue';\n    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);\n    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);\n    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));\n    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));\n\n    // Draw the advance width\n    ctx.strokeStyle = 'green';\n    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);\n};\n\n// The GlyphSet object\n\n// Define a property on the glyph that depends on the path being loaded.\nfunction defineDependentProperty(glyph, externalName, internalName) {\n    Object.defineProperty(glyph, externalName, {\n        get: function() {\n            // Request the path property to make sure the path is loaded.\n            glyph.path; // jshint ignore:line\n            return glyph[internalName];\n        },\n        set: function(newValue) {\n            glyph[internalName] = newValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\n\n/**\n * A GlyphSet represents all glyphs available in the font, but modelled using\n * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n * necessary, to keep the memory footprint down.\n * @exports opentype.GlyphSet\n * @class\n * @param {opentype.Font}\n * @param {Array}\n */\nfunction GlyphSet(font, glyphs) {\n    this.font = font;\n    this.glyphs = {};\n    if (Array.isArray(glyphs)) {\n        for (var i = 0; i < glyphs.length; i++) {\n            var glyph = glyphs[i];\n            glyph.path.unitsPerEm = font.unitsPerEm;\n            this.glyphs[i] = glyph;\n        }\n    }\n\n    this.length = (glyphs && glyphs.length) || 0;\n}\n\n/**\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nGlyphSet.prototype.get = function(index) {\n    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n    if (this.glyphs[index] === undefined) {\n        this.font._push(index);\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n\n        var glyph = this.glyphs[index];\n        var unicodeObj = this.font._IndexToUnicodeMap[index];\n\n        if (unicodeObj) {\n            for (var j = 0; j < unicodeObj.unicodes.length; j++)\n                { glyph.addUnicode(unicodeObj.unicodes[j]); }\n        }\n\n        if (this.font.cffEncoding) {\n            if (this.font.isCIDFont) {\n                glyph.name = 'gid' + index;\n            } else {\n                glyph.name = this.font.cffEncoding.charset[index];\n            }\n        } else if (this.font.glyphNames.names) {\n            glyph.name = this.font.glyphNames.glyphIndexToName(index);\n        }\n\n        this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;\n        this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;\n    } else {\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n    }\n\n    return this.glyphs[index];\n};\n\n/**\n * @param  {number} index\n * @param  {Object}\n */\nGlyphSet.prototype.push = function(index, loader) {\n    this.glyphs[index] = loader;\n    this.length++;\n};\n\n/**\n * @alias opentype.glyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nfunction glyphLoader(font, index) {\n    return new Glyph({index: index, font: font});\n}\n\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n * @alias opentype.ttfGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseGlyph\n * @param  {Object} data\n * @param  {number} position\n * @param  {Function} buildPath\n * @return {opentype.Glyph}\n */\nfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function() {\n        var glyph = new Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            parseGlyph(glyph, data, position);\n            var path = buildPath(font.glyphs, glyph);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        defineDependentProperty(glyph, 'xMin', '_xMin');\n        defineDependentProperty(glyph, 'xMax', '_xMax');\n        defineDependentProperty(glyph, 'yMin', '_yMin');\n        defineDependentProperty(glyph, 'yMax', '_yMax');\n\n        return glyph;\n    };\n}\n/**\n * @alias opentype.cffGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseCFFCharstring\n * @param  {string} charstring\n * @return {opentype.Glyph}\n */\nfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function() {\n        var glyph = new Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            var path = parseCFFCharstring(font, glyph, charstring);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        return glyph;\n    };\n}\n\nvar glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };\n\n// The `CFF` table contains the glyph outlines in PostScript format.\n\n// Custom equals function that can also check lists.\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n\n        for (var i = 0; i < a.length; i += 1) {\n            if (!equals(a[i], b[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    var bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n\n    return bias;\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    var offsets = [];\n    var objects = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n\n        objects.push(value);\n    }\n\n    return {objects: objects, startOffset: start, endOffset: endOffset};\n}\n\nfunction parseCFFIndexLowMemory(data, start) {\n    var offsets = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    return {offsets: offsets, startOffset: start, endOffset: endOffset};\n}\nfunction getCffIndexObject(i, offsets, data, start, conversionFn) {\n    var count = parse.getCard16(data, start);\n    var objectOffset = 0;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n    }\n\n    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n    if (conversionFn) {\n        value = conversionFn(value);\n    }\n    return value;\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    var s = '';\n    var eof = 15;\n    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n    while (true) {\n        var b = parser.parseByte();\n        var n1 = b >> 4;\n        var n2 = b & 15;\n\n        if (n1 === eof) {\n            break;\n        }\n\n        s += lookup[n1];\n\n        if (n2 === eof) {\n            break;\n        }\n\n        s += lookup[n2];\n    }\n\n    return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    var b1;\n    var b2;\n    var b3;\n    var b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return b1 << 8 | b2;\n    }\n\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n    }\n\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n\n    throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    var o = {};\n    for (var i = 0; i < entries.length; i += 1) {\n        var key = entries[i][0];\n        var values = entries[i][1];\n        var value = (void 0);\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n\n        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n            throw new Error('Object ' + o + ' already has key ' + key);\n        }\n\n        o[key] = value;\n    }\n\n    return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    var parser = new parse.Parser(data, start);\n    var entries = [];\n    var operands = [];\n    size = size !== undefined ? size : data.length;\n\n    while (parser.relativeOffset < size) {\n        var op = parser.parseByte();\n\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n\n            entries.push([op, operands]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n\n    return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n\n    return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    var newDict = {};\n    var value;\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (var i = 0; i < meta.length; i += 1) {\n        var m = meta[i];\n\n        if (Array.isArray(m.type)) {\n            var values = [];\n            values.length = m.type.length;\n            for (var j = 0; j < m.type.length; j++) {\n                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                if (value === undefined) {\n                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n                }\n                if (m.type[j] === 'SID') {\n                    value = getCFFString(strings, value);\n                }\n                values[j] = value;\n            }\n            newDict[m.name] = values;\n        } else {\n            value = dict[m.op];\n            if (value === undefined) {\n                value = m.value !== undefined ? m.value : null;\n            }\n\n            if (m.type === 'SID') {\n                value = getCFFString(strings, value);\n            }\n            newDict[m.name] = value;\n        }\n    }\n\n    return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    var header = {};\n    header.formatMajor = parse.getCard8(data, start);\n    header.formatMinor = parse.getCard8(data, start + 1);\n    header.size = parse.getCard8(data, start + 2);\n    header.offsetSize = parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\n\nvar TOP_DICT_META = [\n    {name: 'version', op: 0, type: 'SID'},\n    {name: 'notice', op: 1, type: 'SID'},\n    {name: 'copyright', op: 1200, type: 'SID'},\n    {name: 'fullName', op: 2, type: 'SID'},\n    {name: 'familyName', op: 3, type: 'SID'},\n    {name: 'weight', op: 4, type: 'SID'},\n    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},\n    {name: 'italicAngle', op: 1202, type: 'number', value: 0},\n    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},\n    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},\n    {name: 'paintType', op: 1205, type: 'number', value: 0},\n    {name: 'charstringType', op: 1206, type: 'number', value: 2},\n    {\n        name: 'fontMatrix',\n        op: 1207,\n        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n        value: [0.001, 0, 0, 0.001, 0, 0]\n    },\n    {name: 'uniqueId', op: 13, type: 'number'},\n    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},\n    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},\n    {name: 'xuid', op: 14, type: [], value: null},\n    {name: 'charset', op: 15, type: 'offset', value: 0},\n    {name: 'encoding', op: 16, type: 'offset', value: 0},\n    {name: 'charStrings', op: 17, type: 'offset', value: 0},\n    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},\n    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},\n    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},\n    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},\n    {name: 'cidFontType', op: 1233, type: 'number', value: 0},\n    {name: 'cidCount', op: 1234, type: 'number', value: 8720},\n    {name: 'uidBase', op: 1235, type: 'number'},\n    {name: 'fdArray', op: 1236, type: 'offset'},\n    {name: 'fdSelect', op: 1237, type: 'offset'},\n    {name: 'fontName', op: 1238, type: 'SID'}\n];\n\nvar PRIVATE_DICT_META = [\n    {name: 'subrs', op: 19, type: 'offset', value: 0},\n    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},\n    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}\n];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    var dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    var dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n    var topDictArray = [];\n    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n        var topDict = parseCFFTopDict(topDictData, strings);\n        topDict._subrs = [];\n        topDict._subrsBias = 0;\n        topDict._defaultWidthX = 0;\n        topDict._nominalWidthX = 0;\n        var privateSize = topDict.private[0];\n        var privateOffset = topDict.private[1];\n        if (privateSize !== 0 && privateOffset !== 0) {\n            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n            topDict._defaultWidthX = privateDict.defaultWidthX;\n            topDict._nominalWidthX = privateDict.nominalWidthX;\n            if (privateDict.subrs !== 0) {\n                var subrOffset = privateOffset + privateDict.subrs;\n                var subrIndex = parseCFFIndex(data, subrOffset + start);\n                topDict._subrs = subrIndex.objects;\n                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n            }\n            topDict._privateDict = privateDict;\n        }\n        topDictArray.push(topDict);\n    }\n    return topDictArray;\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    var sid;\n    var count;\n    var parser = new parse.Parser(data, start);\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    var charset = ['.notdef'];\n\n    var format = parser.parseCard8();\n    if (format === 0) {\n        for (var i = 0; i < nGlyphs; i += 1) {\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown charset format ' + format);\n    }\n\n    return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    var code;\n    var enc = {};\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        var nCodes = parser.parseCard8();\n        for (var i = 0; i < nCodes; i += 1) {\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        var nRanges = parser.parseCard8();\n        code = 1;\n        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n            var first = parser.parseCard8();\n            var nLeft = parser.parseCard8();\n            for (var j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown encoding format ' + format);\n    }\n\n    return new CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n    var c1x;\n    var c1y;\n    var c2x;\n    var c2y;\n    var p = new Path();\n    var stack = [];\n    var nStems = 0;\n    var haveWidth = false;\n    var open = false;\n    var x = 0;\n    var y = 0;\n    var subrs;\n    var subrsBias;\n    var defaultWidthX;\n    var nominalWidthX;\n    if (font.isCIDFont) {\n        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n        subrs = fdDict._subrs;\n        subrsBias = fdDict._subrsBias;\n        defaultWidthX = fdDict._defaultWidthX;\n        nominalWidthX = fdDict._nominalWidthX;\n    } else {\n        subrs = font.tables.cff.topDict._subrs;\n        subrsBias = font.tables.cff.topDict._subrsBias;\n        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n    }\n    var width = defaultWidthX;\n\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n\n        p.moveTo(x, y);\n        open = true;\n    }\n\n    function parseStems() {\n        var hasWidthArg;\n\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n        }\n\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n\n    function parse(code) {\n        var b1;\n        var b2;\n        var b3;\n        var b4;\n        var codeIndex;\n        var subrCode;\n        var jpx;\n        var jpy;\n        var c3x;\n        var c3y;\n        var c4x;\n        var c4y;\n\n        var i = 0;\n        while (i < code.length) {\n            var v = code[i];\n            i += 1;\n            switch (v) {\n                case 1: // hstem\n                    parseStems();\n                    break;\n                case 3: // vstem\n                    parseStems();\n                    break;\n                case 4: // vmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 5: // rlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 6: // hlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 7: // vlineto\n                    while (stack.length > 0) {\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 8: // rrcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 10: // callsubr\n                    codeIndex = stack.pop() + subrsBias;\n                    subrCode = subrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 11: // return\n                    return;\n                case 12: // flex operators\n                    v = code[i];\n                    i += 1;\n                    switch (v) {\n                        case 35: // flex\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x   + stack.shift();    // dx6\n                            y = c4y   + stack.shift();    // dy6\n                            stack.shift();                // flex depth\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 34: // hflex\n                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y;                      // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = y;                      // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 36: // hflex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 37: // flex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                x = c4x + stack.shift();\n                            } else {\n                                y = c4y + stack.shift();\n                            }\n\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        default:\n                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n                            stack.length = 0;\n                    }\n                    break;\n                case 14: // endchar\n                    if (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    if (open) {\n                        p.closePath();\n                        open = false;\n                    }\n\n                    break;\n                case 18: // hstemhm\n                    parseStems();\n                    break;\n                case 19: // hintmask\n                case 20: // cntrmask\n                    parseStems();\n                    i += (nStems + 7) >> 3;\n                    break;\n                case 21: // rmoveto\n                    if (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 22: // hmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 23: // vstemhm\n                    parseStems();\n                    break;\n                case 24: // rcurveline\n                    while (stack.length > 2) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    break;\n                case 25: // rlinecurve\n                    while (stack.length > 6) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    break;\n                case 26: // vvcurveto\n                    if (stack.length % 2) {\n                        x += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 27: // hhcurveto\n                    if (stack.length % 2) {\n                        y += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 28: // shortint\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                    i += 2;\n                    break;\n                case 29: // callgsubr\n                    codeIndex = stack.pop() + font.gsubrsBias;\n                    subrCode = font.gsubrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 30: // vhcurveto\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 31: // hvcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                default:\n                    if (v < 32) {\n                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n                    } else if (v < 247) {\n                        stack.push(v - 139);\n                    } else if (v < 251) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push((v - 247) * 256 + b1 + 108);\n                    } else if (v < 255) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push(-(v - 251) * 256 - b1 - 108);\n                    } else {\n                        b1 = code[i];\n                        b2 = code[i + 1];\n                        b3 = code[i + 2];\n                        b4 = code[i + 3];\n                        i += 4;\n                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);\n                    }\n            }\n        }\n    }\n\n    parse(code);\n\n    glyph.advanceWidth = width;\n    return p;\n}\n\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    var fdSelect = [];\n    var fdIndex;\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        // Simple list of nGlyphs elements\n        for (var iGid = 0; iGid < nGlyphs; iGid++) {\n            fdIndex = parser.parseCard8();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            fdSelect.push(fdIndex);\n        }\n    } else if (format === 3) {\n        // Ranges\n        var nRanges = parser.parseCard16();\n        var first = parser.parseCard16();\n        if (first !== 0) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n        }\n        var next;\n        for (var iRange = 0; iRange < nRanges; iRange++) {\n            fdIndex = parser.parseCard8();\n            next = parser.parseCard16();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            if (next > nGlyphs) {\n                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n            }\n            for (; first < next; first++) {\n                fdSelect.push(fdIndex);\n            }\n            first = next;\n        }\n        if (next !== nGlyphs) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n        }\n    } else {\n        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n    }\n    return fdSelect;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font, opt) {\n    font.tables.cff = {};\n    var header = parseCFFHeader(data, start);\n    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n    if (topDictArray.length !== 1) {\n        throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n    }\n\n    var topDict = topDictArray[0];\n    font.tables.cff.topDict = topDict;\n\n    if (topDict._privateDict) {\n        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n    }\n\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n        font.isCIDFont = true;\n    }\n\n    if (font.isCIDFont) {\n        var fdArrayOffset = topDict.fdArray;\n        var fdSelectOffset = topDict.fdSelect;\n        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n        }\n        fdArrayOffset += start;\n        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n        topDict._fdArray = fdArray;\n        fdSelectOffset += start;\n        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n    }\n\n    var privateDictOffset = start + topDict.private[1];\n    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n\n    if (privateDict.subrs !== 0) {\n        var subrOffset = privateDictOffset + privateDict.subrs;\n        var subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    var charStringsIndex;\n    if (opt.lowMemory) {\n        charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.offsets.length;\n    } else {\n        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.objects.length;\n    }\n\n    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n    if (topDict.encoding === 0) {\n        // Standard encoding\n        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) {\n        // Expert encoding\n        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n\n    font.glyphs = new glyphset.GlyphSet(font);\n    if (opt.lowMemory) {\n        font._push = function(i) {\n            var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        };\n    } else {\n        for (var i = 0; i < font.nGlyphs; i += 1) {\n            var charString = charStringsIndex.objects[i];\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        }\n    }\n}\n\n// Convert a string to a String ID (SID).\n// The list of strings is modified in place.\nfunction encodeString(s, strings) {\n    var sid;\n\n    // Is the string in the CFF standard strings?\n    var i = cffStandardStrings.indexOf(s);\n    if (i >= 0) {\n        sid = i;\n    }\n\n    // Is the string already in the string index?\n    i = strings.indexOf(s);\n    if (i >= 0) {\n        sid = i + cffStandardStrings.length;\n    } else {\n        sid = cffStandardStrings.length + strings.length;\n        strings.push(s);\n    }\n\n    return sid;\n}\n\nfunction makeHeader() {\n    return new table.Record('Header', [\n        {name: 'major', type: 'Card8', value: 1},\n        {name: 'minor', type: 'Card8', value: 0},\n        {name: 'hdrSize', type: 'Card8', value: 4},\n        {name: 'major', type: 'Card8', value: 1}\n    ]);\n}\n\nfunction makeNameIndex(fontNames) {\n    var t = new table.Record('Name INDEX', [\n        {name: 'names', type: 'INDEX', value: []}\n    ]);\n    t.names = [];\n    for (var i = 0; i < fontNames.length; i += 1) {\n        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});\n    }\n\n    return t;\n}\n\n// Given a dictionary's metadata, create a DICT structure.\nfunction makeDict(meta, attrs, strings) {\n    var m = {};\n    for (var i = 0; i < meta.length; i += 1) {\n        var entry = meta[i];\n        var value = attrs[entry.name];\n        if (value !== undefined && !equals(value, entry.value)) {\n            if (entry.type === 'SID') {\n                value = encodeString(value, strings);\n            }\n\n            m[entry.op] = {name: entry.name, type: entry.type, value: value};\n        }\n    }\n\n    return m;\n}\n\n// The Top DICT houses the global font attributes.\nfunction makeTopDict(attrs, strings) {\n    var t = new table.Record('Top DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(TOP_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeTopDictIndex(topDict) {\n    var t = new table.Record('Top DICT INDEX', [\n        {name: 'topDicts', type: 'INDEX', value: []}\n    ]);\n    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];\n    return t;\n}\n\nfunction makeStringIndex(strings) {\n    var t = new table.Record('String INDEX', [\n        {name: 'strings', type: 'INDEX', value: []}\n    ]);\n    t.strings = [];\n    for (var i = 0; i < strings.length; i += 1) {\n        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});\n    }\n\n    return t;\n}\n\nfunction makeGlobalSubrIndex() {\n    // Currently we don't use subroutines.\n    return new table.Record('Global Subr INDEX', [\n        {name: 'subrs', type: 'INDEX', value: []}\n    ]);\n}\n\nfunction makeCharsets(glyphNames, strings) {\n    var t = new table.Record('Charsets', [\n        {name: 'format', type: 'Card8', value: 0}\n    ]);\n    for (var i = 0; i < glyphNames.length; i += 1) {\n        var glyphName = glyphNames[i];\n        var glyphSID = encodeString(glyphName, strings);\n        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});\n    }\n\n    return t;\n}\n\nfunction glyphToOps(glyph) {\n    var ops = [];\n    var path = glyph.path;\n    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});\n    var x = 0;\n    var y = 0;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var dx = (void 0);\n        var dy = (void 0);\n        var cmd = path.commands[i];\n        if (cmd.type === 'Q') {\n            // CFF only supports bzier curves, so convert the quad to a bzier.\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n\n            // We're going to create a new command so we don't change the original path.\n            // Since all coordinates are relative, we round() them ASAP to avoid propagating errors.\n            cmd = {\n                type: 'C',\n                x: cmd.x,\n                y: cmd.y,\n                x1: Math.round(_13 * x + _23 * cmd.x1),\n                y1: Math.round(_13 * y + _23 * cmd.y1),\n                x2: Math.round(_13 * cmd.x + _23 * cmd.x1),\n                y2: Math.round(_13 * cmd.y + _23 * cmd.y1)\n            };\n        }\n\n        if (cmd.type === 'M') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rmoveto', type: 'OP', value: 21});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'L') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rlineto', type: 'OP', value: 5});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'C') {\n            var dx1 = Math.round(cmd.x1 - x);\n            var dy1 = Math.round(cmd.y1 - y);\n            var dx2 = Math.round(cmd.x2 - cmd.x1);\n            var dy2 = Math.round(cmd.y2 - cmd.y1);\n            dx = Math.round(cmd.x - cmd.x2);\n            dy = Math.round(cmd.y - cmd.y2);\n            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});\n            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});\n            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});\n            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rrcurveto', type: 'OP', value: 8});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        }\n\n        // Contours are closed automatically.\n    }\n\n    ops.push({name: 'endchar', type: 'OP', value: 14});\n    return ops;\n}\n\nfunction makeCharStringsIndex(glyphs) {\n    var t = new table.Record('CharStrings INDEX', [\n        {name: 'charStrings', type: 'INDEX', value: []}\n    ]);\n\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var ops = glyphToOps(glyph);\n        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});\n    }\n\n    return t;\n}\n\nfunction makePrivateDict(attrs, strings) {\n    var t = new table.Record('Private DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeCFFTable(glyphs, options) {\n    var t = new table.Table('CFF ', [\n        {name: 'header', type: 'RECORD'},\n        {name: 'nameIndex', type: 'RECORD'},\n        {name: 'topDictIndex', type: 'RECORD'},\n        {name: 'stringIndex', type: 'RECORD'},\n        {name: 'globalSubrIndex', type: 'RECORD'},\n        {name: 'charsets', type: 'RECORD'},\n        {name: 'charStringsIndex', type: 'RECORD'},\n        {name: 'privateDict', type: 'RECORD'}\n    ]);\n\n    var fontScale = 1 / options.unitsPerEm;\n    // We use non-zero values for the offsets so that the DICT encodes them.\n    // This is important because the size of the Top DICT plays a role in offset calculation,\n    // and the size shouldn't change after we've written correct offsets.\n    var attrs = {\n        version: options.version,\n        fullName: options.fullName,\n        familyName: options.familyName,\n        weight: options.weightName,\n        fontBBox: options.fontBBox || [0, 0, 0, 0],\n        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n        charset: 999,\n        encoding: 0,\n        charStrings: 999,\n        private: [0, 999]\n    };\n\n    var privateAttrs = {};\n\n    var glyphNames = [];\n    var glyph;\n\n    // Skip first glyph (.notdef)\n    for (var i = 1; i < glyphs.length; i += 1) {\n        glyph = glyphs.get(i);\n        glyphNames.push(glyph.name);\n    }\n\n    var strings = [];\n\n    t.header = makeHeader();\n    t.nameIndex = makeNameIndex([options.postScriptName]);\n    var topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n    t.globalSubrIndex = makeGlobalSubrIndex();\n    t.charsets = makeCharsets(glyphNames, strings);\n    t.charStringsIndex = makeCharStringsIndex(glyphs);\n    t.privateDict = makePrivateDict(privateAttrs, strings);\n\n    // Needs to come at the end, to encode all custom strings used in the font.\n    t.stringIndex = makeStringIndex(strings);\n\n    var startOffset = t.header.sizeOf() +\n        t.nameIndex.sizeOf() +\n        t.topDictIndex.sizeOf() +\n        t.stringIndex.sizeOf() +\n        t.globalSubrIndex.sizeOf();\n    attrs.charset = startOffset;\n\n    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n    attrs.encoding = 0;\n    attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n    // Recreate the Top DICT INDEX with the correct offsets.\n    topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n\n    return t;\n}\n\nvar cff = { parse: parseCFFTable, make: makeCFFTable };\n\n// The `head` table contains global information about the font.\n\n// Parse the header `head` table\nfunction parseHeadTable(data, start) {\n    var head = {};\n    var p = new parse.Parser(data, start);\n    head.version = p.parseVersion();\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n    head.checkSumAdjustment = p.parseULong();\n    head.magicNumber = p.parseULong();\n    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');\n    head.flags = p.parseUShort();\n    head.unitsPerEm = p.parseUShort();\n    head.created = p.parseLongDateTime();\n    head.modified = p.parseLongDateTime();\n    head.xMin = p.parseShort();\n    head.yMin = p.parseShort();\n    head.xMax = p.parseShort();\n    head.yMax = p.parseShort();\n    head.macStyle = p.parseUShort();\n    head.lowestRecPPEM = p.parseUShort();\n    head.fontDirectionHint = p.parseShort();\n    head.indexToLocFormat = p.parseShort();\n    head.glyphDataFormat = p.parseShort();\n    return head;\n}\n\nfunction makeHeadTable(options) {\n    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970\n    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;\n    var createdTimestamp = timestamp;\n\n    if (options.createdTimestamp) {\n        createdTimestamp = options.createdTimestamp + 2082844800;\n    }\n\n    return new table.Table('head', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},\n        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},\n        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},\n        {name: 'flags', type: 'USHORT', value: 0},\n        {name: 'unitsPerEm', type: 'USHORT', value: 1000},\n        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},\n        {name: 'modified', type: 'LONGDATETIME', value: timestamp},\n        {name: 'xMin', type: 'SHORT', value: 0},\n        {name: 'yMin', type: 'SHORT', value: 0},\n        {name: 'xMax', type: 'SHORT', value: 0},\n        {name: 'yMax', type: 'SHORT', value: 0},\n        {name: 'macStyle', type: 'USHORT', value: 0},\n        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},\n        {name: 'fontDirectionHint', type: 'SHORT', value: 2},\n        {name: 'indexToLocFormat', type: 'SHORT', value: 0},\n        {name: 'glyphDataFormat', type: 'SHORT', value: 0}\n    ], options);\n}\n\nvar head = { parse: parseHeadTable, make: makeHeadTable };\n\n// The `hhea` table contains information for horizontal layout.\n\n// Parse the horizontal header `hhea` table\nfunction parseHheaTable(data, start) {\n    var hhea = {};\n    var p = new parse.Parser(data, start);\n    hhea.version = p.parseVersion();\n    hhea.ascender = p.parseShort();\n    hhea.descender = p.parseShort();\n    hhea.lineGap = p.parseShort();\n    hhea.advanceWidthMax = p.parseUShort();\n    hhea.minLeftSideBearing = p.parseShort();\n    hhea.minRightSideBearing = p.parseShort();\n    hhea.xMaxExtent = p.parseShort();\n    hhea.caretSlopeRise = p.parseShort();\n    hhea.caretSlopeRun = p.parseShort();\n    hhea.caretOffset = p.parseShort();\n    p.relativeOffset += 8;\n    hhea.metricDataFormat = p.parseShort();\n    hhea.numberOfHMetrics = p.parseUShort();\n    return hhea;\n}\n\nfunction makeHheaTable(options) {\n    return new table.Table('hhea', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'ascender', type: 'FWORD', value: 0},\n        {name: 'descender', type: 'FWORD', value: 0},\n        {name: 'lineGap', type: 'FWORD', value: 0},\n        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},\n        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},\n        {name: 'minRightSideBearing', type: 'FWORD', value: 0},\n        {name: 'xMaxExtent', type: 'FWORD', value: 0},\n        {name: 'caretSlopeRise', type: 'SHORT', value: 1},\n        {name: 'caretSlopeRun', type: 'SHORT', value: 0},\n        {name: 'caretOffset', type: 'SHORT', value: 0},\n        {name: 'reserved1', type: 'SHORT', value: 0},\n        {name: 'reserved2', type: 'SHORT', value: 0},\n        {name: 'reserved3', type: 'SHORT', value: 0},\n        {name: 'reserved4', type: 'SHORT', value: 0},\n        {name: 'metricDataFormat', type: 'SHORT', value: 0},\n        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}\n    ], options);\n}\n\nvar hhea = { parse: parseHheaTable, make: makeHheaTable };\n\n// The `hmtx` table contains the horizontal metrics for all glyphs.\n\nfunction parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        var glyph = glyphs.get(i);\n        glyph.advanceWidth = advanceWidth;\n        glyph.leftSideBearing = leftSideBearing;\n    }\n}\n\nfunction parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n    font._hmtxTableData = {};\n\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        font._hmtxTableData[i] = {\n            advanceWidth: advanceWidth,\n            leftSideBearing: leftSideBearing\n        };\n    }\n}\n\n// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\nfunction parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n    if (opt.lowMemory)\n        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }\n    else\n        { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }\n}\n\nfunction makeHmtxTable(glyphs) {\n    var t = new table.Table('hmtx', []);\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var advanceWidth = glyph.advanceWidth || 0;\n        var leftSideBearing = glyph.leftSideBearing || 0;\n        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});\n        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});\n    }\n\n    return t;\n}\n\nvar hmtx = { parse: parseHmtxTable, make: makeHmtxTable };\n\n// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\nfunction makeLtagTable(tags) {\n    var result = new table.Table('ltag', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'numTags', type: 'ULONG', value: tags.length}\n    ]);\n\n    var stringPool = '';\n    var stringPoolOffset = 12 + tags.length * 4;\n    for (var i = 0; i < tags.length; ++i) {\n        var pos = stringPool.indexOf(tags[i]);\n        if (pos < 0) {\n            pos = stringPool.length;\n            stringPool += tags[i];\n        }\n\n        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n    return result;\n}\n\nfunction parseLtagTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n    // The 'ltag' specification does not define any flags; skip the field.\n    p.skip('uLong', 1);\n    var numTags = p.parseULong();\n\n    var tags = [];\n    for (var i = 0; i < numTags; i++) {\n        var tag = '';\n        var offset = start + p.parseUShort();\n        var length = p.parseUShort();\n        for (var j = offset; j < offset + length; ++j) {\n            tag += String.fromCharCode(data.getInt8(j));\n        }\n\n        tags.push(tag);\n    }\n\n    return tags;\n}\n\nvar ltag = { make: makeLtagTable, parse: parseLtagTable };\n\n// The `maxp` table establishes the memory requirements for the font.\n\n// Parse the maximum profile `maxp` table.\nfunction parseMaxpTable(data, start) {\n    var maxp = {};\n    var p = new parse.Parser(data, start);\n    maxp.version = p.parseVersion();\n    maxp.numGlyphs = p.parseUShort();\n    if (maxp.version === 1.0) {\n        maxp.maxPoints = p.parseUShort();\n        maxp.maxContours = p.parseUShort();\n        maxp.maxCompositePoints = p.parseUShort();\n        maxp.maxCompositeContours = p.parseUShort();\n        maxp.maxZones = p.parseUShort();\n        maxp.maxTwilightPoints = p.parseUShort();\n        maxp.maxStorage = p.parseUShort();\n        maxp.maxFunctionDefs = p.parseUShort();\n        maxp.maxInstructionDefs = p.parseUShort();\n        maxp.maxStackElements = p.parseUShort();\n        maxp.maxSizeOfInstructions = p.parseUShort();\n        maxp.maxComponentElements = p.parseUShort();\n        maxp.maxComponentDepth = p.parseUShort();\n    }\n\n    return maxp;\n}\n\nfunction makeMaxpTable(numGlyphs) {\n    return new table.Table('maxp', [\n        {name: 'version', type: 'FIXED', value: 0x00005000},\n        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}\n    ]);\n}\n\nvar maxp = { parse: parseMaxpTable, make: makeMaxpTable };\n\n// The `name` naming table.\n\n// NameIDs for the name table.\nvar nameTableNames = [\n    'copyright',              // 0\n    'fontFamily',             // 1\n    'fontSubfamily',          // 2\n    'uniqueID',               // 3\n    'fullName',               // 4\n    'version',                // 5\n    'postScriptName',         // 6\n    'trademark',              // 7\n    'manufacturer',           // 8\n    'designer',               // 9\n    'description',            // 10\n    'manufacturerURL',        // 11\n    'designerURL',            // 12\n    'license',                // 13\n    'licenseURL',             // 14\n    'reserved',               // 15\n    'preferredFamily',        // 16\n    'preferredSubfamily',     // 17\n    'compatibleFullName',     // 18\n    'sampleText',             // 19\n    'postScriptFindFontName', // 20\n    'wwsFamily',              // 21\n    'wwsSubfamily'            // 22\n];\n\nvar macLanguages = {\n    0: 'en',\n    1: 'fr',\n    2: 'de',\n    3: 'it',\n    4: 'nl',\n    5: 'sv',\n    6: 'es',\n    7: 'da',\n    8: 'pt',\n    9: 'no',\n    10: 'he',\n    11: 'ja',\n    12: 'ar',\n    13: 'fi',\n    14: 'el',\n    15: 'is',\n    16: 'mt',\n    17: 'tr',\n    18: 'hr',\n    19: 'zh-Hant',\n    20: 'ur',\n    21: 'hi',\n    22: 'th',\n    23: 'ko',\n    24: 'lt',\n    25: 'pl',\n    26: 'hu',\n    27: 'es',\n    28: 'lv',\n    29: 'se',\n    30: 'fo',\n    31: 'fa',\n    32: 'ru',\n    33: 'zh',\n    34: 'nl-BE',\n    35: 'ga',\n    36: 'sq',\n    37: 'ro',\n    38: 'cz',\n    39: 'sk',\n    40: 'si',\n    41: 'yi',\n    42: 'sr',\n    43: 'mk',\n    44: 'bg',\n    45: 'uk',\n    46: 'be',\n    47: 'uz',\n    48: 'kk',\n    49: 'az-Cyrl',\n    50: 'az-Arab',\n    51: 'hy',\n    52: 'ka',\n    53: 'mo',\n    54: 'ky',\n    55: 'tg',\n    56: 'tk',\n    57: 'mn-CN',\n    58: 'mn',\n    59: 'ps',\n    60: 'ks',\n    61: 'ku',\n    62: 'sd',\n    63: 'bo',\n    64: 'ne',\n    65: 'sa',\n    66: 'mr',\n    67: 'bn',\n    68: 'as',\n    69: 'gu',\n    70: 'pa',\n    71: 'or',\n    72: 'ml',\n    73: 'kn',\n    74: 'ta',\n    75: 'te',\n    76: 'si',\n    77: 'my',\n    78: 'km',\n    79: 'lo',\n    80: 'vi',\n    81: 'id',\n    82: 'tl',\n    83: 'ms',\n    84: 'ms-Arab',\n    85: 'am',\n    86: 'ti',\n    87: 'om',\n    88: 'so',\n    89: 'sw',\n    90: 'rw',\n    91: 'rn',\n    92: 'ny',\n    93: 'mg',\n    94: 'eo',\n    128: 'cy',\n    129: 'eu',\n    130: 'ca',\n    131: 'la',\n    132: 'qu',\n    133: 'gn',\n    134: 'ay',\n    135: 'tt',\n    136: 'ug',\n    137: 'dz',\n    138: 'jv',\n    139: 'su',\n    140: 'gl',\n    141: 'af',\n    142: 'br',\n    143: 'iu',\n    144: 'gd',\n    145: 'gv',\n    146: 'ga',\n    147: 'to',\n    148: 'el-polyton',\n    149: 'kl',\n    150: 'az',\n    151: 'nn'\n};\n\n// MacOS language ID  MacOS script ID\n//\n// Note that the script ID is not sufficient to determine what encoding\n// to use in TrueType files. For some languages, MacOS used a modification\n// of a mainstream script. For example, an Icelandic name would be stored\n// with smRoman in the TrueType naming table, but the actual encoding\n// is a special Icelandic version of the normal Macintosh Roman encoding.\n// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal\n// Syllables but MacOS had run out of available script codes, so this was\n// done as a (pretty radical) \"modification\" of Ethiopic.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nvar macLanguageToScript = {\n    0: 0,  // langEnglish  smRoman\n    1: 0,  // langFrench  smRoman\n    2: 0,  // langGerman  smRoman\n    3: 0,  // langItalian  smRoman\n    4: 0,  // langDutch  smRoman\n    5: 0,  // langSwedish  smRoman\n    6: 0,  // langSpanish  smRoman\n    7: 0,  // langDanish  smRoman\n    8: 0,  // langPortuguese  smRoman\n    9: 0,  // langNorwegian  smRoman\n    10: 5,  // langHebrew  smHebrew\n    11: 1,  // langJapanese  smJapanese\n    12: 4,  // langArabic  smArabic\n    13: 0,  // langFinnish  smRoman\n    14: 6,  // langGreek  smGreek\n    15: 0,  // langIcelandic  smRoman (modified)\n    16: 0,  // langMaltese  smRoman\n    17: 0,  // langTurkish  smRoman (modified)\n    18: 0,  // langCroatian  smRoman (modified)\n    19: 2,  // langTradChinese  smTradChinese\n    20: 4,  // langUrdu  smArabic\n    21: 9,  // langHindi  smDevanagari\n    22: 21,  // langThai  smThai\n    23: 3,  // langKorean  smKorean\n    24: 29,  // langLithuanian  smCentralEuroRoman\n    25: 29,  // langPolish  smCentralEuroRoman\n    26: 29,  // langHungarian  smCentralEuroRoman\n    27: 29,  // langEstonian  smCentralEuroRoman\n    28: 29,  // langLatvian  smCentralEuroRoman\n    29: 0,  // langSami  smRoman\n    30: 0,  // langFaroese  smRoman (modified)\n    31: 4,  // langFarsi  smArabic (modified)\n    32: 7,  // langRussian  smCyrillic\n    33: 25,  // langSimpChinese  smSimpChinese\n    34: 0,  // langFlemish  smRoman\n    35: 0,  // langIrishGaelic  smRoman (modified)\n    36: 0,  // langAlbanian  smRoman\n    37: 0,  // langRomanian  smRoman (modified)\n    38: 29,  // langCzech  smCentralEuroRoman\n    39: 29,  // langSlovak  smCentralEuroRoman\n    40: 0,  // langSlovenian  smRoman (modified)\n    41: 5,  // langYiddish  smHebrew\n    42: 7,  // langSerbian  smCyrillic\n    43: 7,  // langMacedonian  smCyrillic\n    44: 7,  // langBulgarian  smCyrillic\n    45: 7,  // langUkrainian  smCyrillic (modified)\n    46: 7,  // langByelorussian  smCyrillic\n    47: 7,  // langUzbek  smCyrillic\n    48: 7,  // langKazakh  smCyrillic\n    49: 7,  // langAzerbaijani  smCyrillic\n    50: 4,  // langAzerbaijanAr  smArabic\n    51: 24,  // langArmenian  smArmenian\n    52: 23,  // langGeorgian  smGeorgian\n    53: 7,  // langMoldavian  smCyrillic\n    54: 7,  // langKirghiz  smCyrillic\n    55: 7,  // langTajiki  smCyrillic\n    56: 7,  // langTurkmen  smCyrillic\n    57: 27,  // langMongolian  smMongolian\n    58: 7,  // langMongolianCyr  smCyrillic\n    59: 4,  // langPashto  smArabic\n    60: 4,  // langKurdish  smArabic\n    61: 4,  // langKashmiri  smArabic\n    62: 4,  // langSindhi  smArabic\n    63: 26,  // langTibetan  smTibetan\n    64: 9,  // langNepali  smDevanagari\n    65: 9,  // langSanskrit  smDevanagari\n    66: 9,  // langMarathi  smDevanagari\n    67: 13,  // langBengali  smBengali\n    68: 13,  // langAssamese  smBengali\n    69: 11,  // langGujarati  smGujarati\n    70: 10,  // langPunjabi  smGurmukhi\n    71: 12,  // langOriya  smOriya\n    72: 17,  // langMalayalam  smMalayalam\n    73: 16,  // langKannada  smKannada\n    74: 14,  // langTamil  smTamil\n    75: 15,  // langTelugu  smTelugu\n    76: 18,  // langSinhalese  smSinhalese\n    77: 19,  // langBurmese  smBurmese\n    78: 20,  // langKhmer  smKhmer\n    79: 22,  // langLao  smLao\n    80: 30,  // langVietnamese  smVietnamese\n    81: 0,  // langIndonesian  smRoman\n    82: 0,  // langTagalog  smRoman\n    83: 0,  // langMalayRoman  smRoman\n    84: 4,  // langMalayArabic  smArabic\n    85: 28,  // langAmharic  smEthiopic\n    86: 28,  // langTigrinya  smEthiopic\n    87: 28,  // langOromo  smEthiopic\n    88: 0,  // langSomali  smRoman\n    89: 0,  // langSwahili  smRoman\n    90: 0,  // langKinyarwanda  smRoman\n    91: 0,  // langRundi  smRoman\n    92: 0,  // langNyanja  smRoman\n    93: 0,  // langMalagasy  smRoman\n    94: 0,  // langEsperanto  smRoman\n    128: 0,  // langWelsh  smRoman (modified)\n    129: 0,  // langBasque  smRoman\n    130: 0,  // langCatalan  smRoman\n    131: 0,  // langLatin  smRoman\n    132: 0,  // langQuechua  smRoman\n    133: 0,  // langGuarani  smRoman\n    134: 0,  // langAymara  smRoman\n    135: 7,  // langTatar  smCyrillic\n    136: 4,  // langUighur  smArabic\n    137: 26,  // langDzongkha  smTibetan\n    138: 0,  // langJavaneseRom  smRoman\n    139: 0,  // langSundaneseRom  smRoman\n    140: 0,  // langGalician  smRoman\n    141: 0,  // langAfrikaans  smRoman\n    142: 0,  // langBreton  smRoman (modified)\n    143: 28,  // langInuktitut  smEthiopic (modified)\n    144: 0,  // langScottishGaelic  smRoman (modified)\n    145: 0,  // langManxGaelic  smRoman (modified)\n    146: 0,  // langIrishGaelicScript  smRoman (modified)\n    147: 0,  // langTongan  smRoman\n    148: 6,  // langGreekAncient  smRoman\n    149: 0,  // langGreenlandic  smRoman\n    150: 0,  // langAzerbaijanRoman  smRoman\n    151: 0   // langNynorsk  smRoman\n};\n\n// While Microsoft indicates a region/country for all its language\n// IDs, we omit the region code if it's equal to the \"most likely\n// region subtag\" according to Unicode CLDR. For scripts, we omit\n// the subtag if it is equal to the Suppress-Script entry in the\n// IANA language subtag registry for IETF BCP 47.\n//\n// For example, Microsoft states that its language code 0x041A is\n// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'\n// and not 'hr-HR' because Croatia is the default country for Croatian,\n// according to Unicode CLDR. As another example, Microsoft states\n// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform\n// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script\n// for the Croatian language, according to IANA.\n//\n// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html\n// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\nvar windowsLanguages = {\n    0x0436: 'af',\n    0x041C: 'sq',\n    0x0484: 'gsw',\n    0x045E: 'am',\n    0x1401: 'ar-DZ',\n    0x3C01: 'ar-BH',\n    0x0C01: 'ar',\n    0x0801: 'ar-IQ',\n    0x2C01: 'ar-JO',\n    0x3401: 'ar-KW',\n    0x3001: 'ar-LB',\n    0x1001: 'ar-LY',\n    0x1801: 'ary',\n    0x2001: 'ar-OM',\n    0x4001: 'ar-QA',\n    0x0401: 'ar-SA',\n    0x2801: 'ar-SY',\n    0x1C01: 'aeb',\n    0x3801: 'ar-AE',\n    0x2401: 'ar-YE',\n    0x042B: 'hy',\n    0x044D: 'as',\n    0x082C: 'az-Cyrl',\n    0x042C: 'az',\n    0x046D: 'ba',\n    0x042D: 'eu',\n    0x0423: 'be',\n    0x0845: 'bn',\n    0x0445: 'bn-IN',\n    0x201A: 'bs-Cyrl',\n    0x141A: 'bs',\n    0x047E: 'br',\n    0x0402: 'bg',\n    0x0403: 'ca',\n    0x0C04: 'zh-HK',\n    0x1404: 'zh-MO',\n    0x0804: 'zh',\n    0x1004: 'zh-SG',\n    0x0404: 'zh-TW',\n    0x0483: 'co',\n    0x041A: 'hr',\n    0x101A: 'hr-BA',\n    0x0405: 'cs',\n    0x0406: 'da',\n    0x048C: 'prs',\n    0x0465: 'dv',\n    0x0813: 'nl-BE',\n    0x0413: 'nl',\n    0x0C09: 'en-AU',\n    0x2809: 'en-BZ',\n    0x1009: 'en-CA',\n    0x2409: 'en-029',\n    0x4009: 'en-IN',\n    0x1809: 'en-IE',\n    0x2009: 'en-JM',\n    0x4409: 'en-MY',\n    0x1409: 'en-NZ',\n    0x3409: 'en-PH',\n    0x4809: 'en-SG',\n    0x1C09: 'en-ZA',\n    0x2C09: 'en-TT',\n    0x0809: 'en-GB',\n    0x0409: 'en',\n    0x3009: 'en-ZW',\n    0x0425: 'et',\n    0x0438: 'fo',\n    0x0464: 'fil',\n    0x040B: 'fi',\n    0x080C: 'fr-BE',\n    0x0C0C: 'fr-CA',\n    0x040C: 'fr',\n    0x140C: 'fr-LU',\n    0x180C: 'fr-MC',\n    0x100C: 'fr-CH',\n    0x0462: 'fy',\n    0x0456: 'gl',\n    0x0437: 'ka',\n    0x0C07: 'de-AT',\n    0x0407: 'de',\n    0x1407: 'de-LI',\n    0x1007: 'de-LU',\n    0x0807: 'de-CH',\n    0x0408: 'el',\n    0x046F: 'kl',\n    0x0447: 'gu',\n    0x0468: 'ha',\n    0x040D: 'he',\n    0x0439: 'hi',\n    0x040E: 'hu',\n    0x040F: 'is',\n    0x0470: 'ig',\n    0x0421: 'id',\n    0x045D: 'iu',\n    0x085D: 'iu-Latn',\n    0x083C: 'ga',\n    0x0434: 'xh',\n    0x0435: 'zu',\n    0x0410: 'it',\n    0x0810: 'it-CH',\n    0x0411: 'ja',\n    0x044B: 'kn',\n    0x043F: 'kk',\n    0x0453: 'km',\n    0x0486: 'quc',\n    0x0487: 'rw',\n    0x0441: 'sw',\n    0x0457: 'kok',\n    0x0412: 'ko',\n    0x0440: 'ky',\n    0x0454: 'lo',\n    0x0426: 'lv',\n    0x0427: 'lt',\n    0x082E: 'dsb',\n    0x046E: 'lb',\n    0x042F: 'mk',\n    0x083E: 'ms-BN',\n    0x043E: 'ms',\n    0x044C: 'ml',\n    0x043A: 'mt',\n    0x0481: 'mi',\n    0x047A: 'arn',\n    0x044E: 'mr',\n    0x047C: 'moh',\n    0x0450: 'mn',\n    0x0850: 'mn-CN',\n    0x0461: 'ne',\n    0x0414: 'nb',\n    0x0814: 'nn',\n    0x0482: 'oc',\n    0x0448: 'or',\n    0x0463: 'ps',\n    0x0415: 'pl',\n    0x0416: 'pt',\n    0x0816: 'pt-PT',\n    0x0446: 'pa',\n    0x046B: 'qu-BO',\n    0x086B: 'qu-EC',\n    0x0C6B: 'qu',\n    0x0418: 'ro',\n    0x0417: 'rm',\n    0x0419: 'ru',\n    0x243B: 'smn',\n    0x103B: 'smj-NO',\n    0x143B: 'smj',\n    0x0C3B: 'se-FI',\n    0x043B: 'se',\n    0x083B: 'se-SE',\n    0x203B: 'sms',\n    0x183B: 'sma-NO',\n    0x1C3B: 'sms',\n    0x044F: 'sa',\n    0x1C1A: 'sr-Cyrl-BA',\n    0x0C1A: 'sr',\n    0x181A: 'sr-Latn-BA',\n    0x081A: 'sr-Latn',\n    0x046C: 'nso',\n    0x0432: 'tn',\n    0x045B: 'si',\n    0x041B: 'sk',\n    0x0424: 'sl',\n    0x2C0A: 'es-AR',\n    0x400A: 'es-BO',\n    0x340A: 'es-CL',\n    0x240A: 'es-CO',\n    0x140A: 'es-CR',\n    0x1C0A: 'es-DO',\n    0x300A: 'es-EC',\n    0x440A: 'es-SV',\n    0x100A: 'es-GT',\n    0x480A: 'es-HN',\n    0x080A: 'es-MX',\n    0x4C0A: 'es-NI',\n    0x180A: 'es-PA',\n    0x3C0A: 'es-PY',\n    0x280A: 'es-PE',\n    0x500A: 'es-PR',\n\n    // Microsoft has defined two different language codes for\n    // Spanish with modern sorting and Spanish with traditional\n    // sorting. This makes sense for collation APIs, and it would be\n    // possible to express this in BCP 47 language tags via Unicode\n    // extensions (eg., es-u-co-trad is Spanish with traditional\n    // sorting). However, for storing names in fonts, the distinction\n    // does not make sense, so we give es in both cases.\n    0x0C0A: 'es',\n    0x040A: 'es',\n\n    0x540A: 'es-US',\n    0x380A: 'es-UY',\n    0x200A: 'es-VE',\n    0x081D: 'sv-FI',\n    0x041D: 'sv',\n    0x045A: 'syr',\n    0x0428: 'tg',\n    0x085F: 'tzm',\n    0x0449: 'ta',\n    0x0444: 'tt',\n    0x044A: 'te',\n    0x041E: 'th',\n    0x0451: 'bo',\n    0x041F: 'tr',\n    0x0442: 'tk',\n    0x0480: 'ug',\n    0x0422: 'uk',\n    0x042E: 'hsb',\n    0x0420: 'ur',\n    0x0843: 'uz-Cyrl',\n    0x0443: 'uz',\n    0x042A: 'vi',\n    0x0452: 'cy',\n    0x0488: 'wo',\n    0x0485: 'sah',\n    0x0478: 'ii',\n    0x046A: 'yo'\n};\n\n// Returns a IETF BCP 47 language code, for example 'zh-Hant'\n// for 'Chinese in the traditional script'.\nfunction getLanguageCode(platformID, languageID, ltag) {\n    switch (platformID) {\n        case 0:  // Unicode\n            if (languageID === 0xFFFF) {\n                return 'und';\n            } else if (ltag) {\n                return ltag[languageID];\n            }\n\n            break;\n\n        case 1:  // Macintosh\n            return macLanguages[languageID];\n\n        case 3:  // Windows\n            return windowsLanguages[languageID];\n    }\n\n    return undefined;\n}\n\nvar utf16 = 'utf-16';\n\n// MacOS script ID  encoding. This table stores the default case,\n// which can be overridden by macLanguageEncodings.\nvar macScriptEncodings = {\n    0: 'macintosh',           // smRoman\n    1: 'x-mac-japanese',      // smJapanese\n    2: 'x-mac-chinesetrad',   // smTradChinese\n    3: 'x-mac-korean',        // smKorean\n    6: 'x-mac-greek',         // smGreek\n    7: 'x-mac-cyrillic',      // smCyrillic\n    9: 'x-mac-devanagai',     // smDevanagari\n    10: 'x-mac-gurmukhi',     // smGurmukhi\n    11: 'x-mac-gujarati',     // smGujarati\n    12: 'x-mac-oriya',        // smOriya\n    13: 'x-mac-bengali',      // smBengali\n    14: 'x-mac-tamil',        // smTamil\n    15: 'x-mac-telugu',       // smTelugu\n    16: 'x-mac-kannada',      // smKannada\n    17: 'x-mac-malayalam',    // smMalayalam\n    18: 'x-mac-sinhalese',    // smSinhalese\n    19: 'x-mac-burmese',      // smBurmese\n    20: 'x-mac-khmer',        // smKhmer\n    21: 'x-mac-thai',         // smThai\n    22: 'x-mac-lao',          // smLao\n    23: 'x-mac-georgian',     // smGeorgian\n    24: 'x-mac-armenian',     // smArmenian\n    25: 'x-mac-chinesesimp',  // smSimpChinese\n    26: 'x-mac-tibetan',      // smTibetan\n    27: 'x-mac-mongolian',    // smMongolian\n    28: 'x-mac-ethiopic',     // smEthiopic\n    29: 'x-mac-ce',           // smCentralEuroRoman\n    30: 'x-mac-vietnamese',   // smVietnamese\n    31: 'x-mac-extarabic'     // smExtArabic\n};\n\n// MacOS language ID  encoding. This table stores the exceptional\n// cases, which override macScriptEncodings. For writing MacOS naming\n// tables, we need to emit a MacOS script ID. Therefore, we cannot\n// merge macScriptEncodings into macLanguageEncodings.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nvar macLanguageEncodings = {\n    15: 'x-mac-icelandic',    // langIcelandic\n    17: 'x-mac-turkish',      // langTurkish\n    18: 'x-mac-croatian',     // langCroatian\n    24: 'x-mac-ce',           // langLithuanian\n    25: 'x-mac-ce',           // langPolish\n    26: 'x-mac-ce',           // langHungarian\n    27: 'x-mac-ce',           // langEstonian\n    28: 'x-mac-ce',           // langLatvian\n    30: 'x-mac-icelandic',    // langFaroese\n    37: 'x-mac-romanian',     // langRomanian\n    38: 'x-mac-ce',           // langCzech\n    39: 'x-mac-ce',           // langSlovak\n    40: 'x-mac-ce',           // langSlovenian\n    143: 'x-mac-inuit',       // langInuktitut\n    146: 'x-mac-gaelic'       // langIrishGaelicScript\n};\n\nfunction getEncoding(platformID, encodingID, languageID) {\n    switch (platformID) {\n        case 0:  // Unicode\n            return utf16;\n\n        case 1:  // Apple Macintosh\n            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];\n\n        case 3:  // Microsoft Windows\n            if (encodingID === 1 || encodingID === 10) {\n                return utf16;\n            }\n\n            break;\n    }\n\n    return undefined;\n}\n\n// Parse the naming `name` table.\n// FIXME: Format 1 additional fields are not supported yet.\n// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].\nfunction parseNameTable(data, start, ltag) {\n    var name = {};\n    var p = new parse.Parser(data, start);\n    var format = p.parseUShort();\n    var count = p.parseUShort();\n    var stringOffset = p.offset + p.parseUShort();\n    for (var i = 0; i < count; i++) {\n        var platformID = p.parseUShort();\n        var encodingID = p.parseUShort();\n        var languageID = p.parseUShort();\n        var nameID = p.parseUShort();\n        var property = nameTableNames[nameID] || nameID;\n        var byteLength = p.parseUShort();\n        var offset = p.parseUShort();\n        var language = getLanguageCode(platformID, languageID, ltag);\n        var encoding = getEncoding(platformID, encodingID, languageID);\n        if (encoding !== undefined && language !== undefined) {\n            var text = (void 0);\n            if (encoding === utf16) {\n                text = decode.UTF16(data, stringOffset + offset, byteLength);\n            } else {\n                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);\n            }\n\n            if (text) {\n                var translations = name[property];\n                if (translations === undefined) {\n                    translations = name[property] = {};\n                }\n\n                translations[language] = text;\n            }\n        }\n    }\n\n    var langTagCount = 0;\n    if (format === 1) {\n        // FIXME: Also handle Microsoft's 'name' table 1.\n        langTagCount = p.parseUShort();\n    }\n\n    return name;\n}\n\n// {23: 'foo'}  {'foo': 23}\n// ['bar', 'baz']  {'bar': 0, 'baz': 1}\nfunction reverseDict(dict) {\n    var result = {};\n    for (var key in dict) {\n        result[dict[key]] = parseInt(key);\n    }\n\n    return result;\n}\n\nfunction makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n    return new table.Record('NameRecord', [\n        {name: 'platformID', type: 'USHORT', value: platformID},\n        {name: 'encodingID', type: 'USHORT', value: encodingID},\n        {name: 'languageID', type: 'USHORT', value: languageID},\n        {name: 'nameID', type: 'USHORT', value: nameID},\n        {name: 'length', type: 'USHORT', value: length},\n        {name: 'offset', type: 'USHORT', value: offset}\n    ]);\n}\n\n// Finds the position of needle in haystack, or -1 if not there.\n// Like String.indexOf(), but for arrays.\nfunction findSubArray(needle, haystack) {\n    var needleLength = needle.length;\n    var limit = haystack.length - needleLength + 1;\n\n    loop:\n    for (var pos = 0; pos < limit; pos++) {\n        for (; pos < limit; pos++) {\n            for (var k = 0; k < needleLength; k++) {\n                if (haystack[pos + k] !== needle[k]) {\n                    continue loop;\n                }\n            }\n\n            return pos;\n        }\n    }\n\n    return -1;\n}\n\nfunction addStringToPool(s, pool) {\n    var offset = findSubArray(s, pool);\n    if (offset < 0) {\n        offset = pool.length;\n        var i = 0;\n        var len = s.length;\n        for (; i < len; ++i) {\n            pool.push(s[i]);\n        }\n\n    }\n\n    return offset;\n}\n\nfunction makeNameTable(names, ltag) {\n    var nameID;\n    var nameIDs = [];\n\n    var namesWithNumericKeys = {};\n    var nameTableIds = reverseDict(nameTableNames);\n    for (var key in names) {\n        var id = nameTableIds[key];\n        if (id === undefined) {\n            id = key;\n        }\n\n        nameID = parseInt(id);\n\n        if (isNaN(nameID)) {\n            throw new Error('Name table entry \"' + key + '\" does not exist, see nameTableNames for complete list.');\n        }\n\n        namesWithNumericKeys[nameID] = names[key];\n        nameIDs.push(nameID);\n    }\n\n    var macLanguageIds = reverseDict(macLanguages);\n    var windowsLanguageIds = reverseDict(windowsLanguages);\n\n    var nameRecords = [];\n    var stringPool = [];\n\n    for (var i = 0; i < nameIDs.length; i++) {\n        nameID = nameIDs[i];\n        var translations = namesWithNumericKeys[nameID];\n        for (var lang in translations) {\n            var text = translations[lang];\n\n            // For MacOS, we try to emit the name in the form that was introduced\n            // in the initial version of the TrueType spec (in the late 1980s).\n            // However, this can fail for various reasons: the requested BCP 47\n            // language code might not have an old-style Mac equivalent;\n            // we might not have a codec for the needed character encoding;\n            // or the name might contain characters that cannot be expressed\n            // in the old-style Macintosh encoding. In case of failure, we emit\n            // the name in a more modern fashion (Unicode encoding with BCP 47\n            // language tags) that is recognized by MacOS 10.5, released in 2009.\n            // If fonts were only read by operating systems, we could simply\n            // emit all names in the modern form; this would be much easier.\n            // However, there are many applications and libraries that read\n            // 'name' tables directly, and these will usually only recognize\n            // the ancient form (silently skipping the unrecognized names).\n            var macPlatform = 1;  // Macintosh\n            var macLanguage = macLanguageIds[lang];\n            var macScript = macLanguageToScript[macLanguage];\n            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);\n            var macName = encode.MACSTRING(text, macEncoding);\n            if (macName === undefined) {\n                macPlatform = 0;  // Unicode\n                macLanguage = ltag.indexOf(lang);\n                if (macLanguage < 0) {\n                    macLanguage = ltag.length;\n                    ltag.push(lang);\n                }\n\n                macScript = 4;  // Unicode 2.0 and later\n                macName = encode.UTF16(text);\n            }\n\n            var macNameOffset = addStringToPool(macName, stringPool);\n            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,\n                                            nameID, macName.length, macNameOffset));\n\n            var winLanguage = windowsLanguageIds[lang];\n            if (winLanguage !== undefined) {\n                var winName = encode.UTF16(text);\n                var winNameOffset = addStringToPool(winName, stringPool);\n                nameRecords.push(makeNameRecord(3, 1, winLanguage,\n                                                nameID, winName.length, winNameOffset));\n            }\n        }\n    }\n\n    nameRecords.sort(function(a, b) {\n        return ((a.platformID - b.platformID) ||\n                (a.encodingID - b.encodingID) ||\n                (a.languageID - b.languageID) ||\n                (a.nameID - b.nameID));\n    });\n\n    var t = new table.Table('name', [\n        {name: 'format', type: 'USHORT', value: 0},\n        {name: 'count', type: 'USHORT', value: nameRecords.length},\n        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}\n    ]);\n\n    for (var r = 0; r < nameRecords.length; r++) {\n        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});\n    }\n\n    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});\n    return t;\n}\n\nvar _name = { parse: parseNameTable, make: makeNameTable };\n\n// The `OS/2` table contains metrics required in OpenType fonts.\n\nvar unicodeRanges = [\n    {begin: 0x0000, end: 0x007F}, // Basic Latin\n    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement\n    {begin: 0x0100, end: 0x017F}, // Latin Extended-A\n    {begin: 0x0180, end: 0x024F}, // Latin Extended-B\n    {begin: 0x0250, end: 0x02AF}, // IPA Extensions\n    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters\n    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks\n    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic\n    {begin: 0x2C80, end: 0x2CFF}, // Coptic\n    {begin: 0x0400, end: 0x04FF}, // Cyrillic\n    {begin: 0x0530, end: 0x058F}, // Armenian\n    {begin: 0x0590, end: 0x05FF}, // Hebrew\n    {begin: 0xA500, end: 0xA63F}, // Vai\n    {begin: 0x0600, end: 0x06FF}, // Arabic\n    {begin: 0x07C0, end: 0x07FF}, // NKo\n    {begin: 0x0900, end: 0x097F}, // Devanagari\n    {begin: 0x0980, end: 0x09FF}, // Bengali\n    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi\n    {begin: 0x0A80, end: 0x0AFF}, // Gujarati\n    {begin: 0x0B00, end: 0x0B7F}, // Oriya\n    {begin: 0x0B80, end: 0x0BFF}, // Tamil\n    {begin: 0x0C00, end: 0x0C7F}, // Telugu\n    {begin: 0x0C80, end: 0x0CFF}, // Kannada\n    {begin: 0x0D00, end: 0x0D7F}, // Malayalam\n    {begin: 0x0E00, end: 0x0E7F}, // Thai\n    {begin: 0x0E80, end: 0x0EFF}, // Lao\n    {begin: 0x10A0, end: 0x10FF}, // Georgian\n    {begin: 0x1B00, end: 0x1B7F}, // Balinese\n    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo\n    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional\n    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended\n    {begin: 0x2000, end: 0x206F}, // General Punctuation\n    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts\n    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol\n    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols\n    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols\n    {begin: 0x2150, end: 0x218F}, // Number Forms\n    {begin: 0x2190, end: 0x21FF}, // Arrows\n    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators\n    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical\n    {begin: 0x2400, end: 0x243F}, // Control Pictures\n    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition\n    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics\n    {begin: 0x2500, end: 0x257F}, // Box Drawing\n    {begin: 0x2580, end: 0x259F}, // Block Elements\n    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes\n    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols\n    {begin: 0x2700, end: 0x27BF}, // Dingbats\n    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation\n    {begin: 0x3040, end: 0x309F}, // Hiragana\n    {begin: 0x30A0, end: 0x30FF}, // Katakana\n    {begin: 0x3100, end: 0x312F}, // Bopomofo\n    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo\n    {begin: 0xA840, end: 0xA87F}, // Phags-pa\n    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months\n    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility\n    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables\n    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *\n    {begin: 0x10900, end: 0x1091F}, // Phoenicia\n    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs\n    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)\n    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes\n    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms\n    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A\n    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks\n    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms\n    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants\n    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B\n    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms\n    {begin: 0xFFF0, end: 0xFFFF}, // Specials\n    {begin: 0x0F00, end: 0x0FFF}, // Tibetan\n    {begin: 0x0700, end: 0x074F}, // Syriac\n    {begin: 0x0780, end: 0x07BF}, // Thaana\n    {begin: 0x0D80, end: 0x0DFF}, // Sinhala\n    {begin: 0x1000, end: 0x109F}, // Myanmar\n    {begin: 0x1200, end: 0x137F}, // Ethiopic\n    {begin: 0x13A0, end: 0x13FF}, // Cherokee\n    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics\n    {begin: 0x1680, end: 0x169F}, // Ogham\n    {begin: 0x16A0, end: 0x16FF}, // Runic\n    {begin: 0x1780, end: 0x17FF}, // Khmer\n    {begin: 0x1800, end: 0x18AF}, // Mongolian\n    {begin: 0x2800, end: 0x28FF}, // Braille Patterns\n    {begin: 0xA000, end: 0xA48F}, // Yi Syllables\n    {begin: 0x1700, end: 0x171F}, // Tagalog\n    {begin: 0x10300, end: 0x1032F}, // Old Italic\n    {begin: 0x10330, end: 0x1034F}, // Gothic\n    {begin: 0x10400, end: 0x1044F}, // Deseret\n    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols\n    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols\n    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)\n    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors\n    {begin: 0xE0000, end: 0xE007F}, // Tags\n    {begin: 0x1900, end: 0x194F}, // Limbu\n    {begin: 0x1950, end: 0x197F}, // Tai Le\n    {begin: 0x1980, end: 0x19DF}, // New Tai Lue\n    {begin: 0x1A00, end: 0x1A1F}, // Buginese\n    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic\n    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh\n    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols\n    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri\n    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary\n    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers\n    {begin: 0x10380, end: 0x1039F}, // Ugaritic\n    {begin: 0x103A0, end: 0x103DF}, // Old Persian\n    {begin: 0x10450, end: 0x1047F}, // Shavian\n    {begin: 0x10480, end: 0x104AF}, // Osmanya\n    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary\n    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi\n    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols\n    {begin: 0x12000, end: 0x123FF}, // Cuneiform\n    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals\n    {begin: 0x1B80, end: 0x1BBF}, // Sundanese\n    {begin: 0x1C00, end: 0x1C4F}, // Lepcha\n    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki\n    {begin: 0xA880, end: 0xA8DF}, // Saurashtra\n    {begin: 0xA900, end: 0xA92F}, // Kayah Li\n    {begin: 0xA930, end: 0xA95F}, // Rejang\n    {begin: 0xAA00, end: 0xAA5F}, // Cham\n    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols\n    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc\n    {begin: 0x102A0, end: 0x102DF}, // Carian\n    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles\n];\n\nfunction getUnicodeRange(unicode) {\n    for (var i = 0; i < unicodeRanges.length; i += 1) {\n        var range = unicodeRanges[i];\n        if (unicode >= range.begin && unicode < range.end) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n// Parse the OS/2 and Windows metrics `OS/2` table\nfunction parseOS2Table(data, start) {\n    var os2 = {};\n    var p = new parse.Parser(data, start);\n    os2.version = p.parseUShort();\n    os2.xAvgCharWidth = p.parseShort();\n    os2.usWeightClass = p.parseUShort();\n    os2.usWidthClass = p.parseUShort();\n    os2.fsType = p.parseUShort();\n    os2.ySubscriptXSize = p.parseShort();\n    os2.ySubscriptYSize = p.parseShort();\n    os2.ySubscriptXOffset = p.parseShort();\n    os2.ySubscriptYOffset = p.parseShort();\n    os2.ySuperscriptXSize = p.parseShort();\n    os2.ySuperscriptYSize = p.parseShort();\n    os2.ySuperscriptXOffset = p.parseShort();\n    os2.ySuperscriptYOffset = p.parseShort();\n    os2.yStrikeoutSize = p.parseShort();\n    os2.yStrikeoutPosition = p.parseShort();\n    os2.sFamilyClass = p.parseShort();\n    os2.panose = [];\n    for (var i = 0; i < 10; i++) {\n        os2.panose[i] = p.parseByte();\n    }\n\n    os2.ulUnicodeRange1 = p.parseULong();\n    os2.ulUnicodeRange2 = p.parseULong();\n    os2.ulUnicodeRange3 = p.parseULong();\n    os2.ulUnicodeRange4 = p.parseULong();\n    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n    os2.fsSelection = p.parseUShort();\n    os2.usFirstCharIndex = p.parseUShort();\n    os2.usLastCharIndex = p.parseUShort();\n    os2.sTypoAscender = p.parseShort();\n    os2.sTypoDescender = p.parseShort();\n    os2.sTypoLineGap = p.parseShort();\n    os2.usWinAscent = p.parseUShort();\n    os2.usWinDescent = p.parseUShort();\n    if (os2.version >= 1) {\n        os2.ulCodePageRange1 = p.parseULong();\n        os2.ulCodePageRange2 = p.parseULong();\n    }\n\n    if (os2.version >= 2) {\n        os2.sxHeight = p.parseShort();\n        os2.sCapHeight = p.parseShort();\n        os2.usDefaultChar = p.parseUShort();\n        os2.usBreakChar = p.parseUShort();\n        os2.usMaxContent = p.parseUShort();\n    }\n\n    return os2;\n}\n\nfunction makeOS2Table(options) {\n    return new table.Table('OS/2', [\n        {name: 'version', type: 'USHORT', value: 0x0003},\n        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},\n        {name: 'usWeightClass', type: 'USHORT', value: 0},\n        {name: 'usWidthClass', type: 'USHORT', value: 0},\n        {name: 'fsType', type: 'USHORT', value: 0},\n        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},\n        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},\n        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},\n        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},\n        {name: 'sFamilyClass', type: 'SHORT', value: 0},\n        {name: 'bFamilyType', type: 'BYTE', value: 0},\n        {name: 'bSerifStyle', type: 'BYTE', value: 0},\n        {name: 'bWeight', type: 'BYTE', value: 0},\n        {name: 'bProportion', type: 'BYTE', value: 0},\n        {name: 'bContrast', type: 'BYTE', value: 0},\n        {name: 'bStrokeVariation', type: 'BYTE', value: 0},\n        {name: 'bArmStyle', type: 'BYTE', value: 0},\n        {name: 'bLetterform', type: 'BYTE', value: 0},\n        {name: 'bMidline', type: 'BYTE', value: 0},\n        {name: 'bXHeight', type: 'BYTE', value: 0},\n        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},\n        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},\n        {name: 'fsSelection', type: 'USHORT', value: 0},\n        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},\n        {name: 'usLastCharIndex', type: 'USHORT', value: 0},\n        {name: 'sTypoAscender', type: 'SHORT', value: 0},\n        {name: 'sTypoDescender', type: 'SHORT', value: 0},\n        {name: 'sTypoLineGap', type: 'SHORT', value: 0},\n        {name: 'usWinAscent', type: 'USHORT', value: 0},\n        {name: 'usWinDescent', type: 'USHORT', value: 0},\n        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},\n        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},\n        {name: 'sxHeight', type: 'SHORT', value: 0},\n        {name: 'sCapHeight', type: 'SHORT', value: 0},\n        {name: 'usDefaultChar', type: 'USHORT', value: 0},\n        {name: 'usBreakChar', type: 'USHORT', value: 0},\n        {name: 'usMaxContext', type: 'USHORT', value: 0}\n    ], options);\n}\n\nvar os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };\n\n// The `post` table stores additional PostScript information, such as glyph names.\n\n// Parse the PostScript `post` table\nfunction parsePostTable(data, start) {\n    var post = {};\n    var p = new parse.Parser(data, start);\n    post.version = p.parseVersion();\n    post.italicAngle = p.parseFixed();\n    post.underlinePosition = p.parseShort();\n    post.underlineThickness = p.parseShort();\n    post.isFixedPitch = p.parseULong();\n    post.minMemType42 = p.parseULong();\n    post.maxMemType42 = p.parseULong();\n    post.minMemType1 = p.parseULong();\n    post.maxMemType1 = p.parseULong();\n    switch (post.version) {\n        case 1:\n            post.names = standardNames.slice();\n            break;\n        case 2:\n            post.numberOfGlyphs = p.parseUShort();\n            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                post.glyphNameIndex[i] = p.parseUShort();\n            }\n\n            post.names = [];\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                if (post.glyphNameIndex[i$1] >= standardNames.length) {\n                    var nameLength = p.parseChar();\n                    post.names.push(p.parseString(nameLength));\n                }\n            }\n\n            break;\n        case 2.5:\n            post.numberOfGlyphs = p.parseUShort();\n            post.offset = new Array(post.numberOfGlyphs);\n            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {\n                post.offset[i$2] = p.parseChar();\n            }\n\n            break;\n    }\n    return post;\n}\n\nfunction makePostTable() {\n    return new table.Table('post', [\n        {name: 'version', type: 'FIXED', value: 0x00030000},\n        {name: 'italicAngle', type: 'FIXED', value: 0},\n        {name: 'underlinePosition', type: 'FWORD', value: 0},\n        {name: 'underlineThickness', type: 'FWORD', value: 0},\n        {name: 'isFixedPitch', type: 'ULONG', value: 0},\n        {name: 'minMemType42', type: 'ULONG', value: 0},\n        {name: 'maxMemType42', type: 'ULONG', value: 0},\n        {name: 'minMemType1', type: 'ULONG', value: 0},\n        {name: 'maxMemType1', type: 'ULONG', value: 0}\n    ]);\n}\n\nvar post = { parse: parsePostTable, make: makePostTable };\n\n// The `GSUB` table contains ligatures, among other things.\n\nvar subtableParsers = new Array(9);         // subtableParsers[0] is unused\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\nsubtableParsers[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            deltaGlyphId: this.parseUShort()\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            substitute: this.parseOffset16List()\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\nsubtableParsers[2] = function parseLookup2() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        sequences: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\nsubtableParsers[3] = function parseLookup3() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        alternateSets: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\nsubtableParsers[4] = function parseLookup4() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        ligatureSets: this.parseListOfLists(function() {\n            return {\n                ligGlyph: this.parseUShort(),\n                components: this.parseUShortList(this.parseUShort() - 1)\n            };\n        })\n    };\n};\n\nvar lookupRecordDesc = {\n    sequenceIndex: Parser.uShort,\n    lookupListIndex: Parser.uShort\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\nsubtableParsers[5] = function parseLookup5() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n\n    if (substFormat === 1) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            ruleSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    input: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            classDef: this.parsePointer(Parser.classDef),\n            classSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    classes: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        var glyphCount = this.parseUShort();\n        var substCount = this.parseUShort();\n        return {\n            substFormat: substFormat,\n            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\nsubtableParsers[6] = function parseLookup6() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            chainRuleSets: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            backtrackClassDef: this.parsePointer(Parser.classDef),\n            inputClassDef: this.parsePointer(Parser.classDef),\n            lookaheadClassDef: this.parsePointer(Parser.classDef),\n            chainClassSet: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        return {\n            substFormat: 3,\n            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\nsubtableParsers[7] = function parseLookup7() {\n    // Extension Substitution subtable\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');\n    var extensionLookupType = this.parseUShort();\n    var extensionParser = new Parser(this.data, this.offset + this.parseULong());\n    return {\n        substFormat: 1,\n        lookupType: extensionLookupType,\n        extension: subtableParsers[extensionLookupType].call(extensionParser)\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\nsubtableParsers[8] = function parseLookup8() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        substitutes: this.parseUShortList()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/gsub.htm\nfunction parseGsubTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n\n}\n\n// GSUB Writing //////////////////////////////////////////////\nvar subtableMakers = new Array(9);\n\nsubtableMakers[1] = function makeLookup1(subtable) {\n    if (subtable.substFormat === 1) {\n        return new table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 1},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},\n            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}\n        ]);\n    } else {\n        return new table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 2},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n        ].concat(table.ushortList('substitute', subtable.substitute)));\n    }\n};\n\nsubtableMakers[2] = function makeLookup2(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('seqSet', subtable.sequences, function(sequenceSet) {\n        return new table.Table('sequenceSetTable', table.ushortList('sequence', sequenceSet));\n    })));\n};\n\nsubtableMakers[3] = function makeLookup3(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {\n        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));\n    })));\n};\n\nsubtableMakers[4] = function makeLookup4(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {\n        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {\n            return new table.Table('ligatureTable',\n                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]\n                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))\n            );\n        }));\n    })));\n};\n\nsubtableMakers[6] = function makeLookup6(subtable) {\n    if (subtable.substFormat === 1) {\n        var returnTable = new table.Table('chainContextTable', [\n            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n        ].concat(table.tableList('chainRuleSet', subtable.chainRuleSets, function(chainRuleSet) {\n            return new table.Table('chainRuleSetTable', table.tableList('chainRule', chainRuleSet, function(chainRule) {\n                var tableData = table.ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)\n                    .concat(table.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))\n                    .concat(table.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))\n                    .concat(table.ushortList('substitution', [], chainRule.lookupRecords.length));\n\n                chainRule.lookupRecords.forEach(function (record, i) {\n                    tableData = tableData\n                        .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n                        .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n                });\n                return new table.Table('chainRuleTable', tableData);\n            }));\n        })));\n        return returnTable;\n    } else if (subtable.substFormat === 2) {\n        check.assert(false, 'lookup type 6 format 2 is not yet supported.');\n    } else if (subtable.substFormat === 3) {\n        var tableData = [\n            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat} ];\n\n        tableData.push({name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length});\n        subtable.backtrackCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'backtrackCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n        tableData.push({name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length});\n        subtable.inputCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'inputCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n        tableData.push({name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length});\n        subtable.lookaheadCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n\n        tableData.push({name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length});\n        subtable.lookupRecords.forEach(function (record, i) {\n            tableData = tableData\n                .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n                .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n        });\n\n        var returnTable$1 = new table.Table('chainContextTable', tableData);\n\n        return returnTable$1;\n    }\n\n    check.assert(false, 'lookup type 6 format must be 1, 2 or 3.');\n};\n\nfunction makeGsubTable(gsub) {\n    return new table.Table('GSUB', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},\n        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},\n        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}\n    ]);\n}\n\nvar gsub = { parse: parseGsubTable, make: makeGsubTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\n// Parse the metadata `meta` table.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\nfunction parseMetaTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported META table version.');\n    p.parseULong(); // flags - currently unused and set to 0\n    p.parseULong(); // tableOffset\n    var numDataMaps = p.parseULong();\n\n    var tags = {};\n    for (var i = 0; i < numDataMaps; i++) {\n        var tag = p.parseTag();\n        var dataOffset = p.parseULong();\n        var dataLength = p.parseULong();\n        var text = decode.UTF8(data, start + dataOffset, dataLength);\n\n        tags[tag] = text;\n    }\n    return tags;\n}\n\nfunction makeMetaTable(tags) {\n    var numTags = Object.keys(tags).length;\n    var stringPool = '';\n    var stringPoolOffset = 16 + numTags * 12;\n\n    var result = new table.Table('meta', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'offset', type: 'ULONG', value: stringPoolOffset},\n        {name: 'numTags', type: 'ULONG', value: numTags}\n    ]);\n\n    for (var tag in tags) {\n        var pos = stringPool.length;\n        stringPool += tags[tag];\n\n        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});\n        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n\n    return result;\n}\n\nvar meta = { parse: parseMetaTable, make: makeMetaTable };\n\n// The `sfnt` wrapper provides organization for the tables in the font.\n\nfunction log2(v) {\n    return Math.log(v) / Math.log(2) | 0;\n}\n\nfunction computeCheckSum(bytes) {\n    while (bytes.length % 4 !== 0) {\n        bytes.push(0);\n    }\n\n    var sum = 0;\n    for (var i = 0; i < bytes.length; i += 4) {\n        sum += (bytes[i] << 24) +\n            (bytes[i + 1] << 16) +\n            (bytes[i + 2] << 8) +\n            (bytes[i + 3]);\n    }\n\n    sum %= Math.pow(2, 32);\n    return sum;\n}\n\nfunction makeTableRecord(tag, checkSum, offset, length) {\n    return new table.Record('Table Record', [\n        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},\n        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},\n        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},\n        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}\n    ]);\n}\n\nfunction makeSfntTable(tables) {\n    var sfnt = new table.Table('sfnt', [\n        {name: 'version', type: 'TAG', value: 'OTTO'},\n        {name: 'numTables', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n    sfnt.tables = tables;\n    sfnt.numTables = tables.length;\n    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n    sfnt.searchRange = 16 * highestPowerOf2;\n    sfnt.entrySelector = log2(highestPowerOf2);\n    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n\n    var recordFields = [];\n    var tableFields = [];\n\n    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);\n    while (offset % 4 !== 0) {\n        offset += 1;\n        tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n    }\n\n    for (var i = 0; i < tables.length; i += 1) {\n        var t = tables[i];\n        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n        var tableLength = t.sizeOf();\n        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});\n        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});\n        offset += tableLength;\n        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n        while (offset % 4 !== 0) {\n            offset += 1;\n            tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n        }\n    }\n\n    // Table records need to be sorted alphabetically.\n    recordFields.sort(function(r1, r2) {\n        if (r1.value.tag > r2.value.tag) {\n            return 1;\n        } else {\n            return -1;\n        }\n    });\n\n    sfnt.fields = sfnt.fields.concat(recordFields);\n    sfnt.fields = sfnt.fields.concat(tableFields);\n    return sfnt;\n}\n\n// Get the metrics for a character. If the string has more than one character\n// this function returns metrics for the first available character.\n// You can provide optional fallback metrics if no characters are available.\nfunction metricsForChar(font, chars, notFoundMetrics) {\n    for (var i = 0; i < chars.length; i += 1) {\n        var glyphIndex = font.charToGlyphIndex(chars[i]);\n        if (glyphIndex > 0) {\n            var glyph = font.glyphs.get(glyphIndex);\n            return glyph.getMetrics();\n        }\n    }\n\n    return notFoundMetrics;\n}\n\nfunction average(vs) {\n    var sum = 0;\n    for (var i = 0; i < vs.length; i += 1) {\n        sum += vs[i];\n    }\n\n    return sum / vs.length;\n}\n\n// Convert the font object to a SFNT data structure.\n// This structure contains all the necessary tables and metadata to create a binary OTF file.\nfunction fontToSfntTable(font) {\n    var xMins = [];\n    var yMins = [];\n    var xMaxs = [];\n    var yMaxs = [];\n    var advanceWidths = [];\n    var leftSideBearings = [];\n    var rightSideBearings = [];\n    var firstCharIndex;\n    var lastCharIndex = 0;\n    var ulUnicodeRange1 = 0;\n    var ulUnicodeRange2 = 0;\n    var ulUnicodeRange3 = 0;\n    var ulUnicodeRange4 = 0;\n\n    for (var i = 0; i < font.glyphs.length; i += 1) {\n        var glyph = font.glyphs.get(i);\n        var unicode = glyph.unicode | 0;\n\n        if (isNaN(glyph.advanceWidth)) {\n            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');\n        }\n\n        if (firstCharIndex > unicode || firstCharIndex === undefined) {\n            // ignore .notdef char\n            if (unicode > 0) {\n                firstCharIndex = unicode;\n            }\n        }\n\n        if (lastCharIndex < unicode) {\n            lastCharIndex = unicode;\n        }\n\n        var position = os2.getUnicodeRange(unicode);\n        if (position < 32) {\n            ulUnicodeRange1 |= 1 << position;\n        } else if (position < 64) {\n            ulUnicodeRange2 |= 1 << position - 32;\n        } else if (position < 96) {\n            ulUnicodeRange3 |= 1 << position - 64;\n        } else if (position < 123) {\n            ulUnicodeRange4 |= 1 << position - 96;\n        } else {\n            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n        }\n        // Skip non-important characters.\n        if (glyph.name === '.notdef') { continue; }\n        var metrics = glyph.getMetrics();\n        xMins.push(metrics.xMin);\n        yMins.push(metrics.yMin);\n        xMaxs.push(metrics.xMax);\n        yMaxs.push(metrics.yMax);\n        leftSideBearings.push(metrics.leftSideBearing);\n        rightSideBearings.push(metrics.rightSideBearing);\n        advanceWidths.push(glyph.advanceWidth);\n    }\n\n    var globals = {\n        xMin: Math.min.apply(null, xMins),\n        yMin: Math.min.apply(null, yMins),\n        xMax: Math.max.apply(null, xMaxs),\n        yMax: Math.max.apply(null, yMaxs),\n        advanceWidthMax: Math.max.apply(null, advanceWidths),\n        advanceWidthAvg: average(advanceWidths),\n        minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n        minRightSideBearing: Math.min.apply(null, rightSideBearings)\n    };\n    globals.ascender = font.ascender;\n    globals.descender = font.descender;\n\n    var headTable = head.make({\n        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n        unitsPerEm: font.unitsPerEm,\n        xMin: globals.xMin,\n        yMin: globals.yMin,\n        xMax: globals.xMax,\n        yMax: globals.yMax,\n        lowestRecPPEM: 3,\n        createdTimestamp: font.createdTimestamp\n    });\n\n    var hheaTable = hhea.make({\n        ascender: globals.ascender,\n        descender: globals.descender,\n        advanceWidthMax: globals.advanceWidthMax,\n        minLeftSideBearing: globals.minLeftSideBearing,\n        minRightSideBearing: globals.minRightSideBearing,\n        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n        numberOfHMetrics: font.glyphs.length\n    });\n\n    var maxpTable = maxp.make(font.glyphs.length);\n\n    var os2Table = os2.make(Object.assign({\n        xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n        usFirstCharIndex: firstCharIndex,\n        usLastCharIndex: lastCharIndex,\n        ulUnicodeRange1: ulUnicodeRange1,\n        ulUnicodeRange2: ulUnicodeRange2,\n        ulUnicodeRange3: ulUnicodeRange3,\n        ulUnicodeRange4: ulUnicodeRange4,\n        // See http://typophile.com/node/13081 for more info on vertical metrics.\n        // We get metrics for typical characters (such as \"x\" for xHeight).\n        // We provide some fallback characters if characters are unavailable: their\n        // ordering was chosen experimentally.\n        sTypoAscender: globals.ascender,\n        sTypoDescender: globals.descender,\n        sTypoLineGap: 0,\n        usWinAscent: globals.yMax,\n        usWinDescent: Math.abs(globals.yMin),\n        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now\n        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,\n        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.\n        usBreakChar: font.hasChar(' ') ? 32 : 0, // Use space as the break character, if available.\n    }, font.tables.os2));\n\n    var hmtxTable = hmtx.make(font.glyphs);\n    var cmapTable = cmap.make(font.glyphs);\n\n    var englishFamilyName = font.getEnglishName('fontFamily');\n    var englishStyleName = font.getEnglishName('fontSubfamily');\n    var englishFullName = englishFamilyName + ' ' + englishStyleName;\n    var postScriptName = font.getEnglishName('postScriptName');\n    if (!postScriptName) {\n        postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName;\n    }\n\n    var names = {};\n    for (var n in font.names) {\n        names[n] = font.names[n];\n    }\n\n    if (!names.uniqueID) {\n        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};\n    }\n\n    if (!names.postScriptName) {\n        names.postScriptName = {en: postScriptName};\n    }\n\n    if (!names.preferredFamily) {\n        names.preferredFamily = font.names.fontFamily;\n    }\n\n    if (!names.preferredSubfamily) {\n        names.preferredSubfamily = font.names.fontSubfamily;\n    }\n\n    var languageTags = [];\n    var nameTable = _name.make(names, languageTags);\n    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);\n\n    var postTable = post.make();\n    var cffTable = cff.make(font.glyphs, {\n        version: font.getEnglishName('version'),\n        fullName: englishFullName,\n        familyName: englishFamilyName,\n        weightName: englishStyleName,\n        postScriptName: postScriptName,\n        unitsPerEm: font.unitsPerEm,\n        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]\n    });\n\n    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;\n\n    // The order does not matter because makeSfntTable() will sort them.\n    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n    if (ltagTable) {\n        tables.push(ltagTable);\n    }\n    // Optional tables\n    if (font.tables.gsub) {\n        tables.push(gsub.make(font.tables.gsub));\n    }\n    if (metaTable) {\n        tables.push(metaTable);\n    }\n\n    var sfntTable = makeSfntTable(tables);\n\n    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n    var bytes = sfntTable.encode();\n    var checkSum = computeCheckSum(bytes);\n    var tableFields = sfntTable.fields;\n    var checkSumAdjusted = false;\n    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {\n        if (tableFields[i$1].name === 'head table') {\n            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n            checkSumAdjusted = true;\n            break;\n        }\n    }\n\n    if (!checkSumAdjusted) {\n        throw new Error('Could not find head table with checkSum to adjust.');\n    }\n\n    return sfntTable;\n}\n\nvar sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };\n\n// The Layout object is the prototype of Substitution objects, and provides\n\nfunction searchTag(arr, tag) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid].tag;\n        if (val === tag) {\n            return imid;\n        } else if (val < tag) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\nfunction binSearch(arr, value) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid];\n        if (val === value) {\n            return imid;\n        } else if (val < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\n// binary search in a list of ranges (coverage, class definition)\nfunction searchRange(ranges, value) {\n    // jshint bitwise: false\n    var range;\n    var imin = 0;\n    var imax = ranges.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        range = ranges[imid];\n        var start = range.start;\n        if (start === value) {\n            return range;\n        } else if (start < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    if (imin > 0) {\n        range = ranges[imin - 1];\n        if (value > range.end) { return 0; }\n        return range;\n    }\n}\n\n/**\n * @exports opentype.Layout\n * @class\n */\nfunction Layout(font, tableName) {\n    this.font = font;\n    this.tableName = tableName;\n}\n\nLayout.prototype = {\n\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */\n    searchTag: searchTag,\n\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */\n    binSearch: binSearch,\n\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */\n    getTable: function(create) {\n        var layout = this.font.tables[this.tableName];\n        if (!layout && create) {\n            layout = this.font.tables[this.tableName] = this.createDefaultTable();\n        }\n        return layout;\n    },\n\n    /**\n     * Returns all scripts in the substitution table.\n     * @instance\n     * @return {Array}\n     */\n    getScriptNames: function() {\n        var layout = this.getTable();\n        if (!layout) { return []; }\n        return layout.scripts.map(function(script) {\n            return script.tag;\n        });\n    },\n\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */\n    getDefaultScriptName: function() {\n        var layout = this.getTable();\n        if (!layout) { return; }\n        var hasLatn = false;\n        for (var i = 0; i < layout.scripts.length; i++) {\n            var name = layout.scripts[i].tag;\n            if (name === 'DFLT') { return name; }\n            if (name === 'latn') { hasLatn = true; }\n        }\n        if (hasLatn) { return 'latn'; }\n    },\n\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */\n    getScriptTable: function(script, create) {\n        var layout = this.getTable(create);\n        if (layout) {\n            script = script || 'DFLT';\n            var scripts = layout.scripts;\n            var pos = searchTag(layout.scripts, script);\n            if (pos >= 0) {\n                return scripts[pos].script;\n            } else if (create) {\n                var scr = {\n                    tag: script,\n                    script: {\n                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},\n                        langSysRecords: []\n                    }\n                };\n                scripts.splice(-1 - pos, 0, scr);\n                return scr.script;\n            }\n        }\n    },\n\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */\n    getLangSysTable: function(script, language, create) {\n        var scriptTable = this.getScriptTable(script, create);\n        if (scriptTable) {\n            if (!language || language === 'dflt' || language === 'DFLT') {\n                return scriptTable.defaultLangSys;\n            }\n            var pos = searchTag(scriptTable.langSysRecords, language);\n            if (pos >= 0) {\n                return scriptTable.langSysRecords[pos].langSys;\n            } else if (create) {\n                var langSysRecord = {\n                    tag: language,\n                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}\n                };\n                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                return langSysRecord.langSys;\n            }\n        }\n    },\n\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */\n    getFeatureTable: function(script, language, feature, create) {\n        var langSysTable = this.getLangSysTable(script, language, create);\n        if (langSysTable) {\n            var featureRecord;\n            var featIndexes = langSysTable.featureIndexes;\n            var allFeatures = this.font.tables[this.tableName].features;\n            // The FeatureIndex array of indices is in arbitrary order,\n            // even if allFeatures is sorted alphabetically by feature tag.\n            for (var i = 0; i < featIndexes.length; i++) {\n                featureRecord = allFeatures[featIndexes[i]];\n                if (featureRecord.tag === feature) {\n                    return featureRecord.feature;\n                }\n            }\n            if (create) {\n                var index = allFeatures.length;\n                // Automatic ordering of features would require to shift feature indexes in the script list.\n                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n                featureRecord = {\n                    tag: feature,\n                    feature: { params: 0, lookupListIndexes: [] }\n                };\n                allFeatures.push(featureRecord);\n                featIndexes.push(index);\n                return featureRecord.feature;\n            }\n        }\n    },\n\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 9\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */\n    getLookupTables: function(script, language, feature, lookupType, create) {\n        var featureTable = this.getFeatureTable(script, language, feature, create);\n        var tables = [];\n        if (featureTable) {\n            var lookupTable;\n            var lookupListIndexes = featureTable.lookupListIndexes;\n            var allLookups = this.font.tables[this.tableName].lookups;\n            // lookupListIndexes are in no particular order, so use naive search.\n            for (var i = 0; i < lookupListIndexes.length; i++) {\n                lookupTable = allLookups[lookupListIndexes[i]];\n                if (lookupTable.lookupType === lookupType) {\n                    tables.push(lookupTable);\n                }\n            }\n            if (tables.length === 0 && create) {\n                lookupTable = {\n                    lookupType: lookupType,\n                    lookupFlag: 0,\n                    subtables: [],\n                    markFilteringSet: undefined\n                };\n                var index = allLookups.length;\n                allLookups.push(lookupTable);\n                lookupListIndexes.push(index);\n                return [lookupTable];\n            }\n        }\n        return tables;\n    },\n\n    /**\n     * Find a glyph in a class definition table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n     * @param {object} classDefTable - an OpenType Layout class definition table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getGlyphClass: function(classDefTable, glyphIndex) {\n        switch (classDefTable.format) {\n            case 1:\n                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {\n                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];\n                }\n                return 0;\n            case 2:\n                var range = searchRange(classDefTable.ranges, glyphIndex);\n                return range ? range.classId : 0;\n        }\n    },\n\n    /**\n     * Find a glyph in a coverage table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n     * @param {object} coverageTable - an OpenType Layout coverage table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getCoverageIndex: function(coverageTable, glyphIndex) {\n        switch (coverageTable.format) {\n            case 1:\n                var index = binSearch(coverageTable.glyphs, glyphIndex);\n                return index >= 0 ? index : -1;\n            case 2:\n                var range = searchRange(coverageTable.ranges, glyphIndex);\n                return range ? range.index + glyphIndex - range.start : -1;\n        }\n    },\n\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */\n    expandCoverage: function(coverageTable) {\n        if (coverageTable.format === 1) {\n            return coverageTable.glyphs;\n        } else {\n            var glyphs = [];\n            var ranges = coverageTable.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                var start = range.start;\n                var end = range.end;\n                for (var j = start; j <= end; j++) {\n                    glyphs.push(j);\n                }\n            }\n            return glyphs;\n        }\n    }\n\n};\n\n// The Position object provides utility methods to manipulate\n\n/**\n * @exports opentype.Position\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Position(font) {\n    Layout.call(this, font, 'gpos');\n}\n\nPosition.prototype = Layout.prototype;\n\n/**\n * Init some data for faster and easier access later.\n */\nPosition.prototype.init = function() {\n    var script = this.getDefaultScriptName();\n    this.defaultKerningTables = this.getKerningTables(script);\n};\n\n/**\n * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n *\n * @param {integer} leftIndex - left glyph index\n * @param {integer} rightIndex - right glyph index\n * @returns {integer}\n */\nPosition.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n    for (var i = 0; i < kerningLookups.length; i++) {\n        var subtables = kerningLookups[i].subtables;\n        for (var j = 0; j < subtables.length; j++) {\n            var subtable = subtables[j];\n            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);\n            if (covIndex < 0) { continue; }\n            switch (subtable.posFormat) {\n                case 1:\n                    // Search Pair Adjustment Positioning Format 1\n                    var pairSet = subtable.pairSets[covIndex];\n                    for (var k = 0; k < pairSet.length; k++) {\n                        var pair = pairSet[k];\n                        if (pair.secondGlyph === rightIndex) {\n                            return pair.value1 && pair.value1.xAdvance || 0;\n                        }\n                    }\n                    break;      // left glyph found, not right glyph - try next subtable\n                case 2:\n                    // Search Pair Adjustment Positioning Format 2\n                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);\n                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);\n                    var pair$1 = subtable.classRecords[class1][class2];\n                    return pair$1.value1 && pair$1.value1.xAdvance || 0;\n            }\n        }\n    }\n    return 0;\n};\n\n/**\n * List all kerning lookup tables.\n *\n * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n * @param {string} [language='dflt']\n * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n */\nPosition.prototype.getKerningTables = function(script, language) {\n    if (this.font.tables.gpos) {\n        return this.getLookupTables(script, language, 'kern', 2);\n    }\n};\n\n// The Substitution object provides utility methods to manipulate\n\n/**\n * @exports opentype.Substitution\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Substitution(font) {\n    Layout.call(this, font, 'gsub');\n}\n\n// Check if 2 arrays of primitives are equal.\nfunction arraysEqual(ar1, ar2) {\n    var n = ar1.length;\n    if (n !== ar2.length) { return false; }\n    for (var i = 0; i < n; i++) {\n        if (ar1[i] !== ar2[i]) { return false; }\n    }\n    return true;\n}\n\n// Find the first subtable of a lookup table in a particular format.\nfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n    var subtables = lookupTable.subtables;\n    for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i];\n        if (subtable.substFormat === format) {\n            return subtable;\n        }\n    }\n    if (defaultSubtable) {\n        subtables.push(defaultSubtable);\n        return defaultSubtable;\n    }\n    return undefined;\n}\n\nSubstitution.prototype = Layout.prototype;\n\n/**\n * Create a default GSUB table.\n * @return {Object} gsub - The GSUB table.\n */\nSubstitution.prototype.createDefaultTable = function() {\n    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n    return {\n        version: 1,\n        scripts: [{\n            tag: 'DFLT',\n            script: {\n                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n                langSysRecords: []\n            }\n        }],\n        features: [],\n        lookups: []\n    };\n};\n\n/**\n * List all single substitutions (lookup type 1) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getSingle = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 1);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n            if (subtable.substFormat === 1) {\n                var delta = subtable.deltaGlyphId;\n                for (j = 0; j < glyphs.length; j++) {\n                    var glyph = glyphs[j];\n                    substitutions.push({ sub: glyph, by: glyph + delta });\n                }\n            } else {\n                var substitute = subtable.substitute;\n                for (j = 0; j < glyphs.length; j++) {\n                    substitutions.push({ sub: glyphs[j], by: substitute[j] });\n                }\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getMultiple = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 2);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n\n            for (j = 0; j < glyphs.length; j++) {\n                var glyph = glyphs[j];\n                var replacements = subtable.sequences[j];\n                substitutions.push({ sub: glyph, by: replacements });\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all alternates (lookup type 3) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n * @return {Array} alternates - The list of alternates\n */\nSubstitution.prototype.getAlternates = function(feature, script, language) {\n    var alternates = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 3);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var alternateSets = subtable.alternateSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n            }\n        }\n    }\n    return alternates;\n};\n\n/**\n * List all ligatures (lookup type 4) for a given script, language, and feature.\n * The result is an array of ligature objects like { sub: [ids], by: id }\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} ligatures - The list of ligatures.\n */\nSubstitution.prototype.getLigatures = function(feature, script, language) {\n    var ligatures = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 4);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var ligatureSets = subtable.ligatureSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                var startGlyph = glyphs[j];\n                var ligSet = ligatureSets[j];\n                for (var k = 0; k < ligSet.length; k++) {\n                    var lig = ligSet[k];\n                    ligatures.push({\n                        sub: [startGlyph].concat(lig.components),\n                        by: lig.ligGlyph\n                    });\n                }\n            }\n        }\n    }\n    return ligatures;\n};\n\n/**\n * Add or modify a single substitution (lookup type 1)\n * Format 2, more flexible, is always used.\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addSingle = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];\n    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1\n        substFormat: 2,\n        coverage: {format: 1, glyphs: []},\n        substitute: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Single: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.substitute.splice(pos, 0, 0);\n    }\n    subtable.substitute[pos] = substitution.by;\n};\n\n/**\n * Add or modify a multiple substitution (lookup type 2)\n * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addMultiple = function(feature, substitution, script, language) {\n    check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: \"by\" must be an array of two or more ids');\n    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 2 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {format: 1, glyphs: []},\n        sequences: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Multiple: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.sequences.splice(pos, 0, 0);\n    }\n    subtable.sequences[pos] = substitution.by;\n};\n\n/**\n * Add or modify an alternate substitution (lookup type 3)\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: [ids] }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addAlternate = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {format: 1, glyphs: []},\n        alternateSets: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Alternate: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.alternateSets.splice(pos, 0, 0);\n    }\n    subtable.alternateSets[pos] = substitution.by;\n};\n\n/**\n * Add a ligature (lookup type 4)\n * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} ligature - { sub: [ids], by: id }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addLigature = function(feature, ligature, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];\n    var subtable = lookupTable.subtables[0];\n    if (!subtable) {\n        subtable = {                // lookup type 4 subtable, format 1, coverage format 1\n            substFormat: 1,\n            coverage: { format: 1, glyphs: [] },\n            ligatureSets: []\n        };\n        lookupTable.subtables[0] = subtable;\n    }\n    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = ligature.sub[0];\n    var ligComponents = ligature.sub.slice(1);\n    var ligatureTable = {\n        ligGlyph: ligature.by,\n        components: ligComponents\n    };\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos >= 0) {\n        // ligatureSet already exists\n        var ligatureSet = subtable.ligatureSets[pos];\n        for (var i = 0; i < ligatureSet.length; i++) {\n            // If ligature already exists, return.\n            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n                return;\n            }\n        }\n        // ligature does not exist: add it.\n        ligatureSet.push(ligatureTable);\n    } else {\n        // Create a new ligatureSet and add coverage for the first glyph.\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n    }\n};\n\n/**\n * List all feature data for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getFeature = function(feature, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.getSingle(feature, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            return this.getSingle(feature, script, language)\n                    .concat(this.getAlternates(feature, script, language));\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.getLigatures(feature, script, language);\n        case 'ccmp':\n            return this.getMultiple(feature, script, language)\n                .concat(this.getLigatures(feature, script, language));\n        case 'stch':\n            return this.getMultiple(feature, script, language);\n    }\n    return undefined;\n};\n\n/**\n * Add a substitution to a feature for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.add = function(feature, sub, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.addSingle(feature, sub, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            if (typeof sub.by === 'number') {\n                return this.addSingle(feature, sub, script, language);\n            }\n            return this.addAlternate(feature, sub, script, language);\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.addLigature(feature, sub, script, language);\n        case 'ccmp':\n            if (sub.by instanceof Array) {\n                return this.addMultiple(feature, sub, script, language);\n            }\n            return this.addLigature(feature, sub, script, language);\n    }\n    return undefined;\n};\n\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\n\nfunction nodeBufferToArrayBuffer(buffer) {\n    var ab = new ArrayBuffer(buffer.length);\n    var view = new Uint8Array(ab);\n    for (var i = 0; i < buffer.length; ++i) {\n        view[i] = buffer[i];\n    }\n\n    return ab;\n}\n\nfunction arrayBufferToNodeBuffer(ab) {\n    var buffer = new Buffer(ab.byteLength);\n    var view = new Uint8Array(ab);\n    for (var i = 0; i < buffer.length; ++i) {\n        buffer[i] = view[i];\n    }\n\n    return buffer;\n}\n\nfunction checkArgument(expression, message) {\n    if (!expression) {\n        throw message;\n    }\n}\n\n// The `glyf` table describes the glyphs in TrueType outline format.\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    var v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n\n    return v;\n}\n\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n    var p = new parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph._xMin = p.parseShort();\n    glyph._yMin = p.parseShort();\n    glyph._xMax = p.parseShort();\n    glyph._yMax = p.parseShort();\n    var flags;\n    var flag;\n\n    if (glyph.numberOfContours > 0) {\n        // This glyph is not a composite.\n        var endPointIndices = glyph.endPointIndices = [];\n        for (var i = 0; i < glyph.numberOfContours; i += 1) {\n            endPointIndices.push(p.parseUShort());\n        }\n\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n            glyph.instructions.push(p.parseByte());\n        }\n\n        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                var repeatCount = p.parseByte();\n                for (var j = 0; j < repeatCount; j += 1) {\n                    flags.push(flag);\n                    i$2 += 1;\n                }\n            }\n        }\n\n        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n        if (endPointIndices.length > 0) {\n            var points = [];\n            var point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n                    flag = flags[i$3];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n                    points.push(point);\n                }\n\n                var px = 0;\n                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n                    flag = flags[i$4];\n                    point = points[i$4];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n\n                var py = 0;\n                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n                    flag = flags[i$5];\n                    point = points[i$5];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        var moreComponents = true;\n        while (moreComponents) {\n            flags = p.parseUShort();\n            var component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseShort();\n                    component.dy = p.parseShort();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n                }\n\n            } else {\n                // The arguments are bytes\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseChar();\n                    component.dy = p.parseChar();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n                }\n            }\n\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n        if (flags & 0x100) {\n            // We have instructions\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n                glyph.instructions.push(p.parseByte());\n            }\n        }\n    }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    var newPoints = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        var newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n\n    return newPoints;\n}\n\nfunction getContours(points) {\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    var p = new Path();\n    if (!points) {\n        return p;\n    }\n\n    var contours = getContours(points);\n\n    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n        var contour = contours[contourIndex];\n\n        var prev = null;\n        var curr = contour[contour.length - 1];\n        var next = contour[0];\n\n        if (curr.onCurve) {\n            p.moveTo(curr.x, curr.y);\n        } else {\n            if (next.onCurve) {\n                p.moveTo(next.x, next.y);\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n                p.moveTo(start.x, start.y);\n            }\n        }\n\n        for (var i = 0; i < contour.length; ++i) {\n            prev = curr;\n            curr = next;\n            next = contour[(i + 1) % contour.length];\n\n            if (curr.onCurve) {\n                // This is a straight line.\n                p.lineTo(curr.x, curr.y);\n            } else {\n                var prev2 = prev;\n                var next2 = next;\n\n                if (!prev.onCurve) {\n                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n                }\n\n                if (!next.onCurve) {\n                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n                }\n\n                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n            }\n        }\n\n        p.closePath();\n    }\n    return p;\n}\n\nfunction buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for (var j = 0; j < glyph.components.length; j += 1) {\n            var component = glyph.components[j];\n            var componentGlyph = glyphs.get(component.glyphIndex);\n            // Force the ttfGlyphLoader to parse the glyph.\n            componentGlyph.getPath();\n            if (componentGlyph.points) {\n                var transformedPoints = (void 0);\n                if (component.matchedPoints === undefined) {\n                    // component positioned by offset\n                    transformedPoints = transformPoints(componentGlyph.points, component);\n                } else {\n                    // component positioned by matched points\n                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n                        throw Error('Matched points out of range in ' + glyph.name);\n                    }\n                    var firstPt = glyph.points[component.matchedPoints[0]];\n                    var secondPt = componentGlyph.points[component.matchedPoints[1]];\n                    var transform = {\n                        xScale: component.xScale, scale01: component.scale01,\n                        scale10: component.scale10, yScale: component.yScale,\n                        dx: 0, dy: 0\n                    };\n                    secondPt = transformPoints([secondPt], transform)[0];\n                    transform.dx = firstPt.x - secondPt.x;\n                    transform.dy = firstPt.y - secondPt.y;\n                    transformedPoints = transformPoints(componentGlyph.points, transform);\n                }\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n\n    return getPath(glyph.points);\n}\n\nfunction parseGlyfTableAll(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    // The last element of the loca table is invalid.\n    for (var i = 0; i < loca.length - 1; i += 1) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n\n    return glyphs;\n}\n\nfunction parseGlyfTableOnLowMemory(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    font._push = function(i) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    };\n\n    return glyphs;\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font, opt) {\n    if (opt.lowMemory)\n        { return parseGlyfTableOnLowMemory(data, start, loca, font); }\n    else\n        { return parseGlyfTableAll(data, start, loca, font); }\n}\n\nvar glyf = { getPath: getPath, parse: parseGlyfTable};\n\n/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n\nvar instructionTable;\nvar exec;\nvar execGlyph;\nvar execComponent;\n\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\nfunction Hinting(font) {\n    // the font this hinting object is for\n    this.font = font;\n\n    this.getCommands = function (hPoints) {\n        return glyf.getPath(hPoints).commands;\n    };\n\n    // cached states\n    this._fpgmState  =\n    this._prepState  =\n        undefined;\n\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0;\n}\n\n/*\n* Not rounding.\n*/\nfunction roundOff(v) {\n    return v;\n}\n\n/*\n* Rounding to grid.\n*/\nfunction roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v));\n}\n\n/*\n* Rounding to double grid.\n*/\nfunction roundToDoubleGrid(v) {\n    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n\n/*\n* Rounding to half grid.\n*/\nfunction roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n\n/*\n* Rounding to up to grid.\n*/\nfunction roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n\n/*\n* Rounding to down to grid.\n*/\nfunction roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v));\n}\n\n/*\n* Super rounding.\n*/\nvar roundSuper = function (v) {\n    var period = this.srPeriod;\n    var phase = this.srPhase;\n    var threshold = this.srThreshold;\n    var sign = 1;\n\n    if (v < 0) {\n        v = -v;\n        sign = -1;\n    }\n\n    v += threshold - phase;\n\n    v = Math.trunc(v / period) * period;\n\n    v += phase;\n\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (v < 0) { return phase * sign; }\n\n    return v * sign;\n};\n\n/*\n* Unit vector of x-axis.\n*/\nvar xUnitVector = {\n    x: 1,\n\n    y: 0,\n\n    axis: 'x',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.xo - rp1.xo;\n            do2 = p.xo - rp2.xo;\n            dm1 = rp1.x - rp1.xo;\n            dm2 = rp2.x - rp2.xo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.x = p.xo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.x = (org ? rp.xo : rp.x) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n    },\n\n    // Slope of vector line.\n    slope: 0,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.xTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.xTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.xTouched = false;\n    }\n};\n\n/*\n* Unit vector of y-axis.\n*/\nvar yUnitVector = {\n    x: 0,\n\n    y: 1,\n\n    axis: 'y',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.yo - rp1.yo;\n            do2 = p.yo - rp2.yo;\n            dm1 = rp1.y - rp1.yo;\n            dm2 = rp2.y - rp2.yo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.y = p.yo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this.\n    normalSlope: 0,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.y = (org ? rp.yo : rp.y) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n    },\n\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.yTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.yTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.yTouched = false;\n    }\n};\n\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\nfunction UnitVector(x, y) {\n    this.x = x;\n    this.y = y;\n    this.axis = undefined;\n    this.slope = y / x;\n    this.normalSlope = -x / y;\n    Object.freeze(this);\n}\n\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\nUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n    return (\n        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n        this.y * yUnitVector.distance(p1, p2, o1, o2)\n    );\n};\n\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\nUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n    var dm1;\n    var dm2;\n    var do1;\n    var do2;\n    var doa1;\n    var doa2;\n    var dt;\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n        return;\n    }\n\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\nUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n    pv = pv || this;\n\n    var rpx = org ? rp.xo : rp.x;\n    var rpy = org ? rp.yo : rp.y;\n    var rpdx = rpx + d * pv.x;\n    var rpdy = rpy + d * pv.y;\n\n    var pvns = pv.normalSlope;\n    var fvs = this.slope;\n\n    var px = p.x;\n    var py = p.y;\n\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n    p.y = fvs * (p.x - px) + py;\n};\n\n/*\n* Touches the point p.\n*/\nUnitVector.prototype.touch = function(p) {\n    p.xTouched = true;\n    p.yTouched = true;\n};\n\n/*\n* Returns a unit vector with x/y coordinates.\n*/\nfunction getUnitVector(x, y) {\n    var d = Math.sqrt(x * x + y * y);\n\n    x /= d;\n    y /= d;\n\n    if (x === 1 && y === 0) { return xUnitVector; }\n    else if (x === 0 && y === 1) { return yUnitVector; }\n    else { return new UnitVector(x, y); }\n}\n\n/*\n* Creates a point in the hinting engine.\n*/\nfunction HPoint(\n    x,\n    y,\n    lastPointOfContour,\n    onCurve\n) {\n    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n    this.lastPointOfContour = lastPointOfContour;\n    this.onCurve = onCurve;\n    this.prevPointOnContour = undefined;\n    this.nextPointOnContour = undefined;\n    this.xTouched = false;\n    this.yTouched = false;\n\n    Object.preventExtensions(this);\n}\n\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.nextTouched = function(v) {\n    var p = this.nextPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }\n\n    return p;\n};\n\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.prevTouched = function(v) {\n    var p = this.prevPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }\n\n    return p;\n};\n\n/*\n* The zero point.\n*/\nvar HPZero = Object.freeze(new HPoint(0, 0));\n\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\nvar defaultState = {\n    cvCutIn: 17 / 16,    // control value cut in\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1,             // loops some instructions\n    minDis: 1,           // minimum distance\n    autoFlip: true\n};\n\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\nfunction State(env, prog) {\n    this.env = env;\n    this.stack = [];\n    this.prog = prog;\n\n    switch (env) {\n        case 'glyf' :\n            this.zp0 = this.zp1 = this.zp2 = 1;\n            this.rp0 = this.rp1 = this.rp2 = 0;\n            /* fall through */\n        case 'prep' :\n            this.fv = this.pv = this.dpv = xUnitVector;\n            this.round = roundToGrid;\n    }\n}\n\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\nHinting.prototype.exec = function(glyph, ppem) {\n    if (typeof ppem !== 'number') {\n        throw new Error('Point size is not a number!');\n    }\n\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) { return; }\n\n    var font = this.font;\n    var prepState = this._prepState;\n\n    if (!prepState || prepState.ppem !== ppem) {\n        var fpgmState = this._fpgmState;\n\n        if (!fpgmState) {\n            // Executes the fpgm state.\n            // This is used by fonts to define functions.\n            State.prototype = defaultState;\n\n            fpgmState =\n            this._fpgmState =\n                new State('fpgm', font.tables.fpgm);\n\n            fpgmState.funcs = [ ];\n            fpgmState.font = font;\n\n            if (exports.DEBUG) {\n                console.log('---EXEC FPGM---');\n                fpgmState.step = -1;\n            }\n\n            try {\n                exec(fpgmState);\n            } catch (e) {\n                console.log('Hinting error in FPGM:' + e);\n                this._errorState = 3;\n                return;\n            }\n        }\n\n        // Executes the prep program for this ppem setting.\n        // This is used by fonts to set cvt values\n        // depending on to be rendered font size.\n\n        State.prototype = fpgmState;\n        prepState =\n        this._prepState =\n            new State('prep', font.tables.prep);\n\n        prepState.ppem = ppem;\n\n        // Creates a copy of the cvt table\n        // and scales it to the current ppem setting.\n        var oCvt = font.tables.cvt;\n        if (oCvt) {\n            var cvt = prepState.cvt = new Array(oCvt.length);\n            var scale = ppem / font.unitsPerEm;\n            for (var c = 0; c < oCvt.length; c++) {\n                cvt[c] = oCvt[c] * scale;\n            }\n        } else {\n            prepState.cvt = [];\n        }\n\n        if (exports.DEBUG) {\n            console.log('---EXEC PREP---');\n            prepState.step = -1;\n        }\n\n        try {\n            exec(prepState);\n        } catch (e) {\n            if (this._errorState < 2) {\n                console.log('Hinting error in PREP:' + e);\n            }\n            this._errorState = 2;\n        }\n    }\n\n    if (this._errorState > 1) { return; }\n\n    try {\n        return execGlyph(glyph, prepState);\n    } catch (e) {\n        if (this._errorState < 1) {\n            console.log('Hinting error:' + e);\n            console.log('Note: further hinting errors are silenced');\n        }\n        this._errorState = 1;\n        return undefined;\n    }\n};\n\n/*\n* Executes the hinting program for a glyph.\n*/\nexecGlyph = function(glyph, prepState) {\n    // original point positions\n    var xScale = prepState.ppem / prepState.font.unitsPerEm;\n    var yScale = xScale;\n    var components = glyph.components;\n    var contours;\n    var gZone;\n    var state;\n\n    State.prototype = prepState;\n    if (!components) {\n        state = new State('glyf', glyph.instructions);\n        if (exports.DEBUG) {\n            console.log('---EXEC GLYPH---');\n            state.step = -1;\n        }\n        execComponent(glyph, state, xScale, yScale);\n        gZone = state.gZone;\n    } else {\n        var font = prepState.font;\n        gZone = [];\n        contours = [];\n        for (var i = 0; i < components.length; i++) {\n            var c = components[i];\n            var cg = font.glyphs.get(c.glyphIndex);\n\n            state = new State('glyf', cg.instructions);\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMP ' + i + '---');\n                state.step = -1;\n            }\n\n            execComponent(cg, state, xScale, yScale);\n            // appends the computed points to the result array\n            // post processes the component points\n            var dx = Math.round(c.dx * xScale);\n            var dy = Math.round(c.dy * yScale);\n            var gz = state.gZone;\n            var cc = state.contours;\n            for (var pi = 0; pi < gz.length; pi++) {\n                var p = gz[pi];\n                p.xTouched = p.yTouched = false;\n                p.xo = p.x = p.x + dx;\n                p.yo = p.y = p.y + dy;\n            }\n\n            var gLen = gZone.length;\n            gZone.push.apply(gZone, gz);\n            for (var j = 0; j < cc.length; j++) {\n                contours.push(cc[j] + gLen);\n            }\n        }\n\n        if (glyph.instructions && !state.inhibitGridFit) {\n            // the composite has instructions on its own\n            state = new State('glyf', glyph.instructions);\n\n            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n            state.contours = contours;\n\n            // note: HPZero cannot be used here, since\n            //       the point might be modified\n            gZone.push(\n                new HPoint(0, 0),\n                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n            );\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMPOSITE---');\n                state.step = -1;\n            }\n\n            exec(state);\n\n            gZone.length -= 2;\n        }\n    }\n\n    return gZone;\n};\n\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself for a non-component glyph.\n*/\nexecComponent = function(glyph, state, xScale, yScale)\n{\n    var points = glyph.points || [];\n    var pLen = points.length;\n    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n    var contours = state.contours = [];\n\n    // Scales the original points and\n    // makes copies for the hinted points.\n    var cp; // current point\n    for (var i = 0; i < pLen; i++) {\n        cp = points[i];\n\n        gZone[i] = new HPoint(\n            cp.x * xScale,\n            cp.y * yScale,\n            cp.lastPointOfContour,\n            cp.onCurve\n        );\n    }\n\n    // Chain links the contours.\n    var sp; // start point\n    var np; // next point\n\n    for (var i$1 = 0; i$1 < pLen; i$1++) {\n        cp = gZone[i$1];\n\n        if (!sp) {\n            sp = cp;\n            contours.push(i$1);\n        }\n\n        if (cp.lastPointOfContour) {\n            cp.nextPointOnContour = sp;\n            sp.prevPointOnContour = cp;\n            sp = undefined;\n        } else {\n            np = gZone[i$1 + 1];\n            cp.nextPointOnContour = np;\n            np.prevPointOnContour = cp;\n        }\n    }\n\n    if (state.inhibitGridFit) { return; }\n\n    if (exports.DEBUG) {\n        console.log('PROCESSING GLYPH', state.stack);\n        for (var i$2 = 0; i$2 < pLen; i$2++) {\n            console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n        }\n    }\n\n    gZone.push(\n        new HPoint(0, 0),\n        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n    );\n\n    exec(state);\n\n    // Removes the extra points.\n    gZone.length -= 2;\n\n    if (exports.DEBUG) {\n        console.log('FINISHED GLYPH', state.stack);\n        for (var i$3 = 0; i$3 < pLen; i$3++) {\n            console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n        }\n    }\n};\n\n/*\n* Executes the program loaded in state.\n*/\nexec = function(state) {\n    var prog = state.prog;\n\n    if (!prog) { return; }\n\n    var pLen = prog.length;\n    var ins;\n\n    for (state.ip = 0; state.ip < pLen; state.ip++) {\n        if (exports.DEBUG) { state.step++; }\n        ins = instructionTable[prog[state.ip]];\n\n        if (!ins) {\n            throw new Error(\n                'unknown instruction: 0x' +\n                Number(prog[state.ip]).toString(16)\n            );\n        }\n\n        ins(state);\n\n        // very extensive debugging for each step\n        /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */\n    }\n};\n\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\nfunction initTZone(state)\n{\n    var tZone = state.tZone = new Array(state.gZone.length);\n\n    // no idea if this is actually correct...\n    for (var i = 0; i < tZone.length; i++)\n    {\n        tZone[i] = new HPoint(0, 0);\n    }\n}\n\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\nfunction skip(state, handleElse)\n{\n    var prog = state.prog;\n    var ip = state.ip;\n    var nesting = 1;\n    var ins;\n\n    do {\n        ins = prog[++ip];\n        if (ins === 0x58) // IF\n            { nesting++; }\n        else if (ins === 0x59) // EIF\n            { nesting--; }\n        else if (ins === 0x40) // NPUSHB\n            { ip += prog[ip + 1] + 1; }\n        else if (ins === 0x41) // NPUSHW\n            { ip += 2 * prog[ip + 1] + 1; }\n        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n            { ip += ins - 0xB0 + 1; }\n        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n            { ip += (ins - 0xB8 + 1) * 2; }\n        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n            { break; }\n    } while (nesting > 0);\n\n    state.ip = ip;\n}\n\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }\n\n    state.fv = state.pv = state.dpv = v;\n}\n\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }\n\n    state.pv = state.dpv = v;\n}\n\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }\n\n    state.fv = v;\n}\n\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.pv = state.dpv = getUnitVector(dx, dy);\n}\n\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.fv = getUnitVector(dx, dy);\n}\n\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.pv = state.dpv = getUnitVector(x, y);\n}\n\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.fv = getUnitVector(x, y);\n}\n\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n    var stack = state.stack;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }\n\n    stack.push(pv.x * 0x4000);\n    stack.push(pv.y * 0x4000);\n}\n\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n    var stack = state.stack;\n    var fv = state.fv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }\n\n    stack.push(fv.x * 0x4000);\n    stack.push(fv.y * 0x4000);\n}\n\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n    state.fv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }\n}\n\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state)\n{\n    var stack = state.stack;\n    var pa0i = stack.pop();\n    var pa1i = stack.pop();\n    var pb0i = stack.pop();\n    var pb1i = stack.pop();\n    var pi = stack.pop();\n    var z0 = state.z0;\n    var z1 = state.z1;\n    var pa0 = z0[pa0i];\n    var pa1 = z0[pa1i];\n    var pb0 = z1[pb0i];\n    var pb1 = z1[pb1i];\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }\n\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n    var x1 = pa0.x;\n    var y1 = pa0.y;\n    var x2 = pa1.x;\n    var y2 = pa1.y;\n    var x3 = pb0.x;\n    var y3 = pb0.y;\n    var x4 = pb1.x;\n    var y4 = pb1.y;\n\n    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    var f1 = x1 * y2 - y1 * x2;\n    var f2 = x3 * y4 - y3 * x4;\n\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n    state.rp0 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }\n}\n\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n    state.rp1 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }\n}\n\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n    state.rp2 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }\n}\n\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }\n\n    state.zp0 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }\n\n    state.zp1 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z1 = state.tZone;\n            break;\n        case 1 :\n            state.z1 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }\n\n    state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }\n\n    state.zp0 = state.zp1 = state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.z1 = state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.z1 = state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n    state.loop = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }\n}\n\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }\n\n    state.round = roundToGrid;\n}\n\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }\n\n    state.round = roundToHalfGrid;\n}\n\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n    var d = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }\n\n    state.minDis = d / 0x40;\n}\n\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n\n    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }\n\n    skip(state, false);\n}\n\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n    var o = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }\n\n    // A jump by 1 would do nothing.\n    state.ip += o - 1;\n}\n\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }\n\n    state.cvCutIn = n / 0x40;\n}\n\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }\n\n    stack.push(stack[stack.length - 1]);\n}\n\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }\n\n    state.stack.pop();\n}\n\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }\n\n    state.stack.length = 0;\n}\n\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n    var stack = state.stack;\n\n    var a = stack.pop();\n    var b = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }\n\n    stack.push(a);\n    stack.push(b);\n}\n\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }\n\n    stack.push(stack.length);\n}\n\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n    var stack = state.stack;\n    var fn = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    for (var i = 0; i < c; i++) {\n        exec(state);\n\n        if (exports.DEBUG) { console.log(\n            ++state.step,\n            i + 1 < c ? 'next loopcall' : 'done loopcall',\n            i\n        ); }\n    }\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n}\n\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n    var fn = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    exec(state);\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n\n    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }\n}\n\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }\n\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k]);\n}\n\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }\n\n    stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    var fn = stack.pop();\n    var ipBegin = ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }\n\n    while (prog[++ip] !== 0x2D){ }\n\n    state.ip = ip;\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n    var pi = state.stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) { d = state.round(d); }\n\n    fv.setRelative(p, HPZero, d, pv);\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n    var z2 = state.z2;\n    var pLen = z2.length - 2;\n    var cp;\n    var pp;\n    var np;\n\n    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }\n\n    for (var i = 0; i < pLen; i++) {\n        cp = z2[i]; // current point\n\n        // if this point has been touched go on\n        if (v.touched(cp)) { continue; }\n\n        pp = cp.prevTouched(v);\n\n        // no point on the contour has been touched?\n        if (pp === cp) { continue; }\n\n        np = cp.nextTouched(v);\n\n        if (pp === np) {\n            // only one point on the contour has been touched\n            // so simply moves the point like that\n\n            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n        }\n\n        v.interpolate(cp, pp, np, v);\n    }\n}\n\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var loop = state.loop;\n    var z2 = state.z2;\n\n    while (loop--)\n    {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        var d = pv.distance(rp, rp, false, true);\n        fv.setRelative(p, p, d, pv);\n        fv.touch(p);\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ?\n                   'loop ' + (state.loop - loop) + ': ' :\n                   ''\n                ) +\n                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n            );\n        }\n    }\n\n    state.loop = 1;\n}\n\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var ci = stack.pop();\n    var sp = state.z2[state.contours[ci]];\n    var p = sp;\n\n    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }\n\n    var d = pv.distance(rp, rp, false, true);\n\n    do {\n        if (p !== rp) { fv.setRelative(p, p, d, pv); }\n        p = p.nextPointOnContour;\n    } while (p !== sp);\n}\n\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }\n\n    var z;\n    switch (e) {\n        case 0 : z = state.tZone; break;\n        case 1 : z = state.gZone; break;\n        default : throw new Error('Invalid zone');\n    }\n\n    var p;\n    var d = pv.distance(rp, rp, false, true);\n    var pLen = z.length - 2;\n    for (var i = 0; i < pLen; i++)\n    {\n        p = z[i];\n        fv.setRelative(p, p, d, pv);\n        //if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n}\n\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n    var stack = state.stack;\n    var loop = state.loop;\n    var fv = state.fv;\n    var d = stack.pop() / 0x40;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'SHPIX[]', pi, d\n            );\n        }\n\n        fv.setRelative(p, p, d);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n    var stack = state.stack;\n    var rp1i = state.rp1;\n    var rp2i = state.rp2;\n    var loop = state.loop;\n    var rp1 = state.z0[rp1i];\n    var rp2 = state.z1[rp2i];\n    var fv = state.fv;\n    var pv = state.dpv;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'IP[]', pi, rp1i, '<->', rp2i\n            );\n        }\n\n        fv.interpolate(p, rp1, rp2, pv);\n\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n    var stack = state.stack;\n    var d = stack.pop() / 64;\n    var pi = stack.pop();\n    var p = state.z1[pi];\n    var rp0 = state.z0[state.rp0];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    fv.setRelative(p, rp0, d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (a) { state.rp0 = pi; }\n}\n\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n    var stack = state.stack;\n    var rp0i = state.rp0;\n    var rp0 = state.z0[rp0i];\n    var loop = state.loop;\n    var fv = state.fv;\n    var pv = state.pv;\n    var z1 = state.z1;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z1[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'ALIGNRP[]', pi\n            );\n        }\n\n        fv.setRelative(p, rp0, 0, pv);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }\n\n    state.round = roundToDoubleGrid;\n}\n\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var pi = stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var cv = state.cvt[n];\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            'MIAP[' + round + ']',\n            n, '(', cv, ')', pi\n        );\n    }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) {\n        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\n        d = state.round(d);\n    }\n\n    fv.setRelative(p, HPZero, d, pv);\n\n    if (state.zp0 === 0) {\n        p.xo = p.x;\n        p.yo = p.y;\n    }\n\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n    var prog = state.prog;\n    var ip = state.ip;\n    var stack = state.stack;\n\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    if (!store) { store = state.store = []; }\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }\n\n    store[l] = v;\n}\n\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RS', l); }\n\n    var v = (store && store[l]) || 0;\n\n    stack.push(v);\n}\n\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n    var stack = state.stack;\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }\n\n    state.cvt[l] = v / 0x40;\n}\n\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n    var stack = state.stack;\n    var cvte = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }\n\n    stack.push(state.cvt[cvte] * 0x40);\n}\n\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n    var stack = state.stack;\n    var pi = stack.pop();\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }\n\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n    var stack = state.stack;\n    var pi2 = stack.pop();\n    var pi1 = stack.pop();\n    var p2 = state.z1[pi2];\n    var p1 = state.z0[pi1];\n    var d = state.dpv.distance(p1, p2, a, a);\n\n    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }\n\n    state.stack.push(Math.round(d * 64));\n}\n\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }\n    state.stack.push(state.ppem);\n}\n\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }\n    state.autoFlip = true;\n}\n\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }\n\n    stack.push(e1 < e2 ? 1 : 0);\n}\n\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }\n\n    stack.push(e1 <= e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }\n\n    stack.push(e1 > e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }\n\n    stack.push(e1 >= e2 ? 1 : 0);\n}\n\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }\n\n    stack.push(e2 === e1 ? 1 : 0);\n}\n\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }\n\n    stack.push(e2 !== e1 ? 1 : 0);\n}\n\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n    var test = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }\n\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n        skip(state, true);\n\n        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }\n    }\n}\n\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n\n    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n}\n\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }\n\n    stack.push(e2 && e1 ? 1 : 0);\n}\n\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }\n\n    stack.push(e2 || e1 ? 1 : 0);\n}\n\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n    var stack = state.stack;\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }\n\n    stack.push(e ? 0 : 1);\n}\n\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var fv = state.fv;\n    var pv = state.pv;\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n    var z0 = state.z0;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var pi = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }\n\n        var p = z0[pi];\n        fv.setRelative(p, p, mag * ds, pv);\n    }\n}\n\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }\n\n    state.deltaBase = n;\n}\n\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }\n\n    state.deltaShift = Math.pow(0.5, n);\n}\n\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }\n\n    stack.push(n1 + n2);\n}\n\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }\n\n    stack.push(n1 - n2);\n}\n\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }\n\n    stack.push(n1 * 64 / n2);\n}\n\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }\n\n    stack.push(n1 * n2 / 64);\n}\n\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }\n\n    stack.push(Math.abs(n));\n}\n\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }\n\n    stack.push(-n);\n}\n\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }\n\n    stack.push(Math.floor(n / 0x40) * 0x40);\n}\n\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }\n\n    stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }\n\n    stack.push(state.round(n / 0x40) * 0x40);\n}\n\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n    var stack = state.stack;\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }\n\n    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var c = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n\n        var delta = mag * ds;\n\n        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }\n\n        state.cvt[c] += delta;\n    }\n}\n\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = 0.5;\n            break;\n        case 0x40:\n            period = 1;\n            break;\n        case 0x80:\n            period = 2;\n            break;\n        default:\n            throw new Error('invalid SROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default: throw new Error('invalid SROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = Math.sqrt(2) / 2;\n            break;\n        case 0x40:\n            period = Math.sqrt(2);\n            break;\n        case 0x80:\n            period = 2 * Math.sqrt(2);\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }\n\n    state.round = roundOff;\n}\n\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }\n\n    state.round = roundUpToGrid;\n}\n\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }\n\n    state.round = roundDownToGrid;\n}\n\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n    var n = state.stack.pop();\n\n    // ignored by opentype.js\n\n    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }\n}\n\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.dpv = getUnitVector(dx, dy);\n}\n\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n    var stack = state.stack;\n    var sel = stack.pop();\n    var r = 0;\n\n    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }\n\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) { r = 35; }\n\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n\n    // opentype.js is always gray scaling\n    if (sel & 0x20) { r |= 0x1000; }\n\n    stack.push(r);\n}\n\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n    var stack = state.stack;\n    var a = stack.pop();\n    var b = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }\n\n    stack.push(b);\n    stack.push(a);\n    stack.push(c);\n}\n\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }\n\n    stack.push(Math.max(e1, e2));\n}\n\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }\n\n    stack.push(Math.min(e1, e2));\n}\n\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n    var n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }\n}\n\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n    var s = state.stack.pop();\n    var v = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }\n\n    switch (s) {\n        case 1 : state.inhibitGridFit = !!v; return;\n        case 2 : state.ignoreCvt = !!v; return;\n        default: throw new Error('invalid INSTCTRL[] selector');\n    }\n}\n\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    var stack = state.stack;\n    var cvte = indirect && stack.pop();\n    var pi = stack.pop();\n    var rp0i = state.rp0;\n    var rp = state.z0[rp0i];\n    var p = state.z1[pi];\n\n    var md = state.minDis;\n    var fv = state.fv;\n    var pv = state.dpv;\n    var od; // original distance\n    var d; // moving distance\n    var sign; // sign of distance\n    var cv;\n\n    d = od = pv.distance(p, rp, true, true);\n    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n    // TODO consider autoFlip\n    d = Math.abs(d);\n\n    if (indirect) {\n        cv = state.cvt[cvte];\n\n        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n    }\n\n    if (keepD && d < md) { d = md; }\n\n    if (ro) { d = state.round(d); }\n\n    fv.setRelative(p, rp, sign * d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            (indirect ? 'MIRP[' : 'MDRP[') +\n            (setRp0 ? 'M' : 'm') +\n            (keepD ? '>' : '_') +\n            (ro ? 'R' : '_') +\n            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n            ']',\n            indirect ?\n                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n                '',\n            pi,\n            '(d =', od, '->', sign * d, ')'\n        );\n    }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (setRp0) { state.rp0 = pi; }\n}\n\n/*\n* The instruction table.\n*/\ninstructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined,   // TODO SSWCI\n    /* 0x1F */ undefined,   // TODO SSW\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined,   // TODO ALIGNPTS\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined,   // TODO UTP\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined,   // TODO SCFS\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined,   // TODO MPS\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined,   // TODO FLIPOFF\n    /* 0x4F */ undefined,   // TODO DEBUG\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined,   // TODO NROUND[ab]\n    /* 0x6D */ undefined,   // TODO NROUND[ab]\n    /* 0x6E */ undefined,   // TODO NROUND[ab]\n    /* 0x6F */ undefined,   // TODO NROUND[ab]\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined,   // TODO JROT[]\n    /* 0x79 */ undefined,   // TODO JROF[]\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n    /* 0x80 */ undefined,   // TODO FLIPPT\n    /* 0x81 */ undefined,   // TODO FLIPRGON\n    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined,   // TODO IDEF\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n];\n\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90 \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/\n\n/**\n * Converts a string into a list of tokens.\n */\n\n/**\n * Create a new token\n * @param {string} char a single char\n */\nfunction Token(char) {\n    this.char = char;\n    this.state = {};\n    this.activeState = null;\n}\n\n/**\n * Create a new context range\n * @param {number} startIndex range start index\n * @param {number} endOffset range end index offset\n * @param {string} contextName owner context name\n */\nfunction ContextRange(startIndex, endOffset, contextName) {\n    this.contextName = contextName;\n    this.startIndex = startIndex;\n    this.endOffset = endOffset;\n}\n\n/**\n * Check context start and end\n * @param {string} contextName a unique context name\n * @param {function} checkStart a predicate function the indicates a context's start\n * @param {function} checkEnd a predicate function the indicates a context's end\n */\nfunction ContextChecker(contextName, checkStart, checkEnd) {\n    this.contextName = contextName;\n    this.openRange = null;\n    this.ranges = [];\n    this.checkStart = checkStart;\n    this.checkEnd = checkEnd;\n}\n\n/**\n * @typedef ContextParams\n * @type Object\n * @property {array} context context items\n * @property {number} currentIndex current item index\n */\n\n/**\n * Create a context params\n * @param {array} context a list of items\n * @param {number} currentIndex current item index\n */\nfunction ContextParams(context, currentIndex) {\n    this.context = context;\n    this.index = currentIndex;\n    this.length = context.length;\n    this.current = context[currentIndex];\n    this.backtrack = context.slice(0, currentIndex);\n    this.lookahead = context.slice(currentIndex + 1);\n}\n\n/**\n * Create an event instance\n * @param {string} eventId event unique id\n */\nfunction Event(eventId) {\n    this.eventId = eventId;\n    this.subscribers = [];\n}\n\n/**\n * Initialize a core events and auto subscribe required event handlers\n * @param {any} events an object that enlists core events handlers\n */\nfunction initializeCoreEvents(events) {\n    var this$1 = this;\n\n    var coreEvents = [\n        'start', 'end', 'next', 'newToken', 'contextStart',\n        'contextEnd', 'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'\n    ];\n\n    coreEvents.forEach(function (eventId) {\n        Object.defineProperty(this$1.events, eventId, {\n            value: new Event(eventId)\n        });\n    });\n\n    if (!!events) {\n        coreEvents.forEach(function (eventId) {\n            var event = events[eventId];\n            if (typeof event === 'function') {\n                this$1.events[eventId].subscribe(event);\n            }\n        });\n    }\n    var requiresContextUpdate = [\n        'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD'\n    ];\n    requiresContextUpdate.forEach(function (eventId) {\n        this$1.events[eventId].subscribe(\n            this$1.updateContextsRanges\n        );\n    });\n}\n\n/**\n * Converts a string into a list of tokens\n * @param {any} events tokenizer core events\n */\nfunction Tokenizer(events) {\n    this.tokens = [];\n    this.registeredContexts = {};\n    this.contextCheckers = [];\n    this.events = {};\n    this.registeredModifiers = [];\n\n    initializeCoreEvents.call(this, events);\n}\n\n/**\n * Sets the state of a token, usually called by a state modifier.\n * @param {string} key state item key\n * @param {any} value state item value\n */\nToken.prototype.setState = function(key, value) {\n    this.state[key] = value;\n    this.activeState = { key: key, value: this.state[key] };\n    return this.activeState;\n};\n\nToken.prototype.getState = function (stateId) {\n    return this.state[stateId] || null;\n};\n\n/**\n * Checks if an index exists in the tokens list.\n * @param {number} index token index\n */\nTokenizer.prototype.inboundIndex = function(index) {\n    return index >= 0 && index < this.tokens.length;\n};\n\n/**\n * Compose and apply a list of operations (replace, update, delete)\n * @param {array} RUDs replace, update and delete operations\n * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n */\nTokenizer.prototype.composeRUD = function (RUDs) {\n    var this$1 = this;\n\n    var silent = true;\n    var state = RUDs.map(function (RUD) { return (\n        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))\n    ); });\n    var hasFAILObject = function (obj) { return (\n        typeof obj === 'object' &&\n        obj.hasOwnProperty('FAIL')\n    ); };\n    if (state.every(hasFAILObject)) {\n        return {\n            FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n            report: state.filter(hasFAILObject)\n        };\n    }\n    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);\n};\n\n/**\n * Replace a range of tokens with a list of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {token} tokens a list of tokens to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n    offset = offset !== null ? offset : this.tokens.length;\n    var isTokenType = tokens.every(function (token) { return token instanceof Token; });\n    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n        var replaced = this.tokens.splice.apply(\n            this.tokens, [startIndex, offset].concat(tokens)\n        );\n        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }\n        return [replaced, tokens];\n    } else {\n        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };\n    }\n};\n\n/**\n * Replace a token with another token\n * @param {number} index token index\n * @param {token} token a token to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceToken = function (index, token, silent) {\n    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n        var replaced = this.tokens.splice(index, 1, token);\n        if (!silent) { this.dispatch('replaceToken', [index, token]); }\n        return [replaced[0], token];\n    } else {\n        return { FAIL: 'replaceToken: invalid token or index.' };\n    }\n};\n\n/**\n * Removes a range of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeRange = function(startIndex, offset, silent) {\n    offset = !isNaN(offset) ? offset : this.tokens.length;\n    var tokens = this.tokens.splice(startIndex, offset);\n    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }\n    return tokens;\n};\n\n/**\n * Remove a token at a certain index\n * @param {number} index token index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeToken = function(index, silent) {\n    if (!isNaN(index) && this.inboundIndex(index)) {\n        var token = this.tokens.splice(index, 1);\n        if (!silent) { this.dispatch('removeToken', [token, index]); }\n        return token;\n    } else {\n        return { FAIL: 'removeToken: invalid token index.' };\n    }\n};\n\n/**\n * Insert a list of tokens at a certain index\n * @param {array} tokens a list of tokens to insert\n * @param {number} index insert the list of tokens at index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.insertToken = function (tokens, index, silent) {\n    var tokenType = tokens.every(\n        function (token) { return token instanceof Token; }\n    );\n    if (tokenType) {\n        this.tokens.splice.apply(\n            this.tokens, [index, 0].concat(tokens)\n        );\n        if (!silent) { this.dispatch('insertToken', [tokens, index]); }\n        return tokens;\n    } else {\n        return { FAIL: 'insertToken: invalid token(s).' };\n    }\n};\n\n/**\n * A state modifier that is called on 'newToken' event\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a function to update token state\n */\nTokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {\n    this.events.newToken.subscribe(function(token, contextParams) {\n        var conditionParams = [token, contextParams];\n        var canApplyModifier = (\n            condition === null ||\n            condition.apply(this, conditionParams) === true\n        );\n        var modifierParams = [token, contextParams];\n        if (canApplyModifier) {\n            var newStateValue = modifier.apply(this, modifierParams);\n            token.setState(modifierId, newStateValue);\n        }\n    });\n    this.registeredModifiers.push(modifierId);\n};\n\n/**\n * Subscribe a handler to an event\n * @param {function} eventHandler an event handler function\n */\nEvent.prototype.subscribe = function (eventHandler) {\n    if (typeof eventHandler === 'function') {\n        return ((this.subscribers.push(eventHandler)) - 1);\n    } else {\n        return { FAIL: (\"invalid '\" + (this.eventId) + \"' event handler\")};\n    }\n};\n\n/**\n * Unsubscribe an event handler\n * @param {string} subsId subscription id\n */\nEvent.prototype.unsubscribe = function (subsId) {\n    this.subscribers.splice(subsId, 1);\n};\n\n/**\n * Sets context params current value index\n * @param {number} index context params current value index\n */\nContextParams.prototype.setCurrentIndex = function(index) {\n    this.index = index;\n    this.current = this.context[index];\n    this.backtrack = this.context.slice(0, index);\n    this.lookahead = this.context.slice(index + 1);\n};\n\n/**\n * Get an item at an offset from the current value\n * example (current value is 3):\n *  1    2   [3]   4    5   |   items values\n * -2   -1    0    1    2   |   offset values\n * @param {number} offset an offset from current value index\n */\nContextParams.prototype.get = function (offset) {\n    switch (true) {\n        case (offset === 0):\n            return this.current;\n        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):\n            return this.backtrack.slice(offset)[0];\n        case (offset > 0 && offset <= this.lookahead.length):\n            return this.lookahead[offset - 1];\n        default:\n            return null;\n    }\n};\n\n/**\n * Converts a context range into a string value\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.rangeToText = function (range) {\n    if (range instanceof ContextRange) {\n        return (\n            this.getRangeTokens(range)\n                .map(function (token) { return token.char; }).join('')\n        );\n    }\n};\n\n/**\n * Converts all tokens into a string\n */\nTokenizer.prototype.getText = function () {\n    return this.tokens.map(function (token) { return token.char; }).join('');\n};\n\n/**\n * Get a context by name\n * @param {string} contextName context name to get\n */\nTokenizer.prototype.getContext = function (contextName) {\n    var context = this.registeredContexts[contextName];\n    return !!context ? context : null;\n};\n\n/**\n * Subscribes a new event handler to an event\n * @param {string} eventName event name to subscribe to\n * @param {function} eventHandler a function to be invoked on event\n */\nTokenizer.prototype.on = function(eventName, eventHandler) {\n    var event = this.events[eventName];\n    if (!!event) {\n        return event.subscribe(eventHandler);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Dispatches an event\n * @param {string} eventName event name\n * @param {any} args event handler arguments\n */\nTokenizer.prototype.dispatch = function(eventName, args) {\n    var this$1 = this;\n\n    var event = this.events[eventName];\n    if (event instanceof Event) {\n        event.subscribers.forEach(function (subscriber) {\n            subscriber.apply(this$1, args || []);\n        });\n    }\n};\n\n/**\n * Register a new context checker\n * @param {string} contextName a unique context name\n * @param {function} contextStartCheck a predicate function that returns true on context start\n * @param {function} contextEndCheck  a predicate function that returns true on context end\n * TODO: call tokenize on registration to update context ranges with the new context.\n */\nTokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {\n    if (!!this.getContext(contextName)) { return {\n        FAIL:\n        (\"context name '\" + contextName + \"' is already registered.\")\n    }; }\n    if (typeof contextStartCheck !== 'function') { return {\n        FAIL:\n        \"missing context start check.\"\n    }; }\n    if (typeof contextEndCheck !== 'function') { return {\n        FAIL:\n        \"missing context end check.\"\n    }; }\n    var contextCheckers = new ContextChecker(\n        contextName, contextStartCheck, contextEndCheck\n    );\n    this.registeredContexts[contextName] = contextCheckers;\n    this.contextCheckers.push(contextCheckers);\n    return contextCheckers;\n};\n\n/**\n * Gets a context range tokens\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.getRangeTokens = function(range) {\n    var endIndex = range.startIndex + range.endOffset;\n    return [].concat(\n        this.tokens\n            .slice(range.startIndex, endIndex)\n    );\n};\n\n/**\n * Gets the ranges of a context\n * @param {string} contextName context name\n */\nTokenizer.prototype.getContextRanges = function(contextName) {\n    var context = this.getContext(contextName);\n    if (!!context) {\n        return context.ranges;\n    } else {\n        return { FAIL: (\"context checker '\" + contextName + \"' is not registered.\") };\n    }\n};\n\n/**\n * Resets context ranges to run context update\n */\nTokenizer.prototype.resetContextsRanges = function () {\n    var registeredContexts = this.registeredContexts;\n    for (var contextName in registeredContexts) {\n        if (registeredContexts.hasOwnProperty(contextName)) {\n            var context = registeredContexts[contextName];\n            context.ranges = [];\n        }\n    }\n};\n\n/**\n * Updates context ranges\n */\nTokenizer.prototype.updateContextsRanges = function () {\n    this.resetContextsRanges();\n    var chars = this.tokens.map(function (token) { return token.char; });\n    for (var i = 0; i < chars.length; i++) {\n        var contextParams = new ContextParams(chars, i);\n        this.runContextCheck(contextParams);\n    }\n    this.dispatch('updateContextsRanges', [this.registeredContexts]);\n};\n\n/**\n * Sets the end offset of an open range\n * @param {number} offset range end offset\n * @param {string} contextName context name\n */\nTokenizer.prototype.setEndOffset = function (offset, contextName) {\n    var startIndex = this.getContext(contextName).openRange.startIndex;\n    var range = new ContextRange(startIndex, offset, contextName);\n    var ranges = this.getContext(contextName).ranges;\n    range.rangeId = contextName + \".\" + (ranges.length);\n    ranges.push(range);\n    this.getContext(contextName).openRange = null;\n    return range;\n};\n\n/**\n * Runs a context check on the current context\n * @param {contextParams} contextParams current context params\n */\nTokenizer.prototype.runContextCheck = function(contextParams) {\n    var this$1 = this;\n\n    var index = contextParams.index;\n    this.contextCheckers.forEach(function (contextChecker) {\n        var contextName = contextChecker.contextName;\n        var openRange = this$1.getContext(contextName).openRange;\n        if (!openRange && contextChecker.checkStart(contextParams)) {\n            openRange = new ContextRange(index, null, contextName);\n            this$1.getContext(contextName).openRange = openRange;\n            this$1.dispatch('contextStart', [contextName, index]);\n        }\n        if (!!openRange && contextChecker.checkEnd(contextParams)) {\n            var offset = (index - openRange.startIndex) + 1;\n            var range = this$1.setEndOffset(offset, contextName);\n            this$1.dispatch('contextEnd', [contextName, range]);\n        }\n    });\n};\n\n/**\n * Converts a text into a list of tokens\n * @param {string} text a text to tokenize\n */\nTokenizer.prototype.tokenize = function (text) {\n    this.tokens = [];\n    this.resetContextsRanges();\n    var chars = Array.from(text);\n    this.dispatch('start');\n    for (var i = 0; i < chars.length; i++) {\n        var char = chars[i];\n        var contextParams = new ContextParams(chars, i);\n        this.dispatch('next', [contextParams]);\n        this.runContextCheck(contextParams);\n        var token = new Token(char);\n        this.tokens.push(token);\n        this.dispatch('newToken', [token, contextParams]);\n    }\n    this.dispatch('end', [this.tokens]);\n    return this.tokens;\n};\n\n// \n//  Character Class Assertions  Checks if a char belongs to a certain class \n// \n// jscs:disable maximumLineLength\n/**\n * Check if a char is Arabic\n * @param {string} c a single char\n */\nfunction isArabicChar(c) {\n    return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c);\n}\n\n/**\n * Check if a char is an isolated arabic char\n * @param {string} c a single char\n */\nfunction isIsolatedArabicChar(char) {\n    return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(char);\n}\n\n/**\n * Check if a char is an Arabic Tashkeel char\n * @param {string} c a single char\n */\nfunction isTashkeelArabicChar(char) {\n    return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(char);\n}\n\n/**\n * Check if a char is Latin\n * @param {string} c a single char\n */\nfunction isLatinChar(c) {\n    return /[A-z]/.test(c);\n}\n\n/**\n * Check if a char is whitespace char\n * @param {string} c a single char\n */\nfunction isWhiteSpace(c) {\n    return /\\s/.test(c);\n}\n\n/**\n * Query a feature by some of it's properties to lookup a glyph substitution.\n */\n\n/**\n * Create feature query instance\n * @param {Font} font opentype font instance\n */\nfunction FeatureQuery(font) {\n    this.font = font;\n    this.features = {};\n}\n\n/**\n * @typedef SubstitutionAction\n * @type Object\n * @property {number} id substitution type\n * @property {string} tag feature tag\n * @property {any} substitution substitution value(s)\n */\n\n/**\n * Create a substitution action instance\n * @param {SubstitutionAction} action\n */\nfunction SubstitutionAction(action) {\n    this.id = action.id;\n    this.tag = action.tag;\n    this.substitution = action.substitution;\n}\n\n/**\n * Lookup a coverage table\n * @param {number} glyphIndex glyph index\n * @param {CoverageTable} coverage coverage table\n */\nfunction lookupCoverage(glyphIndex, coverage) {\n    if (!glyphIndex) { return -1; }\n    switch (coverage.format) {\n        case 1:\n            return coverage.glyphs.indexOf(glyphIndex);\n\n        case 2:\n            var ranges = coverage.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (glyphIndex >= range.start && glyphIndex <= range.end) {\n                    var offset = glyphIndex - range.start;\n                    return range.index + offset;\n                }\n            }\n            break;\n        default:\n            return -1; // not found\n    }\n    return -1;\n}\n\n/**\n * Handle a single substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return glyphIndex + subtable.deltaGlyphId;\n}\n\n/**\n * Handle a single substitution - format 2\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat2(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.substitute[substituteIndex];\n}\n\n/**\n * Lookup a list of coverage tables\n * @param {any} coverageList a list of coverage tables\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction lookupCoverageList(coverageList, contextParams) {\n    var lookupList = [];\n    for (var i = 0; i < coverageList.length; i++) {\n        var coverage = coverageList[i];\n        var glyphIndex = contextParams.current;\n        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n        var lookupIndex = lookupCoverage(glyphIndex, coverage);\n        if (lookupIndex !== -1) {\n            lookupList.push(lookupIndex);\n        }\n    }\n    if (lookupList.length !== coverageList.length) { return -1; }\n    return lookupList;\n}\n\n/**\n * Handle chaining context substitution - format 3\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction chainingSubstitutionFormat3(contextParams, subtable) {\n    var lookupsCount = (\n        subtable.inputCoverage.length +\n        subtable.lookaheadCoverage.length +\n        subtable.backtrackCoverage.length\n    );\n    if (contextParams.context.length < lookupsCount) { return []; }\n    // INPUT LOOKUP //\n    var inputLookups = lookupCoverageList(\n        subtable.inputCoverage, contextParams\n    );\n    if (inputLookups === -1) { return []; }\n    // LOOKAHEAD LOOKUP //\n    var lookaheadOffset = subtable.inputCoverage.length - 1;\n    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }\n    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n        lookaheadContext.shift();\n    }\n    var lookaheadParams = new ContextParams(lookaheadContext, 0);\n    var lookaheadLookups = lookupCoverageList(\n        subtable.lookaheadCoverage, lookaheadParams\n    );\n    // BACKTRACK LOOKUP //\n    var backtrackContext = [].concat(contextParams.backtrack);\n    backtrackContext.reverse();\n    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n        backtrackContext.shift();\n    }\n    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }\n    var backtrackParams = new ContextParams(backtrackContext, 0);\n    var backtrackLookups = lookupCoverageList(\n        subtable.backtrackCoverage, backtrackParams\n    );\n    var contextRulesMatch = (\n        inputLookups.length === subtable.inputCoverage.length &&\n        lookaheadLookups.length === subtable.lookaheadCoverage.length &&\n        backtrackLookups.length === subtable.backtrackCoverage.length\n    );\n    var substitutions = [];\n    if (contextRulesMatch) {\n        for (var i = 0; i < subtable.lookupRecords.length; i++) {\n            var lookupRecord = subtable.lookupRecords[i];\n            var lookupListIndex = lookupRecord.lookupListIndex;\n            var lookupTable = this.getLookupByIndex(lookupListIndex);\n            for (var s = 0; s < lookupTable.subtables.length; s++) {\n                var subtable$1 = lookupTable.subtables[s];\n                var lookup = this.getLookupMethod(lookupTable, subtable$1);\n                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);\n                if (substitutionType === '12') {\n                    for (var n = 0; n < inputLookups.length; n++) {\n                        var glyphIndex = contextParams.get(n);\n                        var substitution = lookup(glyphIndex);\n                        if (substitution) { substitutions.push(substitution); }\n                    }\n                }\n            }\n        }\n    }\n    return substitutions;\n}\n\n/**\n * Handle ligature substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction ligatureSubstitutionFormat1(contextParams, subtable) {\n    // COVERAGE LOOKUP //\n    var glyphIndex = contextParams.current;\n    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (ligSetIndex === -1) { return null; }\n    // COMPONENTS LOOKUP\n    // (!) note, components are ordered in the written direction.\n    var ligature;\n    var ligatureSet = subtable.ligatureSets[ligSetIndex];\n    for (var s = 0; s < ligatureSet.length; s++) {\n        ligature = ligatureSet[s];\n        for (var l = 0; l < ligature.components.length; l++) {\n            var lookaheadItem = contextParams.lookahead[l];\n            var component = ligature.components[l];\n            if (lookaheadItem !== component) { break; }\n            if (l === ligature.components.length - 1) { return ligature; }\n        }\n    }\n    return null;\n}\n\n/**\n * Handle decomposition substitution - format 1\n * @param {number} glyphIndex glyph index\n * @param {any} subtable subtable\n */\nfunction decompositionSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.sequences[substituteIndex];\n}\n\n/**\n * Get default script features indexes\n */\nFeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n    var scripts = this.font.tables.gsub.scripts;\n    for (var s = 0; s < scripts.length; s++) {\n        var script = scripts[s];\n        if (script.tag === 'DFLT') { return (\n            script.script.defaultLangSys.featureIndexes\n        ); }\n    }\n    return [];\n};\n\n/**\n * Get feature indexes of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {\n    var tables = this.font.tables;\n    if (!tables.gsub) { return []; }\n    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }\n    var scripts = this.font.tables.gsub.scripts;\n    for (var i = 0; i < scripts.length; i++) {\n        var script = scripts[i];\n        if (script.tag === scriptTag && script.script.defaultLangSys) {\n            return script.script.defaultLangSys.featureIndexes;\n        } else {\n            var langSysRecords = script.langSysRecords;\n            if (!!langSysRecords) {\n                for (var j = 0; j < langSysRecords.length; j++) {\n                    var langSysRecord = langSysRecords[j];\n                    if (langSysRecord.tag === scriptTag) {\n                        var langSys = langSysRecord.langSys;\n                        return langSys.featureIndexes;\n                    }\n                }\n            }\n        }\n    }\n    return this.getDefaultScriptFeaturesIndexes();\n};\n\n/**\n * Map a feature tag to a gsub feature\n * @param {any} features gsub features\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n    var tags = {};\n    for (var i = 0; i < features.length; i++) {\n        var tag = features[i].tag;\n        var feature = features[i].feature;\n        tags[tag] = feature;\n    }\n    this.features[scriptTag].tags = tags;\n};\n\n/**\n * Get features of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n    var features = this.features[scriptTag];\n    if (this.features.hasOwnProperty(scriptTag)) { return features; }\n    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n    if (!featuresIndexes) { return null; }\n    var gsub = this.font.tables.gsub;\n    features = featuresIndexes.map(function (index) { return gsub.features[index]; });\n    this.features[scriptTag] = features;\n    this.mapTagsToFeatures(features, scriptTag);\n    return features;\n};\n\n/**\n * Get substitution type\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {\n    var lookupType = lookupTable.lookupType.toString();\n    var substFormat = subtable.substFormat.toString();\n    return lookupType + substFormat;\n};\n\n/**\n * Get lookup method\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {\n    var this$1 = this;\n\n    var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n    switch (substitutionType) {\n        case '11':\n            return function (glyphIndex) { return singleSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '12':\n            return function (glyphIndex) { return singleSubstitutionFormat2.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '63':\n            return function (contextParams) { return chainingSubstitutionFormat3.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '41':\n            return function (contextParams) { return ligatureSubstitutionFormat1.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '21':\n            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        default:\n            throw new Error(\n                \"lookupType: \" + (lookupTable.lookupType) + \" - \" +\n                \"substFormat: \" + (subtable.substFormat) + \" \" +\n                \"is not yet supported\"\n            );\n    }\n};\n\n/**\n * [ LOOKUP TYPES ]\n * -------------------------------\n * Single                        1;\n * Multiple                      2;\n * Alternate                     3;\n * Ligature                      4;\n * Context                       5;\n * ChainingContext               6;\n * ExtensionSubstitution         7;\n * ReverseChainingContext        8;\n * -------------------------------\n *\n */\n\n/**\n * @typedef FQuery\n * @type Object\n * @param {string} tag feature tag\n * @param {string} script feature script\n * @param {ContextParams} contextParams context params\n */\n\n/**\n * Lookup a feature using a query parameters\n * @param {FQuery} query feature query\n */\nFeatureQuery.prototype.lookupFeature = function (query) {\n    var contextParams = query.contextParams;\n    var currentIndex = contextParams.index;\n    var feature = this.getFeature({\n        tag: query.tag, script: query.script\n    });\n    if (!feature) { return new Error(\n        \"font '\" + (this.font.names.fullName.en) + \"' \" +\n        \"doesn't support feature '\" + (query.tag) + \"' \" +\n        \"for script '\" + (query.script) + \"'.\"\n    ); }\n    var lookups = this.getFeatureLookups(feature);\n    var substitutions = [].concat(contextParams.context);\n    for (var l = 0; l < lookups.length; l++) {\n        var lookupTable = lookups[l];\n        var subtables = this.getLookupSubtables(lookupTable);\n        for (var s = 0; s < subtables.length; s++) {\n            var subtable = subtables[s];\n            var substType = this.getSubstitutionType(lookupTable, subtable);\n            var lookup = this.getLookupMethod(lookupTable, subtable);\n            var substitution = (void 0);\n            switch (substType) {\n                case '11':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 11, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '12':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 12, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '63':\n                    substitution = lookup(contextParams);\n                    if (Array.isArray(substitution) && substitution.length) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 63, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '41':\n                    substitution = lookup(contextParams);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 41, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '21':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 21, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n            }\n            contextParams = new ContextParams(substitutions, currentIndex);\n            if (Array.isArray(substitution) && !substitution.length) { continue; }\n            substitution = null;\n        }\n    }\n    return substitutions.length ? substitutions : null;\n};\n\n/**\n * Checks if a font supports a specific features\n * @param {FQuery} query feature query object\n */\nFeatureQuery.prototype.supports = function (query) {\n    if (!query.script) { return false; }\n    this.getScriptFeatures(query.script);\n    var supportedScript = this.features.hasOwnProperty(query.script);\n    if (!query.tag) { return supportedScript; }\n    var supportedFeature = (\n        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })\n    );\n    return supportedScript && supportedFeature;\n};\n\n/**\n * Get lookup table subtables\n * @param {any} lookupTable lookup table\n */\nFeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n    return lookupTable.subtables || null;\n};\n\n/**\n * Get lookup table by index\n * @param {number} index lookup table index\n */\nFeatureQuery.prototype.getLookupByIndex = function (index) {\n    var lookups = this.font.tables.gsub.lookups;\n    return lookups[index] || null;\n};\n\n/**\n * Get lookup tables for a feature\n * @param {string} feature\n */\nFeatureQuery.prototype.getFeatureLookups = function (feature) {\n    // TODO: memoize\n    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n};\n\n/**\n * Query a feature by it's properties\n * @param {any} query an object that describes the properties of a query\n */\nFeatureQuery.prototype.getFeature = function getFeature(query) {\n    if (!this.font) { return { FAIL: \"No font was found\"}; }\n    if (!this.features.hasOwnProperty(query.script)) {\n        this.getScriptFeatures(query.script);\n    }\n    var scriptFeatures = this.features[query.script];\n    if (!scriptFeatures) { return (\n        { FAIL: (\"No feature for script \" + (query.script))}\n    ); }\n    if (!scriptFeatures.tags[query.tag]) { return null; }\n    return this.features[query.script].tags[query.tag];\n};\n\n/**\n * Arabic word context checkers\n */\n\nfunction arabicWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? arabic first char\n        (prevChar === null && isArabicChar(char)) ||\n        // ? arabic char preceded with a non arabic char\n        (!isArabicChar(prevChar) && isArabicChar(char))\n    );\n}\n\nfunction arabicWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last arabic char\n        (nextChar === null) ||\n        // ? next char is not arabic\n        (!isArabicChar(nextChar))\n    );\n}\n\nvar arabicWordCheck = {\n    startCheck: arabicWordStartCheck,\n    endCheck: arabicWordEndCheck\n};\n\n/**\n * Arabic sentence context checkers\n */\n\nfunction arabicSentenceStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? an arabic char preceded with a non arabic char\n        (isArabicChar(char) || isTashkeelArabicChar(char)) &&\n        !isArabicChar(prevChar)\n    );\n}\n\nfunction arabicSentenceEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    switch (true) {\n        case nextChar === null:\n            return true;\n        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):\n            var nextIsWhitespace = isWhiteSpace(nextChar);\n            if (!nextIsWhitespace) { return true; }\n            if (nextIsWhitespace) {\n                var arabicCharAhead = false;\n                arabicCharAhead = (\n                    contextParams.lookahead.some(\n                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }\n                    )\n                );\n                if (!arabicCharAhead) { return true; }\n            }\n            break;\n        default:\n            return false;\n    }\n}\n\nvar arabicSentenceCheck = {\n    startCheck: arabicSentenceStartCheck,\n    endCheck: arabicSentenceEndCheck\n};\n\n/**\n * Apply single substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat1$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply single substitution format 2\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat2$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply chaining context substitution format 3\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction chainingSubstitutionFormat3$1(action, tokens, index) {\n    action.substitution.forEach(function (subst, offset) {\n        var token = tokens[index + offset];\n        token.setState(action.tag, subst);\n    });\n}\n\n/**\n * Apply ligature substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction ligatureSubstitutionFormat1$1(action, tokens, index) {\n    var token = tokens[index];\n    token.setState(action.tag, action.substitution.ligGlyph);\n    var compsCount = action.substitution.components.length;\n    for (var i = 0; i < compsCount; i++) {\n        token = tokens[index + i + 1];\n        token.setState('deleted', true);\n    }\n}\n\n/**\n * Supported substitutions\n */\nvar SUBSTITUTIONS = {\n    11: singleSubstitutionFormat1$1,\n    12: singleSubstitutionFormat2$1,\n    63: chainingSubstitutionFormat3$1,\n    41: ligatureSubstitutionFormat1$1\n};\n\n/**\n * Apply substitutions to a list of tokens\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction applySubstitution(action, tokens, index) {\n    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n        SUBSTITUTIONS[action.id](action, tokens, index);\n    }\n}\n\n/**\n * Apply Arabic presentation forms to a range of tokens\n */\n\n/**\n * Check if a char can be connected to it's preceding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectPrev(charContextParams) {\n    var backtrack = [].concat(charContextParams.backtrack);\n    for (var i = backtrack.length - 1; i >= 0; i--) {\n        var prevChar = backtrack[i];\n        var isolated = isIsolatedArabicChar(prevChar);\n        var tashkeel = isTashkeelArabicChar(prevChar);\n        if (!isolated && !tashkeel) { return true; }\n        if (isolated) { return false; }\n    }\n    return false;\n}\n\n/**\n * Check if a char can be connected to it's proceeding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectNext(charContextParams) {\n    if (isIsolatedArabicChar(charContextParams.current)) { return false; }\n    for (var i = 0; i < charContextParams.lookahead.length; i++) {\n        var nextChar = charContextParams.lookahead[i];\n        var tashkeel = isTashkeelArabicChar(nextChar);\n        if (!tashkeel) { return true; }\n    }\n    return false;\n}\n\n/**\n * Apply arabic presentation forms to a list of tokens\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicPresentationForms(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tags = this.featuresTags[script];\n    var tokens = this.tokenizer.getRangeTokens(range);\n    if (tokens.length === 1) { return; }\n    var contextParams = new ContextParams(\n        tokens.map(function (token) { return token.getState('glyphIndex'); }\n    ), 0);\n    var charContextParams = new ContextParams(\n        tokens.map(function (token) { return token.char; }\n    ), 0);\n    tokens.forEach(function (token, index) {\n        if (isTashkeelArabicChar(token.char)) { return; }\n        contextParams.setCurrentIndex(index);\n        charContextParams.setCurrentIndex(index);\n        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)\n        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }\n        if (willConnectNext(charContextParams)) { CONNECT |= 2; }\n        var tag;\n        switch (CONNECT) {\n            case 1: (tag = 'fina'); break;\n            case 2: (tag = 'init'); break;\n            case 3: (tag = 'medi'); break;\n        }\n        if (tags.indexOf(tag) === -1) { return; }\n        var substitutions = this$1.query.lookupFeature({\n            tag: tag, script: script, contextParams: contextParams\n        });\n        if (substitutions instanceof Error) { return console.info(substitutions.message); }\n        substitutions.forEach(function (action, index) {\n            if (action instanceof SubstitutionAction) {\n                applySubstitution(action, tokens, index);\n                contextParams.context[index] = action.substitution;\n            }\n        });\n    });\n}\n\n/**\n * Apply Arabic required ligatures feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicRequiredLigatures(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'rlig', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams(tokens);\n        }\n    });\n}\n\n/**\n * Latin word context checkers\n */\n\nfunction latinWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? latin first char\n        (prevChar === null && isLatinChar(char)) ||\n        // ? latin char preceded with a non latin char\n        (!isLatinChar(prevChar) && isLatinChar(char))\n    );\n}\n\nfunction latinWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last latin char\n        (nextChar === null) ||\n        // ? next char is not latin\n        (!isLatinChar(nextChar))\n    );\n}\n\nvar latinWordCheck = {\n    startCheck: latinWordStartCheck,\n    endCheck: latinWordEndCheck\n};\n\n/**\n * Apply Latin ligature feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams$1(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction latinLigature(range) {\n    var this$1 = this;\n\n    var script = 'latn';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams$1(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'liga', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams$1(tokens);\n        }\n    });\n}\n\n/**\n * Infer bidirectional properties for a given text and apply\n * the corresponding layout rules.\n */\n\n/**\n * Create Bidi. features\n * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n */\nfunction Bidi(baseDir) {\n    this.baseDir = baseDir || 'ltr';\n    this.tokenizer = new Tokenizer();\n    this.featuresTags = {};\n}\n\n/**\n * Sets Bidi text\n * @param {string} text a text input\n */\nBidi.prototype.setText = function (text) {\n    this.text = text;\n};\n\n/**\n * Store essential context checks:\n * arabic word check for applying gsub features\n * arabic sentence check for adjusting arabic layout\n */\nBidi.prototype.contextChecks = ({\n    latinWordCheck: latinWordCheck,\n    arabicWordCheck: arabicWordCheck,\n    arabicSentenceCheck: arabicSentenceCheck\n});\n\n/**\n * Register arabic word check\n */\nfunction registerContextChecker(checkId) {\n    var check = this.contextChecks[(checkId + \"Check\")];\n    return this.tokenizer.registerContextChecker(\n        checkId, check.startCheck, check.endCheck\n    );\n}\n\n/**\n * Perform pre tokenization procedure then\n * tokenize text input\n */\nfunction tokenizeText() {\n    registerContextChecker.call(this, 'latinWord');\n    registerContextChecker.call(this, 'arabicWord');\n    registerContextChecker.call(this, 'arabicSentence');\n    return this.tokenizer.tokenize(this.text);\n}\n\n/**\n * Reverse arabic sentence layout\n * TODO: check base dir before applying adjustments - priority low\n */\nfunction reverseArabicSentences() {\n    var this$1 = this;\n\n    var ranges = this.tokenizer.getContextRanges('arabicSentence');\n    ranges.forEach(function (range) {\n        var rangeTokens = this$1.tokenizer.getRangeTokens(range);\n        this$1.tokenizer.replaceRange(\n            range.startIndex,\n            range.endOffset,\n            rangeTokens.reverse()\n        );\n    });\n}\n\n/**\n * Register supported features tags\n * @param {script} script script tag\n * @param {Array} tags features tags list\n */\nBidi.prototype.registerFeatures = function (script, tags) {\n    var this$1 = this;\n\n    var supportedTags = tags.filter(\n        function (tag) { return this$1.query.supports({script: script, tag: tag}); }\n    );\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        this.featuresTags[script] = supportedTags;\n    } else {\n        this.featuresTags[script] =\n        this.featuresTags[script].concat(supportedTags);\n    }\n};\n\n/**\n * Apply GSUB features\n * @param {Array} tagsList a list of features tags\n * @param {string} script a script tag\n * @param {Font} font opentype font instance\n */\nBidi.prototype.applyFeatures = function (font, features) {\n    if (!font) { throw new Error(\n        'No valid font was provided to apply features'\n    ); }\n    if (!this.query) { this.query = new FeatureQuery(font); }\n    for (var f = 0; f < features.length; f++) {\n        var feature = features[f];\n        if (!this.query.supports({script: feature.script})) { continue; }\n        this.registerFeatures(feature.script, feature.tags);\n    }\n};\n\n/**\n * Register a state modifier\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a modifier function to set token state\n */\nBidi.prototype.registerModifier = function (modifierId, condition, modifier) {\n    this.tokenizer.registerModifier(modifierId, condition, modifier);\n};\n\n/**\n * Check if 'glyphIndex' is registered\n */\nfunction checkGlyphIndexStatus() {\n    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {\n        throw new Error(\n            'glyphIndex modifier is required to apply ' +\n            'arabic presentation features.'\n        );\n    }\n}\n\n/**\n * Apply arabic presentation forms features\n */\nfunction applyArabicPresentationForms() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicPresentationForms.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyArabicRequireLigatures() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('rlig') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicRequiredLigatures.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyLatinLigatures() {\n    var this$1 = this;\n\n    var script = 'latn';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('liga') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('latinWord');\n    ranges.forEach(function (range) {\n        latinLigature.call(this$1, range);\n    });\n}\n\n/**\n * Check if a context is registered\n * @param {string} contextId context id\n */\nBidi.prototype.checkContextReady = function (contextId) {\n    return !!this.tokenizer.getContext(contextId);\n};\n\n/**\n * Apply features to registered contexts\n */\nBidi.prototype.applyFeaturesToContexts = function () {\n    if (this.checkContextReady('arabicWord')) {\n        applyArabicPresentationForms.call(this);\n        applyArabicRequireLigatures.call(this);\n    }\n    if (this.checkContextReady('latinWord')) {\n        applyLatinLigatures.call(this);\n    }\n    if (this.checkContextReady('arabicSentence')) {\n        reverseArabicSentences.call(this);\n    }\n};\n\n/**\n * process text input\n * @param {string} text an input text\n */\nBidi.prototype.processText = function(text) {\n    if (!this.text || this.text !== text) {\n        this.setText(text);\n        tokenizeText.call(this);\n        this.applyFeaturesToContexts();\n    }\n};\n\n/**\n * Process a string of text to identify and adjust\n * bidirectional text entities.\n * @param {string} text input text\n */\nBidi.prototype.getBidiText = function (text) {\n    this.processText(text);\n    return this.tokenizer.getText();\n};\n\n/**\n * Get the current state index of each token\n * @param {text} text an input text\n */\nBidi.prototype.getTextGlyphs = function (text) {\n    this.processText(text);\n    var indexes = [];\n    for (var i = 0; i < this.tokenizer.tokens.length; i++) {\n        var token = this.tokenizer.tokens[i];\n        if (token.state.deleted) { continue; }\n        var index = token.activeState.value;\n        indexes.push(Array.isArray(index) ? index[0] : index);\n    }\n    return indexes;\n};\n\n// The Font object\n\n/**\n * @typedef FontOptions\n * @type Object\n * @property {Boolean} empty - whether to create a new empty font\n * @property {string} familyName\n * @property {string} styleName\n * @property {string=} fullName\n * @property {string=} postScriptName\n * @property {string=} designer\n * @property {string=} designerURL\n * @property {string=} manufacturer\n * @property {string=} manufacturerURL\n * @property {string=} license\n * @property {string=} licenseURL\n * @property {string=} version\n * @property {string=} description\n * @property {string=} copyright\n * @property {string=} trademark\n * @property {Number} unitsPerEm\n * @property {Number} ascender\n * @property {Number} descender\n * @property {Number} createdTimestamp\n * @property {string=} weightClass\n * @property {string=} widthClass\n * @property {string=} fsSelection\n */\n\n/**\n * A Font represents a loaded OpenType font file.\n * It contains a set of glyphs and methods to draw text on a drawing context,\n * or to get a path representing the text.\n * @exports opentype.Font\n * @class\n * @param {FontOptions}\n * @constructor\n */\nfunction Font(options) {\n    options = options || {};\n    options.tables = options.tables || {};\n\n    if (!options.empty) {\n        // Check that we've provided the minimum set of names.\n        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');\n        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');\n        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');\n        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');\n        checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.');\n\n        // OS X will complain if the names are empty, so we put a single space everywhere by default.\n        this.names = {\n            fontFamily: {en: options.familyName || ' '},\n            fontSubfamily: {en: options.styleName || ' '},\n            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},\n            // postScriptName may not contain any whitespace\n            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\\s/g, '')},\n            designer: {en: options.designer || ' '},\n            designerURL: {en: options.designerURL || ' '},\n            manufacturer: {en: options.manufacturer || ' '},\n            manufacturerURL: {en: options.manufacturerURL || ' '},\n            license: {en: options.license || ' '},\n            licenseURL: {en: options.licenseURL || ' '},\n            version: {en: options.version || 'Version 0.1'},\n            description: {en: options.description || ' '},\n            copyright: {en: options.copyright || ' '},\n            trademark: {en: options.trademark || ' '}\n        };\n        this.unitsPerEm = options.unitsPerEm || 1000;\n        this.ascender = options.ascender;\n        this.descender = options.descender;\n        this.createdTimestamp = options.createdTimestamp;\n        this.tables = Object.assign(options.tables, {\n            os2: Object.assign({\n                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,\n            }, options.tables.os2)\n        });\n    }\n\n    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n    this.encoding = new DefaultEncoding(this);\n    this.position = new Position(this);\n    this.substitution = new Substitution(this);\n    this.tables = this.tables || {};\n\n    // needed for low memory mode only.\n    this._push = null;\n    this._hmtxTableData = {};\n\n    Object.defineProperty(this, 'hinting', {\n        get: function() {\n            if (this._hinting) { return this._hinting; }\n            if (this.outlinesFormat === 'truetype') {\n                return (this._hinting = new Hinting(this));\n            }\n        }\n    });\n}\n\n/**\n * Check if the font has a glyph for the given character.\n * @param  {string}\n * @return {Boolean}\n */\nFont.prototype.hasChar = function(c) {\n    return this.encoding.charToGlyphIndex(c) !== null;\n};\n\n/**\n * Convert the given character to a single glyph index.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.charToGlyphIndex = function(s) {\n    return this.encoding.charToGlyphIndex(s);\n};\n\n/**\n * Convert the given character to a single Glyph object.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.charToGlyph = function(c) {\n    var glyphIndex = this.charToGlyphIndex(c);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * Update features\n * @param {any} options features options\n */\nFont.prototype.updateFeatures = function (options) {\n    // TODO: update all features options not only 'latn'.\n    return this.defaultRenderOptions.features.map(function (feature) {\n        if (feature.script === 'latn') {\n            return {\n                script: 'latn',\n                tags: feature.tags.filter(function (tag) { return options[tag]; })\n            };\n        } else {\n            return feature;\n        }\n    });\n};\n\n/**\n * Convert the given text to a list of Glyph objects.\n * Note that there is no strict one-to-one mapping between characters and\n * glyphs, so the list of returned glyphs can be larger or smaller than the\n * length of the given string.\n * @param  {string}\n * @param  {GlyphRenderOptions} [options]\n * @return {opentype.Glyph[]}\n */\nFont.prototype.stringToGlyphs = function(s, options) {\n    var this$1 = this;\n\n\n    var bidi = new Bidi();\n\n    // Create and register 'glyphIndex' state modifier\n    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };\n    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);\n\n    // roll-back to default features\n    var features = options ?\n    this.updateFeatures(options.features) :\n    this.defaultRenderOptions.features;\n\n    bidi.applyFeatures(this, features);\n\n    var indexes = bidi.getTextGlyphs(s);\n\n    var length = indexes.length;\n\n    // convert glyph indexes to glyph objects\n    var glyphs = new Array(length);\n    var notdef = this.glyphs.get(0);\n    for (var i = 0; i < length; i += 1) {\n        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n    }\n    return glyphs;\n};\n\n/**\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.nameToGlyphIndex = function(name) {\n    return this.glyphNames.nameToGlyphIndex(name);\n};\n\n/**\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.nameToGlyph = function(name) {\n    var glyphIndex = this.nameToGlyphIndex(name);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * @param  {Number}\n * @return {String}\n */\nFont.prototype.glyphIndexToName = function(gid) {\n    if (!this.glyphNames.glyphIndexToName) {\n        return '';\n    }\n\n    return this.glyphNames.glyphIndexToName(gid);\n};\n\n/**\n * Retrieve the value of the kerning pair between the left glyph (or its index)\n * and the right glyph (or its index). If no kerning pair is found, return 0.\n * The kerning value gets added to the advance width when calculating the spacing\n * between glyphs.\n * For GPOS kerning, this method uses the default script and language, which covers\n * most use cases. To have greater control, use font.position.getKerningValue .\n * @param  {opentype.Glyph} leftGlyph\n * @param  {opentype.Glyph} rightGlyph\n * @return {Number}\n */\nFont.prototype.getKerningValue = function(leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph;\n    rightGlyph = rightGlyph.index || rightGlyph;\n    var gposKerning = this.position.defaultKerningTables;\n    if (gposKerning) {\n        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);\n    }\n    // \"kern\" table\n    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n};\n\n/**\n * @typedef GlyphRenderOptions\n * @type Object\n * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n * @property {string} [language='dflt'] - language system used to determine which features to apply.\n *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n * @property {boolean} [kerning=true] - whether to include kerning values\n * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n */\nFont.prototype.defaultRenderOptions = {\n    kerning: true,\n    features: [\n        /**\n         * these 4 features are required to render Arabic text properly\n         * and shouldn't be turned off when rendering arabic text.\n         */\n        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },\n        { script: 'latn', tags: ['liga', 'rlig'] }\n    ]\n};\n\n/**\n * Helper function that invokes the given callback for each glyph in the given text.\n * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n * @param {string} text - The text to apply.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @param  {Function} callback\n */\nFont.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    options = Object.assign({}, this.defaultRenderOptions, options);\n    var fontScale = 1 / this.unitsPerEm * fontSize;\n    var glyphs = this.stringToGlyphs(text, options);\n    var kerningLookups;\n    if (options.kerning) {\n        var script = options.script || this.position.getDefaultScriptName();\n        kerningLookups = this.position.getKerningTables(script, options.language);\n    }\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs[i];\n        callback.call(this, glyph, x, y, fontSize, options);\n        if (glyph.advanceWidth) {\n            x += glyph.advanceWidth * fontScale;\n        }\n\n        if (options.kerning && i < glyphs.length - 1) {\n            // We should apply position adjustment lookups in a more generic way.\n            // Here we only use the xAdvance value.\n            var kerningValue = kerningLookups ?\n                  this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :\n                  this.getKerningValue(glyph, glyphs[i + 1]);\n            x += kerningValue * fontScale;\n        }\n\n        if (options.letterSpacing) {\n            x += options.letterSpacing * fontSize;\n        } else if (options.tracking) {\n            x += (options.tracking / 1000) * fontSize;\n        }\n    }\n    return x;\n};\n\n/**\n * Create a Path object that represents the given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path}\n */\nFont.prototype.getPath = function(text, x, y, fontSize, options) {\n    var fullPath = new Path();\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        fullPath.extend(glyphPath);\n    });\n    return fullPath;\n};\n\n/**\n * Create an array of Path objects that represent the glyphs of a given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path[]}\n */\nFont.prototype.getPaths = function(text, x, y, fontSize, options) {\n    var glyphPaths = [];\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        glyphPaths.push(glyphPath);\n    });\n\n    return glyphPaths;\n};\n\n/**\n * Returns the advance width of a text.\n *\n * This is something different than Path.getBoundingBox() as for example a\n * suffixed whitespace increases the advanceWidth but not the bounding box\n * or an overhanging letter like a calligraphic 'f' might have a quite larger\n * bounding box than its advance width.\n *\n * This corresponds to canvas2dContext.measureText(text).width\n *\n * @param  {string} text - The text to create.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return advance width\n */\nFont.prototype.getAdvanceWidth = function(text, fontSize, options) {\n    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});\n};\n\n/**\n * Draw the text on the given drawing context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n */\nFont.prototype.draw = function(ctx, text, x, y, fontSize, options) {\n    this.getPath(text, x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of all glyphs in the text.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawPoints(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * Draw lines indicating important font measurements for all glyphs in the text.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawMetrics(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * @param  {string}\n * @return {string}\n */\nFont.prototype.getEnglishName = function(name) {\n    var translations = this.names[name];\n    if (translations) {\n        return translations.en;\n    }\n};\n\n/**\n * Validate\n */\nFont.prototype.validate = function() {\n    var _this = this;\n\n    function assert(predicate, message) {\n    }\n\n    function assertNamePresent(name) {\n        var englishName = _this.getEnglishName(name);\n        assert(englishName && englishName.trim().length > 0);\n    }\n\n    // Identification information\n    assertNamePresent('fontFamily');\n    assertNamePresent('weightName');\n    assertNamePresent('manufacturer');\n    assertNamePresent('copyright');\n    assertNamePresent('version');\n\n    // Dimension information\n    assert(this.unitsPerEm > 0);\n};\n\n/**\n * Convert the font object to a SFNT data structure.\n * This structure contains all the necessary tables and metadata to create a binary OTF file.\n * @return {opentype.Table}\n */\nFont.prototype.toTables = function() {\n    return sfnt.fontToTable(this);\n};\n/**\n * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\n */\nFont.prototype.toBuffer = function() {\n    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');\n    return this.toArrayBuffer();\n};\n/**\n * Converts a `opentype.Font` into an `ArrayBuffer`\n * @return {ArrayBuffer}\n */\nFont.prototype.toArrayBuffer = function() {\n    var sfntTable = this.toTables();\n    var bytes = sfntTable.encode();\n    var buffer = new ArrayBuffer(bytes.length);\n    var intArray = new Uint8Array(buffer);\n    for (var i = 0; i < bytes.length; i++) {\n        intArray[i] = bytes[i];\n    }\n\n    return buffer;\n};\n\n/**\n * Initiate a download of the OpenType font.\n */\nFont.prototype.download = function(fileName) {\n    var familyName = this.getEnglishName('fontFamily');\n    var styleName = this.getEnglishName('fontSubfamily');\n    fileName = fileName || familyName.replace(/\\s/g, '') + '-' + styleName + '.otf';\n    var arrayBuffer = this.toArrayBuffer();\n\n    if (isBrowser()) {\n        window.URL = window.URL || window.webkitURL;\n\n        if (window.URL) {\n            var dataView = new DataView(arrayBuffer);\n            var blob = new Blob([dataView], {type: 'font/opentype'});\n\n            var link = document.createElement('a');\n            link.href = window.URL.createObjectURL(blob);\n            link.download = fileName;\n\n            var event = document.createEvent('MouseEvents');\n            event.initEvent('click', true, false);\n            link.dispatchEvent(event);\n        } else {\n            console.warn('Font file could not be downloaded. Try using a different browser.');\n        }\n    } else {\n        var fs = require('fs');\n        var buffer = arrayBufferToNodeBuffer(arrayBuffer);\n        fs.writeFileSync(fileName, buffer);\n    }\n};\n/**\n * @private\n */\nFont.prototype.fsSelectionValues = {\n    ITALIC:              0x001, //1\n    UNDERSCORE:          0x002, //2\n    NEGATIVE:            0x004, //4\n    OUTLINED:            0x008, //8\n    STRIKEOUT:           0x010, //16\n    BOLD:                0x020, //32\n    REGULAR:             0x040, //64\n    USER_TYPO_METRICS:   0x080, //128\n    WWS:                 0x100, //256\n    OBLIQUE:             0x200  //512\n};\n\n/**\n * @private\n */\nFont.prototype.usWidthClasses = {\n    ULTRA_CONDENSED: 1,\n    EXTRA_CONDENSED: 2,\n    CONDENSED: 3,\n    SEMI_CONDENSED: 4,\n    MEDIUM: 5,\n    SEMI_EXPANDED: 6,\n    EXPANDED: 7,\n    EXTRA_EXPANDED: 8,\n    ULTRA_EXPANDED: 9\n};\n\n/**\n * @private\n */\nFont.prototype.usWeightClasses = {\n    THIN: 100,\n    EXTRA_LIGHT: 200,\n    LIGHT: 300,\n    NORMAL: 400,\n    MEDIUM: 500,\n    SEMI_BOLD: 600,\n    BOLD: 700,\n    EXTRA_BOLD: 800,\n    BLACK:    900\n};\n\n// The `fvar` table stores font variation axes and instances.\n\nfunction addName(name, names) {\n    var nameString = JSON.stringify(name);\n    var nameID = 256;\n    for (var nameKey in names) {\n        var n = parseInt(nameKey);\n        if (!n || n < 256) {\n            continue;\n        }\n\n        if (JSON.stringify(names[nameKey]) === nameString) {\n            return n;\n        }\n\n        if (nameID <= n) {\n            nameID = n + 1;\n        }\n    }\n\n    names[nameID] = name;\n    return nameID;\n}\n\nfunction makeFvarAxis(n, axis, names) {\n    var nameID = addName(axis.name, names);\n    return [\n        {name: 'tag_' + n, type: 'TAG', value: axis.tag},\n        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},\n        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},\n        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},\n        {name: 'flags_' + n, type: 'USHORT', value: 0},\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID}\n    ];\n}\n\nfunction parseFvarAxis(data, start, names) {\n    var axis = {};\n    var p = new parse.Parser(data, start);\n    axis.tag = p.parseTag();\n    axis.minValue = p.parseFixed();\n    axis.defaultValue = p.parseFixed();\n    axis.maxValue = p.parseFixed();\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n    axis.name = names[p.parseUShort()] || {};\n    return axis;\n}\n\nfunction makeFvarInstance(n, inst, axes, names) {\n    var nameID = addName(inst.name, names);\n    var fields = [\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID},\n        {name: 'flags_' + n, type: 'USHORT', value: 0}\n    ];\n\n    for (var i = 0; i < axes.length; ++i) {\n        var axisTag = axes[i].tag;\n        fields.push({\n            name: 'axis_' + n + ' ' + axisTag,\n            type: 'FIXED',\n            value: inst.coordinates[axisTag] << 16\n        });\n    }\n\n    return fields;\n}\n\nfunction parseFvarInstance(data, start, axes, names) {\n    var inst = {};\n    var p = new parse.Parser(data, start);\n    inst.name = names[p.parseUShort()] || {};\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n\n    inst.coordinates = {};\n    for (var i = 0; i < axes.length; ++i) {\n        inst.coordinates[axes[i].tag] = p.parseFixed();\n    }\n\n    return inst;\n}\n\nfunction makeFvarTable(fvar, names) {\n    var result = new table.Table('fvar', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'offsetToData', type: 'USHORT', value: 0},\n        {name: 'countSizePairs', type: 'USHORT', value: 2},\n        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},\n        {name: 'axisSize', type: 'USHORT', value: 20},\n        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},\n        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}\n    ]);\n    result.offsetToData = result.sizeOf();\n\n    for (var i = 0; i < fvar.axes.length; i++) {\n        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));\n    }\n\n    for (var j = 0; j < fvar.instances.length; j++) {\n        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));\n    }\n\n    return result;\n}\n\nfunction parseFvarTable(data, start, names) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');\n    var offsetToData = p.parseOffset16();\n    // Skip countSizePairs.\n    p.skip('uShort', 1);\n    var axisCount = p.parseUShort();\n    var axisSize = p.parseUShort();\n    var instanceCount = p.parseUShort();\n    var instanceSize = p.parseUShort();\n\n    var axes = [];\n    for (var i = 0; i < axisCount; i++) {\n        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));\n    }\n\n    var instances = [];\n    var instanceStart = start + offsetToData + axisCount * axisSize;\n    for (var j = 0; j < instanceCount; j++) {\n        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));\n    }\n\n    return {axes: axes, instances: instances};\n}\n\nvar fvar = { make: makeFvarTable, parse: parseFvarTable };\n\n// The `GDEF` table contains various glyph properties\n\nvar attachList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))\n    };\n};\n\nvar caretValue = function() {\n    var format = this.parseUShort();\n    check.argument(format === 1 || format === 2 || format === 3,\n        'Unsupported CaretValue table version.');\n    if (format === 1) {\n        return { coordinate: this.parseShort() };\n    } else if (format === 2) {\n        return { pointindex: this.parseShort() };\n    } else if (format === 3) {\n        // Device / Variation Index tables unsupported\n        return { coordinate: this.parseShort() };\n    }\n};\n\nvar ligGlyph = function() {\n    return this.parseList(Parser.pointer(caretValue));\n};\n\nvar ligCaretList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))\n    };\n};\n\nvar markGlyphSets = function() {\n    this.parseUShort(); // Version\n    return this.parseList(Parser.pointer(Parser.coverage));\n};\n\nfunction parseGDEFTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,\n        'Unsupported GDEF table version.');\n    var gdef = {\n        version: tableVersion,\n        classDef: p.parsePointer(Parser.classDef),\n        attachList: p.parsePointer(attachList),\n        ligCaretList: p.parsePointer(ligCaretList),\n        markAttachClassDef: p.parsePointer(Parser.classDef)\n    };\n    if (tableVersion >= 1.2) {\n        gdef.markGlyphSets = p.parsePointer(markGlyphSets);\n    }\n    return gdef;\n}\nvar gdef = { parse: parseGDEFTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\nvar subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n// this = Parser instance\nsubtableParsers$1[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var posformat = this.parseUShort();\n    if (posformat === 1) {\n        return {\n            posFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            value: this.parseValueRecord()\n        };\n    } else if (posformat === 2) {\n        return {\n            posFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            values: this.parseValueRecordList()\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');\n};\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\nsubtableParsers$1[2] = function parseLookup2() {\n    var start = this.offset + this.relativeOffset;\n    var posFormat = this.parseUShort();\n    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');\n    var coverage = this.parsePointer(Parser.coverage);\n    var valueFormat1 = this.parseUShort();\n    var valueFormat2 = this.parseUShort();\n    if (posFormat === 1) {\n        // Adjustments for Glyph Pairs\n        return {\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            pairSets: this.parseList(Parser.pointer(Parser.list(function() {\n                return {        // pairValueRecord\n                    secondGlyph: this.parseUShort(),\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            })))\n        };\n    } else if (posFormat === 2) {\n        var classDef1 = this.parsePointer(Parser.classDef);\n        var classDef2 = this.parsePointer(Parser.classDef);\n        var class1Count = this.parseUShort();\n        var class2Count = this.parseUShort();\n        return {\n            // Class Pair Adjustment\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            classDef1: classDef1,\n            classDef2: classDef2,\n            class1Count: class1Count,\n            class2Count: class2Count,\n            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {\n                return {\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            }))\n        };\n    }\n};\n\nsubtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };\nsubtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };\nsubtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };\nsubtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };\nsubtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };\nsubtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };\nsubtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\nfunction parseGposTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);\n\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n\n}\n\n// GPOS Writing //////////////////////////////////////////////\n// NOT SUPPORTED\nvar subtableMakers$1 = new Array(10);\n\nfunction makeGposTable(gpos) {\n    return new table.Table('GPOS', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},\n        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},\n        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}\n    ]);\n}\n\nvar gpos = { parse: parseGposTable, make: makeGposTable };\n\n// The `kern` table contains kerning pairs.\n\nfunction parseWindowsKernTable(p) {\n    var pairs = {};\n    // Skip nTables.\n    p.skip('uShort');\n    var subtableVersion = p.parseUShort();\n    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n    // Skip subtableLength, subtableCoverage\n    p.skip('uShort', 2);\n    var nPairs = p.parseUShort();\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n    for (var i = 0; i < nPairs; i += 1) {\n        var leftIndex = p.parseUShort();\n        var rightIndex = p.parseUShort();\n        var value = p.parseShort();\n        pairs[leftIndex + ',' + rightIndex] = value;\n    }\n    return pairs;\n}\n\nfunction parseMacKernTable(p) {\n    var pairs = {};\n    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n    // Skip the rest.\n    p.skip('uShort');\n    var nTables = p.parseULong();\n    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n    if (nTables > 1) {\n        console.warn('Only the first kern subtable is supported.');\n    }\n    p.skip('uLong');\n    var coverage = p.parseUShort();\n    var subtableVersion = coverage & 0xFF;\n    p.skip('uShort');\n    if (subtableVersion === 0) {\n        var nPairs = p.parseUShort();\n        // Skip searchRange, entrySelector, rangeShift.\n        p.skip('uShort', 3);\n        for (var i = 0; i < nPairs; i += 1) {\n            var leftIndex = p.parseUShort();\n            var rightIndex = p.parseUShort();\n            var value = p.parseShort();\n            pairs[leftIndex + ',' + rightIndex] = value;\n        }\n    }\n    return pairs;\n}\n\n// Parse the `kern` table which contains kerning pairs.\nfunction parseKernTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseUShort();\n    if (tableVersion === 0) {\n        return parseWindowsKernTable(p);\n    } else if (tableVersion === 1) {\n        return parseMacKernTable(p);\n    } else {\n        throw new Error('Unsupported kern table version (' + tableVersion + ').');\n    }\n}\n\nvar kern = { parse: parseKernTable };\n\n// The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n// relative to the beginning of the glyphData table.\n// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n// version where offsets are stored as uLongs. The `head` table specifies which version to use\n// (under indexToLocFormat).\nfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n    var p = new parse.Parser(data, start);\n    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    var glyphOffsets = [];\n    for (var i = 0; i < numGlyphs + 1; i += 1) {\n        var glyphOffset = parseFn.call(p);\n        if (shortVersion) {\n            // The short table version stores the actual offset divided by 2.\n            glyphOffset *= 2;\n        }\n\n        glyphOffsets.push(glyphOffset);\n    }\n\n    return glyphOffsets;\n}\n\nvar loca = { parse: parseLocaTable };\n\n// opentype.js\n\n/**\n * The opentype library.\n * @namespace opentype\n */\n\n// File loaders /////////////////////////////////////////////////////////\n/**\n * Loads a font from a file. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} path - The path of the file\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromFile(path, callback) {\n    var fs = require('fs');\n    fs.readFile(path, function(err, buffer) {\n        if (err) {\n            return callback(err.message);\n        }\n\n        callback(null, nodeBufferToArrayBuffer(buffer));\n    });\n}\n/**\n * Loads a font from a URL. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} url - The URL of the font file.\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromUrl(url, callback) {\n    var request = new XMLHttpRequest();\n    request.open('get', url, true);\n    request.responseType = 'arraybuffer';\n    request.onload = function() {\n        if (request.response) {\n            return callback(null, request.response);\n        } else {\n            return callback('Font could not be loaded: ' + request.statusText);\n        }\n    };\n\n    request.onerror = function () {\n        callback('Font could not be loaded');\n    };\n\n    request.send();\n}\n\n// Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseOpenTypeTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 12;\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var checksum = parse.getULong(data, p + 4);\n        var offset = parse.getULong(data, p + 8);\n        var length = parse.getULong(data, p + 12);\n        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});\n        p += 16;\n    }\n\n    return tableEntries;\n}\n\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseWOFFTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 44; // offset to the first table directory entry.\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var offset = parse.getULong(data, p + 4);\n        var compLength = parse.getULong(data, p + 8);\n        var origLength = parse.getULong(data, p + 12);\n        var compression = (void 0);\n        if (compLength < origLength) {\n            compression = 'WOFF';\n        } else {\n            compression = false;\n        }\n\n        tableEntries.push({tag: tag, offset: offset, compression: compression,\n            compressedLength: compLength, length: origLength});\n        p += 20;\n    }\n\n    return tableEntries;\n}\n\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */\n\n/**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */\nfunction uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === 'WOFF') {\n        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n        var outBuffer = new Uint8Array(tableEntry.length);\n        tinyInflate(inBuffer, outBuffer);\n        if (outBuffer.byteLength !== tableEntry.length) {\n            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\\'t match recorded length');\n        }\n\n        var view = new DataView(outBuffer.buffer, 0);\n        return {data: view, offset: 0};\n    } else {\n        return {data: data, offset: tableEntry.offset};\n    }\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @param  {Object} opt - options for parsing\n * @return {opentype.Font}\n */\nfunction parseBuffer(buffer, opt) {\n    opt = (opt === undefined || opt === null) ?  {} : opt;\n\n    var indexToLocFormat;\n    var ltagTable;\n\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    var font = new Font({empty: true});\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    var data = new DataView(buffer, 0);\n    var numTables;\n    var tableEntries = [];\n    var signature = parse.getTag(data, 0);\n    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n        font.outlinesFormat = 'truetype';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'OTTO') {\n        font.outlinesFormat = 'cff';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'wOFF') {\n        var flavor = parse.getTag(data, 4);\n        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n            font.outlinesFormat = 'truetype';\n        } else if (flavor === 'OTTO') {\n            font.outlinesFormat = 'cff';\n        } else {\n            throw new Error('Unsupported OpenType flavor ' + signature);\n        }\n\n        numTables = parse.getUShort(data, 12);\n        tableEntries = parseWOFFTableEntries(data, numTables);\n    } else {\n        throw new Error('Unsupported OpenType signature ' + signature);\n    }\n\n    var cffTableEntry;\n    var fvarTableEntry;\n    var glyfTableEntry;\n    var gdefTableEntry;\n    var gposTableEntry;\n    var gsubTableEntry;\n    var hmtxTableEntry;\n    var kernTableEntry;\n    var locaTableEntry;\n    var nameTableEntry;\n    var metaTableEntry;\n    var p;\n\n    for (var i = 0; i < numTables; i += 1) {\n        var tableEntry = tableEntries[i];\n        var table = (void 0);\n        switch (tableEntry.tag) {\n            case 'cmap':\n                table = uncompressTable(data, tableEntry);\n                font.tables.cmap = cmap.parse(table.data, table.offset);\n                font.encoding = new CmapEncoding(font.tables.cmap);\n                break;\n            case 'cvt ' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                break;\n            case 'fvar':\n                fvarTableEntry = tableEntry;\n                break;\n            case 'fpgm' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.fpgm = p.parseByteList(tableEntry.length);\n                break;\n            case 'head':\n                table = uncompressTable(data, tableEntry);\n                font.tables.head = head.parse(table.data, table.offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n            case 'hhea':\n                table = uncompressTable(data, tableEntry);\n                font.tables.hhea = hhea.parse(table.data, table.offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n            case 'hmtx':\n                hmtxTableEntry = tableEntry;\n                break;\n            case 'ltag':\n                table = uncompressTable(data, tableEntry);\n                ltagTable = ltag.parse(table.data, table.offset);\n                break;\n            case 'maxp':\n                table = uncompressTable(data, tableEntry);\n                font.tables.maxp = maxp.parse(table.data, table.offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n            case 'name':\n                nameTableEntry = tableEntry;\n                break;\n            case 'OS/2':\n                table = uncompressTable(data, tableEntry);\n                font.tables.os2 = os2.parse(table.data, table.offset);\n                break;\n            case 'post':\n                table = uncompressTable(data, tableEntry);\n                font.tables.post = post.parse(table.data, table.offset);\n                font.glyphNames = new GlyphNames(font.tables.post);\n                break;\n            case 'prep' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.prep = p.parseByteList(tableEntry.length);\n                break;\n            case 'glyf':\n                glyfTableEntry = tableEntry;\n                break;\n            case 'loca':\n                locaTableEntry = tableEntry;\n                break;\n            case 'CFF ':\n                cffTableEntry = tableEntry;\n                break;\n            case 'kern':\n                kernTableEntry = tableEntry;\n                break;\n            case 'GDEF':\n                gdefTableEntry = tableEntry;\n                break;\n            case 'GPOS':\n                gposTableEntry = tableEntry;\n                break;\n            case 'GSUB':\n                gsubTableEntry = tableEntry;\n                break;\n            case 'meta':\n                metaTableEntry = tableEntry;\n                break;\n        }\n    }\n\n    var nameTable = uncompressTable(data, nameTableEntry);\n    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);\n    font.names = font.tables.name;\n\n    if (glyfTableEntry && locaTableEntry) {\n        var shortVersion = indexToLocFormat === 0;\n        var locaTable = uncompressTable(data, locaTableEntry);\n        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n        var glyfTable = uncompressTable(data, glyfTableEntry);\n        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);\n    } else if (cffTableEntry) {\n        var cffTable = uncompressTable(data, cffTableEntry);\n        cff.parse(cffTable.data, cffTable.offset, font, opt);\n    } else {\n        throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n    }\n\n    var hmtxTable = uncompressTable(data, hmtxTableEntry);\n    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);\n    addGlyphNames(font, opt);\n\n    if (kernTableEntry) {\n        var kernTable = uncompressTable(data, kernTableEntry);\n        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n    } else {\n        font.kerningPairs = {};\n    }\n\n    if (gdefTableEntry) {\n        var gdefTable = uncompressTable(data, gdefTableEntry);\n        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);\n    }\n\n    if (gposTableEntry) {\n        var gposTable = uncompressTable(data, gposTableEntry);\n        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n        font.position.init();\n    }\n\n    if (gsubTableEntry) {\n        var gsubTable = uncompressTable(data, gsubTableEntry);\n        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n    }\n\n    if (fvarTableEntry) {\n        var fvarTable = uncompressTable(data, fvarTableEntry);\n        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n    }\n\n    if (metaTableEntry) {\n        var metaTable = uncompressTable(data, metaTableEntry);\n        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n        font.metas = font.tables.meta;\n    }\n\n    return font;\n}\n\n/**\n * Asynchronously load the font from a URL or a filesystem. When done, call the callback\n * with two arguments `(err, font)`. The `err` will be null on success,\n * the `font` is a Font object.\n * We use the node.js callback convention so that\n * opentype.js can integrate with frameworks like async.js.\n * @alias opentype.load\n * @param  {string} url - The URL of the font to load.\n * @param  {Function} callback - The callback.\n */\nfunction load(url, callback, opt) {\n    opt = (opt === undefined || opt === null) ?  {} : opt;\n    var isNode = typeof window === 'undefined';\n    var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;\n\n    return new Promise(function (resolve, reject) {\n        loadFn(url, function(err, arrayBuffer) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                } else {\n                    reject(err);\n                }\n            }\n            var font;\n            try {\n                font = parseBuffer(arrayBuffer, opt);\n            } catch (e) {\n                if (callback) {\n                    return callback(e, null);\n                } else {\n                    reject(e);\n                }\n            }\n            if (callback) {\n                return callback(null, font);\n            } else {\n                resolve(font);\n            }\n        });\n    });\n}\n\n/**\n * Synchronously load the font from a URL or file.\n * When done, returns the font object or throws an error.\n * @alias opentype.loadSync\n * @param  {string} url - The URL of the font to load.\n * @param  {Object} opt - opt.lowMemory\n * @return {opentype.Font}\n */\nfunction loadSync(url, opt) {\n    var fs = require('fs');\n    var buffer = fs.readFileSync(url);\n    return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);\n}\n\nvar opentype = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tFont: Font,\n\tGlyph: Glyph,\n\tPath: Path,\n\tBoundingBox: BoundingBox,\n\t_parse: parse,\n\tparse: parseBuffer,\n\tload: load,\n\tloadSync: loadSync\n});\n\nexport default opentype;\nexport { BoundingBox, Font, Glyph, Path, parse as _parse, load, loadSync, parseBuffer as parse };\n//# sourceMappingURL=opentype.module.js.map\n","var A,g=(A=\"file:///build/woff2-wasm.js\",function(g={}){g.ready=new Promise((A,g)=>{C=A,B=g});var C,B,I,Q,E,w,D,G,i,o,L,Y,c,h,F,s,N,K,a,R,H,k,J,Z,M=Object.assign({},g),W=(A,g)=>{throw g},d=\"\";\"undefined\"!=typeof document&&document.currentScript&&(d=document.currentScript.src),A&&(d=A),d=0!==d.indexOf(\"blob:\")?d.substr(0,d.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",g.print||console.log.bind(console);var y=g.printErr||console.error.bind(console);Object.assign(g,M),M=null,g.arguments&&g.arguments,g.thisProgram&&g.thisProgram,g.quit&&(W=g.quit),g.wasmBinary&&(Q=g.wasmBinary);var U=g.noExitRuntime||!0;\"object\"!=typeof WebAssembly&&X(\"no native wasm support detected\");var p=!1;function b(){var A=E.buffer;g.HEAP8=w=new Int8Array(A),g.HEAP16=G=new Int16Array(A),g.HEAPU8=D=new Uint8Array(A),g.HEAPU16=i=new Uint16Array(A),g.HEAP32=o=new Int32Array(A),g.HEAPU32=L=new Uint32Array(A),g.HEAPF32=Y=new Float32Array(A),g.HEAPF64=c=new Float64Array(A)}var l=[],S=[],m=[],q=0,t=null,V=null;function X(A){g.onAbort&&g.onAbort(A),y(A=\"Aborted(\"+A+\")\"),p=!0,A+=\". Build with -sASSERTIONS for more info.\";var C=new WebAssembly.RuntimeError(A);throw B(C),C}var u=\"data:application/octet-stream;base64,\";function n(A){return A.startsWith(u)}function x(A){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${A})`,this.status=A}n(h=\"data:application/octet-stream;base64,AGFzbQEAAAABnQIeYAJ/fwBgAX8Bf2ACf38Bf2ADf39/AX9gA39/fwBgAX8AYAV/f39/fwBgAABgBH9/f38AYAR/f39/AX9gBX9/f39/AX9gBn9/f39/fwBgB39/f39/f38AYAh/f39/f39/fwBgAX8BfGAJf39/f39/f39/AX9gAn9/AXxgAXwBfGAHf39/f39/fwF/YA1/f39/f39/f39/f39/AGAJf39/f39/f39/AGALf39/f39/f39/f38AYAZ/f35/f38Bf2AGf39/f39/AX9gCn9/f39/f39/f38AYAx/f39/f39/f39/f38AYA9/f39/f39/f39/f39/f38AYA1/f39/f39/f39/f39/AX9gCn9/f39/f39/f38Bf2AEf39+fgACbRIBYQFhAAQBYQFiAAYBYQFjAAwBYQFkAAQBYQFlAAQBYQFmAAQBYQFnAAABYQFoAAIBYQFpAAgBYQFqAAABYQFrAAUBYQFsAAUBYQFtAAUBYQFuAAwBYQFvAAcBYQFwAAEBYQFxAAQBYQFyAAADmQGXAQMRAwIFAQQGBgcCDQAAAwMHAw0AAAYGEg4OAgUABQAAAgEBAAkEBAAAAA8PDgwAAAIHAAoKAQEACAAJBBMICBQFBAUBAAQKBwoCCQAACgAEABUCAAYWFxgZEBAPEAgMBhobHAEFAQMEAQIdBQEDCAQCAAkFBA0CAQEHAAEFAQkDAQkDBwACBwEBAQEBCwsGBggIAwMHAQAEBQFwASoqBQcBAYACgIACBggBfwFBsMYeCwckCAFzAgABdABZAXUBAAF2ADMBdwAWAXgApwEBeQCmAQF6AJ0BCUYBAEEBCyl+lwGoAZgBSGVklgGVAUgtlAGTAZIBZWSLAUgthQGFAaUBLaQBngGgAaMBLZ8BoQGiAS2bAS2aAS2cAVSZAVRUCuCqFpcB8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALgAUDAX8HfAJ+IAC9IglCMIinIQEgCUKAgICA8JWp9z99Qv////+flYQBWARAIAlCgICAgICAgPg/UQRARAAAAAAAAAAADwtB+KcaKwMAIgMgAEQAAAAAAADwv6AiAL1CgICAgHCDvyIEoiIFIAAgAKIiAiAAQcCoGisDAKJBuKgaKwMAoKIiBqAiByACIAKiIgggCCACIABBgKkaKwMAokH4qBorAwCgoiAAQfCoGisDAKJB6KgaKwMAoKCiIAIgAEHgqBorAwCiQdioGisDAKCiIABB0KgaKwMAokHIqBorAwCgoKCiIAAgBKEgA6IgAEGAqBorAwCioCAGIAUgB6GgoKCgDwsCQCABQfD/AWtBn4B+TQRAIAC9Qv///////////wCDUARAIwBBEGsiAUQAAAAAAADwvzkDCCABKwMIRAAAAAAAAAAAow8LIAlCgICAgICAgPj/AFENASABQfD/AXFB8P8BRyABQf//AU1xRQRAIAAgAKEiACAAow8LIABEAAAAAAAAMEOivUKAgICAgICAoAN9IQkLIAlCgICAgICAgPM/fSIKQi6Ip0E/cUEEdCIBQZCpGmorAwAgCkI0h6e3oCIDQfinGisDACIEIAFBiKkaaisDACAJIApCgICAgICAgHiDfb8gAUGIsRpqKwMAoSABQZCxGmorAwChoiIAvUKAgICAcIO/IgWiIgagIgcgACAAoiICIAIgAqIgAEGwqBorAwCiQaioGisDAKCiIAIgAEGgqBorAwCiQZioGisDAKCiIABBkKgaKwMAokGIqBorAwCgoKCiIAAgBaEgBKJBgKgaKwMAIACioCAGIAMgB6GgoKCgIQALIAALgAQBA38gAkGABE8EQCAAIAEgAhAQIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0Ag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QQF0IgYgBSAFIAZJGyACQf////8DTxsiBgR/IAYQFwVBAAsiBWoiAiABOgAAIAUgBmohASACQQFqIQYCQCADIAdGBEAgAiEFDAELIAdBf3MgA2ohDCAEQQNxIgkEQEEAIQQDQCACQQFrIgIgA0EBayIDLQAAOgAAIARBAWoiBCAJRw0ACwsgDEEDTwRAA0AgAkEBayADQQFrLQAAOgAAIAJBAmsgA0ECay0AADoAACACQQNrIANBA2stAAA6AAAgAkEEayICIANBBGsiAy0AADoAACADIAdHDQALCyAAKAIAIQMLIAAgATYCCCAAIAY2AgQgACAFNgIAIAMEQCADEBYLDwsQGwALlAQBBH8gASAAIAFGIgI6AAwCQCACDQADQCABKAIIIgItAAwNAQJAIAIgAigCCCIDKAIAIgRGBEACQCADKAIEIgRFDQAgBC0ADA0ADAILAkAgASACKAIARgRAIAIhAQwBCyACIAIoAgQiASgCACIANgIEIAEgAAR/IAAgAjYCCCACKAIIBSADCzYCCCACKAIIIgAgACgCACACR0ECdGogATYCACABIAI2AgAgAiABNgIIIAEoAggiAygCACECCyABQQE6AAwgA0EAOgAMIAMgAigCBCIANgIAIAAEQCAAIAM2AggLIAIgAygCCDYCCCADKAIIIgAgACgCACADR0ECdGogAjYCACACIAM2AgQgAyACNgIIDwsCQCAERQ0AIAQtAAwNAAwBCwJAIAEgAigCAEcEQCACIQEMAQsgAiABKAIEIgA2AgAgASAABH8gACACNgIIIAIoAggFIAMLNgIIIAIoAggiACAAKAIAIAJHQQJ0aiABNgIAIAEgAjYCBCACIAE2AgggASgCCCEDCyABQQE6AAwgA0EAOgAMIAMgAygCBCIAKAIAIgE2AgQgAQRAIAEgAzYCCAsgACADKAIINgIIIAMoAggiASABKAIAIANHQQJ0aiAANgIAIAAgAzYCACADIAA2AggMAgsgBEEMaiEFIAJBAToADCADIAAgA0Y6AAwgBUEBOgAAIAMiASAARw0ACwsL6AIBAn8CQCAAIAFGDQAgASAAIAJqIgRrQQAgAkEBdGtNBEAgACABIAIQFA8LIAAgAXNBA3EhAwJAAkAgACABSQRAIAMEQCAAIQMMAwsgAEEDcUUEQCAAIQMMAgsgACEDA0AgAkUN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ASECDAELIAggAjYCDCAIIAE2AhALIAlBBUYNAwNAAkAgBCAIIABBAnQiBWoiCigCACIBai0AACACIARqLQAATwRAIAIhAQwBCyAKIAI2AgAgCCABNgIMCwJAIAQgBSAIaiIFQQRqKAIAIgJqLQAAIAEgBGotAABPBEAgASECDAELIAUgATYCBCAIIAI2AgwLIABBAmoiACAJRw0ACwsgCUECaw4CAAECCyAHIANBA3ZqIgAgADEAACAINQIAIANBB3GthoQ3AAAgBiADIAtqIgA2AgAgByAAQQN2aiIBIAExAAAgCDUCBCAAQQdxrYaENwAAIAYgACALajYCAAwCCyAHIANBA3ZqIgAgADEAACAINQIAIANBB3GthoQ3AAAgBiADIAtqIgA2AgAgByAAQQN2aiIBIAExAAAgCDUCBCAAQQdxrYaENwAAIAYgACALaiIANgIAIAcgAEEDdmoiASABMQAAIAg1AgggAEEHca2GhDcAACAGIAAgC2o2AgAMAQsgByADQQN2aiIAIAAxAAAgCCgCACIBrSADQQdxrYaENwAAIAYgAyALaiIANgIAIAcgAEEDdmoiAiACMQAAIAg1AgQgAEEHca2GhDcAACAGIAAgC2oiADYCACAHIABBA3ZqIgIgAjEAACAINQIIIABBB3GthoQ3AAAgBiAAIAtqIgA2AgAgByAAQQN2aiICIAIxAAAgCDUCDCAAQQdxrYaENwAAIAYgACALaiIANgIAIAcgAEEDdmoiAiACMQAAIAEgBGotAABBAUatIABBB3GthoQ3AAAgBiAAQQFqNgIACyAIQRBqJAAL3gIBCX8gASAAKAIIIgMgACgCBCICa00EQCAAIAEEfyACQQAgARASIAFqBSACCzYCBA8LIAIgACgCACIFayIGIAFqIgRBAE4EQEH/////ByADIAVrIgNBAXQiCCAEIAQgCEkbIANB/////wNPGyIEBEAgBBAXIQcLIAQgB2ohCCABIAYgB2oiA0EAIAEQEiIEaiEJAkAgAiAFRgRAIAQhBwwBCyAFQX9zIAJqIQogBkEDcSIGBEBBACEBA0AgA0EBayIDIAJBAWsiAi0AADoAACABQQFqIgEgBkcNAAsLIApBA08EQANAIANBAWsgAkEBay0AADoAACADQQJrIAJBAmstAAA6AAAgA0EDayACQQNrLQAAOgAAIANB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ECIDRQ0EIAZBEGohAQsDQCABIQQgAyICQRRqIgEoAgAiAw0AIAJBEGohASACKAIQIgMNAAsgBEEANgIADAQLQcjCGiAGQShrIgBBeCACa0EHcSIBayIINgIAQdTCGiABIAJqIgE2AgAgASAIQQFyNgIEIAAgAmpBKDYCBEHYwhpBpMYaKAIANgIAIAMgBEEnIARrQQdxakEvayIAIAAgA0EQakkbIgFBGzYCBCABQYTGGikCADcCECABQfzFGikCADcCCEGExhogAUEIajYCAEGAxhogBjYCAEH8xRogAjYCAEGIxhpBADYCACABQRhqIQADQCAAQQc2AgQgAEEIaiEMIABBBGohACAMIARJDQALIAEgA0YNACABIAEoAgRBfnE2AgQgAyABIANrIgJBAXI2AgQgASACNgIAIAJB/wFNBEAgAkF4cUHkwhpqIQACf0G8whooAgAiAUEBIAJBA3Z0IgJxRQRAQbzCGiABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAMgADYCHCADQgA3AhAgAEECdEHsxBpqIQECQAJAQcDCGigCACIEQQEgAHQiBnFFBEBBwMIaIAQgBnI2AgAgASADNgIADAELIAJBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhBANAIAQiASgCBEF4cSACRg0CIABBHXYhBCAAQQF0IQAgASAEQQRxaiIGKAIQIgQNAAsgBiADNgIQCyADIAE2AhggAyADNgIMIAMgAzYCCAwBCyABKAIIIgAgAzYCDCABIAM2AgggA0EANgIYIAMgATYCDCADIAA2AggLQcjCGigCACIAIAVNDQBByMIaIAAgBWsiATYCAEHUwhpB1MIaKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwIC0G4whpBMDYCAEEAIQAMBwtBACECCyAIRQ0AAkAgBigCHCIBQQJ0QezEGmoiBCgCACAGRgRAIAQgAjYCACACDQFBwMIaQcDCGigCAEF+IAF3cTYCAAwCCyAIQRBBFCAIKAIQIAZGG2ogAjYCACACRQ0BCyACIAg2AhggBigCECIBBEAgAiABNgIQIAEg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IAEgBCkDEDcCECABIAQpAwg3AgggASAEKQMANwIADAELIAUgBkkEQCAEIAApAhg3AxggBCAAKQIQNwMQIAQgACkCCDcDCCAEIAApAgA3AwAgACACKQIYNwIYIAAgAikCEDcCECAAIAIpAgg3AgggACACKQIANwIAIAIgBCkDGDcCGCACIAQpAxA3AhAgAiAEKQMINwIIIAIgBCkDADcCAEEBDAILIAQgACkCGDcDGCAEIAApAhA3AxAgBCAAKQIINwMIIAQgACkCADcDACAAIAEpAhg3AhggACABKQIQNwIQIAAgASkCCDcCCCAAIAEpAgA3AgAgASAEKQMYNwIYIAEgBCkDEDcCECABIAQpAwg3AgggASAEKQMANwIAQQEgAigCACABKAIATw0BGiAEIAEpAhg3AxggBCABKQIQNwMQIAQgASkCCDcDCCAEIAEpAgA3AwAgASACKQIYNwIYIAEgAikCEDcCECABIAIpAgg3AgggASACKQIANwIAIAIgBCkDGDcCGCACIAQpAxA3AhAgAiAEKQMINwIIIAIgBCkDADcCAAtBAgshBSADKAIAIAIoAgBJBH8gBCACKQIYNwMYIAQgAikCEDcDECAEIAIpAgg3AwggBCACKQIANwMAIAIgAykCGDcCGCACIAMpAhA3AhAgAiADKQIINwIIIAIgAykCADcCACADIAQpAxg3AhggAyAEKQMQNwIQIAMgBCkDCDcCCCADIAQpAwA3AgAgAigCACABKAIATwRAIAVBAWoPCyAEIAEpAhg3AxggBCABKQIQNwMQIAQgASkCCDcDCCAEIAEpAgA3AwAgASACKQIYNwIYIAEgAikCEDcCECABIAIpAgg3AgggASACKQIANwIAIAIgBCkDGDcCGCACIAQpAxA3AhAgAiAEKQMINwIIIAIgBCkDADcCACABKAIAIAAoAgBPBEAgBUECag8LIAQgACkCGDcDGCAEIAApAhA3AxAgBCAAKQIINwMIIAQgACkCADcDACAAIAEpAhg3AhggACABKQIQNwIQIAAgASkCCDcCCCAAIAEpAgA3AgAgASAEKQMYNwIYIAEgBCkDEDcCECABIAQpAwg3AgggASAEKQMANwIAIAVBA2oFIAULC+EBAQR/IwBBEGsiBSQAIwBBIGsiAyQAIwBBEGsiBCQAIAQgATYCDCAEIAEgAmo2Aggg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ADcCACAGIAUpAxg3AhggBiAFKQMQNwIQIAYgBSkDCDcCCCAGIAUpAwA3AgAgACgCACAEKAIATwRAIApBA2ohCgwCCyAFIAQpAhg3AxggBSAEKQIQNwMQIAUgBCkCCDcDCCAFIAQpAgA3AwAgBCAAKQIYNwIYIAQgACkCEDcCECAEIAApAgg3AgggBCAAKQIANwIAIAAgBSkDGDcCGCAAIAUpAxA3AhAgACAFKQMINwIIIAAgBSkDADcCACAKQQRqIQoMAQsgCSgCACEAAkAgBigCACIHIAQoAgBPBEBBACEKIAAgB08NAiAFIAYpAhg3AxggBSAGKQIQNwMQIAUgBikCCDcDCCAFIAYpAgA3AwAgBiAJKQIYNwIYIAYgCSkCEDcCECAGIAkpAgg3AgggBiAJKQIANwIAIAkgBSkDGDcCGCAJIAUpAxA3AhAgCSAFKQMINwIIIAkgBSkDADcCAEEBIQogBigCACAEKAIATw0CIAUgBCkCGDcDGCAFIAQpAhA3AxAgBSAEKQIINwMIIAUgBCkCADcDACAEIAYpAhg3AhggBCAGKQIQNwIQIAQgBikCCDcCCCAEIAYpAgA3AgAgBiAFKQMYNwIYIAYgBSkDEDcCECAGIAUpAwg3AgggBiAFKQMANwIADAELIAAgB0kEQCAFIAQpAhg3AxggBSAEKQIQNwMQIAUgBCkCCDcDCCAFIAQpAgA3AwAgBCAJKQIYNwIYIAQgCSkCEDcCECAEIAkpAgg3AgggBCAJKQIANwIAIAkgBSkDGDcCGCAJIAUpAxA3AhAgCSAFKQMINwIIIAkgBSkDADcCAEEBIQoMAgsgBSAEKQIYNwMYIAUgBCkCEDcDECAFIAQpAgg3AwggBSAEKQIANwMAIAQgBikCGDcCGCAEIAYpAhA3AhAgBCAGKQIINwIIIAQgBikCADcCACAGIAUpAxg3AhggBiAFKQMQNwIQIAYgBSkDCDcCCCAGIAUpAwA3AgBBASEKIAkoAgAgBigCAE8NASAFIAYpAhg3AxggBSAGKQIQNwMQIAUgBikCCDcDCCAFIAYpAgA3AwAgBiAJKQIYNwIYIAYgCSkCEDcCECAGIAkpAgg3AgggBiAJKQIANwIAIAkgBSkDGDcCGCAJIAUpAxA3AhAgCSAFKQMINwIIIAkgBSkDADcCAAtBAiEKCyADQQFrIQMgCSEA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gICAgAQhA0EAIQdBACEAA0AgAyABIAdBAnQiCWooAgAiCiADIApJGyADIAobIgMgASAJQQRyaigCACIJIAMgCUkbIAMgCRshAyAGIApBAEdqIAlBAEdqIQYgB0ECaiEHIABBAmoiACAMRw0ACwsgDQRAIAMgASAHQQJ0aigCACIAIAAgA0sbIAMgABshAyAGIABBAEdqIQYLIAZBBUkNAAJAIANBA0sNACAIIAZrQQVLDQAgBUECSQ0AQQEhBQNAAkAgBUECdCABaiIAQQRrKAIARQ0AIAAoAgANACAAKAIERQ0AIABBATYCAAsgBUEBaiIFIARHDQALCyAGQRxJDQBBACEFIAJBACAIEBIhCiABKAIAIQNBACEHA0ACQAJAIAciACAIRiICRQRAIAEgAEECdGooAgAgA0YNAQsCQCADRSIHIAVBBEtxRQRAIAcNASAFQQdJDQEgBUUNAQsgACAKaiAFa0EBIAUQEhoLQQEhBSACDQEgASAAQQJ0aigCACEDDAELIAVBAWohBQsgAEEBaiEHIAAgCEkNAAsgCEECayEFIAEoAgggASgCBCABKAIAampBCHRBA25BpANqIQdBACEDQQAhBEEAIQYDQAJAAkACQCADIgAgCEYiCQ0AIAAgCmoiAi0AAA0AIAAEQCACQQFrLQAADQELIAEgAEECdGooAgAiAkEIdCAHa0HYCWtBz2xLDQELAkAgBkEDTQRAIAZBA0cNASAEDQELQQAhB0EBIAQgBkEBdmoiAiAGbiACIAZJG0EAIAQbIQJBACEEIAZBAWtBA08EQCAGQXxxIQtBACEDA0AgASAAIARBf3NqQQJ0aiACNgIAIAEgACAEQf7///8Dc2pBAnRqIAI2AgAgASAAIARB/f///wNzakECdGogAjYCACABIAAgBEH8////A3NqQQJ0aiACNgIAIARBBGohBCADQQRqIgMgC0cNAAsLIAZBA3EiA0UNAANAIAEgACAEQX9zakECdGogAjYCACAEQQFqIQQgB0EBaiIHIANHDQALCwJ/IAAgBUkEQCABIABBAnRqIgIoAgQgAigCAGogAigCCGpBCHRBA25BpANqDAELQQAgACAITw0AGiABIABBAnRqKAIAQQh0CyEHQQAhBEEBIQYgCQ0BIAEgAEECdGooAgAhBAwBCyACIARqIQQgBkEBaiIGQQRJDQAg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Ajg3AxggAiAAKQIwNwMQIAIgACkCKDcDCCACIAApAiA3AwAgACABKQIYNwI4IAAgASkCEDcCMCAAIAEpAgg3AiggACABKQIANwIgIAEgAikDGDcCGCABIAIpAxA3AhAgASACKQMINwIIIAEgAikDADcCACAAKAIgIAAoAgBPDQQgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgACkCODcCGCAAIAApAjA3AhAgACAAKQIoNwIIIAAgACkCIDcCACAAIAIpAxg3AjggACACKQMQNwIwIAAgAikDCDcCKCAAIAIpAwA3AiAMBAsgAyAESQRAIAIgACkCGDcDGCACIAApAhA3AxAgAiAAKQIINwMIIAIgACkCADcDACAAIAEpAhg3AhggACABKQIQNwIQIAAgASkCCDcCCCAAIAEpAgA3AgAgASACKQMYNwIYIAEgAikDEDcCECABIAIpAwg3AgggASACKQMANwIADAQLIAIgACkCGDcDGCACIAApAhA3AxAgAiAAKQIINwMIIAIgACkCADcDACAAIAApAjg3AhggACAAKQIwNwIQIAAgACkCKDcCCCAAIAApAiA3AgAgACACKQMYNwI4IAAgAikDEDcCMCAAIAIpAwg3AiggACACKQMANwIgIAEoAgAgACgCIE8NAyACIAApAjg3AxggAiAAKQIwNwMQIAIgACkCKDcDCCACIAApAiA3AwAgACABKQIYNwI4IAAgASkCEDcCMCAAIAEpAgg3AiggACABKQIANwIgIAEgAikDGDcCGCABIAIpAxA3AhAgASACKQMINwIIIAEgAikDADcCAAwDCyAAIABBIGogAEFAayABQSBrEDYaDAILIAAgAEEgaiAAQUBrIgMgAEHgAGoQNhogAUEgayIBKAIAIAAoAmBPDQEgAiAAKQJ4NwMYIAIgACkCcDcDECACIAApAmg3AwggAiAAKQJgNwMAIAAgASkCGDcCeCAAIAEpAhA3AnAgACABKQIINwJoIAAgASkCADcCYCABIAIpAxg3AhggASACKQMQNwIQIAEgAikDCDcCCCABIAIpAwA3AgAgACgCYCADKAIATw0BIAIgAykCGDcDGCACIAMpAhA3AxAgAiADKQIINwMIIAIgAykCADcDACADIAApAng3AhggAyAAKQJwNwIQIAMgACkCaDcCCCADIAApAmA3AgAgACACKQMYNwJ4IAAgAikDEDcCcCAAIAIpAwg3AmggACACKQMANwJgIAMoAgAgACgCIE8NASACIAApAjg3AxggAiAAKQIwNwMQIAIgACkCKDcDCCACIAApAiA3AwAgACADKQIYNwI4IAAgAykCEDcCMCAAIAMpAgg3AiggACADKQIANwIgIAMgAikDGDcCGCADIAIpAxA3AhAgAyACKQMINwIIIAMgAikDADcCACAAKAIgIAAoAgBPDQEgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgACkCODcCGCAAIAApAjA3AhAgACAAKQIoNwIIIAAgACkCIDcCACAAIAIpAxg3AjggACACKQMQNwIwIAAgAikDCDcCKCAAIAIpAwA3AiAMAQsgAEFAayEDIAAoAkAhBAJAIAAoAiAiBiAAKAIAIgdPBEAgBCAGTw0BIAIgACkCODcDGCACIAApAjA3AxAgAiAAKQIoNwMIIAIgACkCIDcDACAAIAMpAhg3AjggACADKQIQNwIwIAAgAykCCDcCKCAAIAMpAgA3AiAgAyACKQMYNwIYIAMgAikDEDcCECADIAIpAwg3AgggAyACKQMANwIAIAAoAiAgB08NASACIAApAhg3AxggAiAAKQIQNwMQIAIgACkCCDcDCCACIAApAgA3AwAgACAAKQI4NwIYIAAgACkCMDcCECAAIAApAig3AgggACAAKQIgNwIAIAAgAikDGDcCOCAAIAIpAxA3AjAgACACKQMINwIoIAAgAikDADcCIAwBCyAEIAZJBEAgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgAykCGDcCGCAAIAMpAhA3AhAgACADKQIINwIIIAAgAykCADcCACADIAIpAxg3AhggAyACKQMQNwIQIAMgAikDCDcCCCADIAIpAwA3AgAMAQsgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgACkCODcCGCAAIAApAjA3AhAgACAAKQIoNwIIIAAgACkCIDcCACAAIAIpAxg3AjggACACKQMQNwIwIAAgAikDCDcCKCAAIAIpAwA3AiAgBCAAKAIgTw0AIAIgACkCODcDGCACIAApAjA3AxAgAiAA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DUEAIQcgA0EETwRAIANB/AFxIQhBACEAA0AgDSAHQZAWbGpBAEGEFhASQoCAgICAgID4/wA3A4gWIA0gB0EBckGQFmxqQQBBhBYQEkKAgICAgICA+P8ANwOIFiANIAdBAnJBkBZsakEAQYQWEBJCgICAgICAgPj/ADcDiBYgDSAHQQNyQZAWbGpBAEGEFhASQoCAgICAgID4/wA3A4gWIAdBBGohByAAQQRqIgAgCEcNAAsLIAQEQANAIA0gB0GQFmxqQQBBhBYQEkKAgICAgICA+P8ANwOIFiAHQQFqIQcgAUEBaiIBIARHDQALCyAVQSlrIQcgFSADbiEIQQchCkEAIQADQCAAIBVsIANuIQEgAARAIApBp4MBbCIKIAhwIAFqIQELIA0gAEGQFmxqIgQgBCgCgBZBKGo2AoAWIAQgGiABIAcgAUEoaiAVSRtBAXRqIgEvAQBBAnRqIgsgCygCAEEBajYCACAEIAEvAQJBAnRqIgsgCygCAEEBajYCACAEIAEvAQRBAnRqIgsgCygCAEEBajYCACAEIAEvAQZBAnRqIgsgCygCAEEBajYCACAEIAEvAQhBAnRqIgsgCygCAEEBajYCACAEIAEvAQpBAnRqIgsgCygCAEEBajYCACAEIAEvAQxBAnRqIgsgCygCAEEBajYCACAEIAEvAQ5BAnRqIgsgCygCAEEBajYCACAEIAEvARBBAnRqIgsgCygCAEEBajYCACAEIAEvARJBAnRqIgsgCygCAEEBajYCACAEIAEvARRBAnRqIgsgCygCAEEBajYCACAEIAEvARZBAnRqIgsgCygCAEEBajYCACAEIAEvARhBAnRqIgsgCygCAEEBajYCACAEIAEvARpBAnRqIgsgCygCAEEBajYCACAEIAEvARxBAnRqIgsgCygCAEEBajYCACAEIAEvAR5BAnRqIgsgCygCAEEBajYCACAEIAEvASBBAnRqIgsgCygCAEEBajYCACAEIAEvASJBAnRqIgsgCygCAEEBajYCACAEIAEvASRBAnRqIgsgCygCAEEBajYCACAEIAEvASZBAnRqIgsgCygCAEEBajYCACAEIAEvAShBAnRqIgsgCygCAEEBajYCACAEIAEvASpBAnRqIgsgCygCAEEBajYCACAEIAEvASxBAnRqIgsgCygCAEEBajYCACAEIAEvAS5BAnRq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NwPAASAKQoSAgICwATcDgAIgCkKPgICAgAI3A4gCIB0gAjYCBCAdIAM2AoABIB0gBCgCADYC8AEgHSAFNgLgASAdQQA2AoQCIApBFjYCCCAKIAA2AgQgCiACNgIQIAogATYCACAdQYQCaiE9QQAhASMAQRBrIkIkACAKEC8CQCAKKALQKUF/Rw0AAkACQCAKKALUKQ4FAQAAAgIACyAdKAIEDQELIAooAgQiAEECTwRAIApBwClqIUcgCkG4KWohOyAKQbQpaiFFIApB4ABqIT4DQAJAIAopA7gBIbYBIAopA3AhtwEgChAvAkBBASAKKAIMdCIAILcBILYBfSK2AaciBkYgtgEgAK1acg0AIB0oAgQiAUUNACAAIAZrIgAgASAAIAFJGyEAIB0oAoABIQggChAvAkACQCAKKAKMASIGDQAgCigCgAEgAE0NACAKIAA2AowBIABBCWoiAQR/ID4gARAVBUEACyEBIAooApABIgYEQCABIAYgCigCiAFBCWoQFBogPigCCCAKKAKQASA+KAIEEQAACyAKIAA2AogBIAogATYCkAEgCiABQQJqNgKUASABQQA6AAEgCigClAFBAmtBADoAACAKKAKUASAKKAKIAWpBADoAACAKKAKIASAKKAKUAWpBADoAASAKKAKIASAKKAKUAWpBADoAAiAKKAKIASAKKAKUAWpBADoAAyAKKAKIASAKKAKUAWpBADoABCAKKAKIASAKKAKUAWpBADoABSAKKAKIASAKKAKUAWpBADoABiAKKAKUASAIIAAQFBogCigCjAEhBgwBCyAKKAKEASIHIAooAogBSwRAIAdBCWoiAQR/ID4gARAVBUEACyEBIAooApABIgYEQCABIAYgCigCiAFBCWoQFBogPigCCCAKKAKQASA+KAIEEQAACyAKIAc2AogBIAogATYCkAEgCiABQQJqNgKUASABQQA6AAEgCigClAFBAmtBADoAACAKKAKUASAKKAKIAWpBADoAACAKKAKIASAKKAKUAWpBADoAASAKKAKIASAKKAKUAWpBADoAAiAKKAKIASAKKAKUAWpBADoAAyAKKAKIASAKKAKUAWpBADoABCAKKAKIASAKKAKUAWpBADoABSAKKAKIASAKKAKUAWpBADoABiAKKAJ4IAooApQBakECa0EAOgAAIAooAnggCigClAFqQQFrQQA6AAAgCigCjAEhBgsgCigCgAEiByAKKAJ8IAZxIgFLBEAgCigClAEgCigCeCABamogCCAAIAcgAWsiBiAAIAZJGxAUGgsgCigClAEgAWohBgJAIAooAnggACABak8EQCAGIAggABAUGgwBCyAGIAggACAKKAKEASABayIGIAAgBkkbEBQaIAooApQBIAggCigCeCABayIBaiAAIAFrEBQaCyAKKAKMASEBIAooApQBQQJrIgYgBiAKKAJ4ai0AADoAACAKKAKUAUEBayIGIAYgCigCeGotAAA6AAAgCiAKKAKMAUH/////B3EgAEH/////B3FqIAFBgICAgHhxciIGNgKMAQsgCiAKKQNwIACtfDcDcCAKKAJ8IAZPBEAgCigClAEgBmoiAUEANgAAIAFBADYAAwsgHSAdKAKAASAAajYCgAEgHSAdKAIEIABrNgIEDAILAkACQCAKKALUKSIAQQFGBEAgCi0AkgIiAARAIApBADoAkgIgCi8BkAIhTiAKQQA7AZACIE5BBiAAdCIIciEBAn8gCigCtCkiBgRAIAYgOygCAGoMAQsgRSBHNgIAIEcLIgYgAToAAAJAIABBA0kNACAGIAFBCHY6AAEgAEELSQ0AIAYgCEEQdjoAAgsgOyA7KAIAIABBDWpBA3ZqNgIADAULIDsoAgAiCA0BIApBADYCtCkgCkEANgLUKQwDCyA7KAIAIghFDQELIB0oAvABIgBFDQEgHSgC4AEgCigCtCkgCCAAIAAgCEsbIgAQFBogHSAdKALgASAAajYC4AEgHSAdKALwASAAazYC8AEgCiAKKAK0KSAAajYCtCkgCiAKKAK4KSAAazYCuCkgCiAKKAK8KSAAaiIANgK8KSA9RQ0CID0gADYCAAwCC0EBIQYgAA0DIB0oAgQiAEUiN0EAcSFBIAooAhBFBEAgCkGAgICABEGAgICABEGAgICABCAKKQNwIAopA7gBfSK2ASAArXwitwGnILcBQv////8DVhsgtgFC/////wNWGyAAQf////8DSxs2AhALQQAhDUEAIQ5EAAAAAAAAAAAhuwFEAAAAAAAAAAAhvQFEAAAAAAAAAAAhvwEjAEGAD2siLCQAIAopA7gBIrcBpyIRIQggtwFCgICAgAxaBEAgEUEBdEEBdUGAgICAfHEgEUH/////A3FyQYCAgIB4cyEICyAK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ICo2AgAgFyAGQQV0NgIEIBdBCGohFyAGIQELIAhBAWsiCCAhTQ0BIAFBA0kNAAsLAkAgASAbTw0AIB8oAgAiKiAWcUEBdCEeIB8gECAgaigAAEG9z9bxAWxBDXZB/P8fcWoiACgCBCEHIBtBgAFJIiFFBEAgACAWNgIECyAeQQFyISkCfwJAIAcgFkYNACAbQYABICEbITJBACEIQcAAIQlBACEOA0AgFiAHayI0ICZLDQEgCUUNASAQIA4gCCAIIA5LGyIoICBqaiEvQQAhAAJAIBAgKCAHIBRxIjNqaiIGIBsgKGtqIhVBBGsiNSAGSQ0AA0AgBigAACAAIC9qKAAARw0BIABBBGohACAGQQRqIgYgNU0NAAsLAkAgBiAVTw0AIAYgFSAGayIVaiE1IAAgFWohUwNAIAAgL2otAAAgBi0AAEcNASAAQQFqIQAgBkEBaiIGIDVHDQALIFMhAAsgACAoaiEAAkAgF0UEQEEAIRcMAQsgACABTQ0AIBcgNDYCACAXIABBBXQ2AgQgF0EIaiEXIAAhAQsgACAyTwRAICENBCASIB5BAnRqIBIgByAqcUEDdGoiACgCADYCACAAQQRqDAMLIAlBAWshCSASAn8gECAAICBqai0AACAQIAAgM2pqLQAASwRAICFFBEAgEiAeQQJ0aiAHNgIACyAAIQ4gByAqcUEBdEEBciIeDAELICFFBEAgEiApQQJ0aiAHNgIACyAAIQggByAqcUEBdCIpC0ECdGooAgAiByAWRw0ACwsgIQ0BIBIgHkECdGogGSgCADYCACAZCyEAIBIgKUECdGogACgCADYCAAsgE0L/////8P///w83A8AwIBNC//////D///8PNwO4MCATQv/////w////DzcDsDAgE0L/////8P///w83A6gwIBNC//////D///8PNwOgMCATQv/////w////DzcDmDAgE0L/////8P///w83A5AwIBNC//////D///8PNwOIMCATQv/////w////DzcDgDAgE0L/////8P///w83A/gvIBNC//////D///8PNwPwLyATQv/////w////DzcD6C8gE0L/////8P///w83A+AvIBNC//////D///8PNwPYLyATQv/////w////DzcD0C8gE0L/////8P///w83A8gvIBNC//////D///8PNwPALyATQv//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ACkCADcCACAAICkoAgA2AhggACAoKQMANwIQIAAgLikDADcCCCAAIBMpA7AeNwIACyAXQQZGDQAgACoCFCATQbAvakENIBVrQQdxQRxsaiIPKgIUXgRAIBNByB5qIhUgACgCGDYCACATQcAeaiIpIAApAhA3AwAgE0G4HmoiKCAAKQIINwMAIBMgACkCADcDsB4gACAPKAIYNgIYIAAgDykCEDcCECAAIA8pAgg3AgggACAPKQIANwIAIA8gFSgCADYCGCAPICkpAwA3AhAgDyAoKQMANwIIIA8gEykDsB43AgALIBdBB0YNACAPKgIUIBNBsC9qQQYgB2tBB3FBHGxqIgAqAhReRQ0AIBNByB5qIgcgDygCGDYCACATQcAeaiIVIA8pAhA3AwAgE0G4HmoiFyAPKQIINwMAIBMgDykCADcDsB4gDyAAKAIYNgIYIA8gACkCEDcCECAPIAApAgg3AgggDyAAKQIANwIAIAAgBygCADYCGCAAIBUpAwA3AhAgACAXKQMANwIIIAAgEykDsB43AgALIAEhBwsgIyAqaigCACAIaiEIIAYhACAMQQFrIgwNAQsLIBMgATYCkDELIAZBAWohACAGQQRqIAtJDQALCyALIQYCQCAmKAIIQf///z9xDQADQCAJIAZBBHRqKAIAQQFHDQEgCSAGQQFrIgZBBHRqKAIIQf///z9xRQ0ACwsgCSAGQQR0akF/NgIMQQAhDEEAIQAgBgRAA0AgCSAGIAkgBkEEdGoiASgCCEH///8/cSABKAIAQf///w9xaiIBayIGQQR0aiABNgIMIABBAWohACAGDQALCyAcIBwoAgAgAGo2AgAgCyANICUgCSAaICcgCiAtICsQUSAkDQALICIoAgggEygClBYgIigCBBEAACATQQA2ApQWICIoAgggEygCjBYgIigCBBEAACATQQA2AowWICIoAgggCSAiKAIEEQAAICIoAgggESAiKAIEEQAAICIoAgggIyAiKAIEEQAAIBNBsM0AaiQADAELIAghESAKKAJsIQggCkHAAWohACAKQagBaiEBIAooApwBIAdBBHRqIQcgCkGkAWohBgJAAkACQAJAAkACQAJAAkACQAJAIAooAhxBAmsONQABAgMECQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJBQYHCQkJCQkJCQkJCQkICQsgCCESIAAhFSAGIRsgASIWKAIAISUCQCALIBEiBmoiHiAGQQhqTQRAIAchDAwBCyAeQQdrIiEgBiALQQdLGyErQQEgCigCCHRBEGshH0HAAEGABCAKKAIEQQlIGyImQQJ0ISkgEkEgaiEZIAYgJmohDyAHIQwDQCAeIAZrIRogECAGIBRxaiIIKQAAIrYBpyENILYBQoCAgOj7tI2PvX9+QjCIpyELIAooAjwhJAJAAkACQAJAIAYgFSgCACIOayIAIAZPDQAgECAAIBRxaiIRLQAAIA1B/wFxRw0AQQAhAQJAIAgiACAAIBpqIglBBGsiE0sNAANAIAAoAAAgASARaigAAEcNASABQQRqIQEgAEEEaiIAIBNNDQALCwJAIAAgCU8NACAAIAkgAGsiCWohEyABIAlqIVgDQCABIBFqLQAAIAAtAABHDQEgAUEBaiEBIABBAWoiACATRw0ACyBYIQELIAFBBEkNACABQYcBbEHPB2oiF0GlCEkNACAZIAtBAnRqIAY2AgBBACELDAELIBkgC0ECdGoiESgCACEAIBEgBjYCACAQIAAgFHFqIgstAAAgDUH/AXFHDQEgACAGRg0BIAYgAGsiDiAGIB8gBiAfSRsiE0sNAUEAIQECQCAIIgAgACAaaiIJQQRrIhdLDQADQCAAKAAAIAEgC2ooAABHDQEgAUEEaiEBIABBBGoiACAXTQ0ACwsCQCAAIAlPDQAgACAJIABrIglqIRcgASAJaiFZA0AgASALai0AACAALQAARw0BIAFBAWohASAAQQFqIgAgF0cNAAsgWSEBCyABQQRPBEBBACELIA5nQR9zQWJsIAFBhwFsakHAB2oiF0GkCEsNAQsCQAJAIBIoAhwiGCASKAIYIgFBB3ZJDQAgCigCUCANQb3P1vEBbEEQdkH8/wNxai8BACEAIBIgAUEBajYCGCAARQ0AIABBH3EiDiAaSw0AQQAhAQJAIAooAkAiDSgCpAEgDSAOQQJ0aigCICAOIABBBXYiC2xqaiIAIA5qIglBBGsiFyAASQ0AA0AgACgAACABIAhqKAAARw0BIAFBBGohASAAQQRqIgAgF00NAAsLAkAgACAJTw0AIAAgCSAAayIJaiEXIAEgCWohWgNAIAEgCGotAAAgAC0AAEcNASABQQFqIQEgAEEBaiIAIBdHDQALIFohAQsgAUUNACAKKAJEIAFqIA5NDQAgE0EBaiALaiAKKQNIIA4gAWsiC0EGbK2Ip0E/cSALQQJ0aiANIA5qLQAAdGoiDiAkSw0AIAFBhwFsIA5nQR9zQWJsakHAB2oiF0GjCEsNAQsgESAGNgIADAILIBIgGEEBajYCHCARIAY2AgAgF0GkCEYNAQtBACEnA0AgBkEBaiIRIB8gESAfSRshGCAQIAFBAWsiACAaQQFrIhogACAaSRtBACAKKAIEQQVIGyIJIBEgFHEiAGpqLQAAISMgACAQaiINKQAAIrYBQoCAgOj7tI2PvX9+QjCIpyEgAkACQAJAAkAgESAVKAIAIg9rIgAgEU8NACAjIBAgACAUcSIAIAlqai0AAEcNACAAIBBqISpBACEAAkAgDSIIIAggGmoiE0EEayIoSw0AA0AgCCgAACAAICpqKAAARw0BIABBBGohACAIQQRqIgggKE0NAAsLAkAgCCATTw0AIAggEyAIayITaiEoIAAgE2ohWwNAIAAgKmotAAAgCC0AAEcNASAAQQFqIQAgCEEBaiIIIChHDQALIFshAAsgAEEESQ0AIABBhwFsQc8HaiIIQaUISQ0AIBkgIEECdGohIEEAIRMMAQsgGSAgQQJ0aiIgKAIAIQAgICARNgIAQaQIIQhBACETICMgECAAIBRxIiogCWpqLQAARw0BIAAgEUYNASARIABrIg8gGEsNASAQICpqISNBACEAAkAgDSIIIAggGmoiE0EEayIqSw0AA0AgCCgAACAAICNqKAAARw0BIABBBGohACAIQQRqIgggKk0NAAsLAkAgCCATTw0AIAggEyAIayITaiEqIAAgE2ohXANAIAAgI2otAAAgCC0AAEcNASAAQQFqIQAgCEEBaiIIICpHDQALIFwhAAsgAEEETwRAQQAhEyAPZ0Efc0FibCAAQYcBbGpBwAdqIghBpAhLDQMLQaQIIQhBACETAkAgEigCHCIoIBIoAhgiAEEHdkkNACAKKAJQILYBp0G9z9bxAWxBEHZB/P8DcWovAQAhDyASIABBAWo2AhggD0UNACAPQR9xIiMgGksNAEEAIQACQCAKKAJAIiooAqQBICogI0ECdGooAiAgIyAPQQV2Ii1samoiEyAjaiIPQQRrIjAgE0kNAANAIBMoAAAgACANaigAAEcNASAAQQRqIQAgE0EEaiITIDBNDQALCwJAIA8gE00NACATIA8gE2siD2ohMCAAIA9qIV0DQCAAIA1qLQAAIBMtAABHDQEgAEEBaiEAIBNBAWoiEyAwRw0ACyBdIQALAkAgAEUNACAKKAJEIABqICNNDQAgGEEBaiAtaiAKKQNIICMgAGsiE0EGbK2Ip0E/cSATQQJ0aiAjICpqLQAAdGoiDyAkSw0AIABBhwFsIA9nQR9zQWJsakHAB2oiCEGkCEkEQEEAIRNBpAghCAwCCyASIChBAWo2AhwMAgtBACETC0EAIQ8gCSEACyAgIBE2AgAMAQtBACEPIAkhAAsCQCAXQa8BaiAISwRAIAYgHyAGIB9JGyEYIAshEyAOIQ8gASEAIAYhEQwBCyAlQQFqISUgJ0ECSw0AIAZBCWohXiAnQQFqIScgEyELIAghFyAPIQ4gACEBIBEhBiBeIB5JDQELCwJAAn8gDyAYSyIBRQRAQQAhCCAVKAIAIgYgD0YNAkEBIBUoAgQiCCAPRg0BGiAPQQNqIgkgBmsiBkEGTQRAQeiI1MsAIAZBAnR2QQ9xDAILIAkgCGsiBkEGTQRAQc617P4AIAZBAnR2QQ9xDAILQQIgFSgCCCAPRg0BGkEDIBUoAgwgD0YNARoLIA9BD2oLIQggAQ0AIAhFDQAgFSAVKAIINgIMIBUgFSkCADcCBCAVIA82AgALIAooAjQhASAKKAIwIQYgDCAAIBNBGXRyNgIEIAwgJTYCAEEAIRogCCAGQRBqIglPBEAgCCAGa0EBIAFBAmp0akEQayIGIAYgBmdBH3NBAWsiCHZBAXEiC0ECciAIdGsgAXYhGiAGQX8gAXRBf3NxIAlqIAsgCCABayIGQQF0ckH+/wNqIAF0aiAGQQp0ciEICyAMIBo2AgggDCAIOwEOIAAgE2ohAQJ/ICUgJUEFTQ0AGiAlQYEBTQRAICVBAmsiBmdBH3NBAWsiCUEBdCAGIAl2akECagwBCyAlQcIAa2dBH3NBCmogJUHBEE0NABpBFSAlQcIwSQ0AGkEWQRcgJUHCsAFJGwshBiAIQf8HcSEJAn8gAUECayABQQlNDQAaIAFBhQFNBEAgAUEGayIBZ0Efc0EBayIIQQF0IAEgCHZqQQRqDAELQRcgAUHFEEsNABogAUHGAGtnQR9zQQxqCyIIQQdxIAZBA3RBOHFyIQEgDAJ/AkAgCQ0AIAZB//8DcUEHSw0AIAhB//8DcSIJQQ9LDQAgASABQcAAciAJQQhJGwwBCyABIAZB+P8DcUEDdkEDbCAIQfj/A3FBA3ZqIgZBBnRBwJrIAiAGQQF0dkHAAXFqckFAaws7AQwgGyAbKAIAICVqNgIAIAAgEWoiBiArIAYgK0kbIQEgEUECaiEIIABBAnYgD0sEQCABIAggBiAPQQJ0ayIJIAggCUsbIgggASAISRshCAsgAEEBdCAmaiARaiEPIAxBEGohDEEAISUgASAITQ0BIAhBAWohACABIAhrQQFxBEAgGSAQIAggFHFqKQAAQoCAgOj7tI2PvX9+QjCIp0ECdGogCDYCACAAIQgLIAAgAUYNAQNAIBkgECAIIBRxaikAAEKAgIDo+7SNj71/fkIwiKdBAnRqIAg2AgAgGSAQIAhBAWoiACAUcWopAABCgICA6Pu0jY+9f35CMIinQQJ0aiAANgIAIAhBAmoiCCABRw0ACwwBCyAlQQFqISUCQCAGQQFqIgAgD00NACAPIClqIABJBEAgACAGQRFqIgEgISABICFJGyIBTw0BA0AgGSAQIAAgFHFqKQAAQoCAgOj7tI2PvX9+QjCIp0ECdGogADYCACAlQQRqISUgAEEEaiIAIAFJDQALDAELIAAgBkEJaiIBICEgASAhSRsiAU8NAANAIBkgECAAIBRxaikAAEKAgIDo+7SNj71/fkIwiKdBAnRqIAA2AgAgJUECaiElIABBAmoiACABSQ0ACwsgACEGCyAGQQhqIB5JDQALCyAWIB4gJWogBms2AgAgHCAcKAIAIAwgB2tBBHVqNgIADAgLIAAhEyAHIRUgBiEXIAEiGygCACEfAkAgCyARIg1qIhkgDUEIak0EQCAHIREMAQsgGUEHayIlIA0gC0EHSxshJEEBIAooAgh0QRBrIRhBwABBgAQgCigCBEEJSBsiKkECdCEoIAhBIGohGiANICpqIQggFSERA0AgECANIBRxIiBqIgEpAAAitgGnIQdBACEGQaQIIQ4gDSAYIA0gGEkbIR4gGSANayIjIAFqIhJBBGshFgJAIBACf0EAIA0gDSATKAIAIglrIgBNDQAaQQAgECAAIBRxaiILLQAAIAdB/wFxRw0AGkEAIQAgASEMAkAgASAjaiIGQQRrIg8gAUkNAANAIAwoAAAgACALaigAAEcNASAAQQRqIQAgDEEEaiIMIA9NDQALCwJAIAYgDE0NACAMIAYgDGsiBmohDyAAIAZqIV8DQCAAIAtqLQAAIAwtAABHDQEgAEEBaiEAIAxBAWoiDCAPRw0ACyBfIQALQQAhBkEAIABBBEkNABpBACAAQYcBbEHPB2oiC0GlCEkNABogECAAICBqai0AACEHIAshDiAJIQYgAAsiCSAaILYBQoCAgOj7tI2PvX9+QjCIpyInQQJ0aiIrKAIAIgAgFHEiDGpqLQAAIAdB/wFxRw0AIAAgDUYNACANIABrIgsgHksNACAMIBBqISFBACEAIAEhDAJAIAEgFksNAANAIAwoAAAgACAhaigAAEcNASAAQQRqIQAgDEEEaiIMIBZNDQALCwJAIAwgEk8NACAMIBIgDGsiD2ohJiAAIA9qIWADQCAAICFqLQAAIAwtAABHDQEgAEEBaiEAIAxBAWoiDCAmRw0ACyBgIQALIABBBEkNACAOIAtnQR9zQWJsIABBhwFsakHAB2oiDE8NACAQIAAgIGpqLQAAIQcgDCEOIAshBiAAIQkLAkAgECArKAIEIgAgFHEiCyAJamotAAAgB0H/AXFHDQAgACANRg0AIA0gAGsiByAeSw0AIAsgEGohDEEAIQACQCABIBZLDQADQCABKAAAIAAgDGooAABHDQEgAEEEaiEAIAFBBGoiASAWTQ0ACwsCQCABIBJPDQAgASASIAFrIgtqIQ8gACALaiFhA0AgACAMai0AACABLQAARw0BIABBAWohACABQQFqIgEgD0cNAAsgYSEACyAAQQRJDQAgDiAHZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgASEOIAchBiAAIQkLIBogDUEDdkEBcSAnakECdGogDTYCAAJAIA5BpQhPBEBBACEgA0AgDUEBaiIPIBhJIR4gECAJQQFrIgAgI0EBayIjIAAgI0kbQQAgCigCBEEFSBsiByAPIBRxIiZqai0AACErIBAgJmoiASkAACG2AUGkCCELAkAgDyAPIBMoAgAiEmsiAE0EQEEAIQgMAQsgECAAIBRxIgAgB2pqLQAAICtHBEBBACEIDAELIAAgEGohFkEAIQAgASEMAkAgASAjaiIIQQRrIiEgAUkNAANAIAwoAAAgACAWaigAAEcNASAAQQRqIQAgDEEEaiIMICFNDQALCwJAIAggDE0NACAMIAggDGsiCGohISAAIAhqIWIDQCAAIBZqLQAAIAwtAABHDQEgAEEBaiEAIAxBAWoiDCAhRw0ACyBiIQALQQAhCCAAQQRJDQAgAEGHAWxBzwdqIgxBpQhJDQAgECAAICZqai0AACErIAwhCyASIQggACEHCyAPIBggHhshHiABICNqIiFBBGshJwJAICsgECAaILYBQoCAgOj7tI2PvX9+QjCIpyItQQJ0aiIwKAIAIgAgFHEiDCAHamotAABHDQAgACAPRg0AIA8gAGsiEiAeSw0AIAwgEGohKUEAIQAgASEMAkAgASAnSw0AA0AgDCgAACAAIClqKAAARw0BIABBBGohACAMQQRqIgwgJ00NAAsLAkAgDCAhTw0AIAwgISAMayIWaiEuIAAgFmohYwNAIAAgKWotAAAgDC0AAEcNASAAQQFqIQAgDEEBaiIMIC5HDQALIGMhAAsgAEEESQ0AIAsgEmdBH3NBYmwgAEGHAWxqQcAHaiIMTw0AIBAgACAmamotAAAhKyAMIQsgEiEIIAAhBwsCQCArIBAgMCgCBCIAIBRxIhIgB2pqLQAARw0AIAAgD0YNACAPIABrIgwgHksNACAQIBJqIRZBACEAAkAgASAnSw0AA0AgASgAACAAIBZqKAAARw0BIABBBGohACABQQRqIgEgJ00NAAsLAkAgASAhTw0AIAEgISABayISaiEhIAAgEmohZANAIAAgFmotAAAgAS0AAEcNASAAQQFqIQAgAUEBaiIBICFHDQALIGQhAAsgAEEESQ0AIAsgDGdBH3NBYmwgAEGHAWxqQcAHaiIBTw0AIAEhCyAMIQggACEHCyAaIA9BA3ZBAXEgLWpBAnRqIA82AgACQCAOQa8BaiALSwRAIA0gGCANIBhJGyEeIAYhCCAJIQcgDSEPDAELIB9BAWohHyAgQQJLDQAgDUEJaiFlICBBAWohICALIQ4gCCEGIAchCSAPIQ0gZSAZSQ0BCwsCQAJ/IAggHksiAEUEQEEAIQEgEygCACIGIAhGDQJBASATKAIEIgEgCEYNARogCEEDaiIJIAZrIgZBBk0EQEHoiNTLACAGQQJ0dkEPcQwCCyAJIAFrIgFBBk0EQEHOtez+ACABQQJ0dkEPcQwCC0ECIBMoAgggCEYNARpBAyATKAIMIAhGDQEaCyAIQQ9qCyEBIAANACABRQ0AIBMgEygCCDYCDCATIBMpAgA3AgQgEyAINgIACyAKKAI0IQAgCigCMCEJIBEgBzYCBCARIB82AgBBACEGIAEgCUEQaiILTwRAIAEgCWtBASAAQQJqdGpBEGsiASABIAFnQR9zQQFrIgl2QQFxIg5BAnIgCXRrIAB2IQYgAUF/IAB0QX9zcSALaiAOIAkgAGsiAUEBdHJB/v8DaiAAdGogAUEKdHIhAQsgESAGNgIIIBEgATsBDgJ/IB8gH0EFTQ0AGiAfQYEBTQRAIB9BAmsiAGdBH3NBAWsiBkEBdCAAIAZ2akECagwBCyAfQcIAa2dBH3NBCmogH0HBEE0NABpBFSAfQcIwSQ0AGkEWQRcgH0HCsAFJGwshACABQf8HcSEJAn8gB0ECayAHQQlNDQAaIAdBhQFNBEAgB0EGayIBZ0Efc0EBayIGQQF0IAEgBnZqQQRqDAELQRcgB0HFEEsNABogB0HGAGtnQR9zQQxqCyIGQQdxIABBA3RBOHFyIQEgEQJ/AkAgCQ0AIABB//8DcUEHSw0AIAZB//8DcSIJQQ9LDQAgASABQcAAciAJQQhJGwwBCyAAQfj/A3FBA3ZBA2wgBkH4/wNxQQN2aiIAQQZ0QcCayAIgAEEBdHZBwAFxaiABckFAaws7AQwgFyAXKAIAIB9qNgIAIAcgD2oiDSAkIA0gJEkbIQYgD0ECaiEBIAdBAnYgCEsEQCAGIAEgDSAIQQJ0ayIAIAAgAUkbIgAgACAGSxshAQsgB0EBdCAqaiAPaiEIIBFBEGohEUEAIR8gASAGTw0BIAFBAWohACAGIAFrQQFxBEAgGiAQIAEgFHFqKQAAQoCAgOj7tI2PvX9+QjCIpyABQQN2QQFxakECdGogATYCACAAIQELIAAgBkYNAQNAIBogECABIBRxaikAAEKAgIDo+7SNj71/fkIwiKcgAUEDdkEBcWpBAnRqIAE2AgAgGiABQQFqIgBBA3ZBAXEgECAAIBRxaikAAEKAgIDo+7SNj71/fkIwiKdqQQJ0aiAANgIAIAFBAmoiASAGRw0ACwwBCyAfQQFqIR8CQCANQQFqIgEgCE0NACAIIChqIAFJBEAgASANQRFqIgAgJSAAICVJGyIATw0BA0AgGiAQIAEgFHFqKQAAQoCAgOj7tI2PvX9+QjCIpyABQQN2QQFxakECdGogATYCACAfQQRqIR8gAUEEaiIBIABJDQALDAELIAEgDUEJaiIAICUgACAlSRsiAE8NAANAIBogECABIBRxaikAAEKAgIDo+7SNj71/fkIwiKcgAUEDdkEBcWpBAnRqIAE2AgAgH0ECaiEfIAFBAmoiASAASQ0ACwsgASENCyANQQhqIBlJDQALCyAbIBkgH2ogDWs2AgAgHCAcKAIAIBEgFWtBBHVqNgIADAcLIAghEiAAIRcgByETIAYhGyABIhooAgAhIQJAIAsgESIMaiImIAxBCGpNBEAgByEPDAELICZBB2siKiAMIAtBB0sbIShBASAKKAIIdEEQayErQcAAQYAEIAooAgRBCUgbIi1BAnQhLyASQSBqISUgDCAtaiEIIBMhDwNAIBAgDCAUcSIjaiIGKQAAIrYBpyEJQQAhByAMICsgDCArSRshGSAKKAI8ITAgBiAmIAxrIh9qIhZBBGshGAJAIBACfwJAIAwgFygCACILayIAIAxPDQBBpAghDkEAIBAgACAUcWoiES0AACAJIg1B/wFxRw0BGkEAIQACQCAGIgEgASAfaiIHQQRrIhVLDQADQCABKAAAIAAgEWooAABHDQEgAEEEaiEAIAFBBGoiASAVTQ0ACwsCQCABIAdPDQAgASAHIAFrIgdqIRUgACAHaiFmA0AgACARai0AACABLQAARw0BIABBAWohACABQQFqIgEgFUcNAAsgZiEAC0EAIQcgAEEESQ0AQQAgAEGHAWxBzwdqIgFBpQhJDQEaIBAgACAjamotAAAhDSABIQ4gCyEHIAAMAQtBpAghDiAJIQ1BAAsiCyAlILYBQoCAgOj7tI2PvX9+Qi+IpyIeQQJ0aiIgKAIAIgAgFHEiAWpqLQAAIA1B/wFxRw0AIAAgDEYNACAMIABrIhEgGUsNACABIBBqISdBACEAAkAgGCAGIgFJDQADQCABKAAAIAAgJ2ooAABHDQEgAEEEaiEAIAFBBGoiASAYTQ0ACwsCQCABIBZPDQAgASAWIAFrIhVqISQgACAVaiFnA0AgACAnai0AACABLQAARw0BIABBAWohACABQQFqIgEgJEcNAAsgZyEACyAAQQRJDQAgDiARZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgECAAICNqai0AACENIAEhDiARIQcgACELCwJAIBAgICgCBCIAIBRxIgEgC2pqLQAAIA1B/wFxRw0AIAAgDEYNACAMIABrIhEgGUsNACABIBBqISdBACEAAkAgGCAGIgFJDQADQCABKAAAIAAgJ2ooAABHDQEgAEEEaiEAIAFBBGoiASAYTQ0ACwsCQCABIBZPDQAgASAWIAFrIhVqISQgACAVaiFoA0AgACAnai0AACABLQAARw0BIABBAWohACABQQFqIgEgJEcNAAsgaCEACyAAQQRJDQAgDiARZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgECAAICNqai0AACENIAEhDiARIQcgACELCwJAIBAgICgCCCIAIBRxIgEgC2pqLQAAIA1B/wFxRw0AIAAgDEYNACAMIABrIhEgGUsNACABIBBqISdBACEAAkAgGCAGIgFJDQADQCABKAAAIAAgJ2ooAABHDQEgAEEEaiEAIAFBBGoiASAYTQ0ACwsCQCABIBZPDQAgASAWIAFrIhVqISQgACAVaiFpA0AgACAnai0AACABLQAARw0BIABBAWohACABQQFqIgEgJEcNAAsgaSEACyAAQQRJDQAgDiARZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgECAAICNqai0AACENIAEhDiARIQcgACELCwJAIBAgICgCDCIAIBRxIgEgC2pqLQAAIA1B/wFxRw0AIAAgDEYNACAMIABrIg0gGUsNACABIBBqIRVBACEAAkAgGCAGIgFJDQADQCABKAAAIAAgFWooAABHDQEgAEEEaiEAIAFBBGoiASAYTQ0ACwsCQCABIBZPDQAgASAWIAFrIhFqIRYgACARaiFqA0AgACAVai0AACABLQAARw0BIABBAWohACABQQFqIgEgFkcNAAsgaiEACyAAQQRJDQAgDiANZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgASEOIA0hByAAIQsLQQAhGEEAIRECQAJAAkAgDkGkCEYEQCASKAIcIg0gEigCGCIBQQd2SQ0BIAooAlAgCUG9z9bxAWxBEHZB/P8DcWovAQAhACASIAFBAWo2AhggAEUNASAAQR9xIgcgH0sNAUEAIQsCQCAKKAJAIgkoAqQBIAkgB0ECdGooAiAgByAAQQV2Ig5samoiACAHaiIBQQRrIhEgAEkNAANAIAAoAAAgBiALaigAAEcNASALQQRqIQsgAEEEaiIAIBFNDQALCwJAIAAgAU8NACAAIAEgAGsiAWohESABIAtqIWsDQCAGIAtqLQAAIAAtAABHDQEgC0EBaiELIABBAWoiACARRw0ACyBrIQsLIAtFDQEgCigCRCALaiAHTQ0BIBlBAWogDmogCikDSCAHIAtrIhFBBmytiKdBP3EgEUECdGogByAJai0AAHRqIgcgMEsNASALQYcBbCAHZ0Efc0FibGpBwAdqIg5BpAhJDQEgEiANQQFqNgIcCyAlIAxBA3ZBA3EgHmpBAnRqIAw2AgAgDkGlCEkNAQNAIAxBAWoiFSArSSEjQQAhCCAQIAtBAWsiACAfQQFrIh8gACAfSRtBACAKKAIEQQVIGyIGIBQgFXEiJGpqLQAAISAgECAkaiINKQAAIbYBQaQIIQkCQCAVIBcoAgAiFmsiACAVTw0AICAgECAAIBRxIgAgBmpqLQAARw0AIAAgEGohGUEAIQACQCANIgEgASAfaiIIQQRrIh5LDQADQCABKAAAIAAgGWooAABHDQEgAEEEaiEAIAFBBGoiASAeTQ0ACwsCQCABIAhPDQAgASAIIAFrIghqIR4gACAIaiFsA0AgACAZai0AACABLQAARw0BIABBAWohACABQQFqIgEgHkcNAAsgbCEAC0EAIQggAEEESQ0AIABBhwFsQc8HaiIBQaUISQ0AIBAgACAkamotAAAhICABIQkgFiEIIAAhBgsgFSArICMbISMgDSAfaiIeQQRrIScCQCAgIBAgJSC2AUKAgIDo+7SNj71/fkIviKciMUECdGoiKSgCACIAIBRxIgEgBmpqLQAARw0AIAAgFUYNACAVIABrIhYgI0sNACABIBBqIS5BACEAAkAgJyANIgFJDQADQCABKAAAIAAgLmooAABHDQEgAEEEaiEAIAFBBGoiASAnTQ0ACwsCQCABIB5PDQAgASAeIAFrIhlqITIgACAZaiFtA0AgACAuai0AACABLQAARw0BIABBAWohACABQQFqIgEgMkcNAAsgbSEACyAAQQRJDQAgCSAWZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgECAAICRqai0AACEgIAEhCSAWIQggACEGCwJAICAgECApKAIEIgAgFHEiASAGamotAABHDQAgACAVRg0AIBUgAGsiFiAjSw0AIAEgEGohLkEAIQACQCAnIA0iAUkNAANAIAEoAAAgACAuaigAAEcNASAAQQRqIQAgAUEEaiIBICdNDQALCwJAIAEgHk8NACABIB4gAWsiGWohMiAAIBlqIW4DQCAAIC5qLQAAIAEtAABHDQEgAEEBaiEAIAFBAWoiASAyRw0ACyBuIQALIABBBEkNACAJIBZnQR9zQWJsIABBhwFsakHAB2oiAU8NACAQIAAgJGpqLQAAISAgASEJIBYhCCAAIQYLAkAgICAQICkoAggiACAUcSIBIAZqai0AAEcNACAAIBVGDQAgFSAAayIWICNLDQAgASAQaiEuQQAhAAJAICcgDSIBSQ0AA0AgASgAACAAIC5qKAAARw0BIABBBGohACABQQRqIgEgJ00NAAsLAkAgASAeTw0AIAEgHiABayIZaiEyIAAgGWohbwNAIAAgLmotAAAgAS0AAEcNASAAQQFqIQAgAUEBaiIBIDJHDQALIG8hAAsgAEEESQ0AIAkgFmdBH3NBYmwgAEGHAWxqQcAHaiIBTw0AIBAgACAkamotAAAhICABIQkgFiEIIAAhBgsCQCAgIBAgKSgCDCIAIBRxIgEgBmpqLQAARw0AIAAgFUYNACAVIABrIhYgI0sNACABIBBqISBBACEAAkAgJyANIgFJDQADQCABKAAAIAAgIGooAABHDQEgAEEEaiEAIAFBBGoiASAnTQ0ACwsCQCABIB5PDQAgASAeIAFrIhlqIR4gACAZaiFwA0AgACAgai0AACABLQAARw0BIABBAWohACABQQFqIgEgHkcNAAsgcCEACyAAQQRJDQAgCSAWZ0Efc0FibCAAQYcBbGpBwAdqIgFPDQAgASEJIBYhCCAAIQYLQQAhAQJAIAlBpAhHDQBBpAghCSASKAIcIh4gEigCGCIAQQd2SQ0AIAooAlAgtgGnQb3P1vEBbEEQdkH8/wNxai8BACEWIBIgAEEBajYCGCAWRQ0AIBZBH3EiGSAfSw0AQQAhAAJAIAooAkAiICgCpAEgICAZQQJ0aigCICAZIBZBBXYiJ2xqaiIBIBlqIhZBBGsiJCABSQ0AA0AgASgAACAAIA1qKAAARw0BIABBBGohACABQQRqIgEgJE0NAAsLAkAgASAWTw0AIAEgFiABayIWaiEkIAAgFmohcQNAIAAgDWotAAAgAS0AAEcNASAAQQFqIQAgAUEBaiIBICRHDQALIHEhAAtBACEBIABFDQAgCigCRCAAaiAZTQ0AICNBAWogJ2ogCikDSCAZIABrIg1BBmytiKdBP3EgDUECdGogGSAgai0AAHRqIhYgMEsNACAAQYcBbCAWZ0Efc0FibGpBwAdqIhlBpAhJDQAgEiAeQQFqNgIcIA0hASAZIQkgFiEIIAAhBgsgJSAVQQN2QQNxIDFqQQJ0aiAVNgIAAkAgDkGvAWogCUsEQCAMICsgDCArSRshIyARIQEgByEIIAshBiAMIRUMAQsgIUEBaiEhIBhBAksNACAMQQlqIXIgGEEBaiEYIAEhESAJIQ4gCCEHIAYhCyAVIQwgciAmSQ0BCwsCQAJ/IAggI0siB0UEQEEAIQAgFygCACIJIAhGDQJBASAXKAIEIgAgCEYNARogCEEDaiILIAlrIglBBk0EQEHoiNTLACAJQQJ0dkEPcQwCCyALIABrIgBBBk0EQEHOtez+ACAAQQJ0dkEPcQwCC0ECIBcoAgggCEYNARpBAyAXKAIMIAhGDQEaCyAIQQ9qCyEAIAcNACAARQ0AIBcgFygCCDYCDCAXIBcpAgA3AgQgFyAINgIACyAKKAI0IQcgCigCMCEJIA8gBiABQRl0cjYCBCAPICE2AgBBACENIAAgCUEQaiILTwRAIAAgCWtBASAHQQJqdGpBEGsiACAAIABnQR9zQQFrIgl2QQFxIg5BAnIgCXRrIAd2IQ0gAEF/IAd0QX9zcSALaiAOIAkgB2siAEEBdHJB/v8DaiAHdGogAEEKdHIhAAsgDyANNgIIIA8gADsBDiABIAZqIQECfyAhICFBBU0NABogIUGBAU0EQCAhQQJrIgdnQR9zQQFrIglBAXQgByAJdmpBAmoMAQsgIUHCAGtnQR9zQQpqICFBwRBNDQAaQRUgIUHCMEkNABpBFkEXICFBwrABSRsLIQcgAEH/B3EhCQJ/IAFBAmsgAUEJTQ0AGiABQYUBTQRAIAFBBmsiAGdBH3NBAWsiAUEBdCAAIAF2akEEagwBC0EXIAFBxRBLDQAaIAFBxgBrZ0Efc0EMagsiAUEHcSAHQQN0QThxciEAIA8CfwJAIAkNACAHQf//A3FBB0sNACABQf//A3EiCUEPSw0AIAAgAEHAAHIgCUEISRsMAQsgACAHQfj/A3FBA3ZBA2wgAUH4/wNxQQN2aiIAQQZ0QcCayAIgAEEBdHZBwAFxanJBQGsLOwEMIBsgGygCACAhajYCACAGIBVqIgwgKCAMIChJGyEHIBVBAmohACAGQQJ2IAhLBEAgByAAIAwgCEECdGsiASAAIAFLGyIAIAAgB0sbIQALIAZBAXQgLWogFWohCCAPQRBqIQ9BACEhIAAgB08NAiAAQQFqIQEgByAAa0EBcQRAICUgECAAIBRxaikAAEKAgIDo+7SNj71/fkIviKcgAEEDdkEDcWpBAnRqIAA2AgAgASEACyABIAdGDQIDQCAlIBAgACAUcWopAABCgICA6Pu0jY+9f35CL4inIABBA3ZBA3FqQQJ0aiAANgIAICUgAEEBaiIBQQN2QQNxIBAgASAUcWopAABCgICA6Pu0jY+9f35CL4inakECdGogATYCACAAQQJqIgAgB0cNAAsMAgsgJSAMQQN2QQNxIB5qQQJ0aiAMNgIACyAhQQFqISECQCAMQQFqIgAgCE0NACAIIC9qIABJBEAgACAMQRFqIgEgKiABICpJGyIBTw0BA0AgJSAQIAAgFHFqKQAAQoCAgOj7tI2PvX9+Qi+IpyAAQQN2QQNxakECdGogADYCACAhQQRqISEgAEEEaiIAIAFJDQALDAELIAAgDEEJaiIBICogASAqSRsiAU8NAANAICUgECAAIBRxaikAAEKAgIDo+7SNj71/fkIviKcgAEEDdkEDcWpBAnRqIAA2AgAgIUECaiEhIABBAmoiACABSQ0ACwsgACEMCyAMQQhqICZJDQALCyAaICEgJmogDGs2AgAgHCAcKAIAIA8gE2tBBHVqNgIADAYLIAAhGCAHIRMgBiEfIAsgEWohISAKKAIIIQYgCigCBCEHIAEiIygCACEmAkAgCCIaKAIQIgFBBUgNACAAIAAoAgAiAEEDajYCJCAYIABBA2s2AiAgGCAAQQJqNgIcIBggAEECazYCGCAYIABBAWo2AhQgGCAAQQFrNgIQIAFBC0kNACAYIBgoAgQiAEEDajYCPCAYIABBA2s2AjggGCAAQQJqNgI0IBggAEECazYCMCAYIABBAWo2AiwgGCAAQQFrNgIoCwJAICEgEUEEak0EQCATIRIMAQsgIUEDayIoIBEgC0EDSxshLUEBIAZ0QRBrIStBwABBgAQgB0EJSBsiMCARaiEVICFBBGshLiAwQQJ0ITogGkEwaiEnIBMhEgNAIBEgKyARICtJGyEPIBEgFHEhDSAhIBFrISUgJyAaKAIgQQF0aiEkIAooAjwhKkEAIQZBACEIQQAhG0GkCCEBIBooAhAiIARAIA0gEGoiCyAlaiIMQQRrIRZBACEXA0ACQCAYIBdBAnRqKAIAIgkgD0sNACARIAlrIgAgEU8NACANIBtqIgcgFEsNACAAIBRxIgAgG2oiDiAUSw0AIAcgEGotAAAgDiAQai0AAEcNACAAIBBqIRlBACEAAkAgFiALIgdJDQADQCAHKAAAIAAgGWooAABHDQEgAEEEaiEAIAdBBGoiByAWTQ0ACwsCQCAHIAxPDQAgByAMIAdrIg5qIR4gACAOaiFzA0AgACAZai0AACAHLQAARw0BIABBAWohACAHQQFqIgcgHkcNAAsgcyEACyAAQQJNBEAgF0EBSw0BIABBAkcNAQsgASAAQYcBbCIOQc8HaiIHTw0AIBcEQCAOQZCUByAXQQ5xdkEOcWtBqAdqIQcLIAEgB08NACAHIQEgCSEGIAAiCCEbCyAXQQFqIhcgIEcNAAsLICQgDSAQaiIMKAAAQb3P1vEBbCIWIBooAih2IgAgGigCCHRBAnRqIRkgGigCLCEgAkAgJyAAQQF0aiIxLwEAIgkgGigCJCI2ayIAQQAgACAJTRsiMiAJTw0AIAwgJWoiHkEEayEpIAkhFwNAIBEgGSAXQQFrIhcgIHFBAnRqKAIAIgBrIgsgD0sNAQJAIA0gG2oiByAUSw0AIAAgFHEiACAbaiIOIBRLDQAgByAQai0AACAOIBBqLQAARw0AIAAgEGohL0EAIQACQCApIAwiB0kNAANAIAcoAAAgACAvaigAAEcNASAAQQRqIQAgB0EEaiIHIClNDQALCwJAIAcgHk8NACAHIB4gB2siDmohNCAAIA5qIXQDQCAAIC9qLQAAIActAABHDQEgAEEBaiEAIAdBAWoiByA0Rw0ACyB0IQALIABBBEkNACABIAtnQR9zQWJsIABBhwFsakHAB2oiB08NACALIQYgACIIIRsgByEBCyAXIDJLDQALCyAZIAkgIHFBAnRqIBE2AgAgMSAJQQFqOwEAQQAhKQJAAkAgAUGkCEcNACAaKAIcIhsgGigCGCIXQQd2SQ0AIAooAlAiICAWQRB2Qfz/A3FqLwEAIQAgGiAXQQFqNgIYIA9BAWohGSAWQRF2IRZBpAghDUEAIQ8CQAJAIABFDQAgAEEfcSILICVLDQBBACEJAkAgCigCQCIOKAKkASAOIAtBAnRqKAIgIAsgAEEFdiIPbGpqIgAgC2oiB0EEayIeIABJDQADQCAAKAAAIAkgDGooAABHDQEgCUEEaiEJIABBBGoiACAeTQ0ACwsCQCAAIAdPDQAgACAHIABrIgdqIR4gByAJaiF1A0AgCSAMai0AACAALQAARw0BIAlBAWohCSAAQQFqIgAgHkcNAAsgdSEJCwJAIAlFDQAgCigCRCAJaiALTQ0AIA8gGWogCikDSCALIAlrIg9BBmytiKdBP3EgD0ECdGogCyAOai0AAHRqIgsgKksNACAJQYcBbCALZ0Efc0FibGpBwAdqIg5BpAhJDQAgGiAbQQFqIhs2AhwgDiENDAILQQAhDwsgASEOIAYhCyAIIQkLICAgFkEBdEECcmovAQAhASAaIBdBAmo2AhggAUUNASABQR9xIgYgJUsNAUEAIQACQCAKKAJAIggoAqQBIAggBkECdGooAiAgBiABQQV2IhdsamoiByAGaiIBQQRrIhYgB0kNAANAIAcoAAAgACAMaigAAEcNASAAQQRqIQAgB0EEaiIHIBZNDQALCwJAIAEgB00NACAHIAEgB2siAWohFiAAIAFqIXYDQCAAIAxqLQAAIActAABHDQEgAEEBaiEAIAdBAWoiByAWRw0ACyB2IQALIABFDQEgCigCRCAAaiAGTQ0BIBcgGWogCikDSCAGIABrIgFBBmytiKdBP3EgAUECdGogBiAIai0AAHRqIgYgKksNASAAQYcBbCAGZ0Efc0FibGpBwAdqIgggDUkNASAaIBtBAWo2AhwgASEPIAghDiAGIQsgACEJDAELQQAhDyABIQ4gBiELIAghCQsCQCAOQaUITwRAA0AgEUEBaiIbICsgGyArSRshIEEAIQYgCUEBayIAICVBAWsiJSAAICVJG0EAIAooAgRBBUgbIQEgFCAbcSEeAkAgGigCECIyRQRAQaQIIQ1BACEIDAELIBAgHmoiFSAlaiIZQQRrIS9BpAghDUEAIQhBACEXA0ACQCAYIBdBAnRqKAIAIgwgIEsNACAbIAxrIgAgG08NACABIB5qIgcgFEsNACAAIBRxIgAgAWoiFiAUSw0AIAcgEGotAAAgECAWai0AAEcNACAAIBBqITFBACEAAkAgLyAVIgdJDQADQCAHKAAAIAAgMWooAABHDQEgAEEEaiEAIAdBBGoiByAvTQ0ACwsCQCAHIBlPDQAgByAZIAdrIhZqITQgACAWaiF3A0AgACAxai0AACAHLQAARw0BIABBAWohACAHQQFqIgcgNEcNAAsgdyEACyAAQQJNBEAgF0EBSw0BIABBAkcNAQsgDSAAQYcBbCIWQc8HaiIHTw0AIBcEQCAWQZCUByAXQQ5xdkEOcWtBqAdqIQcLIAcgDU0NACAHIQ0gDCEGIAAiCCEBCyAXQQFqIhcgMkcNAAsLICQgECAeaiIZKAAAQb3P1vEBbCIvIBooAih2IgAgGigCCHRBAnRqITEgGigCLCEyAkAgJyAAQQF0aiI4LwEAIgwgNmsiAEEAIAAgDE0bIjkgDE8NACAZICVqIjRBBGshMyAMIRcDQCAbIDEgF0EBayIXIDJxQQJ0aigCACIAayIVICBLDQECQCABIB5qIgcgFEsNACAAIBRxIgAgAWoiFiAUSw0AIAcgEGotAAAgECAWai0AAEcNACAAIBBqITVBACEAAkAgMyAZIgdJDQADQCAHKAAAIAAgNWooAABHDQEgAEEEaiEAIAdBBGoiByAzTQ0ACwsCQCAHIDRPDQAgByA0IAdrIhZqITwgACAWaiF4A0AgACA1ai0AACAHLQAARw0BIABBAWohACAHQQFqIgcgPEcNAAsgeCEACyAAQQRJDQAgDSAVZ0Efc0FibCAAQYcBbGpBwAdqIgdPDQAgByENIBUhBiAAIgghAQsgFyA5Sw0ACwsgMSAMIDJxQQJ0aiAbNgIAIDggDEEBajsBAEEAIRUCQAJAIA1BpAhHDQAgGigCHCIeIBooAhgiF0EHdkkNACAKKAJQIjIgL0EQdkH8/wNxai8BACEBIBogF0EBajYCGCAgQQFqITEgL0ERdiE0QaQIIRYCQAJAIAFFDQAgAUEfcSIMICVLDQBBACEAAkAgCigCQCIvKAKkASAvIAxBAnRqKAIgIAwgAUEFdiIVbGpqIgcgDGoiAUEEayIzIAdJDQADQCAHKAAAIAAgGWooAABHDQEgAEEEaiEAIAdBBGoiByAzTQ0ACwsCQCABIAdNDQAgByABIAdrIgFqITMgACABaiF5A0AgACAZai0AACAHLQAARw0BIABBAWohACAHQQFqIgcgM0cNAAsgeSEACwJAIABFDQAgCigCRCAAaiAMTQ0AIBUgMWogCikDSCAMIABrIhVBBmytiKdBP3EgFUECdGogDCAvai0AAHRqIgwgKksNACAAQYcBbCAMZ0Efc0FibGpBwAdqIgFBpAhJDQAgGiAeQQFqIh42AhwgASEWDAILQQAhFQsgDSEBIAYhDCAIIQALIDIgNEEBdEECcmovAQAhBiAaIBdBAmo2AhggBkUNASAGQR9xIgggJUsNAUEAIQcCQCAKKAJAIg0oAqQBIA0gCEECdGooAiAgCCAGQQV2Ii9samoiFyAIaiIGQQRrIjIgF0kNAANAIBcoAAAgByAZaigAAEcNASAHQQRqIQcgF0EEaiIXIDJNDQALCwJAIAYgF00NACAXIAYgF2siBmohMiAGIAdqIXoDQCAHIBlqLQAAIBctAABHDQEgB0EBaiEHIBdBAWoiFyAyRw0ACyB6IQcLIAdFDQEgCigCRCAHaiAITQ0BIC8gMWogCikDSCAIIAdrIgZBBmytiKdBP3EgBkECdGogCCANai0AAHRqIgggKksNASAHQYcBbCAIZ0Efc0FibGpBwAdqIg0gFkkNASAaIB5BAWo2AhwgBiEVIA0hASAIIQwgByEADAELIA0hASAGIQwgCCEACwJAIA5BrwFqIAFLBEAgESArIBEgK0kbISAgDyEVIAshDCAJIQAgESEbDAELICZBAWohJiApQQJLDQAgEUEFaiF7IClBAWohKSAVIQ8gASEOIAwhCyAAIQkgGyERIHsgIUkNAQsLAkACfyAMICBLIgFFBEBBACEHIBgoAgAiBiAMRg0CQQEgGCgCBCIIIAxGDQEaIAxBA2oiByAGayIGQQZNBEBB6IjUywAgBkECdHZBD3EMAgsgByAIayIGQQZNBEBBzrXs/gAgBkECdHZBD3EMAgtBAiAYKAIIIAxGDQEaQQMgGCgCDCAMRg0BGgsgDEEPagshByABDQAgB0UNACAYKQIEIbYBIBggGCgCACIBNgIEIBggtgE3AgggGCAMNgIAIBooAhAiBkEFSA0AIBggDEEDajYCJCAYIAxBA2s2AiAgGCAMQQJqNgIcIBggDEECazYCGCAYIAxBAWo2AhQgGCAMQQFrNgIQIAZBC0kNACAYIAFBA2o2AjwgGCABQQNrNgI4IBggAUECajYCNCAYIAFBAms2AjAgGCABQQFqNgIsIBggAUEBazYCKAsgCigCNCEBIAooAjAhBiASIAAgFUEZdHI2AgQgEiAmNgIAQQAhICAHIAZBEGoiCU8EQCAHIAZrQQEgAUECanRqQRBrIgYgBiAGZ0Efc0EBayIIdkEBcSIHQQJyIAh0ayABdiEgIAZBfyABdEF/c3EgCWogByAIIAFrIgZBAXRyQf7/A2ogAXRqIAZBCnRyIQcLIBIgIDYCCCASIAc7AQ4gACAVaiEBAn8gJiAmQQVNDQAaICZBgQFNBEAgJkECayIGZ0Efc0EBayIIQQF0IAYgCHZqQQJqDAELICZBwgBrZ0Efc0EKaiAmQcEQTQ0AGkEVICZBwjBJDQAaQRZBFyAmQcKwAUkbCyEGIAdB/wdxIQcCfyABQQJrIAFBCU0NABogAUGFAU0EQCABQQZrIgFnQR9zQQFrIghBAXQgASAIdmpBBGoMAQtBFyABQcUQSw0AGiABQcYAa2dBH3NBDGoLIghBB3EgBkEDdEE4cXIhASASAn8CQCAHDQAgBkH//wNxQQdLDQAgCEH//wNxIgdBD0sNACABIAFBwAByIAdBCEkbDAELIAEgBkH4/wNxQQN2QQNsIAhB+P8DcUEDdmoiAUEGdEHAmsgCIAFBAXR2QcABcWpyQUBrCzsBDCAfIB8oAgAgJmo2AgAgACAbaiIRIC0gESAtSRshASAbQQJqIQcgAEEBdCAwaiAbaiEVIBJBEGohEkEAISYgAEECdiAMSwRAIAEgByARIAxBAnRrIgAgACAHSRsiACAAIAFLGyEHCyABIAdNDQEgJyAaKAIgQQF0aiEAA0AgACAQIAcgFHFqKAAAQb3P1vEBbCAaKAIodiIGIBooAgh0ICcgBkEBdGoiBi8BACIIIBooAixxakECdGogBzYCACAGIAhBAWo7AQAgB0EBaiIHIAFHDQALDAELICZBAWohJgJAIBFBAWoiACAVTQ0AIBUgOmogAEkEQCAAIBFBEWoiASAuIAEgLkkbIgFPDQEDQCAkIBAgACAUcWooAABBvc/W8QFsIBooAih2IgYgGigCCHQgJyAGQQF0aiIGLwEAIgggGigCLHFqQQJ0aiAANgIAIAYgCEEBajsBACAmQQRqISYgAEEEaiIAIAFJDQALDAELIAAgEUEJaiIBICggASAoSRsiAU8NAANAICQgECAAIBRxaigAAEG9z9bxAWwgGigCKHYiBiAaKAIIdCAnIAZBAXRqIgYvAQAiCCAaKAIscWpBAnRqIAA2AgAgBiAIQQFqOwEAICZBAmohJiAAQQJqIgAgAUkNAAsLIAAhEQsgEUEEaiAhSQ0ACwsgIyAhICZqIBFrNgIAIBwgHCgCACASIBNrQQR1ajYCAAwFCyAAIRggByETIAYhHyALIBFqISsgCigCCCEGIAooAgQhByABIiMoAgAhIAJAIAgiGigCECIBQQVIDQAgACAAKAIAIgBBA2o2AiQgGCAAQQNrNgIgIBggAEECajYCHCAYIABBAms2AhggGCAAQQFqNgIUIBggAEEBazYCECABQQtJDQAgGCAYKAIEIgBBA2o2AjwgGCAAQQNrNgI4IBggAEECajYCNCAYIABBAms2AjAgGCAAQQFqNgIsIBggAEEBazYCKAsCQCArIBFBCGpNBEAgEyESDAELICtBB2siJCARIAtBB0sbIS1BASAGdEEQayEmQcAAQYAEIAdBCUgbIjAgEWohFSAwQQJ0ITMgGkFAayEnIBMhEgNAIBEgJiARICZJGyEPIBEgFHEhDSArIBFrISEgJyAaKAIgQQF0aiEpIAooAjwhKEEAIQZBACEIQQAhG0GkCCEBIBooAhAiJQRAIA0gEGoiCyAhaiIMQQRrIRZBACEXA0ACQCAYIBdBAnRqKAIAIgkgD0sNACARIAlrIgAgEU8NACANIBtqIgcgFEsNACAAIBRxIgAgG2oiDiAUSw0AIAcgEGotAAAgDiAQai0AAEcNACAAIBBqIRlBACEAAkAgFiALIgdJDQADQCAHKAAAIAAgGWooAABHDQEgAEEEaiEAIAdBBGoiByAWTQ0ACwsCQCAHIAxPDQAgByAMIAdrIg5qIR4gACAOaiF8A0AgACAZai0AACAHLQAARw0BIABBAWohACAHQQFqIgcgHkcNAAsgfCEACyAAQQJNBEAgF0EBSw0BIABBAkcNAQsgASAAQYcBbCIOQc8HaiIHTw0AIBcEQCAOQZCUByAXQQ5xdkEOcWtBqAdqIQcLIAEgB08NACAHIQEgCSEGIAAiCCEbCyAXQQFqIhcgJUcNAAsLICkgGikDMCK2ASANIBBqIgwpAACDQtO33pq9z9bxH34gGjUCKIinIgAgGigCCHRBAnRqIRYgGigCOCEZAkAgJyAAQQF0aiIuLwEAIgkgGigCJCI1ayIAQQAgACAJTRsiLyAJTw0AIAwgIWoiJUEEayEeIAkhFwNAIBEgFiAXQQFrIhcgGXFBAnRqKAIAIgBrIgsgD0sNAQJAIA0gG2oiByAUSw0AIAAgFHEiACAbaiIOIBRLDQAgByAQai0AACAOIBBqLQAARw0AIAAgEGohKkEAIQACQCAeIAwiB0kNAANAIAcoAAAgACAqaigAAEcNASAAQQRqIQAgB0EEaiIHIB5NDQALCwJAIAcgJU8NACAHICUgB2siDmohMSAAIA5qIX0DQCAAICpqLQAAIActAABHDQEgAEEBaiEAIAdBAWoiByAxRw0ACyB9IQALIABBBEkNACABIAtnQR9zQWJsIABBhwFsakHAB2oiB08NACALIQYgACIIIRsgByEBCyAXIC9LDQALCyAWIAkgGXFBAnRqIBE2AgAgLiAJQQFqOwEAQQAhJQJAAkAgAUGkCEcNACAaKAIcIhsgGigCGCIXQQd2SQ0AIAooAlAiGSAMKAAAQb3P1vEBbCIHQRB2Qfz/A3FqLwEAIQAgGiAXQQFqNgIYIA9BAWohFiAHQRF2IR5BpAghDUEAIQ8CQAJAIABFDQAgAEEfcSILICFLDQBBACEJAkAgCigCQCIOKAKkASAOIAtBAnRqKAIgIAsgAEEFdiIPbGpqIgAgC2oiB0EEayIqIABJDQADQCAAKAAAIAkgDGooAABHDQEgCUEEaiEJIABBBGoiACAqTQ0ACwsCQCAAIAdPDQAgACAHIABrIgdqISogByAJaiF+A0AgCSAMai0AACAALQAARw0BIAlBAWohCSAAQQFqIgAgKkcNAAsgfiEJCwJAIAlFDQAgCigCRCAJaiALTQ0AIA8gFmogCikDSCALIAlrIg9BBmytiKdBP3EgD0ECdGogCyAOai0AAHRqIgsgKEsNACAJQYcBbCALZ0Efc0FibGpBwAdqIg5BpAhJDQAgGiAbQQFqIhs2AhwgDiENDAILQQAhDwsgASEOIAYhCyAIIQkLIBkgHkEBdEECcmovAQAhASAaIBdBAmo2AhggAUUNASABQR9xIgYgIUsNAUEAIQACQCAKKAJAIggoAqQBIAggBkECdGooAiAgBiABQQV2IhdsamoiByAGaiIBQQRrIhkgB0kNAANAIAcoAAAgACAMaigAAEcNASAAQQRqIQAgB0EEaiIHIBlNDQALCwJAIAEgB00NACAHIAEgB2siAWohGSAAIAFqIX8DQCAAIAxqLQAAIActAABHDQEgAEEBaiEAIAdBAWoiByAZRw0ACyB/IQALIABFDQEgCigCRCAAaiAGTQ0BIBYgF2ogCikDSCAGIABrIgFBBmytiKdBP3EgAUECdGogBiAIai0AAHRqIgYgKEsNASAAQYcBbCAGZ0Efc0FibGpBwAdqIgggDUkNASAaIBtBAWo2AhwgASEPIAghDiAGIQsgACEJDAELQQAhDyABIQ4gBiELIAghCQsCQCAOQaUITwRAA0AgEUEBaiIbICYgGyAmSRshKkEAIQYgCUEBayIAICFBAWsiISAAICFJG0EAIAooAgRBBUgbIQEgFCAbcSEeAkAgGigCECIxRQRAQaQIIQ1BACEIDAELIBAgHmoiFSAhaiIZQQRrIS5BpAghDUEAIQhBACEXA0ACQCAYIBdBAnRqKAIAIgwgKksNACAbIAxrIgAgG08NACABIB5qIgcgFEsNACAAIBRxIgAgAWoiFiAUSw0AIAcgEGotAAAgECAWai0AAEcNACAAIBBqIS9BACEAAkAgLiAVIgdJDQADQCAHKAAAIAAgL2ooAABHDQEgAEEEaiEAIAdBBGoiByAuTQ0ACwsCQCAHIBlPDQAgByAZIAdrIhZqITIgACAWaiGAAQNAIAAgL2otAAAgBy0AAEcNASAAQQFqIQAgB0EBaiIHIDJHDQALIIABIQALIABBAk0EQCAXQQFLDQEgAEECRw0BCyANIABBhwFsIhZBzwdqIgdPDQAgFwRAIBZBkJQHIBdBDnF2QQ5xa0GoB2ohBwsgByANTQ0AIAchDSAMIQYgACIIIQELIBdBAWoiFyAxRw0ACwsgKSAQIB5qIhkpAAAgtgGDQtO33pq9z9bxH34gGjUCKIinIgAgGigCCHRBAnRqIS4gGigCOCEvAkAgJyAAQQF0aiI6LwEAIgwgNWsiAEEAIAAgDE0bIjYgDE8NACAZICFqIjFBBGshMiAMIRcDQCAbIC4gF0EBayIXIC9xQQJ0aigCACIAayIVICpLDQECQCABIB5qIgcgFEsNACAAIBRxIgAgAWoiFiAUSw0AIAcgEGotAAAgECAWai0AAEcNACAAIBBqITRBACEAAkAgMiAZIgdJDQADQCAHKAAAIAAgNGooAABHDQEgAEEEaiEAIAdBBGoiByAyTQ0ACwsCQCAHIDFPDQAgByAxIAdrIhZqITggACAWaiGBAQNAIAAgNGotAAAgBy0AAEcNASAAQQFqIQAgB0EBaiIHIDhHDQALIIEBIQALIABBBEkNACANIBVnQR9zQWJsIABBhwFsakHAB2oiB08NACAHIQ0gFSEGIAAiCCEBCyAXIDZLDQALCyAuIAwgL3FBAnRqIBs2AgAgOiAMQQFqOwEAQQAhFQJAAkAgDUGkCEcNACAaKAIcIh4gGigCGCIXQQd2SQ0AIAooAlAiMSAZKAAAQb3P1vEBbCIAQRB2Qfz/A3FqLwEAIQEgGiAXQQFqNgIYICpBAWohLiAAQRF2ITJBpAghFgJAAkAgAUUNACABQR9xIgwgIUsNAEEAIQACQCAKKAJAIi8oAqQBIC8gDEECdGooAiAgDCABQQV2IhVsamoiByAMaiIBQQRrIjQgB0kNAANAIAcoAAAgACAZaigAAEcNASAAQQRqIQAgB0EEaiIHIDRNDQALCwJAIAEgB00NACAHIAEgB2siAWohNCAAIAFqIYIBA0AgACAZai0AACAHLQAARw0BIABBAWohACAHQQFqIgcgNEcNAAsgggEhAAsCQCAARQ0AIAooAkQgAGogDE0NACAVIC5qIAopA0ggDCAAayIVQQZsrYinQT9xIBVBAnRqIAwgL2otAAB0aiIMIChLDQAgAEGHAWwgDGdBH3NBYmxqQcAHaiIBQaQISQ0AIBogHkEBaiIeNgIcIAEhFgwCC0EAIRULIA0hASAGIQwgCCEACyAxIDJBAXRBAnJqLwEAIQYgGiAXQQJqNgIYIAZFDQEgBkEfcSIIICFLDQFBACEHAkAgCigCQCINKAKkASANIAhBAnRqKAIgIAggBkEFdiIvbGpqIhcgCGoiBkEEayIxIBdJDQADQCAXKAAAIAcgGWooAABHDQEgB0EEaiEHIBdBBGoiFyAxTQ0ACwsCQCAGIBdNDQAgFyAGIBdrIgZqITEgBiAHaiGDAQNAIAcgGWotAAAgFy0AAEcNASAHQQFqIQcgF0EBaiIXIDFHDQALIIMBIQcLIAdFDQEgCigCRCAHaiAITQ0BIC4gL2ogCikDSCAIIAdrIgZBBmytiKdBP3EgBkECdGogCCANai0AAHRqIgggKEsNASAHQYcBbCAIZ0Efc0FibGpBwAdqIg0gFkkNASAaIB5BAWo2AhwgBiEVIA0hASAIIQwgByEADAELIA0hASAGIQwgCCEACwJAIA5BrwFqIAFLBEAgESAmIBEgJkkbISogDyEVIAshDCAJIQAgESEbDAELICBBAWohICAlQQJLDQAgEUEJaiGEASAlQQFqISUgFSEPIAEhDiAMIQsgACEJIBshESCEASArSQ0BCwsCQAJ/IAwgKksiAUUEQEEAIQcgGCgCACIGIAxGDQJBASAYKAIEIgggDEYNARogDEEDaiIHIAZrIgZBBk0EQEHoiNTLACAGQQJ0dkEPcQwCCyAHIAhrIgZBBk0EQEHOtez+ACAGQQJ0dkEPcQwCC0ECIBgoAgggDEYNARpBAyAYKAIMIAxGDQEaCyAMQQ9qCyEHIAENACAHRQ0AIBgpAgQhtgEgGCAYKAIAIgE2AgQgGCC2ATcCCCAYIAw2AgAgGigCECIGQQVIDQAgGCAMQQNqNgIkIBggDEEDazYCICAYIAxBAmo2AhwgGCAMQQJrNgIYIBggDEEBajYCFCAYIAxBAWs2AhAgBkELSQ0AIBggAUEDajYCPCAYIAFBA2s2AjggGCABQQJqNgI0IBggAUECazYCMCAYIAFBAWo2AiwgGCABQQFrNgIoCyAKKAI0IQEgCigCMCEGIBIgACAVQRl0cjYCBCASICA2AgBBACEqIAcgBkEQaiIJTwRAIAcgBmtBASABQQJqdGpBEGsiBiAGIAZnQR9zQQFrIgh2QQFxIgdBAnIgCHRrIAF2ISogBkF/IAF0QX9zcSAJaiAHIAggAWsiBkEBdHJB/v8DaiABdGogBkEKdHIhBwsgEiAqNgIIIBIgBzsBDiAAIBVqIQECfyAgICBBBU0NABogIEGBAU0EQCAgQQJrIgZnQR9zQQFrIghBAXQgBiAIdmpBAmoMAQsgIEHCAGtnQR9zQQpqICBBwRBNDQAaQRUgIEHCMEkNABpBFkEXICBBwrABSRsLIQYgB0H/B3EhBwJ/IAFBAmsgAUEJTQ0AGiABQYUBTQRAIAFBBmsiAWdBH3NBAWsiCEEBdCABIAh2akEEagwBC0EXIAFBxRBLDQAaIAFBxgBrZ0Efc0EMagsiCEEHcSAGQQN0QThxciEBIBICfwJAIAcNACAGQf//A3FBB0sNACAIQf//A3EiB0EPSw0AIAEgAUHAAHIgB0EISRsMAQsgASAGQfj/A3FBA3ZBA2wgCEH4/wNxQQN2aiIBQQZ0QcCayAIgAUEBdHZBwAFxanJBQGsLOwEMIB8gHygCACAgajYCACAAIBtqIhEgLSARIC1JGyEBIBtBAmohByAAQQF0IDBqIBtqIRUgEkEQaiESQQAhICAAQQJ2IAxLBEAgASAHIBEgDEECdGsiACAAIAdJGyIAIAAgAUsbIQcLIAEgB00NASAnIBooAiBBAXRqIQAgGikDMCG2AQNAIAAgECAHIBRxaikAACC2AYNC07femr3P1vEffiAaNQIoiKciBiAaKAIIdCAnIAZBAXRqIgYvAQAiCCAaKAI4cWpBAnRqIAc2AgAgBiAIQQFqOwEAIAdBAWoiByABRw0ACwwBCyAgQQFqISACQCARQQFqIgAgFU0NACAVIDNqIABJBEAgACARQRFqIgEgJCABICRJGyIBTw0BA0AgKSAQIAAgFHFqKQAAILYBg0LTt96avc/W8R9+IBo1AiiIpyIGIBooAgh0ICcgBkEBdGoiBi8BACIIIBooAjhxakECdGogADYCACAGIAhBAWo7AQAgIEEEaiEgIABBBGoiACABSQ0ACwwBCyAAIBFBCWoiASAkIAEgJEkbIgFPDQADQCApIBAgACAUcWopAAAgtgGDQtO33pq9z9bxH34gGjUCKIinIgYgGigCCHQgJyAGQQF0aiIGLwEAIgggGigCOHFqQQJ0aiAANgIAIAYgCEEBajsBACAgQQJqISAgAEECaiIAIAFJDQALCyAAIRELIBFBCGogK0kNAAsLICMgICAraiARazYCACAcIBwoAgAgEiATa0EEdWo2AgAMBAsgCCEZIAAhHyAHIRIgBiEhIAEiKygCACEoAkAgCyARIg1qIi4gDUEEak0EQCAHIRoMAQsgLkEDayIyIA0gC0EDSxshNEEBIAooAgh0QRBrIS8gLkEEayEzQcAAQYAEIAooAgRBCUgbIjVBAnQhPCAZQaCAEGohMCAZQSBqISkgDSA1aiEJIBIhGgNAIBAgDSAUcSIlaiIOIC4gDWsiJGoiEUEEayEPIA4oAABBvc/W8QFsQRF2IRVBACEBAn8CQCAfKAIAIgcgDSAvIA0gL0kbIhNLDQBBpAghCEEAIA0gB2siACANTw0BGiAQIAAgFHFqIQhBACEAAkAgDyAOIgZJDQADQCAGKAAAIAAgCGooAABHDQEgAEEEaiEAIAZBBGoiBiAPTQ0ACwsCQCAGIBFPDQAgBiARIAZrIgFqIQsgACABaiGFAQNAIAAgCGotAAAgBi0AAEcNASAAQQFqIQAgBkEBaiIGIAtHDQALIIUBIQALQQAhASAAQQJJDQBBpAghCEEAIABBhwFsQc8HaiIGQaUISQ0BGiAGIQggByEBIAAMAQtBpAghCEEACyEHIAooAjwhFwJAIBVB/wFxIhsgKSANIB8oAgQiC2siAEH//wNxakGAgAxqLQAARw0AIAsgE0sNACAAIA1PDQAgECAAIBRxaiEWQQAhAAJAIA8gDiIGSQ0AA0AgBigAACAAIBZqKAAARw0BIABBBGohACAGQQRqIgYgD00NAAsLAkAgBiARTw0AIAYgESAGayIMaiEYIAAgDGohhgEDQCAAIBZqLQAAIAYtAABHDQEgAEEBaiEAIAZBAWoiBiAYRw0ACyCGASEACyAAQQJJDQAgCCAAQYcBbCIGQc8Hak8NACAIIAZBqAdqIgZPDQAgBiEIIAshASAAIQcLAkAgKSANIB8oAggiC2siAEH//wNxakGAgAxqLQAAIBtHDQAgCyATSw0AIAAgDU8NACAQIAAgFHFqIRZBACEAAkAgDyAOIgZJDQADQCAGKAAAIAAgFmooAABHDQEgAEEEaiEAIAZBBGoiBiAPTQ0ACwsCQCAGIBFPDQAgBiARIAZrIgxqIRggACAMaiGHAQNAIAAgFmotAAAgBi0AAEcNASAAQQFqIQAgBkEBaiIGIBhHDQALIIcBIQALIABBAkkNACAIIABBhwFsIgZBzwdqTw0AIAggBkGkB2oiBk8NACAGIQggCyEBIAAhBwsCQCApIA0gHygCDCILayIAQf//A3FqQYCADGotAAAgG0cNACALIBNLDQAgACANTw0AIBAgACAUcWohG0EAIQACQCAPIA4iBkkNAANAIAYoAAAgACAbaigAAEcNASAAQQRqIQAgBkEEaiIGIA9NDQALCwJAIAYgEU8NACAGIBEgBmsiDGohFiAAIAxqIYgBA0AgACAbai0AACAGLQAARw0BIABBAWohACAGQQFqIgYgFkcNAAsgiAEhAAsgAEECSQ0AIAggAEGHAWwiBkHPB2pPDQAgCCAGQaQHaiIGTw0AIAYhCCALIQEgACEHC0EAIQsgGSgCpIAgIichFiApIBVBAXQiIGpBgIAIaiIeLwEAIiYhBiANICkgFUECdGoiKigCAGsiGyEAAkAgJ0UNAANAIAAgC2oiCyATSw0BIDAgBkH//wNxQQJ0aiEYAkAgByAlaiIAIBRLDQAgDSALayAUcSIGIAdqIgwgFEsNACAAIBBqLQAAIAwgEGotAABHDQAgBiAQaiEjQQAhAAJAIA8gDiIGSQ0AA0AgBigAACAAICNqKAAARw0BIABBBGohACAGQQRqIgYgD00NAAsLAkAgBiARTw0AIAYgESAGayIMaiEtIAAgDGohiQEDQCAAICNqLQAAIAYtAABHDQEgAEEBaiEAIAZBAWoiBiAtRw0ACyCJASEACyAAQQRJDQAgCCALZ0Efc0FibCAAQYcBbGpBwAdqIgZPDQAgBiEIIAshASAAIQcLIBgvAQAhACAYLwECIQYgFkEBayIWDQALCyAZIBkvAaCAICIAQQFqIhg7AaCAICApIA1B//8DcWpBgIAMaiAVOgAAIDAgAEECdGoiBiAmOwECIAZB//8DIBsgG0H//wNPGzsBACAqIA02AgAgHiAAOwEAQQAhGwJAAkAgCEGkCEcNACAZKAIcIgsgGSgCGCIWQQd2SQ0AIAooAlAiIyAVQf7/AXFBAXRqLwEAIQAgGSAWQQFqNgIYIBNBAWohFUGkCCERAkACQCAARQ0AIABBH3EiDyAkSw0AQQAhDAJAIAooAkAiEygCpAEgEyAPQQJ0aigCICAPIABBBXYiG2xqaiIAIA9qIgZBBGsiJSAASQ0AA0AgACgAACAMIA5qKAAARw0BIAxBBGohDCAAQQRqIgAgJU0NAAsLAkAgACAGTw0AIAAgBiAAayIGaiElIAYgDGohigEDQCAMIA5qLQAAIAAtAABHDQEgDEEBaiEMIABBAWoiACAlRw0ACyCKASEMCwJAIAxFDQAgCigCRCAMaiAPTQ0AIBUgG2ogCikDSCAPIAxrIhtBBmytiKdBP3EgG0ECdGogDyATai0AAHRqIhMgF0sNACAMQYcBbCATZ0Efc0FibGpBwAdqIg9BpAhJDQAgGSALQQFqIgs2AhwgDyERDAILQQAhGwsgCCEPIAEhEyAHIQwLICMgIEECcmovAQAhASAZIBZBAmo2AhggAUUNASABQR9xIgggJEsNAUEAIQACQCAKKAJAIgcoAqQBIAcgCEECdGooAiAgCCABQQV2IhZsamoiBiAIaiIBQQRrIiMgBkkNAANAIAYoAAAgACAOaigAAEcNASAAQQRqIQAgBkEEaiIGICNNDQALCwJAIAEgBk0NACAGIAEgBmsiAWohIyAAIAFqIYsBA0AgACAOai0AACAGLQAARw0BIABBAWohACAGQQFqIgYgI0cNAAsgiwEhAAsgAEUNASAKKAJEIABqIAhNDQEgFSAWaiAKKQNIIAggAGsiAUEGbK2Ip0E/cSABQQJ0aiAHIAhqLQAAdGoiBiAXSw0BIABBhwFsIAZnQR9zQWJsakHAB2oiCCARSQ0BIBkgC0EBajYCHCABIRsgCCEPIAYhEyAAIQwMAQsgCCEPIAEhEyAHIQwLAkACQCAPQaUITwRAIB8oAgwhIyAfKAIIISUgHygCBCEgIB8oAgAhHkEAISoDQCAMQQFrIgAgJEEBayIkIAAgJEkbQQAgCigCBEEFSBshESAQIA1BAWoiByAUcSJDaiIVICRqIhdBBGshLSAVKAAAQb3P1vEBbEERdiExQaQIIQ4CQAJAIB4gByAvIAcgL0kbIiZLDQAgByAeayIAIAdPDQAgECAAIBRxaiEIQQAhAAJAIC0gFSIGSQ0AA0AgBigAACAAIAhqKAAARw0BIABBBGohACAGQQRqIgYgLU0NAAsLAkAgBiAXTw0AIAYgFyAGayIBaiEJIAAgAWohjAEDQCAAIAhqLQAAIAYtAABHDQEgAEEBaiEAIAZBAWoiBiAJRw0ACyCMASEAC0EAIQkgAEECSQRAQQAhAQwCC0EAIQEgAEGHAWxBzwdqIgZBpQhJDQEgBiEOIB4hCSAAIgEhEQwBC0EAIQlBACEBCyAKKAI8IToCQCAxQf8BcSILICkgByAgayIAQf//A3FqQYCADGotAABHDQAgICAmSw0AIAAgB08NACAQIAAgFHFqIRZBACEAAkAgLSAVIgZJDQADQCAGKAAAIAAgFmooAABHDQEgAEEEaiEAIAZBBGoiBiAtTQ0ACwsCQCAGIBdPDQAgBiAXIAZrIghqITYgACAIaiGNAQNAIAAgFmotAAAgBi0AAEcNASAAQQFqIQAgBkEBaiIGIDZHDQALII0BIQALIABBAkkNACAOIABBhwFsIgZBzwdqTw0AIA4gBkGoB2oiBk8NACAGIQ4gICEJIAAiASERCwJAICkgByAlayIAQf//A3FqQYCADGotAAAgC0cNACAlICZLDQAgACAHTw0AIBAgACAUcWohFkEAIQACQCAtIBUiBkkNAANAIAYoAAAgACAWaigAAEcNASAAQQRqIQAgBkEEaiIGIC1NDQALCwJAIAYgF08NACAGIBcgBmsiCGohNiAAIAhqIY4BA0AgACAWai0AACAGLQAARw0BIABBAWohACAGQQFqIgYgNkcNAAsgjgEhAAsgAEECSQ0AIA4gAEGHAWwiBkHPB2pPDQAgDiAGQaQHaiIGTw0AIAYhDiAlIQkgACIBIRELAkAgKSAHICNrIgBB//8DcWpBgIAMai0AACALRw0AICMgJksNACAAIAdPDQAgECAAIBRxaiELQQAhAAJAIC0gFSIGSQ0AA0AgBigAACAAIAtqKAAARw0BIABBBGohACAGQQRqIgYgLU0NAAsLAkAgBiAXTw0AIAYgFyAGayIIaiEWIAAgCGohjwEDQCAAIAtqLQAAIAYtAABHDQEgAEEBaiEAIAZBAWoiBiAWRw0ACyCPASEACyAAQQJJDQAgDiAAQYcBbCIGQc8Hak8NACAOIAZBpAdqIgZPDQAgBiEOICMhCSAAIgEhEQtBACELICkgMUEBdCJEakGAgAhqIkgvAQAiSSEGIAcgKSAxQQJ0aiJKKAIAayI2IQACQCAnIhZFDQADQCAAIAtqIgsgJksNASAwIAZB//8DcUECdGohOAJAIBEgQ2oiACAUSw0AIAcgC2sgFHEiBiARaiIIIBRLDQAgACAQai0AACAIIBBqLQAARw0AIAYgEGohOUEAIQACQCAtIBUiBkkNAANAIAYoAAAgACA5aigAAEcNASAAQQRqIQAgBkEEaiIGIC1NDQALCwJAIAYgF08NACAGIBcgBmsiCGohSyAAIAhqIZABA0AgACA5ai0AACAGLQAARw0BIABBAWohACAGQQFqIgYgS0cNAAsgkAEhAAsgAEEESQ0AIA4gC2dBH3NBYmwgAEGHAWxqQcAHaiIGTw0AIAYhDiALIQkgACIBIRELIDgvAQAhACA4LwECIQYgFkEBayIWDQALCyAZIBhBAWoiFjsBoIAgICkgB0H//wNxakGAgAxqIDE6AAAgMCAYQf//A3FBAnRqIgAgSTsBAiAAQf//AyA2IDZB//8DTxs7AQAgSiAHNgIAIEggGDsBAEEAIRcCQAJAIA5BpAhHDQAgGSgCHCIYIBkoAhgiLUEHdkkNACAKKAJQIjggMUH+/wFxQQF0ai8BACEGIBkgLUEBajYCGCAmQQFqITFBpAghCAJAAkAgBkUNACAGQR9xIhEgJEsNAEEAIQACQCAKKAJAIjYoAqQBIDYgEUECdGooAiAgESAGQQV2IhdsamoiBiARaiILQQRrIjkgBkkNAANAIAYoAAAgACAVaigAAEcNASAAQQRqIQAgBkEEaiIGIDlNDQALCwJAIAYgC08NACAGIAsgBmsiC2ohOSAAIAtqIZEBA0AgACAVai0AACAGLQAARw0BIABBAWohACAGQQFqIgYgOUcNAAsgkQEhAAsCQCAARQ0AIAooAkQgAGogEU0NACAXIDFqIAopA0ggESAAayIXQQZsrYinQT9xIBdBAnRqIBEgNmotAAB0aiIRIDpLDQAgAEGHAWwgEWdBH3NBYmxqQcAHaiILQaQISQ0AIBkgGEEBaiIYNgIcIAshCAwCC0EAIRcLIA4hCyAJIREgASEACyA4IERBAnJqLwEAIQEgGSAtQQJqNgIYIAFFDQEgAUEfcSIJICRLDQFBACEGAkAgCigCQCItKAKkASAtIAlBAnRqKAIgIAkgAUEFdiI2bGpqIg4gCWoiAUEEayI4IA5JDQADQCAOKAAAIAYgFWooAABHDQEgBkEEaiEGIA5BBGoiDiA4TQ0ACwsCQCABIA5NDQAgDiABIA5rIgFqITggASAGaiGSAQNAIAYgFWotAAAgDi0AAEcNASAGQQFqIQYgDkEBaiIOIDhHDQALIJIBIQYLIAZFDQEgCigCRCAGaiAJTQ0BIDEgNmogCikDSCAJIAZrIgFBBmytiKdBP3EgAUECdGogCSAtai0AAHRqIgkgOksNASAIIAZBhwFsIAlnQR9zQWJsakHAB2oiDksNASAZIBhBAWo2AhwgASEXIA4hCyAJIREgBiEADAELIA4hCyAJIREgASEACwJAIA9BrwFqIAtLBEAgDSAvIA0gL0kbISYgGyEXIBMhESAMIQAgDSEHDAELIChBAWohKCAqQQJLDQAgDUEFaiGTASAqQQFqISogFiEYIBchGyALIQ8gESETIAAhDCAHIQ0gkwEgLkkNAQsLAkACfyARICZLIgFFBEBBACEGIB8oAgAiCCARRg0CQQEgHygCBCIGIBFGDQEaIBFBA2oiCSAIayIIQQZNBEBB6IjUywAgCEECdHZBD3EMAgsgCSAGayIGQQZNBEBBzrXs/gAgBkECdHZBD3EMAgtBAiAfKAIIIBFGDQEaQQMgHygCDCARRg0BGgsgEUEPagshBiABDQAgBkUNACAfIB8oAgg2AgwgHyAfKQIANwIEIB8gETYCAAsgCigCNCEBIAooAjAhCCAaIAAgF0EZdHI2AgQgGiAoNgIAQQAhFiAGIAhBEGoiCU8EQCAGIAhrQQEgAUECanRqQRBrIgYgBiAGZ0Efc0EBayIIdkEBcSILQQJyIAh0ayABdiEWIAZBfyABdEF/c3EgCWogCyAIIAFrIgZBAXRyQf7/A2ogAXRqIAZBCnRyIQYLIBogFjYCCCAaIAY7AQ4gACAXaiEBAn8gKCAoQQVNDQAaIChBgQFNBEAgKEECayIIZ0Efc0EBayIJQQF0IAggCXZqQQJqDAELIChBwgBrZ0Efc0EKaiAoQcEQTQ0AGkEVIChBwjBJDQAaQRZBFyAoQcKwAUkbCyEIIAZB/wdxIQkCfyABQQJrIAFBCU0NABogAUGFAU0EQCABQQZrIgFnQR9zQQFrIgZBAXQgASAGdmpBBGoMAQtBFyABQcUQSw0AGiABQcYAa2dBH3NBDGoLIgZBB3EgCEEDdEE4cXIhASAaAn8CQCAJDQAgCEH//wNxQQdLDQAgBkH//wNxIglBD0sNACABIAFBwAByIAlBCEkbDAELIAEgCEH4/wNxQQN2QQNsIAZB+P8DcUEDdmoiBkEGdEHAmsgCIAZBAXR2QcABcWpyQUBrCzsBDCAhICEoAgAgKGo2AgAgACAHaiINIDQgDSA0SRshASAHQQJqIQYgAEEBdCA1aiAHaiEJIBpBEGohGkEAISggAEECdiARSwRAIAEgBiANIBFBAnRrIgAgACAGSRsiACAAIAFLGyEGCyABIAZNDQIgGS8BoIAgIRgDQCApIBAgBiAUcWooAABBvc/W8QFsQRF2IgBBAnRqIggoAgAhByApIAZB//8DcWpBgIAMaiAAOgAAIDAgGEH//wNxQQJ0aiILQf//AyAGIAdrIgcgB0H//wNPGzsBACALICkgAEEBdGpBgIAIaiIALwEAOwECIAggBjYCACAAIBg7AQAgGEEBaiEYIAZBAWoiBiABRw0ACwwBCyAoQQFqISggCSANQQFqIgBPBEAgACENDAILAkAgCSA8aiAASQRAIA1BEWoiASAzIAEgM0kbIgYgAE0EQCAAIQ0MBAsDQCApIBAgACAUcWooAABBvc/W8QFsQRF2IgFBAnRqIggoAgAhByApIABB//8DcWpBgIAMaiABOgAAIDAgGEH//wNxQQJ0aiILQf//AyAAIAdrIgcgB0H//wNPGzsBACALICkgAUEBdGpBgIAIaiIBLwEAOwECIAggADYCACABIBg7AQAgKEEEaiEoIBhBAWohGCAAQQRqIgAgBkkNAAsMAQsgDUEJaiIBIDIgASAySRsiBiAATQRAIAAhDQwDCwNAICkgECAAIBRxaigAAEG9z9bxAWxBEXYiAUECdGoiCCgCACEHICkgAEH//wNxakGAgAxqIAE6AAAgMCAYQf//A3FBAnRqIgtB//8DIAAgB2siByAHQf//A08bOwEAIAsgKSABQQF0akGAgAhqIgEvAQA7AQIgCCAANgIAIAEgGDsBACAoQQJqISggGEEBaiEYIABBAmoiACAGSQ0ACwsgACENCyAZIBg7AaCAIAsgDUEEaiAuSQ0ACwsgKyAoIC5qIA1rNgIAIBwgHCgCACAaIBJrQQR1ajYCAAwDCyAIIRggByEPIAYhIyAKKAIEIQYgASIgKAIAISQgCigCCCEBIAAiHyAAKAIAIgBBA2o2AiQgHyAAQQNrNgIgIB8gAEECajYCHCAfIABBAms2AhggHyAAQQFqNgIUIB8gAEEBazYCEAJAIAsgESIHaiIoIAdBBGpNBEAgDyEXDAELIChBA2siLiAHIAtBA0sbIS9BASABdEEQayEtIChBBGshMUHAAEGABCAGQQlIGyIyQQJ0ITogGEGggBBqISkgGEEgaiEnIAcgMmohKyAPIRcDQCAQIAcgFHEiKmoiEyAoIAdrIiZqIhVBBGshEiAHIC0gByAtSRshGyATKAAAQb3P1vEBbEERdiENIAooAjwhHkEAIQxBpAghBkEAIQFBpAghEUEAIRZBACEJA0AgByAfIAlBAnRqKAIAIgtrIQACQCAJBEAgJyAAQf//A3FqQYCADGotAAAgDUH/AXFHDQELIAsgG0sNACAAIAdPDQAgECAAIBRxaiEaQQAhAAJAIBIgEyIISQ0AA0AgCCgAACAAIBpqKAAARw0BIABBBGohACAIQQRqIgggEk0NAAsLAkAgCCAVTw0AIAggFSAIayIOaiEZIAAgDmohlAEDQCAAIBpqLQAAIAgtAABHDQEgAEEBaiEAIAhBAWoiCCAZRw0ACyCUASEACyAAQQJJDQAgESAAQYcBbCIOQc8HaiIITw0AIAkEQCAOQZCUByAJQQ5xdkEOcWtBqAdqIQgLIAggEU0NACALIQwgACIBIRYgCCIGIRELIAlBAWoiCUEKRw0AC0EAIQkgGCgCpIAgIiUhGiAnIA1BAXQiMGpBgIAIaiI0LwEAIjMhCCAHICcgDUECdGoiNSgCAGsiDiEAAkAgJUUNAANAIAAgCWoiCSAbSw0BICkgCEH//wNxQQJ0aiEZAkAgFiAqaiIAIBRLDQAgByAJayAUcSIIIBZqIgsgFEsNACAAIBBqLQAAIAsgEGotAABHDQAgCCAQaiEhQQAhAAJAIBIgEyIISQ0AA0AgCCgAACAAICFqKAAARw0BIABBBGohACAIQQRqIgggEk0NAAsLAkAgCCAVTw0AIAggFSAIayILaiE2IAAgC2ohlQEDQCAAICFqLQAAIAgtAABHDQEgAEEBaiEAIAhBAWoiCCA2Rw0ACyCVASEACyAAQQRJDQAgESAJZ0Efc0FibCAAQYcBbGpBwAdqIghPDQAgCSEMIAAiASEWIAgiBiERCyAZLwEAIQAgGS8BAiEIIBpBAWsiGg0ACwsgGCAYLwGggCAiAEEBaiIZOwGggCAgJyAHQf//A3FqQYCADGogDToAACApIABBAnRqIgggMzsBAiAIQf//AyAOIA5B//8DTxs7AQAgNSAHNgIAIDQgADsBAEEAISECQAJAIBFBpAhHDQAgGCgCHCIJIBgoAhgiEUEHdkkNACAKKAJQIhogDUH+/wFxQQF0ai8BACEAIBggEUEBajYCGCAbQQFqIRJBpAghFkEAIRUCQAJAIABFDQAgAEEfcSIOICZLDQBBACELAkAgCigCQCINKAKkASANIA5BAnRqKAIgIA4gAEEFdiIVbGpqIgAgDmoiCEEEayIbIABJDQADQCAAKAAAIAsgE2ooAABHDQEgC0EEaiELIABBBGoiACAbTQ0ACwsCQCAAIAhPDQAgACAIIABrIghqIRsgCCALaiGWAQNAIAsgE2otAAAgAC0AAEcNASALQQFqIQsgAEEBaiIAIBtHDQALIJYBIQsLAkAgC0UNACAKKAJEIAtqIA5NDQAgEiAVaiAKKQNIIA4gC2siFUEGbK2Ip0E/cSAVQQJ0aiANIA5qLQAAdGoiDiAeSw0AIAtBhwFsIA5nQR9zQWJsakHAB2oiDUGkCEkNACAYIAlBAWoiCTYCHCANIRYMAgtBACEVCyAGIQ0gDCEOIAEhCwsgGiAwQQJyai8BACEBIBggEUECajYCGCABRQ0BIAFBH3EiBiAmSw0BQQAhAAJAIAooAkAiDCgCpAEgDCAGQQJ0aigCICAGIAFBBXYiEWxqaiIIIAZqIgFBBGsiGyAISQ0AA0AgCCgAACAAIBNqKAAARw0BIABBBGohACAIQQRqIgggG00NAAsLAkAgASAITQ0AIAggASAIayIBaiEbIAAgAWohlwEDQCAAIBNqLQAAIAgtAABHDQEgAEEBaiEAIAhBAWoiCCAbRw0ACyCXASEACyAARQ0BIAooAkQgAGogBk0NASARIBJqIAopA0ggBiAAayIBQQZsrYinQT9xIAFBAnRqIAYgDGotAAB0aiIGIB5LDQEgAEGHAWwgBmdBH3NBYmxqQcAHaiIIIBZJDQEgGCAJQQFqNgIcIAEhFSAIIQ0gBiEOIAAhCwwBC0EAIRUgBiENIAwhDiABIQsLAkACQCANQaUITwRAA0AgB0EBaiIaIC0gGiAtSRshKkEAIQYgC0EBayIAICZBAWsiJiAAICZJG0EAIAooAgRBBUgbIREgECAUIBpxIjZqIhsgJmoiHkEEayEwIBsoAABBvc/W8QFsQRF2ISsgCigCPCE0QaQIIRNBACEBQQAhCQNAIBogHyAJQQJ0aigCACIMayEAAkAgCQRAICcgAEH//wNxakGAgAxqLQAAICtB/wFxRw0BCyAMICpLDQAgACAaTw0AIBAgACAUcWohFkEAIQACQCAwIBsiCEkNAANAIAgoAAAgACAWaigAAEcNASAAQQRqIQAgCEEEaiIIIDBNDQALCwJAIAggHk8NACAIIB4gCGsiEmohMyAAIBJqIZgBA0AgACAWai0AACAILQAARw0BIABBAWohACAIQQFqIgggM0cNAAsgmAEhAAsgAEECSQ0AIBMgAEGHAWwiEkHPB2oiCE8NACAJBEAgEkGQlAcgCUEOcXZBDnFrQagHaiEICyAIIBNNDQAgCCETIAwhBiAAIgEhEQsgCUEBaiIJQQpHDQALQQAhCSAnICtBAXQiOGpBgIAIaiI5LwEAIjwhCCAaICcgK0ECdGoiQygCAGsiEiEAAkAgJSIWRQ0AA0AgACAJaiIJICpLDQEgKSAIQf//A3FBAnRqITMCQCARIDZqIgAgFEsNACAaIAlrIBRxIgggEWoiDCAUSw0AIAAgEGotAAAgDCAQai0AAEcNACAIIBBqITVBACEAAkAgMCAbIghJDQADQCAIKAAAIAAgNWooAABHDQEgAEEEaiEAIAhBBGoiCCAwTQ0ACwsCQCAIIB5PDQAgCCAeIAhrIgxqIUQgACAMaiGZAQNAIAAgNWotAAAgCC0AAEcNASAAQQFqIQAgCEEBaiIIIERHDQALIJkBIQALIABBBEkNACATIAlnQR9zQWJsIABBhwFsakHAB2oiCE8NACAIIRMgCSEGIAAiASERCyAzLwEAIQAgMy8BAiEIIBZBAWsiFg0ACwsgGCAZQQFqIh47AaCAICAnIBpB//8DcWpBgIAMaiArOgAAICkgGUH//wNxQQJ0aiIAIDw7AQIgAEH//wMgEiASQf//A08bOwEAIEMgGjYCACA5IBk7AQBBACESAkACQCATQaQIRw0AIBgoAhwiFiAYKAIYIhlBB3ZJDQAgCigCUCIzICtB/v8BcUEBdGovAQAhCCAYIBlBAWo2AhggKkEBaiErQaQIIQwCQAJAIAhFDQAgCEEfcSIRICZLDQBBACEAAkAgCigCQCIwKAKkASAwIBFBAnRqKAIgIBEgCEEFdiISbGpqIgggEWoiCUEEayI1IAhJDQADQCAIKAAAIAAgG2ooAABHDQEgAEEEaiEAIAhBBGoiCCA1TQ0ACwsCQCAIIAlPDQAgCCAJIAhrIglqITUgACAJaiGaAQNAIAAgG2otAAAgCC0AAEcNASAAQQFqIQAgCEEBaiIIIDVHDQALIJoBIQALAkAgAEUNACAKKAJEIABqIBFNDQAgEiAraiAKKQNIIBEgAGsiEkEGbK2Ip0E/cSASQQJ0aiARIDBqLQAAdGoiESA0Sw0AIABBhwFsIBFnQR9zQWJsakHAB2oiCUGkCEkNACAYIBZBAWoiFjYCHCAJIQwMAgtBACESCyATIQkgBiERIAEhAAsgMyA4QQJyai8BACEBIBggGUECajYCGCABRQ0BIAFBH3EiEyAmSw0BQQAhCAJAIAooAkAiGSgCpAEgGSATQQJ0aigCICATIAFBBXYiMGxqaiIGIBNqIgFBBGsiMyAGSQ0AA0AgBigAACAIIBtqKAAARw0BIAhBBGohCCAGQQRqIgYgM00NAAsLAkAgASAGTQ0AIAYgASAGayIBaiEzIAEgCGohmwEDQCAIIBtqLQAAIAYtAABHDQEgCEEBaiEIIAZBAWoiBiAzRw0ACyCbASEICyAIRQ0BIAooAkQgCGogE00NASArIDBqIAopA0ggEyAIayIBQQZsrYinQT9xIAFBAnRqIBMgGWotAAB0aiIGIDRLDQEgDCAIQYcBbCAGZ0Efc0FibGpBwAdqIhNLDQEgGCAWQQFqNgIcIAEhEiATIQkgBiERIAghAAwBCyATIQkgBiERIAEhAAsCQCANQa8BaiAJSwRAIAcgLSAHIC1JGyEqIBUhEiAOIREgCyEAIAchGgwBCyAkQQFqISQgIUECSw0AIAdBBWohnAEgIUEBaiEhIB4hGSASIRUgCSENIBEhDiAAIQsgGiEHIJwBIChJDQELCwJAAn8gESAqSyIBRQRAQQAhCCAfKAIAIgYgEUYNAkEBIB8oAgQiCCARRg0BGiARQQNqIgcgBmsiBkEGTQRAQeiI1MsAIAZBAnR2QQ9xDAILIAcgCGsiBkEGTQRAQc617P4AIAZBAnR2QQ9xDAILQQIgHygCCCARRg0BGkEDIB8oAgwgEUYNARoLIBFBD2oLIQggAQ0AIAhFDQAgHyAfKAIINgIMIB8gHykCADcCBCAfIBE2AgAgHyARQQNqNgIkIB8gEUEDazYCICAfIBFBAmo2AhwgHyARQQJrNgIYIB8gEUEBajYCFCAfIBFBAWs2AhALIAooAjQhASAKKAIwIQYgFyAAIBJBGXRyNgIEIBcgJDYCAEEAIRYgCCAGQRBqIgdPBEAgCCAGa0EBIAFBAmp0akEQayIGIAYgBmdBH3NBAWsiCHZBAXEiCUECciAIdGsgAXYhFiAGQX8gAXRBf3NxIAdqIAkgCCABayIGQQF0ckH+/wNqIAF0aiAGQQp0ciEICyAXIBY2AgggFyAIOwEOIAAgEmohAQJ/ICQgJEEFTQ0AGiAkQYEBTQRAICRBAmsiBmdBH3NBAWsiB0EBdCAGIAd2akECagwBCyAkQcIAa2dBH3NBCmogJEHBEE0NABpBFSAkQcIwSQ0AGkEWQRcgJEHCsAFJGwshBiAIQf8HcSEHAn8gAUECayABQQlNDQAaIAFBhQFNBEAgAUEGayIBZ0Efc0EBayIIQQF0IAEgCHZqQQRqDAELQRcgAUHFEEsNABogAUHGAGtnQR9zQQxqCyIIQQdxIAZBA3RBOHFyIQEgFwJ/AkAgBw0AIAZB//8DcUEHSw0AIAhB//8DcSIHQQ9LDQAgASABQcAAciAHQQhJGwwBCyABIAZB+P8DcUEDdkEDbCAIQfj/A3FBA3ZqIgFBBnRBwJrIAiABQQF0dkHAAXFqckFAaws7AQwgIyAjKAIAICRqNgIAIAAgGmoiByAvIAcgL0kbIQEgGkECaiEIIABBAXQgMmogGmohKyAXQRBqIRdBACEkIABBAnYgEUsEQCABIAggByARQQJ0ayIAIAAgCEkbIgAgACABSxshCAsgASAITQ0CIBgvAaCAICEZA0AgJyAQIAggFHFqKAAAQb3P1vEBbEERdiIAQQJ0aiIGKAIAIQkgJyAIQf//A3FqQYCADGogADoAACApIBlB//8DcUECdGoiC0H//wMgCCAJayIJIAlB//8DTxs7AQAgCyAnIABBAXRqQYCACGoiAC8BADsBAiAGIAg2AgAgACAZOwEAIBlBAWohGSAIQQFqIgggAUcNAAsMAQsgJEEBaiEkICsgB0EBaiIATwRAIAAhBwwCCwJAICsgOmogAEkEQCAHQRFqIgEgMSABIDFJGyIGIABNBEAgACEHDAQLA0AgJyAQIAAgFHFqKAAAQb3P1vEBbEERdiIBQQJ0aiIIKAIAIQcgJyAAQf//A3FqQYCADGogAToAACApIBlB//8DcUECdGoiCUH//wMgACAHayIHIAdB//8DTxs7AQAgCSAnIAFBAXRqQYCACGoiAS8BADsBAiAIIAA2AgAgASAZOwEAICRBBGohJCAZQQFqIRkgAEEEaiIAIAZJDQALDAELIAdBCWoiASAuIAEgLkkbIgYgAE0EQCAAIQcMAwsDQCAnIBAgACAUcWooAABBvc/W8QFsQRF2IgFBAnRqIggoAgAhByAnIABB//8DcWpBgIAMaiABOgAAICkgGUH//wNxQQJ0aiIJQf//AyAAIAdrIgcgB0H//wNPGzsBACAJICcgAUEBdGpBgIAIaiIBLwEAOwECIAggADYCACABIBk7AQAgJEECaiEkIBlBAWohGSAAQQJqIgAgBkkNAAsLIAAhBwsgGCAZOwGggCALIAdBBGogKEkNAAsLICAgJCAoaiAHazYCACAcIBwoAgAgFyAPa0EEdWo2AgAMAgsgCCEZIAchEyAGIR8gCigCBCEGIAEiJSgCACEhIAooAgghASAAIhggACgCACIAQQNqNgIkIBggAEEDazYCICAYIABBAmo2AhwgGCAAQQJrNgIYIBggAEEBajYCFCAYIABBAWs2AhAgGCAYKAIEIgBBA2o2AjwgGCAAQQNrNgI4IBggAEECajYCNCAYIABBAms2AjAgGCAAQQFqNgIsIBggAEEBazYCKAJAIAsgEWoiJyARQQRqTQRAIAchGgwBCyAnQQNrIi4gESALQQNLGyEvQQEgAXRBEGshKyAnQQRrITFBwABBgAQgBkEJSBsiMkECdCE6IBlBIGohHiARIDJqISMgEyEaA0AgECARIBRxIjBqIgwgJyARayImaiIXQQRrISAgESArIBEgK0kbISQgDCgAAEG9z9bxAWxBEXYhDyAKKAI8ISlBACEGQaQIIQdBACEIQaQIIRJBACEWQQAhCQNAIBEgGCAJQQJ0aigCACILayEAAkAgCQRAIB4gAEH//wNxakGAgAxqLQAAIA9B/wFxRw0BCyALICRLDQAgACARTw0AIBAgACAUcWohDUEAIQACQCAgIAwiAUkNAANAIAEoAAAgACANaigAAEcNASAAQQRqIQAgAUEEaiIBICBNDQALCwJAIAEgF08NACABIBcgAWsiDmohFSAAIA5qIZ0BA0AgACANai0AACABLQAARw0BIABBAWohACABQQFqIgEgFUcNAAsgnQEhAAsgAEECSQ0AIBIgAEGHAWwiDkHPB2oiAU8NACAJBEAgDkGQlAcgCUEOcXZBDnFrQagHaiEBCyABIBJNDQAgCyEGIAAiCCEWIAEiByESCyAJQQFqIglBEEcNAAsgD0H/A3EhKiARIB4gD0ECdGoiNCgCAGshCyAeIA9BAXQiM2pBgIAIaiI1LwEAIQ4CQCAZKAKgiFAiG0UNACAeICpBC3RqQYCAEGohNkEAIQkgGyEVIA4hASALIQADQCAAIAlqIgkgJEsNASA2IAFB//8DcUECdGohKAJAIBYgMGoiACAUSw0AIBEgCWsgFHEiASAWaiINIBRLDQAgACAQai0AACANIBBqLQAARw0AIAEgEGohLUEAIQACQCAgIAwiAUkNAANAIAEoAAAgACAtaigAAEcNASAAQQRqIQAgAUEEaiIBICBNDQALCwJAIAEgF08NACABIBcgAWsiDWohOCAAIA1qIZ4BA0AgACAtai0A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QQN2QQNxakECdGogATYCACAAIQELIAAgBkYNAQNAIBogECABIBRxaikAAEKA+p6t46Pv0zV+QiyIpyABQQN2QQNxakECdGogATYCACAaIAFBAWoiAEEDdkEDcSAQIAAgFHFqKQAAQoD6nq3jo+/TNX5CLIinakECdGogADYCACABQQJqIgEgBkcNAAsMAQsgH0EBaiEfAkAgDEEBaiIBICVNDQAgJSAtaiABSQRAIAEgDEERaiIAICsgACArSRsiAE8NAQNAIBogECABIBRxaikAAEKA+p6t46Pv0zV+QiyIpyABQQN2QQNxakECdGogATYCACAfQQRqIR8gAUEEaiIBIABJDQALDAELIAEgDEEJaiIAICsgACArSRsiAE8NAANAIBogECABIBRxaikAAEKA+p6t46Pv0zV+QiyIpyABQQN2QQNxakECdGogATYCACAfQQJqIR8gAUECaiIBIABJDQALCyABIQwLIAxBCGogIUkNAAsLIBsgHyAhaiAMazYCACAcIBwoAgAgESAVa0EEdWo2AgALCyAKKQNwIbYBIAooAgwhACAKKAIIIQEgCikDsAEhtwEgChAvQQAhByAKKAIEQQNMBEAgCigCoAEgCigCpAFqQf7fAEshBwsCQCA3IEFyDQAgBw0AQQFBFyABIAAgACABSBsiACAAQRdOG0EBanQiACC2ASC3AX2nQQEgCigCDHRqSQ0AIABBA3YiACAKKAKkAU0NACAcKAIAIABPDQAgCikDuAEitgGnIQAgtgFCgICAgAxaBEAgAEEBdEEBdUGAgICAfHEgAEH/////A3FyQYCAgIB4cyEACyAKKQNwIrYBpyEBIAogtgE3A7gBAkAgtgFCgICAgAxaBH8gAUEBdEEBdUGAgICAfHEgAUH/////A3FyQYCAgIB4cwUgAQsgAE8NACAKKAJsIgBFDQAgAEEANgIUCyA7QQA2AgAMAQsgCigCqAEiAARAIAogCigCoAEiAUEBajYCoAEgCigCnAEiBiABQQR0IghqIgFBEDsBDiABQoCAgMAANwIEIAEgADYCACAGIAhqAn8gACAAQQVNDQAaIABBgQFNBEAgAEECayIBZ0Efc0EBayIGQQF0IAEgBnZqQQJqDAELIABBwgBrZ0Efc0EKaiAAQcEQTQ0AGkEVIABBwjBJDQAaQRZBFyAAQcKwAUkbCyIB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ACAAQbAWaiILIAApA7gGNwMAICAgACkDkAY3AwAgACBHNwOIFiAAIEg3A4AWIABBgBZqIg9BwAAgAEGAFWoQGCAAIB8pAwg3A4gEIAAgHykDADcDgAQgDiAeKQMINwOYBCAOIB4pAwA3A5AEIA4gHSkDCDcDqAQgDiAdKQMANwOgBCAOIABBqBVqKQMANwPYBCAOIABBoBVqKQMANwPQBCAOIABBmBVqKQMANwPIBCAOIABBkBVqKQMANwPABCAOIAApA4gVNwO4BCAOIAApA4AVNwOwBCAOIBwpAwA3A+AEIA4gHCkDCDcD6AQgDiAbKQMANwPwBCAOIBspAwg3A/gEIBpBwAAgExAYICBCADcDACALQgA3AwAgDEIANwMAIBBCADcDACAKQgA3AwAgBUIANwMAIAAgACkDqAY3A4AXIABCADcDiBYgACAAKQOYBjcDgBYgACAAKQOgBjcDwBYgACAAKQOwBjcDwBcgACAAKQO4BjcDgBkgACAALQCABjoAgBcgACAALQCIBjoAgBggACAALQCQBjoAwBkgACAALQCBBjoAiBcgACAALQCJBjoAiBggACAALQCRBjoAyBkgACAALQCCBjoAkBcgACAALQCKBjoAkBggACAALQCSBjoA0BkgACAALQCDBjoAmBcgACAALQCLBjoAmBggACAALQCTBjoA2BkgACAALQCEBjoAoBcgACAALQCMBjoAoBggACAALQCUBjoA4BkgACAALQCFBjoAqBcgACAALQCNBjoAqBggACAALQCVBjoA6BkgACAALQCGBjoAsBcgACAALQCOBjoAsBggACAALQCWBjoA8BkgACAALQCHBjoAuBcgACAALQCPBjoAuBggACAALQCXBjoA+BkgD0HABSAEIAggCRAaIBpBwAAgBCAIIAkQGiAGDQEgCCgCACEEQQAhCiAHIQUDQCAWIApBAnRqKAIAIhBB/wFxIgYgAEGABmpqLQAAIQwgCSAEQQN2aiILIAsxAAAgAEGABGogBkEBdGozAQAgBEEHca2GhDcAACAIIAQgDGoiBDYCACAJIARBA3ZqIgwgDDEAACAQQQh2IhCtIARBB3GthoQ3AAAgCCAGQQJ0IgtBkPUBaigCACAEaiIENgIAAkAgBkEXSw0AQQAhDCALQZD5AWooAgAgEGoiBkUNAANAIAUtAAAiECAAQYAT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KQMANwPwBCAOIBspAwg3A/gEIBpBwAAgExAYICBCADcDACALQgA3AwAgDEIANwMAIBBCADcDACAKQgA3AwAgBUIANwMAIAAgACkDqAY3A4AXIABCADcDiBYgACAAKQOYBjcDgBYgACAAKQOgBjcDwBYgACAAKQOwBjcDwBcgACAAKQO4BjcDgBkgACAALQCABjoAgBcgACAALQCIBjoAgBggACAALQCQBjoAwBkgACAALQCBBjoAiBcgACAALQCJBjoAiBggACAALQCRBjoAyBkgACAALQCCBjoAkBcgACAALQCKBjoAkBggACAALQCSBjoA0BkgACAALQCDBjoAmBcgACAALQCLBjoAmBggACAALQCTBjoA2BkgACAALQCEBjoAoBcgACAALQCMBjoAoBggACAALQCUBjoA4BkgACAALQCFBjoAqBcgACAALQCNBjoAqBggACAALQCVBjoA6BkgACAALQCGBjoAsBcgACAALQCOBjoAsBggACAALQCWBjoA8BkgACAALQCHBjoAuBcgACAALQCPBjoAuBggACAALQCXBjoA+BkgD0HABSAEIAggCRAaIBpBwAAgBCAIIAkQGiAGDQEgCCgCACEEQQAhCiAHIQUDQCAWIApBAnRqKAIAIhBB/wFxIgYgAEGABmpqLQAAIQwgCSAEQQN2aiILIAsxAAAgAEGABGogBkEBdGozAQAgBEEHca2GhDcAACAIIAQgDGoiBDYCACAJIARBA3ZqIgwgDDEAACAQQQh2IhCtIARBB3GthoQ3AAAgCCAGQQJ0IgtBkPUBaigCACAEaiIENgIAAkAgBkEXSw0AQQAhDCALQZD5AWooAgAgEGoiBkUNAANAIAUtAAAiECAAQYATamotAAAhCyAJIARBA3ZqIg8gDzEAACAAQYAPaiAQQQF0ajMBACAEQQdxrYaENwAAIAggBCALaiIENgIAIAVBAWohBSAMQQFqIgwgBkcNAAsLIApBAWoiCiARRw0ACwwBCyAJIARBA3ZqIgAgADEAADcAACAIIARBAWoiADYCACAJIABBA3ZqIgUgBTEAAEEEQQUgFUGBgARJGyIFQQRrrSAAQQdxrYaENwAAIAggBEEDaiIANgIAIAkgAEEDdmoiBCAEMQAAIBRBAWutIABBB3GthoQ3AAAgCCAAIAVBAnRqIgA2AgAgCSAAQQN2aiIE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IAwgE2ooAABHDQEgDEEEaiEMIApBBGoiCiAVTQ0ACwsCQCAKIBJPDQAgCiASIAprIhBqIRsgDCAQaiEpA0AgDCATai0AACAKLQAARw0BIAxBAWohDCAKQQFqIgogG0cNAAsgKSEMCyAMIA9NDQAgESAZNgIAIBEgDEEFdDYCBCARQQhqIREgDCEPCyANQQFrIg0gGE0NASAPQQNJDQALCwJAIA8gF08NACAgKAIAIhkgDnFBAXQhFSAgIAMgHGooAABBvc/W8QFsQQ12Qfz/H3FqIggoAgQhEiAXQYABSSIYRQRAIAggDjYCBAsgFUEBciEbAn8CQCAOIBJGDQAgF0GAASAYGyEiQQAhEEHAACENQQAhEwNAIA4gEmsiJyAaSw0BIA1FDQEgAyATIBAgECATSxsiHiAcamohHUEAIQoCQCADIB4gBCAScSIoamoiDCAXIB5raiIIQQRrIiQgDEkNAANAIAwoAAAgCiAdaigAAEcNASAKQQRqIQogDEEEaiIMICRNDQALCwJAIAggDE0NACAMIAggDGsiCGohJCAIIApqISoDQCAKIB1qLQAAIAwtAABHDQEgCkEBaiEKIAxBAWoiDCAkRw0ACyAqIQoLIAogHmohCAJAIBFFBEBBACERDAELIAggD00NACARICc2AgAgESAIQQV0NgIEIBFBCGohESAIIQ8LIAggIk8EQCAYDQQgFiAVQQJ0aiAWIBIgGXFBA3RqIggoAgA2AgAgCEEEagwDCyANQQFrIQ0gFgJ/IAMgCCAcamotAAAgAyAIIChqai0AAEsEQCAYRQRAIBYgFUECdGogEjYCAAsgCCETIBIgGXFBAXRBAXIiFQwBCyAYRQRAIBYgG0ECdGogEjYCAAsgCCEQIBIgGXFBAXQiGwtBAnRqKAIAIhIgDkcNAAsLIBgNASAWIBVBAnRqIB8oAgA2AgAgHwshCCAWIBtBAnRqIAgoAgA2AgALIAtC//////D///8PNwOQMSALQv/////w////DzcDiDEgC0L/////8P///w83A4AxIAtC//////D///8PNwP4MCALQv/////w////DzcD8DAgC0L/////8P///w83A+gwIAtC//////D///8PNwPgMCALQv/////w////DzcD2DAgC0L/////8P///w83A9AwIAtC//////D///8PNwPIMCALQv/////w////DzcDwDAgC0L/////8P///w83A7gwIAtC//////D///8PNwOwMCALQv/////w////DzcDqDAgC0L/////8P///w83A6AwIAtC//////D///8PNwOYMCALQv/////w////DzcDkDAgC0L/////8P///w83A4gwIAtC//////D///8PNwOAMAJAICYgAyAcakEEIA9BAWoiCCAIQQRNGyIKIBcgC0GAMGoQX0UNACAKQSUgFyAXQSVPGyIPSw0AIBpBAWohDQNAAkAgC0GAMGogCiIIQQJ0aigCACIKQf7///8ASw0AIA0gCkEFdmoiDCAFKAI8Sw0AIBEgDDYCACARIAhBBXQgCkEfcSIKQQAgCCAKRxtyNgIEIBFBCGohEQsgCEEBaiEKIAggD0cNAAsLIAEgAiAUIAMgBCAFIAYgBwJ/QQAgCyARRg0AGiARIAtrQQN1ICUgEUEIayIIQQRyKAIAQQV2Tw0AGiALIAgpAwA3AwBBAQsiCCALIAtB7BlqIAtBiBhqIAkQcyIKQQAgCkGAgAFPGyEVIAhBAUYEQCALKAIEQQV2IgggFSAIIBVLGyAVIAggJUsbIRULAkAgFUECSQRAIBQhDAwBCwJAIA5BAWoiESAOIBVqIgggIyAIICNJGyIcQT9rIA5BQGsgHEsbIgggDkGBBGpJDQAgCCARTQ0AICAoAgAiGEEPayEeA0AgICADIAQgEXEiGWooAABBvc/W8QFsQQ12Qfz/H3FqIgooAgQhEiAKIBE2AgQgESAYcUEBdCIXQQFyIRMCfwJAIBEgEkYNAEEAIQ1BwAAhD0EAIRADQCARIBJrIB5LDQEgD0UNASADIBAgDSANIBBLGyIaIBlqaiEbQQAhCgJAIAMgGiAEIBJxIh1qaiIMQYABIBpraiIOQQRrIiIgDEkNAANAIAwoAAAgCiAbaigAAEcNASAKQQRqIQogDEEEaiIMICJNDQALCwJAIAwgDk8NACAMIA4gDGsiDmohIiAKIA5qISsDQCAKIBtqLQAAIAwtAABHDQEgCkEBaiEKIAxBAWoiDCAiRw0ACyArIQoLIAogGmoiDEGAAU8EQCAWIBdBAnRqIBYgEiAYcUEDdGoiCigCADYCACAKQQRqDAMLIBIgGHFBAXQhCgJAIAMgDCAZamotAAAgAyAMIB1qai0AAEsEQCAWIBdBAnRqIBI2AgAgDCEQIApBAXIiFyEKDAELIBYgE0ECdGogEjYCACAMIQ0gCiETCyAPQQFrIQ8gFiAKQQJ0aigCACISIBFHDQALCyAWIBdBAnRqIB8oAgA2AgAgHwshCiAWIBNBAnRqIAooAgA2AgAgEUEIaiIRIAhJDQALCyAIIBxJBEAgICgCACIXQQ9rIRsDQCAgIAMgBCAIcSIaaigAAEG9z9bxAWxBDXZB/P8fcWoiCigCBCESIAogCDYCBCAIIBdxQQF0IhNBAXIhEAJ/AkAgCCASRg0AQQAhD0HAACERQQAhDQNAIAggEmsgG0sNASARRQ0BIAMgDSAPIA0gD0kbIhggGmpqIRlBACEKAkAgAyAYIAQgEnEiHmpqIgxBgAEgGGtqIg5BBGsiHSAMSQ0AA0AgDCgAACAKIBlqKAAARw0BIApBBGohCiAMQQRqIgwgHU0NAAsLAkAgDCAOTw0AIAwgDiAMayIOaiEdIAogDmohLANAIAogGWotAAAgDC0AAEcNASAKQQFqIQogDEEBaiIMIB1HDQALICwhCgsgCiAYaiIMQYABTwRAIBYgE0ECdGogFiASIBdxQQN0aiIKKAIANgIAIApBBGoMAwsgEiAXcUEBdCEKAkAgAyAMIBpqai0AACADIAwgHmpqLQAASwRAIBYgE0ECdGogEjYCACAMIQ0gCkEBciITIQoMAQsgFiAQQQJ0aiASNgIAIAwhDyAKIRALIBFBAWshESAWIApBAnRqKAIAIhIgCEcNAAsLIBYgE0ECdGogHygCADYCACAfCyEKIBYgEEECdGogCigCADYCACAIQQFqIgggHEkNAAsLIAsoAugZIQ8CQCAVQQFrIhJFBEAgDyENIBQhDAwBCyALKAL0LyERA0AgFEEBaiEMIAEgFEEEak0EQCAPIQ0MAgsgCSAMQQR0aiIIKgIMIS0gCAJ/QQAgDEUNABogCCgCCCEKIAgoAgBB////D3EhDQJAIAgoAgQiCCAGSw0AIAggDWogAiAMaksNACAMIAhBD2ogCkEbdkEBayAKQYCAgMAASRsNARoLIAkgDCANIApB////P3Fqa0EEdGooAgwLIgo2AgwCQCAtIBEgDEECdGoqAgAgESoCAJMiLl9FBEAgDyENDAELIAsgDDYCpDEgCyAtOAK8MSALIC0gLpM4ArgxAkACQCAKRQRAQQAhDQwBCyAJIApBBHRqIggoAgghDSAIKAIAIRAgCyAIKAIENgKoMUEBIQgCf0EEIAkgCiANQf///z9xIBBB////D3Fqa0EEdGooAgwiCkUNABogCSAKQQR0aiINKAIIIRAgDSgCACEUIAsgDSgCBDYCrDFBCCAJIAogEEH///8/cSAUQf///w9xamtBBHRqKAIMIgpFDQAaIAkgCkEEdGoiDSgCCCEQIA0oAgAhFCALIA0oAgQ2ArAxQQwgCSAKIBBB////P3EgFEH///8PcWprQQR0aigCDCIKRQ0AGiALIAkgCkEEdGooAgQ2ArQxQQAhCEEQCyENIAhFDQELIAsgDWpBqDFqIAdBECANaxAUGgsgC0GIGGoiCCAPQQdxIhBBB3NBHGxqIgogCykCpDE3AgAgCiALQbwxaigCADYCGCAKIAtBtDFqKQIANwIQIAogC0GsMWopAgA3AggCQCAPQQFqIg1BAkkNACAKKgIUQQggEGtBB3FBHGwgCGoiCCoCFF4EQCALQZgwaiIUIAooAhg2AgAgC0GQMGoiEyAKKQIQNwMAIAtBiDBqIg4gCikCCDcDACALIAopAgA3A4AwIAogCCgCGDYCGCAKIAgpAhA3AhAgCiAIKQIINwIIIAogCCkCADcCACAIIBQoAgA2AhggCCATKQMANwIQIAggDikDADcCCCAIIAspA4AwNwIAC0EIIA0gDUEITxsiFEECRg0AIAgqAhQgC0GIGGpBCSAQa0EHcUEcbGoiCioCFF4EQCALQZgwaiITIAgoAhg2AgAgC0GQMGoiDiAIKQIQNwMAIAtBiDBqIhUgCCkCCDcDACALIAgpAgA3A4AwIAggCigCGDYCGCAIIAopAhA3AhAgCCAKKQIINwIIIAggCikCADcCACAKIBMoAgA2AhggCiAOKQMANwIQIAogFSkDADcCCCAKIAspA4AwNwIACyAUQQNGDQAgCioCFCALQYgYakEKIBBrQQdxQRxsaiIIKgIUXgRAIAtBmDBqIhMgCigCGDYCACALQZAwaiIOIAopAhA3AwAgC0GIMGoiFSAKKQIINwMAIAsgCikCADcDgDAgCiAIKAIYNgIYIAogCCkCEDcCECAKIAgpAgg3AgggCiAIKQIANwIAIAggEygCADYCGCAIIA4pAwA3AhAgCCAVKQMANwIIIAggCykDgDA3AgALIBRBBEYNACAIKgIUIAtBiBhqQQsgEGtBB3FBHGxqIgoqAhReBEAgC0GYMGoiEyAIKAIYNgIAIAtBkDBqIg4gCCkCEDcDACALQYgwaiIVIAgpAgg3AwAgCyAIKQIANwOAMCAIIAooAhg2AhggCCAKKQIQNwIQIAggCikCCDcCCCAIIAopAgA3AgAgCiATKAIANgIYIAogDikDADcCECAKIBUpAwA3AgggCiALKQOAMDcCAAsgFEEFRg0AIAoqAhQgC0GIGGpBDCAQa0EHcUEcbGoiCCoCFF4EQCALQZgwaiITIAooAhg2AgAgC0GQMGoiDiAKKQIQNwMAIAtBiDBqIhUgCikCCDcDACALIAopAgA3A4AwIAogCCgCGDYCGCAKIAgpAhA3AhAgCiAIKQIINwIIIAogCCkCADcCACAIIBMoAgA2AhggCCAOKQMANwIQIAggFSkDADcCCCAIIAspA4AwNwIACyAUQQZGDQAgCCoCFCALQYgYakENIBBrQQdxQRxsaiIKKgIUXgRAIAtBmDBqIhAgCCgCGDYCACALQZAwaiITIAgpAhA3AwAgC0GIMGoiDiAIKQIINwMAIAsgCCkCADcDgDAgCCAKKAIYNgIYIAggCikCEDcCECAIIAopAgg3AgggCCAKKQIANwIAIAogECgCADYCGCAKIBMpAwA3AhAgCiAOKQMANwIIIAogCykDgDA3AgALIBRBB0YNACAKKgIUIAtBiBhqQQYgD2tBB3FBHGxqIggqAhReRQ0AIAtBmDBqIg8gCigCGDYCACALQZAwaiIQIAopAhA3AwAgC0GIMGoiFCAKKQIINwMAIAsgCikCADcDgDAgCiAIKAIYNgIYIAogCCkCEDcCECAKIAgpAgg3AgggCiAIKQIANwIAIAggDygCADYCGCAIIBApAwA3AhAgCCAUKQMANwIIIAggCykDgDA3AgALIA0hDwsgDCEUIBJBAWsiEg0ACwsgCyANNgLoGQsgDEEBaiEUIAxBBGogAUkNAAsLIAAoAgggCygC9C8gACgCBBEAACAAKAIIICEgACgCBBEAAAJAIAkgAUEEdGooAghB////P3ENAANAIAkgAUEEdGooAgBBAUcNASAJIAFBAWsiAUEEdGooAghB////P3FFDQALCyAJIAFBBHRqQX82AgxBACEMIAEEQANAIAkgASAJIAFBBHRqIgAoAghB////P3EgACgCAEH///8PcWoiAGsiAUEEdGogADYCDCAMQQFqIQwgAQ0ACwsgC0HAMWokACAMC+IRAgp/AXwCQCAAQeTClcMGEBwiAUUNACABKAIgRQRAAkAgASgCDCIDIANBA2pBfHEgA0F8SxsiAiABKAIYIAEoAhQiBWsiBEsEQCABQRRqIAIgBGsQJSABKAIMIQMgASgCFCEFDAELIAIgBE8NACABIAIgBWo2AhgLIAUgASgCECADEBQhAyABKAIMIgUgAkkEQCADIAVqQQAgAiAFaxASGgsgASADNgIQCwJAIAAiBUEMaiIAKAIAIgNFDQAgACECIAMhAQNAIAIgASABKAIQQceSzaIESSIEGyECIAFBBGogASAEGygCACIBDQALIAAgAkYNACACKAIQQceSzaIESw0AAkAgAigCBCIARQRAIAIhAANAIAAoAggiASgCACAARyEKIAEhACAKDQALDAELA0AgACIBKAIAIgANAAsLIAIgBSgCCEYEQCAFIAE2AggLIAUgBSgCEEEBazYCEAJ/AkAgAiIEIgEoAgAiAgRAIAEoAgQiAEUNAQNAIAAiASgCACIADQALCyABKAIEIgINAEEAIQJBAQwBCyACIAEoAgg2AghBAAshBwJAIAEgASgCCCIGKAIAIgBGBEAgBiACNgIAIAEgA0YEQEEAIQAgAiEDDAILIAYoAgQhAAwBCyAGIAI2AgQLIAEtAAwhCCABIARHBEAgASAEKAIIIgY2AgggBiAEKAIIKAIAIARHQQJ0aiABNgIAIAEgBCgCACIGNgIAIAYgATYCCCABIAQoAgQiBjYCBCAGBEAgBiABNgIICyABIAQtAAw6AAwgASADIAMgBEYbIQMLAkAgCEUNACADRQ0AIAcEQANAIAAtAAwhAgJAIAAgACgCCCIBKAIARwRAIAJFBEAgAEEBOgAMIAFBADoADCABIAEoAgQiAigCACIGNgIEIAYEQCAGIAE2AggLIAIgASgCCDYCCCABKAIIIgYgBigCACABR0ECdGogAjYCACACIAE2AgAgASACNgIIIAAgAyADIAAoAgAiAEYbIQMgACgCBCEACwJAAkACQAJAIAAoAgAiAQRAIAEtAAxFDQELIAAoAgQiAgRAIAItAAxFDQILIABBADoADAJAIAMgACgCCCIARgRAIAMhAAwBCyAALQAMDQYLIABBAToADAwICyAAKAIEIgJFDQELIAItAAwNACAAIQEMAQsgAUEBOgAMIABBADoADCAAIAEoAgQiAjYCACACBEAgAiAANgIICyABIAAoAgg2AgggACgCCCICIAIoAgAgAEdBAnRqIAE2AgAgASAANgIEIAAgATYCCCAAIQILIAEgASgCCCIALQAMOgAMIABBAToADCACQQE6AAwgACAAKAIEIgEoAgAiAjYCBCACBEAgAiAANgIICyABIAAoAgg2AgggACgCCCICIAIoAgAgAEdBAnRqIAE2AgAgASAANgIAIAAgATYCCAwECyACRQRAIABBAToADCABQQA6AAwgASAAKAIEIgI2AgAgAgRAIAIgATYCCAsgACABKAIINgIIIAEoAggiAiACKAIAIAFHQQJ0aiAANgIAIAAgATYCBCABIAA2AgggACADIAEgA0YbIQMgASgCACEACwJAAkAgACgCACICRQ0AIAItAAwNACAAIQEMAQsCQCAAKAIEIgEEQCABLQAMRQ0BCyAAQQA6AAwgACgCCCIALQAMQQAgACADRxsNAiAAQQE6AAwMBQsgAgRAIAItAAxFBEAgACEBDAILIAAoAgQhAQsgAUEBOgAMIABBADoADCAAIAEoAgAiAjYCBCACBEAgAiAANgIICyABIAAoAgg2AgggACgCCCICIAIoAgAgAEdBAnRqIAE2AgAgASAANgIAIAAgATYCCCAAIQILIAEgASgCCCIALQAMOgAMIABBAToADCACQQE6AAwgACAAKAIAIgEoAgQiAjYCACACBEAgAiAANgIICyABIAAoAgg2AgggACgCCCICIAIoAgAgAEdBAnRqIAE2AgAgASAANgIEIAAgATYCCAwDCyAAKAIIIgEgASgCACAARkECdGooAgAhAAwACwALIAJBAToADAsgBCgCKCIABEAgBCAANgIsIAAQFgsgBBAWIAUgBSgCEDsBBAsgBUHkwpXDBhAcIgBFDQAgACgCICIBIAAgARsiACgCDEERSQ0AIAAoAhQgACgCEC0AEEEIcjoAEAJ/IAVB5MKVwwYQHCEDIAVB5vKxuwYQHCEAIAVB4ca94wYQHCEBQQAgA0UNABpBASECAkAgACABckUNAEEAIABFIAFFcw0BGkEAIAEoAiAiAUEARyAAKAIgQQBHRw0BGiABDQAgAygCEC0AMyEEIAUQ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AhgRAgAiADYC8CZBayEHIABFDRUgAkIGNwMAQQALIgAgAigC0AEiB0gEQANAAkAgAigCDCIHQR9rQQJPBEAgDSgCACEDDAELIAIoAhQiBkUNDSACIAIoAghBCHYiBTYCCCACKAIQIgQtAAAhAyACIAZBAWs2AhQgAiAEQQFqNgIQIAIgA0EYdCAFciIDNgIIIAdBCGshBwsgAiAHQQJqNgIMIAIoAvAmIABqIAMgB3ZBA3E6AAAgAEEBaiIAIAIoAtABIgdIDQALCyACQRU2AgALIAdBBnQgLyA5IAIQkAEiB0EBRw0TIC1CADcCACAtQgA3AhggLUIANwIQIC1CADcCCCACKALQASIKBEAgOSgCACERQQAhDgNAIA5BBnQiD0EDciEGIA9BAnIhBSAPQQFyIQQgDyARai0AACELQQAhB0EAIQADQCAAIBEgBCAHamotAAAgC3MgESAHIA9qai0AACALc3IgESAFIAdqai0AACALc3IgESAGIAdqai0AACALc3JyIQAgB0E8SSFLIAdBBGohByBLDQALIABFBEAgAiAOQQN2Qfz///8BcWpB/CZqIgAgACgCAEEBIA50cjYCAAsgDkEBaiIOIApHDQALCyACQRY2AgALIAIoAvgBIgVBPkEYIAItANwmQSBxIgAbIAIoAvQBIgdBAWp0aiIEIQMCQCAARQ0AQQEgB3QhBiAHQQJ0IgNBgOMZaigCACIAIAVBEGsiBUsEQCADQZDjGWooAgAgBSAGamohAwwBCyADQZDjGWooAgAhAyAFIAAgBmoiAEsEQCADIAVqIQMMAQsgACADaiEDCyACKALYAUECdCBAID8gAhCQASIHQQFHDRIgAiATQYACQYACIAIoAugmEFggAiAbQcAFQcAFIAIoAtQBEFhxIAIgECAEIAMgAigCgAIQWHFBAXFFBEAgAkFqNgJcQQAhBwwUCyACQhc3AwBBACEDIBMhAAwBCyATIQACQAJAIAIoAgQiAw4DAgABAwsgGyEADAELIBAhAAsCfyACKALEJkEBRgRAIAIoAowQDAELIAAoAgQhBCACQQE2AsQmIAJBADYCjBAgAiAENgKQEEEACyAALwEMSARAIAIoApAQIQcDQCAALwEIIAAvAQogByAsQQxqIAIQRSIHQQFHDRIgACgCACACKAKMECIDQQJ0aiACKAKQEDYCACAs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CyAIIAQ2AlggARAWCyAIQbABaiQAIAkMAgsQIgALIAggCTYCmAEgCCABNgKgAQwBCwR/ICMoAiAhAyAjICMoAhwgQyAjLQAnIgHAQQBIIgAbNgIsICMgAyABIAAbNgIoQbwQICNBKGoQBwVBAgs2AgAgIywAJ0EASARAICMoAhwQFgsgI0EwaiQADwsQGwALrgEBBH8jAEEQayICJAAgASgCACIDQfD///8HSQRAAkAgA0EKTQRAIAIgAzoACyACIQQMAQsgA0EPckEBaiIFEBchBCACIAVBgICAgHhyNgIIIAIgBDYCACACIAM2AgQLIAQgAUEEaiADEBQgA2pBADoAACACQQxqIAIgABEAACACKAIMEAwgAigCDCIAEAsgAiwAC0EASARAIAIoAgAQFgsgAkEQaiQAIAAPCxBDAAsVAEGtCEECQawPQZgQQQJBA0EAEAILBwAgACgCBAsFAEHvCAsFAEH6CQsFAEHLCAsXACAARQRAQQAPCyAAQby6GhCCAUEARwsbACAAIAEoAgggBRAjBEAgASACIAMgBBCAAQsLOAAgACABKAIIIAUQIwRAIAEgAiADIAQQgAEPCyAAKAIIIgAgASACIAMgBCAFIAAoAgAoAhQRCwALpwEAIAAgASgCCCAEECMEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQI0UNAAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNASABQQE2AiAPCyABIAI2AhQgASADNgIgIAEgASgCKEEBajYCKAJAIAEoAiRBAUcNACABKAIYQQJHDQAgAUEBOgA2CyABQQQ2AiwLC4gCACAAIAEoAgggBBAjBEACQCABKAIEIAJHDQAgASgCHEEBRg0AIAEgAzYCHAsPCwJAIAAgASgCACAEECMEQAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNAiABQQE2AiAPCyABIAM2AiACQCABKAIsQQRGDQAgAUEAOwE0IAAoAggiACABIAIgAkEBIAQgACgCACgCFBELACABLQA1BEAgAUEDNgIsIAEtADRFDQEMAwsgAUEENgIsCyABIAI2AhQgASABKAIoQQFqNgIoIAEoAiRBAUcNASABKAIYQQJHDQEgAUEBOgA2DwsgACgCCCIAIAEgAiADIAQg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AyAANgIIIANCADcCACADQgA3AhQgA0IANwIcIANCADcCJCADQgA3AiwgA0IANwI0IAYgAzYCACADIQEgCigCCCgCACIABEAgCiAANgIIIAYoAgAhAQsgASABIAUoAgAiBEYiADoADAJAIAANAANAIAEoAggiAi0ADA0BAkAgAiACKAIIIgAoAgAiBkYEQAJAIAAoAgQiBkUNACAGLQAMDQAMAgsCQCABIAIoAgBGBEAgAiEBDAELIAIgAigCBCIBKAIAIgY2AgQgASAGBH8gBiACNgIIIAIoAggFIAALNgIIIAIoAggiACAAKAIAIAJHQQJ0aiABNgIAIAEgAjYCACACIAE2AgggASgCCCIAKAIAIQILIAFBAToADCAAQQA6AAwgACACKAIEIgE2AgAgAQRAIAEgADYCCAsgAiAAKAIINgIIIAAoAggiASABKAIAIABHQQJ0aiACNgIAIAIgADYCBCAAIAI2AggMAwsCQCAGRQ0AIAYtAAwNAAwBCwJAIAEgAigCAEcEQCACIQEMAQsgAiABKAIEIgY2AgAgASAGBH8gBiACNgIIIAIoAggFIAALNgIIIAIoAggiACAAKAIAIAJHQQJ0aiABNgIAIAEgAjYCBCACIAE2AgggASgCCCEACyABQQE6AAwgAEEAOgAMIAAgACgCBCIBKAIAIgI2AgQgAgRAIAIgADYCCAsgASAAKAIINgIIIAAoAggiAiACKAIAIABHQQJ0aiABNgIAIAEgADYCACAAIAE2AggMAgsgAkEBOgAMIAAgACAERjoADCAGQQE6AAwgBCAAIgFHDQALCyAKIAooAhBBAWo2AhALAkAgAygCNCIABEAgACgCCCEADAELIAwiACADKAIgIgEgAUEDakF8cSABQXxLG2ohDAsgAyAANgIcIA5BBGoiDiAIRw0ACyARKAIEIQ4LIA4EQCARIA42AgggDhAWCyAKQRRqIgogCUcNAAsgECgCFCIAIBAoAhgiAkYEQEEBIQEMAQsDQCAAEHciAUUNASAAQRRqIgAgAkcNAAsLIBFBEGokACABRQ0AIAcoAnghBiAHKAJ0IQACQCAdLQAQBEAgACAGRg0BAkADQAJ/QQAhGCMAQbABayIEJABBASECAkACQCAAIhBB5vKxuwYQHCIAIBBB4ca94wYQHCIBckUNAEEAIQIgAEUgAUVzDQAgASgC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QQF0IgMgACAAIANJGyACQf////8DTxsiAgR/IAIQFwVBAAsiAGoiAyAIOgAAIAAgAmohCCADQQFqIQICQCABIAlGBEAgAyEADAELIAlBf3MgAWohMEEAIQUgD0EDcSIPBEADQCADQQFrIgMgAUEBayIBLQAAOgAAIAVBAWoiBSAPRw0ACwsgMEEDTwRAA0AgA0EBayABQQFrLQAAOgAAIANBAmsgAUECay0AADoAACADQQNrIAFBA2stAAA6AAAgA0EEayIDIAFBBGsiAS0AADoAACABIAlHDQALCyAEKAKIASEBCyAEIAg2ApABIAQgAjYCjAEgBCAANgKIASABRQ0AIAEQFiAEKAKMASECCyAEKAKQASIBIAJLBEAgAiALOgAAIAQgAkEBajYCjAEMBAsgAiAEKAKIASIFayIJQQFqIgBBAEgNDCAJQf////8HIAEgBWsiAUEBdCIDIAAgACADSRsgAUH/////A08bIgMEfyADEBcFQQALIgBqIgEgCzoAACAAIANqIQggAUEBaiELAkAgAiAFRgRAIAEhAAwBCyAFQX9zIAJqITFBACEDIAlBA3EiCQRAA0AgAUEBayIBIAJBAWsiAi0AADoAACADQQFqIgMgCUcNAAsLIDFBA08EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6AAAgAUEDayACQQNrLQAAOgAAIAFBBGsiASACQQRrIgItAAA6AAAgAiAFRw0ACwsgBCgCiAEhAgsgBCAINgKQASAEIAs2AowBIAQgADYCiAEgAkUNAyACEBYMAwsgAiAEKAJYIgVrIgtBAWoiAUEASA0TIAtB/////wcgACAFayIAQQF0Ig8gASABIA9JGyAAQf////8DTxsiDwR/IA8QFwVBAAsiAGoiASADOgAAIAAgD2ohDyABQQFqIRYCQCACIAVGBEAgASEADAELIAVBf3MgAmohMkEAIQMgC0EDcSILBEADQCABQQFrIgEgAkEBayICLQAAOgAAIANBAWoiAyALRw0ACwsgMkEDTwRAA0AgAUEBayACQQFrLQAAOgAAIAFBAmsgAkECay0AADoAACABQQNrIAJBA2stAAA6AAAgAUEEayIBIAJBBGsiAi0AADoAACACIAVHDQALCyAEKAJYIQILIAQgDzYCYCAEIBY2AlwgBCAANgJYIAJFDQAgAhAWCyAIQQR2IQACQCAEKAKMASIBIAQoApABIgNJBEAgASAAOgAAIAQgAUEBaiICNgKMAQwBCyABIAQoAogBIgtrIg9BAWoiAkEASA0LIA9B/////wcgAyALayIDQQF0IgUgAiACIAVJGyADQf////8DTxsiAgR/IAIQFwVBAAsiBWoiAyAAOgAAIAIgBWohFiADQQFqIQICQCABIAtGBEAgAyEFDAELIAtBf3MgAWohM0EAIQAgD0EDcSIPBEADQCADQQFrIgMgAUEBayIBLQAAOgAAIABBAWoiACAPRw0ACwsgM0EDTwRAA0AgA0EBayABQQFrLQAAOgAAIANBAmsgAUECay0AADoAACADQQNrIAFBA2stAAA6AAAgA0EEayIDIAFBBGsiAS0AADoAACABIAtHDQALCyAEKAKIASEBCyAEIBY2ApABIAQgAjYCjAEgBCAFNgKIASABRQ0AIAEQFiAEKAKMASECCyAIQQR0IAlBCHZyIQECQCAEKAKQASIDIAJLBEAgAiABOgAAIAQgAkEBaiIBNgKMAQwBCyACIAQoAogBIghrIgtBAWoiAEEASA0LIAtB/////wcgAyAIayIDQQF0IgUgACAAIAVJGyADQf////8DTxsiBQR/IAUQFwVBAAsiAGoiAyABOgAAIAAgBWohDyADQQFqIQECQCACIAhGBEAgAyEADAELIAhBf3MgAmohNEEAIQUgC0EDcSILBEADQCADQQFrIgMgAkEBayICLQAAOgAAIAVBAWoiBSALRw0ACwsgNEEDTwRAA0AgA0EBayACQQFrLQAAOgAAIANBAmsgAkECay0AADoAACADQQNrIAJBA2stAAA6AAAgA0EEayIDIAJBBGsiAi0AADoAACACIAhHDQALCyAEKAKIASECCyAEIA82ApABIAQgATYCjAEgBCAANgKIASACRQ0AIAIQFiAEKAKMASEBCyAEKAKQASICIAFLBEAgASAJOgAAIAQgAUEBajYCjAEMAgsgASAEKAKIASIFayIIQQFqIgBBAEgNCiAIQf////8HIAIgBWsiAkEBdCIDIAAgACADSRsgAkH/////A08bIgMEfyADEBcFQQALIgBqIgIgCToAACAAIANqIQkgAkEBaiELAkAgASAFRgRAIAIhAAwBCyAFQX9zIAFqITVBACEDIAhBA3EiCARAA0AgAkEBayICIAFBAWsiAS0AADoAACADQQFqIgMgCEcNAAsLIDVBA08EQANAIAJBAWsgAUEBay0AADoAACACQQJrIAFBAmstAAA6AAAgAkEDayABQQNrLQAAOgAAIAJBBGsiAiABQQRrIgEtAAA6AAAgASAFRw0ACwsgBCgCiAEhAQsgBCAJNgKQASAEIAs2AowBIAQgADYCiAEgAUUNASABEBYMAQsgAUH8AHIhAwJAIAAgAksEQCACIAM6AAAgBCACQQFqNgJcDAELIAIgBCgCWCIFayILQQFqIgFBAEgNEiALQf////8HIAAgBWsiAEEBdCIPIAEgASAPSRsgAEH/////A08bIg8EfyAPEBcFQQALIgBqIgEgAzoAACAAIA9qIQ8gAUEBaiEWAkAgAiAFRgRAIAEhAAwBCyAFQX9zIAJqITZBACEDIAtBA3EiCwRAA0AgAUEBayIBIAJBAWsiAi0AADoAACADQQFqIgMgC0cNAAsLIDZBA08EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6AAAgAUEDayACQQNrLQAAOgAAIAFBBGsiASACQQRrIgItAAA6AAAgAiAFRw0ACwsgBCgCWCECCyAEIA82AmAgBCAWNgJcIAQgADYCWCACRQ0AIAIQFgsgCEEIdiEAAkAgBCgCjAEiASAEKAKQASIDSQRAIAEgADoAACAEIAFBAWoiAjYCjAEMAQsgASAEKAKIASILayIPQQFqIgJBAEgNCiAPQf////8HIAMgC2siA0EBdCIFIAIgAiAFSRsgA0H/////A08bIgIEfyACEBcFQQALIgVqIgMgADoAACACIAVqIRYgA0EBaiECAkAgASALRgRAIAMhBQwBCyALQX9zIAFqITdBACEAIA9BA3EiDwRAA0AgA0EBayIDIAFBAWsiAS0AADoAACAAQQFqIgAgD0cNAAsLIDdBA08EQANAIANBAWsgAUEBay0AADoAACADQQJrIAFBAmstAAA6AAAgA0EDayABQQNrLQAAOgAAIANBBGsiAyABQQRrIgEtAAA6AAAgASALRw0ACwsgBCgCiAEhAQsgBCAWNgKQASAEIAI2AowBIAQgBTYCiAEgAUUNACABEBYgBCgCjAEhAgsCQCAEKAKQASIBIAJLBEAgAiAIOgAAIAQgAkEBaiIBNgKMAQwBCyACIAQoAogBIgtrIg9BAWoiAEEASA0KIA9B/////wcgASALayIBQQF0IgMgACAAIANJGyABQf////8DTxsiAQR/IAEQFwVBAAsiAGoiAyAIOgAAIAAgAWohCCADQQFqIQECQCACIAtGBEAgAyEADAELIAtBf3MgAmohOEEAIQUgD0EDcSIPBEADQCADQQFrIgMgAkEBayICLQAAOgAAIAVBAWoiBSAPRw0ACwsgOEEDTwRAA0AgA0EBayACQQFrLQAAOgAAIANBAmsgAkECay0AADoAACADQQNrIAJBA2stAAA6AAAgA0EEayIDIAJBBGsiAi0AADoAACACIAtHDQALCyAEKAKIASECCyAEIAg2ApABIAQgATYCjAEgBCAANgKIASACRQ0AIAIQFiAEKAKMASEBCyAJQQh2IQICQCAEKAKQASIDIAFLBEAgASACOgAAIAQgAUEBaiICNgKMAQwBCyABIAQoAogBIghrIgtBAWoiAEEASA0KIAtB/////wcgAyAIayIDQQF0IgUgACAAIAVJGyADQf////8DTxsiBQR/IAUQFwVBAAsiAGoiAyACOgAAIAAgBWohDyADQQFqIQICQCABIAhGBEAgAyEADAELIAhBf3MgAWohOUEAIQUgC0EDcSILBEADQCADQQFrIgMgAUEBayIBLQAAOgAAIAVBAWoiBSALRw0ACwsgOUEDTwRAA0AgA0EBayABQQFrLQAAOgAAIANBAmsgAUECay0AADoAACADQQNrIAFBA2stAAA6AAAgA0EEayIDIAFBBGsiAS0AADoAACABIAhHDQALCyAEKAKIASEBCyAEIA82ApABIAQgAjYCjAEgBCAANgKIASABRQ0AIAEQFiAEKAKMASECCyAEKAKQASIBIAJLBEAgAiAJOgAAIAQgAkEBajYCjAEMAQsgAiAEKAKIASIFayIIQQFqIgBBAEgNCSAIQf////8HIAEgBWsiAUEBdCIDIAAgACADSRsgAUH/////A08bIgMEfyADEBcFQQALIgBqIgEgCToAACAAIANqIQkgAUEBaiELAkAgAiAFRgRAIAEhAAwBCyAFQX9zIAJqITpBACEDIAhBA3EiCARAA0AgAUEBayIBIAJBAWsiAi0AADoAACADQQFqIgMgCEcNAAsLIDpBA08EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6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PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AMgHAAAQCAAATjEwZW1zY3JpcHRlbjN2YWxFAABUngYAtAcAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAABUngYA0AcAAGlpaQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAFSeBgAcCAAAYWNvbAAAAAAAAAAAcGFtY2RhZWhhZWhoeHRtaHB4YW1lbWFuMi9TT3Rzb3AgdHZjbWdwZmZ5bGdhY29scGVycCBGRkNHUk9WVERCRUNMQkVwc2FneG1kaG5yZWtIU1RMVExDUFhNRFZhZWh2eHRtdkVTQUJGRURHU09QR0JVU0dDU0JFRlRTSkhUQU1UREJDQ0xCQ1JMT0NMQVBDIEdWU3hpYnN0bmNhcmF2YXRhZGJjb2xibmxzYnJhdmNjc2RmdGFlZnh0bWZyYXZmcmF2Z3l0c2h0c3VqcmFjbHRyb214cm9tZGJwb3BvcnBrYXJ0ZnBhWmZsaVN0YWxHY29sR3RhZUZsbGlTAEHaEguDCIA/DeDKPwAAAEB4mhRAB3AlQLSrM0AAAEBADeBKQHiaVEBUZ11AB3BlQAHUbEC0q3NAfwp6QAAAgEB/zIJAB3CFQAbvh0A8TYpA3Y2MQKqzjkAFwZBAA7iSQHialEABapZACiiYQNrVmUCVdJtAPwWdQMeInkAAAKBArWuhQH/MokAWI6RAB3ClQNizpkAG76dABCKpQDxNqkARcatA3Y2sQPajrUCqs65AQ72vQAXBsEAxv7FAA7iyQLSrs0B4mrRAgoS1QAFqtkAgS7dACii4QOYAuUDa1blACae6QJV0u0CdPrxAPwW9QJrIvUDHiL5A4UW/QAAAwEA9t8BArWvBQGcdwkB/zMJACHnDQBYjxEC6ysRAB3DFQAsTxkDYs8ZAfFLHQAbvx0CEichABCLJQJK4yUA8TcpADeDKQBFxy0BTAMxA3Y3MQLsZzUD2o81AmCzOQKqzzkA1Oc9AQ73PQNs/0EAFwdBAykDRQDG/0UBCPNJAA7jSQHwy00C0q9NAsCPUQHia1EASENVAgoTVQND31UABatZAGdvWQCBL10AZutdACijYQPeU2EDmANlA22vZQNrV2UDoPtpACafaQEEO20CVdNtAB9rbQJ0+3EBZotxAPwXdQFRn3UCayN1AFCneQMeI3kC0595A4UXfQE6j30AAAOBA+VvgQD234EDNEeFArWvhQODE4UBnHeJARnXiQH/M4kAUI+NACHnjQF7O40AWI+RANHfkQLrK5ECqHeVAB3DlQNHB5UALE+ZAt2PmQNiz5kBuA+dAfFLnQAOh50AG7+dAhTzoQISJ6EAD1uhABCLpQIht6UCSuOlAIwPqQDxN6kDflupADeDqQMgo60ARcetA6bjrQFMA7EBOR+xA3Y3sQAHU7EC7Ge1ADF/tQPaj7UB56O1AmCzuQFJw7kCqs+5AoPbuQDU570Bre+9AQ73vQL3+70DbP/BAnYDwQAXB8EAUAfFAykDxQCmA8UAxv/FA5P3xQEI88kBMevJAA7jyQGj18kB8MvNAQG/zQLSr80DZ5/NAsCP0QDtf9EB4mvRAatX0QBIQ9UBvSvVAgoT1QE2+9UDQ9/VADDH2QAFq9kCwovZAGdv2QD8T90AgS/dAvoL3QBm690Ay8fdACij4QKFe+ED3lPhADsv4QOYA+UB/NvlA22v5QPmg+UDa1flAfwr6QOg++kAWc/pACaf6QMLa+kBBDvtAh0H7QJV0+0Bqp/tAB9r7QG0M/ECdPvxAlnD8QFmi/EDn0/xAPwX9QGQ2/UBUZ/1AEJj9QJrI/UDw+P1AFCn+QAZZ/kDHiP5AVrj+QLTn/kDjFv9A4UX/QK90/0BOo/9AvtH/QAAAAAABAAAAAgAAAAMAQfgaCxUBAAAAAQAAAAEAAAABAAAAAQAAAAEAQaAbCy3/////AQAAAP7///8CAAAA/f///wMAAAD/////AQAAAP7///8CAAAA/f///wMAQegbC0UBAAAAAQAAAAIAAAACAAAAAwAAAAMAAAAEAAAABAAAAAUAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAAMAAAADgAAABgAQdAcC70WAQAAAAEAAAACAAAAAgAAAAMAAAADAAAABAAAAAQAAAAFAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAAGAAAAAAAAAAEAAAACAAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAACwAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAEGoMwv6KwcAAAAAAAAAFwAAAAAAAAAnAAAAAAAAADcAAAAAAAAARwAAAAAAAABXAAAAAAAAAGcAAAAAAAAAdwAAAAAAAABwBwAAAAAAAIcLAAAAAAAAhxMAAAAAAACHGwAAAAAAAIcjAAAAAAAAhysAAAAAAACHMwAAAAAAAIc7AAAAAAAAlwMAAAAAAACXCwAAAAAAAJcTAAAAAAAAlxsAAAAAAACXIwAAAAAAAJcrAAAAAAAAlzMAAAAAAACXOwAAAAAAAKcDAAAAAAAApwsAAAAAAACnEwAAAAAAAKcbAAAAAAAApyMAAAAAAACnKwAAAAAAAKczAAAAAAAApzsAAAAAAAC3AwAAAAAAALcLAAAAAAAAtxMAAAAAAAC3GwAAAAAAALcjAAAAAAAAtysAAAAAAAC3MwAAAAAAALc7AAAAAAAAxwMAAAAAAADHCwAAAAAAAMcTAAAAAAAAxxsAAAAAAADHIwAAAAAAAMcrAAAAAAAAxzMAAAAAAADHOwAAAAAAANcDAAAAAAAA1wsAAAAAAADXEwAAAAAAANcbAAAAAAAA1yMAAAAAAADXKwAAAAAAANczAAAAAAAA1zsAAAAAAADnAwAAAAAAAOcLAAAAAAAA5xMAAAAAAADnGwAAAAAAAOcjAAAAAAAA5ysAAAAAAADnMwAAAAAAAOc7AAAAAAAA9wMAAAAAAAD3CwAAAAAAAPcTAAAAAAAA9xsAAAAAAAD3IwAAAAAAAPcrAAAAAAAA9zMAAAAAAAD3OwAAAAAAAIfDAQAAAAAAh8MFAAAAAACHwwkAAAAAAIfDDQAAAAAAh8MRAAAAAACHwxUAAAAAAIfDGQAAAAAAh8MdAAAAAACHywEAAAAAAIfLBQAAAAAAh8sJAAAAAACHyw0AAAAAAIfLEQAAAAAAh8sVAAAAAACHyxkAAAAAAIfLHQAAAAAAh9MBAAAAAACH0wUAAAAAAIfTCQAAAAAAh9MNAAAAAACH0xEAAAAAAIfTFQAAAAAAh9MZAAAAAACH0x0AAAAAAIfbAQAAAAAAh9sFAAAAAACH2wkAAAAAAIfbDQAAAAAAh9sRAAAAAACH2xUAAAAAAIfbGQAAAAAAh9sdAAAAAACH4wEAAAAAAIfjBQAAAAAAh+MJAAAAAACH4w0AAAAAAIfjEQAAAAAAh+MVAAAAAACH4xkAAAAAAIfjHQAAAAAAh+sBAAAAAACH6wUAAAAAAIfrCQAAAAAAh+sNAAAAAACH6xEAAAAAAIfrFQAAAAAAh+sZAAAAAACH6x0AAAAAAIfzAQAAAAAAh/MFAAAAAACH8wkAAAAAAIfzDQAAAAAAh/MRAAAAAACH8xUAAAAAAIfzGQAAAAAAh/MdAAAAAACH+wEAAAAAAIf7BQAAAAAAh/sJAAAAAACH+w0AAAAAAIf7EQAAAAAAh/sVAAAAAACH+xkAAAAAAIf7HQAAAAAAl8MBAAAAAACXwwUAAAAAAJfDCQAAAAAAl8MNAAAAAACXwxEAAAAAAJfDFQAAAAAAl8MZAAAAAACXwx0AAAAAAJfLAQAAAAAAl8sFAAAAAACXywkAAAAAAJfLDQAAAAAAl8sRAAAAAACXyxUAAAAAAJfLGQAAAAAAl8sdAAAAAACX0wEAAAAAAJfTBQAAAAAAl9MJAAAAAACX0w0AAAAAAJfTEQAAAAAAl9MVAAAAAACX0xkAAAAAAJfTHQAAAAAAl9sBAAAAAACX2wUAAAAAAJfbCQAAAAAAl9sNAAAAAACX2xEAAAAAAJfbFQAAAAAAl9sZAAAAAACX2x0AAAAAAJfjAQAAAAAAl+MFAAAAAACX4wkAAAAAAJfjDQAAAAAAl+MRAAAAAACX4xUAAAAAAJfjGQAAAAAAl+MdAAAAAACX6wEAAAAAAJfrBQAAAAAAl+sJAAAAAACX6w0AAAAAAJfrEQAAAAAAl+sVAAAAAACX6xkAAAAAAJfrHQAAAAAAl/MBAAAAAACX8wUAAAAAAJfzCQAAAAAAl/MNAAAAAACX8xEAAAAAAJfzFQAAAAAAl/MZAAAAAACX8x0AAAAAAJf7AQAAAAAAl/sFAAAAAACX+wkAAAAAAJf7DQAAAAAAl/sRAAAAAACX+xUAAAAAAJf7GQAAAAAAl/sdAAAAAACnwwEAAAAAAKfDBQAAAAAAp8MJAAAAAACnww0AAAAAAKfDEQAAAAAAp8MVAAAAAACnwxkAAAAAAKfDHQAAAAAAp8sBAAAAAACnywUAAAAAAKfLCQAAAAAAp8sNAAAAAACnyxEAAAAAAKfLFQAAAAAAp8sZAAAAAACnyx0AAAAAAKfTAQAAAAAAp9MFAAAAAACn0wkAAAAAAKfTDQAAAAAAp9MRAAAAAACn0xUAAAAAAKfTGQAAAAAAp9MdAAAAAACn2wEAAAAAAKfbBQAAAAAAp9sJAAAAAACn2w0AAAAAAKfbEQAAAAAAp9sVAAAAAACn2xkAAAAAAKfbHQAAAAAAp+MBAAAAAACn4wUAAAAAAKfjCQAAAAAAp+MNAAAAAACn4xEAAAAAAKfjFQAAAAAAp+MZAAAAAACn4x0AAAAAAKfrAQAAAAAAp+sFAAAAAACn6wkAAAAAAKfrDQAAAAAAp+sRAAAAAACn6xUAAAAAAKfrGQAAAAAAp+sdAAAAAACn8wEAAAAAAKfzBQAAAAAAp/MJAAAAAACn8w0AAAAAAKfzEQAAAAAAp/MVAAAAAACn8xkAAAAAAKfzHQAAAAAAp/sBAAAAAACn+wUAAAAAAKf7CQAAAAAAp/sNAAAAAACn+xEAAAAAAKf7FQAAAAAAp/sZAAAAAACn+x0AAAAAALfDAQAAAAAAt8MFAAAAAAC3wwkAAAAAALfDDQAAAAAAt8MRAAAAAAC3wxUAAAAAALfDGQAAAAAAt8MdAAAAAAC3ywEAAAAAALfLBQAAAAAAt8sJAAAAAAC3yw0AAAAAALfLEQAAAAAAt8sVAAAAAAC3yxkAAAAAALfLHQAAAAAAt9MBAAAAAAC30wUAAAAAALfTCQAAAAAAt9MNAAAAAAC30xEAAAAAALfTFQAAAAAAt9MZAAAAAAC30x0AAAAAALfbAQAAAAAAt9sFAAAAAAC32wkAAAAAALfbDQAAAAAAt9sRAAAAAAC32xUAAAAAALfbGQAAAAAAt9sdAAAAAAC34wEAAAAAALfjBQAAAAAAt+MJAAAAAAC34w0AAAAAALfjEQAAAAAAt+MVAAAAAAC34xkAAAAAALfjHQAAAAAAt+sBAAAAAAC36wUAAAAAALfrCQAAAAAAt+sNAAAAAAC36xEAAAAAALfrFQAAAAAAt+sZAAAAAAC36x0AAAAAALfzAQAAAAAAt/MFAAAAAAC38wkAAAAAALfzDQAAAAAAt/MRAAAAAAC38xUAAAAAALfzGQAAAAAAt/MdAAAAAAC3+wEAAAAAALf7BQAAAAAAt/sJAAAAAAC3+w0AAAAAALf7EQAAAAAAt/sVAAAAAAC3+xkAAAAAALf7HQAAAAAAx8MBAAAAAADHwwUAAAAAAMfDCQAAAAAAx8MNAAAAAADHwxEAAAAAAMfDFQAAAAAAx8MZAAAAAADHwx0AAAAAAMfLAQAAAAAAx8sFAAAAAADHywkAAAAAAMfLDQAAAAAAx8sRAAAAAADHyxUAAAAAAMfLGQAAAAAAx8sdAAAAAADH0wEAAAAAAMfTBQAAAAAAx9MJAAAAAADH0w0AAAAAAMfTEQAAAAAAx9MVAAAAAADH0xkAAAAAAMfTHQAAAAAAx9sBAAAAAADH2wUAAAAAAMfbCQAAAAAAx9sNAAAAAADH2xEAAAAAAMfbFQAAAAAAx9sZAAAAAADH2x0AAAAAAMfjAQAAAAAAx+MFAAAAAADH4wkAAAAAAMfjDQAAAAAAx+MRAAAAAADH4xUAAAAAAMfjGQAAAAAAx+MdAAAAAADH6wEAAAAAAMfrBQAAAAAAx+sJAAAAAADH6w0AAAAAAMfrEQAAAAAAx+sVAAAAAADH6xkAAAAAAMfrHQAAAAAAx/MBAAAAAADH8wUAAAAAAMfzCQAAAAAAx/MNAAAAAADH8xEAAAAAAMfzFQAAAAAAx/MZAAAAAADH8x0AAAAAAMf7AQAAAAAAx/sFAAAAAADH+wkAAAAAAMf7DQAAAAAAx/sRAAAAAADH+xUAAAAAAMf7GQAAAAAAx/sdAAAAAADXwwEAAAAAANfDBQAAAAAA18MJAAAAAADXww0AAAAAANfDEQAAAAAA18MVAAAAAADXwxkAAAAAANfDHQAAAAAA18sBAAAAAADXywUAAAAAANfLCQAAAAAA18sNAAAAAADXyxEAAAAAANfLFQAAAAAA18sZAAAAAADXyx0AAAAAANfTAQAAAAAA19MFAAAAAADX0wkAAAAAANfTDQAAAAAA19MRAAAAAADX0xUAAAAAANfTGQAAAAAA19MdAAAAAADX2wEAAAAAANfbBQAAAAAA19sJAAAAAADX2w0AAAAAANfbEQAAAAAA19sVAAAAAADX2xkAAAAAANfbHQAAAAAA1+MBAAAAAADX4wUAAAAAANfjCQAAAAAA1+MNAAAAAADX4xEAAAAAANfjFQAAAAAA1+MZAAAAAADX4x0AAAAAANfrAQAAAAAA1+sFAAAAAADX6wkAAAAAANfrDQAAAAAA1+sRAAAAAADX6xUAAAAAANfrGQAAAAAA1+sdAAAAAADX8wEAAAAAANfzBQAAAAAA1/MJAAAAAADX8w0AAAAAANfzEQAAAAAA1/MVAAAAAADX8xkAAAAAANfzHQAAAAAA1/sBAAAAAADX+wUAAAAAANf7CQAAAAAA1/sNAAAAAADX+xEAAAAAANf7FQAAAAAA1/sZAAAAAADX+x0AAAAAAOfDAQAAAAAA58MFAAAAAADnwwkAAAAAAOfDDQAAAAAA58MRAAAAAADnwxUAAAAAAOfDGQAAAAAA58MdAAAAAADnywEAAAAAAOfLBQAAAAAA58sJAAAAAADnyw0AAAAAAOfLEQAAAAAA58sVAAAAAADnyxkAAAAAAOfLHQAAAAAA59MBAAAAAADn0wUAAAAAAOfTCQAAAAAA59MNAAAAAADn0xEAAAAAAOfTFQAAAAAA59MZAAAAAADn0x0AAAAAAOfbAQAAAAAA59sFAAAAAADn2wkAAAAAAOfbDQAAAAAA59sRAAAAAADn2xUAAAAAAOfbGQAAAAAA59sdAAAAAADn4wEAAAAAAOfjBQAAAAAA5+MJAAAAAADn4w0AAAAAAOfjEQAAAAAA5+MVAAAAAADn4xkAAAAAAOfjHQAAAAAA5+sBAAAAAADn6wUAAAAAAOfrCQAAAAAA5+sNAAAAAADn6xEAAAAAAOfrFQAAAAAA5+sZAAAAAADn6x0AAAAAAOfzAQAAAAAA5/MFAAAAAADn8wkAAAAAAOfzDQAAAAAA5/MRAAAAAADn8xUAAAAAAOfzGQAAAAAA5/MdAAAAAADn+wEAAAAAAOf7BQAAAAAA5/sJAAAAAADn+w0AAAAAAOf7EQAAAAAA5/sVAAAAAADn+xkAAAAAAOf7HQAAAAAA98MBAAAAAAD3wwUAAAAAAPfDCQAAAAAA98MNAAAAAAD3wxEAAAAAAPfDFQAAAAAA98MZAAAAAAD3wx0AAAAAAPfLAQAAAAAA98sFAAAAAAD3ywkAAAAAAPfLDQAAAAAA98sRAAAAAAD3yxUAAAAAAPfLGQAAAAAA98sdAAAAAAD30wEAAAAAAPfTBQAAAAAA99MJAAAAAAD30w0AAAAAAPfTEQAAAAAA99MVAAAAAAD30xkAAAAAAPfTHQAAAAAA99sBAAAAAAD32wUAAAAAAPfbCQAAAAAA99sNAAAAAAD32xEAAAAAAPfbFQAAAAAA99sZAAAAAAD32x0AAAAAAPfjAQAAAAAA9+MFAAAAAAD34wkAAAAAAPfjDQAAAAAA9+MRAAAAAAD34xUAAAAAAPfjGQAAAAAA9+MdAAAAAAD36wEAAAAAAPfrBQAAAAAA9+sJAAAAAAD36w0AAAAAAPfrEQAAAAAA9+sVAAAAAAD36xkAAAAAAPfrHQAAAAAA9/MBAAAAAAD38wUAAAAAAPfzCQAAAAAA9/MNAAAAAAD38xEAAAAAAPfzFQAAAAAA9/MZAAAAAAD38x0AAAAAAPf7AQAAAAAA9/sFAAAAAAD3+wkAAAAAAPf7DQAAAAAA9/sRAAAAAAD3+xUAAAAAAPf7GQAAAAAA9/sdAAAAAACHw+EAAAAAAIfD4QIAAAAAh8PhBAAAAACHw+EGAAAAAIfD4QgAAAAAh8PhCgAAAACHw+EMAAAAAIfD4Q4AAAAAh8PlAAAAAACHw+UCAAAAAIfD5QQAAAAAh8PlBgAAAACHw+UIAAAAAIfD5QoAAAAAh8PlDAAAAACHw+UOAAAAAIfD6QAAAAAAh8PpAgAAAACHw+kEAAAAAIfD6QYAAAAAh8PpCAAAAACHw+kKAAAAAIfD6QwAAAAAh8PpDgAAAACHw+0AAAAAAIfD7QIAAAAAh8PtBAAAAACHw+0GAAAAAIfD7QgAAAAAh8PtCgAAAACHw+0MAAAAAIfD7Q4AAAAAh8PxAAAAAACHw/ECAAAAAIfD8QQAAAAAh8PxBgAAAACHw/EIAAAAAIfD8QoAAAAAh8PxDAAAAACHw/EOAAAAAIfD9QAAAAAAh8P1AgAAAACHw/UEAAAAAIfD9QYAAAAAh8P1CAAAAACHw/UKAAAAAIfD9QwAAAAAh8P1DgAAAACHw/kAAAAAAIfD+QIAAAAAh8P5BAAAAACHw/kGAAAAAIfD+QgAAAAAh8P5CgAAAACHw/kMAAAAAIfD+Q4AAAAAh8P9AAAAAACHw/0CAAAAAIfD/QQAAAAAh8P9BgAAAACHw/0IAAAAAIfD/QoAAAAAh8P9DAAAAACHw/0OAAAAAIfL4QAAAAAAh8vhAgAAAACHy+EEAAAAAIfL4QYAAAAAh8vhCAAAAACHy+EKAAAAAIfL4QwAAAAAh8vhDgAAAACHy+UAAAAAAIfL5QIAAAAAh8vlBAAAAACHy+UGAAAAAIfL5QgAAAAAh8vlCgAAAACHy+UMAAAAAIfL5Q4AAAAAh8vpAAAAAACHy+kCAAAAAIfL6QQAAAAAh8vpBgAAAACHy+kIAAAAAIfL6QoAAAAAh8vpDAAAAACHy+kOAAAAAIfL7QAAAAAAh8vtAgAAAACHy+0EAAAAAIfL7QYAAAAAh8vtCAAAAACHy+0KAAAAAIfL7QwAAAAAh8vtDgAAAACHy/EAAAAAAIfL8QIAAAAAh8vxBAAAAACHy/EGAAAAAIfL8QgAAAAAh8vxCgAAAACHy/EMAAAAAIfL8Q4AAAAAh8v1AAAAAACHy/UCAAAAAIfL9QQAAAAAh8v1BgAAAACHy/UIAAAAAIfL9QoAAAAAh8v1DAAAAACHy/UOAAAAAIfL+QAAAAAAh8v5AgAAAACHy/kEAAAAAIfL+QYAAAAAh8v5CAAAAAAEBAQEBAQEBAQEBAQEBQUABAQAQbTfAAtBCAAAAAQAAAAMAAAAAgAAAAoAAAAGAAAADgAAAAEAAAAJAAAABQAAAA0AAAADAAAADwAAAB8AAAAAAAAACwAAAAcAQYDgAAuARAYAAAAGAAAABgAAAAYAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAACwAAAAAAAAAbAAAAAAAAACsAAAAAAAAAOwAAAAAAAADLAgAAAAAAAMsGAAAAAAAAywoAAAAAAADLDgAAAAAAANsCAAAAAAAA2wYAAAAAAADbCgAAAAAAANsOAAAAAAAA6wIAAAAAAADrBgAAAAAAAOsKAAAAAAAA6w4AAAAAAAD7AgAAAAAAAPsGAAAAAAAA+woAAAAAAAD7DgAAAAAAAMuyAAAAAAAAy7IBAAAAAADLsgIAAAAAAMuyAwAAAAAAy7YAAAAAAADLtgEAAAAAAMu2AgAAAAAAy7YDAAAAAADLugAAAAAAAMu6AQAAAAAAy7oCAAAAAADLugMAAAAAAMu+AAAAAAAAy74BAAAAAADLvgIAAAAAAMu+AwAAAAAA27IAAAAAAADbsgEAAAAAANuyAgAAAAAA27IDAAAAAADbtgAAAAAAANu2AQAAAAAA27YCAAAAAADbtgMAAAAAANu6AAAAAAAA27oBAAAAAADbugIAAAAAANu6AwAAAAAA274AAAAAAADbvgEAAAAAANu+AgAAAAAA274DAAAAAADrsgAAAAAAAOuyAQAAAAAA67ICAAAAAADrsgMAAAAAAOu2AAAAAAAA67YBAAAAAADrtgIAAAAAAOu2AwAAAAAA67oAAAAAAADrugEAAAAAAOu6AgAAAAAA67oDAAAAAADrvgAAAAAAAOu+AQAAAAAA674CAAAAAADrvgMAAAAAAPuyAAAAAAAA+7IBAAAAAAD7sgIAAAAAAPuyAwAAAAAA+7YAAAAAAAD7tgEAAAAAAPu2AgAAAAAA+7YDAAAAAAD7ugAAAAAAAPu6AQAAAAAA+7oCAAAAAAD7ugMAAAAAAPu+AAAAAAAA+74BAAAAAAD7vgIAAAAAAPu+AwAAAAAAy7IsAAAAAADLsmwAAAAAAMuyrAAAAAAAy7LsAAAAAADLsi0AAAAAAMuybQAAAAAAy7KtAAAAAADLsu0AAAAAAMuyLgAAAAAAy7JuAAAAAADLsq4AAAAAAMuy7gAAAAAAy7IvAAAAAADLsm8AAAAAAMuyrwAAAAAAy7LvAAAAAADLtiwAAAAAAMu2bAAAAAAAy7asAAAAAADLtuwAAAAAAMu2LQAAAAAAy7ZtAAAAAADLtq0AAAAAAMu27QAAAAAAy7YuAAAAAADLtm4AAAAAAMu2rgAAAAAAy7buAAAAAADLti8AAAAAAMu2bwAAAAAAy7avAAAAAADLtu8AAAAAAMu6LAAAAAAAy7psAAAAAADLuqwAAAAAAMu67AAAAAAAy7otAAAAAADLum0AAAAAAMu6rQAAAAAAy7rtAAAAAADLui4AAAAAAMu6bgAAAAAAy7quAAAAAADLuu4AAAAAAMu6LwAAAAAAy7pvAAAAAADLuq8AAAAAAMu67wAAAAAAy74sAAAAAADLvmwAAAAAAMu+rAAAAAAAy77sAAAAAADLvi0AAAAAAMu+bQAAAAAAy76tAAAAAADLvu0AAAAAAMu+LgAAAAAAy75uAAAAAADLvq4AAAAAAMu+7gAAAAAAy74vAAAAAADLvm8AAAAAAMu+rwAAAAAAy77vAAAAAADbsiwAAAAAANuybAAAAAAA27KsAAAAAADbsuwAAAAAANuyLQAAAAAA27JtAAAAAADbsq0AAAAAANuy7QAAAAAA27IuAAAAAADbsm4AAAAAANuyrgAAAAAA27LuAAAAAADbsi8AAAAAANuybwAAAAAA27KvAAAAAADbsu8AAAAAANu2LAAAAAAA27ZsAAAAAADbtqwAAAAAANu27AAAAAAA27YtAAAAAADbtm0AAAAAANu2rQAAAAAA27btAAAAAADbti4AAAAAANu2bgAAAAAA27auAAAAAADbtu4AAAAAANu2LwAAAAAA27ZvAAAAAADbtq8AAAAAANu27wAAAAAA27osAAAAAADbumwAAAAAANu6rAAAAAAA27rsAAAAAADbui0AAAAAANu6bQAAAAAA27qtAAAAAADbuu0AAAAAANu6LgAAAAAA27puAAAAAADbuq4AAAAAANu67gAAAAAA27ovAAAAAADbum8AAAAAANu6rwAAAAAA27rvAAAAAADbviwAAAAAANu+bAAAAAAA276sAAAAAADbvuwAAAAAANu+LQAAAAAA275tAAAAAADbvq0AAAAAANu+7QAAAAAA274uAAAAAADbvm4AAAAAANu+rgAAAAAA277uAAAAAADbvi8AAAAAANu+bwAAAAAA276vAAAAAADbvu8AAAAAAOuyLAAAAAAA67JsAAAAAADrsqwAAAAAAOuy7AAAAAAA67ItAAAAAADrsm0AAAAAAOuyrQAAAAAA67LtAAAAAADrsi4AAAAAAOuybgAAAAAA67KuAAAAAADrsu4AAAAAAOuyLwAAAAAA67JvAAAAAADrsq8AAAAAAOuy7wAAAAAA67YsAAAAAADrtmwAAAAAAOu2rAAAAAAA67bsAAAAAADrti0AAAAAAOu2bQAAAAAA67atAAAAAADrtu0AAAAAAOu2LgAAAAAA67ZuAAAAAADrtq4AAAAAAOu27gAAAAAA67YvAAAAAADrtm8AAAAAAOu2rwAAAAAA67bvAAAAAADruiwAAAAAAOu6bAAAAAAA67qsAAAAAADruuwAAAAAAOu6LQAAAAAA67ptAAAAAADruq0AAAAAAOu67QAAAAAA67ouAAAAAADrum4AAAAAAOu6rgAAAAAA67ruAAAAAADrui8AAAAAAOu6bwAAAAAA67qvAAAAAADruu8AAAAAAOu+LAAAAAAA675sAAAAAADrvqwAAAAAAOu+7AAAAAAA674tAAAAAADrvm0AAAAAAOu+rQAAAAAA677tAAAAAADrvi4AAAAAAOu+bgAAAAAA676uAAAAAADrvu4AAAAAAOu+LwAAAAAA675vAAAAAADrvq8AAAAAAOu+7wAAAAAA+7IsAAAAAAD7smwAAAAAAPuyrAAAAAAA+7LsAAAAAAD7si0AAAAAAPuybQAAAAAA+7KtAAAAAAD7su0AAAAAAPuyLgAAAAAA+7JuAAAAAAD7sq4AAAAAAPuy7gAAAAAA+7IvAAAAAAD7sm8AAAAAAPuyrwAAAAAA+7LvAAAAAAD7tiwAAAAAAPu2bAAAAAAA+7asAAAAAAD7tuwAAAAAAPu2LQAAAAAA+7ZtAAAAAAD7tq0AAAAAAPu27QAAAAAA+7YuAAAAAAD7tm4AAAAAAPu2rgAAAAAA+7buAAAAAAD7ti8AAAAAAPu2bwAAAAAA+7avAAAAAAD7tu8AAAAAAPu6LAAAAAAA+7psAAAAAAD7uqwAAAAAAPu67AAAAAAA+7otAAAAAAD7um0AAAAAAPu6rQAAAAAA+7rtAAAAAAD7ui4AAAAAAPu6bgAAAAAA+7quAAAAAAD7uu4AAAAAAPu6LwAAAAAA+7pvAAAAAAD7uq8AAAAAAPu67wAAAAAA+74sAAAAAAD7vmwAAAAAAPu+rAAAAAAA+77sAAAAAAD7vi0AAAAAAPu+bQAAAAAA+76tAAAAAAD7vu0AAAAAAPu+LgAAAAAA+75uAAAAAAD7vq4AAAAAAPu+7gAAAAAA+74vAAAAAAD7vm8AAAAAAPu+rwAAAAAA+77vAAAAAADLsiwLAAAAAMuyLBsAAAAAy7IsKwAAAADLsiw7AAAAAMuybAsAAAAAy7JsGwAAAADLsmwrAAAAAMuybDsAAAAAy7KsCwAAAADLsqwbAAAAAMuyrCsAAAAAy7KsOwAAAADLsuwLAAAAAMuy7BsAAAAAy7LsKwAAAADLsuw7AAAAAMuyLQsAAAAAy7ItGwAAAADLsi0rAAAAAMuyLTsAAAAAy7JtCwAAAADLsm0bAAAAAMuybSsAAAAAy7JtOwAAAADLsq0LAAAAAMuyrRsAAAAAy7KtKwAAAADLsq07AAAAAMuy7QsAAAAAy7LtGwAAAADLsu0rAAAAAMuy7TsAAAAAy7IuCwAAAADLsi4bAAAAAMuyLisAAAAAy7IuOwAAAADLsm4LAAAAAMuybhsAAAAAy7JuKwAAAADLsm47AAAAAMuyrgsAAAAAy7KuGwAAAADLsq4rAAAAAMuyrjsAAAAAy7LuCwAAAADLsu4bAAAAAMuy7isAAAAAy7LuOwAAAADLsi8LAAAAAMuyLxsAAAAAy7IvKwAAAADLsi87AAAAAMuybwsAAAAAy7JvGwAAAADLsm8rAAAAAMuybzsAAAAAy7KvCwAAAADLsq8bAAAAAMuyrysAAAAAy7KvOwAAAADLsu8LAAAAAMuy7xsAAAAAy7LvKwAAAADLsu87AAAAAMu2LAsAAAAAy7YsGwAAAADLtiwrAAAAAMu2LDsAAAAAy7ZsCwAAAADLtmwbAAAAAMu2bCsAAAAAy7ZsOwAAAADLtqwLAAAAAMu2rBsAAAAAy7asKwAAAADLtqw7AAAAAMu27AsAAAAAy7bsGwAAAADLtuwrAAAAAMu27DsAAAAAy7YtCwAAAADLti0bAAAAAMu2LSsAAAAAy7YtOwAAAADLtm0LAAAAAMu2bRsAAAAAy7ZtKwAAAADLtm07AAAAAMu2rQsAAAAAy7atGwAAAADLtq0rAAAAAMu2rTsAAAAAy7btCwAAAADLtu0bAAAAAMu27SsAAAAAy7btOwAAAADLti4LAAAAAMu2LhsAAAAAy7YuKwAAAADLti47AAAAAMu2bgsAAAAAy7ZuGwAAAADLtm4rAAAAAMu2bjsAAAAAy7auCwAAAADLtq4bAAAAAMu2risAAAAAy7auOwAAAADLtu4LAAAAAMu27hsAAAAAy7buKwAAAADLtu47AAAAAMu2LwsAAAAAy7YvGwAAAADLti8rAAAAAMu2LzsAAAAAy7ZvCwAAAADLtm8bAAAAAMu2bysAAAAAy7ZvOwAAAADLtq8LAAAAAMu2rxsAAAAAy7avKwAAAADLtq87AAAAAMu27wsAAAAAy7bvGwAAAADLtu8rAAAAAMu27zsAAAAAy7osCwAAAADLuiwbAAAAAMu6LCsAAAAAy7osOwAAAADLumwLAAAAAMu6bBsAAAAAy7psKwAAAADLumw7AAAAAMu6rAsAAAAAy7qsGwAAAADLuqwrAAAAAMu6rDsAAAAAy7rsCwAAAADLuuwbAAAAAMu67CsAAAAAy7rsOwAAAADLui0LAAAAAMu6LRsAAAAAy7otKwAAAADLui07AAAAAMu6bQsAAAAAy7ptGwAAAADLum0rAAAAAMu6bTsAAAAAy7qtCwAAAADLuq0bAAAAAMu6rSsAAAAAy7qtOwAAAADLuu0LAAAAAMu67RsAAAAAy7rtKwAAAADLuu07AAAAAMu6LgsAAAAAy7ouGwAAAADLui4rAAAAAMu6LjsAAAAAy7puCwAAAADLum4bAAAAAMu6bisAAAAAy7puOwAAAADLuq4LAAAAAMu6rhsAAAAAy7quKwAAAADLuq47AAAAAMu67gsAAAAAy7ruGwAAAADLuu4rAAAAAMu67jsAAAAAy7ovCwAAAADLui8bAAAAAMu6LysAAAAAy7ovOwAAAADLum8LAAAAAMu6bxsAAAAAy7pvKwAAAADLum87AAAAAMu6rwsAAAAAy7qvGwAAAADLuq8rAAAAAMu6rzsAAAAAy7rvCwAAAADLuu8bAAAAAMu67ysAAAAAy7rvOwAAAADLviwLAAAAAMu+LBsAAAAAy74sKwAAAADLviw7AAAAAMu+bAsAAAAAy75sGwAAAADLvmwrAAAAAMu+bDsAAAAAy76sCwAAAADLvqwbAAAAAMu+rCsAAAAAy76sOwAAAADLvuwLAAAAAMu+7BsAAAAAy77sKwAAAADLvuw7AAAAAMu+LQsAAAAAy74tGwAAAADLvi0rAAAAAMu+LTsAAAAAy75tCwAAAADLvm0bAAAAAMu+bSsAAAAAy75tOwAAAADLvq0LAAAAAMu+rRsAAAAAy76tKwAAAADLvq07AAAAAMu+7QsAAAAAy77tGwAAAADLvu0rAAAAAMu+7TsAAAAAy74uCwAAAADLvi4bAAAAAMu+LisAAAAAy74uOwAAAADLvm4LAAAAAMu+bhsAAAAAy75uKwAAAADLvm47AAAAAMu+rgsAAAAAy76uGwAAAADLvq4rAAAAAMu+rjsAAAAAy77uCwAAAADLvu4bAAAAAMu+7isAAAAAy77uOwAAAADLvi8LAAAAAMu+LxsAAAAAy74vKwAAAADLvi87AAAAAMu+bwsAAAAAy75vGwAAAADLvm8rAAAAAMu+bzsAAAAAy76vCwAAAADLvq8bAAAAAMu+rysAAAAAy76vOwAAAADLvu8LAAAAAMu+7xsAAAAAy77vKwAAAADLvu87AAAAANuyLAsAAAAA27IsGwAAAADbsiwrAAAAANuyLDsAAAAA27JsCwAAAADbsmwbAAAAANuybCsAAAAA27JsOwAAAADbsqwLAAAAANuyrBsAAAAA27KsKwAAAADbsqw7AAAAANuy7AsAAAAA27LsGwAAAADbsuwrAAAAANuy7DsAAAAA27ItCwAAAADbsi0bAAAAANuyLSsAAAAA27ItOwAAAADbsm0LAAAAANuybRsAAAAA27JtKwAAAADbsm07AAAAANuyrQsAAAAA27KtGwAAAADbsq0rAAAAANuyrTsAAAAA27LtCwAAAADbsu0bAAAAANuy7SsAAAAA27LtOwAAAADbsi4LAAAAANuyLhsAAAAA27IuKwAAAADbsi47AAAAANuybgsAAAAA27JuGwAAAADbsm4rAAAAANuybjsAAAAA27KuCwAAAADbsq4bAAAAANuyrisAAAAA27KuOwAAAADbsu4LAAAAANuy7hsAAAAA27LuKwAAAADbsu47AAAAANuyLwsAAAAA27IvGwAAAADbsi8rAAAAANuyLzsAAAAA27JvCwAAAADbsm8bAAAAANuybysAAAAA27JvOwAAAADbsq8LAAAAANuyrxsAAAAA27KvKwAAAADbsq87AAAAANuy7wsAAAAA27LvGwAAAADbsu8rAAAAANuy7zsAAAAA27YsCwAAAADbtiwbAAAAANu2LCsAAAAA27YsOwAAAADbtmwLAAAAANu2bBsAAAAA27ZsKwAAAADbtmw7AAAAANu2rAsAAAAA27asGwAAAADbtqwrAAAAANu2rDsAAAAA27bsCwAAAADbtuwbAAAAANu27CsAAAAA27bsOwAAAADbti0LAAAAANu2LRsAAAAA27YtKwAAAADbti07AAAAANu2bQsAAAAA27ZtGwAAAADbtm0rAAAAANu2bTsAAAAA27atCwAAAADbtq0bAAAAANu2rSsAAAAA27atOwAAAADbtu0LAAAAANu27RsAAAAA27btKwAAAADbtu07AAAAANu2LgsAAAAA27YuGwAAAADbti4rAAAAANu2LjsAAAAA27ZuCwAAAADbtm4bAAAAANu2bisAAAAA27ZuOwAAAADbtq4LAAAAANu2rhsAAAAA27auKwAAAADbtq47AAAAAAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+PwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AQYSmAQv8AQEBAQECAgICAwMDAwQEBAQFBQUFBgYGBgcHBwcICAgICQkJCQoKCgoLCwsLDAwMDA0NDQ0ODg4ODw8PDxAQEBAREREREhISEhMTExMUFBQUFRUVFRYWFhYXFxcXGBgYGBkZGRkaGhoaGxsbGxwcHBwdHR0dHh4eHh8fHx8gICAgISEhISIiIiIjIyMjJCQkJCUlJSUmJiYmJycnJygoKCgpKSkpKioqKisrKyssLCwsLS0tLS4uLi4vLy8vMDAwMDExMTEyMjIyMzMzMzQ0NDQ1NTU1NjY2Njc3Nzc4ODg4OTk5OTo6Ojo7Ozs7PDw8PD09PT0+Pj4+Pz8/PwBBiaoBCwUEBAAABABBoKoBC+ABCAwQDAwUDBAYHAwMIAwkDCwsLCwsLCwsLCwgIBgoHAwMMDQ0NDA0NDQwNDQ0NDQwNDQ0NDQwNDQ0NDQYDBwMDAw4PDw8ODw8PDg8PDw8PDg8PDw8PDg8PDw8PBgMHAwAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMAQaGsAQteAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQEBAQMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAQEBAQBB4K0BC9UWAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIACAgICAgICAgICAgICAgIEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgwMDAwMDAwMDAwMDAwMDA4AAEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBgYGBgYGBgYGBgYGBgYGBwkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAYAAgAFAAEABwADAASAAIAGgAKABYABgAeAA4AEQABABkACQAVAAUAHQANABMAAwAbAAsAFwAHAB8ADwAQgACAGIAIgBSABIAcgAyAEoACgBqACoAWgAaAHoAOgBGAAYAZgAmAFYAFgB2ADYATgAOAG4ALgBeAB4AfgA+AEEAAQBhACEAUQARAHEAMQBJAAkAaQApAFkAGQB5ADkARQAFAGUAJQBVABUAdQA1AE0ADQBtAC0AXQAdAH0APQBDAAMAYwAjAFMAEwBzADMASwALAGsAKwBbABsAewA7AEcABwBnACcAVwAXAHcANwBPAA8AbwAvAF8AHwB/AD8AQIAAgGCAIIBQgBCAcIAwgEiACIBogCiAWIAYgHiAOIBEgASAZIAkgFSAFIB0gDSATIAMgGyALIBcgByAfIA8gEKAAoBigCKAUoASgHKAMoBKgAqAaoAqgFqAGoB6gDqARoAGgGaAJoBWgBaAdoA2gE6ADoBugC6AXoAegH6APoBBgAGAYYAhgFGAEYBxgDGASYAJgGmAKYBZgBmAeYA5gEWABYBlgCWAVYAVgHWANYBNgA2AbYAtgF2AHYB9gD2AQ4ADgGOAI4BTgBOAc4AzgEuAC4BrgCuAW4AbgHuAO4BHgAeAZ4AngFeAF4B3gDeAT4APgG+AL4BfgB+Af4A/gEBAAEBgQCBAUEAQQHBAMEBIQAhAaEAoQFhAGEB4QDhAREAEQGRAJEBUQBRAdEA0QExADEBsQCxAXEAcQHxAPEBCQAJAYkAiQFJAEkByQDJASkAKQGpAKkBaQBpAekA6QEZABkBmQCZAVkAWQHZANkBOQA5AbkAuQF5AHkB+QD5AQUABQGFAIUBRQBFAcUAxQElACUBpQClAWUAZQHlAOUBFQAVAZUAlQFVAFUB1QDVATUANQG1ALUBdQB1AfUA9QENAA0BjQCNAU0ATQHNAM0BLQAtAa0ArQFtAG0B7QDtAR0AHQGdAJ0BXQBdAd0A3QE9AD0BvQC9AX0AfQH9AP0BAwADAYMAgwFDAEMBwwDDASMAIwGjAKMBYwBjAeMA4wETABMBkwCTAVMAUwHTANMBMwAzAbMAswFzAHMB8wDzAQsACwGLAIsBSwBLAcsAywErACsBqwCrAWsAawHrAOsBGwAbAZsAmwFbAFsB2wDbATsAOwG7ALsBewB7AfsA+wEHAAcEBwIHBgcBBwUHAwcHhwCHBIcChwaHAYcFhwOHB0cARwRHAkcGRwFHBUcDRwfHAMcExwLHBscBxwXHA8cHJwAnBCcCJwYnAScFJwMnB6cApwSnAqcGpwGnBacDpwdnAGcEZwJnBmcBZwVnA2cH5wDnBOcC5wbnAecF5wPnBxcAFwQXAhcGFwEXBRcDFweXAJcElwKXBpcBlwWXA5cHVwBXBFcCVwZXAVcFVwNXB9cA1wTXAtcG1wHXBdcD1wc3ADcENwI3BjcBNwU3AzcHtwC3BLcCtwa3AbcFtwO3B3cAdwR3AncGdwF3BXcDdwf3APcE9wL3BvcB9wX3A/cHDwAPBA8CDwYPAQ8FDwMPB48AjwSPAo8GjwGPBY8DjwdPAE8ETwJPBk8BTwVPA08HzwDPBM8CzwbPAc8FzwPPBy8ALwQvAi8GLwEvBS8DLwevAK8ErwKvBq8BrwWvA68HbwBvBG8CbwZvAW8FbwNvB+8A7wTvAu8G7wHvBe8D7wcfAB8EHwIfBh8BHwUfAx8HnwCfBJ8CnwafAZ8FnwOfB18AXwRfAl8GXwFfBV8DXwffAN8E3wLfBt8B3wXfA98HPwA/BD8CPwY/AT8FPwM/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AAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMAQeGPAgteAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQEBAQMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAQEBAQBBoJECC70EAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIACAgICAgICAgICAgICAgIEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgwMDAwMDAwMDAwMDAwMDA4AAEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBgYGBgYGBgYGBgYGBgYGBwAAAAAAAAAAAQAAAAIAAAALAAAACwAAAAwAAAAMAEHwlQILgQEBAAAAAQAAAAkAAAAJAAAAAgAAAAIAAAACAAAAAgAAAAEAAAABAAAAAQAAAAEAAAAIAAAAAwAAAAMAAAADAAAAAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAAIAAAABAAAAAQAAAAEAAAACAAAAAcAAAAEAAAABAAAAAgAQYCXAgtd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EwBB8pcGCw5lbQAAAACpO6VgLBbkTwBBnpgGCxJm2gAAAAAAAAAAzRMmbQAAZFIAQdaYBgsC5TAAQfCYBgsKiFNkbgAAxgmMTgBBkpkGCwaGtgAARngAQaKZBgsChTkAQcCZBgsYSwTkGAAAAAAAAIYwTjsAAOshAACpKQZMAEHkmQYLDDYGAACMewAAaFgmTQBB/pkGCwKGXgBBipoGCwLmxQBBoJoGCwKrIwBBvpoGCwIHKwBB0JoGCwRqQKfVAEHkmgYLDIkyAAAAAAAAAACEPgBBgpsGCwSFCAsbAEGUmwYLFAg9JiwAAAAAKRaHHQAAAABMOUQ9AEG0mwYLvb8HjF4GvAAApl4AAOfYAAAAAIgNxUoAAAAAAAAAAHRpbWVkb3dubGlmZWxlZnRiYWNrY29kZWRhdGFzaG93b25seXNpdGVjaXR5b3Blbmp1c3RsaWtlZnJlZXdvcmt0ZXh0eWVhcm92ZXJib2R5bG92ZWZvcm1ib29rcGxheWxpdmVsaW5laGVscGhvbWVzaWRlbW9yZXdvcmRsb25ndGhlbXZpZXdmaW5kcGFnZWRheXNmdWxsaGVhZHRlcm1lYWNoYXJlYWZyb210cnVlbWFya2FibGV1cG9uaGlnaGRhdGVsYW5kbmV3c2V2ZW5uZXh0Y2FzZWJvdGhwb3N0dXNlZG1hZGVoYW5kaGVyZXdoYXRuYW1lTGlua2Jsb2dzaXplYmFzZWhlbGRtYWtlbWFpbnVzZXInKSAraG9sZGVuZHN3aXRoTmV3c3JlYWR3ZXJlc2lnbnRha2VoYXZlZ2FtZXNlZW5jYWxscGF0aHdlbGxwbHVzbWVudWZpbG1wYXJ0am9pbnRoaXNsaXN0Z29vZG5lZWR3YXlzd2VzdGpvYnNtaW5kYWxzb2xvZ29yaWNodXNlc2xhc3R0ZWFtYXJteWZvb2RraW5nd2lsbGVhc3R3YXJkYmVzdGZpcmVQYWdla25vd2F3YXkucG5nbW92ZXRoYW5sb2FkZ2l2ZXNlbGZub3RlbXVjaGZlZWRtYW55cm9ja2ljb25vbmNlbG9va2hpZGVkaWVkSG9tZXJ1bGVob3N0YWpheGluZm9jbHVibGF3c2xlc3NoYWxmc29tZXN1Y2h6b25lMTAwJW9uZXNjYXJlVGltZXJhY2VibHVlZm91cndlZWtmYWNlaG9wZWdhdmVoYXJkbG9zdHdoZW5wYXJra2VwdHBhc3NzaGlwcm9vbUhUTUxwbGFuVHlwZWRvbmVzYXZla2VlcGZsYWdsaW5rc29sZGZpdmV0b29rcmF0ZXRvd25qdW1wdGh1c2RhcmtjYXJkZmlsZWZlYXJzdGF5a2lsbHRoYXRmYWxsYXV0b2V2ZXIuY29tdGFsa3Nob3B2b3RlZGVlcG1vZGVyZXN0dHVybmJvcm5iYW5kZmVsbHJvc2V1cmwoc2tpbnJvbGVjb21lYWN0c2FnZXNtZWV0Z29sZC5qcGdpdGVtdmFyeWZlbHR0aGVuc2VuZGRyb3BWaWV3Y29weTEuMCI8L2E+c3RvcGVsc2VsaWVzdG91cnBhY2suZ2lmcGFzdGNzcz9ncmF5bWVhbiZndDtyaWRlc2hvdGxhdGVzYWlkcm9hZHZhciBmZWVsam9obnJpY2twb3J0ZmFzdCdVQS1kZWFkPC9iPnBvb3JiaWxsdHlwZVUuUy53b29kbXVzdDJweDtJbmZvcmFua3dpZGV3YW50d2FsbGxlYWRbMF07cGF1bHdhdmVzdXJlJCgnI3dhaXRtYXNzYXJtc2dvZXNnYWlubGFuZ3BhaWQhLS0gbG9ja3VuaXRyb290d2Fsa2Zpcm13aWZleG1sInNvbmd0ZXN0MjBweGtpbmRyb3dzdG9vbGZvbnRtYWlsc2FmZXN0YXJtYXBzY29yZXJhaW5mbG93YmFieXNwYW5zYXlzNHB4OzZweDthcnRzZm9vdHJlYWx3aWtpaGVhdHN0ZXB0cmlwb3JnL2xha2V3ZWFrdG9sZEZvcm1jYXN0ZmFuc2Jhbmt2ZXJ5cnVuc2p1bHl0YXNrMXB4O2dvYWxncmV3c2xvd2VkZ2VpZD0ic2V0czVweDsuanM/NDBweGlmIChzb29uc2VhdG5vbmV0dWJlemVyb3NlbnRyZWVkZmFjdGludG9naWZ0aGFybTE4cHhjYW1laGlsbGJvbGR6b29tdm9pZGVhc3lyaW5nZmlsbHBlYWtpbml0Y29zdDNweDtqYWNrdGFnc2JpdHNyb2xsZWRpdGtuZXduZWFyPCEtLWdyb3dKU09OZHV0eU5hbWVzYWxleW91IGxvdHNwYWluamF6emNvbGRleWVzZmlzaHd3dy5yaXNrdGFic3ByZXYxMHB4cmlzZTI1cHhCbHVlZGluZzMwMCxiYWxsZm9yZGVhcm53aWxkYm94LmZhaXJsYWNrdmVyc3BhaXJqdW5ldGVjaGlmKCFwaWNrZXZpbCQoIiN3YXJtbG9yZGRvZXNwdWxsLDAwMGlkZWFkcmF3aHVnZXNwb3RmdW5kYnVybmhyZWZjZWxsa2V5c3RpY2tob3VybG9zc2Z1ZWwxMnB4c3VpdGRlYWxSU1MiYWdlZGdyZXlHRVQiZWFzZWFpbXNnaXJsYWlkczhweDtuYXZ5Z3JpZHRpcHMjOTk5d2Fyc2xhZHljYXJzKTsgfXBocD9oZWxsdGFsbHdob216aDrlKi8NCiAxMDBoYWxsLgoKQTdweDtwdXNoY2hhdDBweDtjcmV3Ki88L2hhc2g3NXB4ZmxhdHJhcmUgJiYgdGVsbGNhbXBvbnRvbGFpZG1pc3Nza2lwdGVudGZpbmVtYWxlZ2V0c3Bsb3Q0MDAsDQoNCmNvb2xmZWV0LnBocDxicj5lcmljbW9zdGd1aWRiZWxsZGVzY2hhaXJtYXRoYXRvbS9pbWcmIzgybHVja2NlbnQwMDA7dGlueWdvbmVodG1sc2VsbGRydWdGUkVFbm9kZW5pY2s/aWQ9bG9zZW51bGx2YXN0d2luZFJTUyB3ZWFycmVseWJlZW5zYW1lZHVrZW5hc2FjYXBld2lzaGd1bGZUMjM6aGl0c3Nsb3RnYXRla2lja2JsdXJ0aGV5MTVweCcnKTspOyI+bXNpZXdpbnNiaXJkc29ydGJldGFzZWVrVDE4Om9yZHN0cmVlbWFsbDYwcHhmYXJt4oCZc2JveXNbMF0uJyk7IlBPU1RiZWFya2lkcyk7fX1tYXJ5dGVuZChVSylxdWFkemg65i1zaXotLS0tcHJvcCcpOw1saWZ0VDE5OnZpY2VhbmR5ZGVidD5SU1Nwb29sbmVja2Jsb3dUMTY6ZG9vcmV2YWxUMTc6bGV0c2ZhaWxvcmFscG9sbG5vdmFjb2xzZ2VuZSDigJRzb2Z0cm9tZXRpbGxyb3NzPGgzPnBvdXJmYWRlcGluazx0cj5taW5pKXwhKG1pbmV6aDroYmFyc2hlYXIwMCk7bWlsayAtLT5pcm9uZnJlZGRpc2t3ZW50c29pbHB1dHMvanMvaG9seVQyMjpJU0JOVDIwOmFkYW1zZWVzPGgyPmpzb24nLCAnY29udFQyMTogUlNTbG9vcGFzaWFtb29uPC9wPnNvdWxMSU5FZm9ydGNhcnRUMTQ6PGgxPjgwcHghLS08OXB4O1QwNDptaWtlOjQ2Wm5pY2VpbmNoWW9ya3JpY2V6aDrkJykpO3B1cmVtYWdlcGFyYXRvbmVib25kOjM3Wl9vZl8nXSk7MDAwLHpoOud0YW5reWFyZGJvd2xidXNoOjU2WkphdmEzMHB4Cnx9CiVDMyU6MzRaamVmZkVYUEljYXNodmlzYWdvbGZzbm93emg66XF1ZXIuY3Nzc2lja21lYXRtaW4uYmluZGRlbGxoaXJlcGljc3JlbnQ6MzZaSFRUUC0yMDFmb3Rvd29sZkVORCB4Ym94OjU0WkJPRFlkaWNrOwp9CmV4aXQ6MzVadmFyc2JlYXQnfSk7ZGlldDk5OTthbm5lfX08L1tpXS5MYW5na23CsndpcmV0b3lzYWRkc3NlYWxhbGV4OwoJfWVjaG9uaW5lLm9yZzAwNSl0b255amV3c3NhbmRsZWdzcm9vZjAwMCkgMjAwd2luZWdlYXJkb2dzYm9vdGdhcnljdXRzdHlsZXRlbXB0aW9uLnhtbGNvY2tnYW5nJCgnLjUwcHhQaC5EbWlzY2FsYW5sb2FuZGVza21pbGVyeWFudW5peGRpc2MpO30KZHVzdGNsaXApLgoKNzBweC0yMDBEVkRzN10+PHRhcGVkZW1vaSsrKXdhZ2VldXJvcGhpbG9wdHNob2xlRkFRc2FzaW4tMjZUbGFic3BldHNVUkwgYnVsa2Nvb2s7fQ0KSEVBRFswXSlhYmJyanVhbigxOThsZXNodHdpbjwvaT5zb255Z3V5c2Z1Y2twaXBlfC0KITAwMiluZG93WzFdO1tdOwpMb2cgc2FsdA0KCQliYW5ndHJpbWJhdGgpew0KMDBweAp9KTtrbzrsZmVlc2FkPg1zOi8vIFtdO3RvbGxwbHVnKCl7CnsNCiAuanMnMjAwcGR1YWxib2F0LkpQRyk7Cn1xdW90KTsKCicpOwoNCn0NMjAxNDIwMTUyMDE2MjAxNzIwMTgyMDE5MjAyMDIwMjEyMDIyMjAyMzIwMjQyMDI1MjAyNjIwMjcyMDI4MjAyOTIwMzAyMDMxMjAzMjIwMzMyMDM0MjAzNTIwMzYyMDM3MjAxMzIwMTIyMDExMjAxMDIwMDkyMDA4MjAwNzIwMDYyMDA1MjAwNDIwMDMyMDAyMjAwMTIwMDAxOTk5MTk5ODE5OTcxOTk2MTk5NTE5OTQxOTkzMTk5MjE5OTExOTkwMTk4OTE5ODgxOTg3MTk4NjE5ODUxOTg0MTk4MzE5ODIxOTgxMTk4MDE5NzkxOTc4MTk3NzE5NzYxOTc1MTk3NDE5NzMxOTcyMTk3MTE5NzAxOTY5MTk2ODE5NjcxOTY2MTk2NTE5NjQxOTYzMTk2MjE5NjExOTYwMTk1OTE5NTgxOTU3MTk1NjE5NTUxOTU0MTk1MzE5NTIxOTUxMTk1MDEwMDAxMDI0MTM5NDAwMDA5OTk5Y29tb23DoXNlc3RlZXN0YXBlcm90b2RvaGFjZWNhZGFhw7FvYmllbmTDrWFhc8OtdmlkYWNhc29vdHJvZm9yb3NvbG9vdHJhY3VhbGRpam9zaWRvZ3JhbnRpcG90ZW1hZGViZWFsZ29xdcOpZXN0b25hZGF0cmVzcG9jb2Nhc2FiYWpvdG9kYXNpbm9hZ3VhcHVlc3Vub3NhbnRlZGljZWx1aXNlbGxhbWF5b3pvbmFhbW9ycGlzb29icmFjbGljZWxsb2Rpb3Nob3JhY2FzadC30LDQvdCw0L7QvNGA0LDRgNGD0YLQsNC90LXQv9C+0L7RgtC40LfQvdC+0LTQvtGC0L7QttC10L7QvdC40YXQndCw0LXQtdCx0YvQvNGL0JLRi9GB0L7QstGL0LLQvtCd0L7QvtCx0J/QvtC70LjQvdC40KDQpNCd0LXQnNGL0YLRi9Ce0L3QuNC80LTQsNCX0LDQlNCw0J3Rg9Ce0LHRgtC10JjQt9C10LnQvdGD0LzQvNCi0YvRg9C22YHZitij2YbZhdin2YXYudmD2YTYo9mI2LHYr9mK2KfZgdmJ2YfZiNmE2YXZhNmD2KfZiNmE2YfYqNiz2KfZhNil2YbZh9mK2KPZitmC2K/Zh9mE2KvZhdio2YfZhNmI2YTZitio2YTYp9mK2KjZg9i02YrYp9mF2KPZhdmG2KrYqNmK2YTZhtit2KjZh9mF2YXYtNmI2LRmaXJzdHZpZGVvbGlnaHR3b3JsZG1lZGlhd2hpdGVjbG9zZWJsYWNrcmlnaHRzbWFsbGJvb2tzcGxhY2VtdXNpY2ZpZWxkb3JkZXJwb2ludHZhbHVlbGV2ZWx0YWJsZWJvYXJkaG91c2Vncm91cHdvcmtzeWVhcnNzdGF0ZXRvZGF5d2F0ZXJzdGFydHN0eWxlZGVhdGhwb3dlcnBob25lbmlnaHRlcnJvcmlucHV0YWJvdXR0ZXJtc3RpdGxldG9vbHNldmVudGxvY2FsdGltZXNsYXJnZXdvcmRzZ2FtZXNzaG9ydHNwYWNlZm9jdXNjbGVhcm1vZGVsYmxvY2tndWlkZXJhZGlvc2hhcmV3b21lbmFnYWlubW9uZXlpbWFnZW5hbWVzeW91bmdsaW5lc2xhdGVyY29sb3JncmVlbmZyb250JmFtcDt3YXRjaGZvcmNlcHJpY2VydWxlc2JlZ2luYWZ0ZXJ2aXNpdGlzc3VlYXJlYXNiZWxvd2luZGV4dG90YWxob3Vyc2xhYmVscHJpbnRwcmVzc2J1aWx0bGlua3NzcGVlZHN0dWR5dHJhZGVmb3VuZHNlbnNldW5kZXJzaG93bmZvcm1zcmFuZ2VhZGRlZHN0aWxsbW92ZWR0YWtlbmFib3ZlZmxhc2hmaXhlZG9mdGVub3RoZXJ2aWV3c2NoZWNrbGVnYWxyaXZlcml0ZW1zcXVpY2tzaGFwZWh1bWFuZXhpc3Rnb2luZ21vdmlldGhpcmRiYXNpY3BlYWNlc3RhZ2V3aWR0aGxvZ2luaWRlYXN3cm90ZXBhZ2VzdXNlcnNkcml2ZXN0b3JlYnJlYWtzb3V0aHZvaWNlc2l0ZXNtb250aHdoZXJlYnVpbGR3aGljaGVhcnRoZm9ydW10aHJlZXNwb3J0cGFydHlDbGlja2xvd2VybGl2ZXNjbGFzc2xheWVyZW50cnlzdG9yeXVzYWdlc291bmRjb3VydHlvdXIgYmlydGhwb3B1cHR5cGVzYXBwbHlJbWFnZWJlaW5ndXBwZXJub3Rlc2V2ZXJ5c2hvd3NtZWFuc2V4dHJhbWF0Y2h0cmFja2tub3duZWFybHliZWdhbnN1cGVycGFwZXJub3J0aGxlYXJuZ2l2ZW5uYW1lZGVuZGVkVGVybXNwYXJ0c0dyb3VwYnJhbmR1c2luZ3dvbWFuZmFsc2VyZWFkeWF1ZGlvdGFrZXN3aGlsZS5jb20vbGl2ZWRjYXNlc2RhaWx5Y2hpbGRncmVhdGp1ZGdldGhvc2V1bml0c25ldmVyYnJvYWRjb2FzdGNvdmVyYXBwbGVmaWxlc2N5Y2xlc2NlbmVwbGFuc2NsaWNrd3JpdGVxdWVlbnBpZWNlZW1haWxmcmFtZW9sZGVycGhvdG9saW1pdGNhY2hlY2l2aWxzY2FsZWVudGVydGhlbWV0aGVyZXRvdWNoYm91bmRyb3lhbGFza2Vkd2hvbGVzaW5jZXN0b2NrIG5hbWVmYWl0aGhlYXJ0ZW1wdHlvZmZlcnNjb3Blb3duZWRtaWdodGFsYnVtdGhpbmtibG9vZGFycmF5bWFqb3J0cnVzdGNhbm9udW5pb25jb3VudHZhbGlkc3RvbmVTdHlsZUxvZ2luaGFwcHlvY2N1cmxlZnQ6ZnJlc2hxdWl0ZWZpbG1zZ3JhZGVuZWVkc3VyYmFuZmlnaHRiYXNpc2hvdmVyYXV0bztyb3V0ZS5odG1sbWl4ZWRmaW5hbFlvdXIgc2xpZGV0b3BpY2Jyb3duYWxvbmVkcmF3bnNwbGl0cmVhY2hSaWdodGRhdGVzbWFyY2hxdW90ZWdvb2RzTGlua3Nkb3VidGFzeW5jdGh1bWJhbGxvd2NoaWVmeW91dGhub3ZlbDEwcHg7c2VydmV1bnRpbGhhbmRzQ2hlY2tTcGFjZXF1ZXJ5amFtZXNlcXVhbHR3aWNlMCwwMDBTdGFydHBhbmVsc29uZ3Nyb3VuZGVpZ2h0c2hpZnR3b3J0aHBvc3RzbGVhZHN3ZWVrc2F2b2lkdGhlc2VtaWxlc3BsYW5lc21hcnRhbHBoYXBsYW50bWFya3NyYXRlc3BsYXlzY2xhaW1zYWxlc3RleHRzc3RhcnN3cm9uZzwvaDM+dGhpbmcub3JnL211bHRpaGVhcmRQb3dlcnN0YW5kdG9rZW5zb2xpZCh0aGlzYnJpbmdzaGlwc3N0YWZmdHJpZWRjYWxsc2Z1bGx5ZmFjdHNhZ2VudFRoaXMgLy8tLT5hZG1pbmVneXB0RXZlbnQxNXB4O0VtYWlsdHJ1ZSJjcm9zc3NwZW50YmxvZ3Nib3giPm5vdGVkbGVhdmVjaGluYXNpemVzZ3Vlc3Q8L2g0PnJvYm90aGVhdnl0cnVlLHNldmVuZ3JhbmRjcmltZXNpZ25zYXdhcmVkYW5jZXBoYXNlPjwhLS1lbl9VUyYjMzk7MjAwcHhfbmFtZWxhdGluZW5qb3lhamF4LmF0aW9uc21pdGhVLlMuIGhvbGRzcGV0ZXJpbmRpYW5hdiI+Y2hhaW5zY29yZWNvbWVzZG9pbmdwcmlvclNoYXJlMTk5MHNyb21hbmxpc3RzamFwYW5mYWxsc3RyaWFsb3duZXJhZ3JlZTwvaDI+YWJ1c2VhbGVydG9wZXJhIi0vL1djYXJkc2hpbGxzdGVhbXNQaG90b3RydXRoY2xlYW4ucGhwP3NhaW50bWV0YWxsb3Vpc21lYW50cHJvb2ZicmllZnJvdyI+Z2VucmV0cnVja2xvb2tzVmFsdWVGcmFtZS5uZXQvLS0+Cjx0cnkgewp2YXIgbWFrZXNjb3N0c3BsYWluYWR1bHRxdWVzdHRyYWlubGFib3JoZWxwc2NhdXNlbWFnaWNtb3RvcnRoZWlyMjUwcHhsZWFzdHN0ZXBzQ291bnRjb3VsZGdsYXNzc2lkZXNmdW5kc2hvdGVsYXdhcmRtb3V0aG1vdmVzcGFyaXNnaXZlc2R1dGNodGV4YXNmcnVpdG51bGwsfHxbXTt0b3AiPgo8IS0tUE9TVCJvY2Vhbjxici8+Zmxvb3JzcGVha2RlcHRoIHNpemViYW5rc2NhdGNoY2hhcnQyMHB4O2FsaWduZGVhbHN3b3VsZDUwcHg7dXJsPSJwYXJrc21vdXNlTW9zdCAuLi48L2Ftb25nYnJhaW5ib2R5IG5vbmU7YmFzZWRjYXJyeWRyYWZ0cmVmZXJwYWdlX2hvbWUubWV0ZXJkZWxheWRyZWFtcHJvdmVqb2ludDwvdHI+ZHJ1Z3M8IS0tIGFwcmlsaWRlYWxhbGxlbmV4YWN0Zm9ydGhjb2Rlc2xvZ2ljVmlldyBzZWVtc2JsYW5rcG9ydHMgKDIwMHNhdmVkX2xpbmtnb2Fsc2dyYW50Z3JlZWtob21lc3JpbmdzcmF0ZWQzMHB4O3dob3NlcGFyc2UoKTsiIEJsb2NrbGludXhqb25lc3BpeGVsJyk7Ij4pO2lmKC1sZWZ0ZGF2aWRob3JzZUZvY3VzcmFpc2Vib3hlc1RyYWNrZW1lbnQ8L2VtPmJhciI+LnNyYz10b3dlcmFsdD0iY2FibGVoZW5yeTI0cHg7c2V0dXBpdGFseXNoYXJwbWlub3J0YXN0ZXdhbnRzdGhpcy5yZXNldHdoZWVsZ2lybHMvY3NzLzEwMCU7Y2x1YnNzdHVmZmJpYmxldm90ZXMgMTAwMGtvcmVhfSk7DQpiYW5kc3F1ZXVlPSB7fTs4MHB4O2NraW5new0KCQlhaGVhZGNsb2NraXJpc2hsaWtlIHJhdGlvc3RhdHNGb3JtInlhaG9vKVswXTtBYm91dGZpbmRzPC9oMT5kZWJ1Z3Rhc2tzVVJMID1jZWxsc30pKCk7MTJweDtwcmltZXRlbGxzdHVybnMweDYwMC5qcGcic3BhaW5iZWFjaHRheGVzbWljcm9hbmdlbC0tPjwvZ2lmdHNzdGV2ZS1saW5rYm9keS59KTsKCW1vdW50ICgxOTlGQVE8L3JvZ2VyZnJhbmtDbGFzczI4cHg7ZmVlZHM8aDE+PHNjb3R0dGVzdHMyMnB4O2RyaW5rKSB8fCBsZXdpc3NoYWxsIzAzOTsgZm9yIGxvdmVkd2FzdGUwMHB4O2phOuOCc2ltb248Zm9udHJlcGx5bWVldHN1bnRlcmNoZWFwdGlnaHRCcmFuZCkgIT0gZHJlc3NjbGlwc3Jvb21zb25rZXltb2JpbG1haW4uTmFtZSBwbGF0ZWZ1bm55dHJlZXNjb20vIjEuanBnd21vZGVwYXJhbVNUQVJUbGVmdCBpZGRlbiwgMjAxKTsKfQpmb3JtLnZpcnVzY2hhaXJ0cmFuc3dvcnN0UGFnZXNpdGlvbnBhdGNoPCEtLQpvLWNhY2Zpcm1zdG91cnMsMDAwIGFzaWFuaSsrKXthZG9iZScpWzBdaWQ9MTBib3RoO21lbnUgLjIubWkucG5nImtldmluY29hY2hDaGlsZGJydWNlMi5qcGdVUkwpKy5qcGd8c3VpdGVzbGljZWhhcnJ5MTIwIiBzd2VldHRyPg0KbmFtZT1kaWVnb3BhZ2Ugc3dpc3MtLT4KCiNmZmY7Ij5Mb2cuY29tInRyZWF0c2hlZXQpICYmIDE0cHg7c2xlZXBudGVudGZpbGVkamE644NpZD0iY05hbWUid29yc2VzaG90cy1ib3gtZGVsdGEKJmx0O2JlYXJzOjQ4WjxkYXRhLXJ1cmFsPC9hPiBzcGVuZGJha2Vyc2hvcHM9ICIiO3BocCI+Y3Rpb24xM3B4O2JyaWFuaGVsbG9zaXplPW89JTJGIGpvaW5tYXliZTxpbWcgaW1nIj4sIGZqc2ltZyIgIilbMF1NVG9wQlR5cGUibmV3bHlEYW5za2N6ZWNodHJhaWxrbm93czwvaDU+ZmFxIj56aC1jbjEwKTsKLTEiKTt0eXBlPWJsdWVzdHJ1bHlkYXZpcy5qcyc7Pg0KPCFzdGVlbCB5b3UgaDI+DQpmb3JtIGplc3VzMTAwJSBtZW51Lg0KCQ0Kd2FsZXNyaXNrc3VtZW50ZGRpbmdiLWxpa3RlYWNoZ2lmIiB2ZWdhc2RhbnNrZWVzdGlzaHFpcHN1b21pc29icmVkZXNkZWVudHJldG9kb3NwdWVkZWHDsW9zZXN0w6F0aWVuZWhhc3Rhb3Ryb3NwYXJ0ZWRvbmRlbnVldm9oYWNlcmZvcm1hbWlzbW9tZWpvcm11bmRvYXF1w61kw61hc3PDs2xvYXl1ZGFmZWNoYXRvZGFzdGFudG9tZW5vc2RhdG9zb3RyYXNzaXRpb211Y2hvYWhvcmFsdWdhcm1heW9yZXN0b3Nob3Jhc3RlbmVyYW50ZXNmb3Rvc2VzdGFzcGHDrXNudWV2YXNhbHVkZm9yb3NtZWRpb3F1aWVubWVzZXNwb2RlcmNoaWxlc2Vyw6F2ZWNlc2RlY2lyam9zw6llc3RhcnZlbnRhZ3J1cG9oZWNob2VsbG9zdGVuZ29hbWlnb2Nvc2Fzbml2ZWxnZW50ZW1pc21hYWlyZXNqdWxpb3RlbWFzaGFjaWFmYXZvcmp1bmlvbGlicmVwdW50b2J1ZW5vYXV0b3JhYnJpbGJ1ZW5hdGV4dG9tYXJ6b3NhYmVybGlzdGFsdWVnb2PDs21vZW5lcm9qdWVnb3BlcsO6aGFiZXJlc3RveW51bmNhbXVqZXJ2YWxvcmZ1ZXJhbGlicm9ndXN0YWlndWFsdm90b3NjYXNvc2d1w61hcHVlZG9zb21vc2F2aXNvdXN0ZWRkZWJlbm5vY2hlYnVzY2FmYWx0YWV1cm9zc2VyaWVkaWNob2N1cnNvY2xhdmVjYXNhc2xlw7NucGxhem9sYXJnb29icmFzdmlzdGFhcG95b2p1bnRvdHJhdGF2aXN0b2NyZWFyY2FtcG9oZW1vc2NpbmNvY2FyZ29waXNvc29yZGVuaGFjZW7DoXJlYWRpc2NvcGVkcm9jZXJjYXB1ZWRhcGFwZWxtZW5vcsO6dGlsY2xhcm9qb3JnZWNhbGxlcG9uZXJ0YXJkZW5hZGllbWFyY2FzaWd1ZWVsbGFzc2lnbG9jb2NoZW1vdG9zbWFkcmVjbGFzZXJlc3RvbmnDsW9xdWVkYXBhc2FyYmFuY29oaWpvc3ZpYWplcGFibG/DqXN0ZXZpZW5lcmVpbm9kZWphcmZvbmRvY2FuYWxub3J0ZWxldHJhY2F1c2F0b21hcm1hbm9zbHVuZXNhdXRvc3ZpbGxhdmVuZG9wZXNhcnRpcG9zdGVuZ2FtYXJjb2xsZXZhcGFkcmV1bmlkb3ZhbW9zem9uYXNhbWJvc2JhbmRhbWFyaWFhYnVzb211Y2hhc3ViaXJyaW9qYXZpdmlyZ3JhZG9jaGljYWFsbMOtam92ZW5kaWNoYWVzdGFudGFsZXNzYWxpcnN1ZWxvcGVzb3NmaW5lc2xsYW1hYnVzY2/DqXN0YWxsZWdhbmVncm9wbGF6YWh1bW9ycGFnYXJqdW50YWRvYmxlaXNsYXNib2xzYWJhw7FvaGFibGFsdWNoYcOBcmVhZGljZW5qdWdhcm5vdGFzdmFsbGVhbGzDoWNhcmdhZG9sb3JhYmFqb2VzdMOpZ3VzdG9tZW50ZW1hcmlvZmlybWFjb3N0b2ZpY2hhcGxhdGFob2dhcmFydGVzbGV5ZXNhcXVlbG11c2VvYmFzZXNwb2Nvc21pdGFkY2llbG9jaGljb21pZWRvZ2FuYXJzYW50b2V0YXBhZGViZXNwbGF5YXJlZGVzc2lldGVjb3J0ZWNvcmVhZHVkYXNkZXNlb3ZpZWpvZGVzZWFhZ3VhcyZxdW90O2RvbWFpbmNvbW1vbnN0YXR1c2V2ZW50c21hc3RlcnN5c3RlbWFjdGlvbmJhbm5lcnJlbW92ZXNjcm9sbHVwZGF0ZWdsb2JhbG1lZGl1bWZpbHRlcm51bWJlcmNoYW5nZXJlc3VsdHB1YmxpY3NjcmVlbmNob29zZW5vcm1hbHRyYXZlbGlzc3Vlc3NvdXJjZXRhcmdldHNwcmluZ21vZHVsZW1vYmlsZXN3aXRjaHBob3Rvc2JvcmRlcnJlZ2lvbml0c2VsZnNvY2lhbGFjdGl2ZWNvbHVtbnJlY29yZGZvbGxvd3RpdGxlPmVpdGhlcmxlbmd0aGZhbWlseWZyaWVuZGxheW91dGF1dGhvcmNyZWF0ZXJldmlld3N1bW1lcnNlcnZlcnBsYXllZHBsYXllcmV4cGFuZHBvbGljeWZvcm1hdGRvdWJsZXBvaW50c3Nlcmllc3BlcnNvbmxpdmluZ2Rlc2lnbm1vbnRoc2ZvcmNlc3VuaXF1ZXdlaWdodHBlb3BsZWVuZXJneW5hdHVyZXNlYXJjaGZpZ3VyZWhhdmluZ2N1c3RvbW9mZnNldGxldHRlcndpbmRvd3N1Ym1pdHJlbmRlcmdyb3Vwc3VwbG9hZGhlYWx0aG1ldGhvZHZpZGVvc3NjaG9vbGZ1dHVyZXNoYWRvd2RlYmF0ZXZhbHVlc09iamVjdG90aGVyc3JpZ2h0c2xlYWd1ZWNocm9tZXNpbXBsZW5vdGljZXNoYXJlZGVuZGluZ3NlYXNvbnJlcG9ydG9ubGluZXNxdWFyZWJ1dHRvbmltYWdlc2VuYWJsZW1vdmluZ2xhdGVzdHdpbnRlckZyYW5jZXBlcmlvZHN0cm9uZ3JlcGVhdExvbmRvbmRldGFpbGZvcm1lZGRlbWFuZHNlY3VyZXBhc3NlZHRvZ2dsZXBsYWNlc2RldmljZXN0YXRpY2NpdGllc3N0cmVhbXllbGxvd2F0dGFja3N0cmVldGZsaWdodGhpZGRlbmluZm8iPm9wZW5lZHVzZWZ1bHZhbGxleWNhdXNlc2xlYWRlcnNlY3JldHNlY29uZGRhbWFnZXNwb3J0c2V4Y2VwdHJhdGluZ3NpZ25lZHRoaW5nc2VmZmVjdGZpZWxkc3N0YXRlc29mZmljZXZpc3VhbGVkaXRvcnZvbHVtZVJlcG9ydG11c2V1bW1vdmllc3BhcmVudGFjY2Vzc21vc3RseW1vdGhlciIgaWQ9Im1hcmtldGdyb3VuZGNoYW5jZXN1cnZleWJlZm9yZXN5bWJvbG1vbWVudHNwZWVjaG1vdGlvbmluc2lkZW1hdHRlckNlbnRlcm9iamVjdGV4aXN0c21pZGRsZUV1cm9wZWdyb3d0aGxlZ2FjeW1hbm5lcmVub3VnaGNhcmVlcmFuc3dlcm9yaWdpbnBvcnRhbGNsaWVudHNlbGVjdHJhbmRvbWNsb3NlZHRvcGljc2NvbWluZ2ZhdGhlcm9wdGlvbnNpbXBseXJhaXNlZGVzY2FwZWNob3NlbmNodXJjaGRlZmluZXJlYXNvbmNvcm5lcm91dHB1dG1lbW9yeWlmcmFtZXBvbGljZW1vZGVsc051bWJlcmR1cmluZ29mZmVyc3N0eWxlc2tpbGxlZGxpc3RlZGNhbGxlZHNpbHZlcm1hcmdpbmRlbGV0ZWJldHRlcmJyb3dzZWxpbWl0c0dsb2JhbHNpbmdsZXdpZGdldGNlbnRlcmJ1ZGdldG5vd3JhcGNyZWRpdGNsYWltc2VuZ2luZXNhZmV0eWNob2ljZXNwaXJpdC1zdHlsZXNwcmVhZG1ha2luZ25lZWRlZHJ1c3NpYXBsZWFzZWV4dGVudFNjcmlwdGJyb2tlbmFsbG93c2NoYXJnZWRpdmlkZWZhY3Rvcm1lbWJlci1iYXNlZHRoZW9yeWNvbmZpZ2Fyb3VuZHdvcmtlZGhlbHBlZENodXJjaGltcGFjdHNob3VsZGFsd2F5c2xvZ28iIGJvdHRvbWxpc3QiPil7dmFyIHByZWZpeG9yYW5nZUhlYWRlci5wdXNoKGNvdXBsZWdhcmRlbmJyaWRnZWxhdW5jaFJldmlld3Rha2luZ3Zpc2lvbmxpdHRsZWRhdGluZ0J1dHRvbmJlYXV0eXRoZW1lc2ZvcmdvdFNlYXJjaGFuY2hvcmFsbW9zdGxvYWRlZENoYW5nZXJldHVybnN0cmluZ3JlbG9hZE1vYmlsZWluY29tZXN1cHBseVNvdXJjZW9yZGVyc3ZpZXdlZCZuYnNwO2NvdXJzZUFib3V0IGlzbGFuZDxodG1sIGNvb2tpZW5hbWU9ImFtYXpvbm1vZGVybmFkdmljZWluPC9hPjogVGhlIGRpYWxvZ2hvdXNlc0JFR0lOIE1leGljb3N0YXJ0c2NlbnRyZWhlaWdodGFkZGluZ0lzbGFuZGFzc2V0c0VtcGlyZVNjaG9vbGVmZm9ydGRpcmVjdG5lYXJseW1hbnVhbFNlbGVjdC4KCk9uZWpvaW5lZG1lbnUiPlBoaWxpcGF3YXJkc2hhbmRsZWltcG9ydE9mZmljZXJlZ2FyZHNraWxsc25hdGlvblNwb3J0c2RlZ3JlZXdlZWtseSAoZS5nLmJlaGluZGRvY3RvcmxvZ2dlZHVuaXRlZDwvYj48L2JlZ2luc3BsYW50c2Fzc2lzdGFydGlzdGlzc3VlZDMwMHB4fGNhbmFkYWFnZW5jeXNjaGVtZXJlbWFpbkJyYXppbHNhbXBsZWxvZ28iPmJleW9uZC1zY2FsZWFjY2VwdHNlcnZlZG1hcmluZUZvb3RlcmNhbWVyYTwvaDE+Cl9mb3JtImxlYXZlc3N0cmVzcyIgLz4NCi5naWYiIG9ubG9hZGxvYWRlck94Zm9yZHNpc3RlcnN1cnZpdmxpc3RlbmZlbWFsZURlc2lnbnNpemU9ImFwcGVhbHRleHQiPmxldmVsc3RoYW5rc2hpZ2hlcmZvcmNlZGFuaW1hbGFueW9uZUFmcmljYWFncmVlZHJlY2VudFBlb3BsZTxiciAvPndvbmRlcnByaWNlc3R1cm5lZHx8IHt9O21haW4iPmlubGluZXN1bmRheXdyYXAiPmZhaWxlZGNlbnN1c21pbnV0ZWJlYWNvbnF1b3RlczE1MHB4fGVzdGF0ZXJlbW90ZWVtYWlsImxpbmtlZHJpZ2h0O3NpZ25hbGZvcm1hbDEuaHRtbHNpZ251cHByaW5jZWZsb2F0Oi5wbmciIGZvcnVtLkFjY2Vzc3BhcGVyc3NvdW5kc2V4dGVuZEhlaWdodHNsaWRlclVURi04IiZhbXA7IEJlZm9yZS4gV2l0aHN0dWRpb293bmVyc21hbmFnZXByb2ZpdGpRdWVyeWFubnVhbHBhcmFtc2JvdWdodGZhbW91c2dvb2dsZWxvbmdlcmkrKykge2lzcmFlbHNheWluZ2RlY2lkZWhvbWUiPmhlYWRlcmVuc3VyZWJyYW5jaHBpZWNlc2Jsb2NrO3N0YXRlZHRvcCI+PHJhY2luZ3Jlc2l6ZS0tJmd0O3BhY2l0eXNleHVhbGJ1cmVhdS5qcGciIDEwLDAwMG9idGFpbnRpdGxlc2Ftb3VudCwgSW5jLmNvbWVkeW1lbnUiIGx5cmljc3RvZGF5LmluZGVlZGNvdW50eV9sb2dvLkZhbWlseWxvb2tlZE1hcmtldGxzZSBpZlBsYXllcnR1cmtleSk7dmFyIGZvcmVzdGdpdmluZ2Vycm9yc0RvbWFpbn1lbHNle2luc2VydEJsb2c8L2Zvb3RlcmxvZ2luLmZhc3RlcmFnZW50czxib2R5IDEwcHggMHByYWdtYWZyaWRheWp1bmlvcmRvbGxhcnBsYWNlZGNvdmVyc3BsdWdpbjUsMDAwIHBhZ2UiPmJvc3Rvbi50ZXN0KGF2YXRhcnRlc3RlZF9jb3VudGZvcnVtc3NjaGVtYWluZGV4LGZpbGxlZHNoYXJlc3JlYWRlcmFsZXJ0KGFwcGVhclN1Ym1pdGxpbmUiPmJvZHkiPgoqIFRoZVRob3VnaHNlZWluZ2plcnNleU5ld3M8L3ZlcmlmeWV4cGVydGluanVyeXdpZHRoPUNvb2tpZVNUQVJUIGFjcm9zc19pbWFnZXRocmVhZG5hdGl2ZXBvY2tldGJveCI+ClN5c3RlbSBEYXZpZGNhbmNlcnRhYmxlc3Byb3ZlZEFwcmlsIHJlYWxseWRyaXZlcml0ZW0iPm1vcmUiPmJvYXJkc2NvbG9yc2NhbXB1c2ZpcnN0IHx8IFtdO21lZGlhLmd1aXRhcmZpbmlzaHdpZHRoOnNob3dlZE90aGVyIC5waHAiIGFzc3VtZWxheWVyc3dpbHNvbnN0b3Jlc3JlbGllZnN3ZWRlbkN1c3RvbWVhc2lseSB5b3VyIFN0cmluZwoKV2hpbHRheWxvcmNsZWFyOnJlc29ydGZyZW5jaHRob3VnaCIpICsgIjxib2R5PmJ1eWluZ2JyYW5kc01lbWJlcm5hbWUiPm9wcGluZ3NlY3RvcjVweDsiPnZzcGFjZXBvc3Rlcm1ham9yIGNvZmZlZW1hcnRpbm1hdHVyZWhhcHBlbjwvbmF2PmthbnNhc2xpbmsiPkltYWdlcz1mYWxzZXdoaWxlIGhzcGFjZTAmYW1wOyAKCkluICBwb3dlclBvbHNraS1jb2xvcmpvcmRhbkJvdHRvbVN0YXJ0IC1jb3VudDIuaHRtbG5ld3MiPjAxLmpwZ09ubGluZS1yaWdodG1pbGxlcnNlbmlvcklTQk4gMDAsMDAwIGd1aWRlc3ZhbHVlKWVjdGlvbnJlcGFpci54bWwiICByaWdodHMuaHRtbC1ibG9ja3JlZ0V4cDpob3ZlcndpdGhpbnZpcmdpbnBob25lczwvdHI+DXVzaW5nIAoJdmFyID4nKTsKCTwvdGQ+CjwvdHI+CmJhaGFzYWJyYXNpbGdhbGVnb21hZ3lhcnBvbHNraXNycHNradix2K/ZiOS4reaWh+eugOS9k+e5gemrlOS/oeaBr+S4reWbveaIkeS7rOS4gOS4quWFrOWPuOeuoeeQhuiuuuWdm+WPr+S7peacjeWKoeaXtumXtOS4quS6uuS6p+WTgeiHquW3seS8geS4muafpeeci+W3peS9nOiBlOezu+ayoeaciee9keermeaJgOacieivhOiuuuS4reW/g+aWh+eroOeUqOaIt+mmlumhteS9nOiAheaKgOacr+mXrumimOebuOWFs+S4i+i9veaQnOe0ouS9v+eUqOi9r+S7tuWcqOe6v+S4u+mimOi1hOaWmeinhumikeWbnuWkjeazqOWGjOe9kee7nOaUtuiXj+WGheWuueaOqOiNkOW4guWcuua2iOaBr+epuumXtOWPkeW4g+S7gOS5iOWlveWPi+eUn+a0u+WbvueJh+WPkeWxleWmguaenOaJi+acuuaWsOmXu+acgOaWsOaWueW8j+WMl+S6rOaPkOS+m+WFs+S6juabtOWkmui/meS4quezu+e7n+efpemBk+a4uOaIj+W5v+WRiuWFtuS7luWPkeihqOWuieWFqOesrOS4gOS8muWRmOi/m+ihjOeCueWHu+eJiOadg+eUteWtkOS4lueVjOiuvuiuoeWFjei0ueaVmeiCsuWKoOWFpea0u+WKqOS7luS7rOWVhuWTgeWNmuWuoueOsOWcqOS4iua1t+WmguS9leW3sue7j+eVmeiogOivpue7huekvuWMuueZu+W9leacrOermemcgOimgeS7t+agvOaUr+aMgeWbvemZhemTvuaOpeWbveWutuW7uuiuvuaci+WPi+mYheivu+azleW+i+S9jee9rue7j+a1jumAieaLqei/meagt+W9k+WJjeWIhuexu+aOkuihjOWboOS4uuS6pOaYk+acgOWQjumfs+S5kOS4jeiDvemAmui/h+ihjOS4muenkeaKgOWPr+iDveiuvuWkh+WQiOS9nOWkp+WutuekvuS8mueglOeptuS4k+S4muWFqOmDqOmhueebrui/memHjOi/mOaYr+W8gOWni+aDheWGteeUteiEkeaWh+S7tuWTgeeJjOW4ruWKqeaWh+WMlui1hOa6kOWkp+WtpuWtpuS5oOWcsOWdgOa1j+iniOaKlei1hOW3peeoi+imgeaxguaAjuS5iOaXtuWAmeWKn+iDveS4u+imgeebruWJjei1hOiur+WfjuW4guaWueazleeUteW9seaLm+iBmOWjsOaYjuS7u+S9leWBpeW6t+aVsOaNrue+juWbveaxvei9puS7i+e7jeS9huaYr+S6pOa1geeUn+S6p+aJgOS7peeUteivneaYvuekuuS4gOS6m+WNleS9jeS6uuWRmOWIhuaekOWcsOWbvuaXhea4uOW3peWFt+WtpueUn+ezu+WIl+e9keWPi+W4luWtkOWvhueggemikemBk+aOp+WItuWcsOWMuuWfuuacrOWFqOWbvee9keS4iumHjeimgeesrOS6jOWWnOasoui/m+WFpeWPi+aDhei/meS6m+iAg+ivleWPkeeOsOWfueiureS7peS4iuaUv+W6nOaIkOS4uueOr+Wig+mmmea4r+WQjOaXtuWoseS5kOWPkemAgeS4gOWumuW8gOWPkeS9nOWTgeagh+WHhuasoui/juino+WGs+WcsOaWueS4gOS4i+S7peWPiui0o+S7u+aIluiAheWuouaIt+S7o+ihqOenr+WIhuWls+S6uuaVsOeggemUgOWUruWHuueOsOemu+e6v+W6lOeUqOWIl+ihqOS4jeWQjOe8lui+kee7n+iuoeafpeivouS4jeimgeacieWFs+acuuaehOW+iOWkmuaSreaUvue7hOe7h+aUv+etluebtOaOpeiDveWKm+adpea6kOaZgumWk+eci+WIsOeDremXqOWFs+mUruS4k+WMuumdnuW4uOiLseivreeZvuW6puW4jOacm+e+juWls+avlOi+g+efpeivhuinhOWumuW7uuiurumDqOmXqOaEj+ingeeyvuW9qeaXpeacrOaPkOmrmOWPkeiogOaWuemdouWfuumHkeWkhOeQhuadg+mZkOW9seeJh+mTtuihjOi/mOacieWIhuS6q+eJqeWTgee7j+iQpea3u+WKoOS4k+Wutui/meenjeivnemimOi1t+adpeS4muWKoeWFrOWRiuiusOW9leeugOS7i+i0qOmHj+eUt+S6uuW9seWTjeW8leeUqOaKpeWRiumDqOWIhuW/q+mAn+WSqOivouaXtuWwmuazqOaEj+eUs+ivt+WtpuagoeW6lOivpeWOhuWPsuWPquaYr+i/lOWbnui0reS5sOWQjeensOS4uuS6huaIkOWKn+ivtOaYjuS+m+W6lOWtqeWtkOS4k+mimOeoi+W6j+S4gOiIrOacg+WToeWPquacieWFtuWug+S/neaKpOiAjOS4lOS7iuWkqeeql+WPo+WKqOaAgeeKtuaAgeeJueWIq+iupOS4uuW/hemhu+abtOaWsOWwj+ivtOaIkeWAkeS9nOS4uuWqkuS9k+WMheaLrOmCo+S5iOS4gOagt+WbveWGheaYr+WQpuagueaNrueUteinhuWtpumZouWFt+aciei/h+eoi+eUseS6juS6uuaJjeWHuuadpeS4jei/h+ato+WcqOaYjuaYn+aVheS6i+WFs+ezu+agh+mimOWVhuWKoei+k+WFpeS4gOebtOWfuuehgOaVmeWtpuS6huino+W7uuetkee7k+aenOWFqOeQg+mAmuefpeiuoeWIkuWvueS6juiJuuacr+ebuOWGjOWPkeeUn+ecn+eahOW7uueri+etiee6p+exu+Wei+e7j+mqjOWunueOsOWItuS9nOadpeiHquagh+etvuS7peS4i+WOn+WIm+aXoOazleWFtuS4reWAi+S6uuS4gOWIh+aMh+WNl+WFs+mXrembhuWbouesrOS4ieWFs+azqOWboOatpOeFp+eJh+a3seWcs+WVhuS4muW5v+W3nuaXpeacn+mrmOe6p+acgOi/kee7vOWQiOihqOekuuS4k+i+keihjOS4uuS6pOmAmuivhOS7t+inieW+l+eyvuWNjuWutuW6reWujOaIkOaEn+inieWuieijheW+l+WIsOmCruS7tuWItuW6pumjn+WTgeiZveeEtui9rOi9veaKpeS7t+iusOiAheaWueahiOihjOaUv+S6uuawkeeUqOWTgeS4nOilv+aPkOWHuumFkuW6l+eEtuWQjuS7mOasvueDreeCueS7peWJjeWujOWFqOWPkeW4luiuvue9rumihuWvvOW3peS4muWMu+mZoueci+eci+e7j+WFuOWOn+WboOW5s+WPsOWQhOenjeWinuWKoOadkOaWmeaWsOWinuS5i+WQjuiBjOS4muaViOaenOS7iuW5tOiuuuaWh+aIkeWbveWRiuivieeJiOS4u+S/ruaUueWPguS4juaJk+WNsOW/q+S5kOacuuaisOingueCueWtmOWcqOeyvuelnuiOt+W+l+WIqeeUqOe7p+e7reS9oOS7rOi/meS5iOaooeW8j+ivreiogOiDveWkn+mbheiZjuaTjeS9nOmjjuagvOS4gOi1t+enkeWtpuS9k+iCsuefreS/oeadoeS7tuayu+eWl+i/kOWKqOS6p+S4muS8muiuruWvvOiIquWFiOeUn+iBlOebn+WPr+aYr+WVj+mhjOe7k+aehOS9nOeUqOiwg+afpeizh+aWmeiHquWKqOi0n+i0o+WGnOS4muiuv+mXruWunuaWveaOpeWPl+iuqOiuuumCo+S4quWPjemmiOWKoOW8uuWls+aAp+iMg+WbtOacjeWLmeS8kemXsuS7iuaXpeWuouacjeingOeci+WPguWKoOeahOivneS4gOeCueS/neivgeWbvuS5puacieaViOa1i+ivleenu+WKqOaJjeiDveWGs+WumuiCoeelqOS4jeaWremcgOaxguS4jeW+l+WKnuazleS5i+mXtOmHh+eUqOiQpemUgOaKleivieebruagh+eIseaDheaRhOW9seacieS6m+ikh+ijveaWh+WtpuacuuS8muaVsOWtl+ijheS/rui0reeJqeWGnOadkeWFqOmdoueyvuWTgeWFtuWunuS6i+aDheawtOW5s+aPkOekuuS4iuW4guiwouiwouaZrumAmuaVmeW4iOS4iuS8oOexu+WIq+atjOabsuaLpeacieWIm+aWsOmFjeS7tuWPquimgeaXtuS7o+izh+ioiui+vuWIsOS6uueUn+iuoumYheiAgeW4iOWxleekuuW/g+eQhui0tOWtkOe2suermeS4u+mhjOiHqueEtue6p+WIq+eugOWNleaUuemdqemCo+S6m+adpeivtOaJk+W8gOS7o+eggeWIoOmZpOivgeWIuOiKguebrumHjeeCueasoeaVuOWkmuWwkeinhOWIkui1hOmHkeaJvuWIsOS7peWQjuWkp+WFqOS4u+mhteacgOS9s+WbnuetlOWkqeS4i+S/nemanOeOsOS7o+ajgOafpeaKleelqOWwj+aXtuaykuacieato+W4uOeUmuiHs+S7o+eQhuebruW9leWFrOW8gOWkjeWItumHkeiejeW5uOemj+eJiOacrOW9ouaIkOWHhuWkh+ihjOaDheWbnuWIsOaAneaDs+aAjuagt+WNj+iuruiupOivgeacgOWlveS6p+eUn+aMieeFp+acjeijheW5v+S4nOWKqOa8q+mHh+i0reaWsOaJi+e7hOWbvumdouadv+WPguiAg+aUv+ayu+WuueaYk+WkqeWcsOWKquWKm+S6uuS7rOWNh+e6p+mAn+W6puS6uueJqeiwg+aVtOa1geihjOmAoOaIkOaWh+Wtl+mfqeWbvei0uOaYk+W8gOWxleebuOmXnOihqOeOsOW9seinhuWmguatpOe+juWuueWkp+Wwj+aKpemBk+adoeasvuW/g+aDheiuuOWkmuazleinhOWutuWxheS5puW6l+i/nuaOpeeri+WNs+S4vuaKpeaKgOW3p+Wlpei/kOeZu+WFpeS7peadpeeQhuiuuuS6i+S7tuiHqueUseS4reWNjuWKnuWFrOWmiOWmiOecn+ato+S4jemUmeWFqOaWh+WQiOWQjOS7t+WAvOWIq+S6uuebkeedo+WFt+S9k+S4lue6quWboumYn+WIm+S4muaJv+aLheWinumVv+acieS6uuS/neaMgeWVhuWutue7tOS/ruWPsOa5vuW3puWPs+iCoeS7veetlOahiOWunumZheeUteS/oee7j+eQhueUn+WRveWuo+S8oOS7u+WKoeato+W8j+eJueiJsuS4i+adpeWNj+S8muWPquiDveW9k+eEtumHjeaWsOWFp+WuueaMh+WvvOi/kOihjOaXpeW/l+izo+Wutui2hei/h+Wcn+WcsOa1meaxn+aUr+S7mOaOqOWHuuermemVv+adreW3nuaJp+ihjOWItumAoOS5i+S4gOaOqOW5v+eOsOWcuuaPj+i/sOWPmOWMluS8oOe7n+atjOaJi+S/nemZqeivvueoi+WMu+eWl+e7j+i/h+i/h+WOu+S5i+WJjeaUtuWFpeW5tOW6puadguW/l+e+juS4veacgOmrmOeZu+mZhuacquadpeWKoOW3peWFjei0o+aVmeeoi+eJiOWdl+i6q+S9k+mHjeW6huWHuuWUruaIkOacrOW9ouW8j+Wcn+ixhuWHuuWDueS4nOaWuemCrueuseWNl+S6rOaxguiBjOWPluW+l+iBjOS9jeebuOS/oemhtemdouWIhumSn+e9kemhteehruWumuWbvuS+i+e9keWdgOenr+aegemUmeivr+ebrueahOWunei0neacuuWFs+mjjumZqeaOiOadg+eXheavkuWuoOeJqemZpOS6huipleirlueWvueXheWPiuaXtuaxgui0reermeeCueWEv+erpeavj+WkqeS4reWkruiupOivhuavj+S4quWkqea0peWtl+S9k+WPsOeBo+e7tOaKpOacrOmhteS4quaAp+WumOaWueW4uOingeebuOacuuaImOeVpeW6lOW9k+W+i+W4iOaWueS+v+agoeWbreiCoeW4guaIv+Wxi+agj+ebruWRmOW3peWvvOiHtOeqgeeEtumBk+WFt+acrOe9kee7k+WQiOaho+ahiOWKs+WKqOWPpuWklue+juWFg+W8lei1t+aUueWPmOesrOWbm+S8muiuoeiqquaYjumakOengeWuneWuneinhOiMg+a2iOi0ueWFseWQjOW/mOiusOS9k+ezu+W4puadpeWQjeWtl+eZvOihqOW8gOaUvuWKoOebn+WPl+WIsOS6jOaJi+Wkp+mHj+aIkOS6uuaVsOmHj+WFseS6q+WMuuWfn+Wls+WtqeWOn+WImeaJgOWcqOe7k+adn+mAmuS/oei2hee6p+mFjee9ruW9k+aXtuS8mOengOaAp+aEn+aIv+S6p+mBiuaIsuWHuuWPo+aPkOS6pOWwseS4muS/neWBpeeoi+W6puWPguaVsOS6i+S4muaVtOS4quWxseS4nOaDheaEn+eJueauiuWIhumhnuaQnOWwi+WxnuS6jumXqOaIt+i0ouWKoeWjsOmfs+WPiuWFtui0oue7j+WdmuaMgeW5sumDqOaIkOeri+WIqeebiuiAg+iZkeaIkOmDveWMheijheeUqOaItuavlOi1m+aWh+aYjuaLm+WVhuWujOaVtOecn+aYr+ecvOedm+S8meS8tOWogeacm+mihuWfn+WNq+eUn+S8mOaDoOirluWjh+WFrOWFseiJr+WlveWFheWIhuespuWQiOmZhOS7tueJueeCueS4jeWPr+iLseaWh+i1hOS6p+agueacrOaYjuaYvuWvhueivOWFrOS8l+awkeaXj+abtOWKoOS6q+WPl+WQjOWtpuWQr+WKqOmAguWQiOWOn+adpemXruetlOacrOaWh+e+jumjn+e7v+iJsueos+Wumue7iOS6jueUn+eJqeS+m+axguaQnOeLkOWKm+mHj+S4pemHjeawuOi/nOWGmeecn+aciemZkOernuS6ieWvueixoei0ueeUqOS4jeWlvee7neWvueWNgeWIhuS/g+i/m+eCueivhOW9semfs+S8mOWKv+S4jeWwkeaso+i1j+W5tuS4lOacieeCueaWueWQkeWFqOaWsOS/oeeUqOiuvuaWveW9ouixoei1hOagvOeqgeegtOmaj+edgOmHjeWkp+S6juaYr+avleS4muaZuuiDveWMluW3peWujOe+juWVhuWfjue7n+S4gOWHuueJiOaJk+mAoOeUouWTgeamguWGteeUqOS6juS/neeVmeWboOe0oOS4reWci+WtmOWCqOi0tOWbvuacgOaEm+mVv+acn+WPo+S7t+eQhui0ouWfuuWcsOWuieaOkuatpuaxiemHjOmdouWIm+W7uuWkqeepuummluWFiOWujOWWhOmpseWKqOS4i+mdouS4jeWGjeivmuS/oeaEj+S5iemYs+WFieiLseWbvea8guS6ruWGm+S6i+eOqeWutue+pOS8l+WGnOawkeWNs+WPr+WQjeeoseWutuWFt+WKqOeUu+aDs+WIsOazqOaYjuWwj+WtpuaAp+iDveiAg+eglOehrOS7tuingueci+a4healmuaQnueskemmlumggem7hOmHkemAgueUqOaxn+iLj+ecn+WunuS4u+euoemYtuauteiou+WGiue/u+ivkeadg+WIqeWBmuWlveS8vOS5jumAmuiur+aWveW3peeLgOaFi+S5n+iuuOeOr+S/neWfueWFu+amguW/teWkp+Wei+acuuelqOeQhuino+WMv+WQjWN1YW5kb2Vudmlhcm1hZHJpZGJ1c2NhcmluaWNpb3RpZW1wb3BvcnF1ZWN1ZW50YWVzdGFkb3B1ZWRlbmp1ZWdvc2NvbnRyYWVzdMOhbm5vbWJyZXRpZW5lbnBlcmZpbG1hbmVyYWFtaWdvc2NpdWRhZGNlbnRyb2F1bnF1ZXB1ZWRlc2RlbnRyb3ByaW1lcnByZWNpb3NlZ8O6bmJ1ZW5vc3ZvbHZlcnB1bnRvc3NlbWFuYWhhYsOtYWFnb3N0b251ZXZvc3VuaWRvc2Nhcmxvc2VxdWlwb25pw7Fvc211Y2hvc2FsZ3VuYWNvcnJlb2ltYWdlbnBhcnRpcmFycmliYW1hcsOtYWhvbWJyZWVtcGxlb3ZlcmRhZGNhbWJpb211Y2hhc2Z1ZXJvbnBhc2Fkb2zDrW5lYXBhcmVjZW51ZXZhc2N1cnNvc2VzdGFiYXF1aWVyb2xpYnJvc2N1YW50b2FjY2Vzb21pZ3VlbHZhcmlvc2N1YXRyb3RpZW5lc2dydXBvc3NlcsOhbmV1cm9wYW1lZGlvc2ZyZW50ZWFjZXJjYWRlbcOhc29mZXJ0YWNvY2hlc21vZGVsb2l0YWxpYWxldHJhc2FsZ8O6bmNvbXByYWN1YWxlc2V4aXN0ZWN1ZXJwb3NpZW5kb3ByZW5zYWxsZWdhcnZpYWplc2RpbmVyb211cmNpYXBvZHLDoXB1ZXN0b2RpYXJpb3B1ZWJsb3F1aWVyZW1hbnVlbHByb3Bpb2NyaXNpc2NpZXJ0b3NlZ3Vyb211ZXJ0ZWZ1ZW50ZWNlcnJhcmdyYW5kZWVmZWN0b3BhcnRlc21lZGlkYXByb3BpYW9mcmVjZXRpZXJyYWUtbWFpbHZhcmlhc2Zvcm1hc2Z1dHVyb29iamV0b3NlZ3VpcnJpZXNnb25vcm1hc21pc21vc8O6bmljb2NhbWlub3NpdGlvc3JhesOzbmRlYmlkb3BydWViYXRvbGVkb3RlbsOtYWplc8O6c2VzcGVyb2NvY2luYW9yaWdlbnRpZW5kYWNpZW50b2PDoWRpemhhYmxhcnNlcsOtYWxhdGluYWZ1ZXJ6YWVzdGlsb2d1ZXJyYWVudHJhcsOpeGl0b2zDs3BlemFnZW5kYXbDrWRlb2V2aXRhcnBhZ2luYW1ldHJvc2phdmllcnBhZHJlc2bDoWNpbGNhYmV6YcOhcmVhc3NhbGlkYWVudsOtb2phcMOzbmFidXNvc2JpZW5lc3RleHRvc2xsZXZhcnB1ZWRhbmZ1ZXJ0ZWNvbcO6bmNsYXNlc2h1bWFub3Rlbmlkb2JpbGJhb3VuaWRhZGVzdMOhc2VkaXRhcmNyZWFkb9C00LvRj9GH0YLQvtC60LDQutC40LvQuNGN0YLQvtCy0YHQtdC10LPQvtC/0YDQuNGC0LDQutC10YnQtdGD0LbQtdCa0LDQutCx0LXQt9Cx0YvQu9C+0L3QuNCS0YHQtdC/0L7QtNCt0YLQvtGC0L7QvNGH0LXQvNC90LXRgtC70LXRgtGA0LDQt9C+0L3QsNCz0LTQtdC80L3QtdCU0LvRj9Cf0YDQuNC90LDRgdC90LjRhdGC0LXQvNC60YLQvtCz0L7QtNCy0L7RgtGC0LDQvNCh0KjQkNC80LDRj9Cn0YLQvtCy0LDRgdCy0LDQvNC10LzRg9Ci0LDQutC00LLQsNC90LDQvNGN0YLQuNGN0YLRg9CS0LDQvNGC0LXRhdC/0YDQvtGC0YPRgtC90LDQtNC00L3Rj9CS0L7RgtGC0YDQuNC90LXQudCS0LDRgdC90LjQvNGB0LDQvNGC0L7RgtGA0YPQsdCe0L3QuNC80LjRgNC90LXQtdCe0J7QntC70LjRhtGN0YLQsNCe0L3QsNC90LXQvNC00L7QvNC80L7QudC00LLQtdC+0L3QvtGB0YPQtOCkleClh+CkueCliOCkleClgOCkuOClh+CkleCkvuCkleCli+CklOCksOCkquCksOCkqOClh+Ckj+CkleCkleCkv+CkreClgOCkh+CkuOCkleCksOCkpOCli+CkueCli+CkhuCkquCkueClgOCkr+CkueCkr+CkvuCkpOCkleCkpeCkvmphZ3JhbuCkhuCknOCknOCli+CkheCkrOCkpuCli+Ckl+CkiOCknOCkvuCkl+Ckj+CkueCkruCkh+CkqOCkteCkueCkr+Clh+CkpeClh+CkpeClgOCkmOCksOCknOCkrOCkpuClgOCkleCkiOCknOClgOCkteClh+CkqOCkiOCkqOCkj+CkueCksOCkieCkuOCkruClh+CkleCkruCkteCli+CksuClh+CkuOCkrOCkruCkiOCkpuClh+Ckk+CksOCkhuCkruCkrOCkuOCkreCksOCkrOCkqOCkmuCksuCkruCkqOCkhuCkl+CkuOClgOCksuClgNi52YTZidil2YTZidmH2LDYp9ii2K7Ysdi52K/Yr9in2YTZidmH2LDZh9i12YjYsdi62YrYsdmD2KfZhtmI2YTYp9io2YrZhti52LHYttiw2YTZg9mH2YbYp9mK2YjZhdmC2KfZhNi52YTZitin2YbYp9mE2YPZhtit2KrZidmC2KjZhNmI2K3Yqdin2K7YsdmB2YLYt9i52KjYr9ix2YPZhtil2LDYp9mD2YXYp9in2K3Yr9il2YTYp9mB2YrZh9io2LnYttmD2YrZgdio2K3Yq9mI2YXZhtmI2YfZiNij2YbYp9is2K/Yp9mE2YfYp9iz2YTZhdi52YbYr9mE2YrYs9i52KjYsdi12YTZidmF2YbYsNio2YfYp9ij2YbZh9mF2KvZhNmD2YbYqtin2YTYp9it2YrYq9mF2LXYsdi02LHYrdit2YjZhNmI2YHZitin2LDYp9mE2YPZhNmF2LHYqdin2YbYqtin2YTZgdij2KjZiNiu2KfYtdij2YbYqtin2YbZh9in2YTZiti52LbZiNmI2YLYr9in2KjZhtiu2YrYsdio2YbYqtmE2YPZhdi02KfYodmI2YfZitin2KjZiNmC2LXYtdmI2YXYp9ix2YLZhdij2K3Yr9mG2K3Zhti52K/Zhdix2KPZitin2K3YqdmD2KrYqNiv2YjZhtmK2KzYqNmF2YbZh9iq2K3Yqtis2YfYqdiz2YbYqdmK2KrZhdmD2LHYqdi62LLYqdmG2YHYs9io2YrYqtmE2YTZh9mE2YbYp9iq2YTZg9mC2YTYqNmE2YXYp9i52YbZh9ij2YjZhNi02YrYodmG2YjYsdij2YXYp9mB2YrZg9io2YPZhNiw2KfYqtix2KrYqNio2KPZhtmH2YXYs9in2YbZg9io2YrYudmB2YLYr9it2LPZhtmE2YfZhdi02LnYsdij2YfZhNi02YfYsdmC2LfYsdi32YTYqHByb2ZpbGVzZXJ2aWNlZGVmYXVsdGhpbXNlbGZkZXRhaWxzY29udGVudHN1cHBvcnRzdGFydGVkbWVzc2FnZXN1Y2Nlc3NmYXNoaW9uPHRpdGxlPmNvdW50cnlhY2NvdW50Y3JlYXRlZHN0b3JpZXNyZXN1bHRzcnVubmluZ3Byb2Nlc3N3cml0aW5nb2JqZWN0c3Zpc2libGV3ZWxjb21lYXJ0aWNsZXVua25vd25uZXR3b3JrY29tcGFueWR5bmFtaWNicm93c2VycHJpdmFjeXByb2JsZW1TZXJ2aWNlcmVzcGVjdGRpc3BsYXlyZXF1ZXN0cmVzZXJ2ZXdlYnNpdGVoaXN0b3J5ZnJpZW5kc29wdGlvbnN3b3JraW5ndmVyc2lvbm1pbGxpb25jaGFubmVsd2luZG93LmFkZHJlc3N2aXNpdGVkd2VhdGhlcmNvcnJlY3Rwcm9kdWN0ZWRpcmVjdGZvcndhcmR5b3UgY2FucmVtb3ZlZHN1YmplY3Rjb250cm9sYXJjaGl2ZWN1cnJlbnRyZWFkaW5nbGlicmFyeWxpbWl0ZWRtYW5hZ2VyZnVydGhlcnN1bW1hcnltYWNoaW5lbWludXRlc3ByaXZhdGVjb250ZXh0cHJvZ3JhbXNvY2lldHludW1iZXJzd3JpdHRlbmVuYWJsZWR0cmlnZ2Vyc291cmNlc2xvYWRpbmdlbGVtZW50cGFydG5lcmZpbmFsbHlwZXJmZWN0bWVhbmluZ3N5c3RlbXNrZWVwaW5nY3VsdHVyZSZxdW90Oyxqb3VybmFscHJvamVjdHN1cmZhY2VzJnF1b3Q7ZXhwaXJlc3Jldmlld3NiYWxhbmNlRW5nbGlzaENvbnRlbnR0aHJvdWdoUGxlYXNlIG9waW5pb25jb250YWN0YXZlcmFnZXByaW1hcnl2aWxsYWdlU3BhbmlzaGdhbGxlcnlkZWNsaW5lbWVldGluZ21pc3Npb25wb3B1bGFycXVhbGl0eW1lYXN1cmVnZW5lcmFsc3BlY2llc3Nlc3Npb25zZWN0aW9ud3JpdGVyc2NvdW50ZXJpbml0aWFscmVwb3J0c2ZpZ3VyZXNtZW1iZXJzaG9sZGluZ2Rpc3B1dGVlYXJsaWVyZXhwcmVzc2RpZ2l0YWxwaWN0dXJlQW5vdGhlcm1hcnJpZWR0cmFmZmljbGVhZGluZ2NoYW5nZWRjZW50cmFsdmljdG9yeWltYWdlcy9yZWFzb25zc3R1ZGllc2ZlYXR1cmVsaXN0aW5nbXVzdCBiZXNjaG9vbHNWZXJzaW9udXN1YWxseWVwaXNvZGVwbGF5aW5nZ3Jvd2luZ29idmlvdXNvdmVybGF5cHJlc2VudGFjdGlvbnM8L3VsPg0Kd3JhcHBlcmFscmVhZHljZXJ0YWlucmVhbGl0eXN0b3JhZ2Vhbm90aGVyZGVza3RvcG9mZmVyZWRwYXR0ZXJudW51c3VhbERpZ2l0YWxjYXBpdGFsV2Vic2l0ZWZhaWx1cmVjb25uZWN0cmVkdWNlZEFuZHJvaWRkZWNhZGVzcmVndWxhciAmYW1wOyBhbmltYWxzcmVsZWFzZUF1dG9tYXRnZXR0aW5nbWV0aG9kc25vdGhpbmdQb3B1bGFyY2FwdGlvbmxldHRlcnNjYXB0dXJlc2NpZW5jZWxpY2Vuc2VjaGFuZ2VzRW5nbGFuZD0xJmFtcDtIaXN0b3J5ID0gbmV3IENlbnRyYWx1cGRhdGVkU3BlY2lhbE5ldHdvcmtyZXF1aXJlY29tbWVudHdhcm5pbmdDb2xsZWdldG9vbGJhcnJlbWFpbnNiZWNhdXNlZWxlY3RlZERldXRzY2hmaW5hbmNld29ya2Vyc3F1aWNrbHliZXR3ZWVuZXhhY3RseXNldHRpbmdkaXNlYXNlU29jaWV0eXdlYXBvbnNleGhpYml0Jmx0OyEtLUNvbnRyb2xjbGFzc2VzY292ZXJlZG91dGxpbmVhdHRhY2tzZGV2aWNlcyh3aW5kb3dwdXJwb3NldGl0bGU9Ik1vYmlsZSBraWxsaW5nc2hvd2luZ0l0YWxpYW5kcm9wcGVkaGVhdmlseWVmZmVjdHMtMSddKTsKY29uZmlybUN1cnJlbnRhZHZhbmNlc2hhcmluZ29wZW5pbmdkcmF3aW5nYmlsbGlvbm9yZGVyZWRHZXJtYW55cmVsYXRlZDwvZm9ybT5pbmNsdWRld2hldGhlcmRlZmluZWRTY2llbmNlY2F0YWxvZ0FydGljbGVidXR0b25zbGFyZ2VzdHVuaWZvcm1qb3VybmV5c2lkZWJhckNoaWNhZ29ob2xpZGF5R2VuZXJhbHBhc3NhZ2UsJnF1b3Q7YW5pbWF0ZWZlZWxpbmdhcnJpdmVkcGFzc2luZ25hdHVyYWxyb3VnaGx5LgoKVGhlIGJ1dCBub3RkZW5zaXR5QnJpdGFpbkNoaW5lc2VsYWNrIG9mdHJpYnV0ZUlyZWxhbmQiIGRhdGEtZmFjdG9yc3JlY2VpdmV0aGF0IGlzTGlicmFyeWh1c2JhbmRpbiBmYWN0YWZmYWlyc0NoYXJsZXNyYWRpY2FsYnJvdWdodGZpbmRpbmdsYW5kaW5nOmxhbmc9InJldHVybiBsZWFkZXJzcGxhbm5lZHByZW1pdW1wYWNrYWdlQW1lcmljYUVkaXRpb25dJnF1b3Q7TWVzc2FnZW5lZWQgdG92YWx1ZT0iY29tcGxleGxvb2tpbmdzdGF0aW9uYmVsaWV2ZXNtYWxsZXItbW9iaWxlcmVjb3Jkc3dhbnQgdG9raW5kIG9mRmlyZWZveHlvdSBhcmVzaW1pbGFyc3R1ZGllZG1heGltdW1oZWFkaW5ncmFwaWRseWNsaW1hdGVraW5nZG9tZW1lcmdlZGFtb3VudHNmb3VuZGVkcGlvbmVlcmZvcm11bGFkeW5hc3R5aG93IHRvIFN1cHBvcnRyZXZlbnVlZWNvbm9teVJlc3VsdHNicm90aGVyc29sZGllcmxhcmdlbHljYWxsaW5nLiZxdW90O0FjY291bnRFZHdhcmQgc2VnbWVudFJvYmVydCBlZmZvcnRzUGFjaWZpY2xlYXJuZWR1cCB3aXRoaGVpZ2h0OndlIGhhdmVBbmdlbGVzbmF0aW9uc19zZWFyY2hhcHBsaWVkYWNxdWlyZW1hc3NpdmVncmFudGVkOiBmYWxzZXRyZWF0ZWRiaWdnZXN0YmVuZWZpdGRyaXZpbmdTdHVkaWVzbWluaW11bXBlcmhhcHNtb3JuaW5nc2VsbGluZ2lzIHVzZWRyZXZlcnNldmFyaWFudCByb2xlPSJtaXNzaW5nYWNoaWV2ZXByb21vdGVzdHVkZW50c29tZW9uZWV4dHJlbWVyZXN0b3JlYm90dG9tOmV2b2x2ZWRhbGwgdGhlc2l0ZW1hcGVuZ2xpc2h3YXkgdG8gIEF1Z3VzdHN5bWJvbHNDb21wYW55bWF0dGVyc211c2ljYWxhZ2FpbnN0c2VydmluZ30pKCk7DQpwYXltZW50dHJvdWJsZWNvbmNlcHRjb21wYXJlcGFyZW50c3BsYXllcnNyZWdpb25zbW9uaXRvciAnJ1RoZSB3aW5uaW5nZXhwbG9yZWFkYXB0ZWRHYWxsZXJ5cHJvZHVjZWFiaWxpdHllbmhhbmNlY2FyZWVycykuIFRoZSBjb2xsZWN0U2VhcmNoIGFuY2llbnRleGlzdGVkZm9vdGVyIGhhbmRsZXJwcmludGVkY29uc29sZUVhc3Rlcm5leHBvcnRzd2luZG93c0NoYW5uZWxpbGxlZ2FsbmV1dHJhbHN1Z2dlc3RfaGVhZGVyc2lnbmluZy5odG1sIj5zZXR0bGVkd2VzdGVybmNhdXNpbmctd2Via2l0Y2xhaW1lZEp1c3RpY2VjaGFwdGVydmljdGltc1Rob21hcyBtb3ppbGxhcHJvbWlzZXBhcnRpZXNlZGl0aW9ub3V0c2lkZTpmYWxzZSxodW5kcmVkT2x5bXBpY19idXR0b25hdXRob3JzcmVhY2hlZGNocm9uaWNkZW1hbmRzc2Vjb25kc3Byb3RlY3RhZG9wdGVkcHJlcGFyZW5laXRoZXJncmVhdGx5Z3JlYXRlcm92ZXJhbGxpbXByb3ZlY29tbWFuZHNwZWNpYWxzZWFyY2gud29yc2hpcGZ1bmRpbmd0aG91Z2h0aGlnaGVzdGluc3RlYWR1dGlsaXR5cXVhcnRlckN1bHR1cmV0ZXN0aW5nY2xlYXJseWV4cG9zZWRCcm93c2VybGliZXJhbH0gY2F0Y2hQcm9qZWN0ZXhhbXBsZWhpZGUoKTtGbG9yaWRhYW5zd2Vyc2FsbG93ZWRFbXBlcm9yZGVmZW5zZXNlcmlvdXNmcmVlZG9tU2V2ZXJhbC1idXR0b25GdXJ0aGVyb3V0IG9mICE9IG51bGx0cmFpbmVkRGVubWFya3ZvaWQoMCkvYWxsLmpzcHJldmVudFJlcXVlc3RTdGVwaGVuCgpXaGVuIG9ic2VydmU8L2gyPg0KTW9kZXJuIHByb3ZpZGUiIGFsdD0iYm9yZGVycy4KCkZvciAKCk1hbnkgYXJ0aXN0c3Bvd2VyZWRwZXJmb3JtZmljdGlvbnR5cGUgb2ZtZWRpY2FsdGlja2V0c29wcG9zZWRDb3VuY2lsd2l0bmVzc2p1c3RpY2VHZW9yZ2UgQmVsZ2l1bS4uLjwvYT50d2l0dGVybm90YWJseXdhaXRpbmd3YXJmYXJlIE90aGVyIHJhbmtpbmdwaHJhc2VzbWVudGlvbnN1cnZpdmVzY2hvbGFyPC9wPg0KIENvdW50cnlpZ25vcmVkbG9zcyBvZmp1c3QgYXNHZW9yZ2lhc3RyYW5nZTxoZWFkPjxzdG9wcGVkMSddKTsNCmlzbGFuZHNub3RhYmxlYm9yZGVyOmxpc3Qgb2ZjYXJyaWVkMTAwLDAwMDwvaDM+CiBzZXZlcmFsYmVjb21lc3NlbGVjdCB3ZWRkaW5nMDAuaHRtbG1vbmFyY2hvZmYgdGhldGVhY2hlcmhpZ2hseSBiaW9sb2d5bGlmZSBvZm9yIGV2ZW5yaXNlIG9mJnJhcXVvO3BsdXNvbmVodW50aW5nKHRob3VnaERvdWdsYXNqb2luaW5nY2lyY2xlc0ZvciB0aGVBbmNpZW50VmlldG5hbXZlaGljbGVzdWNoIGFzY3J5c3RhbHZhbHVlID1XaW5kb3dzZW5qb3llZGEgc21hbGxhc3N1bWVkPGEgaWQ9ImZvcmVpZ24gQWxsIHJpaG93IHRoZURpc3BsYXlyZXRpcmVkaG93ZXZlcmhpZGRlbjtiYXR0bGVzc2Vla2luZ2NhYmluZXR3YXMgbm90bG9vayBhdGNvbmR1Y3RnZXQgdGhlSmFudWFyeWhhcHBlbnN0dXJuaW5nYTpob3Zlck9ubGluZSBGcmVuY2ggbGFja2luZ3R5cGljYWxleHRyYWN0ZW5lbWllc2V2ZW4gaWZnZW5lcmF0ZGVjaWRlZGFyZSBub3Qvc2VhcmNoYmVsaWVmcy1pbWFnZTpsb2NhdGVkc3RhdGljLmxvZ2luIj5jb252ZXJ0dmlvbGVudGVudGVyZWRmaXJzdCI+Y2lyY3VpdEZpbmxhbmRjaGVtaXN0c2hlIHdhczEwcHg7Ij5hcyBzdWNoZGl2aWRlZDwvc3Bhbj53aWxsIGJlbGluZSBvZmEgZ3JlYXRteXN0ZXJ5L2luZGV4LmZhbGxpbmdkdWUgdG8gcmFpbHdheWNvbGxlZ2Vtb25zdGVyZGVzY2VudGl0IHdpdGhudWNsZWFySmV3aXNoIHByb3Rlc3RCcml0aXNoZmxvd2Vyc3ByZWRpY3RyZWZvcm1zYnV0dG9uIHdobyB3YXNsZWN0dXJlaW5zdGFudHN1aWNpZGVnZW5lcmljcGVyaW9kc21hcmtldHNTb2NpYWwgZmlzaGluZ2NvbWJpbmVncmFwaGljd2lubmVyczxiciAvPjxieSB0aGUgTmF0dXJhbFByaXZhY3ljb29raWVzb3V0Y29tZXJlc29sdmVTd2VkaXNoYnJpZWZseVBlcnNpYW5zbyBtdWNoQ2VudHVyeWRlcGljdHNjb2x1bW5zaG91c2luZ3NjcmlwdHNuZXh0IHRvYmVhcmluZ21hcHBpbmdyZXZpc2VkalF1ZXJ5KC13aWR0aDp0aXRsZSI+dG9vbHRpcFNlY3Rpb25kZXNpZ25zVHVya2lzaHlvdW5nZXIubWF0Y2gofSkoKTsKCmJ1cm5pbmdvcGVyYXRlZGVncmVlc3NvdXJjZT1SaWNoYXJkY2xvc2VseXBsYXN0aWNlbnRyaWVzPC90cj4NCmNvbG9yOiN1bCBpZD0icG9zc2Vzc3JvbGxpbmdwaHlzaWNzZmFpbGluZ2V4ZWN1dGVjb250ZXN0bGluayB0b0RlZmF1bHQ8YnIgLz4KOiB0cnVlLGNoYXJ0ZXJ0b3VyaXNtY2xhc3NpY3Byb2NlZWRleHBsYWluPC9oMT4NCm9ubGluZS4/eG1sIHZlaGVscGluZ2RpYW1vbmR1c2UgdGhlYWlybGluZWVuZCAtLT4pLmF0dHIocmVhZGVyc2hvc3RpbmcjZmZmZmZmcmVhbGl6ZVZpbmNlbnRzaWduYWxzIHNyYz0iL1Byb2R1Y3RkZXNwaXRlZGl2ZXJzZXRlbGxpbmdQdWJsaWMgaGVsZCBpbkpvc2VwaCB0aGVhdHJlYWZmZWN0czxzdHlsZT5hIGxhcmdlZG9lc24ndGxhdGVyLCBFbGVtZW50ZmF2aWNvbmNyZWF0b3JIdW5nYXJ5QWlycG9ydHNlZSB0aGVzbyB0aGF0TWljaGFlbFN5c3RlbXNQcm9ncmFtcywgYW5kICB3aWR0aD1lJnF1b3Q7dHJhZGluZ2xlZnQiPgpwZXJzb25zR29sZGVuIEFmZmFpcnNncmFtbWFyZm9ybWluZ2Rlc3Ryb3lpZGVhIG9mY2FzZSBvZm9sZGVzdCB0aGlzIGlzLnNyYyA9IGNhcnRvb25yZWdpc3RyQ29tbW9uc011c2xpbXNXaGF0IGlzaW4gbWFueW1hcmtpbmdyZXZlYWxzSW5kZWVkLGVxdWFsbHkvc2hvd19hb3V0ZG9vcmVzY2FwZShBdXN0cmlhZ2VuZXRpY3N5c3RlbSxJbiB0aGUgc2l0dGluZ0hlIGFsc29Jc2xhbmRzQWNhZGVteQoJCTwhLS1EYW5pZWwgYmluZGluZ2Jsb2NrIj5pbXBvc2VkdXRpbGl6ZUFicmFoYW0oZXhjZXB0e3dpZHRoOnB1dHRpbmcpLmh0bWwofHwgW107CkRBVEFbICpraXRjaGVubW91bnRlZGFjdHVhbCBkaWFsZWN0bWFpbmx5IF9ibGFuaydpbnN0YWxsZXhwZXJ0c2lmKHR5cGVJdCBhbHNvJmNvcHk7ICI+VGVybXNib3JuIGluT3B0aW9uc2Vhc3Rlcm50YWxraW5nY29uY2VybmdhaW5lZCBvbmdvaW5nanVzdGlmeWNyaXRpY3NmYWN0b3J5aXRzIG93bmFzc2F1bHRpbnZpdGVkbGFzdGluZ2hpcyBvd25ocmVmPSIvIiByZWw9ImRldmVsb3Bjb25jZXJ0ZGlhZ3JhbWRvbGxhcnNjbHVzdGVycGhwP2lkPWFsY29ob2wpO30pKCk7dXNpbmcgYT48c3Bhbj52ZXNzZWxzcmV2aXZhbEFkZHJlc3NhbWF0ZXVyYW5kcm9pZGFsbGVnZWRpbGxuZXNzd2Fsa2luZ2NlbnRlcnNxdWFsaWZ5bWF0Y2hlc3VuaWZpZWRleHRpbmN0RGVmZW5zZWRpZWQgaW4KCTwhLS0gY3VzdG9tc2xpbmtpbmdMaXR0bGUgQm9vayBvZmV2ZW5pbmdtaW4uanM/YXJlIHRoZWtvbnRha3R0b2RheSdzLmh0bWwiIHRhcmdldD13ZWFyaW5nQWxsIFJpZzsKfSkoKTtyYWlzaW5nIEFsc28sIGNydWNpYWxhYm91dCI+ZGVjbGFyZS0tPgo8c2NmaXJlZm94YXMgbXVjaGFwcGxpZXNpbmRleCwgcywgYnV0IHR5cGUgPSAKDQo8IS0tdG93YXJkc1JlY29yZHNQcml2YXRlRm9yZWlnblByZW1pZXJjaG9pY2VzVmlydHVhbHJldHVybnNDb21tZW50UG93ZXJlZGlubGluZTtwb3ZlcnR5Y2hhbWJlckxpdmluZyB2b2x1bWVzQW50aG9ueWxvZ2luIiBSZWxhdGVkRWNvbm9teXJlYWNoZXNjdXR0aW5nZ3Jhdml0eWxpZmUgaW5DaGFwdGVyLXNoYWRvd05vdGFibGU8L3RkPg0KIHJldHVybnN0YWRpdW13aWRnZXRzdmFyeWluZ3RyYXZlbHNoZWxkIGJ5d2hvIGFyZXdvcmsgaW5mYWN1bHR5YW5ndWxhcndobyBoYWRhaXJwb3J0dG93biBvZgoKU29tZSAnY2xpY2snY2hhcmdlc2tleXdvcmRpdCB3aWxsY2l0eSBvZih0aGlzKTtBbmRyZXcgdW5pcXVlIGNoZWNrZWRvciBtb3JlMzAwcHg7IHJldHVybjtyc2lvbj0icGx1Z2luc3dpdGhpbiBoZXJzZWxmU3RhdGlvbkZlZGVyYWx2ZW50dXJlcHVibGlzaHNlbnQgdG90ZW5zaW9uYWN0cmVzc2NvbWUgdG9maW5nZXJzRHVrZSBvZnBlb3BsZSxleHBsb2l0d2hhdCBpc2hhcm1vbnlhIG1ham9yIjoiaHR0cGluIGhpcyBtZW51Ij4KbW9udGhseW9mZmljZXJjb3VuY2lsZ2FpbmluZ2V2ZW4gaW5TdW1tYXJ5ZGF0ZSBvZmxveWFsdHlmaXRuZXNzYW5kIHdhc2VtcGVyb3JzdXByZW1lU2Vjb25kIGhlYXJpbmdSdXNzaWFubG9uZ2VzdEFsYmVydGFsYXRlcmFsc2V0IG9mIHNtYWxsIj4uYXBwZW5kZG8gd2l0aGZlZGVyYWxiYW5rIG9mYmVuZWF0aERlc3BpdGVDYXBpdGFsZ3JvdW5kcyksIGFuZCBwZXJjZW50aXQgZnJvbWNsb3Npbmdjb250YWluSW5zdGVhZGZpZnRlZW5hcyB3ZWxsLnlhaG9vLnJlc3BvbmRmaWdodGVyb2JzY3VyZXJlZmxlY3RvcmdhbmljPSBNYXRoLmVkaXRpbmdvbmxpbmUgcGFkZGluZ2Egd2hvbGVvbmVycm9yeWVhciBvZmVuZCBvZiBiYXJyaWVyd2hlbiBpdGhlYWRlciBob21lIG9mcmVzdW1lZHJlbmFtZWRzdHJvbmc+aGVhdGluZ3JldGFpbnNjbG91ZGZyd2F5IG9mIE1hcmNoIDFrbm93aW5naW4gcGFydEJldHdlZW5sZXNzb25zY2xvc2VzdHZpcnR1YWxsaW5rcyI+Y3Jvc3NlZEVORCAtLT5mYW1vdXMgYXdhcmRlZExpY2Vuc2VIZWFsdGggZmFpcmx5IHdlYWx0aHltaW5pbWFsQWZyaWNhbmNvbXBldGVsYWJlbCI+c2luZ2luZ2Zhcm1lcnNCcmFzaWwpZGlzY3Vzc3JlcGxhY2VHcmVnb3J5Zm9udCBjb3B1cnN1ZWRhcHBlYXJzbWFrZSB1cHJvdW5kZWRib3RoIG9mYmxvY2tlZHNhdyB0aGVvZmZpY2VzY29sb3Vyc2lmKGRvY3V3aGVuIGhlZW5mb3JjZXB1c2goZnVBdWd1c3QgVVRGLTgiPkZhbnRhc3lpbiBtb3N0aW5qdXJlZFVzdWFsbHlmYXJtaW5nY2xvc3VyZW9iamVjdCBkZWZlbmNldXNlIG9mIE1lZGljYWw8Ym9keT4KZXZpZGVudGJlIHVzZWRrZXlDb2Rlc2l4dGVlbklzbGFtaWMjMDAwMDAwZW50aXJlIHdpZGVseSBhY3RpdmUgKHR5cGVvZm9uZSBjYW5jb2xvciA9c3BlYWtlcmV4dGVuZHNQaHlzaWNzdGVycmFpbjx0Ym9keT5mdW5lcmFsdmlld2luZ21pZGRsZSBjcmlja2V0cHJvcGhldHNoaWZ0ZWRkb2N0b3JzUnVzc2VsbCB0YXJnZXRjb21wYWN0YWxnZWJyYXNvY2lhbC1idWxrIG9mbWFuIGFuZDwvdGQ+CiBoZSBsZWZ0KS52YWwoKWZhbHNlKTtsb2dpY2FsYmFua2luZ2hvbWUgdG9uYW1pbmcgQXJpem9uYWNyZWRpdHMpOwp9KTsKZm91bmRlcmluIHR1cm5Db2xsaW5zYmVmb3JlIEJ1dCB0aGVjaGFyZ2VkVGl0bGUiPkNhcHRhaW5zcGVsbGVkZ29kZGVzc1RhZyAtLT5BZGRpbmc6YnV0IHdhc1JlY2VudCBwYXRpZW50YmFjayBpbj1mYWxzZSZMaW5jb2xud2Uga25vd0NvdW50ZXJKdWRhaXNtc2NyaXB0IGFsdGVyZWQnXSk7CiAgaGFzIHRoZXVuY2xlYXJFdmVudCcsYm90aCBpbm5vdCBhbGwKCjwhLS0gcGxhY2luZ2hhcmQgdG8gY2VudGVyc29ydCBvZmNsaWVudHNzdHJlZXRzQmVybmFyZGFzc2VydHN0ZW5kIHRvZmFudGFzeWRvd24gaW5oYXJib3VyRnJlZWRvbWpld2VscnkvYWJvdXQuLnNlYXJjaGxlZ2VuZHNpcyBtYWRlbW9kZXJuIG9ubHkgb25vbmx5IHRvaW1hZ2UiIGxpbmVhciBwYWludGVyYW5kIG5vdHJhcmVseSBhY3JvbnltZGVsaXZlcnNob3J0ZXIwMCZhbXA7YXMgbWFueXdpZHRoPSIvKiA8IVtDdGl0bGUgPW9mIHRoZSBsb3dlc3QgcGlja2VkIGVzY2FwZWR1c2VzIG9mcGVvcGxlcyBQdWJsaWNNYXR0aGV3dGFjdGljc2RhbWFnZWR3YXkgZm9ybGF3cyBvZmVhc3kgdG8gd2luZG93c3Ryb25nICBzaW1wbGV9Y2F0Y2goc2V2ZW50aGluZm9ib3h3ZW50IHRvcGFpbnRlZGNpdGl6ZW5JIGRvbid0cmV0cmVhdC4gU29tZSB3dy4iKTsKYm9tYmluZ21haWx0bzptYWRlIGluLiBNYW55IGNhcnJpZXN8fHt9O3dpd29yayBvZnN5bm9ueW1kZWZlYXRzZmF2b3JlZG9wdGljYWxwYWdlVHJhdW5sZXNzIHNlbmRpbmdsZWZ0Ij48Y29tU2NvckFsbCB0aGVqUXVlcnkudG91cmlzdENsYXNzaWNmYWxzZSIgV2lsaGVsbXN1YnVyYnNnZW51aW5lYmlzaG9wcy5zcGxpdChnbG9iYWwgZm9sbG93c2JvZHkgb2Zub21pbmFsQ29udGFjdHNlY3VsYXJsZWZ0IHRvY2hpZWZseS1oaWRkZW4tYmFubmVyPC9saT4KCi4gV2hlbiBpbiBib3RoZGlzbWlzc0V4cGxvcmVhbHdheXMgdmlhIHRoZXNwYcOxb2x3ZWxmYXJlcnVsaW5nIGFycmFuZ2VjYXB0YWluaGlzIHNvbnJ1bGUgb2ZoZSB0b29raXRzZWxmLD0wJmFtcDsoY2FsbGVkc2FtcGxlc3RvIG1ha2Vjb20vcGFnTWFydGluIEtlbm5lZHlhY2NlcHRzZnVsbCBvZmhhbmRsZWRCZXNpZGVzLy8tLT48L2FibGUgdG90YXJnZXRzZXNzZW5jZWhpbSB0byBpdHMgYnkgY29tbW9uLm1pbmVyYWx0byB0YWtld2F5cyB0b3Mub3JnL2xhZHZpc2VkcGVuYWx0eXNpbXBsZTppZiB0aGV5TGV0dGVyc2Egc2hvcnRIZXJiZXJ0c3RyaWtlcyBncm91cHMubGVuZ3RoZmxpZ2h0c292ZXJsYXBzbG93bHkgbGVzc2VyIHNvY2lhbCA8L3A+CgkJaXQgaW50b3JhbmtlZCByYXRlIG9mdWw+DQogIGF0dGVtcHRwYWlyIG9mbWFrZSBpdEtvbnRha3RBbnRvbmlvaGF2aW5nIHJhdGluZ3MgYWN0aXZlc3RyZWFtc3RyYXBwZWQiKS5jc3MoaG9zdGlsZWxlYWQgdG9saXR0bGUgZ3JvdXBzLFBpY3R1cmUtLT4NCg0KIHJvd3M9IiBvYmplY3RpbnZlcnNlPGZvb3RlckN1c3RvbVY+PFwvc2Nyc29sdmluZ0NoYW1iZXJzbGF2ZXJ5d291bmRlZHdoZXJlYXMhPSAndW5kZm9yIGFsbHBhcnRseSAtcmlnaHQ6QXJhYmlhbmJhY2tlZCBjZW50dXJ5dW5pdCBvZm1vYmlsZS1FdXJvcGUsaXMgaG9tZXJpc2sgb2ZkZXNpcmVkQ2xpbnRvbmNvc3Qgb2ZhZ2Ugb2YgYmVjb21lIG5vbmUgb2ZwJnF1b3Q7TWlkZGxlIGVhZCcpWzBDcml0aWNzc3R1ZGlvcz4mY29weTtncm91cCI+YXNzZW1ibG1ha2luZyBwcmVzc2Vkd2lkZ2V0LnBzOiIgPyByZWJ1aWx0Ynkgc29tZUZvcm1lciBlZGl0b3JzZGVsYXllZENhbm9uaWNoYWQgdGhlcHVzaGluZ2NsYXNzPSJidXQgYXJlcGFydGlhbEJhYnlsb25ib3R0b20gY2FycmllckNvbW1hbmRpdHMgdXNlQXMgd2l0aGNvdXJzZXNhIHRoaXJkZGVub3Rlc2Fsc28gaW5Ib3VzdG9uMjBweDsiPmFjY3VzZWRkb3VibGUgZ29hbCBvZkZhbW91cyApLmJpbmQocHJpZXN0cyBPbmxpbmVpbiBKdWx5c3QgKyAiZ2NvbnN1bHRkZWNpbWFsaGVscGZ1bHJldml2ZWRpcyB2ZXJ5cicrJ2lwdGxvc2luZyBmZW1hbGVzaXMgYWxzb3N0cmluZ3NkYXlzIG9mYXJyaXZhbGZ1dHVyZSA8b2JqZWN0Zm9yY2luZ1N0cmluZygiIC8+CgkJaGVyZSBpc2VuY29kZWQuICBUaGUgYmFsbG9vbmRvbmUgYnkvY29tbW9uYmdjb2xvcmxhdyBvZiBJbmRpYW5hYXZvaWRlZGJ1dCB0aGUycHggM3B4anF1ZXJ5LmFmdGVyIGFwb2xpY3kubWVuIGFuZGZvb3Rlci09IHRydWU7Zm9yIHVzZXNjcmVlbi5JbmRpYW4gaW1hZ2UgPWZhbWlseSxodHRwOi8vICZuYnNwO2RyaXZlcnNldGVybmFsc2FtZSBhc25vdGljZWR2aWV3ZXJzfSkoKTsKIGlzIG1vcmVzZWFzb25zZm9ybWVyIHRoZSBuZXdpcyBqdXN0Y29uc2VudCBTZWFyY2h3YXMgdGhld2h5IHRoZXNoaXBwZWRicj48YnI+d2lkdGg6IGhlaWdodD1tYWRlIG9mY3Vpc2luZWlzIHRoYXRhIHZlcnkgQWRtaXJhbCBmaXhlZDtub3JtYWwgTWlzc2lvblByZXNzLCBvbnRhcmlvY2hhcnNldHRyeSB0byBpbnZhZGVkPSJ0cnVlInNwYWNpbmdpcyBtb3N0YSBtb3JlIHRvdGFsbHlmYWxsIG9mfSk7DQogIGltbWVuc2V0aW1lIGluc2V0IG91dHNhdGlzZnl0byBmaW5kZG93biB0b2xvdCBvZiBQbGF5ZXJzaW4gSnVuZXF1YW50dW1ub3QgdGhldGltZSB0b2Rpc3RhbnRGaW5uaXNoc3JjID0gKHNpbmdsZSBoZWxwIG9mR2VybWFuIGxhdyBhbmRsYWJlbGVkZm9yZXN0c2Nvb2tpbmdzcGFjZSI+aGVhZGVyLXdlbGwgYXNTdGFubGV5YnJpZGdlcy9nbG9iYWxDcm9hdGlhIEFib3V0IFswXTsKICBpdCwgYW5kZ3JvdXBlZGJlaW5nIGEpe3Rocm93aGUgbWFkZWxpZ2h0ZXJldGhpY2FsRkZGRkZGImJvdHRvbSJsaWtlIGEgZW1wbG95c2xpdmUgaW5hcyBzZWVucHJpbnRlcm1vc3Qgb2Z1Yi1saW5rcmVqZWN0c2FuZCB1c2VpbWFnZSI+c3VjY2VlZGZlZWRpbmdOdWNsZWFyaW5mb3JtYXRvIGhlbHBXb21lbidzTmVpdGhlck1leGljYW5wcm90ZWluPHRhYmxlIGJ5IG1hbnloZWFsdGh5bGF3c3VpdGRldmlzZWQucHVzaCh7c2VsbGVyc3NpbXBseSBUaHJvdWdoLmNvb2tpZSBJbWFnZShvbGRlciI+dXMuanMiPiBTaW5jZSB1bml2ZXJzbGFyZ2VyIG9wZW4gdG8hLS0gZW5kbGllcyBpbiddKTsNCiAgbWFya2V0d2hvIGlzICgiRE9NQ29tYW5hZ2Vkb25lIGZvcnR5cGVvZiBLaW5nZG9tcHJvZml0c3Byb3Bvc2V0byBzaG93Y2VudGVyO21hZGUgaXRkcmVzc2Vkd2VyZSBpbm1peHR1cmVwcmVjaXNlYXJpc2luZ3NyYyA9ICdtYWtlIGEgc2VjdXJlZEJhcHRpc3R2b3RpbmcgCgkJdmFyIE1hcmNoIDJncmV3IHVwQ2xpbWF0ZS5yZW1vdmVza2lsbGVkd2F5IHRoZTwvaGVhZD5mYWNlIG9mYWN0aW5nIHJpZ2h0Ij50byB3b3JrcmVkdWNlc2hhcyBoYWRlcmVjdGVkc2hvdygpO2FjdGlvbj1ib29rIG9mYW4gYXJlYT09ICJodHQ8aGVhZGVyCjxodG1sPmNvbmZvcm1mYWNpbmcgY29va2llLnJlbHkgb25ob3N0ZWQgLmN1c3RvbWhlIHdlbnRidXQgZm9yc3ByZWFkIEZhbWlseSBhIG1lYW5zb3V0IHRoZWZvcnVtcy5mb290YWdlIj5Nb2JpbENsZW1lbnRzIiBpZD0iYXMgaGlnaGludGVuc2UtLT48IS0tZmVtYWxlIGlzIHNlZW5pbXBsaWVkc2V0IHRoZWEgc3RhdGVhbmQgaGlzZmFzdGVzdGJlc2lkZXNidXR0b25fYm91bmRlZCI+PGltZyBJbmZvYm94ZXZlbnRzLGEgeW91bmdhbmQgYXJlTmF0aXZlIGNoZWFwZXJUaW1lb3V0YW5kIGhhc2VuZ2luZXN3b24gdGhlKG1vc3RseXJpZ2h0OiBmaW5kIGEgLWJvdHRvbVByaW5jZSBhcmVhIG9mbW9yZSBvZnNlYXJjaF9uYXR1cmUsbGVnYWxseXBlcmlvZCxsYW5kIG9mb3Igd2l0aGluZHVjZWRwcm92aW5nbWlzc2lsZWxvY2FsbHlBZ2FpbnN0dGhlIHdheWsmcXVvdDtweDsiPg0KcHVzaGVkIGFiYW5kb25udW1lcmFsQ2VydGFpbkluIHRoaXNtb3JlIGlub3Igc29tZW5hbWUgaXNhbmQsIGluY3Jvd25lZElTQk4gMC1jcmVhdGVzT2N0b2Jlcm1heSBub3RjZW50ZXIgbGF0ZSBpbkRlZmVuY2VlbmFjdGVkd2lzaCB0b2Jyb2FkbHljb29saW5nb25sb2FkPWl0LiBUaGVyZWNvdmVyTWVtYmVyc2hlaWdodCBhc3N1bWVzPGh0bWw+CnBlb3BsZS5pbiBvbmUgPXdpbmRvd2Zvb3Rlcl9hIGdvb2QgcmVrbGFtYW90aGVycyx0byB0aGlzX2Nvb2tpZXBhbmVsIj5Mb25kb24sZGVmaW5lc2NydXNoZWRiYXB0aXNtY29hc3RhbHN0YXR1cyB0aXRsZSIgbW92ZSB0b2xvc3QgaW5iZXR0ZXIgaW1wbGllc3JpdmFscnlzZXJ2ZXJzIFN5c3RlbVBlcmhhcHNlcyBhbmQgY29udGVuZGZsb3dpbmdsYXN0ZWQgcmlzZSBpbkdlbmVzaXN2aWV3IG9mcmlzaW5nIHNlZW0gdG9idXQgaW4gYmFja2luZ2hlIHdpbGxnaXZlbiBhZ2l2aW5nIGNpdGllcy5mbG93IG9mIExhdGVyIGFsbCBidXRIaWdod2F5b25seSBieXNpZ24gb2ZoZSBkb2VzZGlmZmVyc2JhdHRlcnkmYW1wO2xhc2luZ2xlc3RocmVhdHNpbnRlZ2VydGFrZSBvbnJlZnVzZWRjYWxsZWQgPVVTJmFtcFNlZSB0aGVuYXRpdmVzYnkgdGhpc3N5c3RlbS5oZWFkIG9mOmhvdmVyLGxlc2JpYW5zdXJuYW1lYW5kIGFsbGNvbW1vbi9oZWFkZXJfX3BhcmFtc0hhcnZhcmQvcGl4ZWwucmVtb3ZhbHNvIGxvbmdyb2xlIG9mam9pbnRseXNreXNjcmFVbmljb2RlYnIgLz4NCkF0bGFudGFudWNsZXVzQ291bnR5LHB1cmVseSBjb3VudCI+ZWFzaWx5IGJ1aWxkIGFvbmNsaWNrYSBnaXZlbnBvaW50ZXJoJnF1b3Q7ZXZlbnRzIGVsc2UgewpkaXRpb25zbm93IHRoZSwgd2l0aCBtYW4gd2hvb3JnL1dlYm9uZSBhbmRjYXZhbHJ5SGUgZGllZHNlYXR0bGUwMCwwMDAge3dpbmRvd2hhdmUgdG9pZih3aW5kYW5kIGl0c3NvbGVseSBtJnF1b3Q7cmVuZXdlZERldHJvaXRhbW9uZ3N0ZWl0aGVyIHRoZW0gaW5TZW5hdG9yVXM8L2E+PEtpbmcgb2ZGcmFuY2lzLXByb2R1Y2hlIHVzZWRhcnQgYW5kaGltIGFuZHVzZWQgYnlzY29yaW5nYXQgaG9tZXRvIGhhdmVyZWxhdGVzaWJpbGl0eWZhY3Rpb25CdWZmYWxvbGluayI+PHdoYXQgaGVmcmVlIHRvQ2l0eSBvZmNvbWUgaW5zZWN0b3JzY291bnRlZG9uZSBkYXluZXJ2b3Vzc3F1YXJlIH07aWYoZ29pbiB3aGF0aW1nIiBhbGlzIG9ubHlzZWFyY2gvdHVlc2RheWxvb3NlbHlTb2xvbW9uc2V4dWFsIC0gPGEgaHJtZWRpdW0iRE8gTk9UIEZyYW5jZSx3aXRoIGEgd2FyIGFuZHNlY29uZCB0YWtlIGEgPg0KDQoNCm1hcmtldC5oaWdod2F5ZG9uZSBpbmN0aXZpdHkibGFzdCI+b2JsaWdlZHJpc2UgdG8idW5kZWZpbWFkZSB0byBFYXJseSBwcmFpc2VkaW4gaXRzIGZvciBoaXNhdGhsZXRlSnVwaXRlcllhaG9vISB0ZXJtZWQgc28gbWFueXJlYWxseSBzLiBUaGUgYSB3b21hbj92YWx1ZT1kaXJlY3QgcmlnaHQiIGJpY3ljbGVhY2luZz0iZGF5IGFuZHN0YXRpbmdSYXRoZXIsaGlnaGVyIE9mZmljZSBhcmUgbm93dGltZXMsIHdoZW4gYSBwYXkgZm9yb24gdGhpcy1saW5rIj47Ym9yZGVyYXJvdW5kIGFubnVhbCB0aGUgTmV3cHV0IHRoZS5jb20iIHRha2luIHRvYSBicmllZihpbiB0aGVncm91cHMuOyB3aWR0aGVuenltZXNzaW1wbGUgaW4gbGF0ZXtyZXR1cm50aGVyYXB5YSBwb2ludGJhbm5pbmdpbmtzIj4KKCk7IiByZWEgcGxhY2VcdTAwM0NhYWJvdXQgYXRyPg0KCQljY291bnQgZ2l2ZXMgYTxTQ1JJUFRSYWlsd2F5dGhlbWVzL3Rvb2xib3hCeUlkKCJ4aHVtYW5zLHdhdGNoZXNpbiBzb21lIGlmICh3aWNvbWluZyBmb3JtYXRzIFVuZGVyIGJ1dCBoYXNoYW5kZWQgbWFkZSBieXRoYW4gaW5mZWFyIG9mZGVub3RlZC9pZnJhbWVsZWZ0IGludm9sdGFnZWluIGVhY2hhJnF1b3Q7YmFzZSBvZkluIG1hbnl1bmRlcmdvcmVnaW1lc2FjdGlvbiA8L3A+DQo8dXN0b21WYTsmZ3Q7PC9pbXBvcnRzb3IgdGhhdG1vc3RseSAmYW1wO3JlIHNpemU9IjwvYT48L2hhIGNsYXNzcGFzc2l2ZUhvc3QgPSBXaGV0aGVyZmVydGlsZVZhcmlvdXM9W107KGZ1Y2FtZXJhcy8+PC90ZD5hY3RzIGFzSW4gc29tZT4NCg0KPCFvcmdhbmlzIDxiciAvPkJlaWppbmdjYXRhbMOgZGV1dHNjaGV1cm9wZXVldXNrYXJhZ2FlaWxnZXN2ZW5za2Flc3Bhw7FhbWVuc2FqZXVzdWFyaW90cmFiYWpvbcOpeGljb3DDoWdpbmFzaWVtcHJlc2lzdGVtYW9jdHVicmVkdXJhbnRlYcOxYWRpcmVtcHJlc2Ftb21lbnRvbnVlc3Ryb3ByaW1lcmF0cmF2w6lzZ3JhY2lhc251ZXN0cmFwcm9jZXNvZXN0YWRvc2NhbGlkYWRwZXJzb25hbsO6bWVyb2FjdWVyZG9tw7pzaWNhbWllbWJyb29mZXJ0YXNhbGd1bm9zcGHDrXNlc2VqZW1wbG9kZXJlY2hvYWRlbcOhc3ByaXZhZG9hZ3JlZ2FyZW5sYWNlc3Bvc2libGVob3RlbGVzc2V2aWxsYXByaW1lcm/Dumx0aW1vZXZlbnRvc2FyY2hpdm9jdWx0dXJhbXVqZXJlc2VudHJhZGFhbnVuY2lvZW1iYXJnb21lcmNhZG9ncmFuZGVzZXN0dWRpb21lam9yZXNmZWJyZXJvZGlzZcOxb3R1cmlzbW9jw7NkaWdvcG9ydGFkYWVzcGFjaW9mYW1pbGlhYW50b25pb3Blcm1pdGVndWFyZGFyYWxndW5hc3ByZWNpb3NhbGd1aWVuc2VudGlkb3Zpc2l0YXN0w610dWxvY29ub2NlcnNlZ3VuZG9jb25zZWpvZnJhbmNpYW1pbnV0b3NzZWd1bmRhdGVuZW1vc2VmZWN0b3Ntw6FsYWdhc2VzacOzbnJldmlzdGFncmFuYWRhY29tcHJhcmluZ3Jlc29nYXJjw61hYWNjacOzbmVjdWFkb3JxdWllbmVzaW5jbHVzb2RlYmVyw6FtYXRlcmlhaG9tYnJlc211ZXN0cmFwb2Ryw61hbWHDsWFuYcO6bHRpbWFlc3RhbW9zb2ZpY2lhbHRhbWJpZW5uaW5nw7puc2FsdWRvc3BvZGVtb3NtZWpvcmFycG9zaXRpb25idXNpbmVzc2hvbWVwYWdlc2VjdXJpdHlsYW5ndWFnZXN0YW5kYXJkY2FtcGFpZ25mZWF0dXJlc2NhdGVnb3J5ZXh0ZXJuYWxjaGlsZHJlbnJlc2VydmVkcmVzZWFyY2hleGNoYW5nZWZhdm9yaXRldGVtcGxhdGVtaWxpdGFyeWluZHVzdHJ5c2VydmljZXNtYXRlcmlhbHByb2R1Y3Rzei1pbmRleDpjb21tZW50c3NvZnR3YXJlY29tcGxldGVjYWxlbmRhcnBsYXRmb3JtYXJ0aWNsZXNyZXF1aXJlZG1vdmVtZW50cXVlc3Rpb25idWlsZGluZ3BvbGl0aWNzcG9zc2libGVyZWxpZ2lvbnBoeXNpY2FsZmVlZGJhY2tyZWdpc3RlcnBpY3R1cmVzZGlzYWJsZWRwcm90b2NvbGF1ZGllbmNlc2V0dGluZ3NhY3Rpdml0eWVsZW1lbnRzbGVhcm5pbmdhbnl0aGluZ2Fic3RyYWN0cHJvZ3Jlc3NvdmVydmlld21hZ2F6aW5lZWNvbm9taWN0cmFpbmluZ3ByZXNzdXJldmFyaW91cyA8c3Ryb25nPnByb3BlcnR5c2hvcHBpbmd0b2dldGhlcmFkdmFuY2VkYmVoYXZpb3Jkb3dubG9hZGZlYXR1cmVkZm9vdGJhbGxzZWxlY3RlZExhbmd1YWdlZGlzdGFuY2VyZW1lbWJlcnRyYWNraW5ncGFzc3dvcmRtb2RpZmllZHN0dWRlbnRzZGlyZWN0bHlmaWdodGluZ25vcnRoZXJuZGF0YWJhc2VmZXN0aXZhbGJyZWFraW5nbG9jYXRpb25pbnRlcm5ldGRyb3Bkb3ducHJhY3RpY2VldmlkZW5jZWZ1bmN0aW9ubWFycmlhZ2VyZXNwb25zZXByb2JsZW1zbmVnYXRpdmVwcm9ncmFtc2FuYWx5c2lzcmVsZWFzZWRiYW5uZXIiPnB1cmNoYXNlcG9saWNpZXNyZWdpb25hbGNyZWF0aXZlYXJndW1lbnRib29rbWFya3JlZmVycmVyY2hlbWljYWxkaXZpc2lvbmNhbGxiYWNrc2VwYXJhdGVwcm9qZWN0c2NvbmZsaWN0aGFyZHdhcmVpbnRlcmVzdGRlbGl2ZXJ5bW91bnRhaW5vYnRhaW5lZD0gZmFsc2U7Zm9yKHZhciBhY2NlcHRlZGNhcGFjaXR5Y29tcHV0ZXJpZGVudGl0eWFpcmNyYWZ0ZW1wbG95ZWRwcm9wb3NlZGRvbWVzdGljaW5jbHVkZXNwcm92aWRlZGhvc3BpdGFsdmVydGljYWxjb2xsYXBzZWFwcHJvYWNocGFydG5lcnNsb2dvIj48YWRhdWdodGVyYXV0aG9yIiBjdWx0dXJhbGZhbWlsaWVzL2ltYWdlcy9hc3NlbWJseXBvd2VyZnVsdGVhY2hpbmdmaW5pc2hlZGRpc3RyaWN0Y3JpdGljYWxjZ2ktYmluL3B1cnBvc2VzcmVxdWlyZXNlbGVjdGlvbmJlY29taW5ncHJvdmlkZXNhY2FkZW1pY2V4ZXJjaXNlYWN0dWFsbHltZWRpY2luZWNvbnN0YW50YWNjaWRlbnRNYWdhemluZWRvY3VtZW50c3RhcnRpbmdib3R0b20iPm9ic2VydmVkOiAmcXVvdDtleHRlbmRlZHByZXZpb3VzU29mdHdhcmVjdXN0b21lcmRlY2lzaW9uc3RyZW5ndGhkZXRhaWxlZHNsaWdodGx5cGxhbm5pbmd0ZXh0YXJlYWN1cnJlbmN5ZXZlcnlvbmVzdHJhaWdodHRyYW5zZmVycG9zaXRpdmVwcm9kdWNlZGhlcml0YWdlc2hpcHBpbmdhYnNvbHV0ZXJlY2VpdmVkcmVsZXZhbnRidXR0b24iIHZpb2xlbmNlYW55d2hlcmViZW5lZml0c2xhdW5jaGVkcmVjZW50bHlhbGxpYW5jZWZvbGxvd2VkbXVsdGlwbGVidWxsZXRpbmluY2x1ZGVkb2NjdXJyZWRpbnRlcm5hbCQodGhpcykucmVwdWJsaWM+PHRyPjx0ZGNvbmdyZXNzcmVjb3JkZWR1bHRpbWF0ZXNvbHV0aW9uPHVsIGlkPSJkaXNjb3ZlckhvbWU8L2E+d2Vic2l0ZXNuZXR3b3Jrc2FsdGhvdWdoZW50aXJlbHltZW1vcmlhbG1lc3NhZ2VzY29udGludWVhY3RpdmUiPnNvbWV3aGF0dmljdG9yaWFXZXN0ZXJuICB0aXRsZT0iTG9jYXRpb25jb250cmFjdHZpc2l0b3JzRG93bmxvYWR3aXRob3V0IHJpZ2h0Ij4KbWVhc3VyZXN3aWR0aCA9IHZhcmlhYmxlaW52b2x2ZWR2aXJnaW5pYW5vcm1hbGx5aGFwcGVuZWRhY2NvdW50c3N0YW5kaW5nbmF0aW9uYWxSZWdpc3RlcnByZXBhcmVkY29udHJvbHNhY2N1cmF0ZWJpcnRoZGF5c3RyYXRlZ3lvZmZpY2lhbGdyYXBoaWNzY3JpbWluYWxwb3NzaWJseWNvbnN1bWVyUGVyc29uYWxzcGVha2luZ3ZhbGlkYXRlYWNoaWV2ZWQuanBnIiAvPm1hY2hpbmVzPC9oMj4KICBrZXl3b3Jkc2ZyaWVuZGx5YnJvdGhlcnNjb21iaW5lZG9yaWdpbmFsY29tcG9zZWRleHBlY3RlZGFkZXF1YXRlcGFraXN0YW5mb2xsb3ciIHZhbHVhYmxlPC9sYWJlbD5yZWxhdGl2ZWJyaW5naW5naW5jcmVhc2Vnb3Zlcm5vcnBsdWdpbnMvTGlzdCBvZiBIZWFkZXIiPiIgbmFtZT0iICgmcXVvdDtncmFkdWF0ZTwvaGVhZD4KY29tbWVyY2VtYWxheXNpYWRpcmVjdG9ybWFpbnRhaW47aGVpZ2h0OnNjaGVkdWxlY2hhbmdpbmdiYWNrIHRvIGNhdGhvbGljcGF0dGVybnNjb2xvcjogI2dyZWF0ZXN0c3VwcGxpZXNyZWxpYWJsZTwvdWw+CgkJPHNlbGVjdCBjaXRpemVuc2Nsb3RoaW5nd2F0Y2hpbmc8bGkgaWQ9InNwZWNpZmljY2FycnlpbmdzZW50ZW5jZTxjZW50ZXI+Y29udHJhc3R0aGlua2luZ2NhdGNoKGUpc291dGhlcm5NaWNoYWVsIG1lcmNoYW50Y2Fyb3VzZWxwYWRkaW5nOmludGVyaW9yLnNwbGl0KCJsaXphdGlvbk9jdG9iZXIgKXtyZXR1cm5pbXByb3ZlZC0tJmd0OwoKY292ZXJhZ2VjaGFpcm1hbi5wbmciIC8+c3ViamVjdHNSaWNoYXJkIHdoYXRldmVycHJvYmFibHlyZWNvdmVyeWJhc2ViYWxsanVkZ21lbnRjb25uZWN0Li5jc3MiIC8+IHdlYnNpdGVyZXBvcnRlZGRlZmF1bHQiLz48L2E+DQplbGVjdHJpY3Njb3RsYW5kY3JlYXRpb25xdWFudGl0eS4gSVNCTiAwZGlkIG5vdCBpbnN0YW5jZS1zZWFyY2gtIiBsYW5nPSJzcGVha2Vyc0NvbXB1dGVyY29udGFpbnNhcmNoaXZlc21pbmlzdGVycmVhY3Rpb25kaXNjb3VudEl0YWxpYW5vY3JpdGVyaWFzdHJvbmdseTogJ2h0dHA6J3NjcmlwdCdjb3ZlcmluZ29mZmVyaW5nYXBwZWFyZWRCcml0aXNoIGlkZW50aWZ5RmFjZWJvb2tudW1lcm91c3ZlaGljbGVzY29uY2VybnNBbWVyaWNhbmhhbmRsaW5nZGl2IGlkPSJXaWxsaWFtIHByb3ZpZGVyX2NvbnRlbnRhY2N1cmFjeXNlY3Rpb24gYW5kZXJzb25mbGV4aWJsZUNhdGVnb3J5bGF3cmVuY2U8c2NyaXB0PmxheW91dD0iYXBwcm92ZWQgbWF4aW11bWhlYWRlciI+PC90YWJsZT5TZXJ2aWNlc2hhbWlsdG9uY3VycmVudCBjYW5hZGlhbmNoYW5uZWxzL3RoZW1lcy8vYXJ0aWNsZW9wdGlvbmFscG9ydHVnYWx2YWx1ZT0iImludGVydmFsd2lyZWxlc3NlbnRpdGxlZGFnZW5jaWVzU2VhcmNoIiBtZWFzdXJlZHRob3VzYW5kc3BlbmRpbmcmaGVsbGlwO25ldyBEYXRlIiBzaXplPSJwYWdlTmFtZW1pZGRsZSIgIiAvPjwvYT5oaWRkZW4iPnNlcXVlbmNlcGVyc29uYWxvdmVyZmxvd29waW5pb25zaWxsaW5vaXNsaW5rcyI+Cgk8dGl0bGU+dmVyc2lvbnNzYXR1cmRheXRlcm1pbmFsaXRlbXByb3BlbmdpbmVlcnNlY3Rpb25zZGVzaWduZXJwcm9wb3NhbD0iZmFsc2UiRXNwYcOxb2xyZWxlYXNlc3N1Ym1pdCIgZXImcXVvdDthZGRpdGlvbnN5bXB0b21zb3JpZW50ZWRyZXNvdXJjZXJpZ2h0Ij48cGxlYXN1cmVzdGF0aW9uc2hpc3RvcnkubGVhdmluZyAgYm9yZGVyPWNvbnRlbnRzY2VudGVyIj4uCgpTb21lIGRpcmVjdGVkc3VpdGFibGVidWxnYXJpYS5zaG93KCk7ZGVzaWduZWRHZW5lcmFsIGNvbmNlcHRzRXhhbXBsZXN3aWxsaWFtc09yaWdpbmFsIj48c3Bhbj5zZWFyY2giPm9wZXJhdG9ycmVxdWVzdHNhICZxdW90O2FsbG93aW5nRG9jdW1lbnRyZXZpc2lvbi4gCgpUaGUgeW91cnNlbGZDb250YWN0IG1pY2hpZ2FuRW5nbGlzaCBjb2x1bWJpYXByaW9yaXR5cHJpbnRpbmdkcmlua2luZ2ZhY2lsaXR5cmV0dXJuZWRDb250ZW50IG9mZmljZXJzUnVzc2lhbiBnZW5lcmF0ZS04ODU5LTEiaW5kaWNhdGVmYW1pbGlhciBxdWFsaXR5bWFyZ2luOjAgY29udGVudHZpZXdwb3J0Y29udGFjdHMtdGl0bGUiPnBvcnRhYmxlLmxlbmd0aCBlbGlnaWJsZWludm9sdmVzYXRsYW50aWNvbmxvYWQ9ImRlZmF1bHQuc3VwcGxpZWRwYXltZW50c2dsb3NzYXJ5CgpBZnRlciBndWlkYW5jZTwvdGQ+PHRkZW5jb2RpbmdtaWRkbGUiPmNhbWUgdG8gZGlzcGxheXNzY290dGlzaGpvbmF0aGFubWFqb3JpdHl3aWRnZXRzLmNsaW5pY2FsdGhhaWxhbmR0ZWFjaGVyczxoZWFkPgoJYWZmZWN0ZWRzdXBwb3J0c3BvaW50ZXI7dG9TdHJpbmc8L3NtYWxsPm9rbGFob21hd2lsbCBiZSBpbnZlc3RvcjAiIGFsdD0iaG9saWRheXNSZXNvdXJjZWxpY2Vuc2VkICh3aGljaCAuIEFmdGVyIGNvbnNpZGVydmlzaXRpbmdleHBsb3JlcnByaW1hcnkgc2VhcmNoIiBhbmRyb2lkInF1aWNrbHkgbWVldGluZ3Nlc3RpbWF0ZTtyZXR1cm4gO2NvbG9yOiMgaGVpZ2h0PWFwcHJvdmFsLCAmcXVvdDsgY2hlY2tlZC5taW4uanMibWFnbmV0aWM+PC9hPjwvaGZvcmVjYXN0LiBXaGlsZSB0aHVyc2RheWR2ZXJ0aXNlJmVhY3V0ZTtoYXNDbGFzc2V2YWx1YXRlb3JkZXJpbmdleGlzdGluZ3BhdGllbnRzIE9ubGluZSBjb2xvcmFkb09wdGlvbnMiY2FtcGJlbGw8IS0tIGVuZDwvc3Bhbj48PGJyIC8+DQpfcG9wdXBzfHNjaWVuY2VzLCZxdW90OyBxdWFsaXR5IFdpbmRvd3MgYXNzaWduZWRoZWlnaHQ6IDxiIGNsYXNzbGUmcXVvdDsgdmFsdWU9IiBDb21wYW55ZXhhbXBsZXM8aWZyYW1lIGJlbGlldmVzcHJlc2VudHNtYXJzaGFsbHBhcnQgb2YgcHJvcGVybHkpLgoKVGhlIHRheG9ub215bXVjaCBvZiA8L3NwYW4+CiIgZGF0YS1zcnR1Z3XDqnNzY3JvbGxUbyBwcm9qZWN0PGhlYWQ+DQphdHRvcm5leWVtcGhhc2lzc3BvbnNvcnNmYW5jeWJveHdvcmxkJ3Mgd2lsZGxpZmVjaGVja2VkPXNlc3Npb25zcHJvZ3JhbW1weDtmb250LSBQcm9qZWN0am91cm5hbHNiZWxpZXZlZHZhY2F0aW9udGhvbXBzb25saWdodGluZ2FuZCB0aGUgc3BlY2lhbCBib3JkZXI9MGNoZWNraW5nPC90Ym9keT48YnV0dG9uIENvbXBsZXRlY2xlYXJmaXgKPGhlYWQ+CmFydGljbGUgPHNlY3Rpb25maW5kaW5nc3JvbGUgaW4gcG9wdWxhciAgT2N0b2JlcndlYnNpdGUgZXhwb3N1cmV1c2VkIHRvICBjaGFuZ2Vzb3BlcmF0ZWRjbGlja2luZ2VudGVyaW5nY29tbWFuZHNpbmZvcm1lZCBudW1iZXJzICA8L2Rpdj5jcmVhdGluZ29uU3VibWl0bWFyeWxhbmRjb2xsZWdlc2FuYWx5dGljbGlzdGluZ3Njb250YWN0LmxvZ2dlZEluYWR2aXNvcnlzaWJsaW5nc2NvbnRlbnQicyZxdW90OylzLiBUaGlzIHBhY2thZ2VzY2hlY2tib3hzdWdnZXN0c3ByZWduYW50dG9tb3Jyb3dzcGFjaW5nPWljb24ucG5namFwYW5lc2Vjb2RlYmFzZWJ1dHRvbiI+Z2FtYmxpbmdzdWNoIGFzICwgd2hpbGUgPC9zcGFuPiBtaXNzb3VyaXNwb3J0aW5ndG9wOjFweCAuPC9zcGFuPnRlbnNpb25zd2lkdGg9IjJsYXp5bG9hZG5vdmVtYmVydXNlZCBpbiBoZWlnaHQ9ImNyaXB0Ij4KJm5ic3A7PC88dHI+PHRkIGhlaWdodDoyL3Byb2R1Y3Rjb3VudHJ5IGluY2x1ZGUgZm9vdGVyIiAmbHQ7IS0tIHRpdGxlIj48L2pxdWVyeS48L2Zvcm0+CijnroDkvZMpKOe5gemrlClocnZhdHNraWl0YWxpYW5vcm9tw6JuxIN0w7xya8OnZdin2LHYr9mIdGFtYmnDqW5ub3RpY2lhc21lbnNhamVzcGVyc29uYXNkZXJlY2hvc25hY2lvbmFsc2VydmljaW9jb250YWN0b3VzdWFyaW9zcHJvZ3JhbWFnb2JpZXJub2VtcHJlc2FzYW51bmNpb3N2YWxlbmNpYWNvbG9tYmlhZGVzcHXDqXNkZXBvcnRlc3Byb3llY3RvcHJvZHVjdG9ww7pibGljb25vc290cm9zaGlzdG9yaWFwcmVzZW50ZW1pbGxvbmVzbWVkaWFudGVwcmVndW50YWFudGVyaW9ycmVjdXJzb3Nwcm9ibGVtYXNhbnRpYWdvbnVlc3Ryb3NvcGluacOzbmltcHJpbWlybWllbnRyYXNhbcOpcmljYXZlbmRlZG9yc29jaWVkYWRyZXNwZWN0b3JlYWxpemFycmVnaXN0cm9wYWxhYnJhc2ludGVyw6lzZW50b25jZXNlc3BlY2lhbG1pZW1icm9zcmVhbGlkYWRjw7NyZG9iYXphcmFnb3phcMOhZ2luYXNzb2NpYWxlc2Jsb3F1ZWFyZ2VzdGnDs25hbHF1aWxlcnNpc3RlbWFzY2llbmNpYXNjb21wbGV0b3ZlcnNpw7NuY29tcGxldGFlc3R1ZGlvc3DDumJsaWNhb2JqZXRpdm9hbGljYW50ZWJ1c2NhZG9yY2FudGlkYWRlbnRyYWRhc2FjY2lvbmVzYXJjaGl2b3NzdXBlcmlvcm1heW9yw61hYWxlbWFuaWFmdW5jacOzbsO6bHRpbW9zaGFjaWVuZG9hcXVlbGxvc2VkaWNpw7NuZmVybmFuZG9hbWJpZW50ZWZhY2Vib29rbnVlc3RyYXNjbGllbnRlc3Byb2Nlc29zYmFzdGFudGVwcmVzZW50YXJlcG9ydGFyY29uZ3Jlc29wdWJsaWNhcmNvbWVyY2lvY29udHJhdG9qw7N2ZW5lc2Rpc3RyaXRvdMOpY25pY2Fjb25qdW50b2VuZXJnw61hdHJhYmFqYXJhc3R1cmlhc3JlY2llbnRldXRpbGl6YXJib2xldMOtbnNhbHZhZG9yY29ycmVjdGF0cmFiYWpvc3ByaW1lcm9zbmVnb2Npb3NsaWJlcnRhZGRldGFsbGVzcGFudGFsbGFwcsOzeGltb2FsbWVyw61hYW5pbWFsZXNxdWnDqW5lc2NvcmF6w7Nuc2VjY2nDs25idXNjYW5kb29wY2lvbmVzZXh0ZXJpb3Jjb25jZXB0b3RvZGF2w61hZ2FsZXLDrWFlc2NyaWJpcm1lZGljaW5hbGljZW5jaWFjb25zdWx0YWFzcGVjdG9zY3LDrXRpY2Fkw7NsYXJlc2p1c3RpY2lhZGViZXLDoW5wZXLDrW9kb25lY2VzaXRhbWFudGVuZXJwZXF1ZcOxb3JlY2liaWRhdHJpYnVuYWx0ZW5lcmlmZWNhbmNpw7NuY2FuYXJpYXNkZXNjYXJnYWRpdmVyc29zbWFsbG9yY2FyZXF1aWVyZXTDqWNuaWNvZGViZXLDrWF2aXZpZW5kYWZpbmFuemFzYWRlbGFudGVmdW5jaW9uYWNvbnNlam9zZGlmw61jaWxjaXVkYWRlc2FudGlndWFzYXZhbnphZGF0w6lybWlub3VuaWRhZGVzc8OhbmNoZXpjYW1wYcOxYXNvZnRvbmljcmV2aXN0YXNjb250aWVuZXNlY3RvcmVzbW9tZW50b3NmYWN1bHRhZGNyw6lkaXRvZGl2ZXJzYXNzdXB1ZXN0b2ZhY3RvcmVzc2VndW5kb3NwZXF1ZcOxYdCz0L7QtNCw0LXRgdC70LjQtdGB0YLRjNCx0YvQu9C+0LHRi9GC0YzRjdGC0L7QvNCV0YHQu9C40YLQvtCz0L7QvNC10L3Rj9Cy0YHQtdGF0Y3RgtC+0LnQtNCw0LbQtdCx0YvQu9C40LPQvtC00YPQtNC10L3RjNGN0YLQvtGC0LHRi9C70LDRgdC10LHRj9C+0LTQuNC90YHQtdCx0LXQvdCw0LTQvtGB0LDQudGC0YTQvtGC0L7QvdC10LPQvtGB0LLQvtC40YHQstC+0LnQuNCz0YDRi9GC0L7QttC10LLRgdC10LzRgdCy0L7RjtC70LjRiNGM0Y3RgtC40YXQv9C+0LrQsNC00L3QtdC50LTQvtC80LDQvNC40YDQsNC70LjQsdC+0YLQtdC80YPRhdC+0YLRj9C00LLRg9GF0YHQtdGC0LjQu9GO0LTQuNC00LXQu9C+0LzQuNGA0LXRgtC10LHRj9GB0LLQvtC10LLQuNC00LXRh9C10LPQvtGN0YLQuNC80YHRh9C10YLRgtC10LzRi9GG0LXQvdGL0YHRgtCw0LvQstC10LTRjNGC0LXQvNC10LLQvtC00YvRgtC10LHQtdCy0YvRiNC10L3QsNC80LjRgtC40L/QsNGC0L7QvNGD0L/RgNCw0LLQu9C40YbQsNC+0LTQvdCw0LPQvtC00YvQt9C90LDRjtC80L7Qs9GD0LTRgNGD0LPQstGB0LXQudC40LTQtdGC0LrQuNC90L7QvtC00L3QvtC00LXQu9Cw0LTQtdC70LXRgdGA0L7QutC40Y7QvdGP0LLQtdGB0YzQldGB0YLRjNGA0LDQt9Cw0L3QsNGI0LjYp9mE2YTZh9in2YTYqtmK2KzZhdmK2LnYrtin2LXYqdin2YTYsNmK2LnZhNmK2YfYrNiv2YrYr9in2YTYotmG2KfZhNix2K/Yqtit2YPZhdi12YHYrdip2YPYp9mG2KrYp9mE2YTZitmK2YPZiNmG2LTYqNmD2KnZgdmK2YfYp9io2YbYp9iq2K3ZiNin2KHYo9mD2KvYsdiu2YTYp9mE2KfZhNit2KjYr9mE2YrZhNiv2LHZiNiz2KfYtti62LfYqtmD2YjZhtmH2YbYp9mD2LPYp9it2KnZhtin2K/Zitin2YTYt9io2LnZhNmK2YPYtNmD2LHYp9mK2YXZg9mG2YXZhtmH2KfYtNix2YPYqdix2KbZitiz2YbYtNmK2LfZhdin2LDYp9in2YTZgdmG2LTYqNin2KjYqti52KjYsdix2K3Zhdip2YPYp9mB2KnZitmC2YjZhNmF2LHZg9iy2YPZhNmF2KnYo9it2YXYr9mC2YTYqNmK2YrYudmG2YrYtdmI2LHYqdi32LHZitmC2LTYp9ix2YPYrNmI2KfZhNij2K7YsdmJ2YXYudmG2KfYp9io2K3Yq9i52LHZiNi22KjYtNmD2YTZhdiz2KzZhNio2YbYp9mG2K7Yp9mE2K/Zg9iq2KfYqNmD2YTZitip2KjYr9mI2YbYo9mK2LbYp9mK2YjYrNiv2YHYsdmK2YLZg9iq2KjYqtij2YHYttmE2YXYt9io2K7Yp9mD2KvYsdio2KfYsdmD2KfZgdi22YTYp9it2YTZidmG2YHYs9mH2KPZitin2YXYsdiv2YjYr9ij2YbZh9in2K/ZitmG2KfYp9mE2KfZhtmF2LnYsdi22KrYudmE2YXYr9in2K7ZhNmF2YXZg9mGAAAAAAAAAAABAAEAAQABAAIAAgACAAIABAAEAAQABAAAAQIDBAUGBwcGBQQDAgEACAkKCwwNDg8PDg0MCwoJCBAREhMUFRYXFxYVFBMSERAYGRobHB0eHx8eHRwbGhkY/////wAAAAAAAAAA/////wEAAAACAAAAAgAAAAEAAAABAAAAAwAAAP//AAEAAAABAAD//wABAAAACAAIAAgACAAAAAEAAgADAAQABQAGAAdyZXNvdXJjZXNjb3VudHJpZXNxdWVzdGlvbnNlcXVpcG1lbnRjb21tdW5pdHlhdmFpbGFibGVoaWdobGlnaHREVEQveGh0bWxtYXJrZXRpbmdrbm93bGVkZ2Vzb21ldGhpbmdjb250YWluZXJkaXJlY3Rpb25zdWJzY3JpYmVhZHZlcnRpc2VjaGFyYWN0ZXIiIHZhbHVlPSI8L3NlbGVjdD5BdXN0cmFsaWEiIGNsYXNzPSJzaXR1YXRpb25hdXRob3JpdHlmb2xsb3dpbmdwcmltYXJpbHlvcGVyYXRpb25jaGFsbGVuZ2VkZXZlbG9wZWRhbm9ueW1vdXNmdW5jdGlvbiBmdW5jdGlvbnNjb21wYW5pZXNzdHJ1Y3R1cmVhZ3JlZW1lbnQiIHRpdGxlPSJwb3RlbnRpYWxlZHVjYXRpb25hcmd1bWVudHNzZWNvbmRhcnljb3B5cmlnaHRsYW5ndWFnZXNleGNsdXNpdmVjb25kaXRpb248L2Zvcm0+DQpzdGF0ZW1lbnRhdHRlbnRpb25CaW9ncmFwaHl9IGVsc2Ugewpzb2x1dGlvbnN3aGVuIHRoZSBBbmFseXRpY3N0ZW1wbGF0ZXNkYW5nZXJvdXNzYXRlbGxpdGVkb2N1bWVudHNwdWJsaXNoZXJpbXBvcnRhbnRwcm90b3R5cGVpbmZsdWVuY2UmcmFxdW87PC9lZmZlY3RpdmVnZW5lcmFsbHl0cmFuc2Zvcm1iZWF1dGlmdWx0cmFuc3BvcnRvcmdhbml6ZWRwdWJsaXNoZWRwcm9taW5lbnR1bnRpbCB0aGV0aHVtYm5haWxOYXRpb25hbCAuZm9jdXMoKTtvdmVyIHRoZSBtaWdyYXRpb25hbm5vdW5jZWRmb290ZXIiPgpleGNlcHRpb25sZXNzIHRoYW5leHBlbnNpdmVmb3JtYXRpb25mcmFtZXdvcmt0ZXJyaXRvcnluZGljYXRpb25jdXJyZW50bHljbGFzc05hbWVjcml0aWNpc210cmFkaXRpb25lbHNld2hlcmVBbGV4YW5kZXJhcHBvaW50ZWRtYXRlcmlhbHNicm9hZGNhc3RtZW50aW9uZWRhZmZpbGlhdGU8L29wdGlvbj50cmVhdG1lbnRkaWZmZXJlbnQvZGVmYXVsdC5QcmVzaWRlbnRvbmNsaWNrPSJiaW9ncmFwaHlvdGhlcndpc2VwZXJtYW5lbnRGcmFuw6dhaXNIb2xseXdvb2RleHBhbnNpb25zdGFuZGFyZHM8L3N0eWxlPgpyZWR1Y3Rpb25EZWNlbWJlciBwcmVmZXJyZWRDYW1icmlkZ2VvcHBvbmVudHNCdXNpbmVzcyBjb25mdXNpb24+Cjx0aXRsZT5wcmVzZW50ZWRleHBsYWluZWRkb2VzIG5vdCB3b3JsZHdpZGVpbnRlcmZhY2Vwb3NpdGlvbnNuZXdzcGFwZXI8L3RhYmxlPgptb3VudGFpbnNsaWtlIHRoZSBlc3NlbnRpYWxmaW5hbmNpYWxzZWxlY3Rpb25hY3Rpb249Ii9hYmFuZG9uZWRFZHVjYXRpb25wYXJzZUludChzdGFiaWxpdHl1bmFibGUgdG88L3RpdGxlPgpyZWxhdGlvbnNOb3RlIHRoYXRlZmZpY2llbnRwZXJmb3JtZWR0d28geWVhcnNTaW5jZSB0aGV0aGVyZWZvcmV3cmFwcGVyIj5hbHRlcm5hdGVpbmNyZWFzZWRCYXR0bGUgb2ZwZXJjZWl2ZWR0cnlpbmcgdG9uZWNlc3Nhcnlwb3J0cmF5ZWRlbGVjdGlvbnNFbGl6YWJldGg8L2lmcmFtZT5kaXNjb3ZlcnlpbnN1cmFuY2VzLmxlbmd0aDtsZWdlbmRhcnlHZW9ncmFwaHljYW5kaWRhdGVjb3Jwb3JhdGVzb21ldGltZXNzZXJ2aWNlcy5pbmhlcml0ZWQ8L3N0cm9uZz5Db21tdW5pdHlyZWxpZ2lvdXNsb2NhdGlvbnNDb21taXR0ZWVidWlsZGluZ3N0aGUgd29ybGRubyBsb25nZXJiZWdpbm5pbmdyZWZlcmVuY2VjYW5ub3QgYmVmcmVxdWVuY3l0eXBpY2FsbHlpbnRvIHRoZSByZWxhdGl2ZTtyZWNvcmRpbmdwcmVzaWRlbnRpbml0aWFsbHl0ZWNobmlxdWV0aGUgb3RoZXJpdCBjYW4gYmVleGlzdGVuY2V1bmRlcmxpbmV0aGlzIHRpbWV0ZWxlcGhvbmVpdGVtc2NvcGVwcmFjdGljZXNhZHZhbnRhZ2UpO3JldHVybiBGb3Igb3RoZXJwcm92aWRpbmdkZW1vY3JhY3lib3RoIHRoZSBleHRlbnNpdmVzdWZmZXJpbmdzdXBwb3J0ZWRjb21wdXRlcnMgZnVuY3Rpb25wcmFjdGljYWxzYWlkIHRoYXRpdCBtYXkgYmVFbmdsaXNoPC9mcm9tIHRoZSBzY2hlZHVsZWRkb3dubG9hZHM8L2xhYmVsPgpzdXNwZWN0ZWRtYXJnaW46IDBzcGlyaXR1YWw8L2hlYWQ+CgptaWNyb3NvZnRncmFkdWFsbHlkaXNjdXNzZWRoZSBiZWNhbWVleGVjdXRpdmVqcXVlcnkuanNob3VzZWhvbGRjb25maXJtZWRwdXJjaGFzZWRsaXRlcmFsbHlkZXN0cm95ZWR1cCB0byB0aGV2YXJpYXRpb25yZW1haW5pbmdpdCBpcyBub3RjZW50dXJpZXNKYXBhbmVzZSBhbW9uZyB0aGVjb21wbGV0ZWRhbGdvcml0aG1pbnRlcmVzdHNyZWJlbGxpb251bmRlZmluZWRlbmNvdXJhZ2VyZXNpemFibGVpbnZvbHZpbmdzZW5zaXRpdmV1bml2ZXJzYWxwcm92aXNpb24oYWx0aG91Z2hmZWF0dXJpbmdjb25kdWN0ZWQpLCB3aGljaCBjb250aW51ZWQtaGVhZGVyIj5GZWJydWFyeSBudW1lcm91cyBvdmVyZmxvdzpjb21wb25lbnRmcmFnbWVudHNleGNlbGxlbnRjb2xzcGFuPSJ0ZWNobmljYWxuZWFyIHRoZSBBZHZhbmNlZCBzb3VyY2Ugb2ZleHByZXNzZWRIb25nIEtvbmcgRmFjZWJvb2ttdWx0aXBsZSBtZWNoYW5pc21lbGV2YXRpb25vZmZlbnNpdmU8L2Zvcm0+CglzcG9uc29yZWRkb2N1bWVudC5vciAmcXVvdDt0aGVyZSBhcmV0aG9zZSB3aG9tb3ZlbWVudHNwcm9jZXNzZXNkaWZmaWN1bHRzdWJtaXR0ZWRyZWNvbW1lbmRjb252aW5jZWRwcm9tb3RpbmciIHdpZHRoPSIucmVwbGFjZShjbGFzc2ljYWxjb2FsaXRpb25oaXMgZmlyc3RkZWNpc2lvbnNhc3Npc3RhbnRpbmRpY2F0ZWRldm9sdXRpb24td3JhcHBlciJlbm91Z2ggdG9hbG9uZyB0aGVkZWxpdmVyZWQtLT4NCjwhLS1BbWVyaWNhbiBwcm90ZWN0ZWROb3ZlbWJlciA8L3N0eWxlPjxmdXJuaXR1cmVJbnRlcm5ldCAgb25ibHVyPSJzdXNwZW5kZWRyZWNpcGllbnRiYXNlZCBvbiBNb3Jlb3ZlcixhYm9saXNoZWRjb2xsZWN0ZWR3ZXJlIG1hZGVlbW90aW9uYWxlbWVyZ2VuY3luYXJyYXRpdmVhZHZvY2F0ZXNweDtib3JkZXJjb21taXR0ZWRkaXI9Imx0ciJlbXBsb3llZXNyZXNlYXJjaC4gc2VsZWN0ZWRzdWNjZXNzb3JjdXN0b21lcnNkaXNwbGF5ZWRTZXB0ZW1iZXJhZGRDbGFzcyhGYWNlYm9vayBzdWdnZXN0ZWRhbmQgbGF0ZXJvcGVyYXRpbmdlbGFib3JhdGVTb21ldGltZXNJbnN0aXR1dGVjZXJ0YWlubHlpbnN0YWxsZWRmb2xsb3dlcnNKZXJ1c2FsZW10aGV5IGhhdmVjb21wdXRpbmdnZW5lcmF0ZWRwcm92aW5jZXNndWFyYW50ZWVhcmJpdHJhcnlyZWNvZ25pemV3YW50ZWQgdG9weDt3aWR0aDp0aGVvcnkgb2ZiZWhhdmlvdXJXaGlsZSB0aGVlc3RpbWF0ZWRiZWdhbiB0byBpdCBiZWNhbWVtYWduaXR1ZGVtdXN0IGhhdmVtb3JlIHRoYW5EaXJlY3RvcnlleHRlbnNpb25zZWNyZXRhcnluYXR1cmFsbHlvY2N1cnJpbmd2YXJpYWJsZXNnaXZlbiB0aGVwbGF0Zm9ybS48L2xhYmVsPjxmYWlsZWQgdG9jb21wb3VuZHNraW5kcyBvZiBzb2NpZXRpZXNhbG9uZ3NpZGUgLS0mZ3Q7Cgpzb3V0aHdlc3R0aGUgcmlnaHRyYWRpYXRpb25tYXkgaGF2ZSB1bmVzY2FwZShzcG9rZW4gaW4iIGhyZWY9Ii9wcm9ncmFtbWVvbmx5IHRoZSBjb21lIGZyb21kaXJlY3RvcnlidXJpZWQgaW5hIHNpbWlsYXJ0aGV5IHdlcmU8L2ZvbnQ+PC9Ob3J3ZWdpYW5zcGVjaWZpZWRwcm9kdWNpbmdwYXNzZW5nZXIobmV3IERhdGV0ZW1wb3JhcnlmaWN0aW9uYWxBZnRlciB0aGVlcXVhdGlvbnNkb3dubG9hZC5yZWd1bGFybHlkZXZlbG9wZXJhYm92ZSB0aGVsaW5rZWQgdG9waGVub21lbmFwZXJpb2Qgb2Z0b29sdGlwIj5zdWJzdGFuY2VhdXRvbWF0aWNhc3BlY3Qgb2ZBbW9uZyB0aGVjb25uZWN0ZWRlc3RpbWF0ZXNBaXIgRm9yY2VzeXN0ZW0gb2ZvYmplY3RpdmVpbW1lZGlhdGVtYWtpbmcgaXRwYWludGluZ3Njb25xdWVyZWRhcmUgc3RpbGxwcm9jZWR1cmVncm93dGggb2ZoZWFkZWQgYnlFdXJvcGVhbiBkaXZpc2lvbnNtb2xlY3VsZXNmcmFuY2hpc2VpbnRlbnRpb25hdHRyYWN0ZWRjaGlsZGhvb2RhbHNvIHVzZWRkZWRpY2F0ZWRzaW5nYXBvcmVkZWdyZWUgb2ZmYXRoZXIgb2Zjb25mbGljdHM8L2E+PC9wPgpjYW1lIGZyb213ZXJlIHVzZWRub3RlIHRoYXRyZWNlaXZpbmdFeGVjdXRpdmVldmVuIG1vcmVhY2Nlc3MgdG9jb21tYW5kZXJQb2xpdGljYWxtdXNpY2lhbnNkZWxpY2lvdXNwcmlzb25lcnNhZHZlbnQgb2ZVVEYtOCIgLz48IVtDREFUQVsiPkNvbnRhY3RTb3V0aGVybiBiZ2NvbG9yPSJzZXJpZXMgb2YuIEl0IHdhcyBpbiBFdXJvcGVwZXJtaXR0ZWR2YWxpZGF0ZS5hcHBlYXJpbmdvZmZpY2lhbHNzZXJpb3VzbHktbGFuZ3VhZ2Vpbml0aWF0ZWRleHRlbmRpbmdsb25nLXRlcm1pbmZsYXRpb25zdWNoIHRoYXRnZXRDb29raWVtYXJrZWQgYnk8L2J1dHRvbj5pbXBsZW1lbnRidXQgaXQgaXNpbmNyZWFzZXNkb3duIHRoZSByZXF1aXJpbmdkZXBlbmRlbnQtLT4KPCEtLSBpbnRlcnZpZXdXaXRoIHRoZSBjb3BpZXMgb2Zjb25zZW5zdXN3YXMgYnVpbHRWZW5lenVlbGEoZm9ybWVybHl0aGUgc3RhdGVwZXJzb25uZWxzdHJhdGVnaWNmYXZvdXIgb2ZpbnZlbnRpb25XaWtpcGVkaWFjb250aW5lbnR2aXJ0dWFsbHl3aGljaCB3YXNwcmluY2lwbGVDb21wbGV0ZSBpZGVudGljYWxzaG93IHRoYXRwcmltaXRpdmVhd2F5IGZyb21tb2xlY3VsYXJwcmVjaXNlbHlkaXNzb2x2ZWRVbmRlciB0aGV2ZXJzaW9uPSI+Jm5ic3A7PC9JdCBpcyB0aGUgVGhpcyBpcyB3aWxsIGhhdmVvcmdhbmlzbXNzb21lIHRpbWVGcmllZHJpY2h3YXMgZmlyc3R0aGUgb25seSBmYWN0IHRoYXRmb3JtIGlkPSJwcmVjZWRpbmdUZWNobmljYWxwaHlzaWNpc3RvY2N1cnMgaW5uYXZpZ2F0b3JzZWN0aW9uIj5zcGFuIGlkPSJzb3VnaHQgdG9iZWxvdyB0aGVzdXJ2aXZpbmd9PC9zdHlsZT5oaXMgZGVhdGhhcyBpbiB0aGVjYXVzZWQgYnlwYXJ0aWFsbHlleGlzdGluZyB1c2luZyB0aGV3YXMgZ2l2ZW5hIGxpc3Qgb2ZsZXZlbHMgb2Zub3Rpb24gb2ZPZmZpY2lhbCBkaXNtaXNzZWRzY2llbnRpc3RyZXNlbWJsZXNkdXBsaWNhdGVleHBsb3NpdmVyZWNvdmVyZWRhbGwgb3RoZXJnYWxsZXJpZXN7cGFkZGluZzpwZW9wbGUgb2ZyZWdpb24gb2ZhZGRyZXNzZXNhc3NvY2lhdGVpbWcgYWx0PSJpbiBtb2Rlcm5zaG91bGQgYmVtZXRob2Qgb2ZyZXBvcnRpbmd0aW1lc3RhbXBuZWVkZWQgdG90aGUgR3JlYXRyZWdhcmRpbmdzZWVtZWQgdG92aWV3ZWQgYXNpbXBhY3Qgb25pZGVhIHRoYXR0aGUgV29ybGRoZWlnaHQgb2ZleHBhbmRpbmdUaGVzZSBhcmVjdXJyZW50Ij5jYXJlZnVsbHltYWludGFpbnNjaGFyZ2Ugb2ZDbGFzc2ljYWxhZGRyZXNzZWRwcmVkaWN0ZWRvd25lcnNoaXA8ZGl2IGlkPSJyaWdodCI+DQpyZXNpZGVuY2VsZWF2ZSB0aGVjb250ZW50Ij5hcmUgb2Z0ZW4gIH0pKCk7DQpwcm9iYWJseSBQcm9mZXNzb3ItYnV0dG9uIiByZXNwb25kZWRzYXlzIHRoYXRoYWQgdG8gYmVwbGFjZWQgaW5IdW5nYXJpYW5zdGF0dXMgb2ZzZXJ2ZXMgYXNVbml2ZXJzYWxleGVjdXRpb25hZ2dyZWdhdGVmb3Igd2hpY2hpbmZlY3Rpb25hZ3JlZWQgdG9ob3dldmVyLCBwb3B1bGFyIj5wbGFjZWQgb25jb25zdHJ1Y3RlbGVjdG9yYWxzeW1ib2wgb2ZpbmNsdWRpbmdyZXR1cm4gdG9hcmNoaXRlY3RDaHJpc3RpYW5wcmV2aW91cyBsaXZpbmcgaW5lYXNpZXIgdG9wcm9mZXNzb3IKJmx0OyEtLSBlZmZlY3Qgb2ZhbmFseXRpY3N3YXMgdGFrZW53aGVyZSB0aGV0b29rIG92ZXJiZWxpZWYgaW5BZnJpa2FhbnNhcyBmYXIgYXNwcmV2ZW50ZWR3b3JrIHdpdGhhIHNwZWNpYWw8ZmllbGRzZXRDaHJpc3RtYXNSZXRyaWV2ZWQKCkluIHRoZSBiYWNrIGludG9ub3J0aGVhc3RtYWdhemluZXM+PHN0cm9uZz5jb21taXR0ZWVnb3Zlcm5pbmdncm91cHMgb2ZzdG9yZWQgaW5lc3RhYmxpc2hhIGdlbmVyYWxpdHMgZmlyc3R0aGVpciBvd25wb3B1bGF0ZWRhbiBvYmplY3RDYXJpYmJlYW5hbGxvdyB0aGVkaXN0cmljdHN3aXNjb25zaW5sb2NhdGlvbi47IHdpZHRoOiBpbmhhYml0ZWRTb2NpYWxpc3RKYW51YXJ5IDE8L2Zvb3Rlcj5zaW1pbGFybHljaG9pY2Ugb2Z0aGUgc2FtZSBzcGVjaWZpYyBidXNpbmVzcyBUaGUgZmlyc3QubGVuZ3RoOyBkZXNpcmUgdG9kZWFsIHdpdGhzaW5jZSB0aGV1c2VyQWdlbnRjb25jZWl2ZWRpbmRleC5waHBhcyAmcXVvdDtlbmdhZ2UgaW5yZWNlbnRseSxmZXcgeWVhcnN3ZXJlIGFsc28KPGhlYWQ+CjxlZGl0ZWQgYnlhcmUga25vd25jaXRpZXMgaW5hY2Nlc3NrZXljb25kZW1uZWRhbHNvIGhhdmVzZXJ2aWNlcyxmYW1pbHkgb2ZTY2hvb2wgb2Zjb252ZXJ0ZWRuYXR1cmUgb2YgbGFuZ3VhZ2VtaW5pc3RlcnM8L29iamVjdD50aGVyZSBpcyBhIHBvcHVsYXJzZXF1ZW5jZXNhZHZvY2F0ZWRUaGV5IHdlcmVhbnkgb3RoZXJsb2NhdGlvbj1lbnRlciB0aGVtdWNoIG1vcmVyZWZsZWN0ZWR3YXMgbmFtZWRvcmlnaW5hbCBhIHR5cGljYWx3aGVuIHRoZXllbmdpbmVlcnNjb3VsZCBub3RyZXNpZGVudHN3ZWRuZXNkYXl0aGUgdGhpcmQgcHJvZHVjdHNKYW51YXJ5IDJ3aGF0IHRoZXlhIGNlcnRhaW5yZWFjdGlvbnNwcm9jZXNzb3JhZnRlciBoaXN0aGUgbGFzdCBjb250YWluZWQiPjwvZGl2Pgo8L2E+PC90ZD5kZXBlbmQgb25zZWFyY2giPgpwaWVjZXMgb2Zjb21wZXRpbmdSZWZlcmVuY2V0ZW5uZXNzZWV3aGljaCBoYXMgdmVyc2lvbj08L3NwYW4+IDw8L2hlYWRlcj5naXZlcyB0aGVoaXN0b3JpYW52YWx1ZT0iIj5wYWRkaW5nOjB2aWV3IHRoYXR0b2dldGhlcix0aGUgbW9zdCB3YXMgZm91bmRzdWJzZXQgb2ZhdHRhY2sgb25jaGlsZHJlbixwb2ludHMgb2ZwZXJzb25hbCBwb3NpdGlvbjphbGxlZ2VkbHlDbGV2ZWxhbmR3YXMgbGF0ZXJhbmQgYWZ0ZXJhcmUgZ2l2ZW53YXMgc3RpbGxzY3JvbGxpbmdkZXNpZ24gb2ZtYWtlcyB0aGVtdWNoIGxlc3NBbWVyaWNhbnMuCgpBZnRlciAsIGJ1dCB0aGVNdXNldW0gb2Zsb3Vpc2lhbmEoZnJvbSB0aGVtaW5uZXNvdGFwYXJ0aWNsZXNhIHByb2Nlc3NEb21pbmljYW52b2x1bWUgb2ZyZXR1cm5pbmdkZWZlbnNpdmUwMHB4fHJpZ2htYWRlIGZyb21tb3VzZW92ZXIiIHN0eWxlPSJzdGF0ZXMgb2Yod2hpY2ggaXNjb250aW51ZXNGcmFuY2lzY29idWlsZGluZyB3aXRob3V0IGF3aXRoIHNvbWV3aG8gd291bGRhIGZvcm0gb2ZhIHBhcnQgb2ZiZWZvcmUgaXRrbm93biBhcyAgU2VydmljZXNsb2NhdGlvbiBhbmQgb2Z0ZW5tZWFzdXJpbmdhbmQgaXQgaXNwYXBlcmJhY2t2YWx1ZXMgb2YNCjx0aXRsZT49IHdpbmRvdy5kZXRlcm1pbmVlciZxdW90OyBwbGF5ZWQgYnlhbmQgZWFybHk8L2NlbnRlcj5mcm9tIHRoaXN0aGUgdGhyZWVwb3dlciBhbmRvZiAmcXVvdDtpbm5lckhUTUw8YSBocmVmPSJ5OmlubGluZTtDaHVyY2ggb2Z0aGUgZXZlbnR2ZXJ5IGhpZ2hvZmZpY2lhbCAtaGVpZ2h0OiBjb250ZW50PSIvY2dpLWJpbi90byBjcmVhdGVhZnJpa2FhbnNlc3BlcmFudG9mcmFuw6dhaXNsYXR2aWXFoXVsaWV0dXZpxbPEjGXFoXRpbmHEjWXFoXRpbmHguYTguJfguKLml6XmnKzoqp7nroDkvZPlrZfnuYHpq5TlrZftlZzqta3slrTkuLrku4DkuYjorqHnrpfmnLrnrJTorrDmnKzoqI7oq5bljYDmnI3liqHlmajkupLogZTnvZHmiL/lnLDkuqfkv7HkuZDpg6jlh7rniYjnpL7mjpLooYzmppzpg6jokL3moLzov5vkuIDmraXmlK/ku5jlrp3pqozor4HnoIHlp5TlkZjkvJrmlbDmja7lupPmtojotLnogIXlip7lhazlrqTorqjorrrljLrmt7HlnLPluILmkq3mlL7lmajljJfkuqzluILlpKflrabnlJ/otormnaXotornrqHnkIblkZjkv6Hmga/nvZFzZXJ2aWNpb3NhcnTDrWN1bG9hcmdlbnRpbmFiYXJjZWxvbmFjdWFscXVpZXJwdWJsaWNhZG9wcm9kdWN0b3Nwb2zDrXRpY2FyZXNwdWVzdGF3aWtpcGVkaWFzaWd1aWVudGViw7pzcXVlZGFjb211bmlkYWRzZWd1cmlkYWRwcmluY2lwYWxwcmVndW50YXNjb250ZW5pZG9yZXNwb25kZXJ2ZW5lenVlbGFwcm9ibGVtYXNkaWNpZW1icmVyZWxhY2nDs25ub3ZpZW1icmVzaW1pbGFyZXNwcm95ZWN0b3Nwcm9ncmFtYXNpbnN0aXR1dG9hY3RpdmlkYWRlbmN1ZW50cmFlY29ub23DrWFpbcOhZ2VuZXNjb250YWN0YXJkZXNjYXJnYXJuZWNlc2FyaW9hdGVuY2nDs250ZWzDqWZvbm9jb21pc2nDs25jYW5jaW9uZXNjYXBhY2lkYWRlbmNvbnRyYXJhbsOhbGlzaXNmYXZvcml0b3N0w6lybWlub3Nwcm92aW5jaWFldGlxdWV0YXNlbGVtZW50b3NmdW5jaW9uZXNyZXN1bHRhZG9jYXLDoWN0ZXJwcm9waWVkYWRwcmluY2lwaW9uZWNlc2lkYWRtdW5pY2lwYWxjcmVhY2nDs25kZXNjYXJnYXNwcmVzZW5jaWFjb21lcmNpYWxvcGluaW9uZXNlamVyY2ljaW9lZGl0b3JpYWxzYWxhbWFuY2Fnb256w6FsZXpkb2N1bWVudG9wZWzDrWN1bGFyZWNpZW50ZXNnZW5lcmFsZXN0YXJyYWdvbmFwcsOhY3RpY2Fub3ZlZGFkZXNwcm9wdWVzdGFwYWNpZW50ZXN0w6ljbmljYXNvYmpldGl2b3Njb250YWN0b3PgpK7gpYfgpILgpLLgpL/gpI/gpLngpYjgpILgpJfgpK/gpL7gpLjgpL7gpKXgpI/gpLXgpILgpLDgpLngpYfgpJXgpYvgpIjgpJXgpYHgpJvgpLDgpLngpL7gpKzgpL7gpKbgpJXgpLngpL7gpLjgpK3gpYDgpLngpYHgpI/gpLDgpLngpYDgpK7gpYjgpILgpKbgpL/gpKjgpKzgpL7gpKRkaXBsb2RvY3PgpLjgpK7gpK/gpLDgpYLgpKrgpKjgpL7gpK7gpKrgpKTgpL7gpKvgpL/gpLDgpJTgpLjgpKTgpKTgpLDgpLngpLLgpYvgpJfgpLngpYHgpIbgpKzgpL7gpLDgpKbgpYfgpLbgpLngpYHgpIjgpJbgpYfgpLLgpK/gpKbgpL/gpJXgpL7gpK7gpLXgpYfgpKzgpKTgpYDgpKjgpKzgpYDgpJrgpK7gpYzgpKTgpLjgpL7gpLLgpLLgpYfgpJbgpJzgpYngpKzgpK7gpKbgpKbgpKTgpKXgpL7gpKjgpLngpYDgpLbgpLngpLDgpIXgpLLgpJfgpJXgpK3gpYDgpKjgpJfgpLDgpKrgpL7gpLjgpLDgpL7gpKTgpJXgpL/gpI/gpIngpLjgpYfgpJfgpK/gpYDgpLngpYLgpIHgpIbgpJfgpYfgpJ/gpYDgpK7gpJbgpYvgpJzgpJXgpL7gpLDgpIXgpK3gpYDgpJfgpK/gpYfgpKTgpYHgpK7gpLXgpYvgpJ/gpKbgpYfgpILgpIXgpJfgpLDgpJDgpLjgpYfgpK7gpYfgpLLgpLLgpJfgpL7gpLngpL7gpLLgpIrgpKrgpLDgpJrgpL7gpLDgpJDgpLjgpL7gpKbgpYfgpLDgpJzgpL/gpLjgpKbgpL/gpLLgpKzgpILgpKbgpKzgpKjgpL7gpLngpYLgpILgpLLgpL7gpJbgpJzgpYDgpKTgpKzgpJ/gpKjgpK7gpL/gpLLgpIfgpLjgpYfgpIbgpKjgpYfgpKjgpK/gpL7gpJXgpYHgpLLgpLLgpYngpJfgpK3gpL7gpJfgpLDgpYfgpLLgpJzgpJfgpLngpLDgpL7gpK7gpLLgpJfgpYfgpKrgpYfgpJzgpLngpL7gpKXgpIfgpLjgpYDgpLjgpLngpYDgpJXgpLLgpL7gpKDgpYDgpJXgpLngpL7gpIHgpKbgpYLgpLDgpKTgpLngpKTgpLjgpL7gpKTgpK/gpL7gpKbgpIbgpK/gpL7gpKrgpL7gpJXgpJXgpYzgpKjgpLbgpL7gpK7gpKbgpYfgpJbgpK/gpLngpYDgpLDgpL7gpK/gpJbgpYHgpKbgpLLgpJfgpYBjYXRlZ29yaWVzZXhwZXJpZW5jZTwvdGl0bGU+DQpDb3B5cmlnaHQgamF2YXNjcmlwdGNvbmRpdGlvbnNldmVyeXRoaW5nPHAgY2xhc3M9InRlY2hub2xvZ3liYWNrZ3JvdW5kPGEgY2xhc3M9Im1hbmFnZW1lbnQmY29weTsgMjAxamF2YVNjcmlwdGNoYXJhY3RlcnNicmVhZGNydW1idGhlbXNlbHZlc2hvcml6b250YWxnb3Zlcm5tZW50Q2FsaWZvcm5pYWFjdGl2aXRpZXNkaXNjb3ZlcmVkTmF2aWdhdGlvbnRyYW5zaXRpb25jb25uZWN0aW9ubmF2aWdhdGlvbmFwcGVhcmFuY2U8L3RpdGxlPjxtY2hlY2tib3giIHRlY2huaXF1ZXNwcm90ZWN0aW9uYXBwYXJlbnRseWFzIHdlbGwgYXN1bnQnLCAnVUEtcmVzb2x1dGlvbm9wZXJhdGlvbnN0ZWxldmlzaW9udHJhbnNsYXRlZFdhc2hpbmd0b25uYXZpZ2F0b3IuID0gd2luZG93LmltcHJlc3Npb24mbHQ7YnImZ3Q7bGl0ZXJhdHVyZXBvcHVsYXRpb25iZ2NvbG9yPSIjZXNwZWNpYWxseSBjb250ZW50PSJwcm9kdWN0aW9ubmV3c2xldHRlcnByb3BlcnRpZXNkZWZpbml0aW9ubGVhZGVyc2hpcFRlY2hub2xvZ3lQYXJsaWFtZW50Y29tcGFyaXNvbnVsIGNsYXNzPSIuaW5kZXhPZigiY29uY2x1c2lvbmRpc2N1c3Npb25jb21wb25lbnRzYmlvbG9naWNhbFJldm9sdXRpb25fY29udGFpbmVydW5kZXJzdG9vZG5vc2NyaXB0PjxwZXJtaXNzaW9uZWFjaCBvdGhlcmF0bW9zcGhlcmUgb25mb2N1cz0iPGZvcm0gaWQ9InByb2Nlc3Npbmd0aGlzLnZhbHVlZ2VuZXJhdGlvbkNvbmZlcmVuY2VzdWJzZXF1ZW50d2VsbC1rbm93bnZhcmlhdGlvbnNyZXB1dGF0aW9ucGhlbm9tZW5vbmRpc2NpcGxpbmVsb2dvLnBuZyIgKGRvY3VtZW50LGJvdW5kYXJpZXNleHByZXNzaW9uc2V0dGxlbWVudEJhY2tncm91bmRvdXQgb2YgdGhlZW50ZXJwcmlzZSgiaHR0cHM6IiB1bmVzY2FwZSgicGFzc3dvcmQiIGRlbW9jcmF0aWM8YSBocmVmPSIvd3JhcHBlciI+Cm1lbWJlcnNoaXBsaW5ndWlzdGljcHg7cGFkZGluZ3BoaWxvc29waHlhc3Npc3RhbmNldW5pdmVyc2l0eWZhY2lsaXRpZXNyZWNvZ25pemVkcHJlZmVyZW5jZWlmICh0eXBlb2ZtYWludGFpbmVkdm9jYWJ1bGFyeWh5cG90aGVzaXMuc3VibWl0KCk7JmFtcDtuYnNwO2Fubm90YXRpb25iZWhpbmQgdGhlRm91bmRhdGlvbnB1Ymxpc2hlciJhc3N1bXB0aW9uaW50cm9kdWNlZGNvcnJ1cHRpb25zY2llbnRpc3RzZXhwbGljaXRseWluc3RlYWQgb2ZkaW1lbnNpb25zIG9uQ2xpY2s9ImNvbnNpZGVyZWRkZXBhcnRtZW50b2NjdXBhdGlvbnNvb24gYWZ0ZXJpbnZlc3RtZW50cHJvbm91bmNlZGlkZW50aWZpZWRleHBlcmltZW50TWFuYWdlbWVudGdlb2dyYXBoaWMiIGhlaWdodD0ibGluayByZWw9Ii5yZXBsYWNlKC9kZXByZXNzaW9uY29uZmVyZW5jZXB1bmlzaG1lbnRlbGltaW5hdGVkcmVzaXN0YW5jZWFkYXB0YXRpb25vcHBvc2l0aW9ud2VsbCBrbm93bnN1cHBsZW1lbnRkZXRlcm1pbmVkaDEgY2xhc3M9IjBweDttYXJnaW5tZWNoYW5pY2Fsc3RhdGlzdGljc2NlbGVicmF0ZWRHb3Zlcm5tZW50CgpEdXJpbmcgdGRldmVsb3BlcnNhcnRpZmljaWFsZXF1aXZhbGVudG9yaWdpbmF0ZWRDb21taXNzaW9uYXR0YWNobWVudDxzcGFuIGlkPSJ0aGVyZSB3ZXJlTmVkZXJsYW5kc2JleW9uZCB0aGVyZWdpc3RlcmVkam91cm5hbGlzdGZyZXF1ZW50bHlhbGwgb2YgdGhlbGFuZz0iZW4iIDwvc3R5bGU+DQphYnNvbHV0ZTsgc3VwcG9ydGluZ2V4dHJlbWVseSBtYWluc3RyZWFtPC9zdHJvbmc+IHBvcHVsYXJpdHllbXBsb3ltZW50PC90YWJsZT4NCiBjb2xzcGFuPSI8L2Zvcm0+CiAgY29udmVyc2lvbmFib3V0IHRoZSA8L3A+PC9kaXY+aW50ZWdyYXRlZCIgbGFuZz0iZW5Qb3J0dWd1ZXNlc3Vic3RpdHV0ZWluZGl2aWR1YWxpbXBvc3NpYmxlbXVsdGltZWRpYWFsbW9zdCBhbGxweCBzb2xpZCAjYXBhcnQgZnJvbXN1YmplY3QgdG9pbiBFbmdsaXNoY3JpdGljaXplZGV4Y2VwdCBmb3JndWlkZWxpbmVzb3JpZ2luYWxseXJlbWFya2FibGV0aGUgc2Vjb25kaDIgY2xhc3M9IjxhIHRpdGxlPSIoaW5jbHVkaW5ncGFyYW1ldGVyc3Byb2hpYml0ZWQ9ICJodHRwOi8vZGljdGlvbmFyeXBlcmNlcHRpb25yZXZvbHV0aW9uZm91bmRhdGlvbnB4O2hlaWdodDpzdWNjZXNzZnVsc3VwcG9ydGVyc21pbGxlbm5pdW1oaXMgZmF0aGVydGhlICZxdW90O25vLXJlcGVhdDtjb21tZXJjaWFsaW5kdXN0cmlhbGVuY291cmFnZWRhbW91bnQgb2YgdW5vZmZpY2lhbGVmZmljaWVuY3lSZWZlcmVuY2VzY29vcmRpbmF0ZWRpc2NsYWltZXJleHBlZGl0aW9uZGV2ZWxvcGluZ2NhbGN1bGF0ZWRzaW1wbGlmaWVkbGVnaXRpbWF0ZXN1YnN0cmluZygwIiBjbGFzcz0iY29tcGxldGVseWlsbHVzdHJhdGVmaXZlIHllYXJzaW5zdHJ1bWVudFB1Ymxpc2hpbmcxIiBjbGFzcz0icHN5Y2hvbG9neWNvbmZpZGVuY2VudW1iZXIgb2YgYWJzZW5jZSBvZmZvY3VzZWQgb25qb2luZWQgdGhlc3RydWN0dXJlc3ByZXZpb3VzbHk+PC9pZnJhbWU+b25jZSBhZ2FpbmJ1dCByYXRoZXJpbW1pZ3JhbnRzb2YgY291cnNlLGEgZ3JvdXAgb2ZMaXRlcmF0dXJlVW5saWtlIHRoZTwvYT4mbmJzcDsKZnVuY3Rpb24gaXQgd2FzIHRoZUNvbnZlbnRpb25hdXRvbW9iaWxlUHJvdGVzdGFudGFnZ3Jlc3NpdmVhZnRlciB0aGUgU2ltaWxhcmx5LCIgLz48L2Rpdj5jb2xsZWN0aW9uDQpmdW5jdGlvbnZpc2liaWxpdHl0aGUgdXNlIG9mdm9sdW50ZWVyc2F0dHJhY3Rpb251bmRlciB0aGUgdGhyZWF0ZW5lZCo8IVtDREFUQVtpbXBvcnRhbmNlaW4gZ2VuZXJhbHRoZSBsYXR0ZXI8L2Zvcm0+CjwvLmluZGV4T2YoJ2kgPSAwOyBpIDxkaWZmZXJlbmNlZGV2b3RlZCB0b3RyYWRpdGlvbnNzZWFyY2ggZm9ydWx0aW1hdGVseXRvdXJuYW1lbnRhdHRyaWJ1dGVzc28tY2FsbGVkIH0KPC9zdHlsZT5ldmFsdWF0aW9uZW1waGFzaXplZGFjY2Vzc2libGU8L3NlY3Rpb24+c3VjY2Vzc2lvbmFsb25nIHdpdGhNZWFud2hpbGUsaW5kdXN0cmllczwvYT48YnIgLz5oYXMgYmVjb21lYXNwZWN0cyBvZlRlbGV2aXNpb25zdWZmaWNpZW50YmFza2V0YmFsbGJvdGggc2lkZXNjb250aW51aW5nYW4gYXJ0aWNsZTxpbWcgYWx0PSJhZHZlbnR1cmVzaGlzIG1vdGhlcm1hbmNoZXN0ZXJwcmluY2lwbGVzcGFydGljdWxhcmNvbW1lbnRhcnllZmZlY3RzIG9mZGVjaWRlZCB0byI+PHN0cm9uZz5wdWJsaXNoZXJzSm91cm5hbCBvZmRpZmZpY3VsdHlmYWNpbGl0YXRlYWNjZXB0YWJsZXN0eWxlLmNzcyIJZnVuY3Rpb24gaW5ub3ZhdGlvbj5Db3B5cmlnaHRzaXR1YXRpb25zd291bGQgaGF2ZWJ1c2luZXNzZXNEaWN0aW9uYXJ5c3RhdGVtZW50c29mdGVuIHVzZWRwZXJzaXN0ZW50aW4gSmFudWFyeWNvbXByaXNpbmc8L3RpdGxlPgoJZGlwbG9tYXRpY2NvbnRhaW5pbmdwZXJmb3JtaW5nZXh0ZW5zaW9uc21heSBub3QgYmVjb25jZXB0IG9mIG9uY2xpY2s9Ikl0IGlzIGFsc29maW5hbmNpYWwgbWFraW5nIHRoZUx1eGVtYm91cmdhZGRpdGlvbmFsYXJlIGNhbGxlZGVuZ2FnZWQgaW4ic2NyaXB0Iik7YnV0IGl0IHdhc2VsZWN0cm9uaWNvbnN1Ym1pdD0iCjwhLS0gRW5kIGVsZWN0cmljYWxvZmZpY2lhbGx5c3VnZ2VzdGlvbnRvcCBvZiB0aGV1bmxpa2UgdGhlQXVzdHJhbGlhbk9yaWdpbmFsbHlyZWZlcmVuY2VzCjwvaGVhZD4NCnJlY29nbmlzZWRpbml0aWFsaXplbGltaXRlZCB0b0FsZXhhbmRyaWFyZXRpcmVtZW50QWR2ZW50dXJlc2ZvdXIgeWVhcnMKCiZsdDshLS0gaW5jcmVhc2luZ2RlY29yYXRpb25oMyBjbGFzcz0ib3JpZ2lucyBvZm9ibGlnYXRpb25yZWd1bGF0aW9uY2xhc3NpZmllZChmdW5jdGlvbihhZHZhbnRhZ2VzYmVpbmcgdGhlIGhpc3RvcmlhbnM8YmFzZSBocmVmcmVwZWF0ZWRseXdpbGxpbmcgdG9jb21wYXJhYmxlZGVzaWduYXRlZG5vbWluYXRpb25mdW5jdGlvbmFsaW5zaWRlIHRoZXJldmVsYXRpb25lbmQgb2YgdGhlcyBmb3IgdGhlIGF1dGhvcml6ZWRyZWZ1c2VkIHRvdGFrZSBwbGFjZWF1dG9ub21vdXNjb21wcm9taXNlcG9saXRpY2FsIHJlc3RhdXJhbnR0d28gb2YgdGhlRmVicnVhcnkgMnF1YWxpdHkgb2Zzd2ZvYmplY3QudW5kZXJzdGFuZG5lYXJseSBhbGx3cml0dGVuIGJ5aW50ZXJ2aWV3cyIgd2lkdGg9IjF3aXRoZHJhd2FsZmxvYXQ6bGVmdGlzIHVzdWFsbHljYW5kaWRhdGVzbmV3c3BhcGVyc215c3RlcmlvdXNEZXBhcnRtZW50YmVzdCBrbm93bnBhcmxpYW1lbnRzdXBwcmVzc2VkY29udmVuaWVudHJlbWVtYmVyZWRkaWZmZXJlbnQgc3lzdGVtYXRpY2hhcyBsZWQgdG9wcm9wYWdhbmRhY29udHJvbGxlZGluZmx1ZW5jZXNjZXJlbW9uaWFscHJvY2xhaW1lZFByb3RlY3Rpb25saSBjbGFzcz0iU2NpZW50aWZpY2NsYXNzPSJuby10cmFkZW1hcmtzbW9yZSB0aGFuIHdpZGVzcHJlYWRMaWJlcmF0aW9udG9vayBwbGFjZWRheSBvZiB0aGVhcyBsb25nIGFzaW1wcmlzb25lZEFkZGl0aW9uYWwKPGhlYWQ+CjxtTGFib3JhdG9yeU5vdmVtYmVyIDJleGNlcHRpb25zSW5kdXN0cmlhbHZhcmlldHkgb2ZmbG9hdDogbGVmRHVyaW5nIHRoZWFzc2Vzc21lbnRoYXZlIGJlZW4gZGVhbHMgd2l0aFN0YXRpc3RpY3NvY2N1cnJlbmNlL3VsPjwvZGl2PmNsZWFyZml4Ij50aGUgcHVibGljbWFueSB5ZWFyc3doaWNoIHdlcmVvdmVyIHRpbWUsc3lub255bW91c2NvbnRlbnQiPgpwcmVzdW1hYmx5aGlzIGZhbWlseXVzZXJBZ2VudC51bmV4cGVjdGVkaW5jbHVkaW5nIGNoYWxsZW5nZWRhIG1pbm9yaXR5dW5kZWZpbmVkImJlbG9uZ3MgdG90YWtlbiBmcm9taW4gT2N0b2JlcnBvc2l0aW9uOiBzYWlkIHRvIGJlcmVsaWdpb3VzIEZlZGVyYXRpb24gcm93c3Bhbj0ib25seSBhIGZld21lYW50IHRoYXRsZWQgdG8gdGhlLS0+DQo8ZGl2IDxmaWVsZHNldD5BcmNoYmlzaG9wIGNsYXNzPSJub2JlaW5nIHVzZWRhcHByb2FjaGVzcHJpdmlsZWdlc25vc2NyaXB0PgpyZXN1bHRzIGlubWF5IGJlIHRoZUVhc3RlciBlZ2dtZWNoYW5pc21zcmVhc29uYWJsZVBvcHVsYXRpb25Db2xsZWN0aW9uc2VsZWN0ZWQiPm5vc2NyaXB0Pg0vaW5kZXgucGhwYXJyaXZhbCBvZi1qc3NkaycpKTttYW5hZ2VkIHRvaW5jb21wbGV0ZWNhc3VhbHRpZXNjb21wbGV0aW9uQ2hyaXN0aWFuc1NlcHRlbWJlciBhcml0aG1ldGljcHJvY2VkdXJlc21pZ2h0IGhhdmVQcm9kdWN0aW9uaXQgYXBwZWFyc1BoaWxvc29waHlmcmllbmRzaGlwbGVhZGluZyB0b2dpdmluZyB0aGV0b3dhcmQgdGhlZ3VhcmFudGVlZGRvY3VtZW50ZWRjb2xvcjojMDAwdmlkZW8gZ2FtZWNvbW1pc3Npb25yZWZsZWN0aW5nY2hhbmdlIHRoZWFzc29jaWF0ZWRzYW5zLXNlcmlmb25rZXlwcmVzczsgcGFkZGluZzpIZSB3YXMgdGhldW5kZXJseWluZ3R5cGljYWxseSAsIGFuZCB0aGUgc3JjRWxlbWVudHN1Y2Nlc3NpdmVzaW5jZSB0aGUgc2hvdWxkIGJlIG5ldHdvcmtpbmdhY2NvdW50aW5ndXNlIG9mIHRoZWxvd2VyIHRoYW5zaG93cyB0aGF0PC9zcGFuPgoJCWNvbXBsYWludHNjb250aW51b3VzcXVhbnRpdGllc2FzdHJvbm9tZXJoZSBkaWQgbm90ZHVlIHRvIGl0c2FwcGxpZWQgdG9hbiBhdmVyYWdlZWZmb3J0cyB0b3RoZSBmdXR1cmVhdHRlbXB0IHRvVGhlcmVmb3JlLGNhcGFiaWxpdHlSZXB1YmxpY2Fud2FzIGZvcm1lZEVsZWN0cm9uaWNraWxvbWV0ZXJzY2hhbGxlbmdlc3B1Ymxpc2hpbmd0aGUgZm9ybWVyaW5kaWdlbm91c2RpcmVjdGlvbnNzdWJzaWRpYXJ5Y29uc3BpcmFjeWRldGFpbHMgb2ZhbmQgaW4gdGhlYWZmb3JkYWJsZXN1YnN0YW5jZXNyZWFzb24gZm9yY29udmVudGlvbml0ZW10eXBlPSJhYnNvbHV0ZWx5c3VwcG9zZWRseXJlbWFpbmVkIGFhdHRyYWN0aXZldHJhdmVsbGluZ3NlcGFyYXRlbHlmb2N1c2VzIG9uZWxlbWVudGFyeWFwcGxpY2FibGVmb3VuZCB0aGF0c3R5bGVzaGVldG1hbnVzY3JpcHRzdGFuZHMgZm9yIG5vLXJlcGVhdChzb21ldGltZXNDb21tZXJjaWFsaW4gQW1lcmljYXVuZGVydGFrZW5xdWFydGVyIG9mYW4gZXhhbXBsZXBlcnNvbmFsbHlpbmRleC5waHA/PC9idXR0b24+CnBlcmNlbnRhZ2ViZXN0LWtub3duY3JlYXRpbmcgYSIgZGlyPSJsdHJMaWV1dGVuYW50CjxkaXYgaWQ9InRoZXkgd291bGRhYmlsaXR5IG9mbWFkZSB1cCBvZm5vdGVkIHRoYXRjbGVhciB0aGF0YXJndWUgdGhhdHRvIGFub3RoZXJjaGlsZHJlbidzcHVycG9zZSBvZmZvcm11bGF0ZWRiYXNlZCB1cG9udGhlIHJlZ2lvbnN1YmplY3Qgb2ZwYXNzZW5nZXJzcG9zc2Vzc2lvbi4KCkluIHRoZSBCZWZvcmUgdGhlYWZ0ZXJ3YXJkc2N1cnJlbnRseSBhY3Jvc3MgdGhlc2NpZW50aWZpY2NvbW11bml0eS5jYXBpdGFsaXNtaW4gR2VybWFueXJpZ2h0LXdpbmd0aGUgc3lzdGVtU29jaWV0eSBvZnBvbGl0aWNpYW5kaXJlY3Rpb246d2VudCBvbiB0b3JlbW92YWwgb2YgTmV3IFlvcmsgYXBhcnRtZW50c2luZGljYXRpb25kdXJpbmcgdGhldW5sZXNzIHRoZWhpc3RvcmljYWxoYWQgYmVlbiBhZGVmaW5pdGl2ZWluZ3JlZGllbnRhdHRlbmRhbmNlQ2VudGVyIGZvcnByb21pbmVuY2VyZWFkeVN0YXRlc3RyYXRlZ2llc2J1dCBpbiB0aGVhcyBwYXJ0IG9mY29uc3RpdHV0ZWNsYWltIHRoYXRsYWJvcmF0b3J5Y29tcGF0aWJsZWZhaWx1cmUgb2YsIHN1Y2ggYXMgYmVnYW4gd2l0aHVzaW5nIHRoZSB0byBwcm92aWRlZmVhdHVyZSBvZmZyb20gd2hpY2gvIiBjbGFzcz0iZ2VvbG9naWNhbHNldmVyYWwgb2ZkZWxpYmVyYXRlaW1wb3J0YW50IGhvbGRzIHRoYXRpbmcmcXVvdDsgdmFsaWduPXRvcHRoZSBHZXJtYW5vdXRzaWRlIG9mbmVnb3RpYXRlZGhpcyBjYXJlZXJzZXBhcmF0aW9uaWQ9InNlYXJjaHdhcyBjYWxsZWR0aGUgZm91cnRocmVjcmVhdGlvbm90aGVyIHRoYW5wcmV2ZW50aW9ud2hpbGUgdGhlIGVkdWNhdGlvbixjb25uZWN0aW5nYWNjdXJhdGVseXdlcmUgYnVpbHR3YXMga2lsbGVkYWdyZWVtZW50c211Y2ggbW9yZSBEdWUgdG8gdGhld2lkdGg6IDEwMHNvbWUgb3RoZXJLaW5nZG9tIG9mdGhlIGVudGlyZWZhbW91cyBmb3J0byBjb25uZWN0b2JqZWN0aXZlc3RoZSBGcmVuY2hwZW9wbGUgYW5kZmVhdHVyZWQiPmlzIHNhaWQgdG9zdHJ1Y3R1cmFscmVmZXJlbmR1bW1vc3Qgb2Z0ZW5hIHNlcGFyYXRlLT4KPGRpdiBpZCBPZmZpY2lhbCB3b3JsZHdpZGUuYXJpYS1sYWJlbHRoZSBwbGFuZXRhbmQgaXQgd2FzZCIgdmFsdWU9Imxvb2tpbmcgYXRiZW5lZmljaWFsYXJlIGluIHRoZW1vbml0b3JpbmdyZXBvcnRlZGx5dGhlIG1vZGVybndvcmtpbmcgb25hbGxvd2VkIHRvd2hlcmUgdGhlIGlubm92YXRpdmU8L2E+PC9kaXY+c291bmR0cmFja3NlYXJjaEZvcm10ZW5kIHRvIGJlaW5wdXQgaWQ9Im9wZW5pbmcgb2ZyZXN0cmljdGVkYWRvcHRlZCBieWFkZHJlc3Npbmd0aGVvbG9naWFubWV0aG9kcyBvZnZhcmlhbnQgb2ZDaHJpc3RpYW4gdmVyeSBsYXJnZWF1dG9tb3RpdmVieSBmYXIgdGhlcmFuZ2UgZnJvbXB1cnN1aXQgb2Zmb2xsb3cgdGhlYnJvdWdodCB0b2luIEVuZ2xhbmRhZ3JlZSB0aGF0YWNjdXNlZCBvZmNvbWVzIGZyb21wcmV2ZW50aW5nZGl2IHN0eWxlPWhpcyBvciBoZXJ0cmVtZW5kb3VzZnJlZWRvbSBvZmNvbmNlcm5pbmcwIDFlbSAxZW07QmFza2V0YmFsbC9zdHlsZS5jc3NhbiBlYXJsaWVyZXZlbiBhZnRlci8iIHRpdGxlPSIuY29tL2luZGV4dGFraW5nIHRoZXBpdHRzYnVyZ2hjb250ZW50Ij4NPHNjcmlwdD4oZnR1cm5lZCBvdXRoYXZpbmcgdGhlPC9zcGFuPg0KIG9jY2FzaW9uYWxiZWNhdXNlIGl0c3RhcnRlZCB0b3BoeXNpY2FsbHk+PC9kaXY+CiAgY3JlYXRlZCBieUN1cnJlbnRseSwgYmdjb2xvcj0idGFiaW5kZXg9ImRpc2FzdHJvdXNBbmFseXRpY3MgYWxzbyBoYXMgYT48ZGl2IGlkPSI8L3N0eWxlPgo8Y2FsbGVkIGZvcnNpbmdlciBhbmQuc3JjID0gIi8vdmlvbGF0aW9uc3RoaXMgcG9pbnRjb25zdGFudGx5aXMgbG9jYXRlZHJlY29yZGluZ3NkIGZyb20gdGhlbmVkZXJsYW5kc3BvcnR1Z3XDqnPXoteR16jXmdeq2YHYp9ix2LPbjGRlc2Fycm9sbG9jb21lbnRhcmlvZWR1Y2FjacOzbnNlcHRpZW1icmVyZWdpc3RyYWRvZGlyZWNjacOzbnViaWNhY2nDs25wdWJsaWNpZGFkcmVzcHVlc3Rhc3Jlc3VsdGFkb3NpbXBvcnRhbnRlcmVzZXJ2YWRvc2FydMOtY3Vsb3NkaWZlcmVudGVzc2lndWllbnRlc3JlcMO6YmxpY2FzaXR1YWNpw7NubWluaXN0ZXJpb3ByaXZhY2lkYWRkaXJlY3RvcmlvZm9ybWFjacOzbnBvYmxhY2nDs25wcmVzaWRlbnRlY29udGVuaWRvc2FjY2Vzb3Jpb3N0ZWNobm9yYXRpcGVyc29uYWxlc2NhdGVnb3LDrWFlc3BlY2lhbGVzZGlzcG9uaWJsZWFjdHVhbGlkYWRyZWZlcmVuY2lhdmFsbGFkb2xpZGJpYmxpb3RlY2FyZWxhY2lvbmVzY2FsZW5kYXJpb3BvbMOtdGljYXNhbnRlcmlvcmVzZG9jdW1lbnRvc25hdHVyYWxlemFtYXRlcmlhbGVzZGlmZXJlbmNpYWVjb27Ds21pY2F0cmFuc3BvcnRlcm9kcsOtZ3VlenBhcnRpY2lwYXJlbmN1ZW50cmFuZGlzY3VzacOzbmVzdHJ1Y3R1cmFmdW5kYWNpw7NuZnJlY3VlbnRlc3Blcm1hbmVudGV0b3RhbG1lbnRl0LzQvtC20L3QvtCx0YPQtNC10YLQvNC+0LbQtdGC0LLRgNC10LzRj9GC0LDQutC20LXRh9GC0L7QsdGL0LHQvtC70LXQtdC+0YfQtdC90YzRjdGC0L7Qs9C+0LrQvtCz0LTQsNC/0L7RgdC70LXQstGB0LXQs9C+0YHQsNC50YLQtdGH0LXRgNC10LfQvNC+0LPRg9GC0YHQsNC50YLQsNC20LjQt9C90LjQvNC10LbQtNGD0LHRg9C00YPRgtCf0L7QuNGB0LrQt9C00LXRgdGM0LLQuNC00LXQvtGB0LLRj9C30LjQvdGD0LbQvdC+0YHQstC+0LXQudC70Y7QtNC10LnQv9C+0YDQvdC+0LzQvdC+0LPQvtC00LXRgtC10LnRgdCy0L7QuNGF0L/RgNCw0LLQsNGC0LDQutC+0LnQvNC10YHRgtC+0LjQvNC10LXRgtC20LjQt9C90YzQvtC00L3QvtC50LvRg9GH0YjQtdC/0LXRgNC10LTRh9Cw0YHRgtC40YfQsNGB0YLRjNGA0LDQsdC+0YLQvdC+0LLRi9GF0L/RgNCw0LLQvtGB0L7QsdC+0LnQv9C+0YLQvtC80LzQtdC90LXQtdGH0LjRgdC70LXQvdC+0LLRi9C10YPRgdC70YPQs9C+0LrQvtC70L7QvdCw0LfQsNC00YLQsNC60L7QtdGC0L7Qs9C00LDQv9C+0YfRgtC40J/QvtGB0LvQtdGC0LDQutC40LXQvdC+0LLRi9C50YHRgtC+0LjRgtGC0LDQutC40YXRgdGA0LDQt9GD0KHQsNC90LrRgtGE0L7RgNGD0LzQmtC+0LPQtNCw0LrQvdC40LPQuNGB0LvQvtCy0LDQvdCw0YjQtdC50L3QsNC50YLQuNGB0LLQvtC40LzRgdCy0Y/Qt9GM0LvRjtCx0L7QudGH0LDRgdGC0L7RgdGA0LXQtNC40JrRgNC+0LzQtdCk0L7RgNGD0LzRgNGL0L3QutC10YHRgtCw0LvQuNC/0L7QuNGB0LrRgtGL0YHRj9GH0LzQtdGB0Y/RhtGG0LXQvdGC0YDRgtGA0YPQtNCw0YHQsNC80YvRhdGA0YvQvdC60LDQndC+0LLRi9C50YfQsNGB0L7QstC80LXRgdGC0LDRhNC40LvRjNC80LzQsNGA0YLQsNGB0YLRgNCw0L3QvNC10YHRgtC10YLQtdC60YHRgtC90LDRiNC40YXQvNC40L3Rg9GC0LjQvNC10L3QuNC40LzQtdGO0YLQvdC+0LzQtdGA0LPQvtGA0L7QtNGB0LDQvNC+0LzRjdGC0L7QvNGD0LrQvtC90YbQtdGB0LLQvtC10LzQutCw0LrQvtC50JDRgNGF0LjQstmF2YbYqtiv2YnYpdix2LPYp9mE2LHYs9in2YTYqdin2YTYudin2YXZg9iq2KjZh9in2KjYsdin2YXYrNin2YTZitmI2YXYp9mE2LXZiNix2KzYr9mK2K/Yqdin2YTYudi22YjYpdi22KfZgdip2KfZhNmC2LPZhdin2YTYudin2KjYqtit2YXZitmE2YXZhNmB2KfYqtmF2YTYqtmC2YnYqti52K/ZitmE2KfZhNi02LnYsdij2K7YqNin2LHYqti32YjZitix2LnZhNmK2YPZhdil2LHZgdin2YLYt9mE2KjYp9iq2KfZhNmE2LrYqdiq2LHYqtmK2KjYp9mE2YbYp9iz2KfZhNi02YrYrtmF2YbYqtiv2YrYp9mE2LnYsdio2KfZhNmC2LXYtdin2YHZhNin2YXYudmE2YrZh9in2KrYrdiv2YrYq9in2YTZhNmH2YXYp9mE2LnZhdmE2YXZg9iq2KjYqdmK2YXZg9mG2YPYp9mE2LfZgdmE2YHZitiv2YrZiNil2K/Yp9ix2KnYqtin2LHZitiu2KfZhNi12K3Yqdiq2LPYrNmK2YTYp9mE2YjZgtiq2LnZhtiv2YXYp9mF2K/ZitmG2KnYqti12YXZitmF2KPYsdi02YrZgdin2YTYsNmK2YbYudix2KjZitip2KjZiNin2KjYqdij2YTYudin2KjYp9mE2LPZgdix2YXYtNin2YPZhNiq2LnYp9mE2YnYp9mE2KPZiNmE2KfZhNiz2YbYqdis2KfZhdi52KnYp9mE2LXYrdmB2KfZhNiv2YrZhtmD2YTZhdin2KrYp9mE2K7Yp9i12KfZhNmF2YTZgdij2LnYttin2KHZg9iq2KfYqNip2KfZhNiu2YrYsdix2LPYp9im2YTYp9mE2YLZhNio2KfZhNij2K/YqNmF2YLYp9i32LnZhdix2KfYs9mE2YXZhti32YLYqdin2YTZg9iq2KjYp9mE2LHYrNmE2KfYtNiq2LHZg9in2YTZgtiv2YXZiti52LfZitmDc0J5VGFnTmFtZSguanBnIiBhbHQ9IjFweCBzb2xpZCAjLmdpZiIgYWx0PSJ0cmFuc3BhcmVudGluZm9ybWF0aW9uYXBwbGljYXRpb24iIG9uY2xpY2s9ImVzdGFibGlzaGVkYWR2ZXJ0aXNpbmcucG5nIiBhbHQ9ImVudmlyb25tZW50cGVyZm9ybWFuY2VhcHByb3ByaWF0ZSZhbXA7bWRhc2g7aW1tZWRpYXRlbHk8L3N0cm9uZz48L3JhdGhlciB0aGFudGVtcGVyYXR1cmVkZXZlbG9wbWVudGNvbXBldGl0aW9ucGxhY2Vob2xkZXJ2aXNpYmlsaXR5OmNvcHlyaWdodCI+MCIgaGVpZ2h0PSJldmVuIHRob3VnaHJlcGxhY2VtZW50ZGVzdGluYXRpb25Db3Jwb3JhdGlvbjx1bCBjbGFzcz0iQXNzb2NpYXRpb25pbmRpdmlkdWFsc3BlcnNwZWN0aXZlc2V0VGltZW91dCh1cmwoaHR0cDovL21hdGhlbWF0aWNzbWFyZ2luLXRvcDpldmVudHVhbGx5IGRlc2NyaXB0aW9uKSBuby1yZXBlYXRjb2xsZWN0aW9ucy5KUEd8dGh1bWJ8cGFydGljaXBhdGUvaGVhZD48Ym9keWZsb2F0OmxlZnQ7PGxpIGNsYXNzPSJodW5kcmVkcyBvZgoKSG93ZXZlciwgY29tcG9zaXRpb25jbGVhcjpib3RoO2Nvb3BlcmF0aW9ud2l0aGluIHRoZSBsYWJlbCBmb3I9ImJvcmRlci10b3A6TmV3IFplYWxhbmRyZWNvbW1lbmRlZHBob3RvZ3JhcGh5aW50ZXJlc3RpbmcmbHQ7c3VwJmd0O2NvbnRyb3ZlcnN5TmV0aGVybGFuZHNhbHRlcm5hdGl2ZW1heGxlbmd0aD0ic3dpdHplcmxhbmREZXZlbG9wbWVudGVzc2VudGlhbGx5CgpBbHRob3VnaCA8L3RleHRhcmVhPnRodW5kZXJiaXJkcmVwcmVzZW50ZWQmYW1wO25kYXNoO3NwZWN1bGF0aW9uY29tbXVuaXRpZXNsZWdpc2xhdGlvbmVsZWN0cm9uaWNzCgk8ZGl2IGlkPSJpbGx1c3RyYXRlZGVuZ2luZWVyaW5ndGVycml0b3JpZXNhdXRob3JpdGllc2Rpc3RyaWJ1dGVkNiIgaGVpZ2h0PSJzYW5zLXNlcmlmO2NhcGFibGUgb2YgZGlzYXBwZWFyZWRpbnRlcmFjdGl2ZWxvb2tpbmcgZm9yaXQgd291bGQgYmVBZmdoYW5pc3RhbndhcyBjcmVhdGVkTWF0aC5mbG9vcihzdXJyb3VuZGluZ2NhbiBhbHNvIGJlb2JzZXJ2YXRpb25tYWludGVuYW5jZWVuY291bnRlcmVkPGgyIGNsYXNzPSJtb3JlIHJlY2VudGl0IGhhcyBiZWVuaW52YXNpb24gb2YpLmdldFRpbWUoKWZ1bmRhbWVudGFsRGVzcGl0ZSB0aGUiPjxkaXYgaWQ9Imluc3BpcmF0aW9uZXhhbWluYXRpb25wcmVwYXJhdGlvbmV4cGxhbmF0aW9uPGlucHV0IGlkPSI8L2E+PC9zcGFuPnZlcnNpb25zIG9maW5zdHJ1bWVudHNiZWZvcmUgdGhlICA9ICdodHRwOi8vRGVzY3JpcHRpb25yZWxhdGl2ZWx5IC5zdWJzdHJpbmcoZWFjaCBvZiB0aGVleHBlcmltZW50c2luZmx1ZW50aWFsaW50ZWdyYXRpb25tYW55IHBlb3BsZWR1ZSB0byB0aGUgY29tYmluYXRpb25kbyBub3QgaGF2ZU1pZGRsZSBFYXN0PG5vc2NyaXB0Pjxjb3B5cmlnaHQiIHBlcmhhcHMgdGhlaW5zdGl0dXRpb25pbiBEZWNlbWJlcmFycmFuZ2VtZW50bW9zdCBmYW1vdXNwZXJzb25hbGl0eWNyZWF0aW9uIG9mbGltaXRhdGlvbnNleGNsdXNpdmVseXNvdmVyZWlnbnR5LWNvbnRlbnQiPgo8dGQgY2xhc3M9InVuZGVyZ3JvdW5kcGFyYWxsZWwgdG9kb2N0cmluZSBvZm9jY3VwaWVkIGJ5dGVybWlub2xvZ3lSZW5haXNzYW5jZWEgbnVtYmVyIG9mc3VwcG9ydCBmb3JleHBsb3JhdGlvbnJlY29nbml0aW9ucHJlZGVjZXNzb3I8aW1nIHNyYz0iLzxoMSBjbGFzcz0icHVibGljYXRpb25tYXkgYWxzbyBiZXNwZWNpYWxpemVkPC9maWVsZHNldD5wcm9ncmVzc2l2ZW1pbGxpb25zIG9mc3RhdGVzIHRoYXRlbmZvcmNlbWVudGFyb3VuZCB0aGUgb25lIGFub3RoZXIucGFyZW50Tm9kZWFncmljdWx0dXJlQWx0ZXJuYXRpdmVyZXNlYXJjaGVyc3Rvd2FyZHMgdGhlTW9zdCBvZiB0aGVtYW55IG90aGVyIChlc3BlY2lhbGx5PHRkIHdpZHRoPSI7d2lkdGg6MTAwJWluZGVwZW5kZW50PGgzIGNsYXNzPSIgb25jaGFuZ2U9IikuYWRkQ2xhc3MoaW50ZXJhY3Rpb25PbmUgb2YgdGhlIGRhdWdodGVyIG9mYWNjZXNzb3JpZXNicmFuY2hlcyBvZg0KPGRpdiBpZD0idGhlIGxhcmdlc3RkZWNsYXJhdGlvbnJlZ3VsYXRpb25zSW5mb3JtYXRpb250cmFuc2xhdGlvbmRvY3VtZW50YXJ5aW4gb3JkZXIgdG8iPgo8aGVhZD4KPCIgaGVpZ2h0PSIxYWNyb3NzIHRoZSBvcmllbnRhdGlvbik7PC9zY3JpcHQ+aW1wbGVtZW50ZWRjYW4gYmUgc2VlbnRoZXJlIHdhcyBhZGVtb25zdHJhdGVjb250YWluZXIiPmNvbm5lY3Rpb25zdGhlIEJyaXRpc2h3YXMgd3JpdHRlbiFpbXBvcnRhbnQ7cHg7IG1hcmdpbi1mb2xsb3dlZCBieWFiaWxpdHkgdG8gY29tcGxpY2F0ZWRkdXJpbmcgdGhlIGltbWlncmF0aW9uYWxzbyBjYWxsZWQ8aDQgY2xhc3M9ImRpc3RpbmN0aW9ucmVwbGFjZWQgYnlnb3Zlcm5tZW50c2xvY2F0aW9uIG9maW4gTm92ZW1iZXJ3aGV0aGVyIHRoZTwvcD4KPC9kaXY+YWNxdWlzaXRpb25jYWxsZWQgdGhlIHBlcnNlY3V0aW9uZGVzaWduYXRpb257Zm9udC1zaXplOmFwcGVhcmVkIGluaW52ZXN0aWdhdGVleHBlcmllbmNlZG1vc3QgbGlrZWx5d2lkZWx5IHVzZWRkaXNjdXNzaW9uc3ByZXNlbmNlIG9mIChkb2N1bWVudC5leHRlbnNpdmVseUl0IGhhcyBiZWVuaXQgZG9lcyBub3Rjb250cmFyeSB0b2luaGFiaXRhbnRzaW1wcm92ZW1lbnRzY2hvbGFyc2hpcGNvbnN1bXB0aW9uaW5zdHJ1Y3Rpb25mb3IgZXhhbXBsZW9uZSBvciBtb3JlcHg7IHBhZGRpbmd0aGUgY3VycmVudGEgc2VyaWVzIG9mYXJlIHVzdWFsbHlyb2xlIGluIHRoZXByZXZpb3VzbHkgZGVyaXZhdGl2ZXNldmlkZW5jZSBvZmV4cGVyaWVuY2VzY29sb3JzY2hlbWVzdGF0ZWQgdGhhdGNlcnRpZmljYXRlPC9hPjwvZGl2Pgogc2VsZWN0ZWQ9ImhpZ2ggc2Nob29scmVzcG9uc2UgdG9jb21mb3J0YWJsZWFkb3B0aW9uIG9mdGhyZWUgeWVhcnN0aGUgY291bnRyeWluIEZlYnJ1YXJ5c28gdGhhdCB0aGVwZW9wbGUgd2hvIHByb3ZpZGVkIGJ5PHBhcmFtIG5hbWVhZmZlY3RlZCBieWluIHRlcm1zIG9mYXBwb2ludG1lbnRJU08tODg1OS0xIndhcyBib3JuIGluaGlzdG9yaWNhbCByZWdhcmRlZCBhc21lYXN1cmVtZW50aXMgYmFzZWQgb24gYW5kIG90aGVyIDogZnVuY3Rpb24oc2lnbmlmaWNhbnRjZWxlYnJhdGlvbnRyYW5zbWl0dGVkL2pzL2pxdWVyeS5pcyBrbm93biBhc3RoZW9yZXRpY2FsIHRhYmluZGV4PSJpdCBjb3VsZCBiZTxub3NjcmlwdD4KaGF2aW5nIGJlZW4NCjxoZWFkPg0KPCAmcXVvdDtUaGUgY29tcGlsYXRpb25oZSBoYWQgYmVlbnByb2R1Y2VkIGJ5cGhpbG9zb3BoZXJjb25zdHJ1Y3RlZGludGVuZGVkIHRvYW1vbmcgb3RoZXJjb21wYXJlZCB0b3RvIHNheSB0aGF0RW5naW5lZXJpbmdhIGRpZmZlcmVudHJlZmVycmVkIHRvZGlmZmVyZW5jZXNiZWxpZWYgdGhhdHBob3RvZ3JhcGhzaWRlbnRpZnlpbmdIaXN0b3J5IG9mIFJlcHVibGljIG9mbmVjZXNzYXJpbHlwcm9iYWJpbGl0eXRlY2huaWNhbGx5bGVhdmluZyB0aGVzcGVjdGFjdWxhcmZyYWN0aW9uIG9mZWxlY3RyaWNpdHloZWFkIG9mIHRoZXJlc3RhdXJhbnRzcGFydG5lcnNoaXBlbXBoYXNpcyBvbm1vc3QgcmVjZW50c2hhcmUgd2l0aCBzYXlpbmcgdGhhdGZpbGxlZCB3aXRoZGVzaWduZWQgdG9pdCBpcyBvZnRlbiI+PC9pZnJhbWU+YXMgZm9sbG93czptZXJnZWQgd2l0aHRocm91Z2ggdGhlY29tbWVyY2lhbCBwb2ludGVkIG91dG9wcG9ydHVuaXR5dmlldyBvZiB0aGVyZXF1aXJlbWVudGRpdmlzaW9uIG9mcHJvZ3JhbW1pbmdoZSByZWNlaXZlZHNldEludGVydmFsIj48L3NwYW4+PC9pbiBOZXcgWW9ya2FkZGl0aW9uYWwgY29tcHJlc3Npb24KCjxkaXYgaWQ9ImluY29ycG9yYXRlOzwvc2NyaXB0PjxhdHRhY2hFdmVudGJlY2FtZSB0aGUgIiB0YXJnZXQ9Il9jYXJyaWVkIG91dFNvbWUgb2YgdGhlc2NpZW5jZSBhbmR0aGUgdGltZSBvZkNvbnRhaW5lciI+bWFpbnRhaW5pbmdDaHJpc3RvcGhlck11Y2ggb2YgdGhld3JpdGluZ3Mgb2YiIGhlaWdodD0iMnNpemUgb2YgdGhldmVyc2lvbiBvZiBtaXh0dXJlIG9mIGJldHdlZW4gdGhlRXhhbXBsZXMgb2ZlZHVjYXRpb25hbGNvbXBldGl0aXZlIG9uc3VibWl0PSJkaXJlY3RvciBvZmRpc3RpbmN0aXZlL0RURCBYSFRNTCByZWxhdGluZyB0b3RlbmRlbmN5IHRvcHJvdmluY2Ugb2Z3aGljaCB3b3VsZGRlc3BpdGUgdGhlc2NpZW50aWZpYyBsZWdpc2xhdHVyZS5pbm5lckhUTUwgYWxsZWdhdGlvbnNBZ3JpY3VsdHVyZXdhcyB1c2VkIGluYXBwcm9hY2ggdG9pbnRlbGxpZ2VudHllYXJzIGxhdGVyLHNhbnMtc2VyaWZkZXRlcm1pbmluZ1BlcmZvcm1hbmNlYXBwZWFyYW5jZXMsIHdoaWNoIGlzIGZvdW5kYXRpb25zYWJicmV2aWF0ZWRoaWdoZXIgdGhhbnMgZnJvbSB0aGUgaW5kaXZpZHVhbCBjb21wb3NlZCBvZnN1cHBvc2VkIHRvY2xhaW1zIHRoYXRhdHRyaWJ1dGlvbmZvbnQtc2l6ZToxZWxlbWVudHMgb2ZIaXN0b3JpY2FsIGhpcyBicm90aGVyYXQgdGhlIHRpbWVhbm5pdmVyc2FyeWdvdmVybmVkIGJ5cmVsYXRlZCB0byB1bHRpbWF0ZWx5IGlubm92YXRpb25zaXQgaXMgc3RpbGxjYW4gb25seSBiZWRlZmluaXRpb25zdG9HTVRTdHJpbmdBIG51bWJlciBvZmltZyBjbGFzcz0iRXZlbnR1YWxseSx3YXMgY2hhbmdlZG9jY3VycmVkIGlubmVpZ2hib3JpbmdkaXN0aW5ndWlzaHdoZW4gaGUgd2FzaW50cm9kdWNpbmd0ZXJyZXN0cmlhbE1hbnkgb2YgdGhlYXJndWVzIHRoYXRhbiBBbWVyaWNhbmNvbnF1ZXN0IG9md2lkZXNwcmVhZCB3ZXJlIGtpbGxlZHNjcmVlbiBhbmQgSW4gb3JkZXIgdG9leHBlY3RlZCB0b2Rlc2NlbmRhbnRzYXJlIGxvY2F0ZWRsZWdpc2xhdGl2ZWdlbmVyYXRpb25zIGJhY2tncm91bmRtb3N0IHBlb3BsZXllYXJzIGFmdGVydGhlcmUgaXMgbm90aGUgaGlnaGVzdGZyZXF1ZW50bHkgdGhleSBkbyBub3Rhcmd1ZWQgdGhhdHNob3dlZCB0aGF0cHJlZG9taW5hbnR0aGVvbG9naWNhbGJ5IHRoZSB0aW1lY29uc2lkZXJpbmdzaG9ydC1saXZlZDwvc3Bhbj48L2E+Y2FuIGJlIHVzZWR2ZXJ5IGxpdHRsZW9uZSBvZiB0aGUgaGFkIGFscmVhZHlpbnRlcnByZXRlZGNvbW11bmljYXRlZmVhdHVyZXMgb2Znb3Zlcm5tZW50LDwvbm9zY3JpcHQ+ZW50ZXJlZCB0aGUiIGhlaWdodD0iM0luZGVwZW5kZW50cG9wdWxhdGlvbnNsYXJnZS1zY2FsZS4gQWx0aG91Z2ggdXNlZCBpbiB0aGVkZXN0cnVjdGlvbnBvc3NpYmlsaXR5c3RhcnRpbmcgaW50d28gb3IgbW9yZWV4cHJlc3Npb25zc3Vib3JkaW5hdGVsYXJnZXIgdGhhbmhpc3RvcnkgYW5kPC9vcHRpb24+DQpDb250aW5lbnRhbGVsaW1pbmF0aW5nd2lsbCBub3QgYmVwcmFjdGljZSBvZmluIGZyb250IG9mc2l0ZSBvZiB0aGVlbnN1cmUgdGhhdHRvIGNyZWF0ZSBhbWlzc2lzc2lwcGlwb3RlbnRpYWxseW91dHN0YW5kaW5nYmV0dGVyIHRoYW53aGF0IGlzIG5vd3NpdHVhdGVkIGlubWV0YSBuYW1lPSJUcmFkaXRpb25hbHN1Z2dlc3Rpb25zVHJhbnNsYXRpb250aGUgZm9ybSBvZmF0bW9zcGhlcmljaWRlb2xvZ2ljYWxlbnRlcnByaXNlc2NhbGN1bGF0aW5nZWFzdCBvZiB0aGVyZW1uYW50cyBvZnBsdWdpbnNwYWdlL2luZGV4LnBocD9yZW1haW5lZCBpbnRyYW5zZm9ybWVkSGUgd2FzIGFsc293YXMgYWxyZWFkeXN0YXRpc3RpY2FsaW4gZmF2b3Igb2ZNaW5pc3RyeSBvZm1vdmVtZW50IG9mZm9ybXVsYXRpb25pcyByZXF1aXJlZDxsaW5rIHJlbD0iVGhpcyBpcyB0aGUgPGEgaHJlZj0iL3BvcHVsYXJpemVkaW52b2x2ZWQgaW5hcmUgdXNlZCB0b2FuZCBzZXZlcmFsbWFkZSBieSB0aGVzZWVtcyB0byBiZWxpa2VseSB0aGF0UGFsZXN0aW5pYW5uYW1lZCBhZnRlcml0IGhhZCBiZWVubW9zdCBjb21tb250byByZWZlciB0b2J1dCB0aGlzIGlzY29uc2VjdXRpdmV0ZW1wb3JhcmlseUluIGdlbmVyYWwsY29udmVudGlvbnN0YWtlcyBwbGFjZXN1YmRpdmlzaW9udGVycml0b3JpYWxvcGVyYXRpb25hbHBlcm1hbmVudGx5d2FzIGxhcmdlbHlvdXRicmVhayBvZmluIHRoZSBwYXN0Zm9sbG93aW5nIGEgeG1sbnM6b2c9Ij48YSBjbGFzcz0iY2xhc3M9InRleHRDb252ZXJzaW9uIG1heSBiZSB1c2VkbWFudWZhY3R1cmVhZnRlciBiZWluZ2NsZWFyZml4Ij4KcXVlc3Rpb24gb2Z3YXMgZWxlY3RlZHRvIGJlY29tZSBhYmVjYXVzZSBvZiBzb21lIHBlb3BsZWluc3BpcmVkIGJ5c3VjY2Vzc2Z1bCBhIHRpbWUgd2hlbm1vcmUgY29tbW9uYW1vbmdzdCB0aGVhbiBvZmZpY2lhbHdpZHRoOjEwMCU7dGVjaG5vbG9neSx3YXMgYWRvcHRlZHRvIGtlZXAgdGhlc2V0dGxlbWVudHNsaXZlIGJpcnRoc2luZGV4Lmh0bWwiQ29ubmVjdGljdXRhc3NpZ25lZCB0byZhbXA7dGltZXM7YWNjb3VudCBmb3JhbGlnbj1yaWdodHRoZSBjb21wYW55YWx3YXlzIGJlZW5yZXR1cm5lZCB0b2ludm9sdmVtZW50QmVjYXVzZSB0aGV0aGlzIHBlcmlvZCIgbmFtZT0icSIgY29uZmluZWQgdG9hIHJlc3VsdCBvZnZhbHVlPSIiIC8+aXMgYWN0dWFsbHlFbnZpcm9ubWVudA0KPC9oZWFkPg0KQ29udmVyc2VseSw+CjxkaXYgaWQ9IjAiIHdpZHRoPSIxaXMgcHJvYmFibHloYXZlIGJlY29tZWNvbnRyb2xsaW5ndGhlIHByb2JsZW1jaXRpemVucyBvZnBvbGl0aWNpYW5zcmVhY2hlZCB0aGVhcyBlYXJseSBhczpub25lOyBvdmVyPHRhYmxlIGNlbGx2YWxpZGl0eSBvZmRpcmVjdGx5IHRvb25tb3VzZWRvd253aGVyZSBpdCBpc3doZW4gaXQgd2FzbWVtYmVycyBvZiByZWxhdGlvbiB0b2FjY29tbW9kYXRlYWxvbmcgd2l0aCBJbiB0aGUgbGF0ZXRoZSBFbmdsaXNoZGVsaWNpb3VzIj50aGlzIGlzIG5vdHRoZSBwcmVzZW50aWYgdGhleSBhcmVhbmQgZmluYWxseWEgbWF0dGVyIG9mDQoJPC9kaXY+DQoNCjwvc2NyaXB0PmZhc3RlciB0aGFubWFqb3JpdHkgb2ZhZnRlciB3aGljaGNvbXBhcmF0aXZldG8gbWFpbnRhaW5pbXByb3ZlIHRoZWF3YXJkZWQgdGhlZXIiIGNsYXNzPSJmcmFtZWJvcmRlcnJlc3RvcmF0aW9uaW4gdGhlIHNhbWVhbmFseXNpcyBvZnRoZWlyIGZpcnN0RHVyaW5nIHRoZSBjb250aW5lbnRhbHNlcXVlbmNlIG9mZnVuY3Rpb24oKXtmb250LXNpemU6IHdvcmsgb24gdGhlPC9zY3JpcHQ+CjxiZWdpbnMgd2l0aGphdmFzY3JpcHQ6Y29uc3RpdHVlbnR3YXMgZm91bmRlZGVxdWlsaWJyaXVtYXNzdW1lIHRoYXRpcyBnaXZlbiBieW5lZWRzIHRvIGJlY29vcmRpbmF0ZXN0aGUgdmFyaW91c2FyZSBwYXJ0IG9mb25seSBpbiB0aGVzZWN0aW9ucyBvZmlzIGEgY29tbW9udGhlb3JpZXMgb2ZkaXNjb3Zlcmllc2Fzc29jaWF0aW9uZWRnZSBvZiB0aGVzdHJlbmd0aCBvZnBvc2l0aW9uIGlucHJlc2VudC1kYXl1bml2ZXJzYWxseXRvIGZvcm0gdGhlYnV0IGluc3RlYWRjb3Jwb3JhdGlvbmF0dGFjaGVkIHRvaXMgY29tbW9ubHlyZWFzb25zIGZvciAmcXVvdDt0aGUgY2FuIGJlIG1hZGV3YXMgYWJsZSB0b3doaWNoIG1lYW5zYnV0IGRpZCBub3Rvbk1vdXNlT3ZlcmFzIHBvc3NpYmxlb3BlcmF0ZWQgYnljb21pbmcgZnJvbXRoZSBwcmltYXJ5YWRkaXRpb24gb2Zmb3Igc2V2ZXJhbHRyYW5zZmVycmVkYSBwZXJpb2Qgb2ZhcmUgYWJsZSB0b2hvd2V2ZXIsIGl0c2hvdWxkIGhhdmVtdWNoIGxhcmdlcgoJPC9zY3JpcHQ+YWRvcHRlZCB0aGVwcm9wZXJ0eSBvZmRpcmVjdGVkIGJ5ZWZmZWN0aXZlbHl3YXMgYnJvdWdodGNoaWxkcmVuIG9mUHJvZ3JhbW1pbmdsb25nZXIgdGhhbm1hbnVzY3JpcHRzd2FyIGFnYWluc3RieSBtZWFucyBvZmFuZCBtb3N0IG9mc2ltaWxhciB0byBwcm9wcmlldGFyeW9yaWdpbmF0aW5ncHJlc3RpZ2lvdXNncmFtbWF0aWNhbGV4cGVyaWVuY2UudG8gbWFrZSB0aGVJdCB3YXMgYWxzb2lzIGZvdW5kIGluY29tcGV0aXRvcnNpbiB0aGUgVS5TLnJlcGxhY2UgdGhlYnJvdWdodCB0aGVjYWxjdWxhdGlvbmZhbGwgb2YgdGhldGhlIGdlbmVyYWxwcmFjdGljYWxseWluIGhvbm9yIG9mcmVsZWFzZWQgaW5yZXNpZGVudGlhbGFuZCBzb21lIG9ma2luZyBvZiB0aGVyZWFjdGlvbiB0bzFzdCBFYXJsIG9mY3VsdHVyZSBhbmRwcmluY2lwYWxseTwvdGl0bGU+CiAgdGhleSBjYW4gYmViYWNrIHRvIHRoZXNvbWUgb2YgaGlzZXhwb3N1cmUgdG9hcmUgc2ltaWxhcmZvcm0gb2YgdGhlYWRkRmF2b3JpdGVjaXRpemVuc2hpcHBhcnQgaW4gdGhlcGVvcGxlIHdpdGhpbiBwcmFjdGljZXRvIGNvbnRpbnVlJmFtcDttaW51czthcHByb3ZlZCBieSB0aGUgZmlyc3QgYWxsb3dlZCB0aGVhbmQgZm9yIHRoZWZ1bmN0aW9uaW5ncGxheWluZyB0aGVzb2x1dGlvbiB0b2hlaWdodD0iMCIgaW4gaGlzIGJvb2ttb3JlIHRoYW4gYWZvbGxvd3MgdGhlY3JlYXRlZCB0aGVwcmVzZW5jZSBpbiZuYnNwOzwvdGQ+bmF0aW9uYWxpc3R0aGUgaWRlYSBvZmEgY2hhcmFjdGVyd2VyZSBmb3JjZWQgY2xhc3M9ImJ0bmRheXMgb2YgdGhlZmVhdHVyZWQgaW5zaG93aW5nIHRoZWludGVyZXN0IGluaW4gcGxhY2Ugb2Z0dXJuIG9mIHRoZXRoZSBoZWFkIG9mTG9yZCBvZiB0aGVwb2xpdGljYWxseWhhcyBpdHMgb3duRWR1Y2F0aW9uYWxhcHByb3ZhbCBvZnNvbWUgb2YgdGhlZWFjaCBvdGhlcixiZWhhdmlvciBvZmFuZCBiZWNhdXNlYW5kIGFub3RoZXJhcHBlYXJlZCBvbnJlY29yZGVkIGluYmxhY2smcXVvdDttYXkgaW5jbHVkZXRoZSB3b3JsZCdzY2FuIGxlYWQgdG9yZWZlcnMgdG8gYWJvcmRlcj0iMCIgZ292ZXJubWVudCB3aW5uaW5nIHRoZXJlc3VsdGVkIGluIHdoaWxlIHRoZSBXYXNoaW5ndG9uLHRoZSBzdWJqZWN0Y2l0eSBpbiB0aGU+PC9kaXY+DQoJCXJlZmxlY3QgdGhldG8gY29tcGxldGViZWNhbWUgbW9yZXJhZGlvYWN0aXZlcmVqZWN0ZWQgYnl3aXRob3V0IGFueWhpcyBmYXRoZXIsd2hpY2ggY291bGRjb3B5IG9mIHRoZXRvIGluZGljYXRlYSBwb2xpdGljYWxhY2NvdW50cyBvZmNvbnN0aXR1dGVzd29ya2VkIHdpdGhlcjwvYT48L2xpPm9mIGhpcyBsaWZlYWNjb21wYW5pZWRjbGllbnRXaWR0aHByZXZlbnQgdGhlTGVnaXNsYXRpdmVkaWZmZXJlbnRseXRvZ2V0aGVyIGluaGFzIHNldmVyYWxmb3IgYW5vdGhlcnRleHQgb2YgdGhlZm91bmRlZCB0aGVlIHdpdGggdGhlIGlzIHVzZWQgZm9yY2hhbmdlZCB0aGV1c3VhbGx5IHRoZXBsYWNlIHdoZXJld2hlcmVhcyB0aGU+IDxhIGhyZWY9IiI+PGEgaHJlZj0idGhlbXNlbHZlcyxhbHRob3VnaCBoZXRoYXQgY2FuIGJldHJhZGl0aW9uYWxyb2xlIG9mIHRoZWFzIGEgcmVzdWx0cmVtb3ZlQ2hpbGRkZXNpZ25lZCBieXdlc3Qgb2YgdGhlU29tZSBwZW9wbGVwcm9kdWN0aW9uLHNpZGUgb2YgdGhlbmV3c2xldHRlcnN1c2VkIGJ5IHRoZWRvd24gdG8gdGhlYWNjZXB0ZWQgYnlsaXZlIGluIHRoZWF0dGVtcHRzIHRvb3V0c2lkZSB0aGVmcmVxdWVuY2llc0hvd2V2ZXIsIGlucHJvZ3JhbW1lcnNhdCBsZWFzdCBpbmFwcHJveGltYXRlYWx0aG91Z2ggaXR3YXMgcGFydCBvZmFuZCB2YXJpb3VzR292ZXJub3Igb2Z0aGUgYXJ0aWNsZXR1cm5lZCBpbnRvPjxhIGhyZWY9Ii90aGUgZWNvbm9teWlzIHRoZSBtb3N0bW9zdCB3aWRlbHl3b3VsZCBsYXRlcmFuZCBwZXJoYXBzcmlzZSB0byB0aGVvY2N1cnMgd2hlbnVuZGVyIHdoaWNoY29uZGl0aW9ucy50aGUgd2VzdGVybnRoZW9yeSB0aGF0aXMgcHJvZHVjZWR0aGUgY2l0eSBvZmluIHdoaWNoIGhlc2VlbiBpbiB0aGV0aGUgY2VudHJhbGJ1aWxkaW5nIG9mbWFueSBvZiBoaXNhcmVhIG9mIHRoZWlzIHRoZSBvbmx5bW9zdCBvZiB0aGVtYW55IG9mIHRoZXRoZSBXZXN0ZXJuVGhlcmUgaXMgbm9leHRlbmRlZCB0b1N0YXRpc3RpY2FsY29sc3Bhbj0yIHxzaG9ydCBzdG9yeXBvc3NpYmxlIHRvdG9wb2xvZ2ljYWxjcml0aWNhbCBvZnJlcG9ydGVkIHRvYSBDaHJpc3RpYW5kZWNpc2lvbiB0b2lzIGVxdWFsIHRvcHJvYmxlbXMgb2ZUaGlzIGNhbiBiZW1lcmNoYW5kaXNlZm9yIG1vc3Qgb2ZubyBldmlkZW5jZWVkaXRpb25zIG9mZWxlbWVudHMgaW4mcXVvdDsuIFRoZWNvbS9pbWFnZXMvd2hpY2ggbWFrZXN0aGUgcHJvY2Vzc3JlbWFpbnMgdGhlbGl0ZXJhdHVyZSxpcyBhIG1lbWJlcnRoZSBwb3B1bGFydGhlIGFuY2llbnRwcm9ibGVtcyBpbnRpbWUgb2YgdGhlZGVmZWF0ZWQgYnlib2R5IG9mIHRoZWEgZmV3IHllYXJzbXVjaCBvZiB0aGV0aGUgd29yayBvZkNhbGlmb3JuaWEsc2VydmVkIGFzIGFnb3Zlcm5tZW50LmNvbmNlcHRzIG9mbW92ZW1lbnQgaW4JCTxkaXYgaWQ9Iml0IiB2YWx1ZT0ibGFuZ3VhZ2Ugb2ZhcyB0aGV5IGFyZXByb2R1Y2VkIGluaXMgdGhhdCB0aGVleHBsYWluIHRoZWRpdj48L2Rpdj4KSG93ZXZlciB0aGVsZWFkIHRvIHRoZQk8YSBocmVmPSIvd2FzIGdyYW50ZWRwZW9wbGUgaGF2ZWNvbnRpbnVhbGx5d2FzIHNlZW4gYXNhbmQgcmVsYXRlZHRoZSByb2xlIG9mcHJvcG9zZWQgYnlvZiB0aGUgYmVzdGVhY2ggb3RoZXIuQ29uc3RhbnRpbmVwZW9wbGUgZnJvbWRpYWxlY3RzIG9mdG8gcmV2aXNpb253YXMgcmVuYW1lZGEgc291cmNlIG9mdGhlIGluaXRpYWxsYXVuY2hlZCBpbnByb3ZpZGUgdGhldG8gdGhlIHdlc3R3aGVyZSB0aGVyZWFuZCBzaW1pbGFyYmV0d2VlbiB0d29pcyBhbHNvIHRoZUVuZ2xpc2ggYW5kY29uZGl0aW9ucyx0aGF0IGl0IHdhc2VudGl0bGVkIHRvdGhlbXNlbHZlcy5xdWFudGl0eSBvZnJhbnNwYXJlbmN5dGhlIHNhbWUgYXN0byBqb2luIHRoZWNvdW50cnkgYW5kdGhpcyBpcyB0aGVUaGlzIGxlZCB0b2Egc3RhdGVtZW50Y29udHJhc3QgdG9sYXN0SW5kZXhPZnRocm91Z2ggaGlzaXMgZGVzaWduZWR0aGUgdGVybSBpc2lzIHByb3ZpZGVkcHJvdGVjdCB0aGVuZzwvYT48L2xpPlRoZSBjdXJyZW50dGhlIHNpdGUgb2ZzdWJzdGFudGlhbGV4cGVyaWVuY2UsaW4gdGhlIFdlc3R0aGV5IHNob3VsZHNsb3ZlbsSNaW5hY29tZW50YXJpb3N1bml2ZXJzaWRhZGNvbmRpY2lvbmVzYWN0aXZpZGFkZXNleHBlcmllbmNpYXRlY25vbG9nw61hcHJvZHVjY2nDs25wdW50dWFjacOzbmFwbGljYWNpw7NuY29udHJhc2XDsWFjYXRlZ29yw61hc3JlZ2lzdHJhcnNlcHJvZmVzaW9uYWx0cmF0YW1pZW50b3JlZ8Otc3RyYXRlc2VjcmV0YXLDrWFwcmluY2lwYWxlc3Byb3RlY2Npw7NuaW1wb3J0YW50ZXNpbXBvcnRhbmNpYXBvc2liaWxpZGFkaW50ZXJlc2FudGVjcmVjaW1pZW50b25lY2VzaWRhZGVzc3VzY3JpYmlyc2Vhc29jaWFjacOzbmRpc3BvbmlibGVzZXZhbHVhY2nDs25lc3R1ZGlhbnRlc3Jlc3BvbnNhYmxlcmVzb2x1Y2nDs25ndWFkYWxhamFyYXJlZ2lzdHJhZG9zb3BvcnR1bmlkYWRjb21lcmNpYWxlc2ZvdG9ncmFmw61hYXV0b3JpZGFkZXNpbmdlbmllcsOtYXRlbGV2aXNpw7NuY29tcGV0ZW5jaWFvcGVyYWNpb25lc2VzdGFibGVjaWRvc2ltcGxlbWVudGVhY3R1YWxtZW50ZW5hdmVnYWNpw7NuY29uZm9ybWlkYWRsaW5lLWhlaWdodDpmb250LWZhbWlseToiIDogImh0dHA6Ly9hcHBsaWNhdGlvbnNsaW5rIiBocmVmPSJzcGVjaWZpY2FsbHkvLzwhW0NEQVRBWwpPcmdhbml6YXRpb25kaXN0cmlidXRpb24wcHg7IGhlaWdodDpyZWxhdGlvbnNoaXBkZXZpY2Utd2lkdGg8ZGl2IGNsYXNzPSI8bGFiZWwgZm9yPSJyZWdpc3RyYXRpb248L25vc2NyaXB0PgovaW5kZXguaHRtbCJ3aW5kb3cub3BlbiggIWltcG9ydGFudDthcHBsaWNhdGlvbi9pbmRlcGVuZGVuY2UvL3d3dy5nb29nbGVvcmdhbml6YXRpb25hdXRvY29tcGxldGVyZXF1aXJlbWVudHNjb25zZXJ2YXRpdmU8Zm9ybSBuYW1lPSJpbnRlbGxlY3R1YWxtYXJnaW4tbGVmdDoxOHRoIGNlbnR1cnlhbiBpbXBvcnRhbnRpbnN0aXR1dGlvbnNhYmJyZXZpYXRpb248aW1nIGNsYXNzPSJvcmdhbmlzYXRpb25jaXZpbGl6YXRpb24xOXRoIGNlbnR1cnlhcmNoaXRlY3R1cmVpbmNvcnBvcmF0ZWQyMHRoIGNlbnR1cnktY29udGFpbmVyIj5tb3N0IG5vdGFibHkvPjwvYT48L2Rpdj5ub3RpZmljYXRpb24ndW5kZWZpbmVkJylGdXJ0aGVybW9yZSxiZWxpZXZlIHRoYXRpbm5lckhUTUwgPSBwcmlvciB0byB0aGVkcmFtYXRpY2FsbHlyZWZlcnJpbmcgdG9uZWdvdGlhdGlvbnNoZWFkcXVhcnRlcnNTb3V0aCBBZnJpY2F1bnN1Y2Nlc3NmdWxQZW5uc3lsdmFuaWFBcyBhIHJlc3VsdCw8aHRtbCBsYW5nPSImbHQ7L3N1cCZndDtkZWFsaW5nIHdpdGhwaGlsYWRlbHBoaWFoaXN0b3JpY2FsbHkpOzwvc2NyaXB0PgpwYWRkaW5nLXRvcDpleHBlcmltZW50YWxnZXRBdHRyaWJ1dGVpbnN0cnVjdGlvbnN0ZWNobm9sb2dpZXNwYXJ0IG9mIHRoZSA9ZnVuY3Rpb24oKXtzdWJzY3JpcHRpb25sLmR0ZCI+DQo8aHRnZW9ncmFwaGljYWxDb25zdGl0dXRpb24nLCBmdW5jdGlvbihzdXBwb3J0ZWQgYnlhZ3JpY3VsdHVyYWxjb25zdHJ1Y3Rpb25wdWJsaWNhdGlvbnNmb250LXNpemU6IDFhIHZhcmlldHkgb2Y8ZGl2IHN0eWxlPSJFbmN5Y2xvcGVkaWFpZnJhbWUgc3JjPSJkZW1vbnN0cmF0ZWRhY2NvbXBsaXNoZWR1bml2ZXJzaXRpZXNEZW1vZ3JhcGhpY3MpOzwvc2NyaXB0PjxkZWRpY2F0ZWQgdG9rbm93bGVkZ2Ugb2ZzYXRpc2ZhY3Rpb25wYXJ0aWN1bGFybHk8L2Rpdj48L2Rpdj5FbmdsaXNoIChVUylhcHBlbmRDaGlsZCh0cmFuc21pc3Npb25zLiBIb3dldmVyLCBpbnRlbGxpZ2VuY2UiIHRhYmluZGV4PSJmbG9hdDpyaWdodDtDb21tb253ZWFsdGhyYW5naW5nIGZyb21pbiB3aGljaCB0aGVhdCBsZWFzdCBvbmVyZXByb2R1Y3Rpb25lbmN5Y2xvcGVkaWE7Zm9udC1zaXplOjFqdXJpc2RpY3Rpb25hdCB0aGF0IHRpbWUiPjxhIGNsYXNzPSJJbiBhZGRpdGlvbixkZXNjcmlwdGlvbitjb252ZXJzYXRpb25jb250YWN0IHdpdGhpcyBnZW5lcmFsbHlyIiBjb250ZW50PSJyZXByZXNlbnRpbmcmbHQ7bWF0aCZndDtwcmVzZW50YXRpb25vY2Nhc2lvbmFsbHk8aW1nIHdpZHRoPSJuYXZpZ2F0aW9uIj5jb21wZW5zYXRpb25jaGFtcGlvbnNoaXBtZWRpYT0iYWxsIiB2aW9sYXRpb24gb2ZyZWZlcmVuY2UgdG9yZXR1cm4gdHJ1ZTtTdHJpY3QvL0VOIiB0cmFuc2FjdGlvbnNpbnRlcnZlbnRpb252ZXJpZmljYXRpb25JbmZvcm1hdGlvbiBkaWZmaWN1bHRpZXNDaGFtcGlvbnNoaXBjYXBhYmlsaXRpZXM8IVtlbmRpZl0tLT59Cjwvc2NyaXB0PgpDaHJpc3RpYW5pdHlmb3IgZXhhbXBsZSxQcm9mZXNzaW9uYWxyZXN0cmljdGlvbnNzdWdnZXN0IHRoYXR3YXMgcmVsZWFzZWQoc3VjaCBhcyB0aGVyZW1vdmVDbGFzcyh1bmVtcGxveW1lbnR0aGUgQW1lcmljYW5zdHJ1Y3R1cmUgb2YvaW5kZXguaHRtbCBwdWJsaXNoZWQgaW5zcGFuIGNsYXNzPSIiPjxhIGhyZWY9Ii9pbnRyb2R1Y3Rpb25iZWxvbmdpbmcgdG9jbGFpbWVkIHRoYXRjb25zZXF1ZW5jZXM8bWV0YSBuYW1lPSJHdWlkZSB0byB0aGVvdmVyd2hlbG1pbmdhZ2FpbnN0IHRoZSBjb25jZW50cmF0ZWQsCi5ub250b3VjaCBvYnNlcnZhdGlvbnM8L2E+CjwvZGl2PgpmIChkb2N1bWVudC5ib3JkZXI6IDFweCB7Zm9udC1zaXplOjF0cmVhdG1lbnQgb2YwIiBoZWlnaHQ9IjFtb2RpZmljYXRpb25JbmRlcGVuZGVuY2VkaXZpZGVkIGludG9ncmVhdGVyIHRoYW5hY2hpZXZlbWVudHNlc3RhYmxpc2hpbmdKYXZhU2NyaXB0IiBuZXZlcnRoZWxlc3NzaWduaWZpY2FuY2VCcm9hZGNhc3Rpbmc+Jm5ic3A7PC90ZD5jb250YWluZXIiPgpzdWNoIGFzIHRoZSBpbmZsdWVuY2Ugb2ZhIHBhcnRpY3VsYXJzcmM9J2h0dHA6Ly9uYXZpZ2F0aW9uIiBoYWxmIG9mIHRoZSBzdWJzdGFudGlhbCAmbmJzcDs8L2Rpdj5hZHZhbnRhZ2Ugb2ZkaXNjb3Zlcnkgb2ZmdW5kYW1lbnRhbCBtZXRyb3BvbGl0YW50aGUgb3Bwb3NpdGUiIHhtbDpsYW5nPSJkZWxpYmVyYXRlbHlhbGlnbj1jZW50ZXJldm9sdXRpb24gb2ZwcmVzZXJ2YXRpb25pbXByb3ZlbWVudHNiZWdpbm5pbmcgaW5KZXN1cyBDaHJpc3RQdWJsaWNhdGlvbnNkaXNhZ3JlZW1lbnR0ZXh0LWFsaWduOnIsIGZ1bmN0aW9uKClzaW1pbGFyaXRpZXNib2R5PjwvaHRtbD5pcyBjdXJyZW50bHlhbHBoYWJldGljYWxpcyBzb21ldGltZXN0eXBlPSJpbWFnZS9tYW55IG9mIHRoZSBmbG93OmhpZGRlbjthdmFpbGFibGUgaW5kZXNjcmliZSB0aGVleGlzdGVuY2Ugb2ZhbGwgb3ZlciB0aGV0aGUgSW50ZXJuZXQJPHVsIGNsYXNzPSJpbnN0YWxsYXRpb25uZWlnaGJvcmhvb2Rhcm1lZCBmb3JjZXNyZWR1Y2luZyB0aGVjb250aW51ZXMgdG9Ob25ldGhlbGVzcyx0ZW1wZXJhdHVyZXMKCQk8YSBocmVmPSJjbG9zZSB0byB0aGVleGFtcGxlcyBvZiBpcyBhYm91dCB0aGUoc2VlIGJlbG93KS4iIGlkPSJzZWFyY2hwcm9mZXNzaW9uYWxpcyBhdmFpbGFibGV0aGUgb2ZmaWNpYWwJCTwvc2NyaXB0PgoKCQk8ZGl2IGlkPSJhY2NlbGVyYXRpb250aHJvdWdoIHRoZSBIYWxsIG9mIEZhbWVkZXNjcmlwdGlvbnN0cmFuc2xhdGlvbnNpbnRlcmZlcmVuY2UgdHlwZT0ndGV4dC9yZWNlbnQgeWVhcnNpbiB0aGUgd29ybGR2ZXJ5IHBvcHVsYXJ7YmFja2dyb3VuZDp0cmFkaXRpb25hbCBzb21lIG9mIHRoZSBjb25uZWN0ZWQgdG9leHBsb2l0YXRpb25lbWVyZ2VuY2Ugb2Zjb25zdGl0dXRpb25BIEhpc3Rvcnkgb2ZzaWduaWZpY2FudCBtYW51ZmFjdHVyZWRleHBlY3RhdGlvbnM+PG5vc2NyaXB0PjxjYW4gYmUgZm91bmRiZWNhdXNlIHRoZSBoYXMgbm90IGJlZW5uZWlnaGJvdXJpbmd3aXRob3V0IHRoZSBhZGRlZCB0byB0aGUJPGxpIGNsYXNzPSJpbnN0cnVtZW50YWxTb3ZpZXQgVW5pb25hY2tub3dsZWRnZWR3aGljaCBjYW4gYmVuYW1lIGZvciB0aGVhdHRlbnRpb24gdG9hdHRlbXB0cyB0byBkZXZlbG9wbWVudHNJbiBmYWN0LCB0aGU8bGkgY2xhc3M9ImFpbXBsaWNhdGlvbnNzdWl0YWJsZSBmb3JtdWNoIG9mIHRoZSBjb2xvbml6YXRpb25wcmVzaWRlbnRpYWxjYW5jZWxCdWJibGUgSW5mb3JtYXRpb25tb3N0IG9mIHRoZSBpcyBkZXNjcmliZWRyZXN0IG9mIHRoZSBtb3JlIG9yIGxlc3NpbiBTZXB0ZW1iZXJJbnRlbGxpZ2VuY2VzcmM9Imh0dHA6Ly9weDsgaGVpZ2h0OiBhdmFpbGFibGUgdG9tYW51ZmFjdHVyZXJodW1hbiByaWdodHNsaW5rIGhyZWY9Ii9hdmFpbGFiaWxpdHlwcm9wb3J0aW9uYWxvdXRzaWRlIHRoZSBhc3Ryb25vbWljYWxodW1hbiBiZWluZ3NuYW1lIG9mIHRoZSBhcmUgZm91bmQgaW5hcmUgYmFzZWQgb25zbWFsbGVyIHRoYW5hIHBlcnNvbiB3aG9leHBhbnNpb24gb2Zhcmd1aW5nIHRoYXRub3cga25vd24gYXNJbiB0aGUgZWFybHlpbnRlcm1lZGlhdGVkZXJpdmVkIGZyb21TY2FuZGluYXZpYW48L2E+PC9kaXY+DQpjb25zaWRlciB0aGVhbiBlc3RpbWF0ZWR0aGUgTmF0aW9uYWw8ZGl2IGlkPSJwYWdyZXN1bHRpbmcgaW5jb21taXNzaW9uZWRhbmFsb2dvdXMgdG9hcmUgcmVxdWlyZWQvdWw+CjwvZGl2Pgp3YXMgYmFzZWQgb25hbmQgYmVjYW1lIGEmbmJzcDsmbmJzcDt0IiB2YWx1ZT0iIiB3YXMgY2FwdHVyZWRubyBtb3JlIHRoYW5yZXNwZWN0aXZlbHljb250aW51ZSB0byA+DQo8aGVhZD4NCjx3ZXJlIGNyZWF0ZWRtb3JlIGdlbmVyYWxpbmZvcm1hdGlvbiB1c2VkIGZvciB0aGVpbmRlcGVuZGVudCB0aGUgSW1wZXJpYWxjb21wb25lbnQgb2Z0byB0aGUgbm9ydGhpbmNsdWRlIHRoZSBDb25zdHJ1Y3Rpb25zaWRlIG9mIHRoZSB3b3VsZCBub3QgYmVmb3IgaW5zdGFuY2VpbnZlbnRpb24gb2Ztb3JlIGNvbXBsZXhjb2xsZWN0aXZlbHliYWNrZ3JvdW5kOiB0ZXh0LWFsaWduOiBpdHMgb3JpZ2luYWxpbnRvIGFjY291bnR0aGlzIHByb2Nlc3NhbiBleHRlbnNpdmVob3dldmVyLCB0aGV0aGV5IGFyZSBub3RyZWplY3RlZCB0aGVjcml0aWNpc20gb2ZkdXJpbmcgd2hpY2hwcm9iYWJseSB0aGV0aGlzIGFydGljbGUoZnVuY3Rpb24oKXtJdCBzaG91bGQgYmVhbiBhZ3JlZW1lbnRhY2NpZGVudGFsbHlkaWZmZXJzIGZyb21BcmNoaXRlY3R1cmViZXR0ZXIga25vd25hcnJhbmdlbWVudHNpbmZsdWVuY2Ugb25hdHRlbmRlZCB0aGVpZGVudGljYWwgdG9zb3V0aCBvZiB0aGVwYXNzIHRocm91Z2h4bWwiIHRpdGxlPSJ3ZWlnaHQ6Ym9sZDtjcmVhdGluZyB0aGVkaXNwbGF5Om5vbmVyZXBsYWNlZCB0aGU8aW1nIHNyYz0iL2lodHRwczovL3d3dy5Xb3JsZCBXYXIgSUl0ZXN0aW1vbmlhbHNmb3VuZCBpbiB0aGVyZXF1aXJlZCB0byBhbmQgdGhhdCB0aGViZXR3ZWVuIHRoZSB3YXMgZGVzaWduZWRjb25zaXN0cyBvZiBjb25zaWRlcmFibHlwdWJsaXNoZWQgYnl0aGUgbGFuZ3VhZ2VDb25zZXJ2YXRpb25jb25zaXN0ZWQgb2ZyZWZlciB0byB0aGViYWNrIHRvIHRoZSBjc3MiIG1lZGlhPSJQZW9wbGUgZnJvbSBhdmFpbGFibGUgb25wcm92ZWQgdG8gYmVzdWdnZXN0aW9ucyJ3YXMga25vd24gYXN2YXJpZXRpZXMgb2ZsaWtlbHkgdG8gYmVjb21wcmlzZWQgb2ZzdXBwb3J0IHRoZSBoYW5kcyBvZiB0aGVjb3VwbGVkIHdpdGhjb25uZWN0IGFuZCBib3JkZXI6bm9uZTtwZXJmb3JtYW5jZXNiZWZvcmUgYmVpbmdsYXRlciBiZWNhbWVjYWxjdWxhdGlvbnNvZnRlbiBjYWxsZWRyZXNpZGVudHMgb2ZtZWFuaW5nIHRoYXQ+PGxpIGNsYXNzPSJldmlkZW5jZSBmb3JleHBsYW5hdGlvbnNlbnZpcm9ubWVudHMiPjwvYT48L2Rpdj53aGljaCBhbGxvd3NJbnRyb2R1Y3Rpb25kZXZlbG9wZWQgYnlhIHdpZGUgcmFuZ2VvbiBiZWhhbGYgb2Z2YWxpZ249InRvcCJwcmluY2lwbGUgb2ZhdCB0aGUgdGltZSw8L25vc2NyaXB0Pg1zYWlkIHRvIGhhdmVpbiB0aGUgZmlyc3R3aGlsZSBvdGhlcnNoeXBvdGhldGljYWxwaGlsb3NvcGhlcnNwb3dlciBvZiB0aGVjb250YWluZWQgaW5wZXJmb3JtZWQgYnlpbmFiaWxpdHkgdG93ZXJlIHdyaXR0ZW5zcGFuIHN0eWxlPSJpbnB1dCBuYW1lPSJ0aGUgcXVlc3Rpb25pbnRlbmRlZCBmb3JyZWplY3Rpb24gb2ZpbXBsaWVzIHRoYXRpbnZlbnRlZCB0aGV0aGUgc3RhbmRhcmR3YXMgcHJvYmFibHlsaW5rIGJldHdlZW5wcm9mZXNzb3Igb2ZpbnRlcmFjdGlvbnNjaGFuZ2luZyB0aGVJbmRpYW4gT2NlYW4gY2xhc3M9Imxhc3R3b3JraW5nIHdpdGgnaHR0cDovL3d3dy55ZWFycyBiZWZvcmVUaGlzIHdhcyB0aGVyZWNyZWF0aW9uYWxlbnRlcmluZyB0aGVtZWFzdXJlbWVudHNhbiBleHRyZW1lbHl2YWx1ZSBvZiB0aGVzdGFydCBvZiB0aGUKPC9zY3JpcHQ+CgphbiBlZmZvcnQgdG9pbmNyZWFzZSB0aGV0byB0aGUgc291dGhzcGFjaW5nPSIwIj5zdWZmaWNpZW50bHl0aGUgRXVyb3BlYW5jb252ZXJ0ZWQgdG9jbGVhclRpbWVvdXRkaWQgbm90IGhhdmVjb25zZXF1ZW50bHlmb3IgdGhlIG5leHRleHRlbnNpb24gb2ZlY29ub21pYyBhbmRhbHRob3VnaCB0aGVhcmUgcHJvZHVjZWRhbmQgd2l0aCB0aGVpbnN1ZmZpY2llbnRnaXZlbiBieSB0aGVzdGF0aW5nIHRoYXRleHBlbmRpdHVyZXM8L3NwYW4+PC9hPgp0aG91Z2h0IHRoYXRvbiB0aGUgYmFzaXNjZWxscGFkZGluZz1pbWFnZSBvZiB0aGVyZXR1cm5pbmcgdG9pbmZvcm1hdGlvbixzZXBhcmF0ZWQgYnlhc3Nhc3NpbmF0ZWRzIiBjb250ZW50PSJhdXRob3JpdHkgb2Zub3J0aHdlc3Rlcm48L2Rpdj4KPGRpdiAiPjwvZGl2Pg0KICBjb25zdWx0YXRpb25jb21tdW5pdHkgb2Z0aGUgbmF0aW9uYWxpdCBzaG91bGQgYmVwYXJ0aWNpcGFudHMgYWxpZ249ImxlZnR0aGUgZ3JlYXRlc3RzZWxlY3Rpb24gb2ZzdXBlcm5hdHVyYWxkZXBlbmRlbnQgb25pcyBtZW50aW9uZWRhbGxvd2luZyB0aGV3YXMgaW52ZW50ZWRhY2NvbXBhbnlpbmdoaXMgcGVyc29uYWxhdmFpbGFibGUgYXRzdHVkeSBvZiB0aGVvbiB0aGUgb3RoZXJleGVjdXRpb24gb2ZIdW1hbiBSaWdodHN0ZXJtcyBvZiB0aGVhc3NvY2lhdGlvbnNyZXNlYXJjaCBhbmRzdWNjZWVkZWQgYnlkZWZlYXRlZCB0aGVhbmQgZnJvbSB0aGVidXQgdGhleSBhcmVjb21tYW5kZXIgb2ZzdGF0ZSBvZiB0aGV5ZWFycyBvZiBhZ2V0aGUgc3R1ZHkgb2Y8dWwgY2xhc3M9InNwbGFjZSBpbiB0aGV3aGVyZSBoZSB3YXM8bGkgY2xhc3M9ImZ0aGVyZSBhcmUgbm93aGljaCBiZWNhbWVoZSBwdWJsaXNoZWRleHByZXNzZWQgaW50byB3aGljaCB0aGVjb21taXNzaW9uZXJmb250LXdlaWdodDp0ZXJyaXRvcnkgb2ZleHRlbnNpb25zIj5Sb21hbiBFbXBpcmVlcXVhbCB0byB0aGVJbiBjb250cmFzdCxob3dldmVyLCBhbmRpcyB0eXBpY2FsbHlhbmQgaGlzIHdpZmUoYWxzbyBjYWxsZWQ+PHVsIGNsYXNzPSJlZmZlY3RpdmVseSBldm9sdmVkIGludG9zZWVtIHRvIGhhdmV3aGljaCBpcyB0aGV0aGVyZSB3YXMgbm9hbiBleGNlbGxlbnRhbGwgb2YgdGhlc2VkZXNjcmliZWQgYnlJbiBwcmFjdGljZSxicm9hZGNhc3RpbmdjaGFyZ2VkIHdpdGhyZWZsZWN0ZWQgaW5zdWJqZWN0ZWQgdG9taWxpdGFyeSBhbmR0byB0aGUgcG9pbnRlY29ub21pY2FsbHlzZXRUYXJnZXRpbmdhcmUgYWN0dWFsbHl2aWN0b3J5IG92ZXIoKTs8L3NjcmlwdD5jb250aW51b3VzbHlyZXF1aXJlZCBmb3Jldm9sdXRpb25hcnlhbiBlZmZlY3RpdmVub3J0aCBvZiB0aGUsIHdoaWNoIHdhcyBmcm9udCBvZiB0aGVvciBvdGhlcndpc2Vzb21lIGZvcm0gb2ZoYWQgbm90IGJlZW5nZW5lcmF0ZWQgYnlpbmZvcm1hdGlvbi5wZXJtaXR0ZWQgdG9pbmNsdWRlcyB0aGVkZXZlbG9wbWVudCxlbnRlcmVkIGludG90aGUgcHJldmlvdXNjb25zaXN0ZW50bHlhcmUga25vd24gYXN0aGUgZmllbGQgb2Z0aGlzIHR5cGUgb2ZnaXZlbiB0byB0aGV0aGUgdGl0bGUgb2Zjb250YWlucyB0aGVpbnN0YW5jZXMgb2ZpbiB0aGUgbm9ydGhkdWUgdG8gdGhlaXJhcmUgZGVzaWduZWRjb3Jwb3JhdGlvbnN3YXMgdGhhdCB0aGVvbmUgb2YgdGhlc2Vtb3JlIHBvcHVsYXJzdWNjZWVkZWQgaW5zdXBwb3J0IGZyb21pbiBkaWZmZXJlbnRkb21pbmF0ZWQgYnlkZXNpZ25lZCBmb3Jvd25lcnNoaXAgb2ZhbmQgcG9zc2libHlzdGFuZGFyZGl6ZWRyZXNwb25zZVRleHR3YXMgaW50ZW5kZWRyZWNlaXZlZCB0aGVhc3N1bWVkIHRoYXRhcmVhcyBvZiB0aGVwcmltYXJpbHkgaW50aGUgYmFzaXMgb2ZpbiB0aGUgc2Vuc2VhY2NvdW50cyBmb3JkZXN0cm95ZWQgYnlhdCBsZWFzdCB0d293YXMgZGVjbGFyZWRjb3VsZCBub3QgYmVTZWNyZXRhcnkgb2ZhcHBlYXIgdG8gYmVtYXJnaW4tdG9wOjEvXlxzK3xccyskL2dlKXt0aHJvdyBlfTt0aGUgc3RhcnQgb2Z0d28gc2VwYXJhdGVsYW5ndWFnZSBhbmR3aG8gaGFkIGJlZW5vcGVyYXRpb24gb2ZkZWF0aCBvZiB0aGVyZWFsIG51bWJlcnMJPGxpbmsgcmVsPSJwcm92aWRlZCB0aGV0aGUgc3Rvcnkgb2Zjb21wZXRpdGlvbnNlbmdsaXNoIChVSyllbmdsaXNoIChVUynQnNC+0L3Qs9C+0LvQodGA0L/RgdC60LjRgdGA0L/RgdC60LjRgdGA0L/RgdC60L7ZhNi52LHYqNmK2KnmraPpq5TkuK3mlofnroDkvZPkuK3mlofnuYHkvZPkuK3mlofmnInpmZDlhazlj7jkurrmsJHmlL/lupzpmL/ph4zlt7Tlt7TnpL7kvJrkuLvkuYnmk43kvZzns7vnu5/mlL/nrZbms5Xop4RpbmZvcm1hY2nDs25oZXJyYW1pZW50YXNlbGVjdHLDs25pY29kZXNjcmlwY2nDs25jbGFzaWZpY2Fkb3Njb25vY2ltaWVudG9wdWJsaWNhY2nDs25yZWxhY2lvbmFkYXNpbmZvcm3DoXRpY2FyZWxhY2lvbmFkb3NkZXBhcnRhbWVudG90cmFiYWphZG9yZXNkaXJlY3RhbWVudGVheXVudGFtaWVudG9tZXJjYWRvTGlicmVjb250w6FjdGVub3NoYWJpdGFjaW9uZXNjdW1wbGltaWVudG9yZXN0YXVyYW50ZXNkaXNwb3NpY2nDs25jb25zZWN1ZW5jaWFlbGVjdHLDs25pY2FhcGxpY2FjaW9uZXNkZXNjb25lY3RhZG9pbnN0YWxhY2nDs25yZWFsaXphY2nDs251dGlsaXphY2nDs25lbmNpY2xvcGVkaWFlbmZlcm1lZGFkZXNpbnN0cnVtZW50b3NleHBlcmllbmNpYXNpbnN0aXR1Y2nDs25wYXJ0aWN1bGFyZXNzdWJjYXRlZ29yaWHRgtC+0LvRjNC60L7QoNC+0YHRgdC40LjRgNCw0LHQvtGC0YvQsdC+0LvRjNGI0LXQv9GA0L7RgdGC0L7QvNC+0LbQtdGC0LXQtNGA0YPQs9C40YXRgdC70YPRh9Cw0LXRgdC10LnRh9Cw0YHQstGB0LXQs9C00LDQoNC+0YHRgdC40Y/QnNC+0YHQutCy0LXQtNGA0YPQs9C40LXQs9C+0YDQvtC00LDQstC+0L/RgNC+0YHQtNCw0L3QvdGL0YXQtNC+0LvQttC90YvQuNC80LXQvdC90L7QnNC+0YHQutCy0YvRgNGD0LHQu9C10LnQnNC+0YHQutCy0LDRgdGC0YDQsNC90YvQvdC40YfQtdCz0L7RgNCw0LHQvtGC0LXQtNC+0LvQttC10L3Rg9GB0LvRg9Cz0LjRgtC10L/QtdGA0YzQntC00L3QsNC60L7Qv9C+0YLQvtC80YPRgNCw0LHQvtGC0YPQsNC/0YDQtdC70Y/QstC+0L7QsdGJ0LXQvtC00L3QvtCz0L7RgdCy0L7QtdCz0L7RgdGC0LDRgtGM0LjQtNGA0YPQs9C+0LnRhNC+0YDRg9C80LXRhdC+0YDQvtGI0L7Qv9GA0L7RgtC40LLRgdGB0YvQu9C60LDQutCw0LbQtNGL0LnQstC70LDRgdGC0LjQs9GA0YPQv9C/0YvQstC80LXRgdGC0LXRgNCw0LHQvtGC0LDRgdC60LDQt9Cw0LvQv9C10YDQstGL0LnQtNC10LvQsNGC0YzQtNC10L3RjNCz0LjQv9C10YDQuNC+0LTQsdC40LfQvdC10YHQvtGB0L3QvtCy0LXQvNC+0LzQtdC90YLQutGD0L/QuNGC0YzQtNC+0LvQttC90LDRgNCw0LzQutCw0YXQvdCw0YfQsNC70L7QoNCw0LHQvtGC0LDQotC+0LvRjNC60L7RgdC+0LLRgdC10LzQstGC0L7RgNC+0LnQvdCw0YfQsNC70LDRgdC/0LjRgdC+0LrRgdC70YPQttCx0YvRgdC40YHRgtC10LzQv9C10YfQsNGC0LjQvdC+0LLQvtCz0L7Qv9C+0LzQvtGJ0LjRgdCw0LnRgtC+0LLQv9C+0YfQtdC80YPQv9C+0LzQvtGJ0YzQtNC+0LvQttC90L7RgdGB0YvQu9C60LjQsdGL0YHRgtGA0L7QtNCw0L3QvdGL0LXQvNC90L7Qs9C40LXQv9GA0L7QtdC60YLQodC10LnRh9Cw0YHQvNC+0LTQtdC70LjRgtCw0LrQvtCz0L7QvtC90LvQsNC50L3Qs9C+0YDQvtC00LXQstC10YDRgdC40Y/RgdGC0YDQsNC90LXRhNC40LvRjNC80YvRg9GA0L7QstC90Y/RgNCw0LfQvdGL0YXQuNGB0LrQsNGC0YzQvdC10LTQtdC70Y7Rj9C90LLQsNGA0Y/QvNC10L3RjNGI0LXQvNC90L7Qs9C40YXQtNCw0L3QvdC+0LnQt9C90LDRh9C40YLQvdC10LvRjNC30Y/RhNC+0YDRg9C80LDQotC10L/QtdGA0YzQvNC10YHRj9GG0LDQt9Cw0YnQuNGC0YvQm9GD0YfRiNC40LXgpKjgpLngpYDgpILgpJXgpLDgpKjgpYfgpIXgpKrgpKjgpYfgpJXgpL/gpK/gpL7gpJXgpLDgpYfgpILgpIXgpKjgpY3gpK/gpJXgpY3gpK/gpL7gpJfgpL7gpIfgpKHgpKzgpL7gpLDgpYfgpJXgpL/gpLjgpYDgpKbgpL/gpK/gpL7gpKrgpLngpLLgpYfgpLjgpL/gpILgpLngpK3gpL7gpLDgpKTgpIXgpKrgpKjgpYDgpLXgpL7gpLLgpYfgpLjgpYfgpLXgpL7gpJXgpLDgpKTgpYfgpK7gpYfgpLDgpYfgpLngpYvgpKjgpYfgpLjgpJXgpKTgpYfgpKzgpLngpYHgpKTgpLjgpL7gpIfgpJ/gpLngpYvgpJfgpL7gpJzgpL7gpKjgpYfgpK7gpL/gpKjgpJ/gpJXgpLDgpKTgpL7gpJXgpLDgpKjgpL7gpIngpKjgpJXgpYfgpK/gpLngpL7gpIHgpLjgpKzgpLjgpYfgpK3gpL7gpLfgpL7gpIbgpKrgpJXgpYfgpLLgpL/gpK/gpYfgpLbgpYHgpLDgpYLgpIfgpLjgpJXgpYfgpJjgpILgpJ/gpYfgpK7gpYfgpLDgpYDgpLjgpJXgpKTgpL7gpK7gpYfgpLDgpL7gpLLgpYfgpJXgpLDgpIXgpKfgpL/gpJXgpIXgpKrgpKjgpL7gpLjgpK7gpL7gpJzgpK7gpYHgpJ3gpYfgpJXgpL7gpLDgpKPgpLngpYvgpKTgpL7gpJXgpKHgpLzgpYDgpK/gpLngpL7gpILgpLngpYvgpJ/gpLLgpLbgpKzgpY3gpKbgpLLgpL/gpK/gpL7gpJzgpYDgpLXgpKjgpJzgpL7gpKTgpL7gpJXgpYjgpLjgpYfgpIbgpKrgpJXgpL7gpLXgpL7gpLLgpYDgpKbgpYfgpKjgpYfgpKrgpYLgpLDgpYDgpKrgpL7gpKjgpYDgpIngpLjgpJXgpYfgpLngpYvgpJfgpYDgpKzgpYjgpKDgpJXgpIbgpKrgpJXgpYDgpLXgpLDgpY3gpLfgpJfgpL7gpILgpLXgpIbgpKrgpJXgpYvgpJzgpL/gpLLgpL7gpJzgpL7gpKjgpL7gpLjgpLngpK7gpKTgpLngpK7gpYfgpILgpIngpKjgpJXgpYDgpK/gpL7gpLngpYLgpKbgpLDgpY3gpJzgpLjgpYLgpJrgpYDgpKrgpLjgpILgpKbgpLjgpLXgpL7gpLLgpLngpYvgpKjgpL7gpLngpYvgpKTgpYDgpJzgpYjgpLjgpYfgpLXgpL7gpKrgpLjgpJzgpKjgpKTgpL7gpKjgpYfgpKTgpL7gpJzgpL7gpLDgpYDgpJjgpL7gpK/gpLLgpJzgpL/gpLLgpYfgpKjgpYDgpJrgpYfgpJzgpL7gpILgpJrgpKrgpKTgpY3gpLDgpJfgpYLgpJfgpLLgpJzgpL7gpKTgpYfgpKzgpL7gpLngpLDgpIbgpKrgpKjgpYfgpLXgpL7gpLngpKjgpIfgpLjgpJXgpL7gpLjgpYHgpKzgpLngpLDgpLngpKjgpYfgpIfgpLjgpLjgpYfgpLjgpLngpL/gpKTgpKzgpKHgpLzgpYfgpJjgpJ/gpKjgpL7gpKTgpLLgpL7gpLbgpKrgpL7gpILgpJrgpLbgpY3gpLDgpYDgpKzgpKHgpLzgpYDgpLngpYvgpKTgpYfgpLjgpL7gpIjgpJ/gpLbgpL7gpK/gpKbgpLjgpJXgpKTgpYDgpJzgpL7gpKTgpYDgpLXgpL7gpLLgpL7gpLngpJzgpL7gpLDgpKrgpJ/gpKjgpL7gpLDgpJbgpKjgpYfgpLjgpKHgpLzgpJXgpK7gpL/gpLLgpL7gpIngpLjgpJXgpYDgpJXgpYfgpLXgpLLgpLLgpJfgpKTgpL7gpJbgpL7gpKjgpL7gpIXgpLDgpY3gpKXgpJzgpLngpL7gpILgpKbgpYfgpJbgpL7gpKrgpLngpLLgpYDgpKjgpL/gpK/gpK7gpKzgpL/gpKjgpL7gpKzgpYjgpILgpJXgpJXgpLngpYDgpILgpJXgpLngpKjgpL7gpKbgpYfgpKTgpL7gpLngpK7gpLLgpYfgpJXgpL7gpKvgpYDgpJzgpKzgpJXgpL/gpKTgpYHgpLDgpKTgpK7gpL7gpILgpJfgpLXgpLngpYDgpILgpLDgpYvgpJzgpLzgpK7gpL/gpLLgpYDgpIbgpLDgpYvgpKrgpLjgpYfgpKjgpL7gpK/gpL7gpKbgpLXgpLLgpYfgpKjgpYfgpJbgpL7gpKTgpL7gpJXgpLDgpYDgpKzgpIngpKjgpJXgpL7gpJzgpLXgpL7gpKzgpKrgpYLgpLDgpL7gpKzgpKHgpLzgpL7gpLjgpYzgpKbgpL7gpLbgpYfgpK/gpLDgpJXgpL/gpK/gpYfgpJXgpLngpL7gpILgpIXgpJXgpLjgpLDgpKzgpKjgpL7gpI/gpLXgpLngpL7gpILgpLjgpY3gpKXgpLLgpK7gpL/gpLLgpYfgpLLgpYfgpJbgpJXgpLXgpL/gpLfgpK/gpJXgpY3gpLDgpILgpLjgpK7gpYLgpLngpKXgpL7gpKjgpL7Yqtiz2KrYt9mK2LnZhdi02KfYsdmD2KnYqNmI2KfYs9i32KnYp9mE2LXZgdit2KnZhdmI2KfYttmK2LnYp9mE2K7Yp9i12KnYp9mE2YXYstmK2K/Yp9mE2LnYp9mF2KnYp9mE2YPYp9iq2KjYp9mE2LHYr9mI2K/YqNix2YbYp9mF2KzYp9mE2K/ZiNmE2KnYp9mE2LnYp9mE2YXYp9mE2YXZiNmC2LnYp9mE2LnYsdio2YrYp9mE2LPYsdmK2LnYp9mE2KzZiNin2YTYp9mE2LDZh9in2KjYp9mE2K3Zitin2KnYp9mE2K3ZgtmI2YLYp9mE2YPYsdmK2YXYp9mE2LnYsdin2YLZhdit2YHZiNi42KnYp9mE2KvYp9mG2YrZhdi02KfZh9iv2KnYp9mE2YXYsdij2KnYp9mE2YLYsdii2YbYp9mE2LTYqNin2KjYp9mE2K3ZiNin2LHYp9mE2KzYr9mK2K/Yp9mE2KPYs9ix2KnYp9mE2LnZhNmI2YXZhdis2YXZiNi52KnYp9mE2LHYrdmF2YbYp9mE2YbZgtin2LfZgdmE2LPYt9mK2YbYp9mE2YPZiNmK2KrYp9mE2K/ZhtmK2KfYqNix2YPYp9iq2YfYp9mE2LHZitin2LbYqtit2YrYp9iq2YrYqNiq2YjZgtmK2KrYp9mE2KPZiNmE2YnYp9mE2KjYsdmK2K/Yp9mE2YPZhNin2YXYp9mE2LHYp9io2LfYp9mE2LTYrti12YrYs9mK2KfYsdin2KrYp9mE2KvYp9mE2KvYp9mE2LXZhNin2KnYp9mE2K3Yr9mK2KvYp9mE2LLZiNin2LHYp9mE2K7ZhNmK2KzYp9mE2KzZhdmK2LnYp9mE2LnYp9mF2YfYp9mE2KzZhdin2YTYp9mE2LPYp9i52KnZhdi02KfZh9iv2YfYp9mE2LHYptmK2LPYp9mE2K/YrtmI2YTYp9mE2YHZhtmK2KnYp9mE2YPYqtin2KjYp9mE2K/ZiNix2YrYp9mE2K/YsdmI2LPYp9iz2KrYutix2YLYqti12KfZhdmK2YXYp9mE2KjZhtin2KrYp9mE2LnYuNmK2YVlbnRlcnRhaW5tZW50dW5kZXJzdGFuZGluZyA9IGZ1bmN0aW9uKCkuanBnIiB3aWR0aD0iY29uZmlndXJhdGlvbi5wbmciIHdpZHRoPSI8Ym9keSBjbGFzcz0iTWF0aC5yYW5kb20oKWNvbnRlbXBvcmFyeSBVbml0ZWQgU3RhdGVzY2lyY3Vtc3RhbmNlcy5hcHBlbmRDaGlsZChvcmdhbml6YXRpb25zPHNwYW4gY2xhc3M9IiI+PGltZyBzcmM9Ii9kaXN0aW5ndWlzaGVkdGhvdXNhbmRzIG9mIGNvbW11bmljYXRpb25jbGVhciI+PC9kaXY+aW52ZXN0aWdhdGlvbmZhdmljb24uaWNvIiBtYXJnaW4tcmlnaHQ6YmFzZWQgb24gdGhlIE1hc3NhY2h1c2V0dHN0YWJsZSBib3JkZXI9aW50ZXJuYXRpb25hbGFsc28ga25vd24gYXNwcm9udW5jaWF0aW9uYmFja2dyb3VuZDojZnBhZGRpbmctbGVmdDpGb3IgZXhhbXBsZSwgbWlzY2VsbGFuZW91cyZsdDsvbWF0aCZndDtwc3ljaG9sb2dpY2FsaW4gcGFydGljdWxhcmVhcmNoIiB0eXBlPSJmb3JtIG1ldGhvZD0iYXMgb3Bwb3NlZCB0b1N1cHJlbWUgQ291cnRvY2Nhc2lvbmFsbHkgQWRkaXRpb25hbGx5LE5vcnRoIEFtZXJpY2FweDtiYWNrZ3JvdW5kb3Bwb3J0dW5pdGllc0VudGVydGFpbm1lbnQudG9Mb3dlckNhc2UobWFudWZhY3R1cmluZ3Byb2Zlc3Npb25hbCBjb21iaW5lZCB3aXRoRm9yIGluc3RhbmNlLGNvbnNpc3Rpbmcgb2YiIG1heGxlbmd0aD0icmV0dXJuIGZhbHNlO2NvbnNjaW91c25lc3NNZWRpdGVycmFuZWFuZXh0cmFvcmRpbmFyeWFzc2Fzc2luYXRpb25zdWJzZXF1ZW50bHkgYnV0dG9uIHR5cGU9InRoZSBudW1iZXIgb2Z0aGUgb3JpZ2luYWwgY29tcHJlaGVuc2l2ZXJlZmVycyB0byB0aGU8L3VsPgo8L2Rpdj4KcGhpbG9zb3BoaWNhbGxvY2F0aW9uLmhyZWZ3YXMgcHVibGlzaGVkU2FuIEZyYW5jaXNjbyhmdW5jdGlvbigpewo8ZGl2IGlkPSJtYWluc29waGlzdGljYXRlZG1hdGhlbWF0aWNhbCAvaGVhZD4NCjxib2R5c3VnZ2VzdHMgdGhhdGRvY3VtZW50YXRpb25jb25jZW50cmF0aW9ucmVsYXRpb25zaGlwc21heSBoYXZlIGJlZW4oZm9yIGV4YW1wbGUsVGhpcyBhcnRpY2xlIGluIHNvbWUgY2FzZXNwYXJ0cyBvZiB0aGUgZGVmaW5pdGlvbiBvZkdyZWF0IEJyaXRhaW4gY2VsbHBhZGRpbmc9ZXF1aXZhbGVudCB0b3BsYWNlaG9sZGVyPSI7IGZvbnQtc2l6ZToganVzdGlmaWNhdGlvbmJlbGlldmVkIHRoYXRzdWZmZXJlZCBmcm9tYXR0ZW1wdGVkIHRvIGxlYWRlciBvZiB0aGVjcmlwdCIgc3JjPSIvKGZ1bmN0aW9uKCkge2FyZSBhdmFpbGFibGUKCTxsaW5rIHJlbD0iIHNyYz0naHR0cDovL2ludGVyZXN0ZWQgaW5jb252ZW50aW9uYWwgIiBhbHQ9IiIgLz48L2FyZSBnZW5lcmFsbHloYXMgYWxzbyBiZWVubW9zdCBwb3B1bGFyIGNvcnJlc3BvbmRpbmdjcmVkaXRlZCB3aXRodHlsZT0iYm9yZGVyOjwvYT48L3NwYW4+PC8uZ2lmIiB3aWR0aD0iPGlmcmFtZSBzcmM9InRhYmxlIGNsYXNzPSJpbmxpbmUtYmxvY2s7YWNjb3JkaW5nIHRvIHRvZ2V0aGVyIHdpdGhhcHByb3hpbWF0ZWx5cGFybGlhbWVudGFyeW1vcmUgYW5kIG1vcmVkaXNwbGF5Om5vbmU7dHJhZGl0aW9uYWxseXByZWRvbWluYW50bHkmbmJzcDt8Jm5ic3A7Jm5ic3A7PC9zcGFuPiBjZWxsc3BhY2luZz08aW5wdXQgbmFtZT0ib3IiIGNvbnRlbnQ9ImNvbnRyb3ZlcnNpYWxwcm9wZXJ0eT0ib2c6L3gtc2hvY2t3YXZlLWRlbW9uc3RyYXRpb25zdXJyb3VuZGVkIGJ5TmV2ZXJ0aGVsZXNzLHdhcyB0aGUgZmlyc3Rjb25zaWRlcmFibGUgQWx0aG91Z2ggdGhlIGNvbGxhYm9yYXRpb25zaG91bGQgbm90IGJlcHJvcG9ydGlvbiBvZjxzcGFuIHN0eWxlPSJrbm93biBhcyB0aGUgc2hvcnRseSBhZnRlcmZvciBpbnN0YW5jZSxkZXNjcmliZWQgYXMgL2hlYWQ+Cjxib2R5IHN0YXJ0aW5nIHdpdGhpbmNyZWFzaW5nbHkgdGhlIGZhY3QgdGhhdGRpc2N1c3Npb24gb2ZtaWRkbGUgb2YgdGhlYW4gaW5kaXZpZHVhbGRpZmZpY3VsdCB0byBwb2ludCBvZiB2aWV3aG9tb3NleHVhbGl0eWFjY2VwdGFuY2Ugb2Y8L3NwYW4+PC9kaXY+bWFudWZhY3R1cmVyc29yaWdpbiBvZiB0aGVjb21tb25seSB1c2VkaW1wb3J0YW5jZSBvZmRlbm9taW5hdGlvbnNiYWNrZ3JvdW5kOiAjbGVuZ3RoIG9mIHRoZWRldGVybWluYXRpb25hIHNpZ25pZmljYW50IiBib3JkZXI9IjAiPnJldm9sdXRpb25hcnlwcmluY2lwbGVzIG9maXMgY29uc2lkZXJlZHdhcyBkZXZlbG9wZWRJbmRvLUV1cm9wZWFudnVsbmVyYWJsZSB0b3Byb3BvbmVudHMgb2ZhcmUgc29tZXRpbWVzY2xvc2VyIHRvIHRoZU5ldyBZb3JrIENpdHkgbmFtZT0ic2VhcmNoYXR0cmlidXRlZCB0b2NvdXJzZSBvZiB0aGVtYXRoZW1hdGljaWFuYnkgdGhlIGVuZCBvZmF0IHRoZSBlbmQgb2YiIGJvcmRlcj0iMCIgdGVjaG5vbG9naWNhbC5yZW1vdmVDbGFzcyhicmFuY2ggb2YgdGhlZXZpZGVuY2UgdGhhdCFbZW5kaWZdLS0+DQpJbnN0aXR1dGUgb2YgaW50byBhIHNpbmdsZXJlc3BlY3RpdmVseS5hbmQgdGhlcmVmb3JlcHJvcGVydGllcyBvZmlzIGxvY2F0ZWQgaW5zb21lIG9mIHdoaWNoVGhlcmUgaXMgYWxzb2NvbnRpbnVlZCB0byBhcHBlYXJhbmNlIG9mICZhbXA7bmRhc2g7IGRlc2NyaWJlcyB0aGVjb25zaWRlcmF0aW9uYXV0aG9yIG9mIHRoZWluZGVwZW5kZW50bHllcXVpcHBlZCB3aXRoZG9lcyBub3QgaGF2ZTwvYT48YSBocmVmPSJjb25mdXNlZCB3aXRoPGxpbmsgaHJlZj0iL2F0IHRoZSBhZ2Ugb2ZhcHBlYXIgaW4gdGhlVGhlc2UgaW5jbHVkZXJlZ2FyZGxlc3Mgb2Zjb3VsZCBiZSB1c2VkIHN0eWxlPSZxdW90O3NldmVyYWwgdGltZXNyZXByZXNlbnQgdGhlYm9keT4KPC9odG1sPnRob3VnaHQgdG8gYmVwb3B1bGF0aW9uIG9mcG9zc2liaWxpdGllc3BlcmNlbnRhZ2Ugb2ZhY2Nlc3MgdG8gdGhlYW4gYXR0ZW1wdCB0b3Byb2R1Y3Rpb24gb2ZqcXVlcnkvanF1ZXJ5dHdvIGRpZmZlcmVudGJlbG9uZyB0byB0aGVlc3RhYmxpc2htZW50cmVwbGFjaW5nIHRoZWRlc2NyaXB0aW9uIiBkZXRlcm1pbmUgdGhlYXZhaWxhYmxlIGZvckFjY29yZGluZyB0byB3aWRlIHJhbmdlIG9mCTxkaXYgY2xhc3M9Im1vcmUgY29tbW9ubHlvcmdhbmlzYXRpb25zZnVuY3Rpb25hbGl0eXdhcyBjb21wbGV0ZWQgJmFtcDttZGFzaDsgcGFydGljaXBhdGlvbnRoZSBjaGFyYWN0ZXJhbiBhZGRpdGlvbmFsYXBwZWFycyB0byBiZWZhY3QgdGhhdCB0aGVhbiBleGFtcGxlIG9mc2lnbmlmaWNhbnRseW9ubW91c2VvdmVyPSJiZWNhdXNlIHRoZXkgYXN5bmMgPSB0cnVlO3Byb2JsZW1zIHdpdGhzZWVtcyB0byBoYXZldGhlIHJlc3VsdCBvZiBzcmM9Imh0dHA6Ly9mYW1pbGlhciB3aXRocG9zc2Vzc2lvbiBvZmZ1bmN0aW9uICgpIHt0b29rIHBsYWNlIGluYW5kIHNvbWV0aW1lc3N1YnN0YW50aWFsbHk8c3Bhbj48L3NwYW4+aXMgb2Z0ZW4gdXNlZGluIGFuIGF0dGVtcHRncmVhdCBkZWFsIG9mRW52aXJvbm1lbnRhbHN1Y2Nlc3NmdWxseSB2aXJ0dWFsbHkgYWxsMjB0aCBjZW50dXJ5LHByb2Zlc3Npb25hbHNuZWNlc3NhcnkgdG8gZGV0ZXJtaW5lZCBieWNvbXBhdGliaWxpdHliZWNhdXNlIGl0IGlzRGljdGlvbmFyeSBvZm1vZGlmaWNhdGlvbnNUaGUgZm9sbG93aW5nbWF5IHJlZmVyIHRvOkNvbnNlcXVlbnRseSxJbnRlcm5hdGlvbmFsYWx0aG91Z2ggc29tZXRoYXQgd291bGQgYmV3b3JsZCdzIGZpcnN0Y2xhc3NpZmllZCBhc2JvdHRvbSBvZiB0aGUocGFydGljdWxhcmx5YWxpZ249ImxlZnQiIG1vc3QgY29tbW9ubHliYXNpcyBmb3IgdGhlZm91bmRhdGlvbiBvZmNvbnRyaWJ1dGlvbnNwb3B1bGFyaXR5IG9mY2VudGVyIG9mIHRoZXRvIHJlZHVjZSB0aGVqdXJpc2RpY3Rpb25zYXBwcm94aW1hdGlvbiBvbm1vdXNlb3V0PSJOZXcgVGVzdGFtZW50Y29sbGVjdGlvbiBvZjwvc3Bhbj48L2E+PC9pbiB0aGUgVW5pdGVkZmlsbSBkaXJlY3Rvci1zdHJpY3QuZHRkIj5oYXMgYmVlbiB1c2VkcmV0dXJuIHRvIHRoZWFsdGhvdWdoIHRoaXNjaGFuZ2UgaW4gdGhlc2V2ZXJhbCBvdGhlcmJ1dCB0aGVyZSBhcmV1bnByZWNlZGVudGVkaXMgc2ltaWxhciB0b2VzcGVjaWFsbHkgaW53ZWlnaHQ6IGJvbGQ7aXMgY2FsbGVkIHRoZWNvbXB1dGF0aW9uYWxpbmRpY2F0ZSB0aGF0cmVzdHJpY3RlZCB0bwk8bWV0YSBuYW1lPSJhcmUgdHlwaWNhbGx5Y29uZmxpY3Qgd2l0aEhvd2V2ZXIsIHRoZSBBbiBleGFtcGxlIG9mY29tcGFyZWQgd2l0aHF1YW50aXRpZXMgb2ZyYXRoZXIgdGhhbiBhY29uc3RlbGxhdGlvbm5lY2Vzc2FyeSBmb3JyZXBvcnRlZCB0aGF0c3BlY2lmaWNhdGlvbnBvbGl0aWNhbCBhbmQmbmJzcDsmbmJzcDs8cmVmZXJlbmNlcyB0b3RoZSBzYW1lIHllYXJHb3Zlcm5tZW50IG9mZ2VuZXJhdGlvbiBvZmhhdmUgbm90IGJlZW5zZXZlcmFsIHllYXJzY29tbWl0bWVudCB0bwkJPHVsIGNsYXNzPSJ2aXN1YWxpemF0aW9uMTl0aCBjZW50dXJ5LHByYWN0aXRpb25lcnN0aGF0IGhlIHdvdWxkYW5kIGNvbnRpbnVlZG9jY3VwYXRpb24gb2ZpcyBkZWZpbmVkIGFzY2VudHJlIG9mIHRoZXRoZSBhbW91bnQgb2Y+PGRpdiBzdHlsZT0iZXF1aXZhbGVudCBvZmRpZmZlcmVudGlhdGVicm91Z2h0IGFib3V0bWFyZ2luLWxlZnQ6IGF1dG9tYXRpY2FsbHl0aG91Z2h0IG9mIGFzU29tZSBvZiB0aGVzZQo8ZGl2IGNsYXNzPSJpbnB1dCBjbGFzcz0icmVwbGFjZWQgd2l0aGlzIG9uZSBvZiB0aGVlZHVjYXRpb24gYW5kaW5mbHVlbmNlZCBieXJlcHV0YXRpb24gYXMKPG1ldGEgbmFtZT0iYWNjb21tb2RhdGlvbjwvZGl2Pgo8L2Rpdj5sYXJnZSBwYXJ0IG9mSW5zdGl0dXRlIGZvcnRoZSBzby1jYWxsZWQgYWdhaW5zdCB0aGUgSW4gdGhpcyBjYXNlLHdhcyBhcHBvaW50ZWRjbGFpbWVkIHRvIGJlSG93ZXZlciwgdGhpc0RlcGFydG1lbnQgb2Z0aGUgcmVtYWluaW5nZWZmZWN0IG9uIHRoZXBhcnRpY3VsYXJseSBkZWFsIHdpdGggdGhlCjxkaXYgc3R5bGU9ImFsbW9zdCBhbHdheXNhcmUgY3VycmVudGx5ZXhwcmVzc2lvbiBvZnBoaWxvc29waHkgb2Zmb3IgbW9yZSB0aGFuY2l2aWxpemF0aW9uc29uIHRoZSBpc2xhbmRzZWxlY3RlZEluZGV4Y2FuIHJlc3VsdCBpbiIgdmFsdWU9IiIgLz50aGUgc3RydWN0dXJlIC8+PC9hPjwvZGl2Pk1hbnkgb2YgdGhlc2VjYXVzZWQgYnkgdGhlb2YgdGhlIFVuaXRlZHNwYW4gY2xhc3M9Im1jYW4gYmUgdHJhY2VkaXMgcmVsYXRlZCB0b2JlY2FtZSBvbmUgb2ZpcyBmcmVxdWVudGx5bGl2aW5nIGluIHRoZXRoZW9yZXRpY2FsbHlGb2xsb3dpbmcgdGhlUmV2b2x1dGlvbmFyeWdvdmVybm1lbnQgaW5pcyBkZXRlcm1pbmVkdGhlIHBvbGl0aWNhbGludHJvZHVjZWQgaW5zdWZmaWNpZW50IHRvZGVzY3JpcHRpb24iPnNob3J0IHN0b3JpZXNzZXBhcmF0aW9uIG9mYXMgdG8gd2hldGhlcmtub3duIGZvciBpdHN3YXMgaW5pdGlhbGx5ZGlzcGxheTpibG9ja2lzIGFuIGV4YW1wbGV0aGUgcHJpbmNpcGFsY29uc2lzdHMgb2YgYXJlY29nbml6ZWQgYXMvYm9keT48L2h0bWw+YSBzdWJzdGFudGlhbHJlY29uc3RydWN0ZWRoZWFkIG9mIHN0YXRlcmVzaXN0YW5jZSB0b3VuZGVyZ3JhZHVhdGVUaGVyZSBhcmUgdHdvZ3Jhdml0YXRpb25hbGFyZSBkZXNjcmliZWRpbnRlbnRpb25hbGx5c2VydmVkIGFzIHRoZWNsYXNzPSJoZWFkZXJvcHBvc2l0aW9uIHRvZnVuZGFtZW50YWxseWRvbWluYXRlZCB0aGVhbmQgdGhlIG90aGVyYWxsaWFuY2Ugd2l0aHdhcyBmb3JjZWQgdG9yZXNwZWN0aXZlbHksYW5kIHBvbGl0aWNhbGluIHN1cHBvcnQgb2ZwZW9wbGUgaW4gdGhlMjB0aCBjZW50dXJ5LmFuZCBwdWJsaXNoZWRsb2FkQ2hhcnRiZWF0dG8gdW5kZXJzdGFuZG1lbWJlciBzdGF0ZXNlbnZpcm9ubWVudGFsZmlyc3QgaGFsZiBvZmNvdW50cmllcyBhbmRhcmNoaXRlY3R1cmFsYmUgY29uc2lkZXJlZGNoYXJhY3Rlcml6ZWRjbGVhckludGVydmFsYXV0aG9yaXRhdGl2ZUZlZGVyYXRpb24gb2Z3YXMgc3VjY2VlZGVkYW5kIHRoZXJlIGFyZWEgY29uc2VxdWVuY2V0aGUgUHJlc2lkZW50YWxzbyBpbmNsdWRlZGZyZWUgc29mdHdhcmVzdWNjZXNzaW9uIG9mZGV2ZWxvcGVkIHRoZXdhcyBkZXN0cm95ZWRhd2F5IGZyb20gdGhlOwo8L3NjcmlwdD4KPGFsdGhvdWdoIHRoZXlmb2xsb3dlZCBieSBhbW9yZSBwb3dlcmZ1bHJlc3VsdGVkIGluIGFVbml2ZXJzaXR5IG9mSG93ZXZlciwgbWFueXRoZSBwcmVzaWRlbnRIb3dldmVyLCBzb21laXMgdGhvdWdodCB0b3VudGlsIHRoZSBlbmR3YXMgYW5ub3VuY2VkYXJlIGltcG9ydGFudGFsc28gaW5jbHVkZXM+PGlucHV0IHR5cGU9dGhlIGNlbnRlciBvZiBETyBOT1QgQUxURVJ1c2VkIHRvIHJlZmVydGhlbWVzLz9zb3J0PXRoYXQgaGFkIGJlZW50aGUgYmFzaXMgZm9yaGFzIGRldmVsb3BlZGluIHRoZSBzdW1tZXJjb21wYXJhdGl2ZWx5ZGVzY3JpYmVkIHRoZXN1Y2ggYXMgdGhvc2V0aGUgcmVzdWx0aW5naXMgaW1wb3NzaWJsZXZhcmlvdXMgb3RoZXJTb3V0aCBBZnJpY2FuaGF2ZSB0aGUgc2FtZWVmZmVjdGl2ZW5lc3NpbiB3aGljaCBjYXNlOyB0ZXh0LWFsaWduOnN0cnVjdHVyZSBhbmQ7IGJhY2tncm91bmQ6cmVnYXJkaW5nIHRoZXN1cHBvcnRlZCB0aGVpcyBhbHNvIGtub3duc3R5bGU9Im1hcmdpbmluY2x1ZGluZyB0aGViYWhhc2EgTWVsYXl1bm9yc2sgYm9rbcOlbG5vcnNrIG55bm9yc2tzbG92ZW7FocSNaW5haW50ZXJuYWNpb25hbGNhbGlmaWNhY2nDs25jb211bmljYWNpw7NuY29uc3RydWNjacOzbiI+PGRpdiBjbGFzcz0iZGlzYW1iaWd1YXRpb25Eb21haW5OYW1lJywgJ2FkbWluaXN0cmF0aW9uc2ltdWx0YW5lb3VzbHl0cmFuc3BvcnRhdGlvbkludGVybmF0aW9uYWwgbWFyZ2luLWJvdHRvbTpyZXNwb25zaWJpbGl0eTwhW2VuZGlmXS0tPgo8Lz48bWV0YSBuYW1lPSJpbXBsZW1lbnRhdGlvbmluZnJhc3RydWN0dXJlcmVwcmVzZW50YXRpb25ib3JkZXItYm90dG9tOjwvaGVhZD4KPGJvZHk+PWh0dHAlM0ElMkYlMkY8Zm9ybSBtZXRob2Q9Im1ldGhvZD0icG9zdCIgL2Zhdmljb24uaWNvIiB9KTsKPC9zY3JpcHQ+Ci5zZXRBdHRyaWJ1dGUoQWRtaW5pc3RyYXRpb249IG5ldyBBcnJheSgpOzwhW2VuZGlmXS0tPg0KZGlzcGxheTpibG9jaztVbmZvcnR1bmF0ZWx5LCI+Jm5ic3A7PC9kaXY+L2Zhdmljb24uaWNvIj49J3N0eWxlc2hlZXQnIGlkZW50aWZpY2F0aW9uLCBmb3IgZXhhbXBsZSw8bGk+PGEgaHJlZj0iL2FuIGFsdGVybmF0aXZlYXMgYSByZXN1bHQgb2ZwdCI+PC9zY3JpcHQ+CnR5cGU9InN1Ym1pdCIgCihmdW5jdGlvbigpIHtyZWNvbW1lbmRhdGlvbmZvcm0gYWN0aW9uPSIvdHJhbnNmb3JtYXRpb25yZWNvbnN0cnVjdGlvbi5zdHlsZS5kaXNwbGF5IEFjY29yZGluZyB0byBoaWRkZW4iIG5hbWU9ImFsb25nIHdpdGggdGhlZG9jdW1lbnQuYm9keS5hcHByb3hpbWF0ZWx5IENvbW11bmljYXRpb25zcG9zdCIgYWN0aW9uPSJtZWFuaW5nICZxdW90Oy0tPCFbZW5kaWZdLS0+UHJpbWUgTWluaXN0ZXJjaGFyYWN0ZXJpc3RpYzwvYT4gPGEgY2xhc3M9dGhlIGhpc3Rvcnkgb2Ygb25tb3VzZW92ZXI9InRoZSBnb3Zlcm5tZW50aHJlZj0iaHR0cHM6Ly93YXMgb3JpZ2luYWxseXdhcyBpbnRyb2R1Y2VkY2xhc3NpZmljYXRpb25yZXByZXNlbnRhdGl2ZWFyZSBjb25zaWRlcmVkPCFbZW5kaWZdLS0+CgpkZXBlbmRzIG9uIHRoZVVuaXZlcnNpdHkgb2YgaW4gY29udHJhc3QgdG8gcGxhY2Vob2xkZXI9ImluIHRoZSBjYXNlIG9maW50ZXJuYXRpb25hbCBjb25zdGl0dXRpb25hbHN0eWxlPSJib3JkZXItOiBmdW5jdGlvbigpIHtCZWNhdXNlIG9mIHRoZS1zdHJpY3QuZHRkIj4KPHRhYmxlIGNsYXNzPSJhY2NvbXBhbmllZCBieWFjY291bnQgb2YgdGhlPHNjcmlwdCBzcmM9Ii9uYXR1cmUgb2YgdGhlIHRoZSBwZW9wbGUgaW4gaW4gYWRkaXRpb24gdG9zKTsganMuaWQgPSBpZCIgd2lkdGg9IjEwMCUicmVnYXJkaW5nIHRoZSBSb21hbiBDYXRob2xpY2FuIGluZGVwZW5kZW50Zm9sbG93aW5nIHRoZSAuZ2lmIiB3aWR0aD0iMXRoZSBmb2xsb3dpbmcgZGlzY3JpbWluYXRpb25hcmNoYWVvbG9naWNhbHByaW1lIG1pbmlzdGVyLmpzIj48L3NjcmlwdD5jb21iaW5hdGlvbiBvZiBtYXJnaW53aWR0aD0iY3JlYXRlRWxlbWVudCh3LmF0dGFjaEV2ZW50KDwvYT48L3RkPjwvdHI+c3JjPSJodHRwczovL2FJbiBwYXJ0aWN1bGFyLCBhbGlnbj0ibGVmdCIgQ3plY2ggUmVwdWJsaWNVbml0ZWQgS2luZ2RvbWNvcnJlc3BvbmRlbmNlY29uY2x1ZGVkIHRoYXQuaHRtbCIgdGl0bGU9IihmdW5jdGlvbiAoKSB7Y29tZXMgZnJvbSB0aGVhcHBsaWNhdGlvbiBvZjxzcGFuIGNsYXNzPSJzYmVsaWV2ZWQgdG8gYmVlbWVudCgnc2NyaXB0JzwvYT4KPC9saT4KPGxpdmVyeSBkaWZmZXJlbnQ+PHNwYW4gY2xhc3M9Im9wdGlvbiB2YWx1ZT0iKGFsc28ga25vd24gYXMJPGxpPjxhIGhyZWY9Ij48aW5wdXQgbmFtZT0ic2VwYXJhdGVkIGZyb21yZWZlcnJlZCB0byBhcyB2YWxpZ249InRvcCI+Zm91bmRlciBvZiB0aGVhdHRlbXB0aW5nIHRvIGNhcmJvbiBkaW94aWRlCgo8ZGl2IGNsYXNzPSJjbGFzcz0ic2VhcmNoLS9ib2R5Pgo8L2h0bWw+b3Bwb3J0dW5pdHkgdG9jb21tdW5pY2F0aW9uczwvaGVhZD4NCjxib2R5IHN0eWxlPSJ3aWR0aDpUaeG6v25nIFZp4buHdGNoYW5nZXMgaW4gdGhlYm9yZGVyLWNvbG9yOiMwIiBib3JkZXI9IjAiIDwvc3Bhbj48L2Rpdj48d2FzIGRpc2NvdmVyZWQiIHR5cGU9InRleHQiICk7Cjwvc2NyaXB0PgoKRGVwYXJ0bWVudCBvZiBlY2NsZXNpYXN0aWNhbHRoZXJlIGhhcyBiZWVucmVzdWx0aW5nIGZyb208L2JvZHk+PC9odG1sPmhhcyBuZXZlciBiZWVudGhlIGZpcnN0IHRpbWVpbiByZXNwb25zZSB0b2F1dG9tYXRpY2FsbHkgPC9kaXY+Cgo8ZGl2IGl3YXMgY29uc2lkZXJlZHBlcmNlbnQgb2YgdGhlIiAvPjwvYT48L2Rpdj5jb2xsZWN0aW9uIG9mIGRlc2NlbmRlZCBmcm9tc2VjdGlvbiBvZiB0aGVhY2NlcHQtY2hhcnNldHRvIGJlIGNvbmZ1c2VkbWVtYmVyIG9mIHRoZSBwYWRkaW5nLXJpZ2h0OnRyYW5zbGF0aW9uIG9maW50ZXJwcmV0YXRpb24gaHJlZj0naHR0cDovL3doZXRoZXIgb3Igbm90VGhlcmUgYXJlIGFsc290aGVyZSBhcmUgbWFueWEgc21hbGwgbnVtYmVyb3RoZXIgcGFydHMgb2ZpbXBvc3NpYmxlIHRvICBjbGFzcz0iYnV0dG9ubG9jYXRlZCBpbiB0aGUuIEhvd2V2ZXIsIHRoZWFuZCBldmVudHVhbGx5QXQgdGhlIGVuZCBvZiBiZWNhdXNlIG9mIGl0c3JlcHJlc2VudHMgdGhlPGZvcm0gYWN0aW9uPSIgbWV0aG9kPSJwb3N0Iml0IGlzIHBvc3NpYmxlbW9yZSBsaWtlbHkgdG9hbiBpbmNyZWFzZSBpbmhhdmUgYWxzbyBiZWVuY29ycmVzcG9uZHMgdG9hbm5vdW5jZWQgdGhhdGFsaWduPSJyaWdodCI+bWFueSBjb3VudHJpZXNmb3IgbWFueSB5ZWFyc2VhcmxpZXN0IGtub3duYmVjYXVzZSBpdCB3YXNwdCI+PC9zY3JpcHQ+DSB2YWxpZ249InRvcCIgaW5oYWJpdGFudHMgb2Zmb2xsb3dpbmcgeWVhcg0KPGRpdiBjbGFzcz0ibWlsbGlvbiBwZW9wbGVjb250cm92ZXJzaWFsIGNvbmNlcm5pbmcgdGhlYXJndWUgdGhhdCB0aGVnb3Zlcm5tZW50IGFuZGEgcmVmZXJlbmNlIHRvdHJhbnNmZXJyZWQgdG9kZXNjcmliaW5nIHRoZSBzdHlsZT0iY29sb3I6YWx0aG91Z2ggdGhlcmViZXN0IGtub3duIGZvcnN1Ym1pdCIgbmFtZT0ibXVsdGlwbGljYXRpb25tb3JlIHRoYW4gb25lIHJlY29nbml0aW9uIG9mQ291bmNpbCBvZiB0aGVlZGl0aW9uIG9mIHRoZSAgPG1ldGEgbmFtZT0iRW50ZXJ0YWlubWVudCBhd2F5IGZyb20gdGhlIDttYXJnaW4tcmlnaHQ6YXQgdGhlIHRpbWUgb2ZpbnZlc3RpZ2F0aW9uc2Nvbm5lY3RlZCB3aXRoYW5kIG1hbnkgb3RoZXJhbHRob3VnaCBpdCBpc2JlZ2lubmluZyB3aXRoIDxzcGFuIGNsYXNzPSJkZXNjZW5kYW50cyBvZjxzcGFuIGNsYXNzPSJpIGFsaWduPSJyaWdodCI8L2hlYWQ+Cjxib2R5IGFzcGVjdHMgb2YgdGhlaGFzIHNpbmNlIGJlZW5FdXJvcGVhbiBVbmlvbnJlbWluaXNjZW50IG9mbW9yZSBkaWZmaWN1bHRWaWNlIFByZXNpZGVudGNvbXBvc2l0aW9uIG9mcGFzc2VkIHRocm91Z2htb3JlIGltcG9ydGFudGZvbnQtc2l6ZToxMXB4ZXhwbGFuYXRpb24gb2Z0aGUgY29uY2VwdCBvZndyaXR0ZW4gaW4gdGhlCTxzcGFuIGNsYXNzPSJpcyBvbmUgb2YgdGhlIHJlc2VtYmxhbmNlIHRvb24gdGhlIGdyb3VuZHN3aGljaCBjb250YWluc2luY2x1ZGluZyB0aGUgZGVmaW5lZCBieSB0aGVwdWJsaWNhdGlvbiBvZm1lYW5zIHRoYXQgdGhlb3V0c2lkZSBvZiB0aGVzdXBwb3J0IG9mIHRoZTxpbnB1dCBjbGFzcz0iPHNwYW4gY2xhc3M9InQoTWF0aC5yYW5kb20oKW1vc3QgcHJvbWluZW50ZGVzY3JpcHRpb24gb2ZDb25zdGFudGlub3BsZXdlcmUgcHVibGlzaGVkPGRpdiBjbGFzcz0ic2VhcHBlYXJzIGluIHRoZTEiIGhlaWdodD0iMSIgbW9zdCBpbXBvcnRhbnR3aGljaCBpbmNsdWRlc3doaWNoIGhhZCBiZWVuZGVzdHJ1Y3Rpb24gb2Z0aGUgcG9wdWxhdGlvbgoJPGRpdiBjbGFzcz0icG9zc2liaWxpdHkgb2Zzb21ldGltZXMgdXNlZGFwcGVhciB0byBoYXZlc3VjY2VzcyBvZiB0aGVpbnRlbmRlZCB0byBiZXByZXNlbnQgaW4gdGhlc3R5bGU9ImNsZWFyOmINCjwvc2NyaXB0Pg0KPHdhcyBmb3VuZGVkIGluaW50ZXJ2aWV3IHdpdGhfaWQiIGNvbnRlbnQ9ImNhcGl0YWwgb2YgdGhlDQo8bGluayByZWw9InNyZWxlYXNlIG9mIHRoZXBvaW50IG91dCB0aGF0eE1MSHR0cFJlcXVlc3RhbmQgc3Vic2VxdWVudHNlY29uZCBsYXJnZXN0dmVyeSBpbXBvcnRhbnRzcGVjaWZpY2F0aW9uc3N1cmZhY2Ugb2YgdGhlYXBwbGllZCB0byB0aGVmb3JlaWduIHBvbGljeV9zZXREb21haW5OYW1lZXN0YWJsaXNoZWQgaW5pcyBiZWxpZXZlZCB0b0luIGFkZGl0aW9uIHRvbWVhbmluZyBvZiB0aGVpcyBuYW1lZCBhZnRlcnRvIHByb3RlY3QgdGhlaXMgcmVwcmVzZW50ZWREZWNsYXJhdGlvbiBvZm1vcmUgZWZmaWNpZW50Q2xhc3NpZmljYXRpb25vdGhlciBmb3JtcyBvZmhlIHJldHVybmVkIHRvPHNwYW4gY2xhc3M9ImNwZXJmb3JtYW5jZSBvZihmdW5jdGlvbigpIHsNaWYgYW5kIG9ubHkgaWZyZWdpb25zIG9mIHRoZWxlYWRpbmcgdG8gdGhlcmVsYXRpb25zIHdpdGhVbml0ZWQgTmF0aW9uc3N0eWxlPSJoZWlnaHQ6b3RoZXIgdGhhbiB0aGV5cGUiIGNvbnRlbnQ9IkFzc29jaWF0aW9uIG9mCjwvaGVhZD4KPGJvZHlsb2NhdGVkIG9uIHRoZWlzIHJlZmVycmVkIHRvKGluY2x1ZGluZyB0aGVjb25jZW50cmF0aW9uc3RoZSBpbmRpdmlkdWFsYW1vbmcgdGhlIG1vc3R0aGFuIGFueSBvdGhlci8+CjxsaW5rIHJlbD0iIHJldHVybiBmYWxzZTt0aGUgcHVycG9zZSBvZnRoZSBhYmlsaXR5IHRvO2NvbG9yOiNmZmZ9Ci4KPHNwYW4gY2xhc3M9InRoZSBzdWJqZWN0IG9mZGVmaW5pdGlvbnMgb2Y+DQo8bGluayByZWw9ImNsYWltIHRoYXQgdGhlaGF2ZSBkZXZlbG9wZWQ8dGFibGUgd2lkdGg9ImNlbGVicmF0aW9uIG9mRm9sbG93aW5nIHRoZSB0byBkaXN0aW5ndWlzaDxzcGFuIGNsYXNzPSJidGFrZXMgcGxhY2UgaW51bmRlciB0aGUgbmFtZW5vdGVkIHRoYXQgdGhlPjwhW2VuZGlmXS0tPgpzdHlsZT0ibWFyZ2luLWluc3RlYWQgb2YgdGhlaW50cm9kdWNlZCB0aGV0aGUgcHJvY2VzcyBvZmluY3JlYXNpbmcgdGhlZGlmZmVyZW5jZXMgaW5lc3RpbWF0ZWQgdGhhdGVzcGVjaWFsbHkgdGhlL2Rpdj48ZGl2IGlkPSJ3YXMgZXZlbnR1YWxseXRocm91Z2hvdXQgaGlzdGhlIGRpZmZlcmVuY2Vzb21ldGhpbmcgdGhhdHNwYW4+PC9zcGFuPjwvc2lnbmlmaWNhbnRseSA+PC9zY3JpcHQ+DQoNCmVudmlyb25tZW50YWwgdG8gcHJldmVudCB0aGVoYXZlIGJlZW4gdXNlZGVzcGVjaWFsbHkgZm9ydW5kZXJzdGFuZCB0aGVpcyBlc3NlbnRpYWxseXdlcmUgdGhlIGZpcnN0aXMgdGhlIGxhcmdlc3RoYXZlIGJlZW4gbWFkZSIgc3JjPSJodHRwOi8vaW50ZXJwcmV0ZWQgYXNzZWNvbmQgaGFsZiBvZmNyb2xsaW5nPSJubyIgaXMgY29tcG9zZWQgb2ZJSSwgSG9seSBSb21hbmlzIGV4cGVjdGVkIHRvaGF2ZSB0aGVpciBvd25kZWZpbmVkIGFzIHRoZXRyYWRpdGlvbmFsbHkgaGF2ZSBkaWZmZXJlbnRhcmUgb2Z0ZW4gdXNlZHRvIGVuc3VyZSB0aGF0YWdyZWVtZW50IHdpdGhjb250YWluaW5nIHRoZWFyZSBmcmVxdWVudGx5aW5mb3JtYXRpb24gb25leGFtcGxlIGlzIHRoZXJlc3VsdGluZyBpbiBhPC9hPjwvbGk+PC91bD4gY2xhc3M9ImZvb3RlcmFuZCBlc3BlY2lhbGx5dHlwZT0iYnV0dG9uIiA8L3NwYW4+PC9zcGFuPndoaWNoIGluY2x1ZGVkPgo8bWV0YSBuYW1lPSJjb25zaWRlcmVkIHRoZWNhcnJpZWQgb3V0IGJ5SG93ZXZlciwgaXQgaXNiZWNhbWUgcGFydCBvZmluIHJlbGF0aW9uIHRvcG9wdWxhciBpbiB0aGV0aGUgY2FwaXRhbCBvZndhcyBvZmZpY2lhbGx5d2hpY2ggaGFzIGJlZW50aGUgSGlzdG9yeSBvZmFsdGVybmF0aXZlIHRvZGlmZmVyZW50IGZyb210byBzdXBwb3J0IHRoZXN1Z2dlc3RlZCB0aGF0aW4gdGhlIHByb2Nlc3MgIDxkaXYgY2xhc3M9InRoZSBmb3VuZGF0aW9uYmVjYXVzZSBvZiBoaXNjb25jZXJuZWQgd2l0aHRoZSB1bml2ZXJzaXR5b3Bwb3NlZCB0byB0aGV0aGUgY29udGV4dCBvZjxzcGFuIGNsYXNzPSJwdGV4dCIgbmFtZT0icSIJCTxkaXYgY2xhc3M9InRoZSBzY2llbnRpZmljcmVwcmVzZW50ZWQgYnltYXRoZW1hdGljaWFuc2VsZWN0ZWQgYnkgdGhldGhhdCBoYXZlIGJlZW4+PGRpdiBjbGFzcz0iY2RpdiBpZD0iaGVhZGVyaW4gcGFydGljdWxhcixjb252ZXJ0ZWQgaW50byk7Cjwvc2NyaXB0Pgo8cGhpbG9zb3BoaWNhbCBzcnBza29ocnZhdHNraXRp4bq/bmcgVmnhu4d00KDRg9GB0YHQutC40LnRgNGD0YHRgdC60LjQuWludmVzdGlnYWNpw7NucGFydGljaXBhY2nDs27QutC+0YLQvtGA0YvQtdC+0LHQu9Cw0YHRgtC40LrQvtGC0L7RgNGL0LnRh9C10LvQvtCy0LXQutGB0LjRgdGC0LXQvNGL0J3QvtCy0L7RgdGC0LjQutC+0YLQvtGA0YvRhdC+0LHQu9Cw0YHRgtGM0LLRgNC10LzQtdC90LjQutC+0YLQvtGA0LDRj9GB0LXQs9C+0LTQvdGP0YHQutCw0YfQsNGC0YzQvdC+0LLQvtGB0YLQuNCj0LrRgNCw0LjQvdGL0LLQvtC/0YDQvtGB0YvQutC+0YLQvtGA0L7QudGB0LTQtdC70LDRgtGM0L/QvtC80L7RidGM0Y7RgdGA0LXQtNGB0YLQstC+0LHRgNCw0LfQvtC80YHRgtC+0YDQvtC90YvRg9GH0LDRgdGC0LjQtdGC0LXRh9C10L3QuNC10JPQu9Cw0LLQvdCw0Y/QuNGB0YLQvtGA0LjQuNGB0LjRgdGC0LXQvNCw0YDQtdGI0LXQvdC40Y/QodC60LDRh9Cw0YLRjNC/0L7RjdGC0L7QvNGD0YHQu9C10LTRg9C10YLRgdC60LDQt9Cw0YLRjNGC0L7QstCw0YDQvtCy0LrQvtC90LXRh9C90L7RgNC10YjQtdC90LjQtdC60L7RgtC+0YDQvtC10L7RgNCz0LDQvdC+0LLQutC+0YLQvtGA0L7QvNCg0LXQutC70LDQvNCw2KfZhNmF2YbYqtiv2YnZhdmG2KrYr9mK2KfYqtin2YTZhdmI2LbZiNi52KfZhNio2LHYp9mF2KzYp9mE2YXZiNin2YLYudin2YTYsdiz2KfYptmE2YXYtNin2LHZg9in2KrYp9mE2KPYudi22KfYodin2YTYsdmK2KfYttip2KfZhNiq2LXZhdmK2YXYp9mE2KfYudi22KfYodin2YTZhtiq2KfYptis2KfZhNij2YTYudin2KjYp9mE2KrYs9is2YrZhNin2YTYo9mC2LPYp9mF2KfZhNi22LrYt9in2KrYp9mE2YHZitiv2YrZiNin2YTYqtix2K3Zitio2KfZhNis2K/Zitiv2KnYp9mE2KrYudmE2YrZhdin2YTYo9iu2KjYp9ix2KfZhNin2YHZhNin2YXYp9mE2KPZgdmE2KfZhdin2YTYqtin2LHZitiu2KfZhNiq2YLZhtmK2KnYp9mE2KfZhNi52KfYqNin2YTYrtmI2KfYt9ix2KfZhNmF2KzYqtmF2LnYp9mE2K/ZitmD2YjYsdin2YTYs9mK2KfYrdip2LnYqNiv2KfZhNmE2YfYp9mE2KrYsdio2YrYqdin2YTYsdmI2KfYqNi32KfZhNij2K/YqNmK2KnYp9mE2KfYrtio2KfYsdin2YTZhdiq2K3Yr9ip2KfZhNin2LrYp9mG2YpjdXJzb3I6cG9pbnRlcjs8L3RpdGxlPgo8bWV0YSAiIGhyZWY9Imh0dHA6Ly8iPjxzcGFuIGNsYXNzPSJtZW1iZXJzIG9mIHRoZSB3aW5kb3cubG9jYXRpb252ZXJ0aWNhbC1hbGlnbjovYT4gfCA8YSBocmVmPSI8IWRvY3R5cGUgaHRtbD5tZWRpYT0ic2NyZWVuIiA8b3B0aW9uIHZhbHVlPSJmYXZpY29uLmljbyIgLz4KCQk8ZGl2IGNsYXNzPSJjaGFyYWN0ZXJpc3RpY3MiIG1ldGhvZD0iZ2V0IiAvYm9keT4KPC9odG1sPgpzaG9ydGN1dCBpY29uIiBkb2N1bWVudC53cml0ZShwYWRkaW5nLWJvdHRvbTpyZXByZXNlbnRhdGl2ZXNzdWJtaXQiIHZhbHVlPSJhbGlnbj0iY2VudGVyIiB0aHJvdWdob3V0IHRoZSBzY2llbmNlIGZpY3Rpb24KICA8ZGl2IGNsYXNzPSJzdWJtaXQiIGNsYXNzPSJvbmUgb2YgdGhlIG1vc3QgdmFsaWduPSJ0b3AiPjx3YXMgZXN0YWJsaXNoZWQpOw0KPC9zY3JpcHQ+DQpyZXR1cm4gZmFsc2U7Ij4pLnN0eWxlLmRpc3BsYXliZWNhdXNlIG9mIHRoZSBkb2N1bWVudC5jb29raWU8Zm9ybSBhY3Rpb249Ii99Ym9keXttYXJnaW46MDtFbmN5Y2xvcGVkaWEgb2Z2ZXJzaW9uIG9mIHRoZSAuY3JlYXRlRWxlbWVudChuYW1lIiBjb250ZW50PSI8L2Rpdj4KPC9kaXY+CgphZG1pbmlzdHJhdGl2ZSA8L2JvZHk+CjwvaHRtbD5oaXN0b3J5IG9mIHRoZSAiPjxpbnB1dCB0eXBlPSJwb3J0aW9uIG9mIHRoZSBhcyBwYXJ0IG9mIHRoZSAmbmJzcDs8YSBocmVmPSJvdGhlciBjb3VudHJpZXMiPgo8ZGl2IGNsYXNzPSI8L3NwYW4+PC9zcGFuPjxJbiBvdGhlciB3b3JkcyxkaXNwbGF5OiBibG9jaztjb250cm9sIG9mIHRoZSBpbnRyb2R1Y3Rpb24gb2YvPgo8bWV0YSBuYW1lPSJhcyB3ZWxsIGFzIHRoZSBpbiByZWNlbnQgeWVhcnMNCgk8ZGl2IGNsYXNzPSI8L2Rpdj4KCTwvZGl2PgppbnNwaXJlZCBieSB0aGV0aGUgZW5kIG9mIHRoZSBjb21wYXRpYmxlIHdpdGhiZWNhbWUga25vd24gYXMgc3R5bGU9Im1hcmdpbjouanMiPjwvc2NyaXB0PjwgSW50ZXJuYXRpb25hbCB0aGVyZSBoYXZlIGJlZW5HZXJtYW4gbGFuZ3VhZ2Ugc3R5bGU9ImNvbG9yOiNDb21tdW5pc3QgUGFydHljb25zaXN0ZW50IHdpdGhib3JkZXI9IjAiIGNlbGwgbWFyZ2luaGVpZ2h0PSJ0aGUgbWFqb3JpdHkgb2YiIGFsaWduPSJjZW50ZXJyZWxhdGVkIHRvIHRoZSBtYW55IGRpZmZlcmVudCBPcnRob2RveCBDaHVyY2hzaW1pbGFyIHRvIHRoZSAvPgo8bGluayByZWw9InN3YXMgb25lIG9mIHRoZSB1bnRpbCBoaXMgZGVhdGh9KSgpOwo8L3NjcmlwdD5vdGhlciBsYW5ndWFnZXNjb21wYXJlZCB0byB0aGVwb3J0aW9ucyBvZiB0aGV0aGUgTmV0aGVybGFuZHN0aGUgbW9zdCBjb21tb25iYWNrZ3JvdW5kOnVybChhcmd1ZWQgdGhhdCB0aGVzY3JvbGxpbmc9Im5vIiBpbmNsdWRlZCBpbiB0aGVOb3J0aCBBbWVyaWNhbiB0aGUgbmFtZSBvZiB0aGVpbnRlcnByZXRhdGlvbnN0aGUgdHJhZGl0aW9uYWxkZXZlbG9wbWVudCBvZiBmcmVxdWVudGx5IHVzZWRhIGNvbGxlY3Rpb24gb2Z2ZXJ5IHNpbWlsYXIgdG9zdXJyb3VuZGluZyB0aGVleGFtcGxlIG9mIHRoaXNhbGlnbj0iY2VudGVyIj53b3VsZCBoYXZlIGJlZW5pbWFnZV9jYXB0aW9uID1hdHRhY2hlZCB0byB0aGVzdWdnZXN0aW5nIHRoYXRpbiB0aGUgZm9ybSBvZiBpbnZvbHZlZCBpbiB0aGVpcyBkZXJpdmVkIGZyb21uYW1lZCBhZnRlciB0aGVJbnRyb2R1Y3Rpb24gdG9yZXN0cmljdGlvbnMgb24gc3R5bGU9IndpZHRoOiBjYW4gYmUgdXNlZCB0byB0aGUgY3JlYXRpb24gb2Ztb3N0IGltcG9ydGFudCBpbmZvcm1hdGlvbiBhbmRyZXN1bHRlZCBpbiB0aGVjb2xsYXBzZSBvZiB0aGVUaGlzIG1lYW5zIHRoYXRlbGVtZW50cyBvZiB0aGV3YXMgcmVwbGFjZWQgYnlhbmFseXNpcyBvZiB0aGVpbnNwaXJhdGlvbiBmb3JyZWdhcmRlZCBhcyB0aGVtb3N0IHN1Y2Nlc3NmdWxrbm93biBhcyAmcXVvdDthIGNvbXByZWhlbnNpdmVIaXN0b3J5IG9mIHRoZSB3ZXJlIGNvbnNpZGVyZWRyZXR1cm5lZCB0byB0aGVhcmUgcmVmZXJyZWQgdG9VbnNvdXJjZWQgaW1hZ2U+Cgk8ZGl2IGNsYXNzPSJjb25zaXN0cyBvZiB0aGVzdG9wUHJvcGFnYXRpb25pbnRlcmVzdCBpbiB0aGVhdmFpbGFiaWxpdHkgb2ZhcHBlYXJzIHRvIGhhdmVlbGVjdHJvbWFnbmV0aWNlbmFibGVTZXJ2aWNlcyhmdW5jdGlvbiBvZiB0aGVJdCBpcyBpbXBvcnRhbnQ8L3NjcmlwdD48L2Rpdj5mdW5jdGlvbigpe3ZhciByZWxhdGl2ZSB0byB0aGVhcyBhIHJlc3VsdCBvZiB0aGUgcG9zaXRpb24gb2ZGb3IgZXhhbXBsZSwgaW4gbWV0aG9kPSJwb3N0IiB3YXMgZm9sbG93ZWQgYnkmYW1wO21kYXNoOyB0aGV0aGUgYXBwbGljYXRpb25qcyI+PC9zY3JpcHQ+DQp1bD48L2Rpdj48L2Rpdj5hZnRlciB0aGUgZGVhdGh3aXRoIHJlc3BlY3QgdG9zdHlsZT0icGFkZGluZzppcyBwYXJ0aWN1bGFybHlkaXNwbGF5OmlubGluZTsgdHlwZT0ic3VibWl0IiBpcyBkaXZpZGVkIGludG/kuK3mlocgKOeugOS9kylyZXNwb25zYWJpbGlkYWRhZG1pbmlzdHJhY2nDs25pbnRlcm5hY2lvbmFsZXNjb3JyZXNwb25kaWVudGXgpIngpKrgpK/gpYvgpJfgpKrgpYLgpLDgpY3gpLXgpLngpK7gpL7gpLDgpYfgpLLgpYvgpJfgpYvgpILgpJrgpYHgpKjgpL7gpLXgpLLgpYfgpJXgpL/gpKjgpLjgpLDgpJXgpL7gpLDgpKrgpYHgpLLgpL/gpLjgpJbgpYvgpJzgpYfgpILgpJrgpL7gpLngpL/gpI/gpK3gpYfgpJzgpYfgpILgpLbgpL7gpK7gpL/gpLLgpLngpK7gpL7gpLDgpYDgpJzgpL7gpJfgpLDgpKPgpKzgpKjgpL7gpKjgpYfgpJXgpYHgpK7gpL7gpLDgpKzgpY3gpLLgpYngpJfgpK7gpL7gpLLgpL/gpJXgpK7gpLngpL/gpLLgpL7gpKrgpYPgpLfgpY3gpKDgpKzgpKLgpLzgpKTgpYfgpK3gpL7gpJzgpKrgpL7gpJXgpY3gpLLgpL/gpJXgpJ/gpY3gpLDgpYfgpKjgpJbgpL/gpLLgpL7gpKvgpKbgpYzgpLDgpL7gpKjgpK7gpL7gpK7gpLLgpYfgpK7gpKTgpKbgpL7gpKjgpKzgpL7gpJzgpL7gpLDgpLXgpL/gpJXgpL7gpLjgpJXgpY3gpK/gpYvgpILgpJrgpL7gpLngpKTgpYfgpKrgpLngpYHgpIHgpJrgpKzgpKTgpL7gpK/gpL7gpLjgpILgpLXgpL7gpKbgpKbgpYfgpJbgpKjgpYfgpKrgpL/gpJvgpLLgpYfgpLXgpL/gpLbgpYfgpLfgpLDgpL7gpJzgpY3gpK/gpIngpKTgpY3gpKTgpLDgpK7gpYHgpILgpKzgpIjgpKbgpYvgpKjgpYvgpILgpIngpKrgpJXgpLDgpKPgpKrgpKLgpLzgpYfgpILgpLjgpY3gpKXgpL/gpKTgpKvgpL/gpLLgpY3gpK7gpK7gpYHgpJbgpY3gpK/gpIXgpJrgpY3gpJvgpL7gpJvgpYLgpJ/gpKTgpYDgpLjgpILgpJfgpYDgpKTgpJzgpL7gpI/gpJfgpL7gpLXgpL/gpK3gpL7gpJfgpJjgpKPgpY3gpJ/gpYfgpKbgpYLgpLjgpLDgpYfgpKbgpL/gpKjgpYvgpILgpLngpKTgpY3gpK/gpL7gpLjgpYfgpJXgpY3gpLjgpJfgpL7gpILgpKfgpYDgpLXgpL/gpLbgpY3gpLXgpLDgpL7gpKTgpYfgpILgpKbgpYjgpJ/gpY3gpLjgpKjgpJXgpY3gpLbgpL7gpLjgpL7gpK7gpKjgpYfgpIXgpKbgpL7gpLLgpKTgpKzgpL/gpJzgpLLgpYDgpKrgpYHgpLDgpYLgpLfgpLngpL/gpILgpKbgpYDgpK7gpL/gpKTgpY3gpLDgpJXgpLXgpL/gpKTgpL7gpLDgpYHgpKrgpK/gpYfgpLjgpY3gpKXgpL7gpKjgpJXgpLDgpYvgpKHgpLzgpK7gpYHgpJXgpY3gpKTgpK/gpYvgpJzgpKjgpL7gpJXgpYPgpKrgpK/gpL7gpKrgpYvgpLjgpY3gpJ/gpJjgpLDgpYfgpLLgpYLgpJXgpL7gpLDgpY3gpK/gpLXgpL/gpJrgpL7gpLDgpLjgpYLgpJrgpKjgpL7gpK7gpYLgpLLgpY3gpK/gpKbgpYfgpJbgpYfgpILgpLngpK7gpYfgpLbgpL7gpLjgpY3gpJXgpYLgpLLgpK7gpYjgpILgpKjgpYfgpKTgpYjgpK/gpL7gpLDgpJzgpL/gpLjgpJXgpYdyc3MreG1sIiB0aXRsZT0iLXR5cGUiIGNvbnRlbnQ9InRpdGxlIiBjb250ZW50PSJhdCB0aGUgc2FtZSB0aW1lLmpzIj48L3NjcmlwdD4KPCIgbWV0aG9kPSJwb3N0IiA8L3NwYW4+PC9hPjwvbGk+dmVydGljYWwtYWxpZ246dC9qcXVlcnkubWluLmpzIj4uY2xpY2soZnVuY3Rpb24oIHN0eWxlPSJwYWRkaW5nLX0pKCk7Cjwvc2NyaXB0Pgo8L3NwYW4+PGEgaHJlZj0iPGEgaHJlZj0iaHR0cDovLyk7IHJldHVybiBmYWxzZTt0ZXh0LWRlY29yYXRpb246IHNjcm9sbGluZz0ibm8iIGJvcmRlci1jb2xsYXBzZTphc3NvY2lhdGVkIHdpdGggQmFoYXNhIEluZG9uZXNpYUVuZ2xpc2ggbGFuZ3VhZ2U8dGV4dCB4bWw6c3BhY2U9LmdpZiIgYm9yZGVyPSIwIjwvYm9keT4KPC9odG1sPgpvdmVyZmxvdzpoaWRkZW47aW1nIHNyYz0iaHR0cDovL2FkZEV2ZW50TGlzdGVuZXJyZXNwb25zaWJsZSBmb3Igcy5qcyI+PC9zY3JpcHQ+Ci9mYXZpY29uLmljbyIgLz5vcGVyYXRpbmcgc3lzdGVtIiBzdHlsZT0id2lkdGg6MXRhcmdldD0iX2JsYW5rIj5TdGF0ZSBVbml2ZXJzaXR5dGV4dC1hbGlnbjpsZWZ0Owpkb2N1bWVudC53cml0ZSgsIGluY2x1ZGluZyB0aGUgYXJvdW5kIHRoZSB3b3JsZCk7DQo8L3NjcmlwdD4NCjwiIHN0eWxlPSJoZWlnaHQ6O292ZXJmbG93OmhpZGRlbm1vcmUgaW5mb3JtYXRpb25hbiBpbnRlcm5hdGlvbmFsYSBtZW1iZXIgb2YgdGhlIG9uZSBvZiB0aGUgZmlyc3RjYW4gYmUgZm91bmQgaW4gPC9kaXY+CgkJPC9kaXY+CmRpc3BsYXk6IG5vbmU7Ij4iIC8+CjxsaW5rIHJlbD0iCiAgKGZ1bmN0aW9uKCkge3RoZSAxNXRoIGNlbnR1cnkucHJldmVudERlZmF1bHQobGFyZ2UgbnVtYmVyIG9mIEJ5emFudGluZSBFbXBpcmUuanBnfHRodW1ifGxlZnR8dmFzdCBtYWpvcml0eSBvZm1ham9yaXR5IG9mIHRoZSAgYWxpZ249ImNlbnRlciI+VW5pdmVyc2l0eSBQcmVzc2RvbWluYXRlZCBieSB0aGVTZWNvbmQgV29ybGQgV2FyZGlzdHJpYnV0aW9uIG9mIHN0eWxlPSJwb3NpdGlvbjp0aGUgcmVzdCBvZiB0aGUgY2hhcmFjdGVyaXplZCBieSByZWw9Im5vZm9sbG93Ij5kZXJpdmVzIGZyb20gdGhlcmF0aGVyIHRoYW4gdGhlIGEgY29tYmluYXRpb24gb2ZzdHlsZT0id2lkdGg6MTAwRW5nbGlzaC1zcGVha2luZ2NvbXB1dGVyIHNjaWVuY2Vib3JkZXI9IjAiIGFsdD0idGhlIGV4aXN0ZW5jZSBvZkRlbW9jcmF0aWMgUGFydHkiIHN0eWxlPSJtYXJnaW4tRm9yIHRoaXMgcmVhc29uLC5qcyI+PC9zY3JpcHQ+CglzQnlUYWdOYW1lKHMpWzBdanMiPjwvc2NyaXB0Pg0KPC5qcyI+PC9zY3JpcHQ+DQpsaW5rIHJlbD0iaWNvbiIgJyBhbHQ9JycgY2xhc3M9J2Zvcm1hdGlvbiBvZiB0aGV2ZXJzaW9ucyBvZiB0aGUgPC9hPjwvZGl2PjwvZGl2Pi9wYWdlPgogIDxwYWdlPgo8ZGl2IGNsYXNzPSJjb250YmVjYW1lIHRoZSBmaXJzdGJhaGFzYSBJbmRvbmVzaWFlbmdsaXNoIChzaW1wbGUpzpXOu867zrfOvc65zrrOrNGF0YDQstCw0YLRgdC60LjQutC+0LzQv9Cw0L3QuNC40Y/QstC70Y/QtdGC0YHRj9CU0L7QsdCw0LLQuNGC0YzRh9C10LvQvtCy0LXQutCw0YDQsNC30LLQuNGC0LjRj9CY0L3RgtC10YDQvdC10YLQntGC0LLQtdGC0LjRgtGM0L3QsNC/0YDQuNC80LXRgNC40L3RgtC10YDQvdC10YLQutC+0YLQvtGA0L7Qs9C+0YHRgtGA0LDQvdC40YbRi9C60LDRh9C10YHRgtCy0LXRg9GB0LvQvtCy0LjRj9GF0L/RgNC+0LHQu9C10LzRi9C/0L7Qu9GD0YfQuNGC0YzRj9Cy0LvRj9GO0YLRgdGP0L3QsNC40LHQvtC70LXQtdC60L7QvNC/0LDQvdC40Y/QstC90LjQvNCw0L3QuNC10YHRgNC10LTRgdGC0LLQsNin2YTZhdmI2KfYttmK2LnYp9mE2LHYptmK2LPZitip2KfZhNin2YbYqtmC2KfZhNmF2LTYp9ix2YPYp9iq2YPYp9mE2LPZitin2LHYp9iq2KfZhNmF2YPYqtmI2KjYqdin2YTYs9i52YjYr9mK2KnYp9it2LXYp9im2YrYp9iq2KfZhNi52KfZhNmF2YrYqdin2YTYtdmI2KrZitin2KrYp9mE2KfZhtiq2LHZhtiq2KfZhNiq2LXYp9mF2YrZhdin2YTYpdiz2YTYp9mF2YrYp9mE2YXYtNin2LHZg9ip2KfZhNmF2LHYptmK2KfYqnJvYm90cyIgY29udGVudD0iPGRpdiBpZD0iZm9vdGVyIj50aGUgVW5pdGVkIFN0YXRlczxpbWcgc3JjPSJodHRwOi8vLmpwZ3xyaWdodHx0aHVtYnwuanMiPjwvc2NyaXB0Pg0KPGxvY2F0aW9uLnByb3RvY29sZnJhbWVib3JkZXI9IjAiIHMiIC8+CjxtZXRhIG5hbWU9IjwvYT48L2Rpdj48L2Rpdj48Zm9udC13ZWlnaHQ6Ym9sZDsmcXVvdDsgYW5kICZxdW90O2RlcGVuZGluZyBvbiB0aGUgbWFyZ2luOjA7cGFkZGluZzoiIHJlbD0ibm9mb2xsb3ciIFByZXNpZGVudCBvZiB0aGUgdHdlbnRpZXRoIGNlbnR1cnlldmlzaW9uPgogIDwvcGFnZUludGVybmV0IEV4cGxvcmVyYS5hc3luYyA9IHRydWU7DQppbmZvcm1hdGlvbiBhYm91dDxkaXYgaWQ9ImhlYWRlciI+IiBhY3Rpb249Imh0dHA6Ly88YSBocmVmPSJodHRwczovLzxkaXYgaWQ9ImNvbnRlbnQiPC9kaXY+DQo8L2Rpdj4NCjxkZXJpdmVkIGZyb20gdGhlIDxpbWcgc3JjPSdodHRwOi8vYWNjb3JkaW5nIHRvIHRoZSAKPC9ib2R5Pgo8L2h0bWw+CnN0eWxlPSJmb250LXNpemU6c2NyaXB0IGxhbmd1YWdlPSJBcmlhbCwgSGVsdmV0aWNhLDwvYT48c3BhbiBjbGFzcz0iPC9zY3JpcHQ+PHNjcmlwdCBwb2xpdGljYWwgcGFydGllc3RkPjwvdHI+PC90YWJsZT48aHJlZj0iaHR0cDovL3d3dy5pbnRlcnByZXRhdGlvbiBvZnJlbD0ic3R5bGVzaGVldCIgZG9jdW1lbnQud3JpdGUoJzxjaGFyc2V0PSJ1dGYtOCI+CmJlZ2lubmluZyBvZiB0aGUgcmV2ZWFsZWQgdGhhdCB0aGV0ZWxldmlzaW9uIHNlcmllcyIgcmVsPSJub2ZvbGxvdyI+IHRhcmdldD0iX2JsYW5rIj5jbGFpbWluZyB0aGF0IHRoZWh0dHAlM0ElMkYlMkZ3d3cubWFuaWZlc3RhdGlvbnMgb2ZQcmltZSBNaW5pc3RlciBvZmluZmx1ZW5jZWQgYnkgdGhlY2xhc3M9ImNsZWFyZml4Ij4vZGl2Pg0KPC9kaXY+DQoNCnRocmVlLWRpbWVuc2lvbmFsQ2h1cmNoIG9mIEVuZ2xhbmRvZiBOb3J0aCBDYXJvbGluYXNxdWFyZSBraWxvbWV0cmVzLmFkZEV2ZW50TGlzdGVuZXJkaXN0aW5jdCBmcm9tIHRoZWNvbW1vbmx5IGtub3duIGFzUGhvbmV0aWMgQWxwaGFiZXRkZWNsYXJlZCB0aGF0IHRoZWNvbnRyb2xsZWQgYnkgdGhlQmVuamFtaW4gRnJhbmtsaW5yb2xlLXBsYXlpbmcgZ2FtZXRoZSBVbml2ZXJzaXR5IG9maW4gV2VzdGVybiBFdXJvcGVwZXJzb25hbCBjb21wdXRlclByb2plY3QgR3V0ZW5iZXJncmVnYXJkbGVzcyBvZiB0aGVoYXMgYmVlbiBwcm9wb3NlZHRvZ2V0aGVyIHdpdGggdGhlPjwvbGk+PGxpIGNsYXNzPSJpbiBzb21lIGNvdW50cmllc21pbi5qcyI+PC9zY3JpcHQ+b2YgdGhlIHBvcHVsYXRpb25vZmZpY2lhbCBsYW5ndWFnZTxpbWcgc3JjPSJpbWFnZXMvaWRlbnRpZmllZCBieSB0aGVuYXR1cmFsIHJlc291cmNlc2NsYXNzaWZpY2F0aW9uIG9mY2FuIGJlIGNvbnNpZGVyZWRxdWFudHVtIG1lY2hhbmljc05ldmVydGhlbGVzcywgdGhlbWlsbGlvbiB5ZWFycyBhZ288L2JvZHk+DQo8L2h0bWw+Dc6VzrvOu863zr3Ouc66zqwKdGFrZSBhZHZhbnRhZ2Ugb2ZhbmQsIGFjY29yZGluZyB0b2F0dHJpYnV0ZWQgdG8gdGhlTWljcm9zb2Z0IFdpbmRvd3N0aGUgZmlyc3QgY2VudHVyeXVuZGVyIHRoZSBjb250cm9sZGl2IGNsYXNzPSJoZWFkZXJzaG9ydGx5IGFmdGVyIHRoZW5vdGFibGUgZXhjZXB0aW9udGVucyBvZiB0aG91c2FuZHNzZXZlcmFsIGRpZmZlcmVudGFyb3VuZCB0aGUgd29ybGQucmVhY2hpbmcgbWlsaXRhcnlpc29sYXRlZCBmcm9tIHRoZW9wcG9zaXRpb24gdG8gdGhldGhlIE9sZCBUZXN0YW1lbnRBZnJpY2FuIEFtZXJpY2Fuc2luc2VydGVkIGludG8gdGhlc2VwYXJhdGUgZnJvbSB0aGVtZXRyb3BvbGl0YW4gYXJlYW1ha2VzIGl0IHBvc3NpYmxlYWNrbm93bGVkZ2VkIHRoYXRhcmd1YWJseSB0aGUgbW9zdHR5cGU9InRleHQvY3NzIj4KdGhlIEludGVybmF0aW9uYWxBY2NvcmRpbmcgdG8gdGhlIHBlPSJ0ZXh0L2NzcyIgLz4KY29pbmNpZGUgd2l0aCB0aGV0d28tdGhpcmRzIG9mIHRoZUR1cmluZyB0aGlzIHRpbWUsZHVyaW5nIHRoZSBwZXJpb2Rhbm5vdW5jZWQgdGhhdCBoZXRoZSBpbnRlcm5hdGlvbmFsYW5kIG1vcmUgcmVjZW50bHliZWxpZXZlZCB0aGF0IHRoZWNvbnNjaW91c25lc3MgYW5kZm9ybWVybHkga25vd24gYXNzdXJyb3VuZGVkIGJ5IHRoZWZpcnN0IGFwcGVhcmVkIGlub2NjYXNpb25hbGx5IHVzZWRwb3NpdGlvbjphYnNvbHV0ZTsiIHRhcmdldD0iX2JsYW5rIiBwb3NpdGlvbjpyZWxhdGl2ZTt0ZXh0LWFsaWduOmNlbnRlcjtqYXgvbGlicy9qcXVlcnkvMS5iYWNrZ3JvdW5kLWNvbG9yOiN0eXBlPSJhcHBsaWNhdGlvbi9hbmd1YWdlIiBjb250ZW50PSI8bWV0YSBodHRwLWVxdWl2PSJQcml2YWN5IFBvbGljeTwvYT5lKCIlM0NzY3JpcHQgc3JjPSciIHRhcmdldD0iX2JsYW5rIj5PbiB0aGUgb3RoZXIgaGFuZCwuanBnfHRodW1ifHJpZ2h0fDI8L2Rpdj48ZGl2IGNsYXNzPSI8ZGl2IHN0eWxlPSJmbG9hdDpuaW5ldGVlbnRoIGNlbnR1cnk8L2JvZHk+DQo8L2h0bWw+DQo8aW1nIHNyYz0iaHR0cDovL3M7dGV4dC1hbGlnbjpjZW50ZXJmb250LXdlaWdodDogYm9sZDsgQWNjb3JkaW5nIHRvIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4iIGZyYW1lYm9yZGVyPSIwIiAiIHN0eWxlPSJwb3NpdGlvbjpsaW5rIGhyZWY9Imh0dHA6Ly9odG1sNC9sb29zZS5kdGQiPgpkdXJpbmcgdGhpcyBwZXJpb2Q8L3RkPjwvdHI+PC90YWJsZT5jbG9zZWx5IHJlbGF0ZWQgdG9mb3IgdGhlIGZpcnN0IHRpbWU7Zm9udC13ZWlnaHQ6Ym9sZDtpbnB1dCB0eXBlPSJ0ZXh0IiA8c3BhbiBzdHlsZT0iZm9udC1vbnJlYWR5c3RhdGVjaGFuZ2UJPGRpdiBjbGFzcz0iY2xlYXJkb2N1bWVudC5sb2NhdGlvbi4gRm9yIGV4YW1wbGUsIHRoZSBhIHdpZGUgdmFyaWV0eSBvZiA8IURPQ1RZUEUgaHRtbD4NCjwmbmJzcDsmbmJzcDsmbmJzcDsiPjxhIGhyZWY9Imh0dHA6Ly9zdHlsZT0iZmxvYXQ6bGVmdDtjb25jZXJuZWQgd2l0aCB0aGU9aHR0cCUzQSUyRiUyRnd3dy5pbiBwb3B1bGFyIGN1bHR1cmV0eXBlPSJ0ZXh0L2NzcyIgLz5pdCBpcyBwb3NzaWJsZSB0byBIYXJ2YXJkIFVuaXZlcnNpdHl0eWxlc2hlZXQiIGhyZWY9Ii90aGUgbWFpbiBjaGFyYWN0ZXJPeGZvcmQgVW5pdmVyc2l0eSAgbmFtZT0ia2V5d29yZHMiIGNzdHlsZT0idGV4dC1hbGlnbjp0aGUgVW5pdGVkIEtpbmdkb21mZWRlcmFsIGdvdmVybm1lbnQ8ZGl2IHN0eWxlPSJtYXJnaW4gZGVwZW5kaW5nIG9uIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGU8ZGl2IGNsYXNzPSJoZWFkZXIubWluLmpzIj48L3NjcmlwdD5kZXN0cnVjdGlvbiBvZiB0aGVzbGlnaHRseSBkaWZmZXJlbnRpbiBhY2NvcmRhbmNlIHdpdGh0ZWxlY29tbXVuaWNhdGlvbnNpbmRpY2F0ZXMgdGhhdCB0aGVzaG9ydGx5IHRoZXJlYWZ0ZXJlc3BlY2lhbGx5IGluIHRoZSBFdXJvcGVhbiBjb3VudHJpZXNIb3dldmVyLCB0aGVyZSBhcmVzcmM9Imh0dHA6Ly9zdGF0aWNzdWdnZXN0ZWQgdGhhdCB0aGUiIHNyYz0iaHR0cDovL3d3dy5hIGxhcmdlIG51bWJlciBvZiBUZWxlY29tbXVuaWNhdGlvbnMiIHJlbD0ibm9mb2xsb3ciIHRIb2x5IFJvbWFuIEVtcGVyb3JhbG1vc3QgZXhjbHVzaXZlbHkiIGJvcmRlcj0iMCIgYWx0PSJTZWNyZXRhcnkgb2YgU3RhdGVjdWxtaW5hdGluZyBpbiB0aGVDSUEgV29ybGQgRmFjdGJvb2t0aGUgbW9zdCBpbXBvcnRhbnRhbm5pdmVyc2FyeSBvZiB0aGVzdHlsZT0iYmFja2dyb3VuZC08bGk+PGVtPjxhIGhyZWY9Ii90aGUgQXRsYW50aWMgT2NlYW5zdHJpY3RseSBzcGVha2luZyxzaG9ydGx5IGJlZm9yZSB0aGVkaWZmZXJlbnQgdHlwZXMgb2Z0aGUgT3R0b21hbiBFbXBpcmU+PGltZyBzcmM9Imh0dHA6Ly9BbiBJbnRyb2R1Y3Rpb24gdG9jb25zZXF1ZW5jZSBvZiB0aGVkZXBhcnR1cmUgZnJvbSB0aGVDb25mZWRlcmF0ZSBTdGF0ZXNpbmRpZ2Vub3VzIHBlb3BsZXNQcm9jZWVkaW5ncyBvZiB0aGVpbmZvcm1hdGlvbiBvbiB0aGV0aGVvcmllcyBoYXZlIGJlZW5pbnZvbHZlbWVudCBpbiB0aGVkaXZpZGVkIGludG8gdGhyZWVhZGphY2VudCBjb3VudHJpZXNpcyByZXNwb25zaWJsZSBmb3JkaXNzb2x1dGlvbiBvZiB0aGVjb2xsYWJvcmF0aW9uIHdpdGh3aWRlbHkgcmVnYXJkZWQgYXNoaXMgY29udGVtcG9yYXJpZXNmb3VuZGluZyBtZW1iZXIgb2ZEb21pbmljYW4gUmVwdWJsaWNnZW5lcmFsbHkgYWNjZXB0ZWR0aGUgcG9zc2liaWxpdHkgb2ZhcmUgYWxzbyBhdmFpbGFibGV1bmRlciBjb25zdHJ1Y3Rpb25yZXN0b3JhdGlvbiBvZiB0aGV0aGUgZ2VuZXJhbCBwdWJsaWNpcyBhbG1vc3QgZW50aXJlbHlwYXNzZXMgdGhyb3VnaCB0aGVoYXMgYmVlbiBzdWdnZXN0ZWRjb21wdXRlciBhbmQgdmlkZW9HZXJtYW5pYyBsYW5ndWFnZXMgYWNjb3JkaW5nIHRvIHRoZSBkaWZmZXJlbnQgZnJvbSB0aGVzaG9ydGx5IGFmdGVyd2FyZHNocmVmPSJodHRwczovL3d3dy5yZWNlbnQgZGV2ZWxvcG1lbnRCb2FyZCBvZiBEaXJlY3RvcnM8ZGl2IGNsYXNzPSJzZWFyY2h8IDxhIGhyZWY9Imh0dHA6Ly9JbiBwYXJ0aWN1bGFyLCB0aGVNdWx0aXBsZSBmb290bm90ZXNvciBvdGhlciBzdWJzdGFuY2V0aG91c2FuZHMgb2YgeWVhcnN0cmFuc2xhdGlvbiBvZiB0aGU8L2Rpdj4NCjwvZGl2Pg0KDQo8YSBocmVmPSJpbmRleC5waHB3YXMgZXN0YWJsaXNoZWQgaW5taW4uanMiPjwvc2NyaXB0PgpwYXJ0aWNpcGF0ZSBpbiB0aGVhIHN0cm9uZyBpbmZsdWVuY2VzdHlsZT0ibWFyZ2luLXRvcDpyZXByZXNlbnRlZCBieSB0aGVncmFkdWF0ZWQgZnJvbSB0aGVUcmFkaXRpb25hbGx5LCB0aGVFbGVtZW50KCJzY3JpcHQiKTtIb3dldmVyLCBzaW5jZSB0aGUvZGl2Pgo8L2Rpdj4KPGRpdiBsZWZ0OyBtYXJnaW4tbGVmdDpwcm90ZWN0aW9uIGFnYWluc3QwOyB2ZXJ0aWNhbC1hbGlnbjpVbmZvcnR1bmF0ZWx5LCB0aGV0eXBlPSJpbWFnZS94LWljb24vZGl2Pgo8ZGl2IGNsYXNzPSIgY2xhc3M9ImNsZWFyZml4Ij48ZGl2IGNsYXNzPSJmb290ZXIJCTwvZGl2PgoJCTwvZGl2Pgp0aGUgbW90aW9uIHBpY3R1cmXQkdGK0LvQs9Cw0YDRgdC60LjQsdGK0LvQs9Cw0YDRgdC60LjQpNC10LTQtdGA0LDRhtC40LjQvdC10YHQutC+0LvRjNC60L7RgdC+0L7QsdGJ0LXQvdC40LXRgdC+0L7QsdGJ0LXQvdC40Y/Qv9GA0L7Qs9GA0LDQvNC80YvQntGC0L/RgNCw0LLQuNGC0YzQsdC10YHQv9C70LDRgtC90L7QvNCw0YLQtdGA0LjQsNC70YvQv9C+0LfQstC+0LvRj9C10YLQv9C+0YHQu9C10LTQvdC40LXRgNCw0LfQu9C40YfQvdGL0YXQv9GA0L7QtNGD0LrRhtC40LjQv9GA0L7Qs9GA0LDQvNC80LDQv9C+0LvQvdC+0YHRgtGM0Y7QvdCw0YXQvtC00LjRgtGB0Y/QuNC30LHRgNCw0L3QvdC+0LXQvdCw0YHQtdC70LXQvdC40Y/QuNC30LzQtdC90LXQvdC40Y/QutCw0YLQtdCz0L7RgNC40LjQkNC70LXQutGB0LDQvdC00YDgpKbgpY3gpLXgpL7gpLDgpL7gpK7gpYjgpKjgpYHgpIXgpLLgpKrgpY3gpLDgpKbgpL7gpKjgpK3gpL7gpLDgpKTgpYDgpK/gpIXgpKjgpYHgpKbgpYfgpLbgpLngpL/gpKjgpY3gpKbgpYDgpIfgpILgpKHgpL/gpK/gpL7gpKbgpL/gpLLgpY3gpLLgpYDgpIXgpKfgpL/gpJXgpL7gpLDgpLXgpYDgpKHgpL/gpK/gpYvgpJrgpL/gpJ/gpY3gpKDgpYfgpLjgpK7gpL7gpJrgpL7gpLDgpJzgpILgpJXgpY3gpLbgpKjgpKbgpYHgpKjgpL/gpK/gpL7gpKrgpY3gpLDgpK/gpYvgpJfgpIXgpKjgpYHgpLjgpL7gpLDgpJHgpKjgpLLgpL7gpIfgpKjgpKrgpL7gpLDgpY3gpJ/gpYDgpLbgpLDgpY3gpKTgpYvgpILgpLLgpYvgpJXgpLjgpK3gpL7gpKvgpLzgpY3gpLLgpYjgpLbgpLbgpLDgpY3gpKTgpYfgpILgpKrgpY3gpLDgpKbgpYfgpLbgpKrgpY3gpLLgpYfgpK/gpLDgpJXgpYfgpILgpKbgpY3gpLDgpLjgpY3gpKXgpL/gpKTgpL/gpIngpKTgpY3gpKrgpL7gpKbgpIngpKjgpY3gpLngpYfgpILgpJrgpL/gpJ/gpY3gpKDgpL7gpK/gpL7gpKTgpY3gpLDgpL7gpJzgpY3gpK/gpL7gpKbgpL7gpKrgpYHgpLDgpL7gpKjgpYfgpJzgpYvgpKHgpLzgpYfgpILgpIXgpKjgpYHgpLXgpL7gpKbgpLbgpY3gpLDgpYfgpKPgpYDgpLbgpL/gpJXgpY3gpLfgpL7gpLjgpLDgpJXgpL7gpLDgpYDgpLjgpILgpJfgpY3gpLDgpLngpKrgpLDgpL/gpKPgpL7gpK7gpKzgpY3gpLDgpL7gpILgpKHgpKzgpJrgpY3gpJrgpYvgpILgpIngpKrgpLLgpKzgpY3gpKfgpK7gpILgpKTgpY3gpLDgpYDgpLjgpILgpKrgpLDgpY3gpJXgpIngpK7gpY3gpK7gpYDgpKbgpK7gpL7gpKfgpY3gpK/gpK7gpLjgpLngpL7gpK/gpKTgpL7gpLbgpKzgpY3gpKbgpYvgpILgpK7gpYDgpKHgpL/gpK/gpL7gpIbgpIjgpKrgpYDgpI/gpLLgpK7gpYvgpKzgpL7gpIfgpLLgpLjgpILgpJbgpY3gpK/gpL7gpIbgpKrgpLDgpYfgpLbgpKjgpIXgpKjgpYHgpKzgpILgpKfgpKzgpL7gpJzgpLzgpL7gpLDgpKjgpLXgpYDgpKjgpKTgpK7gpKrgpY3gpLDgpK7gpYHgpJbgpKrgpY3gpLDgpLbgpY3gpKjgpKrgpLDgpL/gpLXgpL7gpLDgpKjgpYHgpJXgpLjgpL7gpKjgpLjgpK7gpLDgpY3gpKXgpKjgpIbgpK/gpYvgpJzgpL/gpKTgpLjgpYvgpK7gpLXgpL7gpLDYp9mE2YXYtNin2LHZg9in2KrYp9mE2YXZhtiq2K/Zitin2KrYp9mE2YPZhdio2YrZiNiq2LHYp9mE2YXYtNin2YfYr9in2KrYudiv2K/Yp9mE2LLZiNin2LHYudiv2K/Yp9mE2LHYr9mI2K/Yp9mE2KXYs9mE2KfZhdmK2KnYp9mE2YHZiNiq2YjYtNmI2KjYp9mE2YXYs9in2KjZgtin2KrYp9mE2YXYudmE2YjZhdin2KrYp9mE2YXYs9mE2LPZhNin2KrYp9mE2KzYsdin2YHZitmD2LPYp9mE2KfYs9mE2KfZhdmK2KnYp9mE2KfYqti12KfZhNin2KprZXl3b3JkcyIgY29udGVudD0idzMub3JnLzE5OTkveGh0bWwiPjxhIHRhcmdldD0iX2JsYW5rIiB0ZXh0L2h0bWw7IGNoYXJzZXQ9IiB0YXJnZXQ9Il9ibGFuayI+PHRhYmxlIGNlbGxwYWRkaW5nPSJhdXRvY29tcGxldGU9Im9mZiIgdGV4dC1hbGlnbjogY2VudGVyO3RvIGxhc3QgdmVyc2lvbiBieSBiYWNrZ3JvdW5kLWNvbG9yOiAjIiBocmVmPSJodHRwOi8vd3d3Li9kaXY+PC9kaXY+PGRpdiBpZD08YSBocmVmPSIjIiBjbGFzcz0iIj48aW1nIHNyYz0iaHR0cDovL2NyaXB0IiBzcmM9Imh0dHA6Ly8KPHNjcmlwdCBsYW5ndWFnZT0iLy9FTiIgImh0dHA6Ly93d3cud2VuY29kZVVSSUNvbXBvbmVudCgiIGhyZWY9ImphdmFzY3JpcHQ6PGRpdiBjbGFzcz0iY29udGVudGRvY3VtZW50LndyaXRlKCc8c2Nwb3NpdGlvbjogYWJzb2x1dGU7c2NyaXB0IHNyYz0iaHR0cDovLyBzdHlsZT0ibWFyZ2luLXRvcDoubWluLmpzIj48L3NjcmlwdD4KPC9kaXY+CjxkaXYgY2xhc3M9InczLm9yZy8xOTk5L3hodG1sIiAKDQo8L2JvZHk+DQo8L2h0bWw+ZGlzdGluY3Rpb24gYmV0d2Vlbi8iIHRhcmdldD0iX2JsYW5rIj48bGluayBocmVmPSJodHRwOi8vZW5jb2Rpbmc9InV0Zi04Ij8+CncuYWRkRXZlbnRMaXN0ZW5lcj9hY3Rpb249Imh0dHA6Ly93d3cuaWNvbiIgaHJlZj0iaHR0cDovLyBzdHlsZT0iYmFja2dyb3VuZDp0eXBlPSJ0ZXh0L2NzcyIgLz4KbWV0YSBwcm9wZXJ0eT0ib2c6dDxpbnB1dCB0eXBlPSJ0ZXh0IiAgc3R5bGU9InRleHQtYWxpZ246dGhlIGRldmVsb3BtZW50IG9mIHR5bGVzaGVldCIgdHlwZT0idGVodG1sOyBjaGFyc2V0PXV0Zi04aXMgY29uc2lkZXJlZCB0byBiZXRhYmxlIHdpZHRoPSIxMDAlIiBJbiBhZGRpdGlvbiB0byB0aGUgY29udHJpYnV0ZWQgdG8gdGhlIGRpZmZlcmVuY2VzIGJldHdlZW5kZXZlbG9wbWVudCBvZiB0aGUgSXQgaXMgaW1wb3J0YW50IHRvIDwvc2NyaXB0PgoKPHNjcmlwdCAgc3R5bGU9ImZvbnQtc2l6ZToxPjwvc3Bhbj48c3BhbiBpZD1nYkxpYnJhcnkgb2YgQ29uZ3Jlc3M8aW1nIHNyYz0iaHR0cDovL2ltRW5nbGlzaCB0cmFuc2xhdGlvbkFjYWRlbXkgb2YgU2NpZW5jZXNkaXYgc3R5bGU9ImRpc3BsYXk6Y29uc3RydWN0aW9uIG9mIHRoZS5nZXRFbGVtZW50QnlJZChpZClpbiBjb25qdW5jdGlvbiB3aXRoRWxlbWVudCgnc2NyaXB0Jyk7IDxtZXRhIHByb3BlcnR5PSJvZzrQkdGK0LvQs9Cw0YDRgdC60LgKIHR5cGU9InRleHQiIG5hbWU9Ij5Qcml2YWN5IFBvbGljeTwvYT5hZG1pbmlzdGVyZWQgYnkgdGhlZW5hYmxlU2luZ2xlUmVxdWVzdHN0eWxlPSZxdW90O21hcmdpbjo8L2Rpdj48L2Rpdj48L2Rpdj48PjxpbWcgc3JjPSJodHRwOi8vaSBzdHlsZT0mcXVvdDtmbG9hdDpyZWZlcnJlZCB0byBhcyB0aGUgdG90YWwgcG9wdWxhdGlvbiBvZmluIFdhc2hpbmd0b24sIEQuQy4gc3R5bGU9ImJhY2tncm91bmQtYW1vbmcgb3RoZXIgdGhpbmdzLG9yZ2FuaXphdGlvbiBvZiB0aGVwYXJ0aWNpcGF0ZWQgaW4gdGhldGhlIGludHJvZHVjdGlvbiBvZmlkZW50aWZpZWQgd2l0aCB0aGVmaWN0aW9uYWwgY2hhcmFjdGVyIE94Zm9yZCBVbml2ZXJzaXR5IG1pc3VuZGVyc3RhbmRpbmcgb2ZUaGVyZSBhcmUsIGhvd2V2ZXIsc3R5bGVzaGVldCIgaHJlZj0iL0NvbHVtYmlhIFVuaXZlcnNpdHlleHBhbmRlZCB0byBpbmNsdWRldXN1YWxseSByZWZlcnJlZCB0b2luZGljYXRpbmcgdGhhdCB0aGVoYXZlIHN1Z2dlc3RlZCB0aGF0YWZmaWxpYXRlZCB3aXRoIHRoZWNvcnJlbGF0aW9uIGJldHdlZW5udW1iZXIgb2YgZGlmZmVyZW50PjwvdGQ+PC90cj48L3RhYmxlPlJlcHVibGljIG9mIElyZWxhbmQKPC9zY3JpcHQ+CjxzY3JpcHQgdW5kZXIgdGhlIGluZmx1ZW5jZWNvbnRyaWJ1dGlvbiB0byB0aGVPZmZpY2lhbCB3ZWJzaXRlIG9maGVhZHF1YXJ0ZXJzIG9mIHRoZWNlbnRlcmVkIGFyb3VuZCB0aGVpbXBsaWNhdGlvbnMgb2YgdGhlaGF2ZSBiZWVuIGRldmVsb3BlZEZlZGVyYWwgUmVwdWJsaWMgb2ZiZWNhbWUgaW5jcmVhc2luZ2x5Y29udGludWF0aW9uIG9mIHRoZU5vdGUsIGhvd2V2ZXIsIHRoYXRzaW1pbGFyIHRvIHRoYXQgb2YgY2FwYWJpbGl0aWVzIG9mIHRoZWFjY29yZGFuY2Ugd2l0aCB0aGVwYXJ0aWNpcGFudHMgaW4gdGhlZnVydGhlciBkZXZlbG9wbWVudHVuZGVyIHRoZSBkaXJlY3Rpb25pcyBvZnRlbiBjb25zaWRlcmVkaGlzIHlvdW5nZXIgYnJvdGhlcjwvdGQ+PC90cj48L3RhYmxlPjxhIGh0dHAtZXF1aXY9IlgtVUEtcGh5c2ljYWwgcHJvcGVydGllc29mIEJyaXRpc2ggQ29sdW1iaWFoYXMgYmVlbiBjcml0aWNpemVkKHdpdGggdGhlIGV4Y2VwdGlvbnF1ZXN0aW9ucyBhYm91dCB0aGVwYXNzaW5nIHRocm91Z2ggdGhlMCIgY2VsbHBhZGRpbmc9IjAiIHRob3VzYW5kcyBvZiBwZW9wbGVyZWRpcmVjdHMgaGVyZS4gRm9yaGF2ZSBjaGlsZHJlbiB1bmRlciUzRSUzQy9zY3JpcHQlM0UiKSk7PGEgaHJlZj0iaHR0cDovL3d3dy48bGk+PGEgaHJlZj0iaHR0cDovL3NpdGVfbmFtZSIgY29udGVudD0idGV4dC1kZWNvcmF0aW9uOm5vbmVzdHlsZT0iZGlzcGxheTogbm9uZTxtZXRhIGh0dHAtZXF1aXY9IlgtbmV3IERhdGUoKS5nZXRUaW1lKCkgdHlwZT0iaW1hZ2UveC1pY29uIjwvc3Bhbj48c3BhbiBjbGFzcz0ibGFuZ3VhZ2U9ImphdmFzY3JpcHR3aW5kb3cubG9jYXRpb24uaHJlZjxhIGhyZWY9ImphdmFzY3JpcHQ6LS0+DQo8c2NyaXB0IHR5cGU9InQ8YSBocmVmPSdodHRwOi8vd3d3LmhvcnRjdXQgaWNvbiIgaHJlZj0iPC9kaXY+DQo8ZGl2IGNsYXNzPSI8c2NyaXB0IHNyYz0iaHR0cDovLyIgcmVsPSJzdHlsZXNoZWV0IiB0PC9kaXY+CjxzY3JpcHQgdHlwZT0vYT4gPGEgaHJlZj0iaHR0cDovLyBhbGxvd1RyYW5zcGFyZW5jeT0iWC1VQS1Db21wYXRpYmxlIiBjb25yZWxhdGlvbnNoaXAgYmV0d2Vlbgo8L3NjcmlwdD4NCjxzY3JpcHQgPC9hPjwvbGk+PC91bD48L2Rpdj5hc3NvY2lhdGVkIHdpdGggdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlPC9hPjxhIGhyZWY9Imh0dHA6Ly88L2E+PC9saT48bGkgY2xhc3M9ImZvcm0gYWN0aW9uPSJodHRwOi8vPGRpdiBzdHlsZT0iZGlzcGxheTp0eXBlPSJ0ZXh0IiBuYW1lPSJxIjx0YWJsZSB3aWR0aD0iMTAwJSIgYmFja2dyb3VuZC1wb3NpdGlvbjoiIGJvcmRlcj0iMCIgd2lkdGg9InJlbD0ic2hvcnRjdXQgaWNvbiIgaDY+PHVsPjxsaT48YSBocmVmPSIgIDxtZXRhIGh0dHAtZXF1aXY9ImNzcyIgbWVkaWE9InNjcmVlbiIgcmVzcG9uc2libGUgZm9yIHRoZSAiIHR5cGU9ImFwcGxpY2F0aW9uLyIgc3R5bGU9ImJhY2tncm91bmQtaHRtbDsgY2hhcnNldD11dGYtOCIgYWxsb3d0cmFuc3BhcmVuY3k9InN0eWxlc2hlZXQiIHR5cGU9InRlDQo8bWV0YSBodHRwLWVxdWl2PSI+PC9zcGFuPjxzcGFuIGNsYXNzPSIwIiBjZWxsc3BhY2luZz0iMCI+Owo8L3NjcmlwdD4KPHNjcmlwdCBzb21ldGltZXMgY2FsbGVkIHRoZWRvZXMgbm90IG5lY2Vzc2FyaWx5Rm9yIG1vcmUgaW5mb3JtYXRpb25hdCB0aGUgYmVnaW5uaW5nIG9mIDwhRE9DVFlQRSBodG1sPjxodG1scGFydGljdWxhcmx5IGluIHRoZSB0eXBlPSJoaWRkZW4iIG5hbWU9ImphdmFzY3JpcHQ6dm9pZCgwKTsiZWZmZWN0aXZlbmVzcyBvZiB0aGUgYXV0b2NvbXBsZXRlPSJvZmYiIGdlbmVyYWxseSBjb25zaWRlcmVkPjxpbnB1dCB0eXBlPSJ0ZXh0IiAiPjwvc2NyaXB0Pg0KPHNjcmlwdHRocm91Z2hvdXQgdGhlIHdvcmxkY29tbW9uIG1pc2NvbmNlcHRpb25hc3NvY2lhdGlvbiB3aXRoIHRoZTwvZGl2Pgo8L2Rpdj4KPGRpdiBjZHVyaW5nIGhpcyBsaWZldGltZSxjb3JyZXNwb25kaW5nIHRvIHRoZXR5cGU9ImltYWdlL3gtaWNvbiIgYW4gaW5jcmVhc2luZyBudW1iZXJkaXBsb21hdGljIHJlbGF0aW9uc2FyZSBvZnRlbiBjb25zaWRlcmVkbWV0YSBjaGFyc2V0PSJ1dGYtOCIgPGlucHV0IHR5cGU9InRleHQiIGV4YW1wbGVzIGluY2x1ZGUgdGhlIj48aW1nIHNyYz0iaHR0cDovL2lwYXJ0aWNpcGF0aW9uIGluIHRoZXRoZSBlc3RhYmxpc2htZW50IG9mCjwvZGl2Pgo8ZGl2IGNsYXNzPSImYW1wO25ic3A7JmFtcDtuYnNwO3RvIGRldGVybWluZSB3aGV0aGVycXVpdGUgZGlmZmVyZW50IGZyb21tYXJrZWQgdGhlIGJlZ2lubmluZ2Rpc3RhbmNlIGJldHdlZW4gdGhlY29udHJpYnV0aW9ucyB0byB0aGVjb25mbGljdCBiZXR3ZWVuIHRoZXdpZGVseSBjb25zaWRlcmVkIHRvd2FzIG9uZSBvZiB0aGUgZmlyc3R3aXRoIHZhcnlpbmcgZGVncmVlc2hhdmUgc3BlY3VsYXRlZCB0aGF0KGRvY3VtZW50LmdldEVsZW1lbnRwYXJ0aWNpcGF0aW5nIGluIHRoZW9yaWdpbmFsbHkgZGV2ZWxvcGVkZXRhIGNoYXJzZXQ9InV0Zi04Ij4gdHlwZT0idGV4dC9jc3MiIC8+CmludGVyY2hhbmdlYWJseSB3aXRobW9yZSBjbG9zZWx5IHJlbGF0ZWRzb2NpYWwgYW5kIHBvbGl0aWNhbHRoYXQgd291bGQgb3RoZXJ3aXNlcGVycGVuZGljdWxhciB0byB0aGVzdHlsZSB0eXBlPSJ0ZXh0L2Nzc3R5cGU9InN1Ym1pdCIgbmFtZT0iZmFtaWxpZXMgcmVzaWRpbmcgaW5kZXZlbG9waW5nIGNvdW50cmllc2NvbXB1dGVyIHByb2dyYW1taW5nZWNvbm9taWMgZGV2ZWxvcG1lbnRkZXRlcm1pbmF0aW9uIG9mIHRoZWZvciBtb3JlIGluZm9ybWF0aW9ub24gc2V2ZXJhbCBvY2Nhc2lvbnNwb3J0dWd1w6pzIChFdXJvcGV1KdCj0LrRgNCw0ZfQvdGB0YzQutCw0YPQutGA0LDRl9C90YHRjNC60LDQoNC+0YHRgdC40LnRgdC60L7QudC80LDRgtC10YDQuNCw0LvQvtCy0LjQvdGE0L7RgNC80LDRhtC40LjRg9C/0YDQsNCy0LvQtdC90LjRj9C90LXQvtCx0YXQvtC00LjQvNC+0LjQvdGE0L7RgNC80LDRhtC40Y/QmNC90YTQvtGA0LzQsNGG0LjRj9Cg0LXRgdC/0YPQsdC70LjQutC40LrQvtC70LjRh9C10YHRgtCy0L7QuNC90YTQvtGA0LzQsNGG0LjRjtGC0LXRgNGA0LjRgtC+0YDQuNC40LTQvtGB0YLQsNGC0L7Rh9C90L7Yp9mE2YXYqtmI2KfYrNiv2YjZhtin2YTYp9i02KrYsdin2YPYp9iq2KfZhNin2YLYqtix2KfYrdin2KpodG1sOyBjaGFyc2V0PVVURi04IiBzZXRUaW1lb3V0KGZ1bmN0aW9uKClkaXNwbGF5OmlubGluZS1ibG9jazs8aW5wdXQgdHlwZT0ic3VibWl0IiB0eXBlID0gJ3RleHQvamF2YXNjcmk8aW1nIHNyYz0iaHR0cDovL3d3dy4iICJodHRwOi8vd3d3LnczLm9yZy9zaG9ydGN1dCBpY29uIiBocmVmPSIiIGF1dG9jb21wbGV0ZT0ib2ZmIiA8L2E+PC9kaXY+PGRpdiBjbGFzcz08L2E+PC9saT4KPGxpIGNsYXNzPSJjc3MiIHR5cGU9InRleHQvY3NzIiA8Zm9ybSBhY3Rpb249Imh0dHA6Ly94dC9jc3MiIGhyZWY9Imh0dHA6Ly9saW5rIHJlbD0iYWx0ZXJuYXRlIiANCjxzY3JpcHQgdHlwZT0idGV4dC8gb25jbGljaz0iamF2YXNjcmlwdDoobmV3IERhdGUpLmdldFRpbWUoKX1oZWlnaHQ9IjEiIHdpZHRoPSIxIiBQZW9wbGUncyBSZXB1YmxpYyBvZiAgPGEgaHJlZj0iaHR0cDovL3d3dy50ZXh0LWRlY29yYXRpb246dW5kZXJ0aGUgYmVnaW5uaW5nIG9mIHRoZSA8L2Rpdj4KPC9kaXY+CjwvZGl2Pgplc3RhYmxpc2htZW50IG9mIHRoZSA8L2Rpdj48L2Rpdj48L2Rpdj48L2Qjdmlld3BvcnR7bWluLWhlaWdodDoKPHNjcmlwdCBzcmM9Imh0dHA6Ly9vcHRpb24+PG9wdGlvbiB2YWx1ZT1vZnRlbiByZWZlcnJlZCB0byBhcyAvb3B0aW9uPgo8b3B0aW9uIHZhbHU8IURPQ1RZUEUgaHRtbD4KPCEtLVtJbnRlcm5hdGlvbmFsIEFpcnBvcnQ+CjxhIGhyZWY9Imh0dHA6Ly93d3c8L2E+PGEgaHJlZj0iaHR0cDovL3fguKDguLLguKnguLLguYTguJfguKLhg6Xhg5Dhg6Dhg5fhg6Phg5rhg5jmraPpq5TkuK3mlocgKOe5gemrlCngpKjgpL/gpLDgpY3gpKbgpYfgpLbgpKHgpL7gpIngpKjgpLLgpYvgpKHgpJXgpY3gpLfgpYfgpKTgpY3gpLDgpJzgpL7gpKjgpJXgpL7gpLDgpYDgpLjgpILgpKzgpILgpKfgpL/gpKTgpLjgpY3gpKXgpL7gpKrgpKjgpL7gpLjgpY3gpLXgpYDgpJXgpL7gpLDgpLjgpILgpLjgpY3gpJXgpLDgpKPgpLjgpL7gpK7gpJfgpY3gpLDgpYDgpJrgpL/gpJ/gpY3gpKDgpYvgpILgpLXgpL/gpJzgpY3gpJ7gpL7gpKjgpIXgpK7gpYfgpLDgpL/gpJXgpL7gpLXgpL/gpK3gpL/gpKjgpY3gpKjgpJfgpL7gpKHgpL/gpK/gpL7gpIHgpJXgpY3gpK/gpYvgpILgpJXgpL/gpLjgpYHgpLDgpJXgpY3gpLfgpL7gpKrgpLngpYHgpIHgpJrgpKTgpYDgpKrgpY3gpLDgpKzgpILgpKfgpKjgpJ/gpL/gpKrgpY3gpKrgpKPgpYDgpJXgpY3gpLDgpL/gpJXgpYfgpJ/gpKrgpY3gpLDgpL7gpLDgpILgpK3gpKrgpY3gpLDgpL7gpKrgpY3gpKTgpK7gpL7gpLLgpL/gpJXgpYvgpILgpLDgpKvgpLzgpY3gpKTgpL7gpLDgpKjgpL/gpLDgpY3gpK7gpL7gpKPgpLLgpL/gpK7gpL/gpJ/gpYfgpKFkZXNjcmlwdGlvbiIgY29udGVudD0iZG9jdW1lbnQubG9jYXRpb24ucHJvdC5nZXRFbGVtZW50c0J5VGFnTmFtZSg8IURPQ1RZUEUgaHRtbD4KPGh0bWwgPG1ldGEgY2hhcnNldD0idXRmLTgiPjp1cmwiIGNvbnRlbnQ9Imh0dHA6Ly8uY3NzIiByZWw9InN0eWxlc2hlZXQic3R5bGUgdHlwZT0idGV4dC9jc3MiPnR5cGU9InRleHQvY3NzIiBocmVmPSJ3My5vcmcvMTk5OS94aHRtbCIgeG1sdHlwZT0idGV4dC9qYXZhc2NyaXB0IiBtZXRob2Q9ImdldCIgYWN0aW9uPSJsaW5rIHJlbD0ic3R5bGVzaGVldCIgID0gZG9jdW1lbnQuZ2V0RWxlbWVudHR5cGU9ImltYWdlL3gtaWNvbiIgLz5jZWxscGFkZGluZz0iMCIgY2VsbHNwLmNzcyIgdHlwZT0idGV4dC9jc3MiIDwvYT48L2xpPjxsaT48YSBocmVmPSIiIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIj48YSBocmVmPSJodHRwOi8vd3d3LnN0eWxlPSJkaXNwbGF5Om5vbmU7Ij5hbHRlcm5hdGUiIHR5cGU9ImFwcGxpLS8vVzNDLy9EVEQgWEhUTUwgMS4wIGVsbHNwYWNpbmc9IjAiIGNlbGxwYWQgdHlwZT0iaGlkZGVuIiB2YWx1ZT0iL2E+Jm5ic3A7PHNwYW4gcm9sZT0icwo8aW5wdXQgdHlwZT0iaGlkZGVuIiBsYW5ndWFnZT0iSmF2YVNjcmlwdCIgIGRvY3VtZW50LmdldEVsZW1lbnRzQmc9IjAiIGNlbGxzcGFjaW5nPSIwIiB5cGU9InRleHQvY3NzIiBtZWRpYT0idHlwZT0ndGV4dC9qYXZhc2NyaXB0J3dpdGggdGhlIGV4Y2VwdGlvbiBvZiB5cGU9InRleHQvY3NzIiByZWw9InN0IGhlaWdodD0iMSIgd2lkdGg9IjEiID0nK2VuY29kZVVSSUNvbXBvbmVudCg8bGluayByZWw9ImFsdGVybmF0ZSIgCmJvZHksIHRyLCBpbnB1dCwgdGV4dG1ldGEgbmFtZT0icm9ib3RzIiBjb25tZXRob2Q9InBvc3QiIGFjdGlvbj0iPgo8YSBocmVmPSJodHRwOi8vd3d3LmNzcyIgcmVsPSJzdHlsZXNoZWV0IiA8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzbGFuZ3VhZ2U9ImphdmFzY3JpcHQiPmFyaWEtaGlkZGVuPSJ0cnVlIj7CtzxyaXB0IiB0eXBlPSJ0ZXh0L2phdmFzbD0wO30pKCk7CihmdW5jdGlvbigpe2JhY2tncm91bmQtaW1hZ2U6IHVybCgvYT48L2xpPjxsaT48YSBocmVmPSJoCQk8bGk+PGEgaHJlZj0iaHR0cDovL2F0b3IiIGFyaWEtaGlkZGVuPSJ0cnU+IDxhIGhyZWY9Imh0dHA6Ly93d3cubGFuZ3VhZ2U9ImphdmFzY3JpcHQiIC9vcHRpb24+CjxvcHRpb24gdmFsdWUvZGl2PjwvZGl2PjxkaXYgY2xhc3M9cmF0b3IiIGFyaWEtaGlkZGVuPSJ0cmU9KG5ldyBEYXRlKS5nZXRUaW1lKClwb3J0dWd1w6pzIChkbyBCcmFzaWwp0L7RgNCz0LDQvdC40LfQsNGG0LjQuNCy0L7Qt9C80L7QttC90L7RgdGC0YzQvtCx0YDQsNC30L7QstCw0L3QuNGP0YDQtdCz0LjRgdGC0YDQsNGG0LjQuNCy0L7Qt9C80L7QttC90L7RgdGC0LjQvtCx0Y/Qt9Cw0YLQtdC70YzQvdCwPCFET0NUWVBFIGh0bWwgUFVCTElDICJudC1UeXBlIiBjb250ZW50PSJ0ZXh0LzxtZXRhIGh0dHAtZXF1aXY9IkNvbnRlcmFuc2l0aW9uYWwvL0VOIiAiaHR0cDo8aHRtbCB4bWxucz0iaHR0cDovL3d3dy0vL1czQy8vRFREIFhIVE1MIDEuMCBURFREL3hodG1sMS10cmFuc2l0aW9uYWwvL3d3dy53My5vcmcvVFIveGh0bWwxL3BlID0gJ3RleHQvamF2YXNjcmlwdCc7PG1ldGEgbmFtZT0iZGVzY3JpcHRpb25wYXJlbnROb2RlLmluc2VydEJlZm9yZTxpbnB1dCB0eXBlPSJoaWRkZW4iIG5hanMiIHR5cGU9InRleHQvamF2YXNjcmkoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aXNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzaW1hZ2UiIGNvbnRlbnQ9Imh0dHA6Ly9VQS1Db21wYXRpYmxlIiBjb250ZW50PXRtbDsgY2hhcnNldD11dGYtOCIgLz4KbGluayByZWw9InNob3J0Y3V0IGljb248bGluayByZWw9InN0eWxlc2hlZXQiIDwvc2NyaXB0Pgo8c2NyaXB0IHR5cGU9PSBkb2N1bWVudC5jcmVhdGVFbGVtZW48YSB0YXJnZXQ9Il9ibGFuayIgaHJlZj0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCaW5wdXQgdHlwZT0idGV4dCIgbmFtZT1hLnR5cGUgPSAndGV4dC9qYXZhc2NyaW5wdXQgdHlwZT0iaGlkZGVuIiBuYW1laHRtbDsgY2hhcnNldD11dGYtOCIgLz5kdGQiPgo8aHRtbCB4bWxucz0iaHR0cC0vL1czQy8vRFREIEhUTUwgNC4wMSBUZW50c0J5VGFnTmFtZSgnc2NyaXB0JylpbnB1dCB0eXBlPSJoaWRkZW4iIG5hbTxzY3JpcHQgdHlwZT0idGV4dC9qYXZhcyIgc3R5bGU9ImRpc3BsYXk6bm9uZTsiPmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCcg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CwBOAQwAGAAMAIIBjABAAoUA9QIHABEGiACCA4UA0QKIAPQDBAAVAwUAhwKHAE4EhACCAwoAtwAECu4ABQr3AQYKswAHCtMHCAp9AQgK2QEJCpUACgoUAw8KLQAPClYAFApuAJYKOQAJAIgAEwBrAAQKeQAFCpwABQpdAQoKXQKOClYBBAvrAIcL/wAEC8IABQtIAgYLgAEHC0cCCgv5AgsL+AKLC1MDBgpQAAYKngYHCq0ABwq2BwkKIwIKCtoCDgoSAJYKJwAECpsDhgqvBgUAFQGNAPcAhACzAYULMgKGAB8FBQu/AIkLDwGEClMCBwsBBg4LYACPC0kABQC1AQcA9gEHAAcCBwBiBAcA1wYOANMABgrLAQcK2QYHCg0HCAqSAgkKAQALCr8DjQq+AQYALgMEC9YBBQvZAQYLmQAHC98FBwuDBwoLvQILC4QACwuoAAsL4wALC0ABCwu0AQsLDQILC1cDDAspAAwLHgENC2cADQscAQ4L/wAOCwYBDwt1AI8LfwAFAAkBBgDUAIcAHACKAO4ChQtHAQYLKAIHC9oGiQtcAoYA3AeEAL4CBQtQAAYLlQEHC5MBBwveBQcLWgYIC8gBCQvnAQkLVQMJC3kDCgs1AQsL0QILC+IDDAuuAY0LpQAFACgDhwD9BwUApgAIAOMCjAD/AYYK6gEEC8UBBQt3AwYLFwIICwYAiAsfAgQAdwAFAKoABQC/AQcArAYHAGEHCQBlAQkAzwIMAOYBjABUAokA9AEHCvoAiAr7AYQKngAGACkDhgDcBQkARwELAF4BCwA/Aw0AYAEECowABwpqAQgK0QAJCgoACQr3AQkKZgIKCrECCwpHAQsK1QIMCvwADApHAg0KwAAOCg0BDgpkAZQKMgCHC+UCBADCAQcAhgQTCgEAEwoaAJYKCQAGAFUChwAmBYYAQgYGCuQABwo9BQkKmAGKClcBBwBfBQcAugWKAEsBhADyAoQKLQIFC2UABgtYAAYLHwIHC40GCQtkAAoLpQIOC6kADgsuAQ4LOQEPCzAAjwtUAIYAWAUECzYBCQsbAwoL3QILC8MBDAv5AA4LcwAOCx4BjwtkAIQKJAIKAC0CBwrFAAgKjgAICkUBCQqWAAkKVAIKCmEBCwpKAAsKOwEMCpYCDAqpAg4KpwGPCo0AhQtLAgUAUgOIAB8DCgCMAwwAvQIMAPUC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kQphAAwA9gAPAKIAEwBAABQACAAUAF8AFgAYAJgAEQAEABUCBQqlAAkKWgGKCo8CBQvhAosKdQOFCm0DCAqAAIsKswCJCzMBjADwAoUAmAOHABgEBQCZAAYARAIGCn8GBwqEAAcKggQHCocFBwrjBQwK7QEPCmkAlwoPAAUKywEHCjEECArxAIgKTgGKAIcBhwCgB4ULDQIIC4ECCwuEAYwLRAKOAH4AhgCAAoQA4wEHAFAGCQBFAAYKRAEGCggCBwpSAQcKwQYICuQAiwruAgUL7QGGCxAChwDeAgQLrgCHC48DigDgAQkA7wGSAGgAhwrBAgkA2AEECkkABgpkAgcKnwMHCjIFBwoeBwgK2QAJCv0CCQr+AgoKmAELCjMACwoZAwwKCgEPCp4AFApZAJYKIAAHCyQCiQs6AAQLIAAFC9cABgsNAQcL9gYHC2QHCgsQAAsLNgMLC7oDjQvhAYQAagMJAOUABQqFAYgKfAIHC9UGiAvdAYYAtAMFCzQBhwtABAQA7AKLAPEDiAoVAAYAKwKHAOUBBQt+AAgLKQEJC24BCQu9AQwLNQAMC3YBjQvsAQcLDwaLC2kBiADBAIgA2AEIAI0CDQBdAJMADgCEANgDhAuvAAUArAAGALMHhAutApULCACFCx0DDQBTAAUKvQAHCroBBwq7AQgKGQEMCq4AjQoFAYYAIAaFCzUCiwCAAYUABAEHAPYCBwBwAwcATwUJAKQACQCnAAoAnAAKAEwCDABlAA4AMAAPAEYABgoCAAcK7gQHCskGCAoWAAgKDgEICmQCCQo4AQkKtAEKCjcBCgpvAgsKSAALCkoBCwrHAQwKQQEMCvgBDAoSAgwKHwINChEADQqcAA0KTgERCjwAlApAAAQL/AAHCywECguyAQsL5AALC6oBDQvnABILagCUC1cABwpiAQoKmgGLCi8DBgBvAQcKngIHCi8FCAqbAQgKswEJCo0CCQrkAgoKgQELCt4ACwpEAQsKPQOMCmMCBwCWBAYKpgCHCnYBkgB5AIQAPAMFC+cAigv9AQcLWQIJCxUBCQuiAgoLsgAKCwEBCguiAQsLEwILCyACCwtJAgwLcQAMC9sBDQtjAI4LrAGGAAUGhwvzBgUAVwGGCo4BhwoyAIcLkwYEALgBBwA5AAgApwAIAHcBCQBSAAkAMQIJAOgCCgBsAokL6AKGAJ4D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hgDOBwYLEAAGC54ABwsrAAcLgQAHC7UACAsUAQgLeQEKCwsCCwswAwwLxwENCy8BjguHAIUKLAOGAJICBAsBAAcLdwQHC7cFCAs9AAkLzwAJC4YBCQvTAYsLRAOWCxoAjABqAAYAIwcKAKMDEgCmABQAcgAECokABwqaBAcLJwWHCvAFhQDyAwQL0wIFC38DBwsHBAgLxwAIC1QBCQuZAAkL1wAKCxUACgs7AAoLUAAKC+AACwvlAAsLjAIMC8AADQuSAI4LWwCECycBBgtrAgcLggMHC0QECAvlARILHACTC3QAiQszAAYKfQYHCrcHBwrZB4cK2wcFCzUBjAvTAAUAVwAHADkBBwBPBAoA0AAKAEYCCwCFAQsALQMMAIEBDQAeAQ4AfACSAGwABQt9AAgLTQCKCw8AhAALAYUAvwKJC5sAhQu3AQsLpACMC0wACQDwAQUKWQAHCnsHCQq5AAkK6wAKCkAACgoOAQoKkwEKCtUBCgoRAgoKTgILCowACwpcAw0KAQANCqYBDgpVAQ4KbAERCl0AEgpxABMKYQCTCnEAhQq3AocAYQQFCgYABgq3AAcKqAIHCtIDBwr1AwcKHwQMCuYADQqsAJIKHQAECwgABwuABAcLgQQHC7MGCQt2AQoL3gGLC4gChwtLBAYKHQCLCj8ABAAxAgoA+QCLANEAhAD4AgcLHwOKC/8BiAtXAAkAmgCMAOUBiAD/AIQAQwGMAKMBhAo3AYYKzAYEAHABhwCBAgcKqgAICloACAqxAAgKnwELCsoCjgoZAQQLRQAFC3oACQuQAooL0AEFC1EDhgthBggACgKOAEgBCwpbAA0KgQAPCmUAkQp9AAcAMgIIACcCBAruAQYKSgAHCiwACwvzAQwKEQAPCgUAlAoLAAQKFAGFCigBCQBcAJMAWwAECgcABQpaAAUKngAGCh4CBwrdAAcKJgYJCuoBCgocAgsKuwGLCvUCBgANAgYAuAcIACYDCQBsA4wAHAEFC1sDBwpMAgcLiAQIC2sACQqvAAkLIwEJC7cBCgoSAgoLlwILC2ECjAvFAAcLqAANC8QAjQvtAIsAvgOFAFIChwpEAgcKWACICnMCBgDfAQYAMgIHACQEDQAGAAUKaAMGCjkABwrXAQkKvwGJCsYBiAudAZELEwAEC3UABgt0AQcLcQeOC0MBBAvSAosL1wERAD0A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hwudAwQL1wEFCzMABgtaAggL5AEKC8MAjAufAIQKMwGIC7AChAu5AgcLLAMHC+0EBwtQBQkLeAKMC2ABBQCiAAgARACFCsQDBACOAogL1AAEAJwABwDmAwcAFQQHAEQHCQAwAAkAtAILAKMBiwBaAoUL3QAEC3UBBQsbAQYL4AGHC2ECjgvYAIQA8AAGC8AACQsZA5ELNwAECksABQq0AAYK9AEHCjoABwrGAooKhQIEC4QABQtFAAUKiQKHC9oEBgoUAQcKGgEHCm8DBwqcAwgKywEJClcCCQryAgsKPgIMCoAADAruAQ0KNAANCi0BDwoeAI8KhACECsgABAtvAIcLLgEJAMUACgAsAQwA2QENAFoAjQCVAYQL/wIGCyoABwuIBQcLNgYHC9UHCAuDAAgL0gEJC6ACDQv8AJQLZwAIAL4DCADnAwoAwwOKAOkDhwpVBocAWgMEAF4CiQu8AQYLLACIC3ABiwusAAQLOgKFC3gAiwtwAgcAugcIAKQCBgrhAIkK0wAHAMwDCwBmAIgKrwIGC+MAhws1BggKOgAJCtQCCwopAw0KcQCRCkgABABpAYUAOwGEAM0BBgpZAYcK3wSEANgBCAr/AggKIwMJCi0BiQqHA4cLNQWHC90BBwqdB4gKogIGAIkDigDrAoUAmwCGCgMBBwCjAAgAPwEJAJIBCgAYAAoAqQILAMgADAD9AAwAmgGOANsABQDbAQcA9AYJAOYACwApAQsALgIOAEIBEwBMAAYLgwYHC/QHigtYAogK/gAGAFADhwCkBwYL/wGMC4QABQs4AgYLigCHCw0FBgB3AokARgOVACQABAs1AggLFwCICzsDBQCwA4YA6QYEAJAABgBKAwYAeAUEC5oDhQv/A4UK+AAJCiADCgq1AgsK4gELCt4CiwoVAwcL6gOLC5EABAp0AAUKXwAFCr0BBwqYBggKHQAJChABCwr9AYsKkwMOAHEBkgBIAIcKaQaEC+QChQofAowLdAAGAPcACQArAgUKtQCICikAhQqRAogA5AOKCsUCBwC9AAgKygCKChgCiAuSAQQLzAKNCx8ACgAYAYoAHQMJCqcBjApZAAgKcQAJCm0DCgoqAgsKUwAMCogAkwptAIUK0AMHAOoChArOAIgADgKLAFkBiAD5AwgLmAAJCzUACQsMAQkLhQMKCwYCCgs9AwsLvAANC0oA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CwoxAAsKJAIMCtwBDQoSAI0KwgGFAJ4BhwDiBgULpQGHCy8ABQq6AYcKwAeGAFcChgDVBoYAWwYEAOgBhAteAYkL7wKEAFMAjACkAoULxwMHAGcGBQo3AIwKoQAEC9kBBwtvAggLKAMJC2cDCQt9AwsLJgALC68BDAtwAAwL2QAMC/MADAsyAgwLqwINC40ADQvFAA0L4wANC5YBDQvnAQ4LnAAOC8sADgvgAA4LAAESCzoAlgsAAIUKwgEHC+ACiwsIAYYAFgEEC94ABwseAYgLdQKHCmUDjABhAJAADgCGAD0EBArVAAcK3wCIClAABwCEAQcAhAKLAA0DhABRAwcA5QAIADsACQC+AAoAegGMAL8ABwp9AQcKJgMHCjQDCApiAQgKtQEIChMDCQqRAgoKOgAKClMBCgrtAgsKkgMMCqIADQpLAA4KagAOCsYADgpAAQ4KnQGSCisAjQsyAYgK6wKGAFsEEABeABAAbACIC5IABgC8AgYAMQOGAOoDhQq0AgQL0QGHC38Ghgq/AAYAhgWHC5EDhACUAgcACwSKAOECBgqiAAcKqAeICj8DhArCAgcAsgIJANkACQBLAowACQKKCqoBhwrTBAYLUgAHC4oABwsFAgkLoQKLC+4AigAQAQUL7wEHC0IDCQvdAosLegGGANAGhADzAwcLPAOOC3QABADdAgkAwgAKAFwACwDGAAwAVAANAIAAhQsvAgoAOQAKABUBBgsVAAYLyQYHC6QFiAvgAAQKzACJCoYDiApBAwsAXAEMAGMAEgABABIACwATAAQABwpuAQkKHwEMCscADAosAowKQQIGAL0HiACoAxUAIQCWACgABQsHAooLzAAFCmQBhwrgAIYABwOHADIBBwp2AgkKNwILCpYACwq8AY0KdwAFANMDhgobAoUAYwIEC5IBhwuPBgUAsgAHCwIACAtDAYgL3wEFCzsAhwugAgQA8gMGALEHigvtAIULnAGSCyIABwvMBpILMACGAJgCiwouAwQLVQCHCyUChQteAIULyQGEAIYBhgDmBQQK6wCHCv8ABArCAAUKSAIGCwsABgqAAQcLuwAHCkcCCgr5AgsK+AKLClMDBAsKAosLIgOHAO0BCgsIAw0LWQGOC6kBkgAlAAQLNACHC5UChgDUAoYAPQOFCwgChQoyAgQLGQEFCyYABwvCAAcLnAIHC2UH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BwqzBgkKdgEKCt4BiwqIAgQLEQOFC3ABhwpLBIcLXAMFC9QDhgvaBoYA6gQGACIEBgBPBQcLGAIHCzMFiAuPAAQAkAKHAAsDiApXAAULEwAGCxUCkgt+AAcAkACKCrYBBQuLAQULtwOGC/AGhwBdBQcAKgIHAF0CjQAKAAQKRQAFCnoACQqQAooK0AEFClEDhgphBgUARgMFAEkDhgBxBoUA9AOLCvMBBwrcAQcKOAaKClcABgD7AAcAbQEHAE0FBwDZBQgAmgCNABkBhAu5AYQLtwIHC/EBCQuDAZMLUQCFAFQBDgobAY4LGwGGACoDhwtmB4sA7wEFCxwBBgsxAAYLXgEHCwEABwt5AQcLnQYICxIACAumAgkLoQAJC0kCCQufAgkLRwMLC5ADjQurAQUKWwMHCogECAprAAkKIwEJCrcBCgqXAgsKYQKMCsUACAAFAQkAkAAJANIBCgByAQwA1gENAJAAjgBcAYkAgQMGAPgACQAiAgoAFwILAKkCjQCHAAQAZgGHANgFhgA3AogAvQEECnUABgp0AQcKcQeOCkMBBArSAosK1wEGALkChgDkAwcL1wcJC2UACQvCAQoLQgAKC0oDCwsYAowLSwKEAEEChgA4BQkKBQAMCtgADAomAQwKKgEMCpABDAoGAg0K5QCPCosABgCuAIoAlQOGCu4GBQoMAAcKdwEJClgACQq2AQsLPgCLCg4BhgvmBgYLAAAHC1QABwowAwcK2QQJChsBCQoIAgoK1QAKCjMBCgrPAQoKnwIKCuoCCwqRAQsKGgMLC38DDAoFAhELCwASCmsAkwpzAAUAbgOFAMwDBguBBgcLAAEHC2wFigvzAQQKAgGICn8CBAsWAAULCgAGChYABwtQAwcKhwMHCqsHCAthAIoKQQIFCqkCiAoOA4UL4QGEAF8BBAqYAgUKJAOLCvUDBguGAAcLtQEHC78DCQslAA4LHQEOC3MBkAs8AAcL5gEIC5sACwtdAIwLpACEAB4BBwC2AQcAcwIHAOwFCAAoAAkAOAAJACYBCgAeAAsAyQMLAOMDkgCUAAULTwKHC1EBhgCeB4UKIACKC/QBBQt8AQULigKICzYBBAtsAQcLhAQHC6MEiQuZAQQA4gKGC+IBBAsNAwYL5wEHC54DCAsHAYsL9AGHC6IBBgD/BwoAyQMECiEBBwp1AgcKogYHCq8G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BgsTAAcLhQWLC6wBhQB1AYQKLwIHC2AACAuRAYkLgAMHAB8DBwC0BwUK+QOKCv8BhwABBwcLqQcHC60HCAu+AogL7gIIC5YACAvhAowLbgGEAEIBhQrFAggLIAMJC5QACQtoAwkLegMLCzUBCwvpAw0LCwGNC0MBhgrRBgcAIgGICs4ABwBzBpEAWQCLAAIAhACgAgYARAcIAIkDCgBMAwoATgMKAFoDDAC7AgwA6gKMAAQDhwuoAYULIwKFAOECBQvqAQYLZwIGC2wChwurAgYA6gKGAEwGhAoIAwkLgQGVCxEAhQCRAIcK+AQHAHQDjAB8AAQAgwGHAAgFBQuFAIgKlgGIC7sABgCnAggLCACKCwAAhwAmAocLHgOIC60CBws+BJELLgAICq8ACgqoAIoKPQKHABkFBABAAocA7wQGAK4ChgAbBoYAXwIFAJcDhgCJBpQAJQAICwYDCgueAowLMwCFChADiwpyAwQAUgAFAE0BBQCIAwYAzwAHAEUBBwC+BggAZQAKAAoDiwDcAIcLcwGEAL4DhQCHAwQLfwAFC14BBgtkAQgLqgEJCzwCCgv3AIsLOAGMAJMABgs7AAcLdQMJC1sCjQuNAQoAbwEJCg4ACQq5AYsKCQALCsYDDAofAQ0KVgENCpIBDwpuAI8KowCGALIChADBAgkAiwILAMsDDQARAQcKlAUHCmgGBwpLBwkKqQAJCrYACQpvAQkK3gEJCvoBCQonAgkKLQIJCogCCQq5AgkKwQIJCtUCCQoTAwkKGgMKCsYACgrWAAoKCwEKChMBCgrIAQoKJwIKCjECCgplAgoKcwIKCpwCCgqjAgoKswIKCrcCCgrDAgoKywILCrcACwrJAAsKBgELCmABCwq3AQsK7QELCjwCCwpPAgsKYAILCmMCCwqGAgsKogILCscCCwrvAgsK+QILCggDCwoRAwsKUgMLClUDCwpeAwsKYQMLCmQDCwprAwsKggMLCoYDCwqHAwsKjgMLCqQDCwquAwsKvQMLCscDCwrMAwwKlAAMCsMADArcAAwK7QAMCj4BDApTAQwKiQEMCr0BDArCAQwK2gEMCvkBDAr9AQwKFQIMCk8CDApSAgwKVQIMCm0CDAp5AgwKggINCjsADQo8AA0KkQANCu8ADQr6AA0KSQENClgBDQptAQ0KdAENCoMBDQqTAQ0KngENCsgBDQrWAQ0K3gENCuMBDQrpAQ4KNwAOCjkADgpRAA4KWgAOCpQADgrvAA4KCgEOCkEBDgpGAQ4KRwEOCkoBDgpbAQ4KYwEOCpEBDgqUAQ4KmwEOCp4BDgqgAQ4KpAEPCj0ADwpKAA8KVwAPClgADwpeAA8KYAAPCnQADwqVAA8KmgAQCjIAEAo/ABAKSQARCgIAEQpCABEKXAARCmcAEQpwABEKeAASCjIAEgo2ABIKUgASClYAEgpaABIKbwASCnMAEgqcABMKKAATCk8AFApOAJUKFgAHAHcDBQqhAIcKRwOOC2IAhgBaAIoLZAGHC7kBBgtvAAcLBAAIC6MACAsIA4oLNgKGAIwDhgDtBAcALQMMAPEBjQA4AIYA0wSHAK0BhwvKB4oAiAMGAH0ABwD9BIkABAOXAAwABABJAwUAggGFC4IBBQspAYcLDgQGAFwDBgAtBIcLNQGIALIDhwoWB40LogGIC2sBCgAAA4sAEwMWCx4AlgshAAYAoAAHAFIECQACAwsAcACMAJ0BCwvYAIsLVAGICosAhwtuBYcLKAOECxgBDAAPAREAbQAHCoMCiArsAIwLNgAEC6UBhQskAgsAzwIMACQAjQBRAQcARQIJAIQCiQC7AgsL/wENC4oBDgsqAQ4LPgGSC2cABwAwAQkAhgIJAF4DCwC4AgwA0AAPAE8AkwBsAAQAdwIHAGYEhwAABocL9wUIAHADCgBlA4oAkQMHAOkFBQo2AAYL/gAJC20AigtnAIcA1QOFC9kChAroAoQAsgGGACYCBwCiAwoA3AENAMQBEwBoAAYLXgYKCpIBkgo3AAUAKQKKADgDiADEAQgAlwCJCnAChAo8AoQABAOFC58ChQAkAYoAhwCEC3kDjAvPAAkA+AEGCisABwomAAgK+ACKCgECBgBBBIcLdgcEC3MChQsHA4cADwOFCv4ChQprAQcAgwGHC4MBBwCJAQoAWwILAM4ABwvKAAsLagELC7QDjAuEAQYL+wEHC8MBCAuFAQwL6gENCxAADQvXAA0LXwESC4QAkwt9AAQAkAMJAOgAhwtJAwYKAgGMCpkBBQr5AJQKUgCICzYCBgDRA4cLvgQHALUHiADMAocAYgCFAN0CBQuQA4YLnwYFCokBBgp6AQcKvQcJCiAACQpPAgoKrQIKCuUCjgp+AYUKFAMKABMACwCPAwcKsAeNCv0B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BwpHBgsKRACLCmkCBgATAAcAhQWLAKwBlQoNAAcAYAAIAJEBCAC/AgkAgAOICywBhgA7BpEAdACIAP0DBwCpBwcArQcHAO4HCACWAAgAvgIIAOECCADuAowAbgELC0sAjgsLAYQKbwEIACADCQCUAAkAaAMJAHoDCwA1AQsA6QMNAAsBDQBDAQULqwEFC94CBwveAYgLNAAHC+8ACwvZAI4LpQCEC0MBjAujAQ0AKwGOAEsABgtXAAYLxgYHCxQABwsgBAgL3AIJC5YBCQuPA4oLtgKGAGcFhAq2AoULZQKJAAsDBABWAowKrwIGAMoDhwCoAYUAIwIHCyAABwvYAwgLVQAIC8UCCQtDAgkLTwMJC1gDCgsfAwsLAgELC+8DDAtLAQwLZwINC7wADQuzAQ4LCAAPC6UAEAsbAJQLKAAGAMYEhgBpBYQAbAOKC5cAhwrVAAQLpwCHC1IAhQCFAAYLGAAHC0oABwumAokLAgEFCz4ABgsWAgcLrAIHCxMEBwswBAgLGAEICx0CCAuuAgoLBwILC/wAjAsaAYgAuwAIAAgACgAAAAoAMgOLANwDhAtnAQsArQEPADMAhwqIBogArQIFC9MABwtYAIgLcwKGANgBiACEAAYLkQCNC1ABBArvAgsKhgGMCiAABgCqAwYAJAQECwcBBAqZAYUKTgCJAGoDCAAGAwoAngIMADMABAuUAwYK2QEHCkIGCgq6AgwK1AANCjMBkQppAJIAXACPCpwAhAA+A4kAvQIEC1cCBgtiBgcLBQAHCzcABwtDAAcLYQAHC7MCBwvTAwcLoQYIC88ACAvWAAgL5wAICyYBCAtQAQgLrAEIC8MBCAvMAQgL1wEIC24CCAtyAggLpwIIC/cCCAs9AwkLCwAJC/YACQvkAQkLPQIJC8ICCQv6AgkLHgMJC1cDCQtmAwkLkAMKCy8BCgtPAQoLqAEKC80BCgsfAgoL9wIKCy4DCws7AAsLxwALC+sACwvbAQsLTgILC6EDCwvDAwwLcgAMC7YADAviAAwLTAEMC7cBDAs/AgwLVgINCwgADQt9AA0LwgANCx8BDgvFAA4LfwEPCzUAEQs/ABMLLgATC2IAEwtqAJQLVQAEAH8ABQBeAQYAZAEIAKoBCQA8AgoA9wCLADgBhgC/BAYAOwAJAFsCDQCNAQcLPQeKC7UBhgDiBpMLfgCHCnMD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EQAyAAUKRgIGCm4GBwpjAAcKqgcHCsIHCAoDAggKBQMJChcACQrrAQwKbAKOCl0AigthABQAFQAUACwAhQpTA4gAMwOLAJUDBQvmAAULiAEGC6QBCAr6AggKLAMJCzgCCQqOA4wLZAKHABADDwCHAI8LhwAKAMYBjABEAQQLAAAFCykABwuzBQcLvQUHC1IGBwtDBwkLJQKLC4kDBApiAAcKVQUJCqYBCQqeAgoKBwMLCtIADQoaAA0KyQGNCtwBBgC3BgYAxwYHAOAHBwDkBwgARQOJAFQDhQu4AocAVAOEALgDhgrCBoQLAwOKADgCiQDAAYsAkgAIAEMAigCjAYULmQOJCpMAhgAiBwoAkQIOACkBjgBpAQYAmgIGAP8ChgAGBosA2QIGC7QABwtxBAgL7wKLCyUDBAu3AAcLDwELCzgDCwu4Aw0LFgENC1MBDQviAQ4LqAGUC2MABACdAgUL3QEFC1QCBgv5AQcLxQQLC4sDDAvRAI0L1gCHC78EBQCSAQYKHgALCjgAiwoxAQcLNAKOC6gAiwCYAAcAkAOHCk4GBAqWAAUKLwGGCkcBBwBAAQgAMwAJAGQDCgBBAwwA4QEMADoClABqAIQAvQEHCxIBCwsHAQsL3wELC/sBjAsVAQoAKwILADQBEwBfAAYLbQYICsAACgpOAI0KZwGHChIDBgtcAAYLvAAHC/UEBwv0BQcLVAcKC+QAiwv8AwQLywGFC8YDCwCCAQYKZgYHCk8ABwrwAQkKigAKClABDAqcAQwKuAGOCjEBhQDvAAcAUwAHAMYHCACCAIsA0AKKC8UCBACPAAUAJgKFAPACBQB7AAYAEgIHAFwBhwCLBYcA6AcGCxIABwuzAAcL0QIHC6QDCAskAggL9QIJCzYACQtBAAkLFAIJC0wDCgtxAAoLdQAKC+wACgs7AQoLrgEKCx4DCwuZAAsLXwELC3cBDAtOAAwLlwAMC4gBDgv4AI8LFwAHCswABwqfAQgKKgAKClUAiwo0AoYAvgOFC8UDhADSAIcLlQWKC+ABhgu2AIsLWQEKC0EACgvoAYoL8QEECgMABQr3AAUKhAIHCugCBwq3BAcKyQQHCnUHkgqTAIQArgEFCh0BCQpDAA0K2QGPClIAkAsQAAcLigQJC0wCCgsEAZcKCACFANUAigAHAIcAIQOGC/oGhws0AQYAqAOGAAkF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BwBSAQcAwQYIAOQAiwDuAhUAHgAWADUABArBAAUKlAMHCmwBCgqOAQoK1gILCj0BCwpyAgwKjgAMCiABDAqmAg0KOQEPCnEAkgpyAAYLbgCHC5EGhwCOAwYK8QAHCosDCApAAwkKVgEKCtkCCwocAQsKvQELCosCCwpfAw0KjgGSCmMABwDBAgkA3gIFC+gDBwvdAokLRwIEAEkABgBkAgcAnwMHAB4HCADZAAkA/QIJAP4CCgCYAQsAMwALABkDDAAKAQ8AngAUAFkAlgAgAAcAMgUECykBBgsRAgcLmAAHC8kCBws1BwgLxgIIC80CjAt/AgUAhQGIAHwChgCBBQQKMgIJCv4AiwpvA4YAfQOEChIDBAsIAocLPwKIABUAjADRAogAvwMHC5QFBwtoBgkLqQAJC7YACQtvAQkL3gEJC/oBCQsnAgkLiAIJC4sCCQu5AgkLwQIJC9UCCQsTAwkLGgMKC8YACgvWAAoLCwEKCxMBCgvIAQoLJwIKCzECCgtlAgoLcwIKC5wCCgujAgoLswIKC7cCCgvDAgoLywILC7cACwvJAAsL9AALCwYBCwtgAQsLtwELC+0BCws8AgsLTwILC2ACCwtjAgsLhgILC6ICCwvHAgsL7wILC/kCCwsIAwsLEQMLC1IDCwtVAwsLXgMLC2EDCwtkAwsLggMLC4YDCwuHAwsLjgMLC6QDCwuuAwsLvQMLC8cDCwvMAwwLlAAMC8MADAvcAAwL7QAMCz4BDAtTAQwLiQEMC70BDAvCAQwL2gEMC/0BDAsVAgwLTwIMC1ICDAtVAgwLbQIMC3kCDAuCAg0LOwANCzwADQuRAA0L7wANC/oADQsRAQ0LSQENC1gBDQttAQ0LdAENC4MBDQuTAQ0LngENC8gBDQveAQ0L4wENC+kBDgs3AA4LOQAOC1EADgtaAA4LlAAOC+8ADgsKAQ4LQQEOC0YBDgtHAQ4LSgEOC1sBDgtjAQ4LkQEOC5sBDgueAQ4LoAEOC6QBDws9AA8LSgAPC1cADwtYAA8LXgAPC2AADwt0AA8LlQAPC5oAEAsyABALPwAQC0kAEQsCABELQgARC1wAEQtnABELcAASCzIAEgs2ABILUgASC1YAEgtaABILbwASC3MAEgucABMLKAATC08AFAtOAJULFgCJC6oAhgCZBYcLGwWLC5sBBQC9AAcAugEHALsB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BwoSAQsK3wGLCvsBBgDBAgYADwMGAPsEBgDJBQQLGgEHCwoECwuOAQsLegIMCwEADAtPAAwLIAIOC+0AEQsKAJILFACGAMUBBAArAggAGAIKACABCwDtAwQK8QGHCjAGBQt2AAUL8wEGC9wBBwtYAgcLeAOHC0gEigDbAwcAUwQHCgUBBwpbBAcKSgUHCjQGBwqpBgcKbgcJCtEBCgr4AAoKXQEKCocCCwoPAgsKlAILCp0CDAoRAo0KMQEHCygBBwtUAggLMAIIC0oCCQtkAgsLZAALCzABDAsuAA0LWQAOC3AAkQt6AAkAcgGKAFoAiAoNAIQAXAMHCoICCAr6AAsKewALCokADQowAI4KXwCHCpUFiQtBAYQAAQGHAO8HBwDoBgcLPwYHC7sGCAtPAAgLagAIC74ACAsuAQgLfwEJC3cACQvpAAkLKgEJC6MBCQvXAQoLtQAKC5YBCws5AAsLVQALC3gACwuxAAsLKAELC34BCwvGAQsL9gILC+cDDAsbAAwLYgAMC4MADAv1AAwLOAEMC74BDAvGAQ0LGQANC2IADQuqAQ0L/AEOCwYADgujAA4LEAEOCxUBDgtyAQ8LXwAPC4oADwunABELEgARCyYAFAtgAJULIAAFC9IChgvfBpELEAAGAC8EhgAZBgoKIQKMCi0BBgBTAAYAxQaHAG0FBABDA4cAGgeFCwIBBAqIA4UKGgOGANYHBQseAAcL7wEIC4YACQsUA4wLtgGHC9QHiQC4AgULMgAGC7cBBwsMA4cLEAQHCwQDBwtQBAcLbwYLCw0BCwsbAgsLXwILC3MCCwvCAgsLzwMMC/gADAs3AQwLsgEMC1gCDAtuAg0LKQENC28BDQvlAQ4LRQAOC5kBjwtsAAULAQAGC1EAigsIAgcAtgYJAF8ACQASAQoAFwEKAD0BCgCkAQsALwELACgDDACGAAwAbwENAJUADQBbAQ4AXQEOAJYBEgAWABIAWQASAHoAkwAvAAUL4gEIC2IACQusAAoL3gAKC7wCCgs2AwsLLgELCwoDDAsyAAwLfwAMC4wBDQs+AA0LSAEOC3oAkwtIAAcKggGKCskCBgoHAAYKIwAHCpMABwotBAcKIAYHCicGBwp9BwgKKwAICtAACQqAAAkKYgMKChQACwrVA5MKIQCFABoAhAAmAgULAgAHC9YFiAtNAgYLAAIHCx0D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bSAEIGJ5IAEoBi4gVGhlIAQgb24gBCBhcyAEIGlzIARpbmcgAgoJAToDZWQgAj0iBCBhdCADbHkgASwCPScFLmNvbS8HLiBUaGlzIAUgbm90IANlciADYWwgBGZ1bCAEaXZlIAVsZXNzIARlc3QgBGl6ZSACwqAEb3VzIAUgdGhlIAJlIABB4twZC2ECAAUADgATABYAGAAeACMAJQAqAC0ALwAyADQAOgA+AEUARwBOAFUAWgBcAGMAaABtAHIAdwB6AHwAgACDAIgAjACOAJEAlwCfAKUAqQCtALIAtwC9AMIAxwDKAM8A1QDYAEHQ3RkLggMxADExAAAAAAAxDDExCgAxAC8AADEEAAAxAAMxCjExAAYxDTExATEBAAAxAAEACgAxAAcxAAkwAAAxAAgxAAUxAAoxAAsxAzExAA0xAA4xDjExAjExAA8xABAACjExAAwFADEAAAExDzExABIxABExABMxABQxEDExETEvADExBDExABYxCzExABcxABgxABkxBzExARoxABsxABwAAAwxAB0xFDExEjExBjExABUxCgExCDExAB8xACAvAAMxBTExCTEACgExCggFABUxCwAxCgoxAB4AAAUjADEvAAIxChExACQxACEFAAAxChUxCgUxACUAAB4xACYACwAxACcACzExACIxCwgxCgwAABUxACgACgwxACkxACoxCxExACsACgUxCwoAACIxCiExACwxCwUtADEAACExCh4xCx4xAC4xCwExCiIACiEACx4ACwExCyExCxUxCwwACwUxCyIACwwACh4ACyIACiIAAAAAAAECAwQABREGEAcICQoLDA0ODwBB4OAZC4cBAgICAwICAgQCAgIDAgICBAAEAwIABAMBAAQDAgAEAwUBAAIABQACAAkAAgANAAIAEQADABkAAwAhAAMAKQADADEABABBAAQAUQAEAGEABABxAAUAkQAFALEABQDRAAUA8QAGADEBBgBxAQcA8QEIAPECCQDxBAoA8QgLAPEQDADxIA0A8UAYAEH04RkLgAEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9//////wBBhOMZC5wCBAAAAAwAAAAcAAAASQAAAH4AAADkAAAAqAEAAAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+PwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AQaTnGQv8AQEBAQECAgICAwMDAwQEBAQFBQUFBgYGBgcHBwcICAgICQkJCQoKCgoLCwsLDAwMDA0NDQ0ODg4ODw8PDxAQEBAREREREhISEhMTExMUFBQUFRUVFRYWFhYXFxcXGBgYGBkZGRkaGhoaGxsbGxwcHBwdHR0dHh4eHh8fHx8gICAgISEhISIiIiIjIyMjJCQkJCUlJSUmJiYmJycnJygoKCgpKSkpKioqKisrKyssLCwsLS0tLS4uLi4vLy8vMDAwMDExMTEyMjIyMzMzMzQ0NDQ1NTU1NjY2Njc3Nzc4ODg4OTk5OTo6Ojo7Ozs7PDw8PD09PT0+Pj4+Pz8/PwBBqesZCwUEBAAABABBwOsZC+ABCAwQDAwUDBAYHAwMIAwkDCwsLCwsLCwsLCwgIBgoHAwMMDQ0NDA0NDQwNDQ0NDQwNDQ0NDQwNDQ0NDQYDBwMDAw4PDw8ODw8PDg8PDw8PDg8PDw8PDg8PDw8PBgMHAwAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMAQcHtGQteAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQEBAQMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAQEBAQBBgO8ZC5dRAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIACAgICAgICAgICAgICAgIEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgwMDAwMDAwMDAwMDAwMDA4AAEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBgYGBgYGBgYGBgYGBgYGBwAAAAAAAAIAAAAAAQAAAwAAAAACAAAEAAAAAAMAAAUAAAAAAwAABgAAAAADAAAHAAAAAAMAAAgAAAAAAwAACQAAAAAAAQACAAAAAAEBAAMAAAAAAgEABAAAAAADAQAFAAAAAAMBAAYAAAAAAwEABwAAAAADAQAIAAAAAAMBAAkAAAAAAAIAAgAAAAABAgADAAAAAAICAAQAAAAAAwIABQAAAAADAgAGAAAAAAMCAAcAAAAAAwIACAAAAAADAgAJAAAAAAADAAIAAAAAAQMAAwAAAAACAwAEAAAAAAMDAAUAAAAAAwMABgAAAAADAwAHAAAAAAMDAAgAAAAAAwMACQAAAAAABAACAAAAAAEEAAMAAAAAAgQABAAAAAADBAAFAAAAAAMEAAYAAAAAAwQABwAAAAADBAAIAAAAAAMEAAkAAAAAAAUAAgAAAAABBQADAAAAAAIFAAQAAAAAAwUABQAAAAADBQAGAAAAAAMFAAcAAAAAAwUACAAAAAADBQAJAAEAAAAGAAIAAQAAAQYAAwABAAACBgAEAAEAAAMGAAUAAQAAAwYABgABAAADBgAHAAEAAAMGAAgAAQAAAwYACQABAAAACAACAAEAAAEIAAMAAQAAAggABAABAAADCAAFAAEAAAMIAAYAAQAAAwgABwABAAADCAAIAAEAAAMIAAkAAAEAAwAACgAAAQADAAAMAAACAAMAAA4AAAIAAwAAEgAAAwADAAAWAAADAAMAAB4AAAQAAwAAJgAABAADAAA2AAABAAMBAAoAAAEAAwEADAAAAgADAQAOAAACAAMBABIAAAMAAwEAFgAAAwADAQAeAAAEAAMBACYAAAQAAwEANgAAAQADAgAKAAABAAMCAAwAAAIAAwIADgAAAgADAgASAAADAAMCABYAAAMAAwIAHgAABAADAgAmAAAEAAMCADYAAAEAAwMACgAAAQADAwAMAAACAAMDAA4AAAIAAwMAEgAAAwADAwAWAAADAAMDAB4AAAQAAwMAJgAABAADAwA2AAABAAMEAAoAAAEAAwQADAAAAgADBAAOAAACAAMEABIAAAMAAwQAFgAAAwADBAAeAAAEAAMEACYAAAQAAwQANgAAAQADBQAKAAABAAMFAAwAAAIAAwUADgAAAgADBQASAAADAAMFABYAAAMAAwUAHgAABAADBQAmAAAEAAMFADYAAQEAAwYACgABAQADBgAMAAECAAMGAA4AAQIAAwYAEgABAwADBgAWAAEDAAMGAB4AAQQAAwYAJgABBAADBgA2AAEBAAMIAAoAAQEAAwgADAABAgADCAAOAAECAAMIABIAAQMAAwgAFgABAwADCAAeAAEEAAMIACYAAQQAAwgANgAAAP8AAAACAAAA/wEAAAMAAAD/AgAABAAAAP8DAAAFAAAA/wMAAAYAAAD/AwAABwAAAP8DAAAIAAAA/wMAAAkAAAD/AAEAAgAAAP8BAQADAAAA/wIBAAQAAAD/AwEABQAAAP8DAQAGAAAA/wMBAAcAAAD/AwEACAAAAP8DAQAJAAAA/wACAAIAAAD/AQIAAwAAAP8CAgAEAAAA/wMCAAUAAAD/AwIABgAAAP8DAgAHAAAA/wMCAAgAAAD/AwIACQAAAP8AAwACAAAA/wEDAAMAAAD/AgMABAAAAP8DAwAFAAAA/wMDAAYAAAD/AwMABwAAAP8DAwAIAAAA/wMDAAkAAAD/AAQAAgAAAP8BBAADAAAA/wIEAAQAAAD/AwQABQAAAP8DBAAGAAAA/wMEAAcAAAD/AwQACAAAAP8DBAAJAAAA/wAFAAIAAAD/AQUAAwAAAP8CBQAEAAAA/wMFAAUAAAD/AwUABgAAAP8DBQAHAAAA/wMFAAgAAAD/AwUACQABAP8ABgACAAEA/wEGAAMAAQD/AgYABAABAP8DBgAFAAEA/wMGAAYAAQD/AwYABwABAP8DBgAIAAEA/wMGAAkAAQD/AAgAAgABAP8BCAADAAEA/wIIAAQAAQD/AwgABQABAP8DCAAGAAEA/wMIAAcAAQD/AwgACAABAP8DCAAJAAAB/wMAAAoAAAH/AwAADAAAAv8DAAAOAAAC/wMAABIAAAP/AwAAFgAAA/8DAAAeAAAE/wMAACYAAAT/AwAANgAAAf8DAQAKAAAB/wMBAAwAAAL/AwEADgAAAv8DAQASAAAD/wMBABYAAAP/AwEAHgAABP8DAQAmAAAE/wMBADYAAAH/AwIACgAAAf8DAgAMAAAC/wMCAA4AAAL/AwIAEgAAA/8DAgAWAAAD/wMCAB4AAAT/AwIAJgAABP8DAgA2AAAB/wMDAAoAAAH/AwMADAAAAv8DAwAOAAAC/wMDABIAAAP/AwMAFgAAA/8DAwAeAAAE/wMDACYAAAT/AwMANgAAAf8DBAAKAAAB/wMEAAwAAAL/AwQADgAAAv8DBAASAAAD/wMEABYAAAP/AwQAHgAABP8DBAAmAAAE/wMEADYAAAH/AwUACgAAAf8DBQAMAAAC/wMFAA4AAAL/AwUAEgAAA/8DBQAWAAAD/wMFAB4AAAT/AwUAJgAABP8DBQA2AAEB/wMGAAoAAQH/AwYADAABAv8DBgAOAAEC/wMGABIAAQP/AwYAFgABA/8DBgAeAAEE/wMGACYAAQT/AwYANgABAf8DCAAKAAEB/wMIAAwAAQL/AwgADgABAv8DCAASAAED/wMIABYAAQP/AwgAHgABBP8DCAAmAAEE/wMIADYAAgD/AAoAAgACAP8BCgADAAIA/wIKAAQAAgD/AwoABQACAP8DCgAGAAIA/wMKAAcAAgD/AwoACAACAP8DCgAJAAIA/wAOAAIAAgD/AQ4AAwACAP8CDgAEAAIA/wMO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tnb2Do5Ozi6ubu4enl7ePr5+/gGBQcEhoWHhEZFR0TGxcfEJiUnJKalp6RmZWdk5uXn5BYVFxSWlZeUVlVXVNbV19Q2NTc0trW3tHZ1d3T29ff0Dg0PDI6Nj4xOTU9Mzs3PzC4tLyyura+sbm1vbO7t7+weHR8cnp2fnF5dX1ze3d/cPj0/PL69v7x+fX98/v3//AAGSAbQB1AH0ARYCNgJWAnYClgK2AtYC9gIWAzYDVgN2A5gDuAPYA/gDGAQ4BFgEeASYBLgE2AT4BBgFOAVYBXgFmAW4BdgF+AVOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAAAABUngYA6pAGAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAABUngYANJEGAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAAVJ4GAHyRBgBOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAFSeBgDIkQYATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAABUngYAFJIGAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAVJ4GADySBgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAFSeBgBkkgYATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAABUngYAjJIGAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAVJ4GALSSBgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAFSeBgDckgYATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAABUngYABJMGAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAVJ4GACyTBgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAAFSeBgBUkwYATjEwZW1zY3JpcHRlbjExbWVtb3J5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\")||(H=h,h=g.locateFile?g.locateFile(H,d):d+H);var j=A=>{for(;A.length>0;)A.shift()(g)};function v(A){this.excPtr=A,this.ptr=A-24,this.set_type=function(A){L[this.ptr+4>>2]=A},this.get_type=function(){return L[this.ptr+4>>2]},this.set_destructor=function(A){L[this.ptr+8>>2]=A},this.get_destructor=function(){return L[this.ptr+8>>2]},this.set_caught=function(A){A=A?1:0,w[this.ptr+12>>0]=A},this.get_caught=function(){return 0!=w[this.ptr+12>>0]},this.set_rethrown=function(A){A=A?1:0,w[this.ptr+13>>0]=A},this.get_rethrown=function(){return 0!=w[this.ptr+13>>0]},this.init=function(A,g){this.set_adjusted_ptr(0),this.set_type(A),this.set_destructor(g)},this.set_adjusted_ptr=function(A){L[this.ptr+16>>2]=A},this.get_adjusted_ptr=function(){return L[this.ptr+16>>2]},this.get_exception_ptr=function(){if(AP(this.get_type()))return L[this.excPtr>>2];var A=this.get_adjusted_ptr();return 0!==A?A:this.excPtr}}var O=0,r=0,P=A=>{for(var g=\"\",C=A;D[C];)g+=F[D[C++]];return g},z={},e={},T={},f=A=>{throw new s(A)},_=A=>{throw new N(A)},$=(A,g,C)=>{function B(g){var B=C(g);B.length!==A.length&&_(\"Mismatched type converter count\");for(var I=0;I<A.length;++I)AA(A[I],B[I])}A.forEach(function(A){T[A]=g});var I=Array(g.length),Q=[],E=0;g.forEach((A,g)=>{e.hasOwnProperty(A)?I[g]=e[A]:(Q.push(A),z.hasOwnProperty(A)||(z[A]=[]),z[A].push(()=>{I[g]=e[A],++E===Q.length&&B(I)}))}),0===Q.length&&B(I)};function AA(A,g,C={}){if(!(\"argPackAdvance\"in g))throw TypeError(\"registerType registeredInstance requires argPackAdvance\");return function(A,g,C={}){var B=g.name;if(A||f(`type \"${B}\" must have a positive integer typeid pointer`),e.hasOwnProperty(A)){if(C.ignoreDuplicateRegistrations)return;f(`Cannot register type '${B}' twice`)}if(e[A]=g,delete T[A],z.hasOwnProperty(A)){var I=z[A];delete z[A],I.forEach(A=>A())}}(A,g,C)}function Ag(){this.allocated=[void 0],this.freelist=[]}var AC=new Ag,AB=A=>{A>=AC.reserved&&0==--AC.get(A).refcount&&AC.free(A)},AI={toValue:A=>(A||f(\"Cannot use deleted val. handle = \"+A),AC.get(A).value),toHandle:A=>{switch(A){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return AC.allocate({refcount:1,value:A})}}};function AQ(A){return this.fromWireType(o[A>>2])}var AE=(A,g)=>{switch(g){case 4:return function(A){return this.fromWireType(Y[A>>2])};case 8:return function(A){return this.fromWireType(c[A>>3])};default:throw TypeError(`invalid float width (${g}): ${A}`)}},Aw=A=>{if(void 0===A)return\"_unknown\";var g=(A=A.replace(/[^a-zA-Z0-9_]/g,\"$\")).charCodeAt(0);return g>=48&&g<=57?`_${A}`:A},AD=A=>{for(;A.length;){var g=A.pop();A.pop()(g)}};function AG(A,g){return({[A=Aw(A)]:function(){return g.apply(this,arguments)}})[A]}var Ai=(A,g,C)=>{if(void 0===A[g].overloadTable){var B=A[g];A[g]=function(){return A[g].overloadTable.hasOwnProperty(arguments.length)||f(`Function '${C}' called with an invalid number of arguments (${arguments.length}) - expects one of (${A[g].overloadTable})!`),A[g].overloadTable[arguments.length].apply(this,arguments)},A[g].overloadTable=[],A[g].overloadTable[B.argCount]=B}},Ao=(A,C,B)=>{g.hasOwnProperty(A)?((void 0===B||void 0!==g[A].overloadTable&&void 0!==g[A].overloadTable[B])&&f(`Cannot register public name '${A}' twice`),Ai(g,A,A),g.hasOwnProperty(B)&&f(`Cannot register multiple overloads of a function with the same number of arguments (${B})!`),g[A].overloadTable[B]=C):(g[A]=C,void 0!==B&&(g[A].numArguments=B))},AL=(A,g)=>{for(var C=[],B=0;B<A;B++)C.push(L[g+4*B>>2]);return C},AY=(A,C,B)=>{g.hasOwnProperty(A)||_(\"Replacing nonexistant public symbol\"),void 0!==g[A].overloadTable&&void 0!==B?g[A].overloadTable[B]=C:(g[A]=C,g[A].argCount=B)},Ac=(A,C,B)=>{var I=g[\"dynCall_\"+A];return B&&B.length?I.apply(null,[C].concat(B)):I.call(null,C)},Ah=[],AF=A=>{var g=Ah[A];return g||(A>=Ah.length&&(Ah.length=A+1),Ah[A]=g=K.get(A)),g},As=(A,g,C)=>A.includes(\"j\")?Ac(A,g,C):AF(g).apply(null,C),AN=(A,g)=>{var C=[];return function(){return C.length=0,Object.assign(C,arguments),As(A,g,C)}},AK=(A,g)=>{var C=(A=P(A)).includes(\"j\")?AN(A,g):AF(g);return\"function\"!=typeof C&&f(`unknown function pointer with signature ${A}: ${g}`),C},Aa=A=>{var g=Ar(A),C=P(g);return AO(g),C},AR=(A,g)=>{var C=[],B={};throw g.forEach(function A(g){if(!B[g]&&!e[g]){if(T[g]){T[g].forEach(A);return}C.push(g),B[g]=!0}}),new a(`${A}: `+C.map(Aa).join([\", \"]))},AH=(A,g,C)=>{switch(g){case 1:return C?A=>w[A>>0]:A=>D[A>>0];case 2:return C?A=>G[A>>1]:A=>i[A>>1];case 4:return C?A=>o[A>>2]:A=>L[A>>2];default:throw TypeError(`invalid integer width (${g}): ${A}`)}};function Ak(A){return this.fromWireType(L[A>>2])}var AJ=(A,g,C,B)=>{if(!(B>0))return 0;for(var I=C,Q=C+B-1,E=0;E<A.length;++E){var w=A.charCodeAt(E);if(w>=55296&&w<=57343&&(w=65536+((1023&w)<<10)|1023&A.charCodeAt(++E)),w<=127){if(C>=Q)break;g[C++]=w}else if(w<=2047){if(C+1>=Q)break;g[C++]=192|w>>6,g[C++]=128|63&w}else if(w<=65535){if(C+2>=Q)break;g[C++]=224|w>>12,g[C++]=128|w>>6&63,g[C++]=128|63&w}else{if(C+3>=Q)break;g[C++]=240|w>>18,g[C++]=128|w>>12&63,g[C++]=128|w>>6&63,g[C++]=128|63&w}}return g[C]=0,C-I},AZ=(A,g,C)=>AJ(A,D,g,C),AM=A=>{for(var g=0,C=0;C<A.length;++C){var B=A.charCodeAt(C);B<=127?g++:B<=2047?g+=2:B>=55296&&B<=57343?(g+=4,++C):g+=3}return g},AW=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,Ad=(A,g,C)=>{for(var B=g+C,I=g;A[I]&&!(I>=B);)++I;if(I-g>16&&A.buffer&&AW)return AW.decode(A.subarray(g,I));for(var Q=\"\";g<I;){var E=A[g++];if(!(128&E)){Q+=String.fromCharCode(E);continue}var w=63&A[g++];if((224&E)==192){Q+=String.fromCharCode((31&E)<<6|w);continue}var D=63&A[g++];if((E=(240&E)==224?(15&E)<<12|w<<6|D:(7&E)<<18|w<<12|D<<6|63&A[g++])<65536)Q+=String.fromCharCode(E);else{var G=E-65536;Q+=String.fromCharCode(55296|G>>10,56320|1023&G)}}return Q},Ay=(A,g)=>A?Ad(D,A,g):\"\",AU=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf-16le\"):void 0,Ap=(A,g)=>{for(var C=A,B=C>>1,I=B+g/2;!(B>=I)&&i[B];)++B;if((C=B<<1)-A>32&&AU)return AU.decode(D.subarray(A,C));for(var Q=\"\",E=0;!(E>=g/2);++E){var w=G[A+2*E>>1];if(0==w)break;Q+=String.fromCharCode(w)}return Q},Ab=(A,g,C)=>{if(void 0===C&&(C=2147483647),C<2)return 0;for(var B=g,I=(C-=2)<2*A.length?C/2:A.length,Q=0;Q<I;++Q){var E=A.charCodeAt(Q);G[g>>1]=E,g+=2}return G[g>>1]=0,g-B},Al=A=>2*A.length,AS=(A,g)=>{for(var C=0,B=\"\";!(C>=g/4);){var I=o[A+4*C>>2];if(0==I)break;if(++C,I>=65536){var Q=I-65536;B+=String.fromCharCode(55296|Q>>10,56320|1023&Q)}else B+=String.fromCharCode(I)}return B},Am=(A,g,C)=>{if(void 0===C&&(C=2147483647),C<4)return 0;for(var B=g,I=B+C-4,Q=0;Q<A.length;++Q){var E=A.charCodeAt(Q);if(E>=55296&&E<=57343&&(E=65536+((1023&E)<<10)|1023&A.charCodeAt(++Q)),o[g>>2]=E,(g+=4)+4>I)break}return o[g>>2]=0,g-B},Aq=A=>{for(var g=0,C=0;C<A.length;++C){var B=A.charCodeAt(C);B>=55296&&B<=57343&&++C,g+=4}return g},At=(A,g)=>{var C=e[A];return void 0===C&&f(g+\" has unknown type \"+Aa(A)),C},AV=()=>2147483648,AX=A=>{var g=(A-E.buffer.byteLength+65535)/65536;try{return E.grow(g),b(),1}catch(A){}},Au={varargs:void 0,get(){var A=o[+Au.varargs>>2];return Au.varargs+=4,A},getp:()=>Au.get(),getStr:A=>Ay(A)},An=A=>{U||(g.onExit&&g.onExit(A),p=!0),W(A,new x(A))};(()=>{for(var A=Array(256),g=0;g<256;++g)A[g]=String.fromCharCode(g);F=A})(),s=g.BindingError=class extends Error{constructor(A){super(A),this.name=\"BindingError\"}},N=g.InternalError=class extends Error{constructor(A){super(A),this.name=\"InternalError\"}},Object.assign(Ag.prototype,{get(A){return this.allocated[A]},has(A){return void 0!==this.allocated[A]},allocate(A){var g=this.freelist.pop()||this.allocated.length;return this.allocated[g]=A,g},free(A){this.allocated[A]=void 0,this.freelist.push(A)}}),AC.allocated.push({value:void 0},{value:null},{value:!0},{value:!1}),AC.reserved=AC.allocated.length,g.count_emval_handles=()=>{for(var A=0,g=AC.reserved;g<AC.allocated.length;++g)void 0!==AC.allocated[g]&&++A;return A},a=g.UnboundTypeError=(k=Error,(Z=AG(J=\"UnboundTypeError\",function(A){this.name=J,this.message=A;var g=Error(A).stack;void 0!==g&&(this.stack=this.toString()+\"\\n\"+g.replace(/^Error(:[^\\n]*)?\\n/,\"\"))})).prototype=Object.create(k.prototype),Z.prototype.constructor=Z,Z.prototype.toString=function(){return void 0===this.message?this.name:`${this.name}: ${this.message}`},Z);var Ax={e:(A,g,C)=>{throw new v(A).init(g,C),O=A,r++,O},n:(A,g,C,B,I)=>{},i:(A,g,C,B)=>{AA(A,{name:g=P(g),fromWireType:function(A){return!!A},toWireType:function(A,g){return g?C:B},argPackAdvance:8,readValueFromPointer:function(A){return this.fromWireType(D[A])},destructorFunction:null})},r:(A,g)=>{AA(A,{name:g=P(g),fromWireType:A=>{var g=AI.toValue(A);return AB(A),g},toWireType:(A,g)=>AI.toHandle(g),argPackAdvance:8,readValueFromPointer:AQ,destructorFunction:null})},f:(A,g,C)=>{AA(A,{name:g=P(g),fromWireType:A=>A,toWireType:(A,g)=>g,argPackAdvance:8,readValueFromPointer:AE(g,C),destructorFunction:null})},c:(A,g,C,B,I,Q,E)=>{var w=AL(g,C);A=P(A),I=AK(B,I),Ao(A,function(){AR(`Cannot call ${A} due to unbound types`,w)},g-1),$([],w,function(C){return AY(A,function(A,g,C,B,I,Q){var E=g.length;E<2&&f(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");for(var w=null!==g[1]&&!1,D=!1,G=1;G<g.length;++G)if(null!==g[G]&&void 0===g[G].destructorFunction){D=!0;break}for(var i=\"void\"!==g[0].name,o=\"\",L=\"\",G=0;G<E-2;++G)o+=(0!==G?\", \":\"\")+\"arg\"+G,L+=(0!==G?\", \":\"\")+\"arg\"+G+\"Wired\";var Y=`\n        return function ${Aw(A)}(${o}) {\n        if (arguments.length !== ${E-2}) {\n          throwBindingError('function ${A} called with ' + arguments.length + ' arguments, expected ${E-2}');\n        }`;D&&(Y+=\"var destructors = [];\\n\");var c=D?\"destructors\":\"null\",h=[\"throwBindingError\",\"invoker\",\"fn\",\"runDestructors\",\"retType\",\"classParam\"],F=[f,B,I,AD,g[0],g[1]];w&&(Y+=\"var thisWired = classParam.toWireType(\"+c+\", this);\\n\");for(var G=0;G<E-2;++G)Y+=\"var arg\"+G+\"Wired = argType\"+G+\".toWireType(\"+c+\", arg\"+G+\"); // \"+g[G+2].name+\"\\n\",h.push(\"argType\"+G),F.push(g[G+2]);if(w&&(L=\"thisWired\"+(L.length>0?\", \":\"\")+L),Y+=(i||Q?\"var rv = \":\"\")+\"invoker(fn\"+(L.length>0?\", \":\"\")+L+\");\\n\",D)Y+=\"runDestructors(destructors);\\n\";else for(var G=w?1:2;G<g.length;++G){var s=1===G?\"thisWired\":\"arg\"+(G-2)+\"Wired\";null!==g[G].destructorFunction&&(Y+=s+\"_dtor(\"+s+\"); // \"+g[G].name+\"\\n\",h.push(s+\"_dtor\"),F.push(g[G].destructorFunction))}return i&&(Y+=\"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\"),Y+=\"}\\n\",h.push(Y),(function(A,g){if(!(A instanceof Function))throw TypeError(`new_ called with constructor type ${typeof A} which is not a function`);var C=AG(A.name||\"unknownFunctionName\",function(){});C.prototype=A.prototype;var B=new C,I=A.apply(B,g);return I instanceof Object?I:B})(Function,h).apply(null,F)}(A,[C[0],null].concat(C.slice(1)),0,I,Q,E),g-1),[]})},b:(A,g,C,B,I)=>{g=P(g),-1===I&&(I=4294967295);var Q=A=>A;if(0===B){var E=32-8*C;Q=A=>A<<E>>>E}var w=g.includes(\"unsigned\"),D=(A,g)=>{};AA(A,{name:g,fromWireType:Q,toWireType:w?function(A,g){return D(g,this.name),g>>>0}:function(A,g){return D(g,this.name),g},argPackAdvance:8,readValueFromPointer:AH(g,C,0!==B),destructorFunction:null})},a:(A,g,C)=>{var B=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][g];function I(A){var g=L[A>>2],C=L[A+4>>2];return new B(w.buffer,C,g)}AA(A,{name:C=P(C),fromWireType:I,argPackAdvance:8,readValueFromPointer:I},{ignoreDuplicateRegistrations:!0})},g:(A,g)=>{var C=\"std::string\"===(g=P(g));AA(A,{name:g,fromWireType(A){var g,B=L[A>>2],I=A+4;if(C)for(var Q=I,E=0;E<=B;++E){var w=I+E;if(E==B||0==D[w]){var G=w-Q,i=Ay(Q,G);void 0===g?g=i:g+=\"\\x00\"+i,Q=w+1}}else{for(var o=Array(B),E=0;E<B;++E)o[E]=String.fromCharCode(D[I+E]);g=o.join(\"\")}return AO(A),g},toWireType(A,g){g instanceof ArrayBuffer&&(g=new Uint8Array(g));var B,I=\"string\"==typeof g;I||g instanceof Uint8Array||g instanceof Uint8ClampedArray||g instanceof Int8Array||f(\"Cannot pass non-string to std::string\"),B=C&&I?AM(g):g.length;var Q=Av(4+B+1),E=Q+4;if(L[Q>>2]=B,C&&I)AZ(g,E,B+1);else if(I)for(var w=0;w<B;++w){var G=g.charCodeAt(w);G>255&&(AO(E),f(\"String has UTF-16 code units that do not fit in 8 bits\")),D[E+w]=G}else for(var w=0;w<B;++w)D[E+w]=g[w];return null!==A&&A.push(AO,Q),Q},argPackAdvance:8,readValueFromPointer:Ak,destructorFunction(A){AO(A)}})},d:(A,g,C)=>{var B,I,Q,E,w;C=P(C),2===g?(B=Ap,I=Ab,E=Al,Q=()=>i,w=1):4===g&&(B=AS,I=Am,E=Aq,Q=()=>L,w=2),AA(A,{name:C,fromWireType:A=>{for(var C,I=L[A>>2],E=Q(),D=A+4,G=0;G<=I;++G){var i=A+4+G*g;if(G==I||0==E[i>>w]){var o=i-D,Y=B(D,o);void 0===C?C=Y:C+=\"\\x00\"+Y,D=i+g}}return AO(A),C},toWireType:(A,B)=>{\"string\"!=typeof B&&f(`Cannot pass non-string to C++ string type ${C}`);var Q=E(B),D=Av(4+Q+g);return L[D>>2]=Q>>w,I(B,D+4,Q+g),null!==A&&A.push(AO,D),D},argPackAdvance:8,readValueFromPointer:AQ,destructorFunction(A){AO(A)}})},j:(A,g)=>{AA(A,{isVoid:!0,name:g=P(g),argPackAdvance:0,fromWireType:()=>void 0,toWireType:(A,g)=>void 0})},l:AB,m:A=>{A>4&&(AC.get(A).refcount+=1)},h:(A,g)=>{var C=(A=At(A,\"_emval_take_value\")).readValueFromPointer(g);return AI.toHandle(C)},o:()=>{X(\"\")},q:(A,g,C)=>D.copyWithin(A,g,g+C),p:A=>{var g=D.length;A>>>=0;var C=AV();if(A>C)return!1;for(var B=(A,g)=>A+(g-A%g)%g,I=1;I<=4;I*=2){var Q=g*(1+.2/I);if(Q=Math.min(Q,A+100663296),AX(Math.min(C,B(Math.max(A,Q),65536))))return!0}return!1},k:(A,g)=>{An(A)}},Aj=function(){var A,C={a:Ax};function w(A,C){var B;return E=(Aj=A.exports).s,b(),K=Aj.u,B=Aj.t,S.unshift(B),function(A){if(q--,g.monitorRunDependencies&&g.monitorRunDependencies(q),0==q&&(null!==t&&(clearInterval(t),t=null),V)){var C=V;V=null,C()}}(0),Aj}if(q++,g.monitorRunDependencies&&g.monitorRunDependencies(q),g.instantiateWasm)try{return g.instantiateWasm(C,w)}catch(A){y(`Module.instantiateWasm callback failed with error: ${A}`),B(A)}return(A=h,Promise.resolve().then(()=>(function(A){if(A==h&&Q)return new Uint8Array(Q);var g=function(A){if(n(A))return function(A){try{for(var g=atob(A),C=new Uint8Array(g.length),B=0;B<g.length;++B)C[B]=g.charCodeAt(B);return C}catch(A){throw Error(\"Converting base64 string to bytes failed.\")}}(A.slice(u.length))}(A);if(g)return g;if(I)return I(A);throw\"both async and sync fetching of the wasm failed\"})(A)).then(A=>WebAssembly.instantiate(A,C)).then(A=>A).then(function(A){w(A.instance)},A=>{y(`failed to asynchronously prepare wasm: ${A}`),X(A)})).catch(B),{}}(),Av=A=>(Av=Aj.v)(A),AO=A=>(AO=Aj.w)(A),Ar=A=>(Ar=Aj.x)(A),AP=(g.__embind_initialize_bindings=()=>(g.__embind_initialize_bindings=Aj.y)(),A=>(AP=Aj.z)(A));function Az(){!(q>0)&&(function(){if(g.preRun)for(\"function\"==typeof g.preRun&&(g.preRun=[g.preRun]);g.preRun.length;){var A;A=g.preRun.shift(),l.unshift(A)}j(l)}(),q>0||(g.setStatus?(g.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){g.setStatus(\"\")},1),A()},1)):A()));function A(){!R&&(R=!0,g.calledRun=!0,p||(j(S),C(g),g.onRuntimeInitialized&&g.onRuntimeInitialized(),function(){if(g.postRun)for(\"function\"==typeof g.postRun&&(g.postRun=[g.postRun]);g.postRun.length;){var A;A=g.postRun.shift(),m.unshift(A)}j(m)}()))}}if(V=function A(){R||Az(),R||(V=A)},g.preInit)for(\"function\"==typeof g.preInit&&(g.preInit=[g.preInit]);g.preInit.length>0;)g.preInit.pop()();return Az(),g.ready});let C=new Promise(A=>{g({onRuntimeInitialized(){A(this)}})});/**\n * Asynchronously loads the WOFF2 module.\n *\n * @returns A promise resolving to the WOFF2 module.\n * @internal\n */async function B(){let A=await C;return new Promise(g=>{setTimeout(()=>{g(A)},0)})}async function I(A){let g=await B(),C=await g.compress(A);if(!C)throw Error(\"Failed to compress the font data.\");return Uint8Array.from(C)}async function Q(A){let g=await B(),C=await g.decompress(A);if(!C)throw Error(\"Failed to decompress the font data.\");return Uint8Array.from(C)}export{I as compress,Q as decompress};","/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n(function () { 'use strict';\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2.x;\n            y = p2.y;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n\n    return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n\n    if (points.length <= 2) return points;\n\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n\n// export as AMD module / Node module / browser or worker variable\nif (typeof define === 'function' && define.amd) define(function() { return simplify; });\nelse if (typeof module !== 'undefined') {\n    module.exports = simplify;\n    module.exports.default = simplify;\n} else if (typeof self !== 'undefined') self.simplify = simplify;\nelse window.simplify = simplify;\n\n})();\n","(function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"module\"], factory);\n    } else if (typeof exports !== \"undefined\") {\n        factory(module);\n    } else {\n        var mod = {\n            exports: {}\n        };\n        factory(mod);\n        global.fitCurve = mod.exports;\n    }\n})(this, function (module) {\n    \"use strict\";\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    /**\n     *  @preserve  JavaScript implementation of\n     *  Algorithm for Automatically Fitting Digitized Curves\n     *  by Philip J. Schneider\n     *  \"Graphics Gems\", Academic Press, 1990\n     *\n     *  The MIT License (MIT)\n     *\n     *  https://github.com/soswow/fit-curves\n     */\n\n    /**\n     * Fit one or more Bezier curves to a set of points.\n     *\n     * @param {Array<Array<Number>>} points - Array of digitized points, e.g. [[5,5],[5,50],[110,140],[210,160],[320,110]]\n     * @param {Number} maxError - Tolerance, squared error between points and fitted curve\n     * @returns {Array<Array<Array<Number>>>} Array of Bezier curves, where each element is [first-point, control-point-1, control-point-2, second-point] and points are [x, y]\n     */\n    function fitCurve(points, maxError, progressCallback) {\n        if (!Array.isArray(points)) {\n            throw new TypeError(\"First argument should be an array\");\n        }\n        points.forEach(function (point) {\n            if (!Array.isArray(point) || point.some(function (item) {\n                return typeof item !== 'number';\n            }) || point.length !== points[0].length) {\n                throw Error(\"Each point should be an array of numbers. Each point should have the same amount of numbers.\");\n            }\n        });\n\n        // Remove duplicate points\n        points = points.filter(function (point, i) {\n            return i === 0 || !point.every(function (val, j) {\n                return val === points[i - 1][j];\n            });\n        });\n\n        if (points.length < 2) {\n            return [];\n        }\n\n        var len = points.length;\n        var leftTangent = createTangent(points[1], points[0]);\n        var rightTangent = createTangent(points[len - 2], points[len - 1]);\n\n        return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);\n    }\n\n    /**\n     * Fit a Bezier curve to a (sub)set of digitized points.\n     * Your code should not call this function directly. Use {@link fitCurve} instead.\n     *\n     * @param {Array<Array<Number>>} points - Array of digitized points, e.g. [[5,5],[5,50],[110,140],[210,160],[320,110]]\n     * @param {Array<Number>} leftTangent - Unit tangent vector at start point\n     * @param {Array<Number>} rightTangent - Unit tangent vector at end point\n     * @param {Number} error - Tolerance, squared error between points and fitted curve\n     * @returns {Array<Array<Array<Number>>>} Array of Bezier curves, where each element is [first-point, control-point-1, control-point-2, second-point] and points are [x, y]\n     */\n    function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {\n        var MaxIterations = 20; //Max times to try iterating (to find an acceptable curve)\n\n        var bezCurve, //Control points of fitted Bezier curve\n        u, //Parameter values for point\n        uPrime, //Improved parameter values\n        maxError, prevErr, //Maximum fitting error\n        splitPoint, prevSplit, //Point to split point set at if we need more than one curve\n        centerVector, toCenterTangent, fromCenterTangent, //Unit tangent vector(s) at splitPoint\n        beziers, //Array of fitted Bezier curves if we need more than one curve\n        dist, i;\n\n        //console.log('fitCubic, ', points.length);\n\n        //Use heuristic if region only has two points in it\n        if (points.length === 2) {\n            dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0;\n            bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]];\n            return [bezCurve];\n        }\n\n        //Parameterize points, and attempt to fit curve\n        u = chordLengthParameterize(points);\n\n        var _generateAndReport = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);\n\n        bezCurve = _generateAndReport[0];\n        maxError = _generateAndReport[1];\n        splitPoint = _generateAndReport[2];\n\n\n        if (maxError === 0 || maxError < error) {\n            return [bezCurve];\n        }\n        //If error not too large, try some reparameterization and iteration\n        if (maxError < error * error) {\n\n            uPrime = u;\n            prevErr = maxError;\n            prevSplit = splitPoint;\n\n            for (i = 0; i < MaxIterations; i++) {\n\n                uPrime = reparameterize(bezCurve, points, uPrime);\n\n                var _generateAndReport2 = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);\n\n                bezCurve = _generateAndReport2[0];\n                maxError = _generateAndReport2[1];\n                splitPoint = _generateAndReport2[2];\n\n\n                if (maxError < error) {\n                    return [bezCurve];\n                }\n                //If the development of the fitted curve grinds to a halt,\n                //we abort this attempt (and try a shorter curve):\n                else if (splitPoint === prevSplit) {\n                        var errChange = maxError / prevErr;\n                        if (errChange > .9999 && errChange < 1.0001) {\n                            break;\n                        }\n                    }\n\n                prevErr = maxError;\n                prevSplit = splitPoint;\n            }\n        }\n\n        //Fitting failed -- split at max error point and fit recursively\n        beziers = [];\n\n        //To create a smooth transition from one curve segment to the next, we\n        //calculate the line between the points directly before and after the\n        //center, and use that as the tangent both to and from the center point.\n        centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);\n        //However, this won't work if they're the same point, because the line we\n        //want to use as a tangent would be 0. Instead, we calculate the line from\n        //that \"double-point\" to the center point, and use its tangent.\n        if (centerVector.every(function (val) {\n            return val === 0;\n        })) {\n            //[x,y] -> [-y,x]: http://stackoverflow.com/a/4780141/1869660\n            centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);\n            var _ref = [-centerVector[1], centerVector[0]];\n            centerVector[0] = _ref[0];\n            centerVector[1] = _ref[1];\n        }\n        toCenterTangent = maths.normalize(centerVector);\n        //To and from need to point in opposite directions:\n        fromCenterTangent = maths.mulItems(toCenterTangent, -1);\n\n        /*\n        Note: An alternative to this \"divide and conquer\" recursion could be to always\n              let new curve segments start by trying to go all the way to the end,\n              instead of only to the end of the current subdivided polyline.\n              That might let many segments fit a few points more, reducing the number of total segments.\n               However, a few tests have shown that the segment reduction is insignificant\n              (240 pts, 100 err: 25 curves vs 27 curves. 140 pts, 100 err: 17 curves on both),\n              and the results take twice as many steps and milliseconds to finish,\n              without looking any better than what we already have.\n        */\n        beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));\n        beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));\n        return beziers;\n    };\n\n    function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {\n        var bezCurve, maxError, splitPoint;\n\n        bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);\n        //Find max deviation of points to fitted curve.\n        //Here we always use the original parameters (from chordLengthParameterize()),\n        //because we need to compare the current curve to the actual source polyline,\n        //and not the currently iterated parameters which reparameterize() & generateBezier() use,\n        //as those have probably drifted far away and may no longer be in ascending order.\n\n        var _computeMaxError = computeMaxError(points, bezCurve, paramsOrig);\n\n        maxError = _computeMaxError[0];\n        splitPoint = _computeMaxError[1];\n\n\n        if (progressCallback) {\n            progressCallback({\n                bez: bezCurve,\n                points: points,\n                params: paramsOrig,\n                maxErr: maxError,\n                maxPoint: splitPoint\n            });\n        }\n\n        return [bezCurve, maxError, splitPoint];\n    }\n\n    /**\n     * Use least-squares method to find Bezier control points for region.\n     *\n     * @param {Array<Array<Number>>} points - Array of digitized points\n     * @param {Array<Number>} parameters - Parameter values for region\n     * @param {Array<Number>} leftTangent - Unit tangent vector at start point\n     * @param {Array<Number>} rightTangent - Unit tangent vector at end point\n     * @returns {Array<Array<Number>>} Approximated Bezier curve: [first-point, control-point-1, control-point-2, second-point] where points are [x, y]\n     */\n    function generateBezier(points, parameters, leftTangent, rightTangent) {\n        var bezCurve,\n            //Bezier curve ctl pts\n        A,\n            a,\n            //Precomputed rhs for eqn\n        C,\n            X,\n            //Matrices C & X\n        det_C0_C1,\n            det_C0_X,\n            det_X_C1,\n            //Determinants of matrices\n        alpha_l,\n            alpha_r,\n            //Alpha values, left and right\n\n        epsilon,\n            segLength,\n            i,\n            len,\n            tmp,\n            u,\n            ux,\n            firstPoint = points[0],\n            lastPoint = points[points.length - 1];\n\n        bezCurve = [firstPoint, null, null, lastPoint];\n        //console.log('gb', parameters.length);\n\n        //Compute the A's\n        A = maths.zeros_Xx2x2(parameters.length);\n        for (i = 0, len = parameters.length; i < len; i++) {\n            u = parameters[i];\n            ux = 1 - u;\n            a = A[i];\n\n            a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));\n            a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));\n        }\n\n        //Create the C and X matrices\n        C = [[0, 0], [0, 0]];\n        X = [0, 0];\n        for (i = 0, len = points.length; i < len; i++) {\n            u = parameters[i];\n            a = A[i];\n\n            C[0][0] += maths.dot(a[0], a[0]);\n            C[0][1] += maths.dot(a[0], a[1]);\n            C[1][0] += maths.dot(a[0], a[1]);\n            C[1][1] += maths.dot(a[1], a[1]);\n\n            tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));\n\n            X[0] += maths.dot(a[0], tmp);\n            X[1] += maths.dot(a[1], tmp);\n        }\n\n        //Compute the determinants of C and X\n        det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];\n        det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];\n        det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];\n\n        //Finally, derive alpha values\n        alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;\n        alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;\n\n        //If alpha negative, use the Wu/Barsky heuristic (see text).\n        //If alpha is 0, you get coincident control points that lead to\n        //divide by zero in any subsequent NewtonRaphsonRootFind() call.\n        segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));\n        epsilon = 1.0e-6 * segLength;\n        if (alpha_l < epsilon || alpha_r < epsilon) {\n            //Fall back on standard (probably inaccurate) formula, and subdivide further if needed.\n            bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0));\n            bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0));\n        } else {\n            //First and last control points of the Bezier curve are\n            //positioned exactly at the first and last data points\n            //Control points 1 and 2 are positioned an alpha distance out\n            //on the tangent vectors, left and right, respectively\n            bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));\n            bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));\n        }\n\n        return bezCurve;\n    };\n\n    /**\n     * Given set of points and their parameterization, try to find a better parameterization.\n     *\n     * @param {Array<Array<Number>>} bezier - Current fitted curve\n     * @param {Array<Array<Number>>} points - Array of digitized points\n     * @param {Array<Number>} parameters - Current parameter values\n     * @returns {Array<Number>} New parameter values\n     */\n    function reparameterize(bezier, points, parameters) {\n        /*\n        var j, len, point, results, u;\n        results = [];\n        for (j = 0, len = points.length; j < len; j++) {\n            point = points[j], u = parameters[j];\n             results.push(newtonRaphsonRootFind(bezier, point, u));\n        }\n        return results;\n        //*/\n        return parameters.map(function (p, i) {\n            return newtonRaphsonRootFind(bezier, points[i], p);\n        });\n    };\n\n    /**\n     * Use Newton-Raphson iteration to find better root.\n     *\n     * @param {Array<Array<Number>>} bez - Current fitted curve\n     * @param {Array<Number>} point - Digitized point\n     * @param {Number} u - Parameter value for \"P\"\n     * @returns {Number} New u\n     */\n    function newtonRaphsonRootFind(bez, point, u) {\n        /*\n            Newton's root finding algorithm calculates f(x)=0 by reiterating\n            x_n+1 = x_n - f(x_n)/f'(x_n)\n            We are trying to find curve parameter u for some point p that minimizes\n            the distance from that point to the curve. Distance point to curve is d=q(u)-p.\n            At minimum distance the point is perpendicular to the curve.\n            We are solving\n            f = q(u)-p * q'(u) = 0\n            with\n            f' = q'(u) * q'(u) + q(u)-p * q''(u)\n            gives\n            u_n+1 = u_n - |q(u_n)-p * q'(u_n)| / |q'(u_n)**2 + q(u_n)-p * q''(u_n)|\n        */\n\n        var d = maths.subtract(bezier.q(bez, u), point),\n            qprime = bezier.qprime(bez, u),\n            numerator = maths.mulMatrix(d, qprime),\n            denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));\n\n        if (denominator === 0) {\n            return u;\n        } else {\n            return u - numerator / denominator;\n        }\n    };\n\n    /**\n     * Assign parameter values to digitized points using relative distances between points.\n     *\n     * @param {Array<Array<Number>>} points - Array of digitized points\n     * @returns {Array<Number>} Parameter values\n     */\n    function chordLengthParameterize(points) {\n        var u = [],\n            currU,\n            prevU,\n            prevP;\n\n        points.forEach(function (p, i) {\n            currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;\n            u.push(currU);\n\n            prevU = currU;\n            prevP = p;\n        });\n        u = u.map(function (x) {\n            return x / prevU;\n        });\n\n        return u;\n    };\n\n    /**\n     * Find the maximum squared distance of digitized points to fitted curve.\n     *\n     * @param {Array<Array<Number>>} points - Array of digitized points\n     * @param {Array<Array<Number>>} bez - Fitted curve\n     * @param {Array<Number>} parameters - Parameterization of points\n     * @returns {Array<Number>} Maximum error (squared) and point of max error\n     */\n    function computeMaxError(points, bez, parameters) {\n        var dist, //Current error\n        maxDist, //Maximum error\n        splitPoint, //Point of maximum error\n        v, //Vector from point to curve\n        i, count, point, t;\n\n        maxDist = 0;\n        splitPoint = Math.floor(points.length / 2);\n\n        var t_distMap = mapTtoRelativeDistances(bez, 10);\n\n        for (i = 0, count = points.length; i < count; i++) {\n            point = points[i];\n            //Find 't' for a point on the bez curve that's as close to 'point' as possible:\n            t = find_t(bez, parameters[i], t_distMap, 10);\n\n            v = maths.subtract(bezier.q(bez, t), point);\n            dist = v[0] * v[0] + v[1] * v[1];\n\n            if (dist > maxDist) {\n                maxDist = dist;\n                splitPoint = i;\n            }\n        }\n\n        return [maxDist, splitPoint];\n    };\n\n    //Sample 't's and map them to relative distances along the curve:\n    var mapTtoRelativeDistances = function mapTtoRelativeDistances(bez, B_parts) {\n        var B_t_curr;\n        var B_t_dist = [0];\n        var B_t_prev = bez[0];\n        var sumLen = 0;\n\n        for (var i = 1; i <= B_parts; i++) {\n            B_t_curr = bezier.q(bez, i / B_parts);\n\n            sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));\n\n            B_t_dist.push(sumLen);\n            B_t_prev = B_t_curr;\n        }\n\n        //Normalize B_length to the same interval as the parameter distances; 0 to 1:\n        B_t_dist = B_t_dist.map(function (x) {\n            return x / sumLen;\n        });\n        return B_t_dist;\n    };\n\n    function find_t(bez, param, t_distMap, B_parts) {\n        if (param < 0) {\n            return 0;\n        }\n        if (param > 1) {\n            return 1;\n        }\n\n        /*\n            'param' is a value between 0 and 1 telling us the relative position\n            of a point on the source polyline (linearly from the start (0) to the end (1)).\n            To see if a given curve - 'bez' - is a close approximation of the polyline,\n            we compare such a poly-point to the point on the curve that's the same\n            relative distance along the curve's length.\n             But finding that curve-point takes a little work:\n            There is a function \"B(t)\" to find points along a curve from the parametric parameter 't'\n            (also relative from 0 to 1: http://stackoverflow.com/a/32841764/1869660\n                                        http://pomax.github.io/bezierinfo/#explanation),\n            but 't' isn't linear by length (http://gamedev.stackexchange.com/questions/105230).\n             So, we sample some points along the curve using a handful of values for 't'.\n            Then, we calculate the length between those samples via plain euclidean distance;\n            B(t) concentrates the points around sharp turns, so this should give us a good-enough outline of the curve.\n            Thus, for a given relative distance ('param'), we can now find an upper and lower value\n            for the corresponding 't' by searching through those sampled distances.\n            Finally, we just use linear interpolation to find a better value for the exact 't'.\n             More info:\n                http://gamedev.stackexchange.com/questions/105230/points-evenly-spaced-along-a-bezier-curve\n                http://stackoverflow.com/questions/29438398/cheap-way-of-calculating-cubic-bezier-length\n                http://steve.hollasch.net/cgindex/curves/cbezarclen.html\n                https://github.com/retuxx/tinyspline\n        */\n        var lenMax, lenMin, tMax, tMin, t;\n\n        //Find the two t-s that the current param distance lies between,\n        //and then interpolate a somewhat accurate value for the exact t:\n        for (var i = 1; i <= B_parts; i++) {\n\n            if (param <= t_distMap[i]) {\n                tMin = (i - 1) / B_parts;\n                tMax = i / B_parts;\n                lenMin = t_distMap[i - 1];\n                lenMax = t_distMap[i];\n\n                t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;\n                break;\n            }\n        }\n        return t;\n    }\n\n    /**\n     * Creates a vector of length 1 which shows the direction from B to A\n     */\n    function createTangent(pointA, pointB) {\n        return maths.normalize(maths.subtract(pointA, pointB));\n    }\n\n    /*\n        Simplified versions of what we need from math.js\n        Optimized for our input, which is only numbers and 1x2 arrays (i.e. [x, y] coordinates).\n    */\n\n    var maths = function () {\n        function maths() {\n            _classCallCheck(this, maths);\n        }\n\n        maths.zeros_Xx2x2 = function zeros_Xx2x2(x) {\n            var zs = [];\n            while (x--) {\n                zs.push([0, 0]);\n            }\n            return zs;\n        };\n\n        maths.mulItems = function mulItems(items, multiplier) {\n            return items.map(function (x) {\n                return x * multiplier;\n            });\n        };\n\n        maths.mulMatrix = function mulMatrix(m1, m2) {\n            //https://en.wikipedia.org/wiki/Matrix_multiplication#Matrix_product_.28two_matrices.29\n            //Simplified to only handle 1-dimensional matrices (i.e. arrays) of equal length:\n            return m1.reduce(function (sum, x1, i) {\n                return sum + x1 * m2[i];\n            }, 0);\n        };\n\n        maths.subtract = function subtract(arr1, arr2) {\n            return arr1.map(function (x1, i) {\n                return x1 - arr2[i];\n            });\n        };\n\n        maths.addArrays = function addArrays(arr1, arr2) {\n            return arr1.map(function (x1, i) {\n                return x1 + arr2[i];\n            });\n        };\n\n        maths.addItems = function addItems(items, addition) {\n            return items.map(function (x) {\n                return x + addition;\n            });\n        };\n\n        maths.sum = function sum(items) {\n            return items.reduce(function (sum, x) {\n                return sum + x;\n            });\n        };\n\n        maths.dot = function dot(m1, m2) {\n            return maths.mulMatrix(m1, m2);\n        };\n\n        maths.vectorLen = function vectorLen(v) {\n            return Math.hypot.apply(Math, v);\n        };\n\n        maths.divItems = function divItems(items, divisor) {\n            return items.map(function (x) {\n                return x / divisor;\n            });\n        };\n\n        maths.squareItems = function squareItems(items) {\n            return items.map(function (x) {\n                return x * x;\n            });\n        };\n\n        maths.normalize = function normalize(v) {\n            return this.divItems(v, this.vectorLen(v));\n        };\n\n        return maths;\n    }();\n\n    var bezier = function () {\n        function bezier() {\n            _classCallCheck(this, bezier);\n        }\n\n        bezier.q = function q(ctrlPoly, t) {\n            var tx = 1.0 - t;\n            var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx),\n                pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t),\n                pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t),\n                pD = maths.mulItems(ctrlPoly[3], t * t * t);\n            return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));\n        };\n\n        bezier.qprime = function qprime(ctrlPoly, t) {\n            var tx = 1.0 - t;\n            var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx),\n                pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t),\n                pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);\n            return maths.addArrays(maths.addArrays(pA, pB), pC);\n        };\n\n        bezier.qprimeprime = function qprimeprime(ctrlPoly, t) {\n            return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));\n        };\n\n        return bezier;\n    }();\n\n    module.exports = fitCurve;\n    module.exports.fitCubic = fitCubic;\n    module.exports.createTangent = createTangent;\n});\n","import { createConsole } from \"./Console.ts\";\nimport { Vector2 } from \"./MathUtils.ts\";\nimport { DisplayBezierCurve } from \"../DisplayManager.ts\";\nimport simplify from \"simplify-js\";\nimport fitCurve from \"fit-curve\";\n\nconst _console = createConsole(\"PathUtils\", { log: false });\n\nfunction perpendicularDistance(p: Vector2, p1: Vector2, p2: Vector2): number {\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n  if (dx === 0 && dy === 0) return Math.hypot(p.x - p1.x, p.y - p1.y);\n  const t = ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / (dx * dx + dy * dy);\n  const projX = p1.x + t * dx;\n  const projY = p1.y + t * dy;\n  return Math.hypot(p.x - projX, p.y - projY);\n}\n\nfunction rdp(points: Vector2[], epsilon: number): Vector2[] {\n  if (points.length < 3) return points;\n  let maxDist = 0;\n  let index = 0;\n  for (let i = 1; i < points.length - 1; i++) {\n    const d = perpendicularDistance(\n      points[i],\n      points[0],\n      points[points.length - 1]\n    );\n    if (d > maxDist) {\n      maxDist = d;\n      index = i;\n    }\n  }\n  if (maxDist > epsilon) {\n    const left = rdp(points.slice(0, index + 1), epsilon);\n    const right = rdp(points.slice(index), epsilon);\n    return left.slice(0, -1).concat(right);\n  }\n  return [points[0], points[points.length - 1]];\n}\n\n// Linear interpolation\nfunction lerp(a: number, b: number, t: number) {\n  return a + (b - a) * t;\n}\n\n// Sample quadratic Bezier\nfunction sampleQuadratic(\n  p0: Vector2,\n  p1: Vector2,\n  p2: Vector2,\n  steps: number = 5\n): Vector2[] {\n  const points: Vector2[] = [];\n  for (let i = 0; i <= steps; i++) {\n    const t = i / steps;\n    const x = (1 - t) ** 2 * p0.x + 2 * (1 - t) * t * p1.x + t ** 2 * p2.x;\n    const y = (1 - t) ** 2 * p0.y + 2 * (1 - t) * t * p1.y + t ** 2 * p2.y;\n    points.push({ x, y });\n  }\n  return points;\n}\n\n// Sample cubic Bezier\nfunction sampleCubic(\n  p0: Vector2,\n  p1: Vector2,\n  p2: Vector2,\n  p3: Vector2,\n  steps: number = 5\n): Vector2[] {\n  const points: Vector2[] = [];\n  for (let i = 0; i <= steps; i++) {\n    const t = i / steps;\n    const mt = 1 - t;\n    const x =\n      mt ** 3 * p0.x +\n      3 * mt ** 2 * t * p1.x +\n      3 * mt * t ** 2 * p2.x +\n      t ** 3 * p3.x;\n    const y =\n      mt ** 3 * p0.y +\n      3 * mt ** 2 * t * p1.y +\n      3 * mt * t ** 2 * p2.y +\n      t ** 3 * p3.y;\n    points.push({ x, y });\n  }\n  return points;\n}\n\nfunction areCollinear(\n  p1: Vector2,\n  p2: Vector2,\n  p3: Vector2,\n  epsilon = 1e-6\n): boolean {\n  // Vector p1->p2\n  const dx1 = p2.x - p1.x;\n  const dy1 = p2.y - p1.y;\n\n  // Vector p2->p3\n  const dx2 = p3.x - p2.x;\n  const dy2 = p3.y - p2.y;\n\n  // Cross product\n  const cross = dx1 * dy2 - dy1 * dx2;\n  return Math.abs(cross) < epsilon;\n}\n\nexport function simplifyCurves(curves: DisplayBezierCurve[], epsilon = 1) {\n  const simplified: DisplayBezierCurve[] = [];\n  //_console.log(\"simplifying\", curves, { epsilon });\n  let cursor: Vector2;\n  curves.forEach((curve, index) => {\n    const { controlPoints } = curve;\n    const isFirst = index == 0;\n    if (isFirst) {\n      cursor = controlPoints[0];\n    }\n\n    switch (curve.type) {\n      case \"segment\":\n        {\n          // Merge collinear lines\n          const lastPoint = controlPoints.at(-1)!;\n          const lastCommand = simplified.at(-1);\n          if (lastCommand?.type == \"segment\" && simplified.length >= 2) {\n            const [c1, c2] = [simplified.at(-1)!, simplified.at(-2)!];\n            if (\n              areCollinear(\n                c2.controlPoints.at(-1)!,\n                c1.controlPoints.at(-1)!,\n                lastPoint\n              )\n            ) {\n              // Remove middle collinear point\n              simplified.pop();\n            }\n          }\n          simplified.push({ ...curve });\n          cursor = lastPoint;\n        }\n        break;\n      case \"quadratic\":\n        {\n          const p0 = cursor;\n          const p1 = controlPoints.at(-2)!;\n          const p2 = controlPoints.at(-1)!;\n\n          // Sample points along the curve\n          const sampled = sampleQuadratic(p0, p1, p2, 5);\n          const simplifiedPoints = rdp(sampled, epsilon);\n\n          // If curve is almost straight, convert to a line\n          if (simplifiedPoints.length === 2) {\n            simplified.push({\n              type: \"segment\",\n              controlPoints: [{ x: p2.x, y: p2.y }],\n            });\n            if (isFirst) {\n              simplified.at(-1)!.controlPoints.unshift({ ...p0 });\n            }\n          } else {\n            simplified.push({ ...curve }); // Keep the curve\n          }\n          cursor = p2;\n        }\n        break;\n      case \"cubic\":\n        {\n          const p0 = cursor;\n          const p1 = controlPoints.at(-3)!;\n          const p2 = controlPoints.at(-2)!;\n          const p3 = controlPoints.at(-1)!;\n\n          const sampled = sampleCubic(p0, p1, p2, p3, 5);\n          const simplifiedPoints = rdp(sampled, epsilon);\n\n          if (simplifiedPoints.length === 2) {\n            simplified.push({\n              type: \"segment\",\n              controlPoints: [{ x: p3.x, y: p3.y }],\n            });\n            if (isFirst) {\n              simplified.at(-1)!.controlPoints.unshift({ ...p0 });\n            }\n          } else {\n            simplified.push({ ...curve }); // Keep the curve\n          }\n          cursor = p3;\n        }\n        break;\n    }\n    cursor = curve.controlPoints[curve.controlPoints.length - 1];\n  });\n  //_console.log(\"simplified\", simplified);\n  return simplified;\n}\n\nexport function simplifyPoints(points: Vector2[], tolerance?: number) {\n  points = simplify(points, tolerance, false);\n  return points;\n}\nexport function simplifyPointsAsCubicCurveControlPoints(\n  points: Vector2[],\n  error?: number\n) {\n  const flatPoints = points.map(({ x, y }) => [x, y]);\n  const curves = fitCurve(flatPoints, error ?? 50);\n  const controlPoints: Vector2[] = [];\n  curves.forEach((curve, index) => {\n    const points = curve.map(([x, y]) => ({ x, y }));\n    if (index != 0) {\n      points.shift();\n    }\n    controlPoints.push(...points);\n  });\n  return controlPoints;\n}\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.svgson = factory());\n})(this, (function () { 'use strict';\n\n  /*!\n   * Determine if an object is a Buffer\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   */\n\n  // The _isBuffer check is for Safari 5-7 support, because it's missing\n  // Object.prototype.constructor. Remove this eventually\n  var isBuffer_1 = function (obj) {\n    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n  };\n\n  function isBuffer (obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n  }\n\n  // For Node v0.10 support. Remove this eventually.\n  function isSlowBuffer (obj) {\n    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n  }\n\n  var toString = Object.prototype.toString;\n\n  /**\n   * Get the native `typeof` a value.\n   *\n   * @param  {*} `val`\n   * @return {*} Native javascript type\n   */\n\n  var kindOf = function kindOf(val) {\n    // primitivies\n    if (typeof val === 'undefined') {\n      return 'undefined';\n    }\n    if (val === null) {\n      return 'null';\n    }\n    if (val === true || val === false || val instanceof Boolean) {\n      return 'boolean';\n    }\n    if (typeof val === 'string' || val instanceof String) {\n      return 'string';\n    }\n    if (typeof val === 'number' || val instanceof Number) {\n      return 'number';\n    }\n\n    // functions\n    if (typeof val === 'function' || val instanceof Function) {\n      return 'function';\n    }\n\n    // array\n    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {\n      return 'array';\n    }\n\n    // check for instances of RegExp and Date before calling `toString`\n    if (val instanceof RegExp) {\n      return 'regexp';\n    }\n    if (val instanceof Date) {\n      return 'date';\n    }\n\n    // other objects\n    var type = toString.call(val);\n\n    if (type === '[object RegExp]') {\n      return 'regexp';\n    }\n    if (type === '[object Date]') {\n      return 'date';\n    }\n    if (type === '[object Arguments]') {\n      return 'arguments';\n    }\n    if (type === '[object Error]') {\n      return 'error';\n    }\n\n    // buffer\n    if (isBuffer_1(val)) {\n      return 'buffer';\n    }\n\n    // es6: Map, WeakMap, Set, WeakSet\n    if (type === '[object Set]') {\n      return 'set';\n    }\n    if (type === '[object WeakSet]') {\n      return 'weakset';\n    }\n    if (type === '[object Map]') {\n      return 'map';\n    }\n    if (type === '[object WeakMap]') {\n      return 'weakmap';\n    }\n    if (type === '[object Symbol]') {\n      return 'symbol';\n    }\n\n    // typed arrays\n    if (type === '[object Int8Array]') {\n      return 'int8array';\n    }\n    if (type === '[object Uint8Array]') {\n      return 'uint8array';\n    }\n    if (type === '[object Uint8ClampedArray]') {\n      return 'uint8clampedarray';\n    }\n    if (type === '[object Int16Array]') {\n      return 'int16array';\n    }\n    if (type === '[object Uint16Array]') {\n      return 'uint16array';\n    }\n    if (type === '[object Int32Array]') {\n      return 'int32array';\n    }\n    if (type === '[object Uint32Array]') {\n      return 'uint32array';\n    }\n    if (type === '[object Float32Array]') {\n      return 'float32array';\n    }\n    if (type === '[object Float64Array]') {\n      return 'float64array';\n    }\n\n    // must be a plain object\n    return 'object';\n  };\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var renameKeys = createCommonjsModule(function (module) {\n  (function() {\n\n    function rename(obj, fn) {\n      if (typeof fn !== 'function') {\n        return obj;\n      }\n\n      var res = {};\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          res[fn(key, obj[key]) || key] = obj[key];\n        }\n      }\n      return res;\n    }\n\n    if (module.exports) {\n      module.exports = rename;\n    } else {\n      {\n        window.rename = rename;\n      }\n    }\n  })();\n  });\n\n  /**\n   * Expose `renameDeep`\n   */\n\n  var deepRenameKeys = function renameDeep(obj, cb) {\n    var type = kindOf(obj);\n\n    if (type !== 'object' && type !== 'array') {\n      throw new Error('expected an object');\n    }\n\n    var res = [];\n    if (type === 'object') {\n      obj = renameKeys(obj, cb);\n      res = {};\n    }\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        var val = obj[key];\n        if (kindOf(val) === 'object' || kindOf(val) === 'array') {\n          res[key] = renameDeep(val, cb);\n        } else {\n          res[key] = val;\n        }\n      }\n    }\n    return res;\n  };\n\n  var eventemitter3 = createCommonjsModule(function (module) {\n\n  var has = Object.prototype.hasOwnProperty\n    , prefix = '~';\n\n  /**\n   * Constructor to create a storage for our `EE` objects.\n   * An `Events` instance is a plain object whose properties are event names.\n   *\n   * @constructor\n   * @api private\n   */\n  function Events() {}\n\n  //\n  // We try to not inherit from `Object.prototype`. In some engines creating an\n  // instance in this way is faster than calling `Object.create(null)` directly.\n  // If `Object.create(null)` is not supported we prefix the event names with a\n  // character to make sure that the built-in object properties are not\n  // overridden or used as an attack vector.\n  //\n  if (Object.create) {\n    Events.prototype = Object.create(null);\n\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new Events().__proto__) prefix = false;\n  }\n\n  /**\n   * Representation of a single event listener.\n   *\n   * @param {Function} fn The listener function.\n   * @param {Mixed} context The context to invoke the listener with.\n   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n   * @constructor\n   * @api private\n   */\n  function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n  }\n\n  /**\n   * Minimal `EventEmitter` interface that is molded against the Node.js\n   * `EventEmitter` interface.\n   *\n   * @constructor\n   * @api public\n   */\n  function EventEmitter() {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  /**\n   * Return an array listing the events for which the emitter has registered\n   * listeners.\n   *\n   * @returns {Array}\n   * @api public\n   */\n  EventEmitter.prototype.eventNames = function eventNames() {\n    var names = []\n      , events\n      , name;\n\n    if (this._eventsCount === 0) return names;\n\n    for (name in (events = this._events)) {\n      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      return names.concat(Object.getOwnPropertySymbols(events));\n    }\n\n    return names;\n  };\n\n  /**\n   * Return the listeners registered for a given event.\n   *\n   * @param {String|Symbol} event The event name.\n   * @param {Boolean} exists Only check if there are listeners.\n   * @returns {Array|Boolean}\n   * @api public\n   */\n  EventEmitter.prototype.listeners = function listeners(event, exists) {\n    var evt = prefix ? prefix + event : event\n      , available = this._events[evt];\n\n    if (exists) return !!available;\n    if (!available) return [];\n    if (available.fn) return [available.fn];\n\n    for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n      ee[i] = available[i].fn;\n    }\n\n    return ee;\n  };\n\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {String|Symbol} event The event name.\n   * @returns {Boolean} `true` if the event had listeners, else `false`.\n   * @api public\n   */\n  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n\n    if (!this._events[evt]) return false;\n\n    var listeners = this._events[evt]\n      , len = arguments.length\n      , args\n      , i;\n\n    if (listeners.fn) {\n      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n      switch (len) {\n        case 1: return listeners.fn.call(listeners.context), true;\n        case 2: return listeners.fn.call(listeners.context, a1), true;\n        case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n      }\n\n      for (i = 1, args = new Array(len -1); i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n\n      listeners.fn.apply(listeners.context, args);\n    } else {\n      var length = listeners.length\n        , j;\n\n      for (i = 0; i < length; i++) {\n        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n        switch (len) {\n          case 1: listeners[i].fn.call(listeners[i].context); break;\n          case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n          case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n          default:\n            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n              args[j - 1] = arguments[j];\n            }\n\n            listeners[i].fn.apply(listeners[i].context, args);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Add a listener for a given event.\n   *\n   * @param {String|Symbol} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {Mixed} [context=this] The context to invoke the listener with.\n   * @returns {EventEmitter} `this`.\n   * @api public\n   */\n  EventEmitter.prototype.on = function on(event, fn, context) {\n    var listener = new EE(fn, context || this)\n      , evt = prefix ? prefix + event : event;\n\n    if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n    else if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [this._events[evt], listener];\n\n    return this;\n  };\n\n  /**\n   * Add a one-time listener for a given event.\n   *\n   * @param {String|Symbol} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {Mixed} [context=this] The context to invoke the listener with.\n   * @returns {EventEmitter} `this`.\n   * @api public\n   */\n  EventEmitter.prototype.once = function once(event, fn, context) {\n    var listener = new EE(fn, context || this, true)\n      , evt = prefix ? prefix + event : event;\n\n    if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n    else if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [this._events[evt], listener];\n\n    return this;\n  };\n\n  /**\n   * Remove the listeners of a given event.\n   *\n   * @param {String|Symbol} event The event name.\n   * @param {Function} fn Only remove the listeners that match this function.\n   * @param {Mixed} context Only remove the listeners that have this context.\n   * @param {Boolean} once Only remove one-time listeners.\n   * @returns {EventEmitter} `this`.\n   * @api public\n   */\n  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n\n    if (!this._events[evt]) return this;\n    if (!fn) {\n      if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n      return this;\n    }\n\n    var listeners = this._events[evt];\n\n    if (listeners.fn) {\n      if (\n           listeners.fn === fn\n        && (!once || listeners.once)\n        && (!context || listeners.context === context)\n      ) {\n        if (--this._eventsCount === 0) this._events = new Events();\n        else delete this._events[evt];\n      }\n    } else {\n      for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n\n      //\n      // Reset the array, or remove it completely if we have no more listeners.\n      //\n      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n      else if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n    }\n\n    return this;\n  };\n\n  /**\n   * Remove all listeners, or those of the specified event.\n   *\n   * @param {String|Symbol} [event] The event name.\n   * @returns {EventEmitter} `this`.\n   * @api public\n   */\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n\n    if (event) {\n      evt = prefix ? prefix + event : event;\n      if (this._events[evt]) {\n        if (--this._eventsCount === 0) this._events = new Events();\n        else delete this._events[evt];\n      }\n    } else {\n      this._events = new Events();\n      this._eventsCount = 0;\n    }\n\n    return this;\n  };\n\n  //\n  // Alias methods names because people roll like that.\n  //\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  //\n  // This function doesn't apply anymore.\n  //\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n    return this;\n  };\n\n  //\n  // Expose the prefix.\n  //\n  EventEmitter.prefixed = prefix;\n\n  //\n  // Allow `EventEmitter` to be imported as module namespace.\n  //\n  EventEmitter.EventEmitter = EventEmitter;\n\n  //\n  // Expose the module.\n  //\n  {\n    module.exports = EventEmitter;\n  }\n  });\n\n  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n  var noop = function noop() {};\n\n  var State = {\n      data: 'state-data',\n      cdata: 'state-cdata',\n      tagBegin: 'state-tag-begin',\n      tagName: 'state-tag-name',\n      tagEnd: 'state-tag-end',\n      attributeNameStart: 'state-attribute-name-start',\n      attributeName: 'state-attribute-name',\n      attributeNameEnd: 'state-attribute-name-end',\n      attributeValueBegin: 'state-attribute-value-begin',\n      attributeValue: 'state-attribute-value'\n  };\n\n  var Action = {\n      lt: 'action-lt',\n      gt: 'action-gt',\n      space: 'action-space',\n      equal: 'action-equal',\n      quote: 'action-quote',\n      slash: 'action-slash',\n      char: 'action-char',\n      error: 'action-error'\n  };\n\n  var Type$1 = {\n      text: 'text',\n      openTag: 'open-tag',\n      closeTag: 'close-tag',\n      attributeName: 'attribute-name',\n      attributeValue: 'attribute-value'\n  };\n\n  var charToAction = {\n      ' ': Action.space,\n      '\\t': Action.space,\n      '\\n': Action.space,\n      '\\r': Action.space,\n      '<': Action.lt,\n      '>': Action.gt,\n      '\"': Action.quote,\n      \"'\": Action.quote,\n      '=': Action.equal,\n      '/': Action.slash\n  };\n\n  var getAction = function getAction(char) {\n      return charToAction[char] || Action.char;\n  };\n\n  /**\n   * @param  {Object} options\n   * @param  {Boolean} options.debug\n   * @return {Object}\n   */\n  var create$1 = function create(options) {\n      var _State$data, _State$tagBegin, _State$tagName, _State$tagEnd, _State$attributeNameS, _State$attributeName, _State$attributeNameE, _State$attributeValue, _State$attributeValue2, _lexer$stateMachine;\n\n      options = Object.assign({ debug: false }, options);\n      var lexer = new eventemitter3();\n      var state = State.data;\n      var data = '';\n      var tagName = '';\n      var attrName = '';\n      var attrValue = '';\n      var isClosing = '';\n      var openingQuote = '';\n\n      var emit = function emit(type, value) {\n          // for now, ignore tags like: '?xml', '!DOCTYPE' or comments\n          if (tagName[0] === '?' || tagName[0] === '!') {\n              return;\n          }\n          var event = { type: type, value: value };\n          if (options.debug) {\n              console.log('emit:', event);\n          }\n          lexer.emit('data', event);\n      };\n\n      lexer.stateMachine = (_lexer$stateMachine = {}, _defineProperty(_lexer$stateMachine, State.data, (_State$data = {}, _defineProperty(_State$data, Action.lt, function () {\n          if (data.trim()) {\n              emit(Type$1.text, data);\n          }\n          tagName = '';\n          isClosing = false;\n          state = State.tagBegin;\n      }), _defineProperty(_State$data, Action.char, function (char) {\n          data += char;\n      }), _State$data)), _defineProperty(_lexer$stateMachine, State.cdata, _defineProperty({}, Action.char, function (char) {\n          data += char;\n          if (data.substr(-3) === ']]>') {\n              emit(Type$1.text, data.slice(0, -3));\n              data = '';\n              state = State.data;\n          }\n      })), _defineProperty(_lexer$stateMachine, State.tagBegin, (_State$tagBegin = {}, _defineProperty(_State$tagBegin, Action.space, noop), _defineProperty(_State$tagBegin, Action.char, function (char) {\n          tagName = char;\n          state = State.tagName;\n      }), _defineProperty(_State$tagBegin, Action.slash, function () {\n          tagName = '';\n          isClosing = true;\n      }), _State$tagBegin)), _defineProperty(_lexer$stateMachine, State.tagName, (_State$tagName = {}, _defineProperty(_State$tagName, Action.space, function () {\n          if (isClosing) {\n              state = State.tagEnd;\n          } else {\n              state = State.attributeNameStart;\n              emit(Type$1.openTag, tagName);\n          }\n      }), _defineProperty(_State$tagName, Action.gt, function () {\n          if (isClosing) {\n              emit(Type$1.closeTag, tagName);\n          } else {\n              emit(Type$1.openTag, tagName);\n          }\n          data = '';\n          state = State.data;\n      }), _defineProperty(_State$tagName, Action.slash, function () {\n          state = State.tagEnd;\n          emit(Type$1.openTag, tagName);\n      }), _defineProperty(_State$tagName, Action.char, function (char) {\n          tagName += char;\n          if (tagName === '![CDATA[') {\n              state = State.cdata;\n              data = '';\n              tagName = '';\n          }\n      }), _State$tagName)), _defineProperty(_lexer$stateMachine, State.tagEnd, (_State$tagEnd = {}, _defineProperty(_State$tagEnd, Action.gt, function () {\n          emit(Type$1.closeTag, tagName);\n          data = '';\n          state = State.data;\n      }), _defineProperty(_State$tagEnd, Action.char, noop), _State$tagEnd)), _defineProperty(_lexer$stateMachine, State.attributeNameStart, (_State$attributeNameS = {}, _defineProperty(_State$attributeNameS, Action.char, function (char) {\n          attrName = char;\n          state = State.attributeName;\n      }), _defineProperty(_State$attributeNameS, Action.gt, function () {\n          data = '';\n          state = State.data;\n      }), _defineProperty(_State$attributeNameS, Action.space, noop), _defineProperty(_State$attributeNameS, Action.slash, function () {\n          isClosing = true;\n          state = State.tagEnd;\n      }), _State$attributeNameS)), _defineProperty(_lexer$stateMachine, State.attributeName, (_State$attributeName = {}, _defineProperty(_State$attributeName, Action.space, function () {\n          state = State.attributeNameEnd;\n      }), _defineProperty(_State$attributeName, Action.equal, function () {\n          emit(Type$1.attributeName, attrName);\n          state = State.attributeValueBegin;\n      }), _defineProperty(_State$attributeName, Action.gt, function () {\n          attrValue = '';\n          emit(Type$1.attributeName, attrName);\n          emit(Type$1.attributeValue, attrValue);\n          data = '';\n          state = State.data;\n      }), _defineProperty(_State$attributeName, Action.slash, function () {\n          isClosing = true;\n          attrValue = '';\n          emit(Type$1.attributeName, attrName);\n          emit(Type$1.attributeValue, attrValue);\n          state = State.tagEnd;\n      }), _defineProperty(_State$attributeName, Action.char, function (char) {\n          attrName += char;\n      }), _State$attributeName)), _defineProperty(_lexer$stateMachine, State.attributeNameEnd, (_State$attributeNameE = {}, _defineProperty(_State$attributeNameE, Action.space, noop), _defineProperty(_State$attributeNameE, Action.equal, function () {\n          emit(Type$1.attributeName, attrName);\n          state = State.attributeValueBegin;\n      }), _defineProperty(_State$attributeNameE, Action.gt, function () {\n          attrValue = '';\n          emit(Type$1.attributeName, attrName);\n          emit(Type$1.attributeValue, attrValue);\n          data = '';\n          state = State.data;\n      }), _defineProperty(_State$attributeNameE, Action.char, function (char) {\n          attrValue = '';\n          emit(Type$1.attributeName, attrName);\n          emit(Type$1.attributeValue, attrValue);\n          attrName = char;\n          state = State.attributeName;\n      }), _State$attributeNameE)), _defineProperty(_lexer$stateMachine, State.attributeValueBegin, (_State$attributeValue = {}, _defineProperty(_State$attributeValue, Action.space, noop), _defineProperty(_State$attributeValue, Action.quote, function (char) {\n          openingQuote = char;\n          attrValue = '';\n          state = State.attributeValue;\n      }), _defineProperty(_State$attributeValue, Action.gt, function () {\n          attrValue = '';\n          emit(Type$1.attributeValue, attrValue);\n          data = '';\n          state = State.data;\n      }), _defineProperty(_State$attributeValue, Action.char, function (char) {\n          openingQuote = '';\n          attrValue = char;\n          state = State.attributeValue;\n      }), _State$attributeValue)), _defineProperty(_lexer$stateMachine, State.attributeValue, (_State$attributeValue2 = {}, _defineProperty(_State$attributeValue2, Action.space, function (char) {\n          if (openingQuote) {\n              attrValue += char;\n          } else {\n              emit(Type$1.attributeValue, attrValue);\n              state = State.attributeNameStart;\n          }\n      }), _defineProperty(_State$attributeValue2, Action.quote, function (char) {\n          if (openingQuote === char) {\n              emit(Type$1.attributeValue, attrValue);\n              state = State.attributeNameStart;\n          } else {\n              attrValue += char;\n          }\n      }), _defineProperty(_State$attributeValue2, Action.gt, function (char) {\n          if (openingQuote) {\n              attrValue += char;\n          } else {\n              emit(Type$1.attributeValue, attrValue);\n              data = '';\n              state = State.data;\n          }\n      }), _defineProperty(_State$attributeValue2, Action.slash, function (char) {\n          if (openingQuote) {\n              attrValue += char;\n          } else {\n              emit(Type$1.attributeValue, attrValue);\n              isClosing = true;\n              state = State.tagEnd;\n          }\n      }), _defineProperty(_State$attributeValue2, Action.char, function (char) {\n          attrValue += char;\n      }), _State$attributeValue2)), _lexer$stateMachine);\n\n      var step = function step(char) {\n          if (options.debug) {\n              console.log(state, char);\n          }\n          var actions = lexer.stateMachine[state];\n          var action = actions[getAction(char)] || actions[Action.error] || actions[Action.char];\n          action(char);\n      };\n\n      lexer.write = function (str) {\n          var len = str.length;\n          for (var i = 0; i < len; i++) {\n              step(str[i]);\n          }\n      };\n\n      return lexer;\n  };\n\n  var lexer = {\n      State: State,\n      Action: Action,\n      Type: Type$1,\n      create: create$1\n  };\n\n  var Type = lexer.Type;\n\n  var NodeType = {\n      element: 'element',\n      text: 'text'\n  };\n\n  var createNode = function createNode(params) {\n      return Object.assign({\n          name: '',\n          type: NodeType.element,\n          value: '',\n          parent: null,\n          attributes: {},\n          children: []\n      }, params);\n  };\n\n  var create = function create(options) {\n      options = Object.assign({\n          stream: false,\n          parentNodes: true,\n          doneEvent: 'done',\n          tagPrefix: 'tag:',\n          emitTopLevelOnly: false,\n          debug: false\n      }, options);\n\n      var lexer$1 = void 0,\n          rootNode = void 0,\n          current = void 0,\n          attrName = void 0;\n\n      var reader = new eventemitter3();\n\n      var handleLexerData = function handleLexerData(data) {\n          switch (data.type) {\n\n              case Type.openTag:\n                  if (current === null) {\n                      current = rootNode;\n                      current.name = data.value;\n                  } else {\n                      var node = createNode({\n                          name: data.value,\n                          parent: current\n                      });\n                      current.children.push(node);\n                      current = node;\n                  }\n                  break;\n\n              case Type.closeTag:\n                  var parent = current.parent;\n                  if (!options.parentNodes) {\n                      current.parent = null;\n                  }\n                  if (current.name !== data.value) {\n                      // ignore unexpected closing tag\n                      break;\n                  }\n                  if (options.stream && parent === rootNode) {\n                      rootNode.children = [];\n                      // do not expose parent node in top level nodes\n                      current.parent = null;\n                  }\n                  if (!options.emitTopLevelOnly || parent === rootNode) {\n                      reader.emit(options.tagPrefix + current.name, current);\n                      reader.emit('tag', current.name, current);\n                  }\n                  if (current === rootNode) {\n                      // end of document, stop listening\n                      lexer$1.removeAllListeners('data');\n                      reader.emit(options.doneEvent, current);\n                      rootNode = null;\n                  }\n                  current = parent;\n                  break;\n\n              case Type.text:\n                  if (current) {\n                      current.children.push(createNode({\n                          type: NodeType.text,\n                          value: data.value,\n                          parent: options.parentNodes ? current : null\n                      }));\n                  }\n                  break;\n\n              case Type.attributeName:\n                  attrName = data.value;\n                  current.attributes[attrName] = '';\n                  break;\n\n              case Type.attributeValue:\n                  current.attributes[attrName] = data.value;\n                  break;\n          }\n      };\n\n      reader.reset = function () {\n          lexer$1 = lexer.create({ debug: options.debug });\n          lexer$1.on('data', handleLexerData);\n          rootNode = createNode();\n          current = null;\n          attrName = '';\n          reader.parse = lexer$1.write;\n      };\n\n      reader.reset();\n      return reader;\n  };\n\n  var parseSync = function parseSync(xml, options) {\n      options = Object.assign({}, options, { stream: false, tagPrefix: ':' });\n      var reader = create(options);\n      var res = void 0;\n      reader.on('done', function (ast) {\n          res = ast;\n      });\n      reader.parse(xml);\n      return res;\n  };\n\n  var reader = {\n      parseSync: parseSync,\n      create: create,\n      NodeType: NodeType\n  };\n  var reader_1 = reader.parseSync;\n\n  var parseInput = function parseInput(input) {\n    var parsed = reader_1(\"<root>\".concat(input, \"</root>\"), {\n      parentNodes: false\n    });\n    var isValid = parsed.children && parsed.children.length > 0 && parsed.children.every(function (node) {\n      return node.name === 'svg';\n    });\n    if (isValid) {\n      return parsed.children.length === 1 ? parsed.children[0] : parsed.children;\n    } else {\n      throw Error('nothing to parse');\n    }\n  };\n  var camelize = function camelize(node) {\n    return deepRenameKeys(node, function (key) {\n      if (!notCamelcase(key)) {\n        return toCamelCase(key);\n      }\n      return key;\n    });\n  };\n  var toCamelCase = function toCamelCase(prop) {\n    return prop.replace(/[-|:]([a-z])/gi, function (all, letter) {\n      return letter.toUpperCase();\n    });\n  };\n  var notCamelcase = function notCamelcase(prop) {\n    return /^(data|aria)(-\\w+)/.test(prop);\n  };\n  var escapeText = function escapeText(text) {\n    if (text) {\n      var str = String(text);\n      return /[&<>]/.test(str) ? \"<![CDATA[\".concat(str.replace(/]]>/, ']]]]><![CDATA[>'), \"]]>\") : str;\n    }\n    return '';\n  };\n  var escapeAttr = function escapeAttr(attr) {\n    return String(attr).replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/\"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  };\n\n  var svgsonSync = function svgsonSync(input) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$transformNode = _ref.transformNode,\n      transformNode = _ref$transformNode === void 0 ? function (node) {\n        return node;\n      } : _ref$transformNode,\n      _ref$camelcase = _ref.camelcase,\n      camelcase = _ref$camelcase === void 0 ? false : _ref$camelcase;\n    var applyFilters = function applyFilters(input) {\n      var n;\n      n = transformNode(input);\n      if (camelcase) {\n        n = camelize(n);\n      }\n      return n;\n    };\n    return applyFilters(parseInput(input));\n  };\n  function svgson() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new Promise(function (resolve, reject) {\n      try {\n        var res = svgsonSync.apply(void 0, args);\n        resolve(res);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  var stringify = function stringify(_ast) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$transformAttr = _ref.transformAttr,\n      transformAttr = _ref$transformAttr === void 0 ? function (key, value, escape) {\n        return \"\".concat(key, \"=\\\"\").concat(escape(value), \"\\\"\");\n      } : _ref$transformAttr,\n      _ref$transformNode = _ref.transformNode,\n      transformNode = _ref$transformNode === void 0 ? function (node) {\n        return node;\n      } : _ref$transformNode,\n      _ref$selfClose = _ref.selfClose,\n      selfClose = _ref$selfClose === void 0 ? true : _ref$selfClose;\n    if (Array.isArray(_ast)) {\n      return _ast.map(function (ast) {\n        return stringify(ast, {\n          transformAttr: transformAttr,\n          selfClose: selfClose,\n          transformNode: transformNode\n        });\n      }).join('');\n    }\n    var ast = transformNode(_ast);\n    if (ast.type === 'text') {\n      return escapeText(ast.value);\n    }\n    var attributes = '';\n    for (var attr in ast.attributes) {\n      var attrStr = transformAttr(attr, ast.attributes[attr], escapeAttr, ast.name);\n      attributes += attrStr ? \" \".concat(attrStr) : '';\n    }\n    return ast.children && ast.children.length > 0 || !selfClose ? \"<\".concat(ast.name).concat(attributes, \">\").concat(stringify(ast.children, {\n      transformAttr: transformAttr,\n      transformNode: transformNode,\n      selfClose: selfClose\n    }), \"</\").concat(ast.name, \">\") : \"<\".concat(ast.name).concat(attributes, \"/>\");\n  };\n\n  var indexUmd = Object.assign({}, {\n    parse: svgson,\n    parseSync: svgsonSync,\n    stringify: stringify\n  });\n\n  return indexUmd;\n\n}));\n","import { SVGPathData } from './SVGPathData.js';\n// Encode SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n// Private consts : Char groups\nconst WSP = ' ';\nexport function encodeSVGPath(commands) {\n    let str = '';\n    if (!Array.isArray(commands)) {\n        commands = [commands];\n    }\n    for (let i = 0; i < commands.length; i++) {\n        const command = commands[i];\n        if (command.type === SVGPathData.CLOSE_PATH) {\n            str += 'z';\n        }\n        else if (command.type === SVGPathData.HORIZ_LINE_TO) {\n            str += (command.relative ? 'h' : 'H') + command.x;\n        }\n        else if (command.type === SVGPathData.VERT_LINE_TO) {\n            str += (command.relative ? 'v' : 'V') + command.y;\n        }\n        else if (command.type === SVGPathData.MOVE_TO) {\n            str += (command.relative ? 'm' : 'M') + command.x + WSP + command.y;\n        }\n        else if (command.type === SVGPathData.LINE_TO) {\n            str += (command.relative ? 'l' : 'L') + command.x + WSP + command.y;\n        }\n        else if (command.type === SVGPathData.CURVE_TO) {\n            str +=\n                (command.relative ? 'c' : 'C') +\n                    command.x1 +\n                    WSP +\n                    command.y1 +\n                    WSP +\n                    command.x2 +\n                    WSP +\n                    command.y2 +\n                    WSP +\n                    command.x +\n                    WSP +\n                    command.y;\n        }\n        else if (command.type === SVGPathData.SMOOTH_CURVE_TO) {\n            str +=\n                (command.relative ? 's' : 'S') +\n                    command.x2 +\n                    WSP +\n                    command.y2 +\n                    WSP +\n                    command.x +\n                    WSP +\n                    command.y;\n        }\n        else if (command.type === SVGPathData.QUAD_TO) {\n            str +=\n                (command.relative ? 'q' : 'Q') +\n                    command.x1 +\n                    WSP +\n                    command.y1 +\n                    WSP +\n                    command.x +\n                    WSP +\n                    command.y;\n        }\n        else if (command.type === SVGPathData.SMOOTH_QUAD_TO) {\n            str += (command.relative ? 't' : 'T') + command.x + WSP + command.y;\n        }\n        else if (command.type === SVGPathData.ARC) {\n            str +=\n                (command.relative ? 'a' : 'A') +\n                    command.rX +\n                    WSP +\n                    command.rY +\n                    WSP +\n                    command.xRot +\n                    WSP +\n                    +command.lArcFlag +\n                    WSP +\n                    +command.sweepFlag +\n                    WSP +\n                    command.x +\n                    WSP +\n                    command.y;\n        }\n        else {\n            // Unknown command\n            throw new Error(`Unexpected command type \"${command?.type}\" at index ${i}.`);\n        }\n    }\n    return str;\n}\n//# sourceMappingURL=SVGPathDataEncoder.js.map","import { SVGPathData } from './SVGPathData.js';\nexport function rotate([x, y], rad) {\n    return [\n        x * Math.cos(rad) - y * Math.sin(rad),\n        x * Math.sin(rad) + y * Math.cos(rad),\n    ];\n}\nconst DEBUG_CHECK_NUMBERS = true;\nexport function assertNumbers(...numbers) {\n    if (DEBUG_CHECK_NUMBERS) {\n        for (let i = 0; i < numbers.length; i++) {\n            if ('number' !== typeof numbers[i]) {\n                throw new Error(`assertNumbers arguments[${i}] is not a number. ${typeof numbers[i]} == typeof ${numbers[i]}`);\n            }\n        }\n    }\n    return true;\n}\nconst PI = Math.PI;\n/**\n * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n * Fixes rX and rY.\n * Ensures lArcFlag and sweepFlag are 0 or 1\n * Adds center coordinates: command.cX, command.cY (relative or absolute, depending on command.relative)\n * Adds start and end arc parameters (in degrees): command.phi1, command.phi2; phi1 < phi2 iff. c.sweepFlag == true\n */\nexport function annotateArcCommand(c, x1, y1) {\n    c.lArcFlag = 0 === c.lArcFlag ? 0 : 1;\n    c.sweepFlag = 0 === c.sweepFlag ? 0 : 1;\n    // tslint:disable-next-line\n    let { rX, rY } = c;\n    const { x, y } = c;\n    if (Math.abs(rX) < 1e-10 || Math.abs(rY) < 1e-10) {\n        c.rX = 0;\n        c.rY = 0;\n        c.cX = (x1 + x) / 2;\n        c.cY = (y1 + y) / 2;\n        c.phi1 = 0;\n        c.phi2 = 0;\n        return;\n    }\n    rX = Math.abs(c.rX);\n    rY = Math.abs(c.rY);\n    const xRotRad = (c.xRot / 180) * PI;\n    const [x1_, y1_] = rotate([(x1 - x) / 2, (y1 - y) / 2], -xRotRad);\n    const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);\n    if (1 < testValue) {\n        rX *= Math.sqrt(testValue);\n        rY *= Math.sqrt(testValue);\n    }\n    c.rX = rX;\n    c.rY = rY;\n    const c_ScaleTemp = Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2);\n    const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) *\n        Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));\n    const cx_ = ((rX * y1_) / rY) * c_Scale;\n    const cy_ = ((-rY * x1_) / rX) * c_Scale;\n    const cRot = rotate([cx_, cy_], xRotRad);\n    c.cX = cRot[0] + (x1 + x) / 2;\n    c.cY = cRot[1] + (y1 + y) / 2;\n    c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);\n    c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);\n    if (0 === c.sweepFlag && c.phi2 > c.phi1) {\n        c.phi2 -= 2 * PI;\n    }\n    if (1 === c.sweepFlag && c.phi2 < c.phi1) {\n        c.phi2 += 2 * PI;\n    }\n    c.phi1 *= 180 / PI;\n    c.phi2 *= 180 / PI;\n}\n/**\n * Solves a quadratic system of equations of the form\n *      a * x + b * y = c\n *      x + y = 1\n * This can be understood as the intersection of the unit circle with a line.\n *      => y = (c - a x) / b\n *      => x + (c - a x) / b = 1\n *      => x b + c - 2 c a x + a x = b\n *      => (a + b) x - 2 a c x + (c - b) = 0\n */\nexport function intersectionUnitCircleLine(a, b, c) {\n    assertNumbers(a, b, c);\n    // cf. pqFormula\n    const termSqr = a * a + b * b - c * c;\n    if (0 > termSqr) {\n        return [];\n    }\n    else if (0 === termSqr) {\n        return [[(a * c) / (a * a + b * b), (b * c) / (a * a + b * b)]];\n    }\n    const term = Math.sqrt(termSqr);\n    return [\n        [\n            (a * c + b * term) / (a * a + b * b),\n            (b * c - a * term) / (a * a + b * b),\n        ],\n        [\n            (a * c - b * term) / (a * a + b * b),\n            (b * c + a * term) / (a * a + b * b),\n        ],\n    ];\n}\nexport const DEG = Math.PI / 180;\nexport function lerp(a, b, t) {\n    return (1 - t) * a + t * b;\n}\nexport function arcAt(c, x1, x2, phiDeg) {\n    return (c + Math.cos((phiDeg / 180) * PI) * x1 + Math.sin((phiDeg / 180) * PI) * x2);\n}\nexport function bezierRoot(x0, x1, x2, x3) {\n    const EPS = 1e-6;\n    // Coefficients for the derivative of a cubic Bezier curve\n    // B'(t) = 3(1-t)(P-P) + 6(1-t)t(P-P) + 3t(P-P)\n    // When rearranged to at + bt + c:\n    const x01 = x1 - x0;\n    const x12 = x2 - x1;\n    const x23 = x3 - x2;\n    const a = 3 * x01 + 3 * x23 - 6 * x12;\n    const b = (x12 - x01) * 6;\n    const c = 3 * x01;\n    // solve a * t + b * t + c = 0\n    if (Math.abs(a) < EPS) {\n        // For near-zero a, it becomes a linear equation: b * t + c = 0\n        return Math.abs(b) < EPS ? [] : [-c / b];\n    }\n    return pqFormula(b / a, c / a, EPS);\n}\nexport function bezierAt(x0, x1, x2, x3, t) {\n    // Calculates a point on a cubic Bezier curve at parameter t.\n    // B(t) = (1-t)P + 3(1-t)tP + 3(1-t)tP + tP\n    // Which is equivalent to:\n    // B(t) = (s)P + (3st)P + (3st)P + (t)P  where s = 1-t\n    const s = 1 - t;\n    const c0 = s * s * s;\n    const c1 = 3 * s * s * t;\n    const c2 = 3 * s * t * t;\n    const c3 = t * t * t;\n    return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;\n}\nfunction pqFormula(p, q, PRECISION = 1e-6) {\n    // 4 times the discriminant:in\n    const discriminantX4 = (p * p) / 4 - q;\n    if (discriminantX4 < -PRECISION) {\n        return [];\n    }\n    else if (discriminantX4 <= PRECISION) {\n        return [-p / 2];\n    }\n    const root = Math.sqrt(discriminantX4);\n    return [-(p / 2) - root, -(p / 2) + root];\n}\nexport function a2c(arc, x0, y0) {\n    if (!arc.cX) {\n        annotateArcCommand(arc, x0, y0);\n    }\n    // Convert xRot to radians\n    const xRotRad = (arc.xRot / 180) * PI;\n    // Handle zero radius case - convert to a straight line represented as a curve\n    if (Math.abs(arc.rX) < 1e-10 || Math.abs(arc.rY) < 1e-10) {\n        return [\n            {\n                relative: arc.relative,\n                type: SVGPathData.CURVE_TO,\n                x1: x0 + (arc.x - x0) / 3,\n                y1: y0 + (arc.y - y0) / 3,\n                x2: x0 + (2 * (arc.x - x0)) / 3,\n                y2: y0 + (2 * (arc.y - y0)) / 3,\n                x: arc.x,\n                y: arc.y,\n            },\n        ];\n    }\n    const phiMin = Math.min(arc.phi1, arc.phi2), phiMax = Math.max(arc.phi1, arc.phi2), deltaPhi = phiMax - phiMin;\n    const partCount = Math.ceil(deltaPhi / 90);\n    const result = new Array(partCount);\n    let prevX = x0;\n    let prevY = y0;\n    const transform = (x, y) => {\n        const [xTemp, yTemp] = rotate([x * arc.rX, y * arc.rY], xRotRad);\n        return [arc.cX + xTemp, arc.cY + yTemp];\n    };\n    for (let i = 0; i < partCount; i++) {\n        const phiStart = lerp(arc.phi1, arc.phi2, i / partCount);\n        const phiEnd = lerp(arc.phi1, arc.phi2, (i + 1) / partCount);\n        const deltaPhi = phiEnd - phiStart;\n        const f = (4 / 3) * Math.tan((deltaPhi * DEG) / 4);\n        // x1/y1, x2/y2 and x/y coordinates on the unit circle for phiStart/phiEnd\n        const x1 = Math.cos(phiStart * DEG) - f * Math.sin(phiStart * DEG);\n        const y1 = Math.sin(phiStart * DEG) + f * Math.cos(phiStart * DEG);\n        const x = Math.cos(phiEnd * DEG);\n        const y = Math.sin(phiEnd * DEG);\n        const x2 = x + f * y;\n        const y2 = y - f * x;\n        const cp1 = transform(x1, y1);\n        const cp2 = transform(x2, y2);\n        const end = transform(x, y);\n        const command = {\n            relative: arc.relative,\n            type: SVGPathData.CURVE_TO,\n            x: end[0],\n            y: end[1],\n            x1: cp1[0],\n            y1: cp1[1],\n            x2: cp2[0],\n            y2: cp2[1],\n        };\n        if (arc.relative) {\n            command.x1 -= prevX;\n            command.y1 -= prevY;\n            command.x2 -= prevX;\n            command.y2 -= prevY;\n            command.x -= prevX;\n            command.y -= prevY;\n        }\n        prevX = end[0];\n        prevY = end[1];\n        result[i] = command;\n    }\n    return result;\n}\n/**\n * Determines if three points are collinear (lie on the same straight line)\n * and the middle point is on the line segment between the first and third points\n *\n * @param p1 First point [x, y]\n * @param p2 Middle point that might be removed\n * @param p3 Last point [x, y]\n * @returns true if the points are collinear and p2 is on the segment p1-p3\n */\nexport function arePointsCollinear(p1, p2, p3) {\n    // Create vectors\n    const v1x = p2[0] - p1[0];\n    const v1y = p2[1] - p1[1];\n    const v2x = p3[0] - p1[0];\n    const v2y = p3[1] - p1[1];\n    // Cross product: v1  v2 = v1x * v2y - v1y * v2x\n    // If cross product is close to zero, points are collinear\n    const cross = v1x * v2y - v1y * v2x;\n    const isCollinear = Math.abs(cross) < 1e-10;\n    if (!isCollinear)\n        return false;\n    // Now check if p2 is on the segment p1-p3\n    // For this we check if the projection of v1 onto v2 is between 0 and |v2|\n    // Calculate dot product\n    const dot = v1x * v2x + v1y * v2y;\n    // Calculate squared lengths\n    const lenSqV1 = v1x * v1x + v1y * v1y;\n    const lenSqV2 = v2x * v2x + v2y * v2y;\n    // p2 is on segment p1-p3 if:\n    // 1. 0  dot(v1,v2)  dot(v2,v2) - this checks if projection is within segment\n    // 2. |v1|  |v2| - this checks if p2 is not beyond p3\n    return 0 <= dot && dot <= lenSqV2 && lenSqV1 <= lenSqV2;\n}\n//# sourceMappingURL=mathUtils.js.map","import { SVGPathData } from '../index.js';\nimport { SVGPathDataTransformer } from '../SVGPathDataTransformer.js';\n/**\n * Reverses the order of path commands to go from end to start\n * IMPORTANT: This function expects absolute commands as input.\n * It doesn't convert relative to absolute - use SVGPathDataTransformer.TO_ABS() first if needed.\n * @param commands SVG path commands in absolute form to reverse\n * @param preserveSubpathOrder If true, keeps subpaths in their original order\n * @returns New SVG commands in reverse order with absolute coordinates\n */\nexport function REVERSE_PATH(commands, preserveSubpathOrder = true) {\n    if (commands.length < 2)\n        return commands;\n    // Extract absolute points using the transformer to track current position\n    const normalized = SVGPathDataTransformer.INFO((command, px, py) => ({\n        ...command,\n        x: command.x ?? px,\n        y: command.y ?? py,\n        relative: command.relative ?? false,\n    }));\n    const result = [];\n    let processing = [];\n    for (const original of commands) {\n        const cmd = normalized(original);\n        // Start a new subpath if needed\n        if (cmd.type === SVGPathData.MOVE_TO && processing.length > 0) {\n            if (preserveSubpathOrder) {\n                result.push(...reverseSubpath(processing));\n            }\n            else {\n                result.unshift(...reverseSubpath(processing));\n            }\n            processing = []; // Clear the current subpath\n        }\n        processing.push(cmd);\n    }\n    if (processing.length > 0) {\n        if (preserveSubpathOrder) {\n            result.push(...reverseSubpath(processing));\n        }\n        else {\n            result.unshift(...reverseSubpath(processing));\n        }\n    }\n    // Join the reversed subpaths in original order\n    return result;\n}\nfunction reverseSubpath(commands) {\n    // Check if path is explicitly closed (ends with CLOSE_PATH)\n    const isExplicitlyClosed = commands[commands.length - 1]?.type === SVGPathData.CLOSE_PATH;\n    // Start with a move to the last explicit point\n    // (if path ends with Z, use the point before Z)\n    const startPointIndex = isExplicitlyClosed\n        ? commands.length - 2\n        : commands.length - 1;\n    const reversed = [\n        {\n            type: SVGPathData.MOVE_TO,\n            relative: false,\n            x: commands[startPointIndex].x,\n            y: commands[startPointIndex].y,\n        },\n    ];\n    // Process each segment in reverse order\n    for (let i = startPointIndex; i > 0; i--) {\n        const curCmd = commands[i];\n        const prevPoint = commands[i - 1];\n        if (curCmd.relative) {\n            throw new Error('Relative command are not supported convert first with `toAbs()`');\n        }\n        // Handle the current command type\n        switch (curCmd.type) {\n            case SVGPathData.HORIZ_LINE_TO:\n                reversed.push({\n                    type: SVGPathData.HORIZ_LINE_TO,\n                    relative: false,\n                    x: prevPoint.x,\n                });\n                break;\n            case SVGPathData.VERT_LINE_TO:\n                reversed.push({\n                    type: SVGPathData.VERT_LINE_TO,\n                    relative: false,\n                    y: prevPoint.y,\n                });\n                break;\n            case SVGPathData.LINE_TO:\n            case SVGPathData.MOVE_TO:\n                reversed.push({\n                    type: SVGPathData.LINE_TO,\n                    relative: false,\n                    x: prevPoint.x,\n                    y: prevPoint.y,\n                });\n                break;\n            case SVGPathData.CURVE_TO:\n                reversed.push({\n                    type: SVGPathData.CURVE_TO,\n                    relative: false,\n                    x: prevPoint.x,\n                    y: prevPoint.y,\n                    x1: curCmd.x2,\n                    y1: curCmd.y2,\n                    x2: curCmd.x1,\n                    y2: curCmd.y1,\n                });\n                break;\n            case SVGPathData.SMOOTH_CURVE_TO:\n                throw new Error(`Unsupported command: S (smooth cubic bezier)`);\n            case SVGPathData.SMOOTH_QUAD_TO:\n                throw new Error(`Unsupported command: T (smooth quadratic bezier)`);\n            case SVGPathData.ARC:\n                throw new Error(`Unsupported command: A (arc)`);\n            case SVGPathData.QUAD_TO:\n                throw new Error(`Unsupported command: Q (quadratic bezier)`);\n        }\n    }\n    // If the original path was explicitly closed, preserve the Z command\n    if (isExplicitlyClosed) {\n        reversed.push({ type: SVGPathData.CLOSE_PATH });\n    }\n    return reversed;\n}\n//# sourceMappingURL=reverse_path.js.map","/* eslint @typescript-eslint/no-explicit-any:0 */\n// Transform SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\nimport { a2c, annotateArcCommand, arcAt, assertNumbers, bezierAt, bezierRoot, intersectionUnitCircleLine, arePointsCollinear, } from './mathUtils.js';\nimport { SVGPathData } from './SVGPathData.js';\nimport { REMOVE_COLLINEAR } from './transformers/remove_collinear.js';\nimport { REVERSE_PATH } from './transformers/reverse_path.js';\n// Predefined transforming functions\n// Rounds commands values\nfunction ROUND(roundVal = 1e13) {\n    assertNumbers(roundVal);\n    function rf(val) {\n        return Math.round(val * roundVal) / roundVal;\n    }\n    return function round(command) {\n        if ('x1' in command && 'undefined' !== typeof command.x1) {\n            command.x1 = rf(command.x1);\n        }\n        if ('y1' in command && 'undefined' !== typeof command.y1) {\n            command.y1 = rf(command.y1);\n        }\n        if ('x2' in command && 'undefined' !== typeof command.x2) {\n            command.x2 = rf(command.x2);\n        }\n        if ('y2' in command && 'undefined' !== typeof command.y2) {\n            command.y2 = rf(command.y2);\n        }\n        if ('x' in command && 'undefined' !== typeof command.x) {\n            command.x = rf(command.x);\n        }\n        if ('y' in command && 'undefined' !== typeof command.y) {\n            command.y = rf(command.y);\n        }\n        if ('rX' in command && 'undefined' !== typeof command.rX) {\n            command.rX = rf(command.rX);\n        }\n        if ('rY' in command && 'undefined' !== typeof command.rY) {\n            command.rY = rf(command.rY);\n        }\n        return command;\n    };\n}\n// Relative to absolute commands\nfunction TO_ABS() {\n    return INFO((command, prevX, prevY) => {\n        if (command.relative) {\n            // x1/y1 values\n            if ('undefined' !== typeof command.x1) {\n                command.x1 += prevX;\n            }\n            if ('undefined' !== typeof command.y1) {\n                command.y1 += prevY;\n            }\n            // x2/y2 values\n            if ('undefined' !== typeof command.x2) {\n                command.x2 += prevX;\n            }\n            if ('undefined' !== typeof command.y2) {\n                command.y2 += prevY;\n            }\n            // Finally x/y values\n            if ('undefined' !== typeof command.x) {\n                command.x += prevX;\n            }\n            if ('undefined' !== typeof command.y) {\n                command.y += prevY;\n            }\n            command.relative = false;\n        }\n        return command;\n    });\n}\n// Absolute to relative commands\nfunction TO_REL() {\n    return INFO((command, prevX, prevY) => {\n        if (!command.relative) {\n            // x1/y1 values\n            if ('undefined' !== typeof command.x1) {\n                command.x1 -= prevX;\n            }\n            if ('undefined' !== typeof command.y1) {\n                command.y1 -= prevY;\n            }\n            // x2/y2 values\n            if ('undefined' !== typeof command.x2) {\n                command.x2 -= prevX;\n            }\n            if ('undefined' !== typeof command.y2) {\n                command.y2 -= prevY;\n            }\n            // Finally x/y values\n            if ('undefined' !== typeof command.x) {\n                command.x -= prevX;\n            }\n            if ('undefined' !== typeof command.y) {\n                command.y -= prevY;\n            }\n            command.relative = true;\n        }\n        return command;\n    });\n}\n// Convert H, V, Z, A with rX = 0, and straight Bezier curves to L\nfunction NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true, normalizeC = true) {\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n        if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) {\n            throw new Error('path must start with moveto');\n        }\n        if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {\n            command.type = SVGPathData.LINE_TO;\n            command.y = command.relative ? 0 : prevY;\n        }\n        if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {\n            command.type = SVGPathData.LINE_TO;\n            command.x = command.relative ? 0 : prevX;\n        }\n        if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {\n            command.type = SVGPathData.LINE_TO;\n            command.x = command.relative ? pathStartX - prevX : pathStartX;\n            command.y = command.relative ? pathStartY - prevY : pathStartY;\n        }\n        // Handle degenerate arcs\n        if (command.type & SVGPathData.ARC &&\n            (0 === command.rX || 0 === command.rY)) {\n            command.type = SVGPathData.LINE_TO;\n            delete command.rX;\n            delete command.rY;\n            delete command.xRot;\n            delete command.lArcFlag;\n            delete command.sweepFlag;\n        }\n        // Check for quad curves that are lines\n        if (normalizeC && command.type & SVGPathData.QUAD_TO) {\n            const startPoint = [prevX, prevY];\n            const controlPoint = command.relative\n                ? [prevX + command.x1, prevY + command.y1]\n                : [command.x1, command.y1];\n            const endPoint = command.relative\n                ? [prevX + command.x, prevY + command.y]\n                : [command.x, command.y];\n            if (arePointsCollinear(startPoint, controlPoint, endPoint)) {\n                command.type = SVGPathData.LINE_TO;\n                // Keep the endpoint\n                delete command.x1;\n                delete command.y1;\n            }\n        }\n        // Check for cubic curves that are lines\n        if (normalizeC && command.type & SVGPathData.CURVE_TO) {\n            const startPoint = [prevX, prevY];\n            const control1 = command.relative\n                ? [prevX + command.x1, prevY + command.y1]\n                : [command.x1, command.y1];\n            const control2 = command.relative\n                ? [prevX + command.x2, prevY + command.y2]\n                : [command.x2, command.y2];\n            const endPoint = command.relative\n                ? [prevX + command.x, prevY + command.y]\n                : [command.x, command.y];\n            // All points need to be collinear\n            if (arePointsCollinear(startPoint, control1, endPoint) &&\n                arePointsCollinear(startPoint, control2, endPoint)) {\n                command.type = SVGPathData.LINE_TO;\n                // Keep the endpoint\n                delete command.x1;\n                delete command.y1;\n                delete command.x2;\n                delete command.y2;\n            }\n        }\n        return command;\n    });\n}\n/*\n * Transforms smooth curves and quads to normal curves and quads (SsTt to CcQq)\n */\nfunction NORMALIZE_ST() {\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n    return INFO((command, prevX, prevY) => {\n        if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n            command.type = SVGPathData.CURVE_TO;\n            prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;\n            prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;\n            command.x1 = command.relative\n                ? prevX - prevCurveC2X\n                : 2 * prevX - prevCurveC2X;\n            command.y1 = command.relative\n                ? prevY - prevCurveC2Y\n                : 2 * prevY - prevCurveC2Y;\n        }\n        if (command.type & SVGPathData.CURVE_TO) {\n            prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n            prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n        }\n        else {\n            prevCurveC2X = NaN;\n            prevCurveC2Y = NaN;\n        }\n        if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n            command.type = SVGPathData.QUAD_TO;\n            prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;\n            prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;\n            command.x1 = command.relative\n                ? prevX - prevQuadCX\n                : 2 * prevX - prevQuadCX;\n            command.y1 = command.relative\n                ? prevY - prevQuadCY\n                : 2 * prevY - prevQuadCY;\n        }\n        if (command.type & SVGPathData.QUAD_TO) {\n            prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n            prevQuadCY = command.relative ? prevY + command.y1 : command.y1;\n        }\n        else {\n            prevQuadCX = NaN;\n            prevQuadCY = NaN;\n        }\n        return command;\n    });\n}\n/*\n * A quadratic bzier curve can be represented by a cubic bzier curve which has\n * the same end points as the quadratic and both control points in place of the\n * quadratic\"s one.\n *\n * This transformer replaces QqTt commands with Cc commands respectively.\n * This is useful for reading path data into a system which only has a\n * representation for cubic curves.\n */\nfunction QT_TO_C() {\n    let prevQuadX1 = NaN;\n    let prevQuadY1 = NaN;\n    return INFO((command, prevX, prevY) => {\n        if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n            command.type = SVGPathData.QUAD_TO;\n            prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;\n            prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;\n            command.x1 = command.relative\n                ? prevX - prevQuadX1\n                : 2 * prevX - prevQuadX1;\n            command.y1 = command.relative\n                ? prevY - prevQuadY1\n                : 2 * prevY - prevQuadY1;\n        }\n        if (command.type & SVGPathData.QUAD_TO) {\n            prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;\n            prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;\n            const x1 = command.x1;\n            const y1 = command.y1;\n            command.type = SVGPathData.CURVE_TO;\n            command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;\n            command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;\n            command.x2 = (command.x + x1 * 2) / 3;\n            command.y2 = (command.y + y1 * 2) / 3;\n        }\n        else {\n            prevQuadX1 = NaN;\n            prevQuadY1 = NaN;\n        }\n        return command;\n    });\n}\nfunction INFO(f) {\n    let prevXAbs = 0;\n    let prevYAbs = 0;\n    let pathStartXAbs = NaN;\n    let pathStartYAbs = NaN;\n    return function transform(command) {\n        if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) {\n            throw new Error('path must start with moveto');\n        }\n        const result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);\n        if (command.type & SVGPathData.CLOSE_PATH) {\n            prevXAbs = pathStartXAbs;\n            prevYAbs = pathStartYAbs;\n        }\n        if ('x' in command && 'undefined' !== typeof command.x) {\n            prevXAbs = command.relative ? prevXAbs + command.x : command.x;\n        }\n        if ('y' in command && 'undefined' !== typeof command.y) {\n            prevYAbs = command.relative ? prevYAbs + command.y : command.y;\n        }\n        if (command.type & SVGPathData.MOVE_TO) {\n            pathStartXAbs = prevXAbs;\n            pathStartYAbs = prevYAbs;\n        }\n        return result;\n    };\n}\n/*\n * remove 0-length segments\n */\nfunction SANITIZE(EPS = 0) {\n    assertNumbers(EPS);\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n        const abs = Math.abs;\n        let skip = false;\n        let x1Rel = 0;\n        let y1Rel = 0;\n        if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n            x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;\n            y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;\n        }\n        if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {\n            prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n            prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n        }\n        else {\n            prevCurveC2X = NaN;\n            prevCurveC2Y = NaN;\n        }\n        if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n            prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;\n            prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;\n        }\n        else if (command.type & SVGPathData.QUAD_TO) {\n            prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n            prevQuadCY = command.relative ? prevY + command.y1 : command.y2;\n        }\n        else {\n            prevQuadCX = NaN;\n            prevQuadCY = NaN;\n        }\n        if (command.type & SVGPathData.LINE_COMMANDS ||\n            (command.type & SVGPathData.ARC &&\n                (0 === command.rX || 0 === command.rY || !command.lArcFlag)) ||\n            command.type & SVGPathData.CURVE_TO ||\n            command.type & SVGPathData.SMOOTH_CURVE_TO ||\n            command.type & SVGPathData.QUAD_TO ||\n            command.type & SVGPathData.SMOOTH_QUAD_TO) {\n            const xRel = 'undefined' === typeof command.x\n                ? 0\n                : command.relative\n                    ? command.x\n                    : command.x - prevX;\n            const yRel = 'undefined' === typeof command.y\n                ? 0\n                : command.relative\n                    ? command.y\n                    : command.y - prevY;\n            x1Rel = !isNaN(prevQuadCX)\n                ? prevQuadCX - prevX\n                : 'undefined' === typeof command.x1\n                    ? x1Rel\n                    : command.relative\n                        ? command.x\n                        : command.x1 - prevX;\n            y1Rel = !isNaN(prevQuadCY)\n                ? prevQuadCY - prevY\n                : 'undefined' === typeof command.y1\n                    ? y1Rel\n                    : command.relative\n                        ? command.y\n                        : command.y1 - prevY;\n            const x2Rel = 'undefined' === typeof command.x2\n                ? 0\n                : command.relative\n                    ? command.x\n                    : command.x2 - prevX;\n            const y2Rel = 'undefined' === typeof command.y2\n                ? 0\n                : command.relative\n                    ? command.y\n                    : command.y2 - prevY;\n            if (abs(xRel) <= EPS &&\n                abs(yRel) <= EPS &&\n                abs(x1Rel) <= EPS &&\n                abs(y1Rel) <= EPS &&\n                abs(x2Rel) <= EPS &&\n                abs(y2Rel) <= EPS) {\n                skip = true;\n            }\n        }\n        if (command.type & SVGPathData.CLOSE_PATH) {\n            if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) {\n                skip = true;\n            }\n        }\n        return skip ? [] : command;\n    });\n}\n// SVG Transforms : http://www.w3.org/TR/SVGTiny12/coords.html#TransformList\n// Matrix : http://apike.ca/prog_svg_transform.html\n// a c e\n// b d f\nfunction MATRIX(a, b, c, d, e, f) {\n    assertNumbers(a, b, c, d, e, f);\n    return INFO((command, prevX, prevY, pathStartX) => {\n        const origX1 = command.x1;\n        const origX2 = command.x2;\n        // if isNaN(pathStartX), then this is the first command, which is ALWAYS an\n        // absolute MOVE_TO, regardless what the relative flag says\n        const comRel = command.relative && !isNaN(pathStartX);\n        const x = 'undefined' !== typeof command.x ? command.x : comRel ? 0 : prevX;\n        const y = 'undefined' !== typeof command.y ? command.y : comRel ? 0 : prevY;\n        if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {\n            command.type = SVGPathData.LINE_TO;\n            command.y = command.relative ? 0 : prevY;\n        }\n        if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {\n            command.type = SVGPathData.LINE_TO;\n            command.x = command.relative ? 0 : prevX;\n        }\n        if ('undefined' !== typeof command.x) {\n            command.x = command.x * a + y * c + (comRel ? 0 : e);\n        }\n        if ('undefined' !== typeof command.y) {\n            command.y = x * b + command.y * d + (comRel ? 0 : f);\n        }\n        if ('undefined' !== typeof command.x1) {\n            command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);\n        }\n        if ('undefined' !== typeof command.y1) {\n            command.y1 = origX1 * b + command.y1 * d + (comRel ? 0 : f);\n        }\n        if ('undefined' !== typeof command.x2) {\n            command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);\n        }\n        if ('undefined' !== typeof command.y2) {\n            command.y2 = origX2 * b + command.y2 * d + (comRel ? 0 : f);\n        }\n        function sqr(x) {\n            return x * x;\n        }\n        const det = a * d - b * c;\n        if ('undefined' !== typeof command.xRot) {\n            // Skip if this is a pure translation\n            if (1 !== a || 0 !== b || 0 !== c || 1 !== d) {\n                // Special case for singular matrix\n                if (0 === det) {\n                    // In the singular case, the arc is compressed to a line. The actual geometric image of the original\n                    // curve under this transform possibly extends beyond the starting and/or ending points of the segment, but\n                    // for simplicity we ignore this detail and just replace this command with a single line segment.\n                    delete command.rX;\n                    delete command.rY;\n                    delete command.xRot;\n                    delete command.lArcFlag;\n                    delete command.sweepFlag;\n                    command.type = SVGPathData.LINE_TO;\n                }\n                else {\n                    // Convert to radians\n                    const xRot = (command.xRot * Math.PI) / 180;\n                    // Convert rotated ellipse to general conic form\n                    // x0^2/rX^2 + y0^2/rY^2 - 1 = 0\n                    // x0 = x*cos(xRot) + y*sin(xRot)\n                    // y0 = -x*sin(xRot) + y*cos(xRot)\n                    // --> A*x^2 + B*x*y + C*y^2 - 1 = 0, where\n                    const sinRot = Math.sin(xRot);\n                    const cosRot = Math.cos(xRot);\n                    const xCurve = 1 / sqr(command.rX);\n                    const yCurve = 1 / sqr(command.rY);\n                    const A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;\n                    const B = 2 * sinRot * cosRot * (xCurve - yCurve);\n                    const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;\n                    // Apply matrix to A*x^2 + B*x*y + C*y^2 - 1 = 0\n                    // x1 = a*x + c*y\n                    // y1 = b*x + d*y\n                    //      (we can ignore e and f, since pure translations don\"t affect the shape of the ellipse)\n                    // --> A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 = 0, where\n                    const A1 = A * d * d - B * b * d + C * b * b;\n                    const B1 = B * (a * d + b * c) - 2 * (A * c * d + C * a * b);\n                    const C1 = A * c * c - B * a * c + C * a * a;\n                    // Unapply newXRot to get back to axis-aligned ellipse equation\n                    // x1 = x2*cos(newXRot) - y2*sin(newXRot)\n                    // y1 = x2*sin(newXRot) + y2*cos(newXRot)\n                    // A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 =\n                    //   x2^2*(A1*cos(newXRot)^2 + B1*sin(newXRot)*cos(newXRot) + C1*sin(newXRot)^2)\n                    //   + x2*y2*(2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2))\n                    //   + y2^2*(A1*sin(newXRot)^2 - B1*sin(newXRot)*cos(newXRot) + C1*cos(newXRot)^2)\n                    //   (which must have the same zeroes as)\n                    // x2^2/newRX^2 + y2^2/newRY^2 - 1\n                    //   (so we have)\n                    // 2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2) = 0\n                    // (A1 - C1)*sin(2*newXRot) = B1*cos(2*newXRot)\n                    // 2*newXRot = atan2(B1, A1 - C1)\n                    const newXRot = ((Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI) / 2;\n                    // For any integer n, (atan2(B1, A1 - C1) + n*pi)/2 is a solution to the above; incrementing n just swaps\n                    // the x and y radii computed below (since that\"s what rotating an ellipse by pi/2 does).  Choosing the\n                    // rotation between 0 and pi/2 eliminates the ambiguity and leads to more predictable output.\n                    // Finally, we get newRX and newRY from the same-zeroes relationship that gave us newXRot\n                    const newSinRot = Math.sin(newXRot);\n                    const newCosRot = Math.cos(newXRot);\n                    command.rX =\n                        Math.abs(det) /\n                            Math.sqrt(A1 * sqr(newCosRot) +\n                                B1 * newSinRot * newCosRot +\n                                C1 * sqr(newSinRot));\n                    command.rY =\n                        Math.abs(det) /\n                            Math.sqrt(A1 * sqr(newSinRot) -\n                                B1 * newSinRot * newCosRot +\n                                C1 * sqr(newCosRot));\n                    command.xRot = (newXRot * 180) / Math.PI;\n                }\n            }\n        }\n        // sweepFlag needs to be inverted when mirroring shapes\n        // see http://www.itk.ilstu.edu/faculty/javila/SVG/SVG_drawing1/elliptical_curve.htm\n        // m 65,10 a 50,25 0 1 0 50,25\n        // M 65,60 A 50,25 0 1 1 115,35\n        if ('undefined' !== typeof command.sweepFlag && 0 > det) {\n            command.sweepFlag = +!command.sweepFlag;\n        }\n        return command;\n    });\n}\nfunction ROTATE(a, x = 0, y = 0) {\n    assertNumbers(a, x, y);\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n    return MATRIX(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);\n}\nfunction TRANSLATE(dX, dY = 0) {\n    assertNumbers(dX, dY);\n    return MATRIX(1, 0, 0, 1, dX, dY);\n}\nfunction SCALE(dX, dY = dX) {\n    assertNumbers(dX, dY);\n    return MATRIX(dX, 0, 0, dY, 0, 0);\n}\nfunction SKEW_X(a) {\n    assertNumbers(a);\n    return MATRIX(1, 0, Math.tan(a), 1, 0, 0);\n}\nfunction SKEW_Y(a) {\n    assertNumbers(a);\n    return MATRIX(1, Math.tan(a), 0, 1, 0, 0);\n}\nfunction X_AXIS_SYMMETRY(xOffset = 0) {\n    assertNumbers(xOffset);\n    return MATRIX(-1, 0, 0, 1, xOffset, 0);\n}\nfunction Y_AXIS_SYMMETRY(yOffset = 0) {\n    assertNumbers(yOffset);\n    return MATRIX(1, 0, 0, -1, 0, yOffset);\n}\n// Convert arc commands to curve commands\nfunction A_TO_C() {\n    return INFO((command, prevX, prevY) => {\n        if (SVGPathData.ARC === command.type) {\n            return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);\n        }\n        return command;\n    });\n}\n// @see annotateArcCommand\nfunction ANNOTATE_ARCS() {\n    return INFO((c, x1, y1) => {\n        if (c.relative) {\n            x1 = 0;\n            y1 = 0;\n        }\n        if (SVGPathData.ARC === c.type) {\n            annotateArcCommand(c, x1, y1);\n        }\n        return c;\n    });\n}\nfunction CLONE() {\n    return (c) => {\n        return { ...c };\n    };\n}\n// @see annotateArcCommand\nfunction CALCULATE_BOUNDS() {\n    const clone = CLONE();\n    const toAbs = TO_ABS();\n    const qtToC = QT_TO_C();\n    const normST = NORMALIZE_ST();\n    const f = INFO((command, prevXAbs, prevYAbs) => {\n        const c = normST(qtToC(toAbs(clone(command))));\n        function fixX(absX) {\n            if (absX > f.maxX) {\n                f.maxX = absX;\n            }\n            if (absX < f.minX) {\n                f.minX = absX;\n            }\n        }\n        function fixY(absY) {\n            if (absY > f.maxY) {\n                f.maxY = absY;\n            }\n            if (absY < f.minY) {\n                f.minY = absY;\n            }\n        }\n        if (c.type & SVGPathData.DRAWING_COMMANDS) {\n            fixX(prevXAbs);\n            fixY(prevYAbs);\n        }\n        if (c.type & SVGPathData.HORIZ_LINE_TO) {\n            fixX(c.x);\n        }\n        if (c.type & SVGPathData.VERT_LINE_TO) {\n            fixY(c.y);\n        }\n        if (c.type & SVGPathData.LINE_TO) {\n            fixX(c.x);\n            fixY(c.y);\n        }\n        if (c.type & SVGPathData.CURVE_TO) {\n            // add start and end points\n            fixX(c.x);\n            fixY(c.y);\n            const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);\n            for (const derivRoot of xDerivRoots) {\n                if (0 < derivRoot && 1 > derivRoot) {\n                    fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));\n                }\n            }\n            const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);\n            for (const derivRoot of yDerivRoots) {\n                if (0 < derivRoot && 1 > derivRoot) {\n                    fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));\n                }\n            }\n        }\n        if (c.type & SVGPathData.ARC) {\n            // add start and end points\n            fixX(c.x);\n            fixY(c.y);\n            annotateArcCommand(c, prevXAbs, prevYAbs);\n            // p = cos(phi) * xv + sin(phi) * yv\n            // dp = -sin(phi) * xv + cos(phi) * yv = 0\n            const xRotRad = (c.xRot / 180) * Math.PI;\n            // points on ellipse for phi = 0 and phi = 90\n            const x0 = Math.cos(xRotRad) * c.rX;\n            const y0 = Math.sin(xRotRad) * c.rX;\n            const x90 = -Math.sin(xRotRad) * c.rY;\n            const y90 = Math.cos(xRotRad) * c.rY;\n            // annotateArcCommand returns phi1 and phi2 such that -180 < phi1 < 180 and phi2 is smaller or greater\n            // depending on the sweep flag. Calculate phiMin, phiMax such that -180 < phiMin < 180 and phiMin < phiMax\n            const [phiMin, phiMax] = c.phi1 < c.phi2\n                ? [c.phi1, c.phi2]\n                : -180 > c.phi2\n                    ? [c.phi2 + 360, c.phi1 + 360]\n                    : [c.phi2, c.phi1];\n            const normalizeXiEta = ([xi, eta]) => {\n                const phiRad = Math.atan2(eta, xi);\n                const phi = (phiRad * 180) / Math.PI;\n                return phi < phiMin ? phi + 360 : phi;\n            };\n            // xi = cos(phi), eta = sin(phi)\n            const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);\n            for (const derivRoot of xDerivRoots) {\n                if (derivRoot > phiMin && derivRoot < phiMax) {\n                    fixX(arcAt(c.cX, x0, x90, derivRoot));\n                }\n            }\n            const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);\n            for (const derivRoot of yDerivRoots) {\n                if (derivRoot > phiMin && derivRoot < phiMax) {\n                    fixY(arcAt(c.cY, y0, y90, derivRoot));\n                }\n            }\n        }\n        return command;\n    });\n    f.minX = Infinity;\n    f.maxX = -Infinity;\n    f.minY = Infinity;\n    f.maxY = -Infinity;\n    return f;\n}\nexport const SVGPathDataTransformer = {\n    ROUND,\n    TO_ABS,\n    TO_REL,\n    NORMALIZE_HVZ,\n    NORMALIZE_ST,\n    QT_TO_C,\n    INFO,\n    SANITIZE,\n    MATRIX,\n    ROTATE,\n    TRANSLATE,\n    SCALE,\n    SKEW_X,\n    SKEW_Y,\n    X_AXIS_SYMMETRY,\n    Y_AXIS_SYMMETRY,\n    A_TO_C,\n    ANNOTATE_ARCS,\n    CLONE,\n    CALCULATE_BOUNDS,\n    REVERSE_PATH,\n    REMOVE_COLLINEAR,\n};\n//# sourceMappingURL=SVGPathDataTransformer.js.map","import { SVGPathData } from '../SVGPathData.js';\nimport { SVGPathDataTransformer } from '../index.js';\nimport { arePointsCollinear } from '../mathUtils.js';\n/**\n * Process a path and remove collinear points\n * @param commands Array of SVG path commands to process (must be absolute)\n * @returns New array with collinear points removed\n */\nexport function REMOVE_COLLINEAR(commands) {\n    if (commands.length <= 2)\n        return commands; // exit early if there are less than 3 points\n    const results = [];\n    const points = commands.map(SVGPathDataTransformer.INFO((cmd, pXAbs, pYAbs) => {\n        // Calculate absolute coordinates and normlise HV\n        const isRelatve = 'relative' in cmd && cmd.relative;\n        return [\n            'x' in cmd ? cmd.x + (isRelatve ? pXAbs : 0) : pXAbs,\n            'y' in cmd ? cmd.y + (isRelatve ? pYAbs : 0) : pYAbs,\n        ];\n    }));\n    let prevPoint = points[0];\n    results.push(commands[0]); // always keep the first point\n    for (let i = 1; i < commands.length; i++) {\n        const cmd = commands[i];\n        const nextCmd = commands[i + 1];\n        if (i < commands.length - 1 &&\n            nextCmd &&\n            cmd.type & SVGPathData.LINE_COMMANDS &&\n            nextCmd.type & SVGPathData.LINE_COMMANDS) {\n            const nextPoint = points[i + 1];\n            // Check triplets of points for collinearity\n            if (arePointsCollinear(prevPoint, points[i], nextPoint)) {\n                // update next point if its relative\n                if ('relative' in nextCmd && nextCmd.relative) {\n                    if ('x' in nextCmd)\n                        nextCmd.x = nextPoint[0] - prevPoint[0];\n                    if ('y' in nextCmd)\n                        nextCmd.y = nextPoint[1] - prevPoint[1];\n                }\n                continue;\n            }\n        }\n        results.push(cmd);\n        prevPoint = points[i];\n    }\n    return results;\n}\n//# sourceMappingURL=remove_collinear.js.map","import { SVGPathDataTransformer } from './SVGPathDataTransformer.js';\nexport class TransformableSVG {\n    round(x) {\n        return this.transform(SVGPathDataTransformer.ROUND(x));\n    }\n    toAbs() {\n        return this.transform(SVGPathDataTransformer.TO_ABS());\n    }\n    toRel() {\n        return this.transform(SVGPathDataTransformer.TO_REL());\n    }\n    normalizeHVZ(a, b, c) {\n        return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a, b, c));\n    }\n    normalizeST() {\n        return this.transform(SVGPathDataTransformer.NORMALIZE_ST());\n    }\n    qtToC() {\n        return this.transform(SVGPathDataTransformer.QT_TO_C());\n    }\n    aToC() {\n        return this.transform(SVGPathDataTransformer.A_TO_C());\n    }\n    sanitize(eps) {\n        return this.transform(SVGPathDataTransformer.SANITIZE(eps));\n    }\n    translate(x, y) {\n        return this.transform(SVGPathDataTransformer.TRANSLATE(x, y));\n    }\n    scale(x, y) {\n        return this.transform(SVGPathDataTransformer.SCALE(x, y));\n    }\n    rotate(a, x, y) {\n        return this.transform(SVGPathDataTransformer.ROTATE(a, x, y));\n    }\n    matrix(a, b, c, d, e, f) {\n        return this.transform(SVGPathDataTransformer.MATRIX(a, b, c, d, e, f));\n    }\n    skewX(a) {\n        return this.transform(SVGPathDataTransformer.SKEW_X(a));\n    }\n    skewY(a) {\n        return this.transform(SVGPathDataTransformer.SKEW_Y(a));\n    }\n    xSymmetry(xOffset) {\n        return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));\n    }\n    ySymmetry(yOffset) {\n        return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));\n    }\n    annotateArcs() {\n        return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());\n    }\n}\n//# sourceMappingURL=TransformableSVG.js.map","// Parse SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\nimport { COMMAND_ARG_COUNTS, SVGPathData } from './SVGPathData.js';\nimport { TransformableSVG } from './TransformableSVG.js';\n// Private consts : Char groups\nconst isWhiteSpace = (c) => ' ' === c || '\\t' === c || '\\r' === c || '\\n' === c;\nconst isDigit = (c) => '0'.charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= '9'.charCodeAt(0);\nexport class SVGPathDataParser extends TransformableSVG {\n    curNumber = '';\n    curCommandType = -1;\n    curCommandRelative = false;\n    canParseCommandOrComma = true;\n    curNumberHasExp = false;\n    curNumberHasExpDigits = false;\n    curNumberHasDecimal = false;\n    curArgs = [];\n    constructor() {\n        super();\n    }\n    finish(commands = []) {\n        this.parse(' ', commands);\n        // Adding residual command\n        if (0 !== this.curArgs.length || !this.canParseCommandOrComma) {\n            throw new SyntaxError('Unterminated command at the path end.');\n        }\n        return commands;\n    }\n    parse(str, commands = []) {\n        const finishCommand = (command) => {\n            commands.push(command);\n            this.curArgs.length = 0;\n            this.canParseCommandOrComma = true;\n        };\n        for (let i = 0; i < str.length; i++) {\n            const c = str[i];\n            // White spaces parsing\n            const isAArcFlag = this.curCommandType === SVGPathData.ARC &&\n                (this.curArgs.length === 3 || this.curArgs.length === 4) &&\n                this.curNumber.length === 1 &&\n                (this.curNumber === '0' || this.curNumber === '1');\n            const isEndingDigit = isDigit(c) && ((this.curNumber === '0' && c === '0') || isAArcFlag);\n            if (isDigit(c) && !isEndingDigit) {\n                this.curNumber += c;\n                this.curNumberHasExpDigits = this.curNumberHasExp;\n                continue;\n            }\n            if ('e' === c || 'E' === c) {\n                this.curNumber += c;\n                this.curNumberHasExp = true;\n                continue;\n            }\n            if (('-' === c || '+' === c) &&\n                this.curNumberHasExp &&\n                !this.curNumberHasExpDigits) {\n                this.curNumber += c;\n                continue;\n            }\n            // if we already have a \".\", it means we are starting a new number\n            if ('.' === c &&\n                !this.curNumberHasExp &&\n                !this.curNumberHasDecimal &&\n                !isAArcFlag) {\n                this.curNumber += c;\n                this.curNumberHasDecimal = true;\n                continue;\n            }\n            // New number\n            if (this.curNumber && -1 !== this.curCommandType) {\n                const val = Number(this.curNumber);\n                if (isNaN(val)) {\n                    throw new SyntaxError(`Invalid number ending at ${i}`);\n                }\n                if (this.curCommandType === SVGPathData.ARC) {\n                    if (0 === this.curArgs.length || 1 === this.curArgs.length) {\n                        if (0 > val) {\n                            throw new SyntaxError(`Expected positive number, got \"${val}\" at index \"${i}\"`);\n                        }\n                    }\n                    else if (3 === this.curArgs.length || 4 === this.curArgs.length) {\n                        if ('0' !== this.curNumber && '1' !== this.curNumber) {\n                            throw new SyntaxError(`Expected a flag, got \"${this.curNumber}\" at index \"${i}\"`);\n                        }\n                    }\n                }\n                this.curArgs.push(val);\n                if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {\n                    if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) {\n                        finishCommand({\n                            type: SVGPathData.HORIZ_LINE_TO,\n                            relative: this.curCommandRelative,\n                            x: val,\n                        });\n                    }\n                    else if (SVGPathData.VERT_LINE_TO === this.curCommandType) {\n                        finishCommand({\n                            type: SVGPathData.VERT_LINE_TO,\n                            relative: this.curCommandRelative,\n                            y: val,\n                        });\n                        // Move to / line to / smooth quadratic curve to commands (x, y)\n                    }\n                    else if (this.curCommandType === SVGPathData.MOVE_TO ||\n                        this.curCommandType === SVGPathData.LINE_TO ||\n                        this.curCommandType === SVGPathData.SMOOTH_QUAD_TO) {\n                        finishCommand({\n                            type: this.curCommandType,\n                            relative: this.curCommandRelative,\n                            x: this.curArgs[0],\n                            y: this.curArgs[1],\n                        });\n                        // Switch to line to state\n                        if (SVGPathData.MOVE_TO === this.curCommandType) {\n                            this.curCommandType = SVGPathData.LINE_TO;\n                        }\n                    }\n                    else if (this.curCommandType === SVGPathData.CURVE_TO) {\n                        finishCommand({\n                            type: SVGPathData.CURVE_TO,\n                            relative: this.curCommandRelative,\n                            x1: this.curArgs[0],\n                            y1: this.curArgs[1],\n                            x2: this.curArgs[2],\n                            y2: this.curArgs[3],\n                            x: this.curArgs[4],\n                            y: this.curArgs[5],\n                        });\n                    }\n                    else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) {\n                        finishCommand({\n                            type: SVGPathData.SMOOTH_CURVE_TO,\n                            relative: this.curCommandRelative,\n                            x2: this.curArgs[0],\n                            y2: this.curArgs[1],\n                            x: this.curArgs[2],\n                            y: this.curArgs[3],\n                        });\n                    }\n                    else if (this.curCommandType === SVGPathData.QUAD_TO) {\n                        finishCommand({\n                            type: SVGPathData.QUAD_TO,\n                            relative: this.curCommandRelative,\n                            x1: this.curArgs[0],\n                            y1: this.curArgs[1],\n                            x: this.curArgs[2],\n                            y: this.curArgs[3],\n                        });\n                    }\n                    else if (this.curCommandType === SVGPathData.ARC) {\n                        finishCommand({\n                            type: SVGPathData.ARC,\n                            relative: this.curCommandRelative,\n                            rX: this.curArgs[0],\n                            rY: this.curArgs[1],\n                            xRot: this.curArgs[2],\n                            lArcFlag: this.curArgs[3],\n                            sweepFlag: this.curArgs[4],\n                            x: this.curArgs[5],\n                            y: this.curArgs[6],\n                        });\n                    }\n                }\n                this.curNumber = '';\n                this.curNumberHasExpDigits = false;\n                this.curNumberHasExp = false;\n                this.curNumberHasDecimal = false;\n                this.canParseCommandOrComma = true;\n            }\n            // Continue if a white space or a comma was detected\n            if (isWhiteSpace(c)) {\n                continue;\n            }\n            if (',' === c && this.canParseCommandOrComma) {\n                // L 0,0, H is not valid:\n                this.canParseCommandOrComma = false;\n                continue;\n            }\n            // if a sign is detected, then parse the new number\n            if ('+' === c || '-' === c || '.' === c) {\n                this.curNumber = c;\n                this.curNumberHasDecimal = '.' === c;\n                continue;\n            }\n            // if a 0 is detected, then parse the new number\n            if (isEndingDigit) {\n                this.curNumber = c;\n                this.curNumberHasDecimal = false;\n                continue;\n            }\n            // Adding residual command\n            if (0 !== this.curArgs.length) {\n                throw new SyntaxError(`Unterminated command at index ${i}.`);\n            }\n            if (!this.canParseCommandOrComma) {\n                throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}. Command cannot follow comma`);\n            }\n            this.canParseCommandOrComma = false;\n            // Detecting the next command\n            if ('z' === c || 'Z' === c) {\n                commands.push({\n                    type: SVGPathData.CLOSE_PATH,\n                });\n                this.canParseCommandOrComma = true;\n                this.curCommandType = -1;\n                continue;\n                // Horizontal move to command\n            }\n            else if ('h' === c || 'H' === c) {\n                this.curCommandType = SVGPathData.HORIZ_LINE_TO;\n                this.curCommandRelative = 'h' === c;\n                // Vertical move to command\n            }\n            else if ('v' === c || 'V' === c) {\n                this.curCommandType = SVGPathData.VERT_LINE_TO;\n                this.curCommandRelative = 'v' === c;\n                // Move to command\n            }\n            else if ('m' === c || 'M' === c) {\n                this.curCommandType = SVGPathData.MOVE_TO;\n                this.curCommandRelative = 'm' === c;\n                // Line to command\n            }\n            else if ('l' === c || 'L' === c) {\n                this.curCommandType = SVGPathData.LINE_TO;\n                this.curCommandRelative = 'l' === c;\n                // Curve to command\n            }\n            else if ('c' === c || 'C' === c) {\n                this.curCommandType = SVGPathData.CURVE_TO;\n                this.curCommandRelative = 'c' === c;\n                // Smooth curve to command\n            }\n            else if ('s' === c || 'S' === c) {\n                this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;\n                this.curCommandRelative = 's' === c;\n                // Quadratic bezier curve to command\n            }\n            else if ('q' === c || 'Q' === c) {\n                this.curCommandType = SVGPathData.QUAD_TO;\n                this.curCommandRelative = 'q' === c;\n                // Smooth quadratic bezier curve to command\n            }\n            else if ('t' === c || 'T' === c) {\n                this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;\n                this.curCommandRelative = 't' === c;\n                // Elliptic arc command\n            }\n            else if ('a' === c || 'A' === c) {\n                this.curCommandType = SVGPathData.ARC;\n                this.curCommandRelative = 'a' === c;\n            }\n            else {\n                throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}.`);\n            }\n        }\n        return commands;\n    }\n    /**\n     * Return a wrapper around this parser which applies the transformation on parsed commands.\n     */\n    transform(transform) {\n        const result = Object.create(this, {\n            parse: {\n                value(chunk, commands = []) {\n                    const parsedCommands = Object.getPrototypeOf(this).parse.call(this, chunk);\n                    for (const c of parsedCommands) {\n                        const cT = transform(c);\n                        if (Array.isArray(cT)) {\n                            commands.push(...cT);\n                        }\n                        else {\n                            commands.push(cT);\n                        }\n                    }\n                    return commands;\n                },\n            },\n        });\n        return result;\n    }\n}\n//# sourceMappingURL=SVGPathDataParser.js.map","import { encodeSVGPath } from './SVGPathDataEncoder.js';\nimport { SVGPathDataParser } from './SVGPathDataParser.js';\nimport { SVGPathDataTransformer } from './SVGPathDataTransformer.js';\nimport { TransformableSVG } from './TransformableSVG.js';\nexport class SVGPathData extends TransformableSVG {\n    commands;\n    constructor(content) {\n        super();\n        if ('string' === typeof content) {\n            this.commands = SVGPathData.parse(content);\n        }\n        else {\n            this.commands = content;\n        }\n    }\n    encode() {\n        return SVGPathData.encode(this.commands);\n    }\n    getBounds() {\n        const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();\n        this.transform(boundsTransform);\n        return boundsTransform;\n    }\n    transform(transformFunction) {\n        const newCommands = [];\n        for (const command of this.commands) {\n            const transformedCommand = transformFunction(command);\n            if (Array.isArray(transformedCommand)) {\n                newCommands.push(...transformedCommand);\n            }\n            else {\n                newCommands.push(transformedCommand);\n            }\n        }\n        this.commands = newCommands;\n        return this;\n    }\n    /**\n     * Reverses the order of path commands to go from end to start\n     * IMPORTANT: This function expects absolute commands as input.\n     * @param preserveSubpathOrder If true, keeps subpaths in their original order\n     */\n    reverse(preserveSubpathOrder = true) {\n        this.commands = SVGPathDataTransformer.REVERSE_PATH(this.commands, preserveSubpathOrder);\n        return this;\n    }\n    removeCollinear() {\n        this.commands = SVGPathDataTransformer.REMOVE_COLLINEAR(this.commands);\n        return this;\n    }\n    static encode(commands) {\n        return encodeSVGPath(commands);\n    }\n    static parse(path) {\n        const parser = new SVGPathDataParser();\n        const commands = [];\n        parser.parse(path, commands);\n        parser.finish(commands);\n        return commands;\n    }\n    static CLOSE_PATH = 1;\n    static MOVE_TO = 2;\n    static HORIZ_LINE_TO = 4;\n    static VERT_LINE_TO = 8;\n    static LINE_TO = 16;\n    static CURVE_TO = 32;\n    static SMOOTH_CURVE_TO = 64;\n    static QUAD_TO = 128;\n    static SMOOTH_QUAD_TO = 256;\n    static ARC = 512;\n    static LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;\n    static DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO |\n        SVGPathData.VERT_LINE_TO |\n        SVGPathData.LINE_TO |\n        SVGPathData.CURVE_TO |\n        SVGPathData.SMOOTH_CURVE_TO |\n        SVGPathData.QUAD_TO |\n        SVGPathData.SMOOTH_QUAD_TO |\n        SVGPathData.ARC;\n}\nexport const COMMAND_ARG_COUNTS = {\n    [SVGPathData.MOVE_TO]: 2,\n    [SVGPathData.LINE_TO]: 2,\n    [SVGPathData.HORIZ_LINE_TO]: 1,\n    [SVGPathData.VERT_LINE_TO]: 1,\n    [SVGPathData.CLOSE_PATH]: 0,\n    [SVGPathData.QUAD_TO]: 4,\n    [SVGPathData.SMOOTH_QUAD_TO]: 2,\n    [SVGPathData.CURVE_TO]: 6,\n    [SVGPathData.SMOOTH_CURVE_TO]: 4,\n    [SVGPathData.ARC]: 7,\n};\n//# sourceMappingURL=SVGPathData.js.map","import { createConsole } from \"./Console.ts\";\nimport {\n  DisplayContextCommand,\n  trimContextCommands,\n} from \"./DisplayContextCommand.ts\";\nimport { INode, parseSync } from \"svgson\";\nimport { SVGPathData } from \"svg-pathdata\";\nimport { DisplayBezierCurve, DisplaySize } from \"../DisplayManager.ts\";\nimport { pointInPolygon, Vector2 } from \"./MathUtils.ts\";\nimport {\n  contourArea,\n  DisplaySprite,\n  DisplaySpriteSheet,\n  spriteLinesToSerializedLines,\n  stringToSpriteLines,\n} from \"./DisplaySpriteSheetUtils.ts\";\nimport { simplifyCurves } from \"./PathUtils.ts\";\nimport { DisplayBoundingBox } from \"./DisplayCanvasHelper.ts\";\nimport RangeHelper from \"./RangeHelper.ts\";\nimport { kMeansColors, mapToClosestPaletteIndex } from \"./ColorUtils.ts\";\nimport { DefaultDisplayContextState } from \"./DisplayContextState.ts\";\nimport { DisplayManagerInterface } from \"./DisplayManagerInterface.ts\";\n\nconst _console = createConsole(\"SvgUtils\", { log: false });\n\ntype FillRule = \"nonzero\" | \"evenodd\";\ntype CanvasCommand =\n  | { type: \"lineWidth\"; lineWidth: number }\n  | { type: \"fillStyle\"; fillStyle: string }\n  | { type: \"strokeStyle\"; strokeStyle: string }\n  | { type: \"fillRule\"; fillRule: FillRule }\n  | { type: \"pathStart\" | \"pathEnd\" }\n  | { type: \"moveTo\" | \"lineTo\"; x: number; y: number }\n  | { type: \"line\"; x1: number; y1: number; x2: number; y2: number }\n  | { type: \"quadraticCurveTo\"; cpx: number; cpy: number; x: number; y: number }\n  | {\n      type: \"bezierCurveTo\";\n      cp1x: number;\n      cp1y: number;\n      cp2x: number;\n      cp2y: number;\n      x: number;\n      y: number;\n    }\n  | { type: \"closePath\"; checkIfHole?: boolean }\n  | {\n      type: \"rect\";\n      x: number;\n      y: number;\n      width: number;\n      height: number;\n      rotation: number;\n    }\n  | {\n      type: \"roundRect\";\n      x: number;\n      y: number;\n      width: number;\n      height: number;\n      r: number;\n      rotation: number;\n    }\n  | { type: \"circle\"; x: number; y: number; r: number }\n  | {\n      type: \"ellipse\";\n      x: number;\n      y: number;\n      rx: number;\n      ry: number;\n      rotation: number;\n    }\n  | {\n      type: \"text\";\n      text: string;\n      x: number;\n      y: number;\n      fontFamily: string;\n      fill: string;\n      fontSize: string;\n      fontStyle: string;\n      fontWeight: string;\n      stroke: string;\n      strokeDasharray: string;\n      strokeWidth: number;\n    };\n\ninterface Transform {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}\n\ninterface DecomposedTransform {\n  translation: { x: number; y: number };\n  rotation: number; // in radians\n  scale: { x: number; y: number };\n  skew: { x: number; y: number }; // skewX/Y in radians\n  isScaleUniform: boolean; // true if scaleX  scaleY\n}\n\n/** Fully decompose a 2D affine transform */\nfunction decomposeTransform(\n  t: Transform,\n  tolerance = 1e-6\n): DecomposedTransform {\n  // Translation\n  const tx = t.e;\n  const ty = t.f;\n\n  // Compute scale\n  const scaleX = Math.sqrt(t.a * t.a + t.b * t.b);\n  const scaleY = Math.sqrt(t.c * t.c + t.d * t.d);\n\n  // Compute rotation (from X-axis)\n  let rotation = 0;\n  if (scaleX !== 0) {\n    rotation = Math.atan2(t.b / scaleX, t.a / scaleX);\n  }\n\n  // Compute skew (skewX = angle between x and y axes)\n  let skewX = 0;\n  let skewY = 0;\n  if (scaleX !== 0 && scaleY !== 0) {\n    skewX = Math.atan2(t.a * t.c + t.b * t.d, scaleX * scaleX);\n    skewY = 0; // rarely needed, can be calculated similarly if desired\n  }\n\n  // Uniform scale check\n  const isScaleUniform = Math.abs(scaleX - scaleY) < tolerance;\n\n  return {\n    translation: { x: tx, y: ty },\n    rotation,\n    scale: { x: scaleX, y: scaleY },\n    skew: { x: skewX, y: skewY },\n    isScaleUniform,\n  };\n}\n\nconst identity: Transform = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };\n\nfunction multiply(t1: Transform, t2: Transform): Transform {\n  //_console.log(\"multiplying matrices\", t1, t2);\n  return {\n    a: t1.a * t2.a + t1.c * t2.b,\n    b: t1.b * t2.a + t1.d * t2.b,\n    c: t1.a * t2.c + t1.c * t2.d,\n    d: t1.b * t2.c + t1.d * t2.d,\n    e: t1.a * t2.e + t1.c * t2.f + t1.e,\n    f: t1.b * t2.e + t1.d * t2.f + t1.f,\n  };\n}\n\nfunction parseTransform(transformStr: string): Transform {\n  // Very basic parser, handles translate, scale, rotate, matrix\n  if (!transformStr) return identity;\n\n  const t = transformStr.match(/(\\w+)\\(([^)]+)\\)/g);\n  if (!t) return identity;\n\n  let matrix = structuredClone(identity);\n\n  for (const part of t) {\n    const [, fn, argsStr] = /(\\w+)\\(([^)]+)\\)/.exec(part)!;\n    const args = argsStr.split(/[\\s,]+/).map(Number);\n    let m: Transform = structuredClone(identity);\n\n    switch (fn) {\n      case \"translate\":\n        //_console.log(\"translate\", { x: args[0], y: args[1] });\n        m.e = args[0];\n        m.f = args[1] || 0;\n        break;\n      case \"scale\":\n        //_console.log(\"scale\", { x: args[0], y: args[1] });\n        m.a = args[0];\n        m.d = args[1] !== undefined ? args[1] : args[0];\n        break;\n      case \"rotate\":\n        const angle = (args[0] * Math.PI) / 180;\n        //_console.log(\"rotate\", { angle });\n        const cos = Math.cos(angle),\n          sin = Math.sin(angle);\n        if (args[1] !== undefined && args[2] !== undefined) {\n          const [cx, cy] = [args[1], args[2]];\n          m = {\n            a: cos,\n            b: sin,\n            c: -sin,\n            d: cos,\n            e: cx - cos * cx + sin * cy,\n            f: cy - sin * cx - cos * cy,\n          };\n        } else {\n          m.a = cos;\n          m.b = sin;\n          m.c = -sin;\n          m.d = cos;\n        }\n        break;\n      case \"matrix\":\n        //_console.log(\"matrix\", args);\n        [m.a, m.b, m.c, m.d, m.e, m.f] = args;\n        break;\n    }\n\n    matrix = multiply(matrix, m);\n  }\n\n  //_console.log(\"parsedTransform\", matrix);\n  return matrix;\n}\n\nfunction applyTransform(x: number, y: number, t: Transform) {\n  //_console.log(\"applying transform\", { x, y, t });\n  const value: Vector2 = {\n    x: t.a * x + t.c * y + t.e,\n    y: t.b * x + t.d * y + t.f,\n  };\n  //_console.log(\"transformed value\", value);\n  return value;\n}\nfunction parseStyle(styleStr: string | undefined): Record<string, string> {\n  const style: Record<string, string> = {};\n  if (!styleStr) return style;\n\n  styleStr.split(\";\").forEach((item) => {\n    const [key, value] = item.split(\":\").map((s) => s.trim());\n    if (key && value) style[key] = value;\n  });\n  return style;\n}\n\nconst circleBezierConstant = 0.5522847498307936;\nfunction svgJsonToCanvasCommands(svgJson: INode): CanvasCommand[] {\n  const commands: CanvasCommand[] = [];\n\n  function traverse(node: INode, parentTransform: Transform) {\n    //_console.log(\"traversing node\", node, parentTransform);\n    const transform = parseTransform(node.attributes.transform);\n    //_console.log(\"transform\", transform);\n    const nodeTransform = multiply(parentTransform, transform);\n    //_console.log(\"nodeTransform\", nodeTransform);\n\n    const { scale, translation, rotation, isScaleUniform } =\n      decomposeTransform(nodeTransform);\n    //_console.log({ scale, translation, rotation, isScaleUniform });\n    const uniformScale = scale.x;\n\n    // Handle styles\n    const style = parseStyle(node.attributes.style);\n    if (style.fill) commands.push({ type: \"fillStyle\", fillStyle: style.fill });\n    if (node.attributes.fill)\n      commands.push({ type: \"fillStyle\", fillStyle: node.attributes.fill });\n\n    // Stroke\n    if (style.stroke)\n      commands.push({ type: \"strokeStyle\", strokeStyle: style.stroke });\n    if (node.attributes.stroke)\n      commands.push({\n        type: \"strokeStyle\",\n        strokeStyle: node.attributes.stroke,\n      });\n\n    // Stroke width\n    let strokeWidth = 0;\n    if (style[\"stroke-width\"])\n      strokeWidth = parseLength(style[\"stroke-width\"]) ?? 0;\n    if (node.attributes[\"stroke-width\"])\n      strokeWidth = parseLength(node.attributes[\"stroke-width\"]) ?? strokeWidth;\n    if (strokeWidth)\n      commands.push({\n        type: \"lineWidth\",\n        lineWidth: strokeWidth * nodeTransform.a, // scale to pixels\n      });\n\n    // Fill rule\n    let fillRule = style[\"fill-rule\"];\n    if (node.attributes[\"fill-rule\"]) fillRule = node.attributes[\"fill-rule\"];\n    if (fillRule)\n      commands.push({ type: \"fillRule\", fillRule: fillRule as FillRule });\n\n    switch (node.name) {\n      case \"path\":\n        const d = node.attributes.d;\n        if (!d) break;\n        const pathData = new SVGPathData(d)\n          .toAbs()\n          .aToC()\n          .normalizeHVZ(false)\n          .normalizeST()\n          .removeCollinear()\n          .sanitize();\n        //_console.log(\"pathData\", d, pathData);\n        commands.push({ type: \"pathStart\" });\n        for (const cmd of pathData.commands) {\n          switch (cmd.type) {\n            case SVGPathData.MOVE_TO:\n              commands.push({ type: \"closePath\" });\n              const m = applyTransform(cmd.x!, cmd.y!, nodeTransform);\n              commands.push({ type: \"moveTo\", x: m.x, y: m.y });\n              break;\n\n            case SVGPathData.LINE_TO:\n              const l = applyTransform(cmd.x!, cmd.y!, nodeTransform);\n              commands.push({ type: \"lineTo\", x: l.x, y: l.y });\n              break;\n            case SVGPathData.CURVE_TO:\n              const c1 = applyTransform(cmd.x1!, cmd.y1!, nodeTransform);\n              const c2 = applyTransform(cmd.x2!, cmd.y2!, nodeTransform);\n              const ce = applyTransform(cmd.x!, cmd.y!, nodeTransform);\n              commands.push({\n                type: \"bezierCurveTo\",\n                cp1x: c1.x,\n                cp1y: c1.y,\n                cp2x: c2.x,\n                cp2y: c2.y,\n                x: ce.x,\n                y: ce.y,\n              });\n              break;\n            case SVGPathData.QUAD_TO:\n              const qcp = applyTransform(cmd.x1!, cmd.y1!, nodeTransform);\n              const qe = applyTransform(cmd.x!, cmd.y!, nodeTransform);\n              commands.push({\n                type: \"quadraticCurveTo\",\n                cpx: qcp.x,\n                cpy: qcp.y,\n                x: qe.x,\n                y: qe.y,\n              });\n              break;\n            case SVGPathData.CLOSE_PATH:\n              commands.push({ type: \"closePath\" });\n              break;\n            default:\n              _console.warn(\"uncaught command\", cmd);\n              break;\n          }\n        }\n        if (commands.at(-1)?.type != \"closePath\") {\n          commands.push({ type: \"closePath\" });\n        }\n        commands.push({ type: \"pathEnd\" });\n\n        break;\n\n      case \"rect\": {\n        const x = parseFloat(node.attributes.x || \"0\");\n        const y = parseFloat(node.attributes.y || \"0\");\n        const width = parseFloat(node.attributes.width || \"0\");\n        const height = parseFloat(node.attributes.height || \"0\");\n\n        let rx = parseFloat(node.attributes.rx || \"0\");\n        let ry = parseFloat(node.attributes.ry || \"0\");\n        if (!node.attributes.ry && rx) ry = rx;\n\n        rx = Math.min(rx, width / 2);\n        ry = Math.min(ry, height / 2);\n\n        if (rx === 0 && ry === 0) {\n          // sharp rect\n          if (isScaleUniform) {\n            const center = applyTransform(\n              x + width / 2,\n              y + height / 2,\n              nodeTransform\n            );\n            commands.push({\n              type: \"rect\",\n              x: center.x,\n              y: center.y,\n              width: width * uniformScale,\n              height: height * uniformScale,\n              rotation,\n            });\n          } else {\n            const tl = applyTransform(x, y, nodeTransform);\n            const tr = applyTransform(x + width, y, nodeTransform);\n            const br = applyTransform(x + width, y + height, nodeTransform);\n            const bl = applyTransform(x, y + height, nodeTransform);\n\n            commands.push({ type: \"moveTo\", x: tl.x, y: tl.y });\n            commands.push({ type: \"lineTo\", x: tr.x, y: tr.y });\n            commands.push({ type: \"lineTo\", x: br.x, y: br.y });\n            commands.push({ type: \"lineTo\", x: bl.x, y: bl.y });\n            commands.push({ type: \"closePath\" });\n          }\n        } else {\n          // rounded rect\n          if (rx == ry && isScaleUniform) {\n            const center = applyTransform(\n              x + width / 2,\n              y + height / 2,\n              nodeTransform\n            );\n            commands.push({\n              type: \"roundRect\",\n              x: center.x,\n              y: center.y,\n              width: width * uniformScale,\n              height: height * uniformScale,\n              rotation,\n              r: rx * uniformScale,\n            });\n          } else {\n            const ox = rx * circleBezierConstant; // x offset for control points\n            const oy = ry * circleBezierConstant; // y offset for control points\n\n            // Corners before transform\n            const p1 = { x: x + rx, y: y };\n            const p2 = { x: x + width - rx, y: y };\n            const p3 = { x: x + width, y: y + ry };\n            const p4 = { x: x + width, y: y + height - ry };\n            const p5 = { x: x + width - rx, y: y + height };\n            const p6 = { x: x + rx, y: y + height };\n            const p7 = { x: x, y: y + height - ry };\n            const p8 = { x: x, y: y + ry };\n\n            // Move to start\n            const start = applyTransform(p1.x, p1.y, nodeTransform);\n            commands.push({ type: \"moveTo\", x: start.x, y: start.y });\n\n            // Top edge + top-right corner\n            let cp1 = applyTransform(p2.x + ox, p2.y, nodeTransform);\n            let cp2 = applyTransform(p3.x, p3.y - oy, nodeTransform);\n            let end = applyTransform(p3.x, p3.y, nodeTransform);\n            commands.push({\n              type: \"lineTo\",\n              x: applyTransform(p2.x, p2.y, nodeTransform).x,\n              y: applyTransform(p2.x, p2.y, nodeTransform).y,\n            });\n            commands.push({\n              type: \"bezierCurveTo\",\n              cp1x: cp1.x,\n              cp1y: cp1.y,\n              cp2x: cp2.x,\n              cp2y: cp2.y,\n              x: end.x,\n              y: end.y,\n            });\n\n            // Right edge + bottom-right corner\n            cp1 = applyTransform(p4.x, p4.y + oy, nodeTransform);\n            cp2 = applyTransform(p5.x + ox, p5.y, nodeTransform);\n            end = applyTransform(p5.x, p5.y, nodeTransform);\n            commands.push({\n              type: \"lineTo\",\n              x: applyTransform(p4.x, p4.y, nodeTransform).x,\n              y: applyTransform(p4.x, p4.y, nodeTransform).y,\n            });\n            commands.push({\n              type: \"bezierCurveTo\",\n              cp1x: cp1.x,\n              cp1y: cp1.y,\n              cp2x: cp2.x,\n              cp2y: cp2.y,\n              x: end.x,\n              y: end.y,\n            });\n\n            // Bottom edge + bottom-left corner\n            cp1 = applyTransform(p6.x - ox, p6.y, nodeTransform);\n            cp2 = applyTransform(p7.x, p7.y + oy, nodeTransform);\n            end = applyTransform(p7.x, p7.y, nodeTransform);\n            commands.push({\n              type: \"lineTo\",\n              x: applyTransform(p6.x, p6.y, nodeTransform).x,\n              y: applyTransform(p6.x, p6.y, nodeTransform).y,\n            });\n            commands.push({\n              type: \"bezierCurveTo\",\n              cp1x: cp1.x,\n              cp1y: cp1.y,\n              cp2x: cp2.x,\n              cp2y: cp2.y,\n              x: end.x,\n              y: end.y,\n            });\n\n            // Left edge + top-left corner\n            cp1 = applyTransform(p8.x, p8.y - oy, nodeTransform);\n            cp2 = applyTransform(p1.x - ox, p1.y, nodeTransform);\n            end = applyTransform(p1.x, p1.y, nodeTransform);\n            commands.push({\n              type: \"lineTo\",\n              x: applyTransform(p8.x, p8.y, nodeTransform).x,\n              y: applyTransform(p8.x, p8.y, nodeTransform).y,\n            });\n            commands.push({\n              type: \"bezierCurveTo\",\n              cp1x: cp1.x,\n              cp1y: cp1.y,\n              cp2x: cp2.x,\n              cp2y: cp2.y,\n              x: end.x,\n              y: end.y,\n            });\n\n            commands.push({ type: \"closePath\" });\n          }\n        }\n        break;\n      }\n\n      case \"circle\": {\n        const cx = parseFloat(node.attributes.cx || \"0\");\n        const cy = parseFloat(node.attributes.cy || \"0\");\n        const r = parseFloat(node.attributes.r || \"0\");\n\n        if (r === 0) break;\n\n        if (isScaleUniform) {\n          //_console.log({ cx, cy, r, uniformScale });\n          const center = applyTransform(cx, cy, nodeTransform);\n          commands.push({\n            type: \"circle\",\n            x: center.x,\n            y: center.y,\n            r: r * uniformScale,\n          });\n        } else {\n          const ox = r * circleBezierConstant; // control point offset\n\n          // Points around the circle\n          const pTop = applyTransform(cx, cy - r, nodeTransform);\n          const pRight = applyTransform(cx + r, cy, nodeTransform);\n          const pBottom = applyTransform(cx, cy + r, nodeTransform);\n          const pLeft = applyTransform(cx - r, cy, nodeTransform);\n          //_console.log({ pTop, pRight, pBottom, pLeft });\n\n          const cpTopRight = applyTransform(cx + ox, cy - r, nodeTransform);\n          const cpRightTop = applyTransform(cx + r, cy - ox, nodeTransform);\n\n          const cpRightBottom = applyTransform(cx + r, cy + ox, nodeTransform);\n          const cpBottomRight = applyTransform(cx + ox, cy + r, nodeTransform);\n\n          const cpBottomLeft = applyTransform(cx - ox, cy + r, nodeTransform);\n          const cpLeftBottom = applyTransform(cx - r, cy + ox, nodeTransform);\n\n          const cpLeftTop = applyTransform(cx - r, cy - ox, nodeTransform);\n          const cpTopLeft = applyTransform(cx - ox, cy - r, nodeTransform);\n\n          commands.push({ type: \"moveTo\", x: pTop.x, y: pTop.y });\n\n          commands.push({\n            type: \"bezierCurveTo\",\n            cp1x: cpTopRight.x,\n            cp1y: cpTopRight.y,\n            cp2x: cpRightTop.x,\n            cp2y: cpRightTop.y,\n            x: pRight.x,\n            y: pRight.y,\n          });\n\n          commands.push({\n            type: \"bezierCurveTo\",\n            cp1x: cpRightBottom.x,\n            cp1y: cpRightBottom.y,\n            cp2x: cpBottomRight.x,\n            cp2y: cpBottomRight.y,\n            x: pBottom.x,\n            y: pBottom.y,\n          });\n\n          commands.push({\n            type: \"bezierCurveTo\",\n            cp1x: cpBottomLeft.x,\n            cp1y: cpBottomLeft.y,\n            cp2x: cpLeftBottom.x,\n            cp2y: cpLeftBottom.y,\n            x: pLeft.x,\n            y: pLeft.y,\n          });\n\n          commands.push({\n            type: \"bezierCurveTo\",\n            cp1x: cpLeftTop.x,\n            cp1y: cpLeftTop.y,\n            cp2x: cpTopLeft.x,\n            cp2y: cpTopLeft.y,\n            x: pTop.x,\n            y: pTop.y,\n          });\n\n          commands.push({ type: \"closePath\" });\n        }\n        break;\n      }\n\n      case \"ellipse\": {\n        const cx = parseFloat(node.attributes.cx || \"0\");\n        const cy = parseFloat(node.attributes.cy || \"0\");\n        const rx = parseFloat(node.attributes.rx || \"0\");\n        const ry = parseFloat(node.attributes.ry || \"0\");\n\n        if (rx === 0 || ry === 0) break;\n\n        if (isScaleUniform) {\n          const center = applyTransform(cx, cy, nodeTransform);\n          if (rx == ry) {\n            commands.push({\n              type: \"circle\",\n              x: center.x,\n              y: center.y,\n              r: rx * uniformScale,\n            });\n          } else {\n            commands.push({\n              type: \"ellipse\",\n              x: center.x,\n              y: center.y,\n              rx: rx * uniformScale,\n              ry: ry * uniformScale,\n              rotation,\n            });\n          }\n        } else {\n          const ox = rx * circleBezierConstant;\n          const oy = ry * circleBezierConstant;\n\n          // Key points\n          const pTop = applyTransform(cx, cy - ry, nodeTransform);\n          const pRight = applyTransform(cx + rx, cy, nodeTransform);\n          const pBottom = applyTransform(cx, cy + ry, nodeTransform);\n          const pLeft = applyTransform(cx - rx, cy, nodeTransform);\n\n          // Control points\n          const cpTopRight = applyTransform(cx + ox, cy - ry, nodeTransform);\n          const cpRightTop = applyTransform(cx + rx, cy - oy, nodeTransform);\n\n          const cpRightBottom = applyTransform(cx + rx, cy + oy, nodeTransform);\n          const cpBottomRight = applyTransform(cx + ox, cy + ry, nodeTransform);\n\n          const cpBottomLeft = applyTransform(cx - ox, cy + ry, nodeTransform);\n          const cpLeftBottom = applyTransform(cx - rx, cy + oy, nodeTransform);\n\n          const cpLeftTop = applyTransform(cx - rx, cy - oy, nodeTransform);\n          const cpTopLeft = applyTransform(cx - ox, cy - ry, nodeTransform);\n\n          // Draw ellipse using cubic Beziers\n          commands.push({ type: \"moveTo\", x: pTop.x, y: pTop.y });\n\n          commands.push({\n            type: \"bezierCurveTo\",\n            cp1x: cpTopRight.x,\n            cp1y: cpTopRight.y,\n            cp2x: cpRightTop.x,\n            cp2y: cpRightTop.y,\n            x: pRight.x,\n            y: pRight.y,\n          });\n\n          commands.push({\n            type: \"bezierCurveTo\",\n            cp1x: cpRightBottom.x,\n            cp1y: cpRightBottom.y,\n            cp2x: cpBottomRight.x,\n            cp2y: cpBottomRight.y,\n            x: pBottom.x,\n            y: pBottom.y,\n          });\n\n          commands.push({\n            type: \"bezierCurveTo\",\n            cp1x: cpBottomLeft.x,\n            cp1y: cpBottomLeft.y,\n            cp2x: cpLeftBottom.x,\n            cp2y: cpLeftBottom.y,\n            x: pLeft.x,\n            y: pLeft.y,\n          });\n\n          commands.push({\n            type: \"bezierCurveTo\",\n            cp1x: cpLeftTop.x,\n            cp1y: cpLeftTop.y,\n            cp2x: cpTopLeft.x,\n            cp2y: cpTopLeft.y,\n            x: pTop.x,\n            y: pTop.y,\n          });\n\n          commands.push({ type: \"closePath\" });\n        }\n        break;\n      }\n\n      case \"polyline\":\n      case \"polygon\": {\n        const pointsStr: string = node.attributes.points || \"\";\n        const points: { x: number; y: number }[] = pointsStr\n          .trim()\n          .split(/[\\s,]+/)\n          .map(Number)\n          .reduce<{ x?: number; y?: number }[]>((acc, val, idx) => {\n            if (idx % 2 === 0) acc.push({ x: val, y: 0 });\n            else acc[acc.length - 1].y = val;\n            return acc;\n          }, [])\n          .map((p) => ({ x: p.x!, y: p.y! }));\n\n        if (points.length === 0) break;\n\n        // Move to first point\n        const start = applyTransform(points[0].x, points[0].y, nodeTransform);\n        commands.push({ type: \"moveTo\", x: start.x, y: start.y });\n\n        // Draw lines to remaining points\n        for (let i = 1; i < points.length; i++) {\n          const p = applyTransform(points[i].x, points[i].y, nodeTransform);\n          commands.push({ type: \"lineTo\", x: p.x, y: p.y });\n        }\n\n        // close path, even if polyline\n        commands.push({ type: \"closePath\" });\n        break;\n      }\n\n      case \"line\": {\n        const x1 = parseFloat(node.attributes.x1 || \"0\");\n        const y1 = parseFloat(node.attributes.y1 || \"0\");\n        const x2 = parseFloat(node.attributes.x2 || \"0\");\n        const y2 = parseFloat(node.attributes.y2 || \"0\");\n\n        const p1 = applyTransform(x1, y1, nodeTransform);\n        const p2 = applyTransform(x2, y2, nodeTransform);\n\n        commands.push({ type: \"line\", x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y });\n\n        break;\n      }\n      case \"svg\":\n      case \"g\":\n        break;\n      case \"text\":\n        const text =\n          node.children.find((child) => child.type == \"text\")?.value ?? \"\";\n\n        const x = parseFloat(node.attributes.x || \"0\");\n        const y = parseFloat(node.attributes.y || \"0\");\n        const p = applyTransform(x, y, nodeTransform);\n        const strokeWidth = parseFloat(node.attributes[\"stroke-width\"] || \"0\");\n\n        // console.log(node.attributes);\n\n        const {\n          \"font-family\": fontFamily,\n          fill,\n          \"font-size\": fontSize,\n          \"font-style\": fontStyle,\n          \"font-weight\": fontWeight,\n          stroke,\n          \"stroke-dasharray\": strokeDasharray,\n        } = node.attributes;\n\n        //_console.log({ text }, node.attributes);\n        commands.push({\n          type: \"text\",\n          text,\n          x: p.x,\n          y: p.y,\n          fontFamily,\n          fill,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          stroke,\n          strokeDasharray,\n          strokeWidth,\n        });\n        break;\n      default:\n        _console.log(\"uncaught node\", node);\n        break;\n    }\n\n    if (node.children && node.name != \"text\") {\n      for (const child of node.children) traverse(child, nodeTransform);\n    }\n  }\n\n  traverse(svgJson, getSvgTransformToPixels(svgJson));\n  return commands;\n}\n\nfunction parseLength(\n  str: string | undefined,\n  relativeTo?: number\n): number | undefined {\n  if (!str) return undefined;\n  const match = /^([0-9.]+)([a-z%]*)$/.exec(str.trim());\n  if (!match) return undefined;\n\n  const value = parseFloat(match[1]);\n  const unit = match[2] || \"px\";\n\n  switch (unit) {\n    case \"px\":\n      return value;\n    case \"pt\":\n      return value * (96 / 72); // 1pt = 1/72in, 96dpi\n    case \"in\":\n      return value * 96; // 1in = 96px\n    case \"cm\":\n      return value * (96 / 2.54); // 1cm = 96/2.54 px\n    case \"mm\":\n      return value * (96 / 25.4); // 1mm = 96/25.4 px\n    case \"%\":\n      if (relativeTo === undefined) return undefined;\n      return (value / 100) * relativeTo;\n    case \"\":\n      return value; // unitless  px\n    default:\n      return value; // unknown unit  assume px\n  }\n}\n\nfunction getSvgJsonSize(svgJson: INode) {\n  const attrs = svgJson.attributes || {};\n  let width = parseLength(attrs.width);\n  let height = parseLength(attrs.height);\n\n  // Fallback to viewBox dimensions\n  if ((width == null || height == null) && attrs.viewBox) {\n    const [, , vbWidth, vbHeight] = attrs.viewBox\n      .split(/[\\s,]+/)\n      .map(parseFloat);\n    width ??= vbWidth;\n    height ??= vbHeight;\n  }\n\n  const size: DisplaySize = {\n    width: width ?? 300,\n    height: height ?? 150,\n  };\n  //_console.log(\"size\", size);\n  return size;\n}\n\nfunction getSvgJsonViewBox(svgJson: INode): DisplayBoundingBox {\n  const attrs = svgJson.attributes || {};\n  let x = 0,\n    y = 0,\n    width: number | undefined,\n    height: number | undefined;\n\n  if (attrs.viewBox) {\n    [x, y, width, height] = attrs.viewBox.split(/[\\s,]+/).map(parseFloat);\n  }\n\n  // Fallback to size if no viewBox\n  if (width == null || height == null) {\n    const size = getSvgJsonSize(svgJson);\n    width ??= size.width;\n    height ??= size.height;\n  }\n\n  const viewBox: DisplayBoundingBox = {\n    x,\n    y,\n    width: width!,\n    height: height!,\n  };\n  //_console.log(\"viewBox\", viewBox);\n  return viewBox;\n}\n\nfunction getSvgJsonBoundingBox(svgJson: INode): DisplayBoundingBox {\n  const { width, height } = getSvgJsonSize(svgJson);\n  const viewBox = getSvgJsonViewBox(svgJson);\n\n  if (width !== undefined && height !== undefined) {\n    return { x: 0, y: 0, width, height };\n  } else if (viewBox.width !== undefined && viewBox.height !== undefined) {\n    return viewBox;\n  } else {\n    return { x: 0, y: 0, width: 300, height: 150 };\n  }\n}\n\nfunction getSvgTransformToPixels(svgJson: INode): Transform {\n  const attrs = svgJson.attributes || {};\n  const { width, height } = getSvgJsonSize(svgJson); // in px\n  const viewBox = getSvgJsonViewBox(svgJson); // { x, y, width, height }\n\n  //_console.log({ width, height, viewBox });\n\n  // Base scales\n  let scaleX = width / viewBox.width;\n  let scaleY = height / viewBox.height;\n  let offsetX = 0;\n  let offsetY = 0;\n\n  // Handle preserveAspectRatio=\"xMidYMid meet\"\n  if (attrs.preserveAspectRatio?.includes(\"meet\")) {\n    const s = Math.min(scaleX, scaleY);\n    offsetX = (width - viewBox.width * s) / 2;\n    offsetY = (height - viewBox.height * s) / 2;\n    scaleX = scaleY = s;\n  }\n\n  // Return the affine transform matrix\n  return {\n    a: scaleX,\n    b: 0,\n    c: 0,\n    d: scaleY,\n    e: -viewBox.x * scaleX + offsetX,\n    f: -viewBox.y * scaleY + offsetY,\n  };\n}\n\nexport type ParseSvgOptions = {\n  fit?: boolean; // removes extra empty space around the shapes\n  width?: number; // scale output to this width\n  height?: number; // scale output to this height\n  aspectRatio?: number; // width / height, used if only one of width/height is provided\n  offsetX?: number;\n  offsetY?: number;\n  centered?: boolean;\n  displayManager?: DisplayManagerInterface;\n  includeText?: boolean;\n};\nconst defaultParseSvgOptions: ParseSvgOptions = {\n  fit: false,\n  centered: true,\n};\n\nfunction transformCanvasCommands(\n  canvasCommands: CanvasCommand[],\n  xCallback: (x: number) => number,\n  yCallback: (y: number) => number,\n  type: \"offset\" | \"scale\"\n): CanvasCommand[] {\n  return canvasCommands.map((command) => {\n    switch (command.type) {\n      case \"moveTo\":\n      case \"lineTo\": {\n        let { x, y } = command;\n        x = xCallback(x);\n        y = yCallback(y);\n        return { type: command.type, x, y };\n        break;\n      }\n      case \"quadraticCurveTo\": {\n        let { x, y, cpx, cpy } = command;\n        x = xCallback(x);\n        y = yCallback(y);\n        cpx = xCallback(cpx);\n        cpy = yCallback(cpy);\n        return { type: command.type, x, y, cpx, cpy };\n        break;\n      }\n      case \"bezierCurveTo\": {\n        let { x, y, cp1x, cp1y, cp2x, cp2y } = command;\n        x = xCallback(x);\n        y = yCallback(y);\n        cp1x = xCallback(cp1x);\n        cp1y = yCallback(cp1y);\n        cp2x = xCallback(cp2x);\n        cp2y = yCallback(cp2y);\n        return { type: command.type, x, y, cp1x, cp1y, cp2x, cp2y };\n        break;\n      }\n      case \"lineWidth\": {\n        if (type == \"scale\") {\n          let { lineWidth } = command;\n          lineWidth = xCallback(lineWidth);\n          return { type: command.type, lineWidth };\n        }\n        break;\n      }\n      case \"rect\":\n      case \"roundRect\": {\n        let { x, y, width, height, rotation } = command;\n        x = xCallback(x);\n        y = yCallback(y);\n        if (type == \"scale\") {\n          width = xCallback(width);\n          height = yCallback(height);\n        }\n        if (command.type == \"roundRect\") {\n          let { r } = command;\n          if (type == \"scale\") {\n            r = xCallback(r);\n          }\n          return { type: command.type, x, y, width, height, rotation, r };\n        }\n        return { type: command.type, x, y, width, height, rotation };\n        break;\n      }\n      case \"circle\":\n        {\n          let { x, y, r } = command;\n          x = xCallback(x);\n          y = yCallback(y);\n          if (type == \"scale\") {\n            r = xCallback(r);\n          }\n          return { type: command.type, x, y, r };\n        }\n        break;\n      case \"ellipse\":\n        {\n          let { x, y, rx, ry, rotation } = command;\n          x = xCallback(x);\n          y = yCallback(y);\n          if (type == \"scale\") {\n            rx = xCallback(rx);\n            ry = xCallback(ry);\n          }\n          return { type: command.type, x, y, rx, ry, rotation };\n        }\n        break;\n      default:\n        return command;\n    }\n    return command;\n  });\n}\nfunction forEachCanvasCommandVector2(\n  canvasCommands: CanvasCommand[],\n  vectorCallback: (x: number, y: number) => void\n) {\n  canvasCommands.forEach((command) => {\n    switch (command.type) {\n      case \"moveTo\":\n      case \"lineTo\":\n        {\n          let { x, y } = command;\n          vectorCallback(x, y);\n        }\n        break;\n      case \"quadraticCurveTo\":\n        {\n          let { x, y, cpx, cpy } = command;\n          vectorCallback(x, y);\n          vectorCallback(cpx, cpy);\n        }\n        break;\n      case \"bezierCurveTo\": {\n        let { x, y, cp1x, cp1y, cp2x, cp2y } = command;\n        vectorCallback(x, y);\n        vectorCallback(cp1x, cp1y);\n        vectorCallback(cp2x, cp2y);\n      }\n      default:\n        break;\n    }\n  });\n}\nfunction offsetCanvasCommands(\n  canvasCommands: CanvasCommand[],\n  offsetX = 0,\n  offsetY = 0\n) {\n  return transformCanvasCommands(\n    canvasCommands,\n    (x) => x + offsetX,\n    (y) => y + offsetY,\n    \"offset\"\n  );\n}\nfunction scaleCanvasCommands(\n  canvasCommands: CanvasCommand[],\n  scaleX: number,\n  scaleY: number\n) {\n  return transformCanvasCommands(\n    canvasCommands,\n    (x) => x * scaleX,\n    (y) => y * scaleY,\n    \"scale\"\n  );\n}\n\nfunction getBoundingBox(path: Vector2[]) {\n  let minX = Infinity,\n    minY = Infinity,\n    maxX = -Infinity,\n    maxY = -Infinity;\n  for (const p of path) {\n    if (p.x < minX) minX = p.x;\n    if (p.y < minY) minY = p.y;\n    if (p.x > maxX) maxX = p.x;\n    if (p.y > maxY) maxY = p.y;\n  }\n  return { minX, minY, maxX, maxY };\n}\n\nfunction bboxContains(\n  a: ReturnType<typeof getBoundingBox>,\n  b: ReturnType<typeof getBoundingBox>\n) {\n  return (\n    a.minX <= b.minX && a.minY <= b.minY && a.maxX >= b.maxX && a.maxY >= b.maxY\n  );\n}\n\nexport function classifySubpath(\n  subpath: Vector2[],\n  previous: { path: Vector2[]; isHole: boolean }[],\n  fillRule: FillRule\n): boolean {\n  const centroid = subpath.reduce(\n    (acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }),\n    { x: 0, y: 0 }\n  );\n  centroid.x /= subpath.length;\n  centroid.y /= subpath.length;\n\n  const subBBox = getBoundingBox(subpath);\n\n  let insideCount = 0;\n\n  for (const other of previous) {\n    const otherBBox = getBoundingBox(other.path);\n\n    // must be fully inside bbox\n    if (!bboxContains(otherBBox, subBBox)) continue;\n\n    // require *most* points to be inside\n    const insidePoints = subpath.filter((p) =>\n      pointInPolygon(p, other.path)\n    ).length;\n    const allInside = insidePoints > subpath.length * 0.8;\n    if (!allInside) continue;\n\n    insideCount++;\n  }\n\n  if (fillRule === \"evenodd\") {\n    return insideCount % 2 === 1; // odd count = hole\n  } else {\n    // non-zero winding rule\n    let winding = 0;\n    for (const other of previous) {\n      const otherBBox = getBoundingBox(other.path);\n      if (!bboxContains(otherBBox, subBBox)) continue;\n      if (pointInPolygon(centroid, other.path)) {\n        winding += contourArea(other.path) > 0 ? 1 : -1;\n      }\n    }\n    return winding !== 0; // nonzero = inside  hole\n  }\n}\n\nconst SVG_XMLNS = \"http://www.w3.org/2000/svg\";\n\nexport async function getSvgString(\n  input: string | SVGSVGElement\n): Promise<string> {\n  // Case 1: already an <svg> element\n  if (input instanceof SVGSVGElement) {\n    return ensureSvgXmlnsFromElement(input);\n  }\n\n  const trimmed = input.trim();\n\n  // Case 2: inline SVG markup\n  const svgText = trimmed.includes(\"<svg\") ? trimmed : await fetchSvg(trimmed);\n\n  return ensureSvgXmlns(svgText);\n}\n\nasync function fetchSvg(pathOrUrl: string): Promise<string> {\n  const res = await fetch(pathOrUrl);\n\n  if (!res.ok) {\n    throw new Error(`Failed to load SVG: ${pathOrUrl}`);\n  }\n\n  return await res.text();\n}\n\nfunction ensureSvgXmlns(svgText: string): string {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(svgText, \"image/svg+xml\");\n\n  const svg = doc.documentElement;\n\n  if (svg.tagName.toLowerCase() !== \"svg\") {\n    throw new Error(\"Invalid SVG\");\n  }\n\n  if (!svg.hasAttribute(\"xmlns\")) {\n    svg.setAttribute(\"xmlns\", SVG_XMLNS);\n  }\n\n  return new XMLSerializer().serializeToString(svg);\n}\n\nfunction ensureSvgXmlnsFromElement(svg: SVGSVGElement): string {\n  // Avoid mutating the original DOM node\n  const clone = svg.cloneNode(true) as SVGSVGElement;\n\n  if (!clone.hasAttribute(\"xmlns\")) {\n    clone.setAttribute(\"xmlns\", SVG_XMLNS);\n  }\n\n  return new XMLSerializer().serializeToString(clone);\n}\n\nexport async function svgToDisplayContextCommands(\n  svgString: string | SVGSVGElement,\n  numberOfColors: number,\n  paletteOffset: number,\n  colors?: string[],\n  options?: ParseSvgOptions\n) {\n  svgString = await getSvgString(svgString);\n\n  _console.assertWithError(\n    numberOfColors > 1,\n    \"numberOfColors must be greater than 1\"\n  );\n  options = { ...defaultParseSvgOptions, ...options };\n  _console.log(\"options\", options);\n\n  const svgJson = parseSync(svgString);\n\n  let canvasCommands = svgJsonToCanvasCommands(svgJson);\n  _console.log(\"canvasCommands\", canvasCommands);\n\n  const boundingBox = getSvgJsonBoundingBox(svgJson);\n  _console.log(\"boundingBox\", boundingBox);\n\n  let intrinsicWidth = boundingBox.width;\n  let intrinsicHeight = boundingBox.height;\n\n  _console.log({ intrinsicWidth, intrinsicHeight });\n\n  let scaleX = 1,\n    scaleY = 1;\n  if (options.width && options.height) {\n    scaleX = options.width / intrinsicWidth;\n    scaleY = options.height / intrinsicHeight;\n  } else if (options.width) {\n    scaleX = scaleY = options.width / intrinsicWidth;\n    if (options.aspectRatio) scaleY = scaleX / options.aspectRatio;\n  } else if (options.height) {\n    scaleX = scaleY = options.height / intrinsicHeight;\n    if (options.aspectRatio) scaleX = scaleY * options.aspectRatio;\n  }\n\n  _console.log({ scaleX, scaleY });\n\n  let width = Math.ceil(intrinsicWidth * scaleX);\n  let height = Math.ceil(intrinsicHeight * scaleY);\n\n  _console.log({ width, height });\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    canvasCommands = scaleCanvasCommands(canvasCommands, scaleX, scaleY);\n  }\n\n  if (options.fit) {\n    const rangeHelper = {\n      x: new RangeHelper(),\n      y: new RangeHelper(),\n    };\n    forEachCanvasCommandVector2(canvasCommands, (x, y) => {\n      rangeHelper.x.update(x);\n      rangeHelper.y.update(y);\n    });\n\n    // _console.log(\"xRange\", rangeHelper.x.min, rangeHelper.x.max);\n    // _console.log(\"yRange\", rangeHelper.y.min, rangeHelper.y.max);\n\n    width = rangeHelper.x.span;\n    height = rangeHelper.y.span;\n\n    const offsetX = -rangeHelper.x.min;\n    const offsetY = -rangeHelper.y.min;\n\n    canvasCommands = offsetCanvasCommands(canvasCommands, offsetX, offsetY);\n  }\n\n  if (options.offsetX || options.offsetY) {\n    const offsetX = options.offsetX || 0;\n    const offsetY = options.offsetY || 0;\n    canvasCommands = offsetCanvasCommands(canvasCommands, offsetX, offsetY);\n  }\n\n  if (options.centered) {\n    const offsetX = -width / 2;\n    const offsetY = -height / 2;\n    canvasCommands = offsetCanvasCommands(canvasCommands, offsetX, offsetY);\n  }\n\n  let svgColors: string[] = [];\n  canvasCommands.forEach((canvasCommand) => {\n    let color: string | undefined;\n    switch (canvasCommand.type) {\n      case \"fillStyle\":\n        color = canvasCommand.fillStyle;\n        break;\n      case \"strokeStyle\":\n        color = canvasCommand.strokeStyle;\n        break;\n      default:\n        return;\n    }\n    if (color && color != \"none\" && !svgColors.includes(color)) {\n      svgColors.push(color);\n    }\n  });\n  if (svgColors.length == 0) {\n    svgColors.push(\"black\");\n  }\n  if (svgColors.length == 1) {\n    svgColors.push(\"white\");\n  }\n  _console.log(\"colors\", svgColors);\n\n  const colorToIndex: Record<string, number> = {};\n  if (colors) {\n    colors = colors.slice(0, numberOfColors);\n    const mapping = mapToClosestPaletteIndex(svgColors, colors.slice(1));\n    _console.log(\"mapping\", mapping, colors);\n    svgColors.forEach((color) => {\n      colorToIndex[color] = mapping[color] + 1;\n    });\n  } else {\n    // FIX - annoying when an svg has a black fill\n    const { palette, mapping } = kMeansColors(svgColors, numberOfColors);\n    _console.log(\"mapping\", mapping);\n    _console.log(\"palette\", palette);\n\n    svgColors.forEach((color) => {\n      colorToIndex[color] = mapping[color];\n    });\n    colors = palette;\n  }\n  _console.log(\"colorToIndex\", colorToIndex);\n\n  _console.log(\"transformed canvasCommands\", canvasCommands);\n\n  let curves: DisplayBezierCurve[] = [];\n  let startPoint: Vector2 = { x: 0, y: 0 };\n  let fillRule: FillRule = \"nonzero\";\n  let fillStyle: string | undefined;\n  let strokeStyle = \"none\";\n  let lineWidth = 1;\n  let segmentRadius = 1;\n  let wasHole = false;\n  let ignoreFill = false;\n  let ignoreLine = true;\n  let fillColorIndex = 1;\n  let lineColorIndex = 1;\n  const getFillColorIndex = () => fillColorIndex + paletteOffset;\n  const getLineColorIndex = () => lineColorIndex + paletteOffset;\n  let isDrawingPath = false;\n  const parsedPaths: { path: Vector2[]; isHole: boolean }[] = [];\n\n  let displayCommands: DisplayContextCommand[] = [];\n  displayCommands.push({\n    type: \"selectFillColor\",\n    fillColorIndex: getFillColorIndex(),\n  });\n  displayCommands.push({\n    type: \"selectLineColor\",\n    lineColorIndex: getLineColorIndex(),\n  });\n  displayCommands.push({ type: \"setIgnoreLine\", ignoreLine: true });\n  displayCommands.push({ type: \"setLineWidth\", lineWidth });\n  displayCommands.push({\n    type: \"setSegmentRadius\",\n    segmentRadius,\n  });\n\n  canvasCommands.forEach((canvasCommand) => {\n    switch (canvasCommand.type) {\n      case \"moveTo\":\n        {\n          const { x, y } = canvasCommand;\n          startPoint.x = x;\n          startPoint.y = y;\n        }\n        break;\n      case \"lineTo\":\n        {\n          const { x, y } = canvasCommand;\n          const controlPoints: Vector2[] = [{ x, y }];\n          if (curves.length === 0) {\n            controlPoints.unshift({ ...startPoint });\n          }\n          curves.push({ type: \"segment\", controlPoints });\n        }\n        break;\n      case \"quadraticCurveTo\":\n        {\n          const { x, y, cpx, cpy } = canvasCommand;\n          const controlPoints: Vector2[] = [\n            { x: cpx, y: cpy },\n            { x, y },\n          ];\n          if (curves.length === 0) {\n            controlPoints.unshift({ ...startPoint });\n          }\n          curves.push({ type: \"quadratic\", controlPoints });\n        }\n        break;\n      case \"bezierCurveTo\":\n        {\n          const { x, y, cp1x, cp1y, cp2x, cp2y } = canvasCommand;\n          const controlPoints: Vector2[] = [\n            { x: cp1x, y: cp1y },\n            { x: cp2x, y: cp2y },\n            { x, y },\n          ];\n          if (curves.length === 0) {\n            controlPoints.unshift({ ...startPoint });\n          }\n          curves.push({ type: \"cubic\", controlPoints });\n        }\n        break;\n      case \"closePath\":\n        if (curves.length === 0) break;\n\n        curves = simplifyCurves(curves);\n\n        // Flatten all control points\n        const controlPoints = curves.flatMap((c) => c.controlPoints);\n        controlPoints.forEach((controlPoint) => {\n          controlPoint.x = Math.round(controlPoint.x);\n          controlPoint.y = Math.round(controlPoint.y);\n        });\n\n        if (isDrawingPath) {\n          const isHole = classifySubpath(controlPoints, parsedPaths, fillRule);\n          parsedPaths.push({ path: controlPoints, isHole });\n\n          // _console.log({\n          //   pathIndex: parsedPaths.length - 1,\n          //   isHole,\n          //   fillStyle,\n          //   strokeStyle,\n          //   fillRule,\n          //   lineWidth,\n          // });\n\n          if (isHole != wasHole) {\n            wasHole = isHole;\n            if (isHole) {\n              displayCommands.push({\n                type: \"selectFillColor\",\n                fillColorIndex: 0,\n              });\n            } else {\n              displayCommands.push({\n                type: \"selectFillColor\",\n                fillColorIndex: getFillColorIndex(),\n              });\n            }\n          }\n        }\n\n        if (ignoreFill) {\n          displayCommands.push({\n            type: \"setLineWidth\",\n            lineWidth: 0,\n          });\n          displayCommands.push({\n            type: \"selectFillColor\",\n            fillColorIndex: getLineColorIndex(),\n          });\n          displayCommands.push({\n            type: \"setIgnoreFill\",\n            ignoreFill: false,\n          });\n        }\n\n        const isSegments = curves.every((c) => c.type === \"segment\");\n        if (isSegments) {\n          if (ignoreFill) {\n            displayCommands.push({\n              type: \"drawSegments\",\n              points: controlPoints,\n            });\n          } else {\n            displayCommands.push({\n              type: \"drawPolygon\",\n              points: controlPoints,\n            });\n          }\n        } else {\n          if (ignoreFill) {\n            displayCommands.push({ type: \"drawPath\", curves });\n          } else {\n            displayCommands.push({ type: \"drawClosedPath\", curves });\n          }\n        }\n\n        if (ignoreFill) {\n          displayCommands.push({\n            type: \"setLineWidth\",\n            lineWidth,\n          });\n          displayCommands.push({\n            type: \"selectFillColor\",\n            fillColorIndex: getFillColorIndex(),\n          });\n          displayCommands.push({\n            type: \"setIgnoreFill\",\n            ignoreFill,\n          });\n        }\n\n        // Reset curves\n        curves = [];\n        break;\n      case \"pathStart\":\n        parsedPaths.length = 0;\n        if (wasHole) {\n          displayCommands.push({ type: \"selectFillColor\", fillColorIndex });\n        }\n        wasHole = false;\n        isDrawingPath = true;\n        break;\n      case \"pathEnd\":\n        isDrawingPath = false;\n        break;\n      case \"line\":\n        if (strokeStyle != \"none\") {\n          displayCommands.push({\n            type: \"setLineWidth\",\n            lineWidth: 0,\n          });\n          displayCommands.push({\n            type: \"selectFillColor\",\n            fillColorIndex: getLineColorIndex(),\n          });\n          displayCommands.push({\n            type: \"setIgnoreFill\",\n            ignoreFill: false,\n          });\n\n          const { x1, y1, x2, y2 } = canvasCommand;\n          displayCommands.push({\n            type: \"drawSegment\",\n            startX: x1,\n            startY: y1,\n            endX: x2,\n            endY: y2,\n          });\n\n          displayCommands.push({\n            type: \"setLineWidth\",\n            lineWidth,\n          });\n          displayCommands.push({\n            type: \"selectFillColor\",\n            fillColorIndex: getFillColorIndex(),\n          });\n          displayCommands.push({\n            type: \"setIgnoreFill\",\n            ignoreFill,\n          });\n        }\n\n        break;\n      case \"fillStyle\":\n        //_console.log(\"fillStyle\", canvasCommand.fillStyle);\n        const newIgnoreFill = canvasCommand.fillStyle == \"none\";\n        if (\n          fillStyle != canvasCommand.fillStyle ||\n          ignoreFill != newIgnoreFill\n        ) {\n          if (ignoreFill != newIgnoreFill) {\n            ignoreFill = newIgnoreFill;\n            //_console.log({ ignoreFill });\n            displayCommands.push({ type: \"setIgnoreFill\", ignoreFill });\n          }\n          if (!ignoreFill) {\n            if (fillStyle != canvasCommand.fillStyle) {\n              fillStyle = canvasCommand.fillStyle;\n              if (fillColorIndex != colorToIndex[fillStyle]) {\n                _console.log({ fillColorIndex });\n                fillColorIndex = colorToIndex[fillStyle];\n                displayCommands.push({\n                  type: \"selectFillColor\",\n                  fillColorIndex: getFillColorIndex(),\n                });\n              }\n            }\n          }\n        }\n        break;\n      case \"strokeStyle\":\n        //_console.log(\"strokeStyle\", canvasCommand.strokeStyle);\n        const newIgnoreLine = canvasCommand.strokeStyle == \"none\";\n        if (\n          strokeStyle != canvasCommand.strokeStyle ||\n          ignoreLine != newIgnoreLine\n        ) {\n          if (ignoreLine != newIgnoreLine) {\n            ignoreLine = newIgnoreLine;\n            //_console.log({ ignoreLine });\n            displayCommands.push({ type: \"setIgnoreLine\", ignoreLine });\n          }\n          if (!ignoreLine) {\n            if (strokeStyle != canvasCommand.strokeStyle) {\n              strokeStyle = canvasCommand.strokeStyle;\n              if (lineColorIndex != colorToIndex[strokeStyle]) {\n                //_console.log({ lineColorIndex });\n                lineColorIndex = colorToIndex[strokeStyle];\n                displayCommands.push({\n                  type: \"selectLineColor\",\n                  lineColorIndex: getLineColorIndex(),\n                });\n              }\n            }\n          }\n        }\n        break;\n      case \"lineWidth\":\n        if (lineWidth != canvasCommand.lineWidth) {\n          lineWidth = canvasCommand.lineWidth;\n          lineWidth = Math.ceil(lineWidth);\n          displayCommands.push({ type: \"setLineWidth\", lineWidth });\n          segmentRadius = lineWidth / 2;\n          segmentRadius = Math.ceil(segmentRadius);\n          displayCommands.push({\n            type: \"setSegmentRadius\",\n            segmentRadius,\n          });\n        }\n        break;\n      case \"fillRule\":\n        fillRule = canvasCommand.fillRule;\n        break;\n      case \"rect\":\n        {\n          let { x, y, width, height, rotation } = canvasCommand;\n          x = Math.round(x);\n          y = Math.round(y);\n          width = Math.round(width);\n          height = Math.round(height);\n          rotation = Math.round(rotation);\n          displayCommands.push({\n            type: \"setRotation\",\n            rotation,\n            isRadians: true,\n          });\n          displayCommands.push({\n            type: \"drawRect\",\n            offsetX: x,\n            offsetY: y,\n            width: width,\n            height: height,\n          });\n        }\n        break;\n      case \"roundRect\":\n        {\n          let { x, y, width, height, rotation, r } = canvasCommand;\n          x = Math.round(x);\n          y = Math.round(y);\n          width = Math.round(width);\n          height = Math.round(height);\n          rotation = Math.round(rotation);\n          r = Math.round(r);\n          displayCommands.push({\n            type: \"setRotation\",\n            rotation,\n            isRadians: true,\n          });\n          displayCommands.push({\n            type: \"drawRoundRect\",\n            offsetX: x,\n            offsetY: y,\n            width: width,\n            height: height,\n            borderRadius: r,\n          });\n        }\n        break;\n      case \"circle\":\n        {\n          let { x, y, r } = canvasCommand;\n          x = Math.round(x);\n          y = Math.round(y);\n          r = Math.round(r);\n          displayCommands.push({\n            type: \"drawCircle\",\n            offsetX: x,\n            offsetY: y,\n            radius: r,\n          });\n        }\n        break;\n      case \"ellipse\":\n        {\n          let { x, y, rx, ry, rotation } = canvasCommand;\n          x = Math.round(x);\n          y = Math.round(y);\n          width = Math.round(width);\n          height = Math.round(height);\n          rotation = Math.round(rotation);\n          rx = Math.round(rx);\n          ry = Math.round(ry);\n          displayCommands.push({\n            type: \"setRotation\",\n            rotation,\n            isRadians: true,\n          });\n          displayCommands.push({\n            type: \"drawEllipse\",\n            offsetX: x,\n            offsetY: y,\n            radiusX: rx,\n            radiusY: ry,\n          });\n        }\n        break;\n      case \"text\":\n        if (options.includeText && options.displayManager) {\n          const { displayManager } = options;\n          let { x, y, strokeWidth } = canvasCommand;\n          const { text, fontSize, fill, stroke } = canvasCommand;\n          x = Math.round(x);\n          y = Math.round(y) - 5; // baseline fix\n          strokeWidth = Math.round(strokeWidth);\n\n          //_console.log({ text, x, y, fontSize, fill, stroke, strokeWidth });\n\n          displayCommands.push({\n            type: \"setSpritesLineHeight\",\n            spritesLineHeight: displayManager.contextState.spritesLineHeight,\n          });\n          displayCommands.push({\n            type: \"setSpriteScaleX\",\n            spriteScaleX: scaleX,\n          });\n          displayCommands.push({\n            type: \"setSpriteScaleY\",\n            spriteScaleY: scaleY,\n          });\n          displayCommands.push({\n            type: \"setHorizontalAlignment\",\n            horizontalAlignment: \"start\",\n          });\n          displayCommands.push({\n            type: \"setVerticalAlignment\",\n            verticalAlignment: \"center\",\n          });\n          const spriteLines = stringToSpriteLines(\n            text,\n            displayManager.spriteSheets,\n            DefaultDisplayContextState\n          );\n          displayCommands.push({\n            type: \"drawSprites\",\n            offsetX: Math.round(x - width / 2),\n            offsetY: Math.round(y - height / 2),\n            spriteSerializedLines: spriteLinesToSerializedLines(\n              displayManager,\n              spriteLines\n            ),\n          });\n          // trimContextCommands doesn't treat resetAlignment and setHorizontalAlignment/setVerticalAlignment as similar (yet)\n          if (true) {\n            displayCommands.push({\n              type: \"setHorizontalAlignment\",\n              horizontalAlignment: \"center\",\n            });\n            displayCommands.push({\n              type: \"setVerticalAlignment\",\n              verticalAlignment: \"center\",\n            });\n          } else {\n            displayCommands.push({\n              type: \"resetAlignment\",\n            });\n          }\n          if (true) {\n            displayCommands.push({\n              type: \"setSpriteScaleX\",\n              spriteScaleX: 1,\n            });\n            displayCommands.push({\n              type: \"setSpriteScaleY\",\n              spriteScaleY: 1,\n            });\n          } else {\n            displayCommands.push({\n              type: \"resetSpriteScale\",\n            });\n          }\n        }\n        break;\n      default:\n        _console.warn(\"uncaught canvasCommand\", canvasCommand);\n        break;\n    }\n  });\n\n  displayCommands = trimContextCommands(displayCommands);\n\n  _console.log(\"displayCommands\", displayCommands);\n  _console.log(\"colors\", colors);\n  return { commands: displayCommands, colors, width, height };\n}\n\nexport async function svgToSprite(\n  svgString: string | SVGSVGElement,\n  spriteName: string,\n  numberOfColors: number,\n  paletteName: string,\n  overridePalette: boolean,\n  spriteSheet: DisplaySpriteSheet,\n  paletteOffset = 0,\n  options?: ParseSvgOptions\n) {\n  options = { ...defaultParseSvgOptions, ...options };\n  _console.log(\"options\", options, { overridePalette });\n\n  let palette = spriteSheet.palettes?.find(\n    (palette) => palette.name == paletteName\n  );\n  if (!palette) {\n    palette = {\n      name: paletteName,\n      numberOfColors,\n      colors: new Array(numberOfColors).fill(\"white\"),\n    };\n    palette.colors[0] = \"black\";\n    spriteSheet.palettes = spriteSheet.palettes || [];\n    spriteSheet.palettes?.push(palette);\n  }\n  _console.log(\"pallete\", palette);\n\n  const { commands, colors, width, height } = await svgToDisplayContextCommands(\n    svgString,\n    numberOfColors,\n    paletteOffset,\n    !overridePalette ? palette.colors : undefined,\n    options\n  );\n\n  const sprite: DisplaySprite = {\n    name: spriteName,\n    width,\n    height,\n    paletteSwaps: [],\n    commands,\n  };\n  if (overridePalette) {\n    _console.log(\"overriding palette\", colors);\n    colors.forEach((color, index) => {\n      palette.colors[index + paletteOffset] = color;\n    });\n  }\n\n  const spriteIndex = spriteSheet.sprites.findIndex(\n    (sprite) => sprite.name == spriteName\n  );\n  if (spriteIndex == -1) {\n    spriteSheet.sprites.push(sprite);\n  } else {\n    _console.log(`overwriting spriteInde ${spriteIndex}`);\n    spriteSheet.sprites[spriteIndex] = sprite;\n  }\n\n  return sprite;\n}\n\nexport async function svgToSpriteSheet(\n  svgString: string,\n  spriteSheetName: string,\n  spriteName: string,\n  numberOfColors: number,\n  paletteName: string,\n  options?: ParseSvgOptions\n) {\n  const spriteSheet: DisplaySpriteSheet = {\n    name: spriteSheetName,\n    palettes: [],\n    paletteSwaps: [],\n    sprites: [],\n  };\n\n  await svgToSprite(\n    svgString,\n    spriteName,\n    numberOfColors,\n    paletteName,\n    false,\n    spriteSheet,\n    0,\n    options\n  );\n\n  return spriteSheet;\n}\n\nexport function getSvgStringFromDataUrl(string: string) {\n  if (!string.startsWith(\"data:image/svg+xml\"))\n    throw new Error(\"Not a data URL\");\n\n  // Data URL might be base64 or URI encoded\n  const data = string.split(\",\")[1];\n  if (string.includes(\"base64\")) {\n    return atob(data);\n  } else {\n    return decodeURIComponent(data);\n  }\n}\n\nexport function isValidSVG(svgString: string) {\n  if (typeof svgString !== \"string\") return false;\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(svgString, \"image/svg+xml\");\n\n  // Different browsers may put parser errors in different places; check several ways:\n  if (\n    doc.querySelector(\"parsererror\") ||\n    doc.getElementsByTagName(\"parsererror\").length > 0\n  ) {\n    return false;\n  }\n\n  const root = doc.documentElement;\n  return !!root && root.nodeName.toLowerCase() === \"svg\";\n}\n","import { removeRedundancies } from \"./ObjectUtils.ts\";\n\nexport function spacesToPascalCase(string: string) {\n  return string\n    .replace(/(?:^\\w|\\b\\w)/g, function (match) {\n      return match.toUpperCase();\n    })\n    .replace(/\\s+/g, \"\");\n}\n\nexport function capitalizeFirstCharacter(string: string) {\n  return string[0].toUpperCase() + string.slice(1);\n}\n\nexport function removeRedundantCharacters(string: string) {\n  return removeRedundancies(Array.from(string)).join(\"\");\n}\n\nexport function removeSubstrings(string: string, substrings: string[]): string {\n  let result = string;\n  for (const sub of substrings) {\n    result = result.split(sub).join(\"\");\n  }\n  return result;\n}\n","import {\n  DisplayBezierCurve,\n  DisplayBitmap,\n  DisplaySize,\n} from \"../DisplayManager.ts\";\nimport { concatenateArrayBuffers } from \"./ArrayBufferUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { quantizeCanvas } from \"./DisplayBitmapUtils.ts\";\nimport {\n  DisplayContextCommand,\n  serializeContextCommands,\n} from \"./DisplayContextCommand.ts\";\nimport { DisplayManagerInterface } from \"./DisplayManagerInterface.ts\";\nimport opentype, { Glyph, Font } from \"opentype.js\";\nimport { decompress } from \"woff2-encoder\";\nimport RangeHelper from \"./RangeHelper.ts\";\nimport { Vector2 } from \"./MathUtils.ts\";\nimport { simplifyCurves } from \"./PathUtils.ts\";\nimport {\n  DisplayContextState,\n  isDirectionHorizontal,\n} from \"./DisplayContextState.ts\";\nimport { classifySubpath } from \"./SvgUtils.ts\";\nimport { removeRedundantCharacters, removeSubstrings } from \"./stringUtils.ts\";\n\nconst _console = createConsole(\"DisplaySpriteSheetUtils\", { log: false });\n\nexport type DisplaySpriteSubLine = {\n  spriteSheetName: string;\n  spriteNames: string[];\n};\nexport type DisplaySpriteLine = DisplaySpriteSubLine[];\nexport type DisplaySpriteLines = DisplaySpriteLine[];\n\nexport type DisplaySpriteSerializedSubLine = {\n  spriteSheetIndex: number;\n  spriteIndices: number[];\n  use2Bytes: boolean;\n};\nexport type DisplaySpriteSerializedLine = DisplaySpriteSerializedSubLine[];\nexport type DisplaySpriteSerializedLines = DisplaySpriteSerializedLine[];\n\nexport type DisplaySpritePaletteSwap = {\n  name: string;\n  numberOfColors: number;\n  spriteColorIndices: number[];\n};\nexport type DisplaySprite = {\n  name: string;\n  width: number;\n  height: number;\n  paletteSwaps?: DisplaySpritePaletteSwap[];\n  commands: DisplayContextCommand[];\n};\nexport type DisplaySpriteSheetPaletteSwap = {\n  name: string;\n  numberOfColors: number;\n  spriteColorIndices: number[];\n};\nexport type DisplaySpriteSheetPalette = {\n  name: string;\n  numberOfColors: number;\n  colors: string[];\n  opacities?: number[];\n};\nexport type DisplaySpriteSheet = {\n  name: string;\n  palettes?: DisplaySpriteSheetPalette[];\n  paletteSwaps?: DisplaySpriteSheetPaletteSwap[];\n  sprites: DisplaySprite[];\n};\n\nexport const spriteHeaderLength = 3 * 2; // width, height, commandsLength\nexport function calculateSpriteSheetHeaderLength(numberOfSprites: number) {\n  // numberOfSprites, spriteOffsets, spriteHeader\n  return 2 + numberOfSprites * 2 + numberOfSprites * spriteHeaderLength;\n}\nexport function getCurvesPoints(curves: DisplayBezierCurve[]) {\n  const curvePoints: Vector2[] = [];\n  curves.forEach((curve, index) => {\n    if (index == 0) {\n      curvePoints.push(curve.controlPoints[0]);\n    }\n    curvePoints.push(curve.controlPoints.at(-1)!);\n  });\n  return curvePoints;\n}\nexport function serializeSpriteSheet(\n  displayManager: DisplayManagerInterface,\n  spriteSheet: DisplaySpriteSheet\n) {\n  const { name, sprites } = spriteSheet;\n  _console.log(`serializing ${name} spriteSheet`, spriteSheet);\n\n  const numberOfSprites = sprites.length;\n  const numberOfSpritesDataView = new DataView(new ArrayBuffer(2));\n  numberOfSpritesDataView.setUint16(0, numberOfSprites, true);\n\n  const spritePayloads = sprites.map((sprite, index) => {\n    const commandsData = serializeContextCommands(\n      displayManager,\n      sprite.commands\n    );\n    const dataView = new DataView(new ArrayBuffer(spriteHeaderLength));\n    dataView.setUint16(0, sprite.width, true);\n    dataView.setUint16(2, sprite.height, true);\n    dataView.setUint16(4, commandsData.byteLength, true);\n    const serializedSprite = concatenateArrayBuffers(dataView, commandsData);\n    _console.log(\"serializedSprite\", sprite, serializedSprite);\n    return serializedSprite;\n  });\n  const spriteOffsetsDataView = new DataView(\n    new ArrayBuffer(sprites.length * 2)\n  );\n  let offset =\n    numberOfSpritesDataView.byteLength + spriteOffsetsDataView.byteLength;\n  spritePayloads.forEach((spritePayload, index) => {\n    //_console.log(\"spritePayloads\", index, offset, spritePayload);\n    spriteOffsetsDataView.setUint16(index * 2, offset, true);\n    offset += spritePayload.byteLength;\n  });\n\n  // [numberOfSprites, ...spriteOffsets, ...[width, height, commands]]\n  const serializedSpriteSheet = concatenateArrayBuffers(\n    numberOfSpritesDataView,\n    spriteOffsetsDataView,\n    spritePayloads\n  );\n  _console.log(\"serializedSpriteSheet\", serializedSpriteSheet);\n\n  return serializedSpriteSheet;\n}\n\nexport function parseSpriteSheet(dataView: DataView<ArrayBuffer>) {\n  // FILL\n}\n\nexport type FontToSpriteSheetOptions = {\n  stroke?: boolean;\n  strokeWidth?: number;\n  unicodeOnly?: boolean;\n  englishOnly?: boolean;\n  usePath?: boolean;\n  script?: string;\n  string?: string;\n  minSpriteY?: number;\n  maxSpriteY?: number;\n  maxSpriteHeight?: number;\n  overrideMaxSpriteHeight?: boolean;\n};\nexport const defaultFontToSpriteSheetOptions: FontToSpriteSheetOptions = {\n  stroke: false,\n  strokeWidth: 1,\n  unicodeOnly: true,\n  englishOnly: true,\n  usePath: false,\n  overrideMaxSpriteHeight: true,\n};\n\nfunction isWoff2(arrayBuffer: ArrayBuffer) {\n  if (arrayBuffer.byteLength < 4) return false;\n\n  const header = new Uint8Array(arrayBuffer, 0, 4);\n  return (\n    header[0] === 0x77 && // 'w'\n    header[1] === 0x4f && // 'O'\n    header[2] === 0x46 && // 'F'\n    header[3] === 0x32 // '2'\n  );\n}\nexport async function parseFont(arrayBuffer: ArrayBuffer) {\n  if (isWoff2(arrayBuffer)) {\n    const result = await decompress(arrayBuffer);\n    // @ts-expect-error\n    arrayBuffer = result.buffer;\n  }\n  const font = opentype.parse(arrayBuffer);\n  //_console.log(\"font\", font);\n  return font;\n}\n\nexport function getFontUnicodeRange(font: Font) {\n  const rangeHelper = new RangeHelper();\n\n  for (let i = 0; i < font.glyphs.length; i++) {\n    const glyph = font.glyphs.get(i);\n    if (!glyph.unicodes || glyph.unicodes.length === 0) continue;\n\n    glyph.unicodes\n      .filter((unicode) => {\n        const char = String.fromCodePoint(unicode);\n        // Keep only letters (any language)\n        return /\\p{Letter}/u.test(char);\n      })\n      .forEach((unicode) => rangeHelper.update(unicode));\n  }\n\n  //_console.log(\"range\", rangeHelper.range);\n  return rangeHelper.span > 0 ? rangeHelper.range : undefined;\n}\n\nexport const englishRegex = /^[A-Za-z0-9 !\"#$%&'()*+,\\-./:;?@[\\]^_`{|}~\\\\]+$/;\n\nexport function contourArea(points: Vector2[]) {\n  let area = 0;\n  for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\n    area += (points[j].x - points[i].x) * (points[j].y + points[i].y);\n  }\n  return area;\n}\n\nexport function getFontMetrics(\n  font: Font | Font[],\n  fontSize: number,\n  options?: FontToSpriteSheetOptions\n) {\n  _console.assertTypeWithError(fontSize, \"number\");\n\n  options = options\n    ? { ...defaultFontToSpriteSheetOptions, ...options }\n    : defaultFontToSpriteSheetOptions;\n\n  const fonts = Array.isArray(font) ? font : [font];\n\n  let minSpriteY = Infinity;\n  let maxSpriteY = -Infinity;\n\n  const strokeWidth = options.stroke ? options.strokeWidth || 1 : 0;\n\n  let string = options.string;\n  if (string) {\n    string = removeRedundantCharacters(string);\n    _console.log(\"filtered string\", string);\n  }\n\n  for (let font of fonts) {\n    const fontScale = (1 / font.unitsPerEm) * fontSize;\n\n    const glyphs: Glyph[] = [];\n    let filteredGlyphs: Glyph[] | undefined;\n    if (string != undefined) {\n      filteredGlyphs = font\n        .stringToGlyphs(string)\n        .filter((glyph) => glyph.unicode != undefined);\n      string = removeSubstrings(\n        string,\n        filteredGlyphs.map((glyph) => String.fromCharCode(glyph.unicode!))\n      );\n    }\n\n    for (let index = 0; index < font.glyphs.length; index++) {\n      const glyph = font.glyphs.get(index);\n      const hasUnicode = glyph.unicode != undefined;\n      if (hasUnicode) {\n        //_console.log(String.fromCharCode(glyph.unicode!), glyph);\n      } else {\n        //_console.log(\"no unicode\", glyph);\n      }\n\n      if (filteredGlyphs) {\n        if (!filteredGlyphs.includes(glyph)) {\n          continue;\n        }\n      }\n\n      if (options.unicodeOnly || options.englishOnly) {\n        if (!hasUnicode) {\n          continue;\n        }\n      }\n      if (options.script && hasUnicode) {\n        const regex = new RegExp(`\\\\p{Script=${options.script}}`, \"u\");\n        if (!regex.test(String.fromCharCode(glyph.unicode!))) {\n          continue;\n        }\n      }\n      if (options.englishOnly) {\n        if (!englishRegex.test(String.fromCharCode(glyph.unicode!))) {\n          continue;\n        }\n      }\n\n      const bbox = glyph.getBoundingBox();\n      minSpriteY = Math.min(minSpriteY, bbox.y1 * fontScale);\n      maxSpriteY = Math.max(maxSpriteY, bbox.y2 * fontScale);\n\n      glyphs.push(glyph);\n    }\n\n    // _console.log({\n    //   fontName: font.getEnglishName(\"fullName\"),\n    //   minSpriteY,\n    //   maxSpriteY,\n    // });\n  }\n\n  minSpriteY = options.minSpriteY ?? minSpriteY;\n  maxSpriteY = options.maxSpriteY ?? maxSpriteY;\n\n  let maxSpriteHeight =\n    options.maxSpriteHeight ?? maxSpriteY - minSpriteY + strokeWidth;\n\n  // if (options.maxSpriteHeight) {\n  //   if (options.overrideMaxSpriteHeight) {\n  //     maxSpriteHeight = options.maxSpriteHeight;\n  //   } else {\n  //     maxSpriteHeight = Math.max(options.maxSpriteHeight, maxSpriteHeight);\n  //   }\n  // }\n  return { maxSpriteHeight, maxSpriteY, minSpriteY };\n}\n\nexport async function fontToSpriteSheet(\n  font: Font | Font[],\n  fontSize: number,\n  spriteSheetName?: string,\n  options?: FontToSpriteSheetOptions\n) {\n  _console.assertTypeWithError(fontSize, \"number\");\n\n  options = options\n    ? { ...defaultFontToSpriteSheetOptions, ...options }\n    : defaultFontToSpriteSheetOptions;\n\n  const fonts = Array.isArray(font) ? font : [font];\n  font = fonts[0];\n  spriteSheetName = spriteSheetName || font.getEnglishName(\"fullName\");\n  const spriteSheet: DisplaySpriteSheet = {\n    name: spriteSheetName,\n    sprites: [],\n  };\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\")!;\n\n  const { maxSpriteHeight, maxSpriteY, minSpriteY } = getFontMetrics(\n    fonts,\n    fontSize,\n    options\n  );\n  const strokeWidth = options.stroke ? options.strokeWidth || 1 : 0;\n\n  let string = options.string;\n  if (string) {\n    string = removeRedundantCharacters(string);\n    _console.log(\"filtered string\", string);\n  }\n\n  for (let font of fonts) {\n    const fontScale = (1 / font.unitsPerEm) * fontSize;\n\n    const glyphs: Glyph[] = [];\n    let filteredGlyphs: Glyph[] | undefined;\n    if (string != undefined) {\n      filteredGlyphs = font\n        .stringToGlyphs(string)\n        .filter((glyph) => glyph.unicode != undefined);\n      string = removeSubstrings(\n        string,\n        filteredGlyphs.map((glyph) => String.fromCharCode(glyph.unicode!))\n      );\n      //_console.log(\"filteredString\", string);\n      //_console.log(\"filteredGlyphs\", filteredGlyphs);\n    }\n\n    for (let index = 0; index < font.glyphs.length; index++) {\n      const glyph = font.glyphs.get(index);\n      const hasUnicode = glyph.unicode != undefined;\n      if (hasUnicode) {\n        //_console.log(String.fromCharCode(glyph.unicode!), glyph);\n      } else {\n        //_console.log(\"no unicode\", glyph);\n      }\n\n      if (filteredGlyphs) {\n        if (!filteredGlyphs.includes(glyph)) {\n          continue;\n        }\n      }\n\n      if (options.unicodeOnly || options.englishOnly) {\n        if (!hasUnicode) {\n          continue;\n        }\n      }\n      if (options.script && hasUnicode) {\n        const regex = new RegExp(`\\\\p{Script=${options.script}}`, \"u\");\n        if (!regex.test(String.fromCharCode(glyph.unicode!))) {\n          continue;\n        }\n      }\n      if (options.englishOnly) {\n        if (!englishRegex.test(String.fromCharCode(glyph.unicode!))) {\n          continue;\n        }\n      }\n\n      glyphs.push(glyph);\n    }\n\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n\n      let name = glyph.name;\n      if (glyph.unicode != undefined) {\n        name = String.fromCharCode(glyph.unicode);\n      }\n      // _console.log(name, glyph);\n      if (typeof name != \"string\") {\n        continue;\n      }\n\n      const bbox = glyph.getBoundingBox();\n\n      const spriteWidth =\n        Math.max(\n          Math.max(bbox.x2, bbox.x2 - bbox.x1),\n          glyph.advanceWidth ?? 0\n        ) *\n          fontScale +\n        strokeWidth;\n      const spriteHeight = maxSpriteHeight;\n\n      const commands: DisplayContextCommand[] = [];\n\n      const path = glyph.getPath(\n        -bbox.x1 * fontScale,\n        bbox.y2 * fontScale,\n        fontSize\n      );\n      if (options.stroke) {\n        path.stroke = \"white\";\n        path.strokeWidth = strokeWidth;\n        commands.push({ type: \"setLineWidth\", lineWidth: strokeWidth });\n        commands.push({ type: \"setIgnoreFill\", ignoreFill: true });\n      } else {\n        path.fill = \"white\";\n      }\n\n      const bitmapWidth = (bbox.x2 - bbox.x1) * fontScale + strokeWidth;\n      const bitmapHeight = (bbox.y2 - bbox.y1) * fontScale + strokeWidth;\n\n      const bitmapX = (spriteWidth - bitmapWidth) / 2;\n      const bitmapY =\n        (spriteHeight - bitmapHeight) / 2 - (bbox.y1 * fontScale - minSpriteY);\n      if (options.usePath) {\n        const pathOffset: Vector2 = {\n          x: -bitmapWidth / 2 + bitmapX,\n          y: -bitmapHeight / 2 + bitmapY,\n        };\n        _console.log(`${name} path.commands`, path.commands);\n        let curves: DisplayBezierCurve[] = [];\n        let startPoint: Vector2 = { x: 0, y: 0 };\n\n        const allCurves: DisplayBezierCurve[][] = [];\n        const parsedPaths: { path: Vector2[]; isHole: boolean }[] = [];\n        let wasHole = false;\n\n        let pathCommands = path.commands;\n        pathCommands.forEach((cmd) => {\n          switch (cmd.type) {\n            case \"M\": // moveTo\n              {\n                startPoint.x = cmd.x;\n                startPoint.y = cmd.y;\n              }\n              break;\n\n            case \"L\": // lineTo\n              {\n                const controlPoints: Vector2[] = [{ x: cmd.x, y: cmd.y }];\n                if (curves.length === 0) {\n                  controlPoints.unshift({ ...startPoint });\n                }\n                curves.push({ type: \"segment\", controlPoints });\n              }\n              break;\n\n            case \"Q\": // quadratic Bezier\n              {\n                const controlPoints: Vector2[] = [\n                  { x: cmd.x1, y: cmd.y1 },\n                  { x: cmd.x, y: cmd.y },\n                ];\n                if (curves.length === 0) {\n                  controlPoints.unshift({ ...startPoint });\n                }\n                curves.push({ type: \"quadratic\", controlPoints });\n              }\n              break;\n\n            case \"C\": // cubic Bezier\n              {\n                const controlPoints: Vector2[] = [\n                  { x: cmd.x1, y: cmd.y1 },\n                  { x: cmd.x2, y: cmd.y2 },\n                  { x: cmd.x, y: cmd.y },\n                ];\n                if (curves.length === 0) {\n                  controlPoints.unshift({ ...startPoint });\n                }\n                curves.push({ type: \"cubic\", controlPoints });\n              }\n              break;\n\n            case \"Z\": // closePath\n              {\n                if (curves.length === 0) {\n                  break;\n                }\n\n                curves = simplifyCurves(curves);\n\n                // Flatten all control points\n                const controlPoints = curves.flatMap((c) => c.controlPoints);\n\n                // Apply path offset\n                controlPoints.forEach((pt) => {\n                  pt.x = pt.x + pathOffset.x;\n                  pt.y = pt.y + pathOffset.y;\n                });\n\n                allCurves.push(curves);\n\n                // Reset curves\n                curves = [];\n              }\n              break;\n          }\n        });\n\n        // allCurves.sort((a, b) => {\n        //   const aPoints = getCurvesPoints(a);\n        //   const bPoints = getCurvesPoints(b);\n        //   return contourArea(bPoints) - contourArea(aPoints);\n        // });\n\n        allCurves.forEach((curves) => {\n          let controlPoints = curves.flatMap((c) => c.controlPoints);\n          const isHole = classifySubpath(controlPoints, parsedPaths, \"nonzero\");\n          parsedPaths.push({ path: controlPoints, isHole });\n          if (isHole != wasHole) {\n            wasHole = isHole;\n            if (isHole) {\n              commands.push({\n                type: \"selectFillColor\",\n                fillColorIndex: 0,\n              });\n            } else {\n              commands.push({\n                type: \"selectFillColor\",\n                fillColorIndex: 1,\n              });\n            }\n          }\n\n          const isSegments = curves.every((c) => c.type === \"segment\");\n          controlPoints.forEach((controlPoint) => {\n            controlPoint.x = Math.round(controlPoint.x);\n            controlPoint.y = Math.round(controlPoint.y);\n          });\n          controlPoints = controlPoints.map(({ x, y }) => ({\n            x: Math.round(x),\n            y: Math.round(y),\n          }));\n          if (isSegments) {\n            commands.push({\n              type: \"drawPolygon\",\n              points: controlPoints,\n            });\n          } else {\n            commands.push({ type: \"drawClosedPath\", curves });\n          }\n        });\n      } else {\n        if (bitmapWidth > 0 && bitmapHeight > 0) {\n          const _bitmapWidth = Math.ceil(bitmapWidth);\n          const _bitmapHeight = Math.ceil(bitmapHeight);\n\n          canvas.width = _bitmapWidth;\n          canvas.height = _bitmapHeight;\n\n          ctx.imageSmoothingEnabled = false;\n\n          ctx.fillStyle = \"black\";\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n          path.draw(ctx);\n          const { colorIndices } = await quantizeCanvas(canvas, 2, [\n            \"#000000\",\n            \"#ffffff\",\n          ]);\n          const bitmap: DisplayBitmap = {\n            width: _bitmapWidth,\n            height: _bitmapHeight,\n            numberOfColors: 2,\n            pixels: colorIndices,\n          };\n\n          commands.push({\n            type: \"selectBitmapColor\",\n            bitmapColorIndex: 1,\n            colorIndex: 1,\n          });\n          if (false) {\n            // debugging\n            commands.push({\n              type: \"selectFillColor\",\n              fillColorIndex: 2,\n            });\n            commands.push({\n              type: \"drawRect\",\n              offsetX: 0,\n              offsetY: 0,\n              width: spriteWidth,\n              height: spriteHeight,\n            });\n          }\n\n          commands.push({\n            type: \"drawBitmap\",\n            offsetX: bitmapX,\n            offsetY: bitmapY,\n            bitmap,\n          });\n        }\n      }\n\n      const sprite: DisplaySprite = {\n        name,\n        commands,\n        width: Math.ceil(spriteWidth),\n        height: Math.ceil(spriteHeight),\n      };\n\n      spriteSheet.sprites.push(sprite);\n    }\n\n    if (string != undefined && string.length == 0) {\n      break;\n    }\n  }\n\n  return spriteSheet;\n}\n\nexport function stringToSprites(\n  string: string,\n  spriteSheet: DisplaySpriteSheet,\n  requireAll = false\n) {\n  const sprites: DisplaySprite[] = [];\n  let substring = string;\n  while (substring.length > 0) {\n    let longestSprite: DisplaySprite | undefined;\n\n    spriteSheet.sprites.forEach((sprite) => {\n      if (substring.startsWith(sprite.name)) {\n        if (!longestSprite || sprite.name.length > longestSprite.name.length) {\n          longestSprite = sprite;\n        }\n      }\n    });\n\n    // _console.log(\"longestSprite\", longestSprite);\n    if (requireAll) {\n      _console.assertWithError(\n        longestSprite,\n        `couldn't find sprite with name prefixing \"${substring}\"`\n      );\n    }\n\n    if (longestSprite) {\n      sprites.push(longestSprite);\n      substring = substring.substring(longestSprite!.name.length);\n    } else {\n      substring = substring.substring(1);\n    }\n    //_console.log(\"new substring\", substring);\n  }\n\n  //_console.log(`string \"${string}\" to sprites`, sprites);\n  return sprites;\n}\n\nexport function getReferencedSprites(\n  sprite: DisplaySprite,\n  spriteSheet: DisplaySpriteSheet\n) {\n  const sprites: DisplaySprite[] = [];\n  sprite.commands\n    .filter((command) => command.type == \"drawSprite\")\n    .map((command) => command.spriteIndex)\n    .map((spriteIndex) => spriteSheet.sprites[spriteIndex])\n    .forEach((_sprite) => {\n      if (!sprites.includes(_sprite)) {\n        sprites.push(_sprite);\n        sprites.push(...getReferencedSprites(_sprite, spriteSheet));\n      }\n    });\n  _console.log(\"referencedSprites\", sprite, sprites);\n  return sprites;\n}\nexport function reduceSpriteSheet(\n  spriteSheet: DisplaySpriteSheet,\n  spriteNames: string | string[],\n  requireAll = false\n) {\n  const reducedSpriteSheet = Object.assign({}, spriteSheet);\n  if (!(spriteNames instanceof Array)) {\n    spriteNames = stringToSprites(spriteNames, spriteSheet, requireAll).map(\n      (sprite) => sprite.name\n    );\n  }\n  _console.log(\"reducingSpriteSheet\", spriteSheet, spriteNames);\n  reducedSpriteSheet.sprites = [];\n  spriteSheet.sprites.forEach((sprite) => {\n    if (spriteNames.includes(sprite.name)) {\n      reducedSpriteSheet.sprites.push(sprite);\n      reducedSpriteSheet.sprites.push(\n        ...getReferencedSprites(sprite, spriteSheet)\n      );\n    }\n  });\n  _console.log(\"reducedSpriteSheet\", reducedSpriteSheet);\n  return reducedSpriteSheet;\n}\n\nexport function stringToSpriteLines(\n  string: string,\n  spriteSheets: Record<string, DisplaySpriteSheet>,\n  contextState: DisplayContextState,\n  requireAll = false,\n  maxLineBreadth = Infinity,\n  separators = [\" \"]\n): DisplaySpriteLines {\n  _console.log(\"stringToSpriteLines\", string);\n  const isSpritesDirectionHorizontal = isDirectionHorizontal(\n    contextState.spritesDirection\n  );\n  const isSpritesLineDirectionHorizontal = isDirectionHorizontal(\n    contextState.spritesLineDirection\n  );\n  const areSpritesDirectionsOrthogonal =\n    isSpritesDirectionHorizontal != isSpritesLineDirectionHorizontal;\n\n  const lineStrings = string.split(\"\\n\");\n  let lineBreadth = 0;\n\n  if (isSpritesDirectionHorizontal) {\n    maxLineBreadth /= contextState.spriteScaleX;\n  } else {\n    maxLineBreadth /= contextState.spriteScaleY;\n  }\n\n  const sprites: {\n    sprite: DisplaySprite;\n    spriteSheet: DisplaySpriteSheet;\n  }[][] = [];\n  let latestSeparatorIndex = -1;\n  let latestSeparator: string | undefined;\n  let latestSeparatorLineBreadth: number | undefined;\n  let latestSeparatorBreadth: number | undefined;\n  const spritesLineIndices: number[][] = [];\n\n  lineStrings.forEach((lineString) => {\n    sprites.push([]);\n    spritesLineIndices.push([]);\n    const i = sprites.length - 1;\n    if (areSpritesDirectionsOrthogonal) {\n      lineBreadth = 0;\n    } else {\n      lineBreadth += contextState.spritesLineSpacing;\n    }\n\n    let lineSubstring = lineString;\n    while (lineSubstring.length > 0) {\n      let longestSprite: DisplaySprite | undefined;\n      let longestSpriteSheet: DisplaySpriteSheet | undefined;\n      for (let spriteSheetName in spriteSheets) {\n        const spriteSheet = spriteSheets[spriteSheetName];\n        spriteSheet.sprites.forEach((sprite) => {\n          if (lineSubstring.startsWith(sprite.name)) {\n            if (\n              !longestSprite ||\n              sprite.name.length > longestSprite.name.length\n            ) {\n              longestSprite = sprite;\n              longestSpriteSheet = spriteSheet;\n            }\n          }\n        });\n      }\n      //_console.log(\"longestSprite\", longestSprite);\n      if (requireAll) {\n        _console.assertWithError(\n          longestSprite,\n          `couldn't find sprite with name prefixing \"${lineSubstring}\"`\n        );\n      }\n\n      if (longestSprite && longestSpriteSheet) {\n        const isSeparator =\n          separators.length > 0\n            ? separators.includes(longestSprite.name)\n            : true;\n\n        sprites[i].push({\n          sprite: longestSprite,\n          spriteSheet: longestSpriteSheet,\n        });\n\n        // _console.log({\n        //   name: longestSprite!.name,\n        //   isSeparator,\n        //   lineBreadth,\n        //   latestSeparatorIndex,\n        //   latestSeparatorLineBreadth,\n        //   latestSeparator,\n        //   index: sprites[i].length - 1,\n        // });\n\n        let newLineBreadth = lineBreadth;\n        const longestSpriteBreadth = isSpritesDirectionHorizontal\n          ? longestSprite.width\n          : longestSprite.height;\n        newLineBreadth += longestSpriteBreadth;\n        newLineBreadth += contextState.spritesSpacing;\n        if (newLineBreadth >= maxLineBreadth) {\n          if (isSeparator) {\n            if (longestSprite.name.trim().length == 0) {\n              sprites[i].pop();\n            }\n            spritesLineIndices[i].push(sprites[i].length);\n            lineBreadth = 0;\n          } else {\n            if (latestSeparatorIndex != -1) {\n              if (latestSeparator!.trim().length == 0) {\n                sprites[i].splice(latestSeparatorIndex, 1);\n                lineBreadth -= latestSeparatorBreadth!;\n                latestSeparatorIndex;\n              }\n              spritesLineIndices[i].push(latestSeparatorIndex);\n              lineBreadth = newLineBreadth - latestSeparatorLineBreadth!;\n            } else {\n              spritesLineIndices[i].push(sprites[i].length - 1);\n              lineBreadth = 0;\n            }\n          }\n          latestSeparatorIndex = -1;\n          latestSeparator = undefined;\n        } else {\n          lineBreadth = newLineBreadth;\n\n          if (isSeparator) {\n            latestSeparator = longestSprite.name;\n            latestSeparatorIndex = sprites[i].length - 1;\n            //_console.log({ latestSeparatorIndex });\n            latestSeparatorLineBreadth = lineBreadth;\n            latestSeparatorBreadth = longestSpriteBreadth;\n          }\n        }\n\n        lineSubstring = lineSubstring.substring(longestSprite!.name.length);\n      } else {\n        lineSubstring = lineSubstring.substring(1);\n      }\n    }\n  });\n\n  const spriteLines: DisplaySpriteLine[] = [];\n  sprites.forEach((_sprites, i) => {\n    let spriteLine: DisplaySpriteLine = [];\n    spriteLines.push(spriteLine);\n\n    let spriteSubLine: DisplaySpriteSubLine | undefined;\n\n    _sprites.forEach(({ sprite, spriteSheet }, index) => {\n      if (spritesLineIndices[i].includes(index)) {\n        spriteLine = [];\n        spriteLines.push(spriteLine);\n        spriteSubLine = undefined;\n      }\n\n      if (!spriteSubLine || spriteSubLine.spriteSheetName != spriteSheet.name) {\n        spriteSubLine = {\n          spriteSheetName: spriteSheet.name,\n          spriteNames: [],\n        };\n        spriteLine.push(spriteSubLine);\n      }\n      spriteSubLine.spriteNames.push(sprite.name);\n    });\n  });\n  _console.log(`spriteLines for \"${string}\"`, spriteLines);\n  return spriteLines;\n}\n\nexport function getFontMaxHeight(font: Font, fontSize: number) {\n  const scale = (1 / font.unitsPerEm) * fontSize;\n  const maxHeight = (font.ascender - font.descender) * scale;\n  return maxHeight;\n}\nexport function getMaxSpriteSheetSize(spriteSheet: DisplaySpriteSheet) {\n  const size: DisplaySize = { width: 0, height: 0 };\n  spriteSheet.sprites.forEach((sprite) => {\n    size.width = Math.max(size.width, sprite.width);\n    size.height = Math.max(size.height, sprite.height);\n  });\n  return size;\n}\n\nexport function assertValidSpriteLines(\n  displayManager: DisplayManagerInterface,\n  spriteLines: DisplaySpriteLines\n) {\n  spriteLines.forEach((spriteLine) => {\n    spriteLine.forEach((spriteSubLine) => {\n      const { spriteSheetName, spriteNames } = spriteSubLine;\n      displayManager.assertLoadedSpriteSheet(spriteSheetName);\n      const spriteSheet = displayManager.spriteSheets[spriteSheetName];\n      spriteNames.forEach((spriteName) => {\n        const sprite = spriteSheet.sprites.find(\n          (sprite) => sprite.name == spriteName\n        );\n        _console.assertWithError(\n          sprite,\n          `no sprite with name \"${spriteName}\" found in spriteSheet \"${spriteSheetName}\"`\n        );\n      });\n    });\n  });\n}\n\nexport function getExpandedSpriteLines(\n  spriteLines: DisplaySpriteLines,\n  spriteSheets: Record<string, DisplaySpriteSheet>\n) {\n  const expandedSpritesLines: DisplaySprite[][] = [];\n\n  spriteLines.forEach((spriteLine) => {\n    const _spritesLine: DisplaySprite[] = [];\n\n    spriteLine.forEach(({ spriteSheetName, spriteNames }) => {\n      const spriteSheet = spriteSheets[spriteSheetName];\n      _console.assertWithError(\n        spriteSheet,\n        `no spriteSheet found with name \"${spriteSheetName}\"`\n      );\n\n      spriteNames.forEach((spriteName) => {\n        const sprite = spriteSheet.sprites.find(\n          (sprite) => sprite.name == spriteName\n        )!;\n        _console.assertWithError(\n          sprite,\n          `no sprite found with name \"${spriteName} in \"${spriteSheetName}\" spriteSheet`\n        );\n        _spritesLine.push(sprite);\n      });\n    });\n    expandedSpritesLines.push(_spritesLine);\n  });\n  return expandedSpritesLines;\n}\n\nexport function getExpandedSpriteLinesSize(\n  expandedSpritesLines: DisplaySprite[][],\n  contextState: DisplayContextState\n) {\n  const localSize = { width: 0, height: 0 };\n\n  const isSpritesDirectionHorizontal = isDirectionHorizontal(\n    contextState.spritesDirection\n  );\n  const isSpritesLineDirectionHorizontal = isDirectionHorizontal(\n    contextState.spritesLineDirection\n  );\n\n  const areSpritesDirectionsOrthogonal =\n    isSpritesDirectionHorizontal != isSpritesLineDirectionHorizontal;\n\n  const breadthSizeKey = isSpritesDirectionHorizontal ? \"width\" : \"height\";\n  const depthSizeKey = isSpritesLineDirectionHorizontal ? \"width\" : \"height\";\n\n  if (!areSpritesDirectionsOrthogonal) {\n    if (isSpritesDirectionHorizontal) {\n      localSize.height += contextState.spritesLineHeight;\n    } else {\n      localSize.width += contextState.spritesLineHeight;\n    }\n  }\n\n  const lineBreadths: number[] = [];\n\n  expandedSpritesLines.forEach((expandedSpriteLine, lineIndex) => {\n    let spritesLineBreadth = 0;\n\n    expandedSpriteLine.forEach((sprite) => {\n      spritesLineBreadth += isSpritesDirectionHorizontal\n        ? sprite.width\n        : sprite.height;\n      spritesLineBreadth += contextState.spritesSpacing;\n    });\n    spritesLineBreadth -= contextState.spritesSpacing;\n\n    if (areSpritesDirectionsOrthogonal) {\n      localSize[breadthSizeKey] = Math.max(\n        localSize[breadthSizeKey],\n        spritesLineBreadth\n      );\n\n      localSize[depthSizeKey] += contextState.spritesLineHeight;\n    } else {\n      localSize[breadthSizeKey] += spritesLineBreadth;\n    }\n\n    localSize[depthSizeKey] += contextState.spritesLineSpacing;\n\n    // _console.log({\n    //   lineIndex,\n    //   spritesBreadth: spritesSize[breadthSizeKey],\n    //   spritesDepth: spritesSize[depthSizeKey],\n    // });\n\n    lineBreadths.push(spritesLineBreadth);\n  });\n  localSize[depthSizeKey] -= contextState.spritesLineSpacing;\n\n  // _console.log({\n  //   spritesWidth: spritesSize.width,\n  //   spritesHeight: spritesSize.height,\n  // });\n\n  const spritesScaledWidth =\n    localSize.width * Math.abs(contextState.spriteScaleX);\n  const spritesScaledHeight =\n    localSize.height * Math.abs(contextState.spriteScaleY);\n\n  const size: DisplaySize = {\n    width: spritesScaledWidth,\n    height: spritesScaledHeight,\n  };\n\n  // _console.log(\"localSize\", localSize);\n  // _console.log(\"size\", size);\n  // _console.log(\"lineBreadths\", lineBreadths);\n\n  return { localSize, size, lineBreadths };\n}\n\nexport function getSpriteLinesMetrics(\n  spriteLines: DisplaySpriteLines,\n  spriteSheets: Record<string, DisplaySpriteSheet>,\n  contextState: DisplayContextState\n) {\n  const expandedSpritesLines = getExpandedSpriteLines(\n    spriteLines,\n    spriteSheets\n  );\n  return {\n    expandedSpritesLines,\n    numberOfLines: expandedSpritesLines.length,\n    ...getExpandedSpriteLinesSize(expandedSpritesLines, contextState),\n  };\n}\n\nexport type DisplaySpriteLinesMetrics = {\n  localSize: DisplaySize;\n  size: DisplaySize;\n  lineBreadths: number[];\n  expandedSpritesLines: DisplaySprite[][];\n  numberOfLines: number;\n};\nexport function stringToSpriteLinesMetrics(\n  string: string,\n  spriteSheets: Record<string, DisplaySpriteSheet>,\n  contextState: DisplayContextState,\n  requireAll?: boolean,\n  maxLineBreadth?: number,\n  separators?: string[]\n): DisplaySpriteLinesMetrics {\n  return getSpriteLinesMetrics(\n    stringToSpriteLines(\n      string,\n      spriteSheets,\n      contextState,\n      requireAll,\n      maxLineBreadth,\n      separators\n    ),\n    spriteSheets,\n    contextState\n  );\n}\n\nexport function spriteLinesToSerializedLines(\n  displayManager: DisplayManagerInterface,\n  spriteLines: DisplaySpriteLines\n) {\n  const spriteSerializedLines: DisplaySpriteSerializedLines = [];\n  spriteLines.forEach((spriteLine) => {\n    const serializedLine: DisplaySpriteSerializedLine = [];\n    spriteLine.forEach((spriteSubLine) => {\n      displayManager.assertLoadedSpriteSheet(spriteSubLine.spriteSheetName);\n      const spriteSheet =\n        displayManager.spriteSheets[spriteSubLine.spriteSheetName];\n      const spriteSheetIndex =\n        displayManager.spriteSheetIndices[spriteSheet.name];\n      const serializedSubLine: DisplaySpriteSerializedSubLine = {\n        spriteSheetIndex,\n        spriteIndices: [],\n        use2Bytes: spriteSheet.sprites.length > 255,\n      };\n      spriteSubLine.spriteNames.forEach((spriteName) => {\n        let spriteIndex = spriteSheet.sprites.findIndex(\n          (sprite) => sprite.name == spriteName\n        );\n        _console.assertWithError(\n          spriteIndex != -1,\n          `sprite \"${spriteName}\" not found`\n        );\n        spriteIndex = spriteIndex!;\n        serializedSubLine.spriteIndices.push(spriteIndex);\n      });\n      serializedLine.push(serializedSubLine);\n    });\n    spriteSerializedLines.push(serializedLine);\n  });\n  _console.log(\"spriteSerializedLines\", spriteSerializedLines);\n  return spriteSerializedLines;\n}\n","import {\n  DisplayBitmapColorPair,\n  DisplayBrightness,\n  DisplaySpriteColorPair,\n  DisplayBitmap,\n  DisplayBezierCurve,\n  DisplayBezierCurveType,\n  DisplayWireframe,\n  DisplaySize,\n} from \"../DisplayManager.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport { DisplayContextCommand } from \"./DisplayContextCommand.ts\";\nimport {\n  DisplayAlignment,\n  DisplayAlignmentDirection,\n  DisplayContextState,\n  DisplayDirection,\n  DisplaySegmentCap,\n} from \"./DisplayContextState.ts\";\nimport {\n  DisplaySprite,\n  DisplaySpriteLine,\n  DisplaySpriteLines,\n  DisplaySpriteLinesMetrics,\n  DisplaySpritePaletteSwap,\n  DisplaySpriteSheet,\n  DisplaySpriteSheetPalette,\n  DisplaySpriteSheetPaletteSwap,\n  DisplaySpriteSubLine,\n  reduceSpriteSheet,\n} from \"./DisplaySpriteSheetUtils.ts\";\nimport {\n  DisplayScaleDirection,\n  DisplayColorRGB,\n  DisplayCropDirection,\n} from \"./DisplayUtils.ts\";\nimport { degToRad, Vector2 } from \"./MathUtils.ts\";\n\nconst _console = createConsole(\"DisplayManagerInterface\", { log: false });\n\nexport interface DisplayManagerInterface {\n  get isReady(): boolean;\n\n  get contextState(): DisplayContextState;\n\n  flushContextCommands(): Promise<void>;\n\n  get brightness(): DisplayBrightness;\n  setBrightness(\n    newDisplayBrightness: DisplayBrightness,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  show(sendImmediately?: boolean): Promise<void>;\n  clear(sendImmediately?: boolean): Promise<void>;\n\n  get colors(): string[];\n  get numberOfColors(): number;\n  setColor(\n    colorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  assertValidColorIndex(colorIndex: number): void;\n  assertValidLineWidth(lineWidth: number): void;\n  assertValidNumberOfColors(numberOfColors: number): void;\n  assertValidBitmap(bitmap: DisplayBitmap, checkSize?: boolean): void;\n\n  get opacities(): number[];\n  setColorOpacity(\n    colorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setOpacity(opacity: number, sendImmediately?: boolean): Promise<void>;\n\n  saveContext(sendImmediately?: boolean): Promise<void>;\n  restoreContext(sendImmediately?: boolean): Promise<void>;\n\n  selectFillColor(\n    fillColorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  selectBackgroundColor(\n    backgroundColorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  selectLineColor(\n    lineColorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setLineWidth(lineWidth: number, sendImmediately?: boolean): Promise<void>;\n\n  setIgnoreFill(ignoreFill: boolean, sendImmediately?: boolean): Promise<void>;\n  setIgnoreLine(ignoreLine: boolean, sendImmediately?: boolean): Promise<void>;\n  setFillBackground(\n    fillBackground: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setAlignment(\n    alignmentDirection: DisplayAlignmentDirection,\n    alignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setHorizontalAlignment(\n    horizontalAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setVerticalAlignment(\n    verticalAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  resetAlignment(sendImmediately?: boolean): Promise<void>;\n\n  setRotation(\n    rotation: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  clearRotation(sendImmediately?: boolean): Promise<void>;\n\n  setSegmentStartCap(\n    segmentStartCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentEndCap(\n    segmentEndCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentCap(\n    segmentCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setSegmentStartRadius(\n    segmentStartRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentEndRadius(\n    segmentEndRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSegmentRadius(\n    segmentRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setCropTop(cropTop: number, sendImmediately?: boolean): Promise<void>;\n  setCropRight(cropRight: number, sendImmediately?: boolean): Promise<void>;\n  setCropBottom(cropBottom: number, sendImmediately?: boolean): Promise<void>;\n  setCropLeft(cropLeft: number, sendImmediately?: boolean): Promise<void>;\n  clearCrop(sendImmediately?: boolean): Promise<void>;\n\n  setRotationCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropTop(\n    rotationCropTop: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropRight(\n    rotationCropRight: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropBottom(\n    rotationCropBottom: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setRotationCropLeft(\n    rotationCropLeft: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  clearRotationCrop(sendImmediately?: boolean): Promise<void>;\n\n  selectBitmapColor(\n    bitmapColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  get bitmapColorIndices(): number[];\n  get bitmapColors(): string[];\n  selectBitmapColors(\n    bitmapColorPairs: DisplayBitmapColorPair[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setBitmapColor(\n    bitmapColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapColorOpacity(\n    bitmapColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setBitmapScaleDirection(\n    direction: DisplayScaleDirection,\n    bitmapScale: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapScaleX(\n    bitmapScaleX: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapScaleY(\n    bitmapScaleY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setBitmapScale(bitmapScale: number, sendImmediately?: boolean): Promise<void>;\n  resetBitmapScale(sendImmediately?: boolean): Promise<void>;\n\n  selectSpriteColor(\n    spriteColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  get spriteColorIndices(): number[];\n  get spriteColors(): string[];\n  selectSpriteColors(\n    spriteColorPairs: DisplaySpriteColorPair[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n  resetSpriteColors(sendImmediately?: boolean): Promise<void>;\n\n  setSpriteColor(\n    spriteColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpriteColorOpacity(\n    spriteColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setSpriteScaleDirection(\n    direction: DisplayScaleDirection,\n    spriteScale: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpriteScaleX(\n    spriteScaleX: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpriteScaleY(\n    spriteScaleY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpriteScale(spriteScale: number, sendImmediately?: boolean): Promise<void>;\n  resetSpriteScale(sendImmediately?: boolean): Promise<void>;\n\n  setSpritesLineHeight(\n    spritesLineHeight: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setSpritesDirectionGeneric(\n    direction: DisplayDirection,\n    isOrthogonal: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpritesDirection(\n    spritesDirection: DisplayDirection,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpritesLineDirection(\n    spritesLineDirection: DisplayDirection,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setSpritesSpacingGeneric(\n    spacing: number,\n    isOrthogonal: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpritesSpacing(\n    spritesSpacing: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpritesLineSpacing(\n    spritesSpacing: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  setSpritesAlignmentGeneric(\n    alignment: DisplayAlignment,\n    isOrthogonal: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpritesAlignment(\n    spritesAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  setSpritesLineAlignment(\n    spritesLineAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  clearRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawRoundRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawCircle(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawRegularPolygon(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    numberOfSides: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawPolygon(points: Vector2[], sendImmediately?: boolean): Promise<void>;\n\n  drawWireframe(\n    wireframe: DisplayWireframe,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  drawCurve(\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawCurves(\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  drawQuadraticBezierCurve(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawQuadraticBezierCurves(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  drawCubicBezierCurve(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawCubicBezierCurves(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  _drawPath(\n    isClosed: boolean,\n    curves: DisplayBezierCurve[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawPath(\n    curves: DisplayBezierCurve[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawClosedPath(\n    curves: DisplayBezierCurve[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  drawSegment(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawSegments(points: Vector2[], sendImmediately?: boolean): Promise<void>;\n\n  drawArc(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawArcEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  drawBitmap(\n    offsetX: number,\n    offsetY: number,\n    bitmap: DisplayBitmap,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  runContextCommand(\n    command: DisplayContextCommand,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  runContextCommands(\n    commands: DisplayContextCommand[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  imageToBitmap(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors?: number\n  ): Promise<{\n    blob: Blob;\n    bitmap: DisplayBitmap;\n  }>;\n  quantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number,\n    colors?: string[],\n    canvas?: HTMLCanvasElement\n  ): Promise<{\n    blob: Blob;\n    colors: string[];\n    colorIndices: number[];\n  }>;\n  resizeAndQuantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number,\n    colors?: string[],\n    canvas?: HTMLCanvasElement\n  ): Promise<{\n    blob: Blob;\n    colors: string[];\n    colorIndices: number[];\n  }>;\n\n  uploadSpriteSheet(spriteSheet: DisplaySpriteSheet): Promise<void>;\n  uploadSpriteSheets(spriteSheets: DisplaySpriteSheet[]): Promise<void>;\n  selectSpriteSheet(\n    spriteSheetName: string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawSprite(\n    offsetX: number,\n    offsetY: number,\n    spriteName: string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  stringToSpriteLines(\n    string: string,\n    requireAll?: boolean,\n    maxLineBreadth?: number,\n    separators?: string[]\n  ): DisplaySpriteLines;\n  stringToSpriteLinesMetrics(\n    string: string,\n    requireAll?: boolean,\n    maxLineBreadth?: number,\n    separators?: string[]\n  ): DisplaySpriteLinesMetrics;\n  drawSprites(\n    offsetX: number,\n    offsetY: number,\n    spriteLines: DisplaySpriteLines,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  drawSpritesString(\n    offsetX: number,\n    offsetY: number,\n    string: string,\n    requireAll?: boolean,\n    maxLineBreadth?: number,\n    separators?: string[],\n    sendImmediately?: boolean\n  ): Promise<void>;\n  assertLoadedSpriteSheet(spriteSheetName: string): void;\n  assertSelectedSpriteSheet(spriteSheetName: string): void;\n  assertAnySelectedSpriteSheet(): void;\n  assertSprite(spriteName: string): void;\n  getSprite(spriteName: string): DisplaySprite | undefined;\n  getSpriteSheetPalette(\n    paletteName: string\n  ): DisplaySpriteSheetPalette | undefined;\n  getSpriteSheetPaletteSwap(\n    paletteSwapName: string\n  ): DisplaySpriteSheetPaletteSwap | undefined;\n  getSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string\n  ): DisplaySpritePaletteSwap | undefined;\n\n  drawSpriteFromSpriteSheet(\n    offsetX: number,\n    offsetY: number,\n    spriteName: string,\n    spriteSheet: DisplaySpriteSheet,\n    paletteName?: string,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  get selectedSpriteSheet(): DisplaySpriteSheet | undefined;\n  get selectedSpriteSheetName(): string | undefined;\n\n  spriteSheets: Record<string, DisplaySpriteSheet>;\n  spriteSheetIndices: Record<string, number>;\n\n  assertSpriteSheetPalette(paletteName: string): void;\n  assertSpriteSheetPaletteSwap(paletteSwapName: string): void;\n  assertSpritePaletteSwap(spriteName: string, paletteSwapName: string): void;\n  selectSpriteSheetPalette(\n    paletteName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  selectSpriteSheetPaletteSwap(\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  selectSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n\n  serializeSpriteSheet(spriteSheet: DisplaySpriteSheet): ArrayBuffer;\n\n  startSprite(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ): Promise<void>;\n  endSprite(sendImmediately?: boolean): Promise<void>;\n}\n\nexport async function runDisplayContextCommand(\n  displayManager: DisplayManagerInterface,\n  command: DisplayContextCommand,\n  sendImmediately?: boolean\n) {\n  if (command.hide) {\n    return;\n  }\n  switch (command.type) {\n    case \"show\":\n      await displayManager.show(sendImmediately);\n      break;\n    case \"clear\":\n      await displayManager.clear(sendImmediately);\n      break;\n    case \"saveContext\":\n      //await displayManager.saveContext(sendImmediately);\n      break;\n    case \"restoreContext\":\n      //await displayManager.restoreContext(sendImmediately);\n      break;\n    case \"clearRotation\":\n      await displayManager.clearRotation(sendImmediately);\n      break;\n    case \"clearCrop\":\n      await displayManager.clearCrop(sendImmediately);\n      break;\n    case \"clearRotationCrop\":\n      await displayManager.clearRotationCrop(sendImmediately);\n      break;\n    case \"resetBitmapScale\":\n      await displayManager.resetBitmapScale(sendImmediately);\n      break;\n    case \"resetSpriteScale\":\n      await displayManager.resetSpriteScale(sendImmediately);\n      break;\n    case \"setColor\":\n      {\n        const { colorIndex, color } = command;\n        await displayManager.setColor(colorIndex, color, sendImmediately);\n      }\n      break;\n    case \"setColorOpacity\":\n      {\n        const { colorIndex, opacity } = command;\n        await displayManager.setColorOpacity(\n          colorIndex,\n          opacity,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setOpacity\":\n      {\n        const { opacity } = command;\n        await displayManager.setOpacity(opacity, sendImmediately);\n      }\n      break;\n    case \"selectBackgroundColor\":\n      {\n        const { backgroundColorIndex } = command;\n        await displayManager.selectBackgroundColor(\n          backgroundColorIndex,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectFillColor\":\n      {\n        const { fillColorIndex } = command;\n        await displayManager.selectFillColor(fillColorIndex, sendImmediately);\n      }\n      break;\n    case \"selectLineColor\":\n      {\n        const { lineColorIndex } = command;\n        await displayManager.selectLineColor(lineColorIndex, sendImmediately);\n      }\n      break;\n    case \"setIgnoreFill\":\n      {\n        const { ignoreFill } = command;\n        await displayManager.setIgnoreFill(ignoreFill, sendImmediately);\n      }\n      break;\n    case \"setIgnoreLine\":\n      {\n        const { ignoreLine } = command;\n        await displayManager.setIgnoreLine(ignoreLine, sendImmediately);\n      }\n      break;\n    case \"setFillBackground\":\n      {\n        const { fillBackground } = command;\n        await displayManager.setFillBackground(fillBackground, sendImmediately);\n      }\n      break;\n    case \"setLineWidth\":\n      {\n        const { lineWidth } = command;\n        await displayManager.setLineWidth(lineWidth, sendImmediately);\n      }\n      break;\n    case \"setRotation\":\n      {\n        let { rotation, isRadians } = command;\n        rotation = isRadians ? rotation : degToRad(rotation);\n        rotation;\n        await displayManager.setRotation(rotation, true, sendImmediately);\n      }\n      break;\n    case \"setSegmentStartCap\":\n      {\n        const { segmentStartCap } = command;\n        await displayManager.setSegmentStartCap(\n          segmentStartCap,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSegmentEndCap\":\n      {\n        const { segmentEndCap } = command;\n        await displayManager.setSegmentEndCap(segmentEndCap, sendImmediately);\n      }\n      break;\n    case \"setSegmentCap\":\n      {\n        const { segmentCap } = command;\n        await displayManager.setSegmentCap(segmentCap, sendImmediately);\n      }\n      break;\n    case \"setSegmentStartRadius\":\n      {\n        const { segmentStartRadius } = command;\n        await displayManager.setSegmentStartRadius(\n          segmentStartRadius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSegmentEndRadius\":\n      {\n        const { segmentEndRadius } = command;\n        await displayManager.setSegmentEndRadius(\n          segmentEndRadius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSegmentRadius\":\n      {\n        const { segmentRadius } = command;\n        await displayManager.setSegmentRadius(segmentRadius, sendImmediately);\n      }\n      break;\n    case \"setHorizontalAlignment\":\n      {\n        const { horizontalAlignment } = command;\n        await displayManager.setHorizontalAlignment(\n          horizontalAlignment,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setVerticalAlignment\":\n      {\n        const { verticalAlignment } = command;\n        await displayManager.setVerticalAlignment(\n          verticalAlignment,\n          sendImmediately\n        );\n      }\n      break;\n    case \"resetAlignment\":\n      {\n        await displayManager.resetAlignment(sendImmediately);\n      }\n      break;\n    case \"setCropTop\":\n      {\n        const { cropTop } = command;\n        await displayManager.setCropTop(cropTop, sendImmediately);\n      }\n      break;\n    case \"setCropRight\":\n      {\n        const { cropRight } = command;\n        await displayManager.setCropRight(cropRight, sendImmediately);\n      }\n      break;\n    case \"setCropBottom\":\n      {\n        const { cropBottom } = command;\n        await displayManager.setCropBottom(cropBottom, sendImmediately);\n      }\n      break;\n    case \"setCropLeft\":\n      {\n        const { cropLeft } = command;\n        await displayManager.setCropLeft(cropLeft, sendImmediately);\n      }\n      break;\n    case \"setRotationCropTop\":\n      {\n        const { rotationCropTop } = command;\n        await displayManager.setRotationCropTop(\n          rotationCropTop,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setRotationCropRight\":\n      {\n        const { rotationCropRight } = command;\n        await displayManager.setRotationCropRight(\n          rotationCropRight,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setRotationCropBottom\":\n      {\n        const { rotationCropBottom } = command;\n        await displayManager.setRotationCropBottom(\n          rotationCropBottom,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setRotationCropLeft\":\n      {\n        const { rotationCropLeft } = command;\n        await displayManager.setRotationCropLeft(\n          rotationCropLeft,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectBitmapColor\":\n      {\n        const { bitmapColorIndex, colorIndex } = command;\n        await displayManager.selectBitmapColor(\n          bitmapColorIndex,\n          colorIndex,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectBitmapColors\":\n      {\n        const { bitmapColorPairs } = command;\n        await displayManager.selectBitmapColors(\n          bitmapColorPairs,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setBitmapScaleX\":\n      {\n        const { bitmapScaleX } = command;\n        await displayManager.setBitmapScaleX(bitmapScaleX, sendImmediately);\n      }\n      break;\n    case \"setBitmapScaleY\":\n      {\n        const { bitmapScaleY } = command;\n        await displayManager.setBitmapScaleY(bitmapScaleY, sendImmediately);\n      }\n      break;\n    case \"setBitmapScale\":\n      {\n        const { bitmapScale } = command;\n        await displayManager.setBitmapScale(bitmapScale, sendImmediately);\n      }\n      break;\n    case \"selectSpriteColor\":\n      {\n        const { spriteColorIndex, colorIndex } = command;\n        await displayManager.selectSpriteColor(\n          spriteColorIndex,\n          colorIndex,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectSpriteColors\":\n      {\n        const { spriteColorPairs } = command;\n        await displayManager.selectSpriteColors(\n          spriteColorPairs,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSpriteScaleX\":\n      {\n        const { spriteScaleX } = command;\n        await displayManager.setSpriteScaleX(spriteScaleX, sendImmediately);\n      }\n      break;\n    case \"setSpriteScaleY\":\n      {\n        const { spriteScaleY } = command;\n        await displayManager.setSpriteScaleY(spriteScaleY, sendImmediately);\n      }\n      break;\n    case \"setSpriteScale\":\n      {\n        const { spriteScale } = command;\n        await displayManager.setSpriteScale(spriteScale, sendImmediately);\n      }\n      break;\n\n    case \"clearRect\":\n      {\n        const { x, y, width, height } = command;\n        await displayManager.clearRect(x, y, width, height, sendImmediately);\n      }\n      break;\n    case \"drawRect\":\n      {\n        const { offsetX, offsetY, width, height } = command;\n        await displayManager.drawRect(\n          offsetX,\n          offsetY,\n          width,\n          height,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawRoundRect\":\n      {\n        const { offsetX, offsetY, width, height, borderRadius } = command;\n        await displayManager.drawRoundRect(\n          offsetX,\n          offsetY,\n          width,\n          height,\n          borderRadius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawCircle\":\n      {\n        const { offsetX, offsetY, radius } = command;\n        await displayManager.drawCircle(\n          offsetX,\n          offsetY,\n          radius,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawEllipse\":\n      {\n        const { offsetX, offsetY, radiusX, radiusY } = command;\n        await displayManager.drawEllipse(\n          offsetX,\n          offsetY,\n          radiusX,\n          radiusY,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawPolygon\":\n      {\n        const { points } = command;\n        await displayManager.drawPolygon(points, sendImmediately);\n      }\n      break;\n    case \"drawRegularPolygon\":\n      {\n        const { offsetX, offsetY, radius, numberOfSides } = command;\n        await displayManager.drawRegularPolygon(\n          offsetX,\n          offsetY,\n          radius,\n          numberOfSides,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawWireframe\":\n      {\n        const { wireframe } = command;\n        await displayManager.drawWireframe(wireframe, sendImmediately);\n      }\n      break;\n    case \"drawSegment\":\n      {\n        const { startX, startY, endX, endY } = command;\n        await displayManager.drawSegment(\n          startX,\n          startY,\n          endX,\n          endY,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawSegments\":\n      {\n        const { points } = command;\n        await displayManager.drawSegments(\n          points.map(({ x, y }) => ({ x: x, y: y })),\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawArc\":\n      {\n        let { offsetX, offsetY, radius, startAngle, angleOffset, isRadians } =\n          command;\n        startAngle = isRadians ? startAngle : degToRad(startAngle);\n        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n\n        await displayManager.drawArc(\n          offsetX,\n          offsetY,\n          radius,\n          startAngle,\n          angleOffset,\n          true,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawArcEllipse\":\n      {\n        let {\n          offsetX,\n          offsetY,\n          radiusX,\n          radiusY,\n          startAngle,\n          angleOffset,\n          isRadians,\n        } = command;\n        startAngle = isRadians ? startAngle : degToRad(startAngle);\n        angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n\n        await displayManager.drawArcEllipse(\n          offsetX,\n          offsetY,\n          radiusX,\n          radiusY,\n          startAngle,\n          angleOffset,\n          true,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawBitmap\":\n      {\n        const { offsetX, offsetY, bitmap } = command;\n        await displayManager.drawBitmap(\n          offsetX,\n          offsetY,\n          bitmap,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawSprite\":\n      {\n        const { offsetX, offsetY, spriteIndex } = command;\n        const spriteName =\n          displayManager.selectedSpriteSheet?.sprites[spriteIndex].name!;\n        await displayManager.drawSprite(\n          offsetX,\n          offsetY,\n          spriteName,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSpritesLineHeight\":\n      {\n        const { spritesLineHeight } = command;\n        await displayManager.setSpritesLineHeight(\n          spritesLineHeight,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSpritesSpacing\":\n      {\n        const { spritesSpacing } = command;\n        await displayManager.setSpritesSpacing(spritesSpacing, sendImmediately);\n      }\n      break;\n    case \"setSpritesAlignment\":\n      {\n        const { spritesAlignment } = command;\n        await displayManager.setSpritesAlignment(\n          spritesAlignment,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSpritesDirection\":\n      {\n        const { spritesDirection } = command;\n        await displayManager.setSpritesDirection(\n          spritesDirection,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSpritesLineAlignment\":\n      {\n        const { spritesLineAlignment } = command;\n        await displayManager.setSpritesLineAlignment(\n          spritesLineAlignment,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSpritesLineDirection\":\n      {\n        const { spritesLineDirection } = command;\n        await displayManager.setSpritesLineDirection(\n          spritesLineDirection,\n          sendImmediately\n        );\n      }\n      break;\n    case \"setSpritesLineSpacing\":\n      {\n        const { spritesLineSpacing } = command;\n        await displayManager.setSpritesLineSpacing(\n          spritesLineSpacing,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawSprites\":\n      {\n        const { offsetX, offsetY, spriteSerializedLines } = command;\n        //_console.log({ offsetX, offsetY, spriteSerializedLines });\n        const spriteLines: DisplaySpriteLines = [];\n        spriteSerializedLines.forEach((spriteSerializedLine) => {\n          const spriteLine: DisplaySpriteLine = [];\n          spriteSerializedLine.forEach((spriteSerializedSubLine) => {\n            const { spriteIndices, spriteSheetIndex } = spriteSerializedSubLine;\n            // _console.log(\n            //   { spriteIndices, spriteSheetIndex },\n            //   displayManager.spriteSheetIndices\n            // );\n            const spriteSheetName = Object.entries(\n              displayManager.spriteSheetIndices\n            ).find(([_spriteSheetName, _spriteSheetIndex]) => {\n              return _spriteSheetIndex == spriteSheetIndex;\n            })![0];\n            //_console.log({ spriteSheetName });\n            const spriteSheet = displayManager.spriteSheets[spriteSheetName];\n            const spriteSubLine: DisplaySpriteSubLine = {\n              spriteSheetName: spriteSheet.name,\n              spriteNames: spriteIndices.map(\n                (spriteIndex) => spriteSheet.sprites[spriteIndex].name\n              ),\n            };\n            spriteLine.push(spriteSubLine);\n          });\n          spriteLines.push(spriteLine);\n        });\n        //_console.log({ spriteLines });\n        await displayManager.drawSprites(\n          offsetX,\n          offsetY,\n          spriteLines,\n          sendImmediately\n        );\n      }\n      break;\n    case \"selectSpriteSheet\":\n      {\n        const { spriteSheetIndex } = command;\n        const spriteSheetName = Object.entries(\n          displayManager.spriteSheetIndices\n        ).find((entry) => entry[1] == spriteSheetIndex)?.[0];\n        await displayManager.selectSpriteSheet(\n          spriteSheetName!,\n          sendImmediately\n        );\n      }\n      break;\n    case \"resetSpriteColors\":\n      await displayManager.resetSpriteColors(sendImmediately);\n      break;\n\n    case \"drawQuadraticBezierCurve\":\n      {\n        const { controlPoints } = command;\n        await displayManager.drawQuadraticBezierCurve(\n          controlPoints,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawQuadraticBezierCurves\":\n      {\n        const { controlPoints } = command;\n        await displayManager.drawQuadraticBezierCurves(\n          controlPoints,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawCubicBezierCurve\":\n      {\n        const { controlPoints } = command;\n        await displayManager.drawCubicBezierCurve(\n          controlPoints,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawCubicBezierCurves\":\n      {\n        const { controlPoints } = command;\n        await displayManager.drawCubicBezierCurves(\n          controlPoints,\n          sendImmediately\n        );\n      }\n      break;\n    case \"drawClosedPath\":\n      {\n        const { curves } = command;\n        await displayManager.drawClosedPath(curves, sendImmediately);\n      }\n      break;\n    case \"drawPath\":\n      {\n        const { curves } = command;\n        await displayManager.drawPath(curves, sendImmediately);\n      }\n      break;\n    case \"startSprite\":\n      {\n        const { offsetX, offsetY, width, height } = command;\n        await displayManager.startSprite(\n          offsetX,\n          offsetY,\n          width,\n          height,\n          sendImmediately\n        );\n      }\n      break;\n    case \"endSprite\":\n      await displayManager.endSprite(sendImmediately);\n      break;\n  }\n}\n\nexport async function runDisplayContextCommands(\n  displayManager: DisplayManagerInterface,\n  commands: DisplayContextCommand[],\n  sendImmediately?: boolean\n) {\n  _console.log(\"runDisplayContextCommands\", commands);\n  commands\n    .filter((command) => !command.hide)\n    .forEach((command) => {\n      runDisplayContextCommand(displayManager, command, false);\n    });\n  if (sendImmediately) {\n    displayManager.flushContextCommands();\n  }\n}\n\nexport function assertLoadedSpriteSheet(\n  displayManager: DisplayManagerInterface,\n  spriteSheetName: string\n) {\n  _console.assertWithError(\n    displayManager.spriteSheets[spriteSheetName],\n    `spriteSheet \"${spriteSheetName}\" not loaded`\n  );\n}\nexport function assertSelectedSpriteSheet(\n  displayManager: DisplayManagerInterface,\n  spriteSheetName: string\n) {\n  displayManager.assertLoadedSpriteSheet(spriteSheetName);\n  _console.assertWithError(\n    displayManager.selectedSpriteSheetName == spriteSheetName,\n    `spriteSheet \"${spriteSheetName}\" not selected`\n  );\n}\nexport function assertAnySelectedSpriteSheet(\n  displayManager: DisplayManagerInterface\n) {\n  _console.assertWithError(\n    displayManager.selectedSpriteSheet,\n    \"no spriteSheet selected\"\n  );\n}\nexport function getSprite(\n  displayManager: DisplayManagerInterface,\n  spriteName: string\n): DisplaySprite | undefined {\n  displayManager.assertAnySelectedSpriteSheet();\n  return displayManager.selectedSpriteSheet!.sprites.find(\n    (sprite) => sprite.name == spriteName\n  );\n}\nexport function assertSprite(\n  displayManager: DisplayManagerInterface,\n  spriteName: string\n) {\n  displayManager.assertAnySelectedSpriteSheet();\n  const sprite = displayManager.getSprite(spriteName);\n  _console.assertWithError(sprite, `no sprite found with name \"${spriteName}\"`);\n}\nexport function getSpriteSheetPalette(\n  displayManager: DisplayManagerInterface,\n  paletteName: string\n): DisplaySpriteSheetPalette | undefined {\n  return displayManager.selectedSpriteSheet?.palettes?.find(\n    (palette) => palette.name == paletteName\n  );\n}\nexport function getSpriteSheetPaletteSwap(\n  displayManager: DisplayManagerInterface,\n  paletteSwapName: string\n): DisplaySpriteSheetPaletteSwap | undefined {\n  return displayManager.selectedSpriteSheet?.paletteSwaps?.find(\n    (paletteSwap) => paletteSwap.name == paletteSwapName\n  );\n}\nexport function getSpritePaletteSwap(\n  displayManager: DisplayManagerInterface,\n  spriteName: string,\n  paletteSwapName: string\n): DisplaySpritePaletteSwap | undefined {\n  return displayManager\n    .getSprite(spriteName)\n    ?.paletteSwaps?.find((paletteSwap) => paletteSwap.name == paletteSwapName);\n}\n\nexport function assertSpriteSheetPalette(\n  displayManagerInterface: DisplayManagerInterface,\n  paletteName: string\n) {\n  const spriteSheetPalette =\n    displayManagerInterface.getSpriteSheetPalette(paletteName);\n  _console.assertWithError(\n    spriteSheetPalette,\n    `no spriteSheetPalette found with name \"${paletteName}\"`\n  );\n}\nexport function assertSpriteSheetPaletteSwap(\n  displayManagerInterface: DisplayManagerInterface,\n  paletteSwapName: string\n) {\n  const spriteSheetPaletteSwap =\n    displayManagerInterface.getSpriteSheetPaletteSwap(paletteSwapName);\n  _console.assertWithError(\n    spriteSheetPaletteSwap,\n    `no paletteSwapName found with name \"${paletteSwapName}\"`\n  );\n}\nexport function assertSpritePaletteSwap(\n  displayManagerInterface: DisplayManagerInterface,\n  spriteName: string,\n  paletteSwapName: string\n) {\n  const spritePaletteSwap = displayManagerInterface.getSpritePaletteSwap(\n    spriteName,\n    paletteSwapName\n  );\n  _console.assertWithError(\n    spritePaletteSwap,\n    `no spritePaletteSwap found for sprite \"${spriteName}\" name \"${paletteSwapName}\"`\n  );\n}\nexport async function selectSpriteSheetPalette(\n  displayManagerInterface: DisplayManagerInterface,\n  paletteName: string,\n  offset?: number,\n  indicesOnly?: boolean,\n  sendImmediately?: boolean\n) {\n  offset = offset || 0;\n\n  displayManagerInterface.assertAnySelectedSpriteSheet();\n  displayManagerInterface.assertSpriteSheetPalette(paletteName);\n  const palette = displayManagerInterface.getSpriteSheetPalette(paletteName)!;\n\n  _console.assertWithError(\n    palette.numberOfColors + offset <= displayManagerInterface.numberOfColors,\n    `invalid offset ${offset} and palette.numberOfColors ${palette.numberOfColors} (max ${displayManagerInterface.numberOfColors})`\n  );\n\n  //_console.log({ indicesOnly });\n  for (let index = 0; index < palette.numberOfColors; index++) {\n    if (!indicesOnly) {\n      const color = palette.colors[index];\n      let opacity = palette.opacities?.[index];\n      if (opacity == undefined) {\n        opacity = 1;\n      }\n      //_console.log({ index, offset, color });\n      displayManagerInterface.setColor(index + offset, color, false);\n      displayManagerInterface.setColorOpacity(index + offset, opacity, false);\n    }\n    displayManagerInterface.selectSpriteColor(index, index + offset);\n  }\n\n  if (sendImmediately) {\n    displayManagerInterface.flushContextCommands();\n  }\n}\nexport async function selectSpriteSheetPaletteSwap(\n  displayManagerInterface: DisplayManagerInterface,\n  paletteSwapName: string,\n  offset?: number,\n  sendImmediately?: boolean\n) {\n  offset = offset || 0;\n  displayManagerInterface.assertAnySelectedSpriteSheet();\n  displayManagerInterface.assertSpriteSheetPaletteSwap(paletteSwapName);\n\n  const paletteSwap =\n    displayManagerInterface.getSpriteSheetPaletteSwap(paletteSwapName)!;\n\n  const spriteColorPairs: DisplaySpriteColorPair[] = [];\n  for (\n    let spriteColorIndex = 0;\n    spriteColorIndex < paletteSwap.numberOfColors;\n    spriteColorIndex++\n  ) {\n    const colorIndex = paletteSwap.spriteColorIndices[spriteColorIndex];\n    spriteColorPairs.push({\n      spriteColorIndex: spriteColorIndex + offset,\n      colorIndex,\n    });\n  }\n  displayManagerInterface.selectSpriteColors(spriteColorPairs, false);\n\n  if (sendImmediately) {\n    displayManagerInterface.flushContextCommands();\n  }\n}\nexport async function selectSpritePaletteSwap(\n  displayManagerInterface: DisplayManagerInterface,\n  spriteName: string,\n  paletteSwapName: string,\n  offset?: number,\n  sendImmediately?: boolean\n) {\n  offset = offset || 0;\n  displayManagerInterface.assertAnySelectedSpriteSheet();\n\n  const paletteSwap = displayManagerInterface.getSpritePaletteSwap(\n    spriteName,\n    paletteSwapName\n  )!;\n\n  const spriteColorPairs: DisplaySpriteColorPair[] = [];\n  for (\n    let spriteColorIndex = 0;\n    spriteColorIndex < paletteSwap.numberOfColors;\n    spriteColorIndex++\n  ) {\n    const colorIndex = paletteSwap.spriteColorIndices[spriteColorIndex];\n    spriteColorPairs.push({\n      spriteColorIndex: spriteColorIndex + offset,\n      colorIndex,\n    });\n  }\n  displayManagerInterface.selectSpriteColors(spriteColorPairs, false);\n\n  if (sendImmediately) {\n    displayManagerInterface.flushContextCommands();\n  }\n}\n\nexport async function drawSpriteFromSpriteSheet(\n  displayManagerInterface: DisplayManagerInterface,\n  offsetX: number,\n  offsetY: number,\n  spriteName: string,\n  spriteSheet: DisplaySpriteSheet,\n  paletteName?: string,\n  sendImmediately?: boolean\n) {\n  const reducedSpriteSheet = reduceSpriteSheet(spriteSheet, [spriteName]);\n  await displayManagerInterface.uploadSpriteSheet(reducedSpriteSheet);\n  await displayManagerInterface.selectSpriteSheet(spriteSheet.name);\n  await displayManagerInterface.drawSprite(\n    offsetX,\n    offsetY,\n    spriteName,\n    sendImmediately\n  );\n  if (paletteName != undefined) {\n    await displayManagerInterface.selectSpriteSheetPalette(paletteName);\n  }\n}\n","import Device, { SendMessageCallback } from \"./Device.ts\";\nimport {\n  concatenateArrayBuffers,\n  UInt8ByteBuffer,\n} from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport autoBind from \"auto-bind\";\nimport {\n  clamp,\n  degToRad,\n  normalizeRadians,\n  Vector2,\n} from \"./utils/MathUtils.ts\";\nimport { rgbToHex, stringToRGB } from \"./utils/ColorUtils.ts\";\nimport DisplayContextStateHelper from \"./utils/DisplayContextStateHelper.ts\";\nimport {\n  assertValidColor,\n  assertValidDisplayBrightness,\n  assertValidSegmentCap,\n  DisplayScaleDirection,\n  DisplayBitmapScaleDirectionToCommandType,\n  DisplayColorRGB,\n  DisplayCropDirection,\n  DisplayCropDirections,\n  DisplayCropDirectionToCommandType,\n  DisplayCropDirectionToStateKey,\n  DisplayRotationCropDirectionToCommandType,\n  DisplayRotationCropDirectionToStateKey,\n  maxDisplayScale,\n  roundScale,\n  DisplaySpriteScaleDirectionToCommandType,\n  minDisplayScale,\n  assertValidAlignment,\n  DisplayAlignmentDirectionToCommandType,\n  DisplayAlignmentDirectionToStateKey,\n  assertValidDirection,\n  assertValidAlignmentDirection,\n  assertValidWireframe,\n  trimWireframe,\n  assertValidNumberOfControlPoints,\n  assertValidPathNumberOfControlPoints,\n  assertValidPath,\n  isWireframePolygon,\n} from \"./utils/DisplayUtils.ts\";\nimport {\n  assertValidBitmapPixels,\n  drawBitmapHeaderLength,\n  getBitmapNumberOfBytes,\n  imageToBitmap,\n  quantizeImage,\n  resizeAndQuantizeImage,\n} from \"./utils/DisplayBitmapUtils.ts\";\nimport {\n  DefaultDisplayContextState,\n  DisplayAlignment,\n  DisplayAlignmentDirection,\n  DisplayContextState,\n  DisplayContextStateKey,\n  DisplayDirection,\n  DisplaySegmentCap,\n  isDirectionHorizontal,\n  isDirectionPositive,\n  PartialDisplayContextState,\n} from \"./utils/DisplayContextState.ts\";\nimport {\n  DisplayContextCommand,\n  DisplayContextCommandType,\n  DisplayContextCommandTypes,\n  serializeContextCommand,\n} from \"./utils/DisplayContextCommand.ts\";\nimport {\n  assertAnySelectedSpriteSheet,\n  assertLoadedSpriteSheet,\n  assertSelectedSpriteSheet,\n  assertSprite,\n  assertSpritePaletteSwap,\n  assertSpriteSheetPalette,\n  assertSpriteSheetPaletteSwap,\n  DisplayManagerInterface,\n  drawSpriteFromSpriteSheet,\n  getSprite,\n  getSpritePaletteSwap,\n  getSpriteSheetPalette,\n  getSpriteSheetPaletteSwap,\n  runDisplayContextCommand,\n  runDisplayContextCommands,\n  selectSpritePaletteSwap,\n  selectSpriteSheetPalette,\n  selectSpriteSheetPaletteSwap,\n} from \"./utils/DisplayManagerInterface.ts\";\nimport { SendFileCallback } from \"./FileTransferManager.ts\";\nimport { textDecoder, textEncoder } from \"./utils/Text.ts\";\nimport {\n  DisplaySprite,\n  DisplaySpritePaletteSwap,\n  DisplaySpriteSheetPalette,\n  DisplaySpriteSheetPaletteSwap,\n  serializeSpriteSheet,\n  DisplaySpriteSheet,\n  DisplaySpriteLines,\n  stringToSpriteLines,\n  stringToSpriteLinesMetrics,\n  spriteLinesToSerializedLines,\n  getSpriteLinesMetrics,\n} from \"./utils/DisplaySpriteSheetUtils.ts\";\nimport { wait } from \"./utils/Timer.ts\";\n\nconst _console = createConsole(\"DisplayManager\", { log: false });\n\nexport const DefaultNumberOfDisplayColors = 16;\n\nexport const DisplayCommands = [\"sleep\", \"wake\"] as const;\nexport type DisplayCommand = (typeof DisplayCommands)[number];\n\nexport const DisplayStatuses = [\"awake\", \"asleep\"] as const;\nexport type DisplayStatus = (typeof DisplayStatuses)[number];\n\nexport const DisplayInformationTypes = [\n  \"type\",\n  \"width\",\n  \"height\",\n  \"pixelDepth\",\n] as const;\nexport type DisplayInformationType = (typeof DisplayInformationTypes)[number];\n\nexport const DisplayTypes = [\n  \"none\",\n  \"generic\",\n  \"monocularLeft\",\n  \"monocularRight\",\n  \"binocular\",\n] as const;\nexport type DisplayType = (typeof DisplayTypes)[number];\n\nexport const DisplayPixelDepths = [\"1\", \"2\", \"4\"] as const;\nexport type DisplayPixelDepth = (typeof DisplayPixelDepths)[number];\n\nexport const DisplayBrightnesses = [\n  \"veryLow\",\n  \"low\",\n  \"medium\",\n  \"high\",\n  \"veryHigh\",\n] as const;\nexport type DisplayBrightness = (typeof DisplayBrightnesses)[number];\n\nexport const DisplayMessageTypes = [\n  \"isDisplayAvailable\",\n  \"displayStatus\",\n  \"displayInformation\",\n  \"displayCommand\",\n  \"getDisplayBrightness\",\n  \"setDisplayBrightness\",\n  \"displayContextCommands\",\n  \"displayReady\",\n  \"getSpriteSheetName\",\n  \"setSpriteSheetName\",\n  \"spriteSheetIndex\",\n] as const;\nexport type DisplayMessageType = (typeof DisplayMessageTypes)[number];\n\nexport type DisplaySize = {\n  width: number;\n  height: number;\n};\nexport type DisplayInformation = {\n  type: DisplayType;\n  width: number;\n  height: number;\n  pixelDepth: DisplayPixelDepth;\n};\n\nexport type DisplayBitmapColorPair = {\n  bitmapColorIndex: number;\n  colorIndex: number;\n};\n\nexport type DisplaySpriteColorPair = {\n  spriteColorIndex: number;\n  colorIndex: number;\n};\n\nexport type DisplayWireframeEdge = {\n  startIndex: number;\n  endIndex: number;\n};\nexport type DisplaySegment = {\n  start: Vector2;\n  end: Vector2;\n};\nexport type DisplayWireframe = {\n  points: Vector2[];\n  edges: DisplayWireframeEdge[];\n};\n\nexport const DisplayBezierCurveTypes = [\n  \"segment\",\n  \"quadratic\",\n  \"cubic\",\n] as const;\nexport type DisplayBezierCurveType = (typeof DisplayBezierCurveTypes)[number];\nexport type DisplayBezierCurve = {\n  type: DisplayBezierCurveType;\n  controlPoints: Vector2[];\n};\n\nexport const displayCurveTypeBitWidth = 2;\nexport const displayCurveTypesPerByte = 8 / displayCurveTypeBitWidth;\n\nexport const DisplayPointDataTypes = [\"int8\", \"int16\", \"float\"] as const;\nexport type DisplayPointDataType = (typeof DisplayPointDataTypes)[number];\nexport const displayPointDataTypeToSize: Record<DisplayPointDataType, number> =\n  {\n    int8: 1 * 2,\n    int16: 2 * 2,\n    float: 4 * 2,\n  };\nexport const displayPointDataTypeToRange: Record<\n  DisplayPointDataType,\n  { min: number; max: number }\n> = {\n  int8: { min: -(2 ** 7), max: 2 ** 7 - 1 },\n  int16: { min: -(2 ** 15), max: 2 ** 15 - 1 },\n  float: { min: -Infinity, max: Infinity },\n};\n\nexport const DisplayInformationValues = {\n  type: DisplayTypes,\n  pixelDepth: DisplayPixelDepths,\n};\n\nexport const RequiredDisplayMessageTypes: DisplayMessageType[] = [\n  \"isDisplayAvailable\",\n  \"displayInformation\",\n  \"displayStatus\",\n  \"getDisplayBrightness\",\n] as const;\n\nexport const DisplayEventTypes = [\n  ...DisplayMessageTypes,\n  \"displayContextState\",\n  \"displayColor\",\n  \"displayColorOpacity\",\n  \"displayOpacity\",\n  \"displaySpriteSheetUploadStart\",\n  \"displaySpriteSheetUploadProgress\",\n  \"displaySpriteSheetUploadComplete\",\n] as const;\nexport type DisplayEventType = (typeof DisplayEventTypes)[number];\n\nexport interface DisplayEventMessages {\n  isDisplayAvailable: { isDisplayAvailable: boolean };\n  displayStatus: {\n    displayStatus: DisplayStatus;\n    previousDisplayStatus: DisplayStatus;\n  };\n  displayInformation: {\n    displayInformation: DisplayInformation;\n  };\n  getDisplayBrightness: {\n    displayBrightness: DisplayBrightness;\n  };\n  displayContextState: {\n    displayContextState: DisplayContextState;\n    differences: DisplayContextStateKey[];\n  };\n  displayColor: {\n    colorIndex: number;\n    colorRGB: DisplayColorRGB;\n    colorHex: string;\n  };\n  displayColorOpacity: {\n    opacity: number;\n    colorIndex: number;\n  };\n  displayOpacity: {\n    opacity: number;\n  };\n  displayReady: {};\n  getSpriteSheetName: {\n    spriteSheetName: string;\n  };\n\n  displaySpriteSheetUploadStart: {\n    spriteSheetName: string;\n    spriteSheet: DisplaySpriteSheet;\n  };\n  displaySpriteSheetUploadProgress: {\n    spriteSheetName: string;\n    spriteSheet: DisplaySpriteSheet;\n    progress: number;\n  };\n  displaySpriteSheetUploadComplete: {\n    spriteSheetName: string;\n    spriteSheet: DisplaySpriteSheet;\n  };\n  displayContextCommands: {};\n}\n\nexport type DisplayEventDispatcher = EventDispatcher<\n  Device,\n  DisplayEventType,\n  DisplayEventMessages\n>;\nexport type SendDisplayMessageCallback =\n  SendMessageCallback<DisplayMessageType>;\n\nexport const MinSpriteSheetNameLength = 1;\nexport const MaxSpriteSheetNameLength = 30;\n\nexport type DisplayBitmap = {\n  width: number;\n  height: number;\n  numberOfColors: number;\n  pixels: number[];\n};\n\nclass DisplayManager implements DisplayManagerInterface {\n  constructor() {\n    autoBind(this);\n  }\n\n  sendMessage!: SendDisplayMessageCallback;\n\n  eventDispatcher!: DisplayEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  requestRequiredInformation() {\n    _console.log(\"requesting required display information\");\n    const messages = RequiredDisplayMessageTypes.map((messageType) => ({\n      type: messageType,\n    }));\n    this.sendMessage(messages, false);\n  }\n\n  // IS DISPLAY AVAILABLE\n  #isAvailable = false;\n  get isAvailable() {\n    return this.#isAvailable;\n  }\n\n  #assertDisplayIsAvailable() {\n    _console.assertWithError(this.#isAvailable, \"display is not available\");\n  }\n\n  #parseIsDisplayAvailable(dataView: DataView<ArrayBuffer>) {\n    const newIsDisplayAvailable = dataView.getUint8(0) == 1;\n    this.#isAvailable = newIsDisplayAvailable;\n    _console.log({ isDisplayAvailable: this.#isAvailable });\n    this.#dispatchEvent(\"isDisplayAvailable\", {\n      isDisplayAvailable: this.#isAvailable,\n    });\n  }\n\n  // DISPLAY CONTEXT STATE\n  #contextStateHelper = new DisplayContextStateHelper();\n  get contextState() {\n    return this.#contextStateHelper.state;\n  }\n  #onContextStateUpdate(differences: DisplayContextStateKey[]) {\n    this.#dispatchEvent(\"displayContextState\", {\n      displayContextState: structuredClone(this.contextState),\n      differences,\n    });\n  }\n  async setContextState(\n    newState: PartialDisplayContextState,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.diff(newState);\n    if (differences.length == 0) {\n      return;\n    }\n    differences.forEach((difference) => {\n      switch (difference) {\n        case \"backgroundColorIndex\":\n          this.selectBackgroundColor(newState.backgroundColorIndex!);\n          break;\n        case \"fillBackground\":\n          this.setFillBackground(newState.fillBackground!);\n          break;\n        case \"ignoreFill\":\n          this.setIgnoreFill(newState.ignoreFill!);\n          break;\n        case \"ignoreLine\":\n          this.setIgnoreLine(newState.ignoreLine!);\n          break;\n        case \"fillColorIndex\":\n          this.selectFillColor(newState.fillColorIndex!);\n          break;\n        case \"lineColorIndex\":\n          this.selectLineColor(newState.lineColorIndex!);\n          break;\n        case \"lineWidth\":\n          this.setLineWidth(newState.lineWidth!);\n          break;\n        case \"horizontalAlignment\":\n          this.setHorizontalAlignment(newState.horizontalAlignment!);\n          break;\n        case \"verticalAlignment\":\n          this.setVerticalAlignment(newState.verticalAlignment!);\n          break;\n        case \"rotation\":\n          this.setRotation(newState.rotation!, true);\n          break;\n        case \"segmentStartCap\":\n          if (\n            differences.includes(\"segmentEndCap\") &&\n            newState.segmentStartCap == newState.segmentEndCap\n          ) {\n            this.setSegmentCap(newState.segmentStartCap!);\n          } else {\n            this.setSegmentStartCap(newState.segmentStartCap!);\n          }\n          break;\n        case \"segmentEndCap\":\n          if (\n            !differences.includes(\"segmentStartCap\") ||\n            newState.segmentStartCap != newState.segmentEndCap\n          ) {\n            this.setSegmentEndCap(newState.segmentEndCap!);\n          }\n          break;\n        case \"segmentStartRadius\":\n          if (\n            differences.includes(\"segmentEndRadius\") &&\n            newState.segmentStartRadius == newState.segmentEndRadius\n          ) {\n            this.setSegmentRadius(newState.segmentStartRadius!);\n          } else {\n            this.setSegmentStartRadius(newState.segmentStartRadius!);\n          }\n          break;\n        case \"segmentEndRadius\":\n          if (\n            !differences.includes(\"segmentStartRadius\") ||\n            newState.segmentStartRadius != newState.segmentEndRadius\n          ) {\n            this.setSegmentEndRadius(newState.segmentEndRadius!);\n          }\n          break;\n        case \"cropTop\":\n          this.setCropTop(newState.cropTop!);\n          break;\n        case \"cropRight\":\n          this.setCropRight(newState.cropRight!);\n          break;\n        case \"cropBottom\":\n          this.setCropBottom(newState.cropBottom!);\n          break;\n        case \"cropLeft\":\n          this.setCropLeft(newState.cropLeft!);\n          break;\n        case \"rotationCropTop\":\n          this.setRotationCropTop(newState.rotationCropTop!);\n          break;\n        case \"rotationCropRight\":\n          this.setRotationCropRight(newState.rotationCropRight!);\n          break;\n        case \"rotationCropBottom\":\n          this.setRotationCropBottom(newState.rotationCropBottom!);\n          break;\n        case \"rotationCropLeft\":\n          this.setRotationCropLeft(newState.rotationCropLeft!);\n          break;\n        case \"bitmapColorIndices\":\n          const bitmapColors: DisplayBitmapColorPair[] = [];\n          newState.bitmapColorIndices!.forEach(\n            (colorIndex, bitmapColorIndex) => {\n              bitmapColors.push({ bitmapColorIndex, colorIndex });\n            }\n          );\n          this.selectBitmapColors(bitmapColors);\n          break;\n        case \"bitmapScaleX\":\n          if (\n            differences.includes(\"bitmapScaleY\") &&\n            newState.bitmapScaleX == newState.bitmapScaleY\n          ) {\n            this.setBitmapScale(newState.bitmapScaleX!);\n          } else {\n            this.setBitmapScaleX(newState.bitmapScaleX!);\n          }\n          break;\n        case \"bitmapScaleY\":\n          if (\n            !differences.includes(\"bitmapScaleX\") ||\n            newState.bitmapScaleX != newState.bitmapScaleY\n          ) {\n            this.setBitmapScaleY(newState.bitmapScaleY!);\n          }\n          break;\n        case \"spriteColorIndices\":\n          const spriteColors: DisplaySpriteColorPair[] = [];\n          newState.spriteColorIndices!.forEach(\n            (colorIndex, spriteColorIndex) => {\n              spriteColors.push({ spriteColorIndex, colorIndex });\n            }\n          );\n          this.selectSpriteColors(spriteColors);\n          break;\n        case \"spriteScaleX\":\n          if (\n            differences.includes(\"spriteScaleY\") &&\n            newState.spriteScaleX == newState.spriteScaleY\n          ) {\n            this.setSpriteScale(newState.spriteScaleX!);\n          } else {\n            this.setSpriteScaleX(newState.spriteScaleX!);\n          }\n          break;\n        case \"spriteScaleY\":\n          if (\n            !differences.includes(\"spriteScaleX\") ||\n            newState.spriteScaleX != newState.spriteScaleY\n          ) {\n            this.setSpriteScaleY(newState.spriteScaleY!);\n          }\n          break;\n        case \"spritesLineHeight\":\n          this.setSpritesLineHeight(newState.spritesLineHeight!);\n          break;\n        case \"spritesDirection\":\n          this.setSpritesDirection(newState.spritesDirection!);\n          break;\n        case \"spritesLineDirection\":\n          this.setSpritesLineDirection(newState.spritesLineDirection!);\n          break;\n        case \"spritesSpacing\":\n          this.setSpritesSpacing(newState.spritesSpacing!);\n          break;\n        case \"spritesLineSpacing\":\n          this.setSpritesLineSpacing(newState.spritesLineSpacing!);\n          break;\n        case \"spritesAlignment\":\n          this.setSpritesAlignment(newState.spritesAlignment!);\n          break;\n        case \"spritesLineAlignment\":\n          this.setSpritesLineAlignment(newState.spritesLineAlignment!);\n          break;\n      }\n    });\n    if (sendImmediately) {\n      await this.#sendContextCommands();\n    }\n  }\n\n  // DISPLAY STATUS\n  #displayStatus!: DisplayStatus;\n  get displayStatus() {\n    return this.#displayStatus;\n  }\n  get isDisplayAwake() {\n    return this.#displayStatus == \"awake\";\n  }\n  #parseDisplayStatus(dataView: DataView<ArrayBuffer>) {\n    const displayStatusIndex = dataView.getUint8(0);\n    const newDisplayStatus = DisplayStatuses[displayStatusIndex];\n    this.#updateDisplayStatus(newDisplayStatus);\n  }\n  #updateDisplayStatus(newDisplayStatus: DisplayStatus) {\n    _console.assertEnumWithError(newDisplayStatus, DisplayStatuses);\n    if (newDisplayStatus == this.#displayStatus) {\n      _console.log(`redundant displayStatus ${newDisplayStatus}`);\n      return;\n    }\n    const previousDisplayStatus = this.#displayStatus;\n    this.#displayStatus = newDisplayStatus;\n    _console.log(`updated displayStatus to \"${this.displayStatus}\"`);\n    this.#dispatchEvent(\"displayStatus\", {\n      displayStatus: this.displayStatus,\n      previousDisplayStatus,\n    });\n  }\n\n  // DISPLAY COMMAND\n  async #sendDisplayCommand(\n    command: DisplayCommand,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(command, DisplayCommands);\n    _console.log(`sending display command \"${command}\"`);\n\n    const promise = this.waitForEvent(\"displayStatus\");\n    _console.log(`setting command \"${command}\"`);\n    const commandEnum = DisplayCommands.indexOf(command);\n\n    this.sendMessage(\n      [\n        {\n          type: \"displayCommand\",\n          data: UInt8ByteBuffer(commandEnum),\n        },\n      ],\n      sendImmediately\n    );\n\n    await promise;\n  }\n  #assertIsAwake() {\n    _console.assertWithError(\n      this.#displayStatus == \"awake\",\n      `display is not awake - currently ${this.#displayStatus}`\n    );\n  }\n  #assertIsNotAwake() {\n    _console.assertWithError(\n      this.#displayStatus != \"awake\",\n      `display is awake`\n    );\n  }\n\n  async wake() {\n    this.#assertIsNotAwake();\n    await this.#sendDisplayCommand(\"wake\");\n  }\n  async sleep() {\n    this.#assertIsAwake();\n    await this.#sendDisplayCommand(\"sleep\");\n  }\n  async toggle() {\n    switch (this.displayStatus) {\n      case \"asleep\":\n        this.wake();\n        break;\n      case \"awake\":\n        this.sleep();\n        break;\n    }\n  }\n\n  get numberOfColors() {\n    return 2 ** Number(this.pixelDepth!);\n  }\n\n  // INFORMATION\n  #displayInformation?: DisplayInformation;\n  get displayInformation() {\n    return this.#displayInformation!;\n  }\n\n  get pixelDepth() {\n    return this.#displayInformation?.pixelDepth!;\n  }\n  get width() {\n    return this.#displayInformation?.width!;\n  }\n  get height() {\n    return this.#displayInformation?.width!;\n  }\n  get size() {\n    return {\n      width: this.width!,\n      height: this.height!,\n    };\n  }\n  get type() {\n    return this.#displayInformation?.type!;\n  }\n\n  #parseDisplayInformation(dataView: DataView<ArrayBuffer>) {\n    // @ts-expect-error\n    const parsedDisplayInformation: DisplayInformation = {};\n\n    let byteOffset = 0;\n    while (byteOffset < dataView.byteLength) {\n      const displayInformationTypeIndex = dataView.getUint8(byteOffset++);\n      const displayInformationType =\n        DisplayInformationTypes[displayInformationTypeIndex];\n      _console.assertWithError(\n        displayInformationType,\n        `invalid displayInformationTypeIndex ${displayInformationType}`\n      );\n      _console.log({ displayInformationType });\n\n      switch (displayInformationType) {\n        case \"width\":\n        case \"height\":\n          {\n            const value = dataView.getUint16(byteOffset, true);\n            parsedDisplayInformation[displayInformationType] = value;\n            byteOffset += 2;\n          }\n          break;\n        case \"pixelDepth\":\n        case \"type\":\n          {\n            const values = DisplayInformationValues[displayInformationType];\n            let rawValue = dataView.getUint8(byteOffset++);\n            const value = values[rawValue];\n            _console.assertEnumWithError(value, values);\n            // @ts-expect-error\n            parsedDisplayInformation[displayInformationType] = value;\n          }\n          break;\n      }\n    }\n\n    _console.log({ parsedDisplayInformation });\n    const missingDisplayInformationType = DisplayInformationTypes.find(\n      (type) => !(type in parsedDisplayInformation)\n    );\n    _console.assertWithError(\n      !missingDisplayInformationType,\n      `missingDisplayInformationType ${missingDisplayInformationType}`\n    );\n    this.#displayInformation = parsedDisplayInformation;\n    this.#colors = new Array(this.numberOfColors).fill(\"#000000\");\n    this.#opacities = new Array(this.numberOfColors).fill(1);\n    this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.#dispatchEvent(\"displayInformation\", {\n      displayInformation: this.#displayInformation,\n    });\n  }\n\n  // DISPLAY BRIGHTNESS\n  #brightness!: DisplayBrightness;\n  get brightness() {\n    return this.#brightness;\n  }\n\n  #parseDisplayBrightness(dataView: DataView<ArrayBuffer>) {\n    const newDisplayBrightnessEnum = dataView.getUint8(0);\n    const newDisplayBrightness = DisplayBrightnesses[newDisplayBrightnessEnum];\n    assertValidDisplayBrightness(newDisplayBrightness);\n\n    this.#brightness = newDisplayBrightness;\n    _console.log({ displayBrightness: this.#brightness });\n    this.#dispatchEvent(\"getDisplayBrightness\", {\n      displayBrightness: this.#brightness,\n    });\n  }\n\n  async setBrightness(\n    newDisplayBrightness: DisplayBrightness,\n    sendImmediately?: boolean\n  ) {\n    this.#assertDisplayIsAvailable();\n    assertValidDisplayBrightness(newDisplayBrightness);\n    if (this.brightness == newDisplayBrightness) {\n      _console.log(`redundant displayBrightness ${newDisplayBrightness}`);\n      return;\n    }\n    const newDisplayBrightnessEnum =\n      DisplayBrightnesses.indexOf(newDisplayBrightness);\n    const newDisplayBrightnessData = UInt8ByteBuffer(newDisplayBrightnessEnum);\n\n    const promise = this.waitForEvent(\"getDisplayBrightness\");\n    this.sendMessage(\n      [{ type: \"setDisplayBrightness\", data: newDisplayBrightnessData }],\n      sendImmediately\n    );\n    await promise;\n  }\n\n  // DISPLAY CONTEXT\n  #assertValidDisplayContextCommandType(\n    displayContextCommand: DisplayContextCommandType\n  ) {\n    _console.assertEnumWithError(\n      displayContextCommand,\n      DisplayContextCommandTypes\n    );\n  }\n\n  get #maxCommandDataLength() {\n    return this.mtu - 7;\n  }\n  #contextCommandBuffers: ArrayBuffer[] = [];\n  async #sendContextCommand(\n    contextCommandType: DisplayContextCommandType,\n    arrayBuffer?: ArrayBufferLike,\n    sendImmediately?: boolean\n  ) {\n    this.#assertValidDisplayContextCommandType(contextCommandType);\n    _console.log(\n      \"sendContextCommand\",\n      { displayContextCommand: contextCommandType, sendImmediately },\n      arrayBuffer\n    );\n    const displayContextCommandEnum =\n      DisplayContextCommandTypes.indexOf(contextCommandType);\n    const _arrayBuffer = concatenateArrayBuffers(\n      UInt8ByteBuffer(displayContextCommandEnum),\n      arrayBuffer\n    );\n    const newLength = this.#contextCommandBuffers.reduce(\n      (sum, buffer) => sum + buffer.byteLength,\n      _arrayBuffer.byteLength\n    );\n    if (newLength > this.#maxCommandDataLength) {\n      _console.log(\"displayContextCommandBuffers too full - sending now\");\n      await this.#sendContextCommands();\n    }\n    this.#contextCommandBuffers.push(_arrayBuffer);\n    if (sendImmediately) {\n      await this.#sendContextCommands();\n    }\n  }\n  async #sendContextCommands() {\n    if (this.#contextCommandBuffers.length == 0) {\n      return;\n    }\n    const data = concatenateArrayBuffers(this.#contextCommandBuffers);\n    _console.log(\n      `sending displayContextCommands`,\n      this.#contextCommandBuffers.slice(),\n      data\n    );\n    this.#contextCommandBuffers.length = 0;\n    await this.sendMessage([{ type: \"displayContextCommands\", data }], true);\n    this.#dispatchEvent(\"displayContextCommands\", {});\n  }\n  async flushContextCommands() {\n    await this.#sendContextCommands();\n  }\n  async show(sendImmediately = true) {\n    _console.log(\"showDisplay\");\n    this.#isReady = false;\n    this.#lastShowRequestTime = Date.now();\n    await this.#sendContextCommand(\"show\", undefined, sendImmediately);\n  }\n  async clear(sendImmediately = true) {\n    _console.log(\"clearDisplay\");\n    this.#isReady = false;\n    this.#lastShowRequestTime = Date.now();\n    await this.#sendContextCommand(\"clear\", undefined, sendImmediately);\n  }\n\n  assertValidColorIndex(colorIndex: number) {\n    _console.assertRangeWithError(\n      \"colorIndex\",\n      colorIndex,\n      0,\n      this.numberOfColors\n    );\n  }\n  #colors: string[] = [];\n  get colors() {\n    return this.#colors;\n  }\n  async setColor(\n    colorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    let colorRGB: DisplayColorRGB;\n    if (typeof color == \"string\") {\n      colorRGB = stringToRGB(color);\n    } else {\n      colorRGB = color;\n    }\n    const colorHex = rgbToHex(colorRGB);\n    if (this.colors[colorIndex] == colorHex) {\n      _console.log(`redundant color #${colorIndex} ${colorHex}`);\n      return;\n    }\n\n    //_console.log(`setting color #${colorIndex}`, colorRGB);\n    this.assertValidColorIndex(colorIndex);\n    assertValidColor(colorRGB);\n    const dataView = new DataView(new ArrayBuffer(4));\n    dataView.setUint8(0, colorIndex);\n    dataView.setUint8(1, colorRGB.r);\n    dataView.setUint8(2, colorRGB.g);\n    dataView.setUint8(3, colorRGB.b);\n    await this.#sendContextCommand(\n      \"setColor\",\n      dataView.buffer,\n      sendImmediately\n    );\n    this.colors[colorIndex] = colorHex;\n    this.#dispatchEvent(\"displayColor\", {\n      colorIndex,\n      colorRGB,\n      colorHex,\n    });\n  }\n  #opacities: number[] = [];\n  get opacities() {\n    return this.#opacities;\n  }\n  async setColorOpacity(\n    colorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"setColorOpacity\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      colorIndex,\n      opacity,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#opacities[colorIndex] = opacity;\n    this.#dispatchEvent(\"displayColorOpacity\", { colorIndex, opacity });\n  }\n  async setOpacity(opacity: number, sendImmediately?: boolean) {\n    const commandType: DisplayContextCommandType = \"setOpacity\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      opacity,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#opacities.fill(opacity);\n    this.#dispatchEvent(\"displayOpacity\", { opacity });\n  }\n\n  #contextStack: DisplayContextState[] = [];\n  #saveContext(sendImmediately?: boolean) {\n    this.#contextStack.push(structuredClone(this.contextState));\n  }\n  #restoreContext(sendImmediately?: boolean) {\n    const contextState = this.#contextStack.pop();\n    if (!contextState) {\n      _console.warn(\"#contextStack empty\");\n      return;\n    }\n    this.setContextState(contextState, sendImmediately);\n  }\n  async saveContext(sendImmediately?: boolean) {\n    if (true) {\n      this.#saveContext(sendImmediately);\n    } else {\n      // const commandType: DisplayContextCommandType = \"saveContext\";\n      // const dataView = serializeContextCommand(this, { type: commandType });\n      // await this.#sendDisplayContextCommand(\n      //   commandType,\n      //   dataView?.buffer,\n      //   sendImmediately\n      // );\n    }\n  }\n  async restoreContext(sendImmediately?: boolean) {\n    if (true) {\n      this.#restoreContext(sendImmediately);\n    } else {\n      // const commandType: DisplayContextCommandType = \"restoreContext\";\n      // const dataView = serializeContextCommand(this, { type: commandType });\n      // await this.#sendDisplayContextCommand(\n      //   commandType,\n      //   dataView?.buffer,\n      //   sendImmediately\n      // );\n    }\n  }\n\n  async selectFillColor(fillColorIndex: number, sendImmediately?: boolean) {\n    this.assertValidColorIndex(fillColorIndex);\n    const differences = this.#contextStateHelper.update({\n      fillColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"selectFillColor\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      fillColorIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async selectBackgroundColor(\n    backgroundColorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(backgroundColorIndex);\n    const differences = this.#contextStateHelper.update({\n      backgroundColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"selectBackgroundColor\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      backgroundColorIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async selectLineColor(lineColorIndex: number, sendImmediately?: boolean) {\n    this.assertValidColorIndex(lineColorIndex);\n    const differences = this.#contextStateHelper.update({\n      lineColorIndex,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"selectLineColor\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      lineColorIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setIgnoreFill(ignoreFill: boolean, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      ignoreFill,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setIgnoreFill\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      ignoreFill,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setIgnoreLine(ignoreLine: boolean, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      ignoreLine,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setIgnoreLine\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      ignoreLine,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setFillBackground(fillBackground: boolean, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      fillBackground,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setFillBackground\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      fillBackground,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  assertValidLineWidth(lineWidth: number) {\n    _console.assertRangeWithError(\n      \"lineWidth\",\n      lineWidth,\n      0,\n      Math.max(this.width, this.height)\n    );\n  }\n  async setLineWidth(lineWidth: number, sendImmediately?: boolean) {\n    this.assertValidLineWidth(lineWidth);\n    const differences = this.#contextStateHelper.update({\n      lineWidth,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setLineWidth\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      lineWidth,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setAlignment(\n    alignmentDirection: DisplayAlignmentDirection,\n    alignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    assertValidAlignmentDirection(alignmentDirection);\n    const alignmentCommand =\n      DisplayAlignmentDirectionToCommandType[alignmentDirection];\n    const alignmentKey =\n      DisplayAlignmentDirectionToStateKey[alignmentDirection];\n    const differences = this.#contextStateHelper.update({\n      [alignmentKey]: alignment,\n    });\n    _console.log({ alignmentKey, alignment, differences });\n    if (differences.length == 0) {\n      return;\n    }\n    // @ts-ignore\n    const dataView = serializeContextCommand(this, {\n      type: alignmentCommand,\n      [alignmentKey]: alignment,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      alignmentCommand,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setHorizontalAlignment(\n    horizontalAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    await this.setAlignment(\"horizontal\", horizontalAlignment, sendImmediately);\n  }\n  async setVerticalAlignment(\n    verticalAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    await this.setAlignment(\"vertical\", verticalAlignment, sendImmediately);\n  }\n  async resetAlignment(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      verticalAlignment: DefaultDisplayContextState.verticalAlignment,\n      horizontalAlignment: DefaultDisplayContextState.horizontalAlignment,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"resetAlignment\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setRotation(\n    rotation: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    rotation = isRadians ? rotation : degToRad(rotation);\n    rotation = normalizeRadians(rotation);\n    isRadians = true;\n    const differences = this.#contextStateHelper.update({\n      rotation,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setRotation\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      rotation,\n      isRadians,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n\n    this.#onContextStateUpdate(differences);\n  }\n  async clearRotation(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotation: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"clearRotation\";\n    const dataView = serializeContextCommand(this, { type: commandType });\n    await this.#sendContextCommand(\n      commandType,\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSegmentStartCap(\n    segmentStartCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentStartCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setSegmentStartCap\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      segmentStartCap,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndCap(\n    segmentEndCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentEndCap);\n    const differences = this.#contextStateHelper.update({\n      segmentEndCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setSegmentEndCap\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      segmentEndCap,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentCap(\n    segmentCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap: segmentCap,\n      segmentEndCap: segmentCap,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setSegmentCap\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      segmentCap,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSegmentStartRadius(\n    segmentStartRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setSegmentStartRadius\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      segmentStartRadius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndRadius(\n    segmentEndRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentEndRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setSegmentEndRadius\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      segmentEndRadius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentRadius(segmentRadius: number, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius: segmentRadius,\n      segmentEndRadius: segmentRadius,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setSegmentRadius\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      segmentRadius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    crop = Math.max(0, crop);\n    const cropCommand = DisplayCropDirectionToCommandType[cropDirection];\n    const cropKey = DisplayCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // @ts-ignore\n    const dataView = serializeContextCommand(this, {\n      type: cropCommand,\n      [cropKey]: crop,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      cropCommand,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setCropTop(cropTop: number, sendImmediately?: boolean) {\n    await this.setCrop(\"top\", cropTop, sendImmediately);\n  }\n  async setCropRight(cropRight: number, sendImmediately?: boolean) {\n    await this.setCrop(\"right\", cropRight, sendImmediately);\n  }\n  async setCropBottom(cropBottom: number, sendImmediately?: boolean) {\n    await this.setCrop(\"bottom\", cropBottom, sendImmediately);\n  }\n  async setCropLeft(cropLeft: number, sendImmediately?: boolean) {\n    await this.setCrop(\"left\", cropLeft, sendImmediately);\n  }\n  async clearCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      cropTop: 0,\n      cropRight: 0,\n      cropBottom: 0,\n      cropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"clearCrop\";\n    const dataView = serializeContextCommand(this, { type: commandType });\n    await this.#sendContextCommand(\n      commandType,\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setRotationCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    const cropCommand =\n      DisplayRotationCropDirectionToCommandType[cropDirection];\n    const cropKey = DisplayRotationCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // @ts-ignore\n    const dataView = serializeContextCommand(this, {\n      type: cropCommand,\n      [cropKey]: crop,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      cropCommand,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setRotationCropTop(rotationCropTop: number, sendImmediately?: boolean) {\n    await this.setRotationCrop(\"top\", rotationCropTop, sendImmediately);\n  }\n  async setRotationCropRight(\n    rotationCropRight: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"right\", rotationCropRight, sendImmediately);\n  }\n  async setRotationCropBottom(\n    rotationCropBottom: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"bottom\", rotationCropBottom, sendImmediately);\n  }\n  async setRotationCropLeft(\n    rotationCropLeft: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"left\", rotationCropLeft, sendImmediately);\n  }\n  async clearRotationCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotationCropTop: 0,\n      rotationCropRight: 0,\n      rotationCropBottom: 0,\n      rotationCropLeft: 0,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"clearRotationCrop\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n    });\n    await this.#sendContextCommand(\n      commandType,\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async selectBitmapColor(\n    bitmapColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(bitmapColorIndex);\n    this.assertValidColorIndex(colorIndex);\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"selectBitmapColor\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      bitmapColorIndex,\n      colorIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  get bitmapColorIndices() {\n    return this.contextState.bitmapColorIndices;\n  }\n  get bitmapColors() {\n    return this.bitmapColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  async selectBitmapColors(\n    bitmapColorPairs: DisplayBitmapColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"bitmapColors\",\n      bitmapColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n      this.assertValidColorIndex(bitmapColorIndex);\n      this.assertValidColorIndex(colorIndex);\n      bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    });\n\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"selectBitmapColors\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      bitmapColorPairs,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setBitmapColor(\n    bitmapColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.bitmapColorIndices[bitmapColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setBitmapColorOpacity(\n    bitmapColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.bitmapColorIndices[bitmapColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n  async setBitmapScaleDirection(\n    direction: DisplayScaleDirection,\n    bitmapScale: number,\n    sendImmediately?: boolean\n  ) {\n    bitmapScale = clamp(bitmapScale, minDisplayScale, maxDisplayScale);\n    bitmapScale = roundScale(bitmapScale);\n    const commandType = DisplayBitmapScaleDirectionToCommandType[direction];\n    _console.log({ [commandType]: bitmapScale });\n    const newState: PartialDisplayContextState = {};\n    let command: DisplayContextCommand;\n    switch (direction) {\n      case \"all\":\n        newState.bitmapScaleX = bitmapScale;\n        newState.bitmapScaleY = bitmapScale;\n        command = { type: \"setBitmapScale\", bitmapScale };\n        break;\n      case \"x\":\n        newState.bitmapScaleX = bitmapScale;\n        command = { type: \"setBitmapScaleX\", bitmapScaleX: bitmapScale };\n        break;\n      case \"y\":\n        newState.bitmapScaleY = bitmapScale;\n        command = { type: \"setBitmapScaleY\", bitmapScaleY: bitmapScale };\n        break;\n    }\n    const differences = this.#contextStateHelper.update(newState);\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, command);\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n\n    this.#onContextStateUpdate(differences);\n  }\n  async setBitmapScaleX(bitmapScaleX: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"x\", bitmapScaleX, sendImmediately);\n  }\n  async setBitmapScaleY(bitmapScaleY: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"y\", bitmapScaleY, sendImmediately);\n  }\n  async setBitmapScale(bitmapScale: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"all\", bitmapScale, sendImmediately);\n  }\n  async resetBitmapScale(sendImmediately?: boolean) {\n    //return this.setBitmapScaleDirection(\"all\", 1, sendImmediately);\n\n    const differences = this.#contextStateHelper.update({\n      bitmapScaleX: 1,\n      bitmapScaleY: 1,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"resetBitmapScale\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n    });\n    await this.#sendContextCommand(\n      commandType,\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async selectSpriteColor(\n    spriteColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(spriteColorIndex);\n    this.assertValidColorIndex(colorIndex);\n    const spriteColorIndices = this.contextState.spriteColorIndices.slice();\n    spriteColorIndices[spriteColorIndex] = colorIndex;\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"selectSpriteColor\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      spriteColorIndex,\n      colorIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  get spriteColorIndices() {\n    return this.contextState.spriteColorIndices;\n  }\n  get spriteColors() {\n    return this.spriteColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  async selectSpriteColors(\n    spriteColorPairs: DisplaySpriteColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"spriteColors\",\n      spriteColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const spriteColorIndices = this.contextState.spriteColorIndices.slice();\n    spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {\n      this.assertValidColorIndex(spriteColorIndex);\n      this.assertValidColorIndex(colorIndex);\n      spriteColorIndices[spriteColorIndex] = colorIndex;\n    });\n\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"selectSpriteColors\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      spriteColorPairs,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpriteColor(\n    spriteColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.spriteColorIndices[spriteColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setSpriteColorOpacity(\n    spriteColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.spriteColorIndices[spriteColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n\n  async resetSpriteColors(sendImmediately?: boolean) {\n    const spriteColorIndices = new Array(this.numberOfColors).fill(0);\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"resetSpriteColors\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n    });\n    await this.#sendContextCommand(\n      commandType,\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpriteScaleDirection(\n    direction: DisplayScaleDirection,\n    spriteScale: number,\n    sendImmediately?: boolean\n  ) {\n    spriteScale = clamp(spriteScale, minDisplayScale, maxDisplayScale);\n    spriteScale = roundScale(spriteScale);\n    const commandType = DisplaySpriteScaleDirectionToCommandType[direction];\n    _console.log({ [commandType]: spriteScale, direction });\n    const newState: PartialDisplayContextState = {};\n    let command: DisplayContextCommand;\n    switch (direction) {\n      case \"all\":\n        newState.spriteScaleX = spriteScale;\n        newState.spriteScaleY = spriteScale;\n        command = { type: \"setSpriteScale\", spriteScale };\n        break;\n      case \"x\":\n        newState.spriteScaleX = spriteScale;\n        command = { type: \"setSpriteScaleX\", spriteScaleX: spriteScale };\n        break;\n      case \"y\":\n        newState.spriteScaleY = spriteScale;\n        command = { type: \"setSpriteScaleY\", spriteScaleY: spriteScale };\n        break;\n    }\n    const differences = this.#contextStateHelper.update(newState);\n    if (differences.length == 0) {\n      return;\n    }\n    const dataView = serializeContextCommand(this, command);\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpriteScaleX(spriteScaleX: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"x\", spriteScaleX, sendImmediately);\n  }\n  async setSpriteScaleY(spriteScaleY: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"y\", spriteScaleY, sendImmediately);\n  }\n  async setSpriteScale(spriteScale: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"all\", spriteScale, sendImmediately);\n  }\n  async resetSpriteScale(sendImmediately?: boolean) {\n    //return this.setSpriteScaleDirection(\"all\", 1, sendImmediately);\n\n    const differences = this.#contextStateHelper.update({\n      spriteScaleX: 1,\n      spriteScaleY: 1,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"resetSpriteScale\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n    });\n    await this.#sendContextCommand(\n      commandType,\n      dataView?.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpritesLineHeight(\n    spritesLineHeight: number,\n    sendImmediately?: boolean\n  ) {\n    spritesLineHeight = Math.round(spritesLineHeight);\n    this.assertValidLineWidth(spritesLineHeight);\n    const differences = this.#contextStateHelper.update({\n      spritesLineHeight,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const commandType: DisplayContextCommandType = \"setSpritesLineHeight\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      spritesLineHeight,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpritesDirectionGeneric(\n    direction: DisplayDirection,\n    isOrthogonal: boolean,\n    sendImmediately?: boolean\n  ) {\n    assertValidDirection(direction);\n    const stateKey: DisplayContextStateKey = isOrthogonal\n      ? \"spritesLineDirection\"\n      : \"spritesDirection\";\n    const commandType: DisplayContextCommandType = isOrthogonal\n      ? \"setSpritesLineDirection\"\n      : \"setSpritesDirection\";\n\n    const differences = this.#contextStateHelper.update({\n      [stateKey]: direction,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // @ts-expect-error\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      [stateKey]: direction,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpritesDirection(\n    spritesDirection: DisplayDirection,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesDirectionGeneric(\n      spritesDirection,\n      false,\n      sendImmediately\n    );\n  }\n  async setSpritesLineDirection(\n    spritesLineDirection: DisplayDirection,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesDirectionGeneric(\n      spritesLineDirection,\n      true,\n      sendImmediately\n    );\n  }\n\n  async setSpritesSpacingGeneric(\n    spacing: number,\n    isOrthogonal: boolean,\n    sendImmediately?: boolean\n  ) {\n    const stateKey: DisplayContextStateKey = isOrthogonal\n      ? \"spritesLineSpacing\"\n      : \"spritesSpacing\";\n    const commandType: DisplayContextCommandType = isOrthogonal\n      ? \"setSpritesLineSpacing\"\n      : \"setSpritesSpacing\";\n\n    const differences = this.#contextStateHelper.update({\n      [stateKey]: spacing,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // @ts-expect-error\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      [stateKey]: spacing,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpritesSpacing(spritesSpacing: number, sendImmediately?: boolean) {\n    await this.setSpritesSpacingGeneric(spritesSpacing, false, sendImmediately);\n  }\n  async setSpritesLineSpacing(\n    spritesSpacing: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesSpacingGeneric(spritesSpacing, true, sendImmediately);\n  }\n\n  async setSpritesAlignmentGeneric(\n    alignment: DisplayAlignment,\n    isOrthogonal: boolean,\n    sendImmediately?: boolean\n  ) {\n    assertValidAlignment(alignment);\n    const stateKey: DisplayContextStateKey = isOrthogonal\n      ? \"spritesLineAlignment\"\n      : \"spritesAlignment\";\n    const commandType: DisplayContextCommandType = isOrthogonal\n      ? \"setSpritesLineAlignment\"\n      : \"setSpritesAlignment\";\n    const differences = this.#contextStateHelper.update({\n      [stateKey]: alignment,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    // @ts-expect-error\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      [stateKey]: alignment,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpritesAlignment(\n    spritesAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesAlignmentGeneric(\n      spritesAlignment,\n      false,\n      sendImmediately\n    );\n  }\n  async setSpritesLineAlignment(\n    spritesLineAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesAlignmentGeneric(\n      spritesLineAlignment,\n      true,\n      sendImmediately\n    );\n  }\n\n  async clearRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"clearRect\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      x,\n      y,\n      width,\n      height,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"drawRect\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      width,\n      height,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawRoundRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"drawRoundRect\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      width,\n      height,\n      borderRadius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawCircle(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"drawCircle\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      radius,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"drawEllipse\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      radiusX,\n      radiusY,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawRegularPolygon(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    numberOfSides: number,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"drawRegularPolygon\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      radius,\n      numberOfSides,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawPolygon(points: Vector2[], sendImmediately?: boolean) {\n    _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n    const commandType: DisplayContextCommandType = \"drawPolygon\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      points,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawWireframe(wireframe: DisplayWireframe, sendImmediately?: boolean) {\n    wireframe = trimWireframe(wireframe);\n    if (wireframe.points.length == 0) {\n      return;\n    }\n    assertValidWireframe(wireframe);\n    if (this.#contextStateHelper.isSegmentUniform) {\n      const polygon = isWireframePolygon(wireframe);\n      if (polygon) {\n        return this.drawSegments(polygon, sendImmediately);\n      }\n    }\n    const commandType: DisplayContextCommandType = \"drawWireframe\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      wireframe,\n    });\n    if (!dataView) {\n      return;\n    }\n    if (dataView.byteLength > this.#maxCommandDataLength) {\n      _console.error(\n        `wireframe data ${dataView.byteLength} too large (max ${\n          this.#maxCommandDataLength\n        })`\n      );\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawCurve(\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    assertValidNumberOfControlPoints(curveType, controlPoints);\n    const commandType: DisplayContextCommandType =\n      curveType == \"cubic\"\n        ? \"drawCubicBezierCurve\"\n        : \"drawQuadraticBezierCurve\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      controlPoints,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawCurves(\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    assertValidPathNumberOfControlPoints(curveType, controlPoints);\n    const commandType: DisplayContextCommandType =\n      curveType == \"cubic\"\n        ? \"drawCubicBezierCurves\"\n        : \"drawQuadraticBezierCurves\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      controlPoints,\n    });\n    if (!dataView) {\n      return;\n    }\n    if (dataView.byteLength > this.#maxCommandDataLength) {\n      _console.error(\n        `curve data ${dataView.byteLength} too large (max ${\n          this.#maxCommandDataLength\n        })`\n      );\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawQuadraticBezierCurve(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    await this.drawCurve(\"quadratic\", controlPoints, sendImmediately);\n  }\n  async drawQuadraticBezierCurves(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    await this.drawCurves(\"quadratic\", controlPoints, sendImmediately);\n  }\n\n  async drawCubicBezierCurve(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    await this.drawCurve(\"cubic\", controlPoints, sendImmediately);\n  }\n  async drawCubicBezierCurves(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    await this.drawCurves(\"cubic\", controlPoints, sendImmediately);\n  }\n\n  async _drawPath(\n    isClosed: boolean,\n    curves: DisplayBezierCurve[],\n    sendImmediately?: boolean\n  ) {\n    assertValidPath(curves);\n\n    const commandType: DisplayContextCommandType = isClosed\n      ? \"drawClosedPath\"\n      : \"drawPath\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      curves,\n    });\n    if (!dataView) {\n      return;\n    }\n    if (dataView.byteLength > this.#maxCommandDataLength) {\n      _console.error(\n        `path data ${dataView.byteLength} too large (max ${\n          this.#maxCommandDataLength\n        })`\n      );\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawPath(curves: DisplayBezierCurve[], sendImmediately?: boolean) {\n    await this._drawPath(false, curves, sendImmediately);\n  }\n  async drawClosedPath(\n    curves: DisplayBezierCurve[],\n    sendImmediately?: boolean\n  ) {\n    await this._drawPath(true, curves, sendImmediately);\n  }\n\n  async drawSegment(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"drawSegment\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      startX,\n      startY,\n      endX,\n      endY,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawSegments(points: Vector2[], sendImmediately?: boolean) {\n    _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n    const commandType: DisplayContextCommandType = \"drawSegments\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      points,\n    });\n    if (!dataView) {\n      return;\n    }\n    if (dataView.byteLength > this.#maxCommandDataLength) {\n      const mid = Math.floor(points.length / 2);\n      const firstHalf = points.slice(0, mid + 1);\n      const secondHalf = points.slice(mid);\n      _console.log({ firstHalf, secondHalf });\n      _console.log(\"sending first half\", firstHalf);\n      await this.drawSegments(firstHalf, false);\n      _console.log(\"sending second half\", secondHalf);\n      await this.drawSegments(secondHalf, sendImmediately);\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawArc(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"drawArc\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      radius,\n      startAngle,\n      angleOffset,\n      isRadians,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async drawArcEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    const commandType: DisplayContextCommandType = \"drawArcEllipse\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      radiusX,\n      radiusY,\n      startAngle,\n      angleOffset,\n      isRadians,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  assertValidNumberOfColors(numberOfColors: number) {\n    _console.assertRangeWithError(\n      \"numberOfColors\",\n      numberOfColors,\n      2,\n      this.numberOfColors\n    );\n  }\n\n  assertValidBitmap(bitmap: DisplayBitmap, checkSize?: boolean) {\n    this.assertValidNumberOfColors(bitmap.numberOfColors);\n    assertValidBitmapPixels(bitmap);\n    if (checkSize) {\n      this.#assertValidBitmapSize(bitmap);\n    }\n  }\n  #assertValidBitmapSize(bitmap: DisplayBitmap) {\n    const pixelDataLength = getBitmapNumberOfBytes(bitmap);\n    _console.assertRangeWithError(\n      \"bitmap.pixels.length\",\n      pixelDataLength,\n      1,\n      this.#maxCommandDataLength - drawBitmapHeaderLength\n    );\n  }\n  async drawBitmap(\n    offsetX: number,\n    offsetY: number,\n    bitmap: DisplayBitmap,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidBitmap(bitmap, true);\n    const commandType: DisplayContextCommandType = \"drawBitmap\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      bitmap,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async imageToBitmap(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors?: number\n  ) {\n    return imageToBitmap(\n      image,\n      width,\n      height,\n      this.colors,\n      this.bitmapColorIndices,\n      numberOfColors\n    );\n  }\n  async quantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number\n  ) {\n    return quantizeImage(image, width, height, numberOfColors);\n  }\n  async resizeAndQuantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number,\n    colors?: string[]\n  ) {\n    return resizeAndQuantizeImage(image, width, height, numberOfColors, colors);\n  }\n\n  // CONTEXT COMMANDS\n\n  async runContextCommand(\n    command: DisplayContextCommand,\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommand(this, command, sendImmediately);\n  }\n  async runContextCommands(\n    commands: DisplayContextCommand[],\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommands(this, commands, sendImmediately);\n  }\n\n  #isReady = true;\n  get isReady() {\n    return this.isAvailable && this.#isReady;\n  }\n  #lastReadyTime = 0;\n  #lastShowRequestTime = 0;\n  #minReadyInterval = 60; // Forced delay due to Frame's fpga timing...\n  #waitBeforeReady = true;\n  async #parseDisplayReady(dataView: DataView<ArrayBuffer>) {\n    const now = Date.now();\n    const timeSinceLastDraw = now - this.#lastShowRequestTime;\n    const timeSinceLastReady = now - this.#lastReadyTime;\n    //_console.log(`${timeSinceLastReady}ms since last render`);\n    _console.log(`${timeSinceLastDraw}ms draw time`);\n    if (this.#waitBeforeReady && timeSinceLastReady < this.#minReadyInterval) {\n      const timeToWait = this.#minReadyInterval - timeSinceLastReady;\n      _console.log(`waiting ${timeToWait}ms`);\n      await wait(timeToWait);\n    }\n    this.#isReady = true;\n    this.#lastReadyTime = Date.now();\n    this.#dispatchEvent(\"displayReady\", {});\n  }\n\n  // SPRITE SHEET\n  #spriteSheets: Record<string, DisplaySpriteSheet> = {};\n  #spriteSheetIndices: Record<string, number> = {};\n  get spriteSheets() {\n    return this.#spriteSheets;\n  }\n  get spriteSheetIndices() {\n    return this.#spriteSheetIndices;\n  }\n  async #setSpriteSheetName(\n    spriteSheetName: string,\n    sendImmediately?: boolean\n  ) {\n    if (typeof spriteSheetName == \"number\") {\n      // @ts-expect-error\n      spriteSheetName = spriteSheetName.toString();\n    }\n    _console.assertTypeWithError(spriteSheetName, \"string\");\n    _console.assertRangeWithError(\n      \"newName\",\n      spriteSheetName.length,\n      MinSpriteSheetNameLength,\n      MaxSpriteSheetNameLength\n    );\n    const setSpriteSheetNameData = textEncoder.encode(spriteSheetName);\n    _console.log({ setSpriteSheetNameData });\n\n    const promise = this.waitForEvent(\"getSpriteSheetName\");\n    this.sendMessage(\n      [{ type: \"setSpriteSheetName\", data: setSpriteSheetNameData.buffer }],\n      sendImmediately\n    );\n    await promise;\n  }\n  #pendingSpriteSheet?: DisplaySpriteSheet;\n  get pendingSpriteSheet() {\n    return this.#pendingSpriteSheet;\n  }\n  #pendingSpriteSheetName?: string;\n  get pendingSpriteSheetName() {\n    return this.#pendingSpriteSheetName;\n  }\n  #updateSpriteSheetName(updatedSpriteSheetName: string) {\n    _console.assertTypeWithError(updatedSpriteSheetName, \"string\");\n    this.#pendingSpriteSheetName = updatedSpriteSheetName;\n    _console.log({ updatedSpriteSheetName: this.#pendingSpriteSheetName });\n    this.#dispatchEvent(\"getSpriteSheetName\", {\n      spriteSheetName: this.#pendingSpriteSheetName,\n    });\n  }\n  sendFile!: SendFileCallback;\n  serializeSpriteSheet(spriteSheet: DisplaySpriteSheet): ArrayBuffer {\n    return serializeSpriteSheet(this, spriteSheet);\n  }\n  async uploadSpriteSheet(spriteSheet: DisplaySpriteSheet) {\n    if (spriteSheet.sprites.length == 0) {\n      _console.log(\"no sprites in spriteSheet\");\n      return;\n    }\n    if (this.#pendingSpriteSheet) {\n      await this.waitForEvent(\"displaySpriteSheetUploadComplete\");\n      await this.uploadSpriteSheet(spriteSheet);\n      return;\n    }\n    spriteSheet = structuredClone(spriteSheet);\n    this.#pendingSpriteSheet = spriteSheet;\n    const buffer = this.serializeSpriteSheet(this.#pendingSpriteSheet);\n    await this.#setSpriteSheetName(this.#pendingSpriteSheet.name);\n    const promise = this.waitForEvent(\"displaySpriteSheetUploadComplete\");\n    this.sendFile(\"spriteSheet\", buffer, true);\n    await promise;\n  }\n  async uploadSpriteSheets(spriteSheets: DisplaySpriteSheet[]) {\n    for (const spriteSheet of spriteSheets) {\n      await this.uploadSpriteSheet(spriteSheet);\n    }\n  }\n  assertLoadedSpriteSheet(spriteSheetName: string) {\n    assertLoadedSpriteSheet(this, spriteSheetName);\n  }\n  assertSelectedSpriteSheet(spriteSheetName: string) {\n    assertSelectedSpriteSheet(this, spriteSheetName);\n  }\n  assertAnySelectedSpriteSheet() {\n    assertAnySelectedSpriteSheet(this);\n  }\n  assertSprite(spriteName: string) {\n    return assertSprite(this, spriteName);\n  }\n  getSprite(spriteName: string): DisplaySprite | undefined {\n    return getSprite(this, spriteName);\n  }\n  getSpriteSheetPalette(\n    paletteName: string\n  ): DisplaySpriteSheetPalette | undefined {\n    return getSpriteSheetPalette(this, paletteName);\n  }\n  getSpriteSheetPaletteSwap(\n    paletteSwapName: string\n  ): DisplaySpriteSheetPaletteSwap | undefined {\n    return getSpriteSheetPaletteSwap(this, paletteSwapName);\n  }\n  getSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string\n  ): DisplaySpritePaletteSwap | undefined {\n    return getSpritePaletteSwap(this, spriteName, paletteSwapName);\n  }\n\n  get selectedSpriteSheet() {\n    if (this.contextState.spriteSheetName) {\n      return this.#spriteSheets[this.contextState.spriteSheetName];\n    }\n  }\n  get selectedSpriteSheetName() {\n    return this.selectedSpriteSheet?.name;\n  }\n  async selectSpriteSheet(spriteSheetName: string, sendImmediately?: boolean) {\n    this.assertLoadedSpriteSheet(spriteSheetName);\n    const differences = this.#contextStateHelper.update({\n      spriteSheetName,\n    });\n    if (differences.length == 0) {\n      return;\n    }\n    const spriteSheetIndex = this.spriteSheetIndices[spriteSheetName];\n    //_console.log(\"selecting\", { spriteSheetIndex, spriteSheetName });\n    const commandType: DisplayContextCommandType = \"selectSpriteSheet\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      spriteSheetIndex,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n    this.#onContextStateUpdate(differences);\n  }\n  async drawSprite(\n    offsetX: number,\n    offsetY: number,\n    spriteName: string,\n    sendImmediately?: boolean\n  ) {\n    _console.assertWithError(\n      this.selectedSpriteSheet,\n      \"no spriteSheet selected\"\n    );\n    _console.log(\n      `drawing sprite \"${spriteName}\" in selectedSpriteSheet`,\n      this.selectedSpriteSheet\n    );\n    let spriteIndex = this.selectedSpriteSheet!.sprites.findIndex(\n      (sprite) => sprite.name == spriteName\n    );\n    _console.assertWithError(\n      spriteIndex != -1,\n      `sprite \"${spriteName}\" not found in spriteSheet`\n    );\n    spriteIndex = spriteIndex!;\n    const commandType: DisplayContextCommandType = \"drawSprite\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      spriteIndex,\n      use2Bytes: this.selectedSpriteSheet!.sprites.length > 255,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawSprites(\n    offsetX: number,\n    offsetY: number,\n    spriteLines: DisplaySpriteLines,\n    sendImmediately?: boolean\n  ) {\n    _console.assertWithError(\n      this.contextState.spritesLineHeight > 0,\n      `spritesLineHeight must be >0`\n    );\n    const spriteSerializedLines = spriteLinesToSerializedLines(\n      this,\n      spriteLines\n    );\n    _console.log(\"spriteSerializedLines\", spriteSerializedLines);\n    const commandType: DisplayContextCommandType = \"drawSprites\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      spriteSerializedLines: spriteSerializedLines,\n    });\n    if (!dataView) {\n      return;\n    }\n    if (dataView.byteLength > this.#maxCommandDataLength) {\n      _console.log(\"breaking up sprites...\");\n      const mid = Math.floor(spriteLines.length / 2);\n      const firstHalf = spriteLines.slice(0, mid);\n      const secondHalf = spriteLines.slice(mid);\n      // _console.log({ firstHalf, secondHalf });\n\n      let firstHalfOffsetX = offsetX;\n      let firstHalfOffsetY = offsetY;\n      let secondHalfOffsetX = offsetX;\n      let secondHalfOffsetY = offsetY;\n\n      let didStartSprite = false;\n      if (!this.#isDrawingBlankSprite) {\n        didStartSprite = true;\n\n        const { localSize } = getSpriteLinesMetrics(\n          spriteLines,\n          this.spriteSheets,\n          this.contextState\n        );\n\n        const {\n          spritesLineHeight,\n          spritesDirection,\n          spritesLineDirection,\n          spritesAlignment,\n          spritesLineAlignment,\n          spritesLineSpacing,\n          spritesSpacing,\n          horizontalAlignment,\n          verticalAlignment,\n        } = this.contextState;\n        _console.log(\"starting sprites sprite...\");\n        await this.startSprite(\n          offsetX,\n          offsetY,\n          localSize.width,\n          localSize.height,\n          false\n        );\n        await this.setSpritesLineHeight(spritesLineHeight, false);\n        await this.setSpritesDirection(spritesDirection, false);\n        await this.setSpritesLineDirection(spritesLineDirection, false);\n        await this.setSpritesAlignment(spritesAlignment, false);\n        await this.setSpritesLineAlignment(spritesLineAlignment, false);\n        await this.setSpritesSpacing(spritesSpacing, false);\n        await this.setSpritesLineSpacing(spritesLineSpacing, false);\n        await this.setHorizontalAlignment(horizontalAlignment, false);\n        await this.setVerticalAlignment(verticalAlignment, false);\n\n        switch (horizontalAlignment) {\n          case \"start\":\n            firstHalfOffsetX = -localSize.width / 2;\n            break;\n          case \"center\":\n            firstHalfOffsetX = -localSize.width / 4;\n            break;\n          case \"end\":\n            firstHalfOffsetX = 0;\n            break;\n        }\n\n        switch (verticalAlignment) {\n          case \"start\":\n            firstHalfOffsetY = -localSize.height / 2;\n            break;\n          case \"center\":\n            firstHalfOffsetY = -localSize.height / 4;\n            break;\n          case \"end\":\n            firstHalfOffsetY = 0;\n            break;\n        }\n\n        secondHalfOffsetX = firstHalfOffsetX;\n        secondHalfOffsetY = firstHalfOffsetY;\n      }\n\n      _console.log(\"sending first half sprites\", firstHalf);\n      await this.drawSprites(\n        firstHalfOffsetX,\n        firstHalfOffsetY,\n        firstHalf,\n        false\n      );\n\n      const { localSize: firstHalfSize } = getSpriteLinesMetrics(\n        firstHalf,\n        this.#spriteSheets,\n        this.contextState\n      );\n\n      const isSpritesLineDirectionPositive = isDirectionPositive(\n        this.contextState.spritesLineDirection\n      );\n\n      const isSpritesLineDirectionHorizontal = isDirectionHorizontal(\n        this.contextState.spritesLineDirection\n      );\n\n      const sign = isSpritesLineDirectionPositive ? 1 : -1;\n      if (isSpritesLineDirectionHorizontal) {\n        secondHalfOffsetX += firstHalfSize.width * sign;\n      } else {\n        secondHalfOffsetY += firstHalfSize.height * sign;\n      }\n\n      _console.log(\"sending second half sprites\", secondHalf);\n      await this.drawSprites(\n        secondHalfOffsetX,\n        secondHalfOffsetY,\n        secondHalf,\n        false\n      );\n      if (didStartSprite) {\n        _console.log(\"ending sprites sprite...\");\n        await this.endSprite(sendImmediately);\n      }\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n\n  async drawSpritesString(\n    offsetX: number,\n    offsetY: number,\n    string: string,\n    requireAll?: boolean,\n    maxLineBreadth?: number,\n    separators?: string[],\n    sendImmediately?: boolean\n  ) {\n    const spriteLines = this.stringToSpriteLines(\n      string,\n      requireAll,\n      maxLineBreadth,\n      separators\n    );\n    await this.drawSprites(offsetX, offsetY, spriteLines, sendImmediately);\n  }\n  stringToSpriteLines(\n    string: string,\n    requireAll?: boolean,\n    maxLineBreadth?: number,\n    separators?: string[]\n  ): DisplaySpriteLines {\n    return stringToSpriteLines(\n      string,\n      this.spriteSheets,\n      this.contextState,\n      requireAll,\n      maxLineBreadth,\n      separators\n    );\n  }\n  stringToSpriteLinesMetrics(\n    string: string,\n    requireAll?: boolean,\n    maxLineBreadth?: number,\n    separators?: string[]\n  ) {\n    return stringToSpriteLinesMetrics(\n      string,\n      this.spriteSheets,\n      this.contextState,\n      requireAll,\n      maxLineBreadth,\n      separators\n    );\n  }\n\n  async drawSpriteFromSpriteSheet(\n    offsetX: number,\n    offsetY: number,\n    spriteName: string,\n    spriteSheet: DisplaySpriteSheet,\n    paletteName?: string,\n    sendImmediately?: boolean\n  ) {\n    return drawSpriteFromSpriteSheet(\n      this,\n      offsetX,\n      offsetY,\n      spriteName,\n      spriteSheet,\n      paletteName,\n      sendImmediately\n    );\n  }\n\n  #parseSpriteSheetIndex(dataView: DataView<ArrayBuffer>) {\n    const spriteSheetIndex = dataView.getUint8(0);\n    _console.log({\n      pendingSpriteSheet: this.#pendingSpriteSheet,\n      spriteSheetName: this.#pendingSpriteSheetName,\n      spriteSheetIndex,\n    });\n    if (this.isServerSide) {\n      return;\n    }\n    _console.assertWithError(\n      this.#pendingSpriteSheetName != undefined,\n      \"expected spriteSheetName when receiving spriteSheetIndex\"\n    );\n    _console.assertWithError(\n      this.#pendingSpriteSheet != undefined,\n      \"expected pendingSpriteSheet when receiving spriteSheetIndex\"\n    );\n    this.#spriteSheets[this.#pendingSpriteSheetName!] =\n      this.#pendingSpriteSheet!;\n    this.#spriteSheetIndices[this.#pendingSpriteSheetName!] = spriteSheetIndex;\n    _console.log(\n      `finished uploading \"${this.#pendingSpriteSheetName!}\" spriteSheet`\n    );\n    this.#dispatchEvent(\"displaySpriteSheetUploadComplete\", {\n      spriteSheetName: this.#pendingSpriteSheetName!,\n      spriteSheet: this.#pendingSpriteSheet!,\n    });\n    this.#pendingSpriteSheet = undefined;\n  }\n\n  // MESSAGE\n  parseMessage(\n    messageType: DisplayMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType, dataView });\n\n    switch (messageType) {\n      case \"isDisplayAvailable\":\n        this.#parseIsDisplayAvailable(dataView);\n        break;\n      case \"displayStatus\":\n        this.#parseDisplayStatus(dataView);\n        break;\n      case \"displayInformation\":\n        this.#parseDisplayInformation(dataView);\n        break;\n      case \"getDisplayBrightness\":\n      case \"setDisplayBrightness\":\n        this.#parseDisplayBrightness(dataView);\n        break;\n      case \"displayReady\":\n        this.#parseDisplayReady(dataView);\n        break;\n      case \"getSpriteSheetName\":\n      case \"setSpriteSheetName\":\n        const spriteSheetName = textDecoder.decode(\n          dataView.buffer as ArrayBuffer\n        );\n        _console.log({ spriteSheetName });\n        this.#updateSpriteSheetName(spriteSheetName);\n        break;\n      case \"spriteSheetIndex\":\n        this.#parseSpriteSheetIndex(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  // SPRITE SHEET PALETTES\n\n  assertSpriteSheetPalette(paletteName: string) {\n    assertSpriteSheetPalette(this, paletteName);\n  }\n  assertSpriteSheetPaletteSwap(paletteSwapName: string) {\n    assertSpriteSheetPaletteSwap(this, paletteSwapName);\n  }\n  assertSpritePaletteSwap(spriteName: string, paletteSwapName: string) {\n    assertSpritePaletteSwap(this, spriteName, paletteSwapName);\n  }\n  async selectSpriteSheetPalette(\n    paletteName: string,\n    offset?: number,\n    indicesOnly?: boolean,\n    sendImmediately?: boolean\n  ) {\n    await selectSpriteSheetPalette(\n      this,\n      paletteName,\n      offset,\n      indicesOnly,\n      sendImmediately\n    );\n  }\n  async selectSpriteSheetPaletteSwap(\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpriteSheetPaletteSwap(\n      this,\n      paletteSwapName,\n      offset,\n      sendImmediately\n    );\n  }\n  async selectSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpritePaletteSwap(\n      this,\n      spriteName,\n      paletteSwapName,\n      offset,\n      sendImmediately\n    );\n  }\n\n  #isDrawingBlankSprite = false;\n  async startSprite(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertWithError(\n      !this.#isDrawingBlankSprite,\n      `already drawing blank sprite`\n    );\n    this.#isDrawingBlankSprite = true;\n    this.#saveContext(sendImmediately);\n    this.#contextStateHelper.reset();\n    this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n\n    const commandType: DisplayContextCommandType = \"startSprite\";\n    const dataView = serializeContextCommand(this, {\n      type: commandType,\n      offsetX,\n      offsetY,\n      width,\n      height,\n    });\n    if (!dataView) {\n      return;\n    }\n    await this.#sendContextCommand(\n      commandType,\n      dataView.buffer,\n      sendImmediately\n    );\n  }\n  async endSprite(sendImmediately?: boolean) {\n    this.#restoreContext(sendImmediately);\n\n    _console.assertWithError(\n      this.#isDrawingBlankSprite,\n      `not drawing blank sprite`\n    );\n    this.#isDrawingBlankSprite = false;\n\n    // _console.log(\"endSprite\");\n    await this.#sendContextCommand(\"endSprite\", undefined, sendImmediately);\n  }\n\n  reset() {\n    _console.log(\"clearing displayManager\");\n    // @ts-ignore\n    this.#displayStatus = undefined;\n    this.#isAvailable = false;\n    this.#displayInformation = undefined;\n    // @ts-ignore\n    this.#brightness = undefined;\n    this.#contextCommandBuffers = [];\n    this.#isAvailable = false;\n\n    this.#contextStateHelper.reset();\n    this.#colors.length = 0;\n    this.#opacities.length = 0;\n\n    this.#isReady = true;\n    this.#pendingSpriteSheet = undefined;\n    this.#pendingSpriteSheetName = undefined;\n\n    this.isServerSide = false;\n\n    this.#isDrawingBlankSprite = false;\n\n    Object.keys(this.#spriteSheetIndices).forEach(\n      (spriteSheetName) => delete this.#spriteSheetIndices[spriteSheetName]\n    );\n    Object.keys(this.#spriteSheets).forEach(\n      (spriteSheetName) => delete this.#spriteSheets[spriteSheetName]\n    );\n  }\n\n  // MTU\n  #mtu!: number;\n  get mtu() {\n    return this.#mtu;\n  }\n  set mtu(newMtu: number) {\n    this.#mtu = newMtu;\n  }\n\n  // SERVER SIDE\n  #isServerSide = false;\n  get isServerSide() {\n    return this.#isServerSide;\n  }\n  set isServerSide(newIsServerSide) {\n    if (this.#isServerSide == newIsServerSide) {\n      //_console.log(\"redundant isServerSide assignment\");\n      return;\n    }\n    this.#isServerSide = newIsServerSide;\n    _console.log({ isServerSide: this.isServerSide });\n  }\n}\n\nexport default DisplayManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport { Timer } from \"../utils/Timer.ts\";\nimport { FileTransferMessageTypes } from \"../FileTransferManager.ts\";\nimport { TfliteMessageTypes } from \"../TfliteManager.ts\";\nimport { concatenateArrayBuffers } from \"../utils/ArrayBufferUtils.ts\";\nimport { parseMessage } from \"../utils/ParseUtils.ts\";\nimport { DeviceInformationTypes } from \"../DeviceInformationManager.ts\";\nimport { InformationMessageTypes } from \"../InformationManager.ts\";\nimport { VibrationMessageTypes } from \"../vibration/VibrationManager.ts\";\nimport { SensorConfigurationMessageTypes } from \"../sensor/SensorConfigurationManager.ts\";\nimport { SensorDataMessageTypes } from \"../sensor/SensorDataManager.ts\";\nimport { WifiMessageTypes } from \"../WifiManager.ts\";\nimport { CameraMessageTypes } from \"../CameraManager.ts\";\nimport { MicrophoneMessageTypes } from \"../MicrophoneManager.ts\";\nimport { DisplayMessageTypes } from \"../DisplayManager.ts\";\n\nconst _console = createConsole(\"BaseConnectionManager\", { log: false });\n\nexport const ConnectionTypes = [\n  \"webBluetooth\",\n  \"noble\",\n  \"client\",\n  \"webSocket\",\n  \"udp\",\n] as const;\nexport type ConnectionType = (typeof ConnectionTypes)[number];\n\nexport const ClientConnectionTypes = [\"noble\", \"webSocket\", \"udp\"] as const;\nexport type ClientConnectionType = (typeof ClientConnectionTypes)[number];\n\ninterface BaseConnectOptions {\n  type: \"client\" | \"webBluetooth\" | \"webSocket\" | \"udp\";\n}\nexport interface WebBluetoothConnectOptions extends BaseConnectOptions {\n  type: \"webBluetooth\";\n}\ninterface BaseWifiConnectOptions extends BaseConnectOptions {\n  ipAddress: string;\n}\nexport interface ClientConnectOptions extends BaseConnectOptions {\n  type: \"client\";\n  subType?: \"noble\" | \"webSocket\" | \"udp\";\n}\nexport interface WebSocketConnectOptions extends BaseWifiConnectOptions {\n  type: \"webSocket\";\n  isWifiSecure?: boolean;\n}\nexport interface UDPConnectOptions extends BaseWifiConnectOptions {\n  type: \"udp\";\n  //sendPort: number;\n  receivePort?: number;\n}\nexport type ConnectOptions =\n  | WebBluetoothConnectOptions\n  | WebSocketConnectOptions\n  | UDPConnectOptions\n  | ClientConnectOptions;\n\nexport const ConnectionStatuses = [\n  \"notConnected\",\n  \"connecting\",\n  \"connected\",\n  \"disconnecting\",\n] as const;\nexport type ConnectionStatus = (typeof ConnectionStatuses)[number];\n\nexport const ConnectionEventTypes = [\n  ...ConnectionStatuses,\n  \"connectionStatus\",\n  \"isConnected\",\n] as const;\nexport type ConnectionEventType = (typeof ConnectionEventTypes)[number];\n\nexport interface ConnectionStatusEventMessages {\n  notConnected: any;\n  connecting: any;\n  connected: any;\n  disconnecting: any;\n  connectionStatus: { connectionStatus: ConnectionStatus };\n  isConnected: { isConnected: boolean };\n}\n\nexport interface TxMessage {\n  type: TxRxMessageType;\n  data?: ArrayBuffer;\n}\n\nexport const TxRxMessageTypes = [\n  ...InformationMessageTypes,\n  ...SensorConfigurationMessageTypes,\n  ...SensorDataMessageTypes,\n  ...VibrationMessageTypes,\n  ...FileTransferMessageTypes,\n  ...TfliteMessageTypes,\n  ...WifiMessageTypes,\n  ...CameraMessageTypes,\n  ...MicrophoneMessageTypes,\n  ...DisplayMessageTypes,\n] as const;\nexport type TxRxMessageType = (typeof TxRxMessageTypes)[number];\n\nexport const SMPMessageTypes = [\"smp\"] as const;\nexport type SMPMessageType = (typeof SMPMessageTypes)[number];\n\nexport const BatteryLevelMessageTypes = [\"batteryLevel\"] as const;\nexport type BatteryLevelMessageType = (typeof BatteryLevelMessageTypes)[number];\n\nexport const MetaConnectionMessageTypes = [\"rx\", \"tx\"] as const;\nexport type MetaConnectionMessageType =\n  (typeof MetaConnectionMessageTypes)[number];\n\nexport const ConnectionMessageTypes = [\n  ...BatteryLevelMessageTypes,\n  ...DeviceInformationTypes,\n  ...MetaConnectionMessageTypes,\n  ...TxRxMessageTypes,\n  ...SMPMessageTypes,\n] as const;\nexport type ConnectionMessageType = (typeof ConnectionMessageTypes)[number];\n\nexport type ConnectionStatusCallback = (status: ConnectionStatus) => void;\nexport type MessageReceivedCallback = (\n  messageType: ConnectionMessageType,\n  dataView: DataView<ArrayBuffer>\n) => void;\nexport type MessagesReceivedCallback = () => void;\n\nabstract class BaseConnectionManager {\n  static #AssertValidTxRxMessageType(messageType: TxRxMessageType) {\n    _console.assertEnumWithError(messageType, TxRxMessageTypes);\n  }\n\n  abstract get bluetoothId(): string;\n\n  // CALLBACKS\n  onStatusUpdated?: ConnectionStatusCallback;\n  onMessageReceived?: MessageReceivedCallback;\n  onMessagesReceived?: MessagesReceivedCallback;\n\n  protected get baseConstructor() {\n    return this.constructor as typeof BaseConnectionManager;\n  }\n  static get isSupported() {\n    return false;\n  }\n  get isSupported() {\n    return this.baseConstructor.isSupported;\n  }\n\n  get canUpdateFirmware() {\n    return false;\n  }\n\n  static type: ConnectionType;\n  get type(): ConnectionType {\n    return this.baseConstructor.type;\n  }\n\n  /** @throws {Error} if not supported */\n  #assertIsSupported() {\n    _console.assertWithError(this.isSupported, `${this.type} is not supported`);\n  }\n\n  constructor() {\n    this.#assertIsSupported();\n  }\n\n  #status: ConnectionStatus = \"notConnected\";\n  get status() {\n    return this.#status;\n  }\n  protected set status(newConnectionStatus) {\n    _console.assertEnumWithError(newConnectionStatus, ConnectionStatuses);\n    if (this.#status == newConnectionStatus) {\n      _console.log(\n        `tried to assign same connection status \"${newConnectionStatus}\"`\n      );\n      return;\n    }\n    _console.log(`new connection status \"${newConnectionStatus}\"`);\n    this.#status = newConnectionStatus;\n    this.onStatusUpdated!(this.status);\n\n    if (this.isConnected) {\n      this.#timer.start();\n    } else {\n      this.#timer.stop();\n    }\n\n    if (this.#status == \"notConnected\") {\n      this.mtu = this.defaultMtu;\n    }\n  }\n\n  get isConnected() {\n    return this.status == \"connected\";\n  }\n\n  get isAvailable() {\n    return false;\n  }\n\n  /** @throws {Error} if connected */\n  protected assertIsNotConnected() {\n    _console.assertWithError(!this.isConnected, \"device is already connected\");\n  }\n  /** @throws {Error} if connecting */\n  #assertIsNotConnecting() {\n    _console.assertWithError(\n      this.status != \"connecting\",\n      \"device is already connecting\"\n    );\n  }\n  /** @throws {Error} if not connected */\n  protected assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"device is not connected\");\n  }\n  /** @throws {Error} if disconnecting */\n  #assertIsNotDisconnecting() {\n    _console.assertWithError(\n      this.status != \"disconnecting\",\n      \"device is already disconnecting\"\n    );\n  }\n  /** @throws {Error} if not connected or is disconnecting */\n  assertIsConnectedAndNotDisconnecting() {\n    this.assertIsConnected();\n    this.#assertIsNotDisconnecting();\n  }\n\n  async connect() {\n    if (this.isConnected) {\n      _console.log(\"already connected\");\n      return false;\n    }\n    if (this.#status == \"connecting\") {\n      _console.log(\"already connecting\");\n      return false;\n    }\n    // this.assertIsNotConnected();\n    // this.#assertIsNotConnecting();\n    this.status = \"connecting\";\n    return true;\n  }\n  get canReconnect() {\n    return false;\n  }\n  async reconnect() {\n    if (this.isConnected) {\n      _console.log(\"already connected\");\n      return false;\n    }\n    if (this.#status == \"connecting\") {\n      _console.log(\"already connecting\");\n      return false;\n    }\n    // this.assertIsNotConnected();\n    // this.#assertIsNotConnecting();\n    if (!this.canReconnect) {\n      _console.warn(\"unable to reconnect\");\n      return false;\n    }\n    // _console.assertWithError(this.canReconnect, \"unable to reconnect\");\n    this.status = \"connecting\";\n    _console.log(\"attempting to reconnect...\");\n    return true;\n  }\n  async disconnect() {\n    if (this.#status == \"notConnected\") {\n      _console.log(\"already not connected\");\n      return false;\n    }\n    if (this.#status == \"disconnecting\") {\n      _console.log(\"already disconnecting\");\n      return false;\n    }\n    // this.assertIsConnected();\n    // this.#assertIsNotDisconnecting();\n    this.status = \"disconnecting\";\n    _console.log(\"disconnecting from device...\");\n    return true;\n  }\n\n  async sendSmpMessage(data: ArrayBuffer) {\n    this.assertIsConnectedAndNotDisconnecting();\n    _console.log(\"sending smp message\", data);\n  }\n\n  #pendingMessages: TxMessage[] = [];\n  #isSendingMessages = false;\n  async sendTxMessages(\n    messages: TxMessage[] | undefined,\n    sendImmediately: boolean = true\n  ) {\n    this.assertIsConnectedAndNotDisconnecting();\n\n    if (messages) {\n      this.#pendingMessages.push(...messages);\n      _console.log(`appended ${messages.length} messages`);\n    }\n\n    if (!sendImmediately) {\n      _console.log(\"not sending immediately - waiting until later\");\n      return;\n    }\n\n    if (this.#isSendingMessages) {\n      _console.log(\"already sending messages - waiting until later\");\n      return;\n    }\n    if (this.#pendingMessages.length == 0) {\n      _console.log(\"no pendingMessages\");\n      return;\n    }\n    this.#isSendingMessages = true;\n\n    _console.log(\"sendTxMessages\", this.#pendingMessages.slice());\n\n    const arrayBuffers = this.#pendingMessages.map((message) => {\n      BaseConnectionManager.#AssertValidTxRxMessageType(message.type);\n      const messageTypeEnum = TxRxMessageTypes.indexOf(message.type);\n      const dataLength = new DataView(new ArrayBuffer(2));\n      dataLength.setUint16(0, message.data?.byteLength || 0, true);\n      return concatenateArrayBuffers(messageTypeEnum, dataLength, message.data);\n    });\n    this.#pendingMessages.length = 0;\n\n    if (this.mtu) {\n      while (arrayBuffers.length > 0) {\n        if (\n          arrayBuffers.every(\n            (arrayBuffer) => arrayBuffer.byteLength > this.mtu! - 3\n          )\n        ) {\n          _console.error(\"every arrayBuffer is too big to send\");\n          break;\n        }\n        _console.log(\"remaining arrayBuffers.length\", arrayBuffers.length);\n        let arrayBufferByteLength = 0;\n        let arrayBufferCount = 0;\n        arrayBuffers.some((arrayBuffer) => {\n          if (arrayBufferByteLength + arrayBuffer.byteLength > this.mtu! - 3) {\n            _console.log(\n              `stopping appending arrayBuffers ( length ${arrayBuffer.byteLength} too much)`\n            );\n            return true;\n          }\n          _console.log(\n            `allowing arrayBuffer with length ${arrayBuffer.byteLength}`\n          );\n          arrayBufferCount++;\n          arrayBufferByteLength += arrayBuffer.byteLength;\n        });\n        const arrayBuffersToSend = arrayBuffers.splice(0, arrayBufferCount);\n        _console.log({ arrayBufferCount, arrayBuffersToSend });\n\n        const arrayBuffer = concatenateArrayBuffers(...arrayBuffersToSend);\n        _console.log(\"sending arrayBuffer (partitioned)\", arrayBuffer);\n        await this.sendTxData(arrayBuffer);\n      }\n    } else {\n      const arrayBuffer = concatenateArrayBuffers(...arrayBuffers);\n      _console.log(\"sending arrayBuffer (all)\", arrayBuffer);\n      await this.sendTxData(arrayBuffer);\n    }\n\n    this.#isSendingMessages = false;\n\n    this.sendTxMessages(undefined, true);\n  }\n\n  protected defaultMtu = 23;\n  //mtu?: number;\n  mtu?: number = this.defaultMtu;\n\n  async sendTxData(data: ArrayBuffer) {\n    _console.log(\"sendTxData\", data);\n  }\n\n  parseRxMessage(dataView: DataView<ArrayBuffer>) {\n    parseMessage(\n      dataView,\n      TxRxMessageTypes,\n      this.#onRxMessage.bind(this),\n      null,\n      true\n    );\n    this.onMessagesReceived!();\n  }\n\n  #onRxMessage(messageType: TxRxMessageType, dataView: DataView<ArrayBuffer>) {\n    _console.log({ messageType, dataView });\n    this.onMessageReceived!(messageType, dataView);\n  }\n\n  #timer = new Timer(this.#checkConnection.bind(this), 5000);\n  #checkConnection() {\n    //console.log(\"checking connection...\");\n    if (!this.isConnected) {\n      _console.log(\"timer detected disconnection\");\n      this.status = \"notConnected\";\n    }\n  }\n\n  clear() {\n    this.#isSendingMessages = false;\n    this.#pendingMessages.length = 0;\n  }\n\n  remove() {\n    this.clear();\n\n    this.onStatusUpdated = undefined;\n    this.onMessageReceived = undefined;\n    this.onMessagesReceived = undefined;\n  }\n}\n\nexport default BaseConnectionManager;\n","import { createConsole } from \"./Console.ts\";\nimport { spacesToPascalCase } from \"./stringUtils.ts\";\n\nconst _console = createConsole(\"EventUtils\", { log: false });\n\ntype BoundEventListeners = { [eventType: string]: EventListener };\nexport type BoundGenericEventListeners = { [eventType: string]: Function };\n\nexport function bindEventListeners(\n  eventTypes: readonly string[],\n  boundEventListeners: BoundGenericEventListeners,\n  target: any\n) {\n  _console.log(\"bindEventListeners\", { eventTypes, boundEventListeners, target });\n  eventTypes.forEach((eventType) => {\n    const _eventType = `_on${spacesToPascalCase(eventType)}`;\n    _console.assertWithError(target[_eventType], `no event \"${_eventType}\" found in target`);\n    _console.log(`binding eventType \"${eventType}\" as ${_eventType} from target`, target);\n    const boundEvent = target[_eventType].bind(target);\n    target[_eventType] = boundEvent;\n    boundEventListeners[eventType] = boundEvent;\n  });\n}\n\nexport function addEventListeners(target: any, boundEventListeners: BoundGenericEventListeners) {\n  let addEventListener = target.addEventListener || target.addListener || target.on || target.AddEventListener;\n  _console.assertWithError(addEventListener, \"no add listener function found for target\");\n  addEventListener = addEventListener.bind(target);\n  Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {\n    addEventListener(eventType, eventListener);\n  });\n}\n\nexport function removeEventListeners(target: any, boundEventListeners: BoundGenericEventListeners) {\n  let removeEventListener = target.removeEventListener || target.removeListener || target.RemoveEventListener;\n  _console.assertWithError(removeEventListener, \"no remove listener function found for target\");\n  removeEventListener = removeEventListener.bind(target);\n  Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {\n    removeEventListener(eventType, eventListener);\n  });\n}\n","import {\n  isInBrowser,\n  isInLensStudio,\n  isInNode,\n} from \"../../utils/environment.ts\";\nimport { createConsole } from \"../../utils/Console.ts\";\n\nconst _console = createConsole(\"bluetoothUUIDs\", { log: false });\n\nimport { BluetoothUUID as _BluetoothUUID } from \"webbluetooth\";\nvar BluetoothUUID: typeof _BluetoothUUID;\n\n/** NODE_START */\nimport * as webbluetooth from \"webbluetooth\";\nBluetoothUUID = webbluetooth.BluetoothUUID;\n/** NODE_END */\n\n/** BROWSER_START */\nif (isInBrowser) {\n  BluetoothUUID = window.BluetoothUUID;\n}\n/** BROWSER_END */\n\n/** LS_START */\nif (typeof BluetoothUUID == undefined) {\n  BluetoothUUID = {\n    getService: (uuid: number | string): string => toUUID(uuid),\n    getCharacteristic: (uuid: number | string): string => toUUID(uuid),\n    getDescriptor: (uuid: number | string): string => toUUID(uuid),\n    canonicalUUID: (alias: string | number) => toUUID(alias),\n  };\n}\n\nfunction toUUID(uuid: number | string): string {\n  if (typeof uuid === \"number\") {\n    uuid = uuid.toString(16).padStart(4, \"0\");\n  }\n\n  if (/^[0-9a-fA-F]{4,8}$/.test(uuid)) {\n    return `0000${uuid.padStart(8, \"0\")}-0000-1000-8000-00805f9b34fb`;\n  }\n\n  return uuid.toLowerCase();\n}\n/** LS_END */\n\nfunction generateBluetoothUUID(value: string): BluetoothServiceUUID {\n  _console.assertTypeWithError(value, \"string\");\n  _console.assertWithError(\n    value.length == 4,\n    \"value must be 4 characters long\"\n  );\n  return `ea6d${value}-a725-4f9b-893d-c3913e33b39f`;\n}\n\nfunction stringToCharacteristicUUID(\n  identifier: string\n): BluetoothCharacteristicUUID {\n  return BluetoothUUID?.getCharacteristic?.(identifier);\n}\n\nfunction stringToServiceUUID(identifier: string): BluetoothServiceUUID {\n  return BluetoothUUID?.getService?.(identifier);\n}\n\nexport type BluetoothServiceName =\n  | \"deviceInformation\"\n  | \"battery\"\n  | \"main\"\n  | \"smp\";\nimport { DeviceInformationType } from \"../../DeviceInformationManager.ts\";\nexport type BluetoothCharacteristicName =\n  | DeviceInformationType\n  | \"batteryLevel\"\n  | \"rx\"\n  | \"tx\"\n  | \"smp\";\n\ninterface BluetoothCharacteristicInformation {\n  uuid: BluetoothCharacteristicUUID;\n}\ninterface BluetoothServiceInformation {\n  uuid: BluetoothServiceUUID;\n  characteristics: {\n    [characteristicName in BluetoothCharacteristicName]?: BluetoothCharacteristicInformation;\n  };\n}\ninterface BluetoothServicesInformation {\n  services: {\n    [serviceName in BluetoothServiceName]: BluetoothServiceInformation;\n  };\n}\nconst bluetoothUUIDs: BluetoothServicesInformation = Object.freeze({\n  services: {\n    deviceInformation: {\n      uuid: stringToServiceUUID(\"device_information\"),\n      characteristics: {\n        manufacturerName: {\n          uuid: stringToCharacteristicUUID(\"manufacturer_name_string\"),\n        },\n        modelNumber: {\n          uuid: stringToCharacteristicUUID(\"model_number_string\"),\n        },\n        hardwareRevision: {\n          uuid: stringToCharacteristicUUID(\"hardware_revision_string\"),\n        },\n        firmwareRevision: {\n          uuid: stringToCharacteristicUUID(\"firmware_revision_string\"),\n        },\n        softwareRevision: {\n          uuid: stringToCharacteristicUUID(\"software_revision_string\"),\n        },\n        pnpId: {\n          uuid: stringToCharacteristicUUID(\"pnp_id\"),\n        },\n        serialNumber: {\n          uuid: stringToCharacteristicUUID(\"serial_number_string\"),\n        },\n      },\n    },\n    battery: {\n      uuid: stringToServiceUUID(\"battery_service\"),\n      characteristics: {\n        batteryLevel: {\n          uuid: stringToCharacteristicUUID(\"battery_level\"),\n        },\n      },\n    },\n    main: {\n      uuid: generateBluetoothUUID(\"0000\"),\n      characteristics: {\n        rx: { uuid: generateBluetoothUUID(\"1000\") },\n        tx: { uuid: generateBluetoothUUID(\"1001\") },\n      },\n    },\n    smp: {\n      uuid: \"8d53dc1d-1db7-4cd3-868b-8a527460aa84\",\n      characteristics: {\n        smp: { uuid: \"da2e7828-fbce-4e01-ae9e-261174997c48\" },\n      },\n    },\n  },\n});\n\nexport const serviceUUIDs = [bluetoothUUIDs.services.main.uuid];\nexport const optionalServiceUUIDs = [\n  bluetoothUUIDs.services.deviceInformation.uuid,\n  bluetoothUUIDs.services.battery.uuid,\n  bluetoothUUIDs.services.smp.uuid,\n];\nexport const allServiceUUIDs = [...serviceUUIDs, ...optionalServiceUUIDs];\n\nexport function getServiceNameFromUUID(\n  serviceUUID: BluetoothServiceUUID\n): BluetoothServiceName | undefined {\n  serviceUUID = serviceUUID.toString().toLowerCase();\n  const serviceNames = Object.keys(\n    bluetoothUUIDs.services\n  ) as BluetoothServiceName[];\n  return serviceNames.find((serviceName) => {\n    const serviceInfo = bluetoothUUIDs.services[serviceName];\n    let serviceInfoUUID = serviceInfo.uuid.toString();\n    if (serviceUUID.length == 4) {\n      serviceInfoUUID = serviceInfoUUID.slice(4, 8);\n    }\n    if (!serviceUUID.includes(\"-\")) {\n      serviceInfoUUID = serviceInfoUUID.replaceAll(\"-\", \"\");\n    }\n    return serviceUUID == serviceInfoUUID;\n  });\n}\n\nexport const characteristicUUIDs: BluetoothCharacteristicUUID[] = [];\nexport const allCharacteristicUUIDs: BluetoothCharacteristicUUID[] = [];\n\nexport const characteristicNames: BluetoothCharacteristicName[] = [];\nexport const allCharacteristicNames: BluetoothCharacteristicName[] = [];\n\nObject.values(bluetoothUUIDs.services).forEach((serviceInfo) => {\n  if (!serviceInfo.characteristics) {\n    return;\n  }\n  const characteristicNames = Object.keys(\n    serviceInfo.characteristics\n  ) as BluetoothCharacteristicName[];\n  characteristicNames.forEach((characteristicName) => {\n    const characteristicInfo = serviceInfo.characteristics[characteristicName]!;\n    if (serviceUUIDs.includes(serviceInfo.uuid)) {\n      characteristicUUIDs.push(characteristicInfo.uuid);\n      characteristicNames.push(characteristicName);\n    }\n    allCharacteristicUUIDs.push(characteristicInfo.uuid);\n    allCharacteristicNames.push(characteristicName);\n  });\n}, []);\n\n//_console.log({ characteristicUUIDs, allCharacteristicUUIDs });\n\nexport function getCharacteristicNameFromUUID(\n  characteristicUUID: BluetoothCharacteristicUUID\n): BluetoothCharacteristicName | undefined {\n  //_console.log({ characteristicUUID });\n  characteristicUUID = characteristicUUID.toString().toLowerCase();\n  var characteristicName: BluetoothCharacteristicName | undefined;\n  Object.values(bluetoothUUIDs.services).some((serviceInfo) => {\n    const characteristicNames = Object.keys(\n      serviceInfo.characteristics\n    ) as BluetoothCharacteristicName[];\n    characteristicName = characteristicNames.find((_characteristicName) => {\n      const characteristicInfo =\n        serviceInfo.characteristics[_characteristicName]!;\n      let characteristicInfoUUID = characteristicInfo.uuid.toString();\n      if (characteristicUUID.length == 4) {\n        characteristicInfoUUID = characteristicInfoUUID.slice(4, 8);\n      }\n      if (!characteristicUUID.includes(\"-\")) {\n        characteristicInfoUUID = characteristicInfoUUID.replaceAll(\"-\", \"\");\n      }\n      return characteristicUUID == characteristicInfoUUID;\n    });\n    return characteristicName;\n  });\n  return characteristicName;\n}\n\nexport function getCharacteristicProperties(\n  characteristicName: BluetoothCharacteristicName\n): BluetoothCharacteristicProperties {\n  const properties = {\n    broadcast: false,\n    read: true,\n    writeWithoutResponse: false,\n    write: false,\n    notify: false,\n    indicate: false,\n    authenticatedSignedWrites: false,\n    reliableWrite: false,\n    writableAuxiliaries: false,\n  };\n\n  // read\n  switch (characteristicName) {\n    case \"rx\":\n    case \"tx\":\n    case \"smp\":\n      properties.read = false;\n      break;\n  }\n\n  // notify\n  switch (characteristicName) {\n    case \"batteryLevel\":\n    case \"rx\":\n    case \"smp\":\n      properties.notify = true;\n      break;\n  }\n\n  // write without response\n  switch (characteristicName) {\n    case \"smp\":\n      properties.writeWithoutResponse = true;\n      break;\n  }\n\n  // write\n  switch (characteristicName) {\n    case \"tx\":\n      properties.write = true;\n      break;\n  }\n\n  return properties;\n}\n\nexport const serviceDataUUID = \"0000\";\n","import { createConsole } from \"../../utils/Console.ts\";\nimport BaseConnectionManager from \"../BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"BluetoothConnectionManager\", { log: false });\n\nimport { BluetoothCharacteristicName } from \"./bluetoothUUIDs.ts\";\n\nabstract class BluetoothConnectionManager extends BaseConnectionManager {\n  get isAvailable() {\n    // no way to tell if the user has turned bluetooth on or off\n    return true;\n  }\n\n  isInRange = true;\n\n  protected onCharacteristicValueChanged(\n    characteristicName: BluetoothCharacteristicName,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    if (characteristicName == \"rx\") {\n      this.parseRxMessage(dataView);\n    } else {\n      this.onMessageReceived?.(characteristicName, dataView);\n    }\n  }\n\n  protected async writeCharacteristic(\n    characteristicName: BluetoothCharacteristicName,\n    data: ArrayBuffer\n  ) {\n    _console.log(\"writeCharacteristic\", ...arguments);\n  }\n\n  async sendSmpMessage(data: ArrayBuffer) {\n    super.sendSmpMessage(data);\n    await this.writeCharacteristic(\"smp\", data);\n  }\n\n  async sendTxData(data: ArrayBuffer) {\n    super.sendTxData(data);\n    if (data.byteLength == 0) {\n      return;\n    }\n    await this.writeCharacteristic(\"tx\", data);\n  }\n}\n\nexport default BluetoothConnectionManager;\n","import { createConsole } from \"../../utils/Console.ts\";\nimport {\n  isInNode,\n  isInBrowser,\n  isInBluefy,\n  isInWebBLE,\n} from \"../../utils/environment.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../../utils/EventUtils.ts\";\nimport {\n  serviceUUIDs,\n  optionalServiceUUIDs,\n  getServiceNameFromUUID,\n  getCharacteristicNameFromUUID,\n  getCharacteristicProperties,\n} from \"./bluetoothUUIDs.ts\";\nimport BluetoothConnectionManager from \"./BluetoothConnectionManager.ts\";\nimport {\n  BluetoothCharacteristicName,\n  BluetoothServiceName,\n} from \"./bluetoothUUIDs.ts\";\nimport { ConnectionType } from \"../BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"WebBluetoothConnectionManager\", { log: false });\n\ntype WebBluetoothInterface = webbluetooth.Bluetooth | Bluetooth;\n\ninterface BluetoothService extends BluetoothRemoteGATTService {\n  name?: BluetoothServiceName;\n}\ninterface BluetoothCharacteristic extends BluetoothRemoteGATTCharacteristic {\n  name?: BluetoothCharacteristicName;\n}\n\nvar bluetooth: WebBluetoothInterface | undefined;\n/** NODE_START */\nimport * as webbluetooth from \"webbluetooth\";\nif (isInNode) {\n  bluetooth = webbluetooth.bluetooth;\n}\n/** NODE_END */\n\n/** BROWSER_START */\nif (isInBrowser) {\n  bluetooth = window.navigator.bluetooth;\n}\n/** BROWSER_END */\n\nclass WebBluetoothConnectionManager extends BluetoothConnectionManager {\n  get bluetoothId() {\n    return this.device!.id;\n  }\n\n  get canUpdateFirmware() {\n    return this.#characteristics.has(\"smp\");\n  }\n\n  #boundBluetoothCharacteristicEventListeners: {\n    [eventType: string]: EventListener;\n  } = {\n    characteristicvaluechanged: this.#onCharacteristicvaluechanged.bind(this),\n  };\n  #boundBluetoothDeviceEventListeners: { [eventType: string]: EventListener } =\n    {\n      gattserverdisconnected: this.#onGattserverdisconnected.bind(this),\n    };\n\n  static get isSupported() {\n    return Boolean(bluetooth);\n  }\n  static get type(): ConnectionType {\n    return \"webBluetooth\";\n  }\n\n  #device?: BluetoothDevice;\n  get device() {\n    return this.#device;\n  }\n  set device(newDevice) {\n    if (this.#device == newDevice) {\n      _console.log(\"tried to assign the same BluetoothDevice\");\n      return;\n    }\n    if (this.#device) {\n      removeEventListeners(\n        this.#device,\n        this.#boundBluetoothDeviceEventListeners\n      );\n    }\n    if (newDevice) {\n      addEventListeners(newDevice, this.#boundBluetoothDeviceEventListeners);\n    }\n    this.#device = newDevice;\n  }\n\n  get server(): BluetoothRemoteGATTServer | undefined {\n    return this.#device?.gatt;\n  }\n  get isConnected() {\n    return this.server?.connected || false;\n  }\n\n  #services: Map<BluetoothServiceName, BluetoothService> = new Map();\n  #characteristics: Map<BluetoothCharacteristicName, BluetoothCharacteristic> =\n    new Map();\n\n  async connect() {\n    const canContinue = super.connect();\n    if (!canContinue) {\n      return false;\n    }\n\n    try {\n      const device = await bluetooth!.requestDevice({\n        filters: [{ services: serviceUUIDs }],\n        optionalServices: isInBrowser ? optionalServiceUUIDs : [],\n      });\n\n      _console.log(\"got BluetoothDevice\");\n      this.device = device;\n\n      _console.log(\"connecting to device...\");\n      const server = await this.server!.connect();\n      _console.log(`connected to device? ${server.connected}`);\n\n      await this.#getServicesAndCharacteristics();\n\n      _console.log(\"fully connected\");\n\n      this.status = \"connected\";\n      return true;\n    } catch (error) {\n      _console.error(error);\n      this.status = \"notConnected\";\n      this.server?.disconnect();\n      await this.#removeEventListeners();\n      return false;\n    }\n  }\n  async #getServicesAndCharacteristics() {\n    this.#removeEventListeners();\n\n    _console.log(\"getting services...\");\n    const services = await this.server!.getPrimaryServices();\n    _console.log(\"got services\", services.length);\n    //const service = await this.server!.getPrimaryService(\"8d53dc1d-1db7-4cd3-868b-8a527460aa84\");\n\n    _console.log(\"getting characteristics...\");\n    for (const serviceIndex in services) {\n      const service = services[serviceIndex] as BluetoothService;\n      _console.log({ service });\n      const serviceName = getServiceNameFromUUID(service.uuid)!;\n      _console.assertWithError(\n        serviceName,\n        `no name found for service uuid \"${service.uuid}\"`\n      );\n      _console.log(`got \"${serviceName}\" service`);\n      service.name = serviceName;\n      this.#services.set(serviceName, service);\n      _console.log(`getting characteristics for \"${serviceName}\" service`);\n      const characteristics = await service.getCharacteristics();\n      _console.log(`got characteristics for \"${serviceName}\" service`);\n      for (const characteristicIndex in characteristics) {\n        const characteristic = characteristics[\n          characteristicIndex\n        ] as BluetoothCharacteristic;\n        _console.log({ characteristic });\n        const characteristicName = getCharacteristicNameFromUUID(\n          characteristic.uuid\n        )!;\n        _console.assertWithError(\n          Boolean(characteristicName),\n          `no name found for characteristic uuid \"${characteristic.uuid}\" in \"${serviceName}\" service`\n        );\n        _console.log(\n          `got \"${characteristicName}\" characteristic in \"${serviceName}\" service`\n        );\n        characteristic.name = characteristicName;\n        this.#characteristics.set(characteristicName, characteristic);\n        addEventListeners(\n          characteristic,\n          this.#boundBluetoothCharacteristicEventListeners\n        );\n        const characteristicProperties =\n          characteristic.properties ||\n          getCharacteristicProperties(characteristicName);\n        if (characteristicProperties.notify) {\n          _console.log(\n            `starting notifications for \"${characteristicName}\" characteristic`\n          );\n          await characteristic.startNotifications();\n        }\n        if (characteristicProperties.read) {\n          _console.log(`reading \"${characteristicName}\" characteristic...`);\n          await characteristic.readValue();\n          if (isInBluefy || isInWebBLE) {\n            this.#onCharacteristicValueChanged(characteristic);\n          }\n        }\n      }\n    }\n  }\n  async #removeEventListeners() {\n    if (this.device) {\n      removeEventListeners(\n        this.device,\n        this.#boundBluetoothDeviceEventListeners\n      );\n    }\n\n    const promises = Array.from(this.#characteristics.keys()).map(\n      (characteristicName) => {\n        const characteristic = this.#characteristics.get(characteristicName)!;\n        removeEventListeners(\n          characteristic,\n          this.#boundBluetoothCharacteristicEventListeners\n        );\n        const characteristicProperties =\n          characteristic.properties ||\n          getCharacteristicProperties(characteristicName);\n        if (characteristicProperties.notify) {\n          _console.log(\n            `stopping notifications for \"${characteristicName}\" characteristic`\n          );\n          return characteristic.stopNotifications();\n        }\n      }\n    );\n\n    return Promise.allSettled(promises);\n  }\n  async disconnect() {\n    const canContinue = await super.disconnect();\n    if (!canContinue) {\n      return false;\n    }\n    await this.#removeEventListeners();\n    this.server?.disconnect();\n    this.status = \"notConnected\";\n    return true;\n  }\n\n  #onCharacteristicvaluechanged(event: Event) {\n    _console.log(\"oncharacteristicvaluechanged\");\n\n    const characteristic = event.target as BluetoothCharacteristic;\n    this.#onCharacteristicValueChanged(characteristic);\n  }\n\n  #onCharacteristicValueChanged(characteristic: BluetoothCharacteristic) {\n    _console.log(\"onCharacteristicValue\");\n\n    const characteristicName = characteristic.name!;\n    _console.assertWithError(\n      Boolean(characteristicName),\n      `no name found for characteristic with uuid \"${characteristic.uuid}\"`\n    );\n\n    _console.log(\n      `oncharacteristicvaluechanged for \"${characteristicName}\" characteristic`\n    );\n    const dataView = characteristic.value! as DataView<ArrayBuffer>;\n    _console.assertWithError(\n      dataView,\n      `no data found for \"${characteristicName}\" characteristic`\n    );\n    _console.log(\n      `data for \"${characteristicName}\" characteristic`,\n      Array.from(new Uint8Array(dataView.buffer))\n    );\n\n    try {\n      this.onCharacteristicValueChanged(characteristicName, dataView);\n    } catch (error) {\n      _console.error(error);\n    }\n  }\n\n  async writeCharacteristic(\n    characteristicName: BluetoothCharacteristicName,\n    data: ArrayBuffer\n  ) {\n    super.writeCharacteristic(characteristicName, data);\n\n    const characteristic = this.#characteristics.get(characteristicName)!;\n    _console.assertWithError(\n      characteristic,\n      `${characteristicName} characteristic not found`\n    );\n    _console.log(\"writing characteristic\", characteristic, data);\n    const characteristicProperties =\n      characteristic.properties ||\n      getCharacteristicProperties(characteristicName);\n    if (characteristicProperties.writeWithoutResponse) {\n      _console.log(\"writing without response\");\n      await characteristic.writeValueWithoutResponse(data);\n    } else {\n      _console.log(\"writing with response\");\n      await characteristic.writeValueWithResponse(data);\n    }\n    _console.log(\"wrote characteristic\");\n\n    if (characteristicProperties.read && !characteristicProperties.notify) {\n      _console.log(\"reading value after write...\");\n      await characteristic.readValue();\n      if (isInBluefy || isInWebBLE) {\n        this.#onCharacteristicValueChanged(characteristic);\n      }\n    }\n  }\n\n  #onGattserverdisconnected() {\n    _console.log(\"gattserverdisconnected\");\n    this.status = \"notConnected\";\n  }\n\n  get canReconnect() {\n    return Boolean(this.server && !this.server.connected && this.isInRange);\n  }\n  async reconnect() {\n    const canContinue = await super.reconnect();\n    if (!canContinue) {\n      return false;\n    }\n    try {\n      await this.server!.connect();\n    } catch (error) {\n      _console.error(error);\n      this.isInRange = false;\n      return false;\n    }\n\n    if (this.isConnected) {\n      _console.log(\"successfully reconnected!\");\n      await this.#getServicesAndCharacteristics();\n      this.status = \"connected\";\n      return true;\n    } else {\n      _console.log(\"unable to reconnect\");\n      this.status = \"notConnected\";\n      return false;\n    }\n  }\n\n  remove() {\n    super.remove();\n    this.device = undefined;\n  }\n}\n\nexport default WebBluetoothConnectionManager;\n","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2016 Patrick Gansterer <paroga@paroga.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst POW_2_24 = 5.960464477539063e-8;\nconst POW_2_32 = 4294967296;\nconst POW_2_53 = 9007199254740992;\n\nexport function encode(value) {\n  let data = new ArrayBuffer(256);\n  let dataView = new DataView(data);\n  let lastLength;\n  let offset = 0;\n\n  function prepareWrite(length) {\n    let newByteLength = data.byteLength;\n    const requiredLength = offset + length;\n    while (newByteLength < requiredLength) {\n      newByteLength <<= 1;\n    }\n    if (newByteLength !== data.byteLength) {\n      const oldDataView = dataView;\n      data = new ArrayBuffer(newByteLength);\n      dataView = new DataView(data);\n      const uint32count = (offset + 3) >> 2;\n      for (let i = 0; i < uint32count; ++i) {\n        dataView.setUint32(i << 2, oldDataView.getUint32(i << 2));\n      }\n    }\n\n    lastLength = length;\n    return dataView;\n  }\n  function commitWrite() {\n    offset += lastLength;\n  }\n  function writeFloat64(value) {\n    commitWrite(prepareWrite(8).setFloat64(offset, value));\n  }\n  function writeUint8(value) {\n    commitWrite(prepareWrite(1).setUint8(offset, value));\n  }\n  function writeUint8Array(value) {\n    const dataView = prepareWrite(value.length);\n    for (let i = 0; i < value.length; ++i) {\n      dataView.setUint8(offset + i, value[i]);\n    }\n    commitWrite();\n  }\n  function writeUint16(value) {\n    commitWrite(prepareWrite(2).setUint16(offset, value));\n  }\n  function writeUint32(value) {\n    commitWrite(prepareWrite(4).setUint32(offset, value));\n  }\n  function writeUint64(value) {\n    const low = value % POW_2_32;\n    const high = (value - low) / POW_2_32;\n    const dataView = prepareWrite(8);\n    dataView.setUint32(offset, high);\n    dataView.setUint32(offset + 4, low);\n    commitWrite();\n  }\n  function writeTypeAndLength(type, length) {\n    if (length < 24) {\n      writeUint8((type << 5) | length);\n    } else if (length < 0x100) {\n      writeUint8((type << 5) | 24);\n      writeUint8(length);\n    } else if (length < 0x10000) {\n      writeUint8((type << 5) | 25);\n      writeUint16(length);\n    } else if (length < 0x100000000) {\n      writeUint8((type << 5) | 26);\n      writeUint32(length);\n    } else {\n      writeUint8((type << 5) | 27);\n      writeUint64(length);\n    }\n  }\n\n  function encodeItem(value) {\n    let i;\n    const utf8data = [];\n    let length;\n\n    if (value === false) {\n      return writeUint8(0xf4);\n    }\n    if (value === true) {\n      return writeUint8(0xf5);\n    }\n    if (value === null) {\n      return writeUint8(0xf6);\n    }\n    if (value === undefined) {\n      return writeUint8(0xf7);\n    }\n\n    switch (typeof value) {\n      case \"number\":\n        if (Math.floor(value) === value) {\n          if (value >= 0 && value <= POW_2_53) {\n            return writeTypeAndLength(0, value);\n          }\n          if (-POW_2_53 <= value && value < 0) {\n            return writeTypeAndLength(1, -(value + 1));\n          }\n        }\n        writeUint8(0xfb);\n        return writeFloat64(value);\n\n      case \"string\":\n        for (i = 0; i < value.length; ++i) {\n          let charCode = value.charCodeAt(i);\n          if (charCode < 0x80) {\n            utf8data.push(charCode);\n          } else if (charCode < 0x800) {\n            utf8data.push(0xc0 | (charCode >> 6));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          } else if (charCode < 0xd800) {\n            utf8data.push(0xe0 | (charCode >> 12));\n            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          } else {\n            charCode = (charCode & 0x3ff) << 10;\n            charCode |= value.charCodeAt(++i) & 0x3ff;\n            charCode += 0x10000;\n\n            utf8data.push(0xf0 | (charCode >> 18));\n            utf8data.push(0x80 | ((charCode >> 12) & 0x3f));\n            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          }\n        }\n\n        writeTypeAndLength(3, utf8data.length);\n        return writeUint8Array(utf8data);\n\n      default:\n        if (Array.isArray(value)) {\n          length = value.length;\n          writeTypeAndLength(4, length);\n          for (i = 0; i < length; ++i) {\n            encodeItem(value[i]);\n          }\n        } else if (value instanceof Uint8Array) {\n          writeTypeAndLength(2, value.length);\n          writeUint8Array(value);\n        } else {\n          const keys = Object.keys(value);\n          length = keys.length;\n          writeTypeAndLength(5, length);\n          for (i = 0; i < length; ++i) {\n            const key = keys[i];\n            encodeItem(key);\n            encodeItem(value[key]);\n          }\n        }\n    }\n  }\n\n  encodeItem(value);\n\n  if (\"slice\" in data) {\n    return data.slice(0, offset);\n  }\n\n  const ret = new ArrayBuffer(offset);\n  const retView = new DataView(ret);\n  for (let i = 0; i < offset; ++i) {\n    retView.setUint8(i, dataView.getUint8(i));\n  }\n  return ret;\n}\n\nexport function decode(data, tagger, simpleValue) {\n  const dataView = new DataView(data);\n  let offset = 0;\n\n  if (typeof tagger !== \"function\") {\n    tagger = function (value) {\n      return value;\n    };\n  }\n  if (typeof simpleValue !== \"function\") {\n    simpleValue = function () {\n      return undefined;\n    };\n  }\n\n  function commitRead(length, value) {\n    offset += length;\n    return value;\n  }\n  function readArrayBuffer(length) {\n    return commitRead(length, new Uint8Array(data, offset, length));\n  }\n  function readFloat16() {\n    const tempArrayBuffer = new ArrayBuffer(4);\n    const tempDataView = new DataView(tempArrayBuffer);\n    const value = readUint16();\n\n    const sign = value & 0x8000;\n    let exponent = value & 0x7c00;\n    const fraction = value & 0x03ff;\n\n    if (exponent === 0x7c00) {\n      exponent = 0xff << 10;\n    } else if (exponent !== 0) {\n      exponent += (127 - 15) << 10;\n    } else if (fraction !== 0) {\n      return (sign ? -1 : 1) * fraction * POW_2_24;\n    }\n\n    tempDataView.setUint32(0, (sign << 16) | (exponent << 13) | (fraction << 13));\n    return tempDataView.getFloat32(0);\n  }\n  function readFloat32() {\n    return commitRead(4, dataView.getFloat32(offset));\n  }\n  function readFloat64() {\n    return commitRead(8, dataView.getFloat64(offset));\n  }\n  function readUint8() {\n    return commitRead(1, dataView.getUint8(offset));\n  }\n  function readUint16() {\n    return commitRead(2, dataView.getUint16(offset));\n  }\n  function readUint32() {\n    return commitRead(4, dataView.getUint32(offset));\n  }\n  function readUint64() {\n    return readUint32() * POW_2_32 + readUint32();\n  }\n  function readBreak() {\n    if (dataView.getUint8(offset) !== 0xff) {\n      return false;\n    }\n    offset += 1;\n    return true;\n  }\n  function readLength(additionalInformation) {\n    if (additionalInformation < 24) {\n      return additionalInformation;\n    }\n    if (additionalInformation === 24) {\n      return readUint8();\n    }\n    if (additionalInformation === 25) {\n      return readUint16();\n    }\n    if (additionalInformation === 26) {\n      return readUint32();\n    }\n    if (additionalInformation === 27) {\n      return readUint64();\n    }\n    if (additionalInformation === 31) {\n      return -1;\n    }\n    throw new Error(\"Invalid length encoding\");\n  }\n  function readIndefiniteStringLength(majorType) {\n    const initialByte = readUint8();\n    if (initialByte === 0xff) {\n      return -1;\n    }\n    const length = readLength(initialByte & 0x1f);\n    if (length < 0 || initialByte >> 5 !== majorType) {\n      throw new Error(\"Invalid indefinite length element\");\n    }\n    return length;\n  }\n\n  function appendUtf16Data(utf16data, length) {\n    for (let i = 0; i < length; ++i) {\n      let value = readUint8();\n      if (value & 0x80) {\n        if (value < 0xe0) {\n          value = ((value & 0x1f) << 6) | (readUint8() & 0x3f);\n          length -= 1;\n        } else if (value < 0xf0) {\n          value = ((value & 0x0f) << 12) | ((readUint8() & 0x3f) << 6) | (readUint8() & 0x3f);\n          length -= 2;\n        } else {\n          value =\n            ((value & 0x0f) << 18) | ((readUint8() & 0x3f) << 12) | ((readUint8() & 0x3f) << 6) | (readUint8() & 0x3f);\n          length -= 3;\n        }\n      }\n\n      if (value < 0x10000) {\n        utf16data.push(value);\n      } else {\n        value -= 0x10000;\n        utf16data.push(0xd800 | (value >> 10));\n        utf16data.push(0xdc00 | (value & 0x3ff));\n      }\n    }\n  }\n\n  function decodeItem() {\n    const initialByte = readUint8();\n    const majorType = initialByte >> 5;\n    const additionalInformation = initialByte & 0x1f;\n    let i;\n    let length;\n\n    if (majorType === 7) {\n      switch (additionalInformation) {\n        case 25:\n          return readFloat16();\n        case 26:\n          return readFloat32();\n        case 27:\n          return readFloat64();\n      }\n    }\n\n    length = readLength(additionalInformation);\n    if (length < 0 && (majorType < 2 || majorType > 6)) {\n      throw new Error(\"Invalid length\");\n    }\n\n    const utf16data = [];\n    let retArray;\n    const retObject = {};\n\n    switch (majorType) {\n      case 0:\n        return length;\n      case 1:\n        return -1 - length;\n      case 2:\n        if (length < 0) {\n          const elements = [];\n          let fullArrayLength = 0;\n          while ((length = readIndefiniteStringLength(majorType)) >= 0) {\n            fullArrayLength += length;\n            elements.push(readArrayBuffer(length));\n          }\n          const fullArray = new Uint8Array(fullArrayLength);\n          let fullArrayOffset = 0;\n          for (i = 0; i < elements.length; ++i) {\n            fullArray.set(elements[i], fullArrayOffset);\n            fullArrayOffset += elements[i].length;\n          }\n          return fullArray;\n        }\n        return readArrayBuffer(length);\n      case 3:\n        if (length < 0) {\n          while ((length = readIndefiniteStringLength(majorType)) >= 0) {\n            appendUtf16Data(utf16data, length);\n          }\n        } else {\n          appendUtf16Data(utf16data, length);\n        }\n        return String.fromCharCode.apply(null, utf16data);\n      case 4:\n        if (length < 0) {\n          retArray = [];\n          while (!readBreak()) {\n            retArray.push(decodeItem());\n          }\n        } else {\n          retArray = new Array(length);\n          for (i = 0; i < length; ++i) {\n            retArray[i] = decodeItem();\n          }\n        }\n        return retArray;\n      case 5:\n        for (i = 0; i < length || (length < 0 && !readBreak()); ++i) {\n          const key = decodeItem();\n          retObject[key] = decodeItem();\n        }\n        return retObject;\n      case 6:\n        return tagger(decodeItem(), length);\n      case 7:\n        switch (length) {\n          case 20:\n            return false;\n          case 21:\n            return true;\n          case 22:\n            return null;\n          case 23:\n            return undefined;\n          default:\n            return simpleValue(length);\n        }\n    }\n  }\n\n  const ret = decodeItem();\n  if (offset !== data.byteLength) {\n    throw new Error(\"Remaining bytes\");\n  }\n  return ret;\n}\n\nexport const CBOR = {\n  encode,\n  decode,\n};\n","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2023 Laird Connectivity\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * @file mcumgr\n * @brief Provides MCU manager operation functions for the Xbit USB Shell.\n * This file is inspired by the MIT licensed mcumgr file originally\n * authored by Andras Barthazi (https://github.com/boogie/mcumgr-web),\n * updated to also support file upload/download over SMP.\n */\n\nimport { CBOR } from \"./cbor.js\";\nimport { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"mcumgr\", { log: false });\n\nexport const constants = {\n  // Opcodes\n  MGMT_OP_READ: 0,\n  MGMT_OP_READ_RSP: 1,\n  MGMT_OP_WRITE: 2,\n  MGMT_OP_WRITE_RSP: 3,\n\n  // Groups\n  MGMT_GROUP_ID_OS: 0,\n  MGMT_GROUP_ID_IMAGE: 1,\n  MGMT_GROUP_ID_STAT: 2,\n  MGMT_GROUP_ID_CONFIG: 3,\n  MGMT_GROUP_ID_LOG: 4,\n  MGMT_GROUP_ID_CRASH: 5,\n  MGMT_GROUP_ID_SPLIT: 6,\n  MGMT_GROUP_ID_RUN: 7,\n  MGMT_GROUP_ID_FS: 8,\n  MGMT_GROUP_ID_SHELL: 9,\n\n  // OS group\n  OS_MGMT_ID_ECHO: 0,\n  OS_MGMT_ID_CONS_ECHO_CTRL: 1,\n  OS_MGMT_ID_TASKSTAT: 2,\n  OS_MGMT_ID_MPSTAT: 3,\n  OS_MGMT_ID_DATETIME_STR: 4,\n  OS_MGMT_ID_RESET: 5,\n\n  // Image group\n  IMG_MGMT_ID_STATE: 0,\n  IMG_MGMT_ID_UPLOAD: 1,\n  IMG_MGMT_ID_FILE: 2,\n  IMG_MGMT_ID_CORELIST: 3,\n  IMG_MGMT_ID_CORELOAD: 4,\n  IMG_MGMT_ID_ERASE: 5,\n\n  // Filesystem group\n  FS_MGMT_ID_FILE: 0,\n};\n\nexport class MCUManager {\n  constructor() {\n    this._mtu = 256;\n    this._messageCallback = null;\n    this._imageUploadProgressCallback = null;\n    this._imageUploadNextCallback = null;\n    this._fileUploadProgressCallback = null;\n    this._fileUploadNextCallback = null;\n    this._uploadIsInProgress = false;\n    this._downloadIsInProgress = false;\n    this._buffer = new Uint8Array();\n    this._seq = 0;\n  }\n\n  onMessage(callback) {\n    this._messageCallback = callback;\n    return this;\n  }\n\n  onImageUploadNext(callback) {\n    this._imageUploadNextCallback = callback;\n    return this;\n  }\n\n  onImageUploadProgress(callback) {\n    this._imageUploadProgressCallback = callback;\n    return this;\n  }\n\n  onImageUploadFinished(callback) {\n    this._imageUploadFinishedCallback = callback;\n    return this;\n  }\n\n  onFileUploadNext(callback) {\n    this._fileUploadNextCallback = callback;\n    return this;\n  }\n\n  onFileUploadProgress(callback) {\n    this._fileUploadProgressCallback = callback;\n    return this;\n  }\n\n  onFileUploadFinished(callback) {\n    this._fileUploadFinishedCallback = callback;\n    return this;\n  }\n\n  onFileDownloadNext(callback) {\n    this._fileDownloadNextCallback = callback;\n    return this;\n  }\n\n  onFileDownloadProgress(callback) {\n    this._fileDownloadProgressCallback = callback;\n    return this;\n  }\n\n  onFileDownloadFinished(callback) {\n    this._fileDownloadFinishedCallback = callback;\n    return this;\n  }\n\n  _getMessage(op, group, id, data) {\n    const _flags = 0;\n    let encodedData = [];\n    if (typeof data !== \"undefined\") {\n      encodedData = [...new Uint8Array(CBOR.encode(data))];\n    }\n    const lengthLo = encodedData.length & 255;\n    const lengthHi = encodedData.length >> 8;\n    const groupLo = group & 255;\n    const groupHi = group >> 8;\n    const message = [op, _flags, lengthHi, lengthLo, groupHi, groupLo, this._seq, id, ...encodedData];\n    this._seq = (this._seq + 1) % 256;\n\n    return message;\n  }\n\n  _notification(buffer) {\n    _console.log(\"mcumgr - message received\");\n    const message = new Uint8Array(buffer);\n    this._buffer = new Uint8Array([...this._buffer, ...message]);\n    const messageLength = this._buffer[2] * 256 + this._buffer[3];\n    if (this._buffer.length < messageLength + 8) return;\n    this._processMessage(this._buffer.slice(0, messageLength + 8));\n    this._buffer = this._buffer.slice(messageLength + 8);\n  }\n\n  _processMessage(message) {\n    const [op, , lengthHi, lengthLo, groupHi, groupLo, , id] = message;\n    const data = CBOR.decode(message.slice(8).buffer);\n    const length = lengthHi * 256 + lengthLo;\n    const group = groupHi * 256 + groupLo;\n\n    _console.log(\"mcumgr - Process Message - Group: \" + group + \", Id: \" + id + \", Off: \" + data.off);\n    if (group === constants.MGMT_GROUP_ID_IMAGE && id === constants.IMG_MGMT_ID_UPLOAD && data.off) {\n      this._uploadOffset = data.off;\n      this._uploadNext();\n      return;\n    }\n    if (\n      op === constants.MGMT_OP_WRITE_RSP &&\n      group === constants.MGMT_GROUP_ID_FS &&\n      id === constants.FS_MGMT_ID_FILE &&\n      data.off\n    ) {\n      this._uploadFileOffset = data.off;\n      this._uploadFileNext();\n      return;\n    }\n    if (op === constants.MGMT_OP_READ_RSP && group === constants.MGMT_GROUP_ID_FS && id === constants.FS_MGMT_ID_FILE) {\n      this._downloadFileOffset += data.data.length;\n      if (data.len != undefined) {\n        this._downloadFileLength = data.len;\n      }\n      _console.log(\"downloaded \" + this._downloadFileOffset + \" bytes of \" + this._downloadFileLength);\n      if (this._downloadFileLength > 0) {\n        this._fileDownloadProgressCallback({\n          percentage: Math.floor((this._downloadFileOffset / this._downloadFileLength) * 100),\n        });\n      }\n      if (this._messageCallback) this._messageCallback({ op, group, id, data, length });\n      this._downloadFileNext();\n      return;\n    }\n\n    if (this._messageCallback) this._messageCallback({ op, group, id, data, length });\n  }\n\n  cmdReset() {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_OS, constants.OS_MGMT_ID_RESET);\n  }\n\n  smpEcho(message) {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_OS, constants.OS_MGMT_ID_ECHO, {\n      d: message,\n    });\n  }\n\n  cmdImageState() {\n    return this._getMessage(constants.MGMT_OP_READ, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE);\n  }\n\n  cmdImageErase() {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_ERASE, {});\n  }\n\n  cmdImageTest(hash) {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE, {\n      hash,\n      confirm: false,\n    });\n  }\n\n  cmdImageConfirm(hash) {\n    return this._getMessage(constants.MGMT_OP_WRITE, constants.MGMT_GROUP_ID_IMAGE, constants.IMG_MGMT_ID_STATE, {\n      hash,\n      confirm: true,\n    });\n  }\n\n  _hash(image) {\n    return crypto.subtle.digest(\"SHA-256\", image);\n  }\n\n  async _uploadNext() {\n    if (!this._uploadImage) {\n      return;\n    }\n\n    if (this._uploadOffset >= this._uploadImage.byteLength) {\n      this._uploadIsInProgress = false;\n      this._imageUploadFinishedCallback();\n      return;\n    }\n\n    const nmpOverhead = 8;\n    const message = { data: new Uint8Array(), off: this._uploadOffset };\n    if (this._uploadOffset === 0) {\n      message.len = this._uploadImage.byteLength;\n      message.sha = new Uint8Array(await this._hash(this._uploadImage));\n    }\n    this._imageUploadProgressCallback({\n      percentage: Math.floor((this._uploadOffset / this._uploadImage.byteLength) * 100),\n    });\n\n    const length = this._mtu - CBOR.encode(message).byteLength - nmpOverhead - 3 - 5;\n\n    message.data = new Uint8Array(this._uploadImage.slice(this._uploadOffset, this._uploadOffset + length));\n\n    this._uploadOffset += length;\n\n    const packet = this._getMessage(\n      constants.MGMT_OP_WRITE,\n      constants.MGMT_GROUP_ID_IMAGE,\n      constants.IMG_MGMT_ID_UPLOAD,\n      message\n    );\n\n    _console.log(\"mcumgr - _uploadNext: Message Length: \" + packet.length);\n\n    this._imageUploadNextCallback({ packet });\n  }\n  async reset() {\n    this._messageCallback = null;\n    this._imageUploadProgressCallback = null;\n    this._imageUploadNextCallback = null;\n    this._fileUploadProgressCallback = null;\n    this._fileUploadNextCallback = null;\n    this._uploadIsInProgress = false;\n    this._downloadIsInProgress = false;\n    this._buffer = new Uint8Array();\n    this._seq = 0;\n  }\n\n  async cmdUpload(image, slot = 0) {\n    if (this._uploadIsInProgress) {\n      _console.error(\"Upload is already in progress.\");\n      return;\n    }\n    this._uploadIsInProgress = true;\n\n    this._uploadOffset = 0;\n    this._uploadImage = image;\n    this._uploadSlot = slot;\n\n    this._uploadNext();\n  }\n\n  async cmdUploadFile(filebuf, destFilename) {\n    if (this._uploadIsInProgress) {\n      _console.error(\"Upload is already in progress.\");\n      return;\n    }\n    this._uploadIsInProgress = true;\n    this._uploadFileOffset = 0;\n    this._uploadFile = filebuf;\n    this._uploadFilename = destFilename;\n\n    this._uploadFileNext();\n  }\n\n  async _uploadFileNext() {\n    _console.log(\"uploadFileNext - offset: \" + this._uploadFileOffset + \", length: \" + this._uploadFile.byteLength);\n\n    if (this._uploadFileOffset >= this._uploadFile.byteLength) {\n      this._uploadIsInProgress = false;\n      this._fileUploadFinishedCallback();\n      return;\n    }\n\n    const nmpOverhead = 8;\n    const message = { data: new Uint8Array(), off: this._uploadFileOffset };\n    if (this._uploadFileOffset === 0) {\n      message.len = this._uploadFile.byteLength;\n    }\n    message.name = this._uploadFilename;\n    this._fileUploadProgressCallback({\n      percentage: Math.floor((this._uploadFileOffset / this._uploadFile.byteLength) * 100),\n    });\n\n    const length = this._mtu - CBOR.encode(message).byteLength - nmpOverhead;\n\n    message.data = new Uint8Array(this._uploadFile.slice(this._uploadFileOffset, this._uploadFileOffset + length));\n\n    this._uploadFileOffset += length;\n\n    const packet = this._getMessage(\n      constants.MGMT_OP_WRITE,\n      constants.MGMT_GROUP_ID_FS,\n      constants.FS_MGMT_ID_FILE,\n      message\n    );\n\n    _console.log(\"mcumgr - _uploadNext: Message Length: \" + packet.length);\n\n    this._fileUploadNextCallback({ packet });\n  }\n\n  async cmdDownloadFile(filename, destFilename) {\n    if (this._downloadIsInProgress) {\n      _console.error(\"Download is already in progress.\");\n      return;\n    }\n    this._downloadIsInProgress = true;\n    this._downloadFileOffset = 0;\n    this._downloadFileLength = 0;\n    this._downloadRemoteFilename = filename;\n    this._downloadLocalFilename = destFilename;\n\n    this._downloadFileNext();\n  }\n\n  async _downloadFileNext() {\n    if (this._downloadFileLength > 0) {\n      if (this._downloadFileOffset >= this._downloadFileLength) {\n        this._downloadIsInProgress = false;\n        this._fileDownloadFinishedCallback();\n        return;\n      }\n    }\n\n    const message = { off: this._downloadFileOffset };\n    if (this._downloadFileOffset === 0) {\n      message.name = this._downloadRemoteFilename;\n    }\n\n    const packet = this._getMessage(\n      constants.MGMT_OP_READ,\n      constants.MGMT_GROUP_ID_FS,\n      constants.FS_MGMT_ID_FILE,\n      message\n    );\n    _console.log(\"mcumgr - _downloadNext: Message Length: \" + packet.length);\n    this._fileDownloadNextCallback({ packet });\n  }\n\n  async imageInfo(image) {\n    const info = {};\n    const view = new Uint8Array(image);\n\n    // check header length\n    if (view.length < 32) {\n      throw new Error(\"Invalid image (too short file)\");\n    }\n\n    // check MAGIC bytes 0x96f3b83d\n    if (view[0] !== 0x3d || view[1] !== 0xb8 || view[2] !== 0xf3 || view[3] !== 0x96) {\n      throw new Error(\"Invalid image (wrong magic bytes)\");\n    }\n\n    // check load address is 0x00000000\n    if (view[4] !== 0x00 || view[5] !== 0x00 || view[6] !== 0x00 || view[7] !== 0x00) {\n      throw new Error(\"Invalid image (wrong load address)\");\n    }\n\n    const headerSize = view[8] + view[9] * 2 ** 8;\n\n    // check protected TLV area size is 0\n    if (view[10] !== 0x00 || view[11] !== 0x00) {\n      throw new Error(\"Invalid image (wrong protected TLV area size)\");\n    }\n\n    const imageSize = view[12] + view[13] * 2 ** 8 + view[14] * 2 ** 16 + view[15] * 2 ** 24;\n    info.imageSize = imageSize;\n\n    // check image size is correct\n    if (view.length < imageSize + headerSize) {\n      throw new Error(\"Invalid image (wrong image size)\");\n    }\n\n    // check flags is 0x00000000\n    if (view[16] !== 0x00 || view[17] !== 0x00 || view[18] !== 0x00 || view[19] !== 0x00) {\n      throw new Error(\"Invalid image (wrong flags)\");\n    }\n\n    const version = `${view[20]}.${view[21]}.${view[22] + view[23] * 2 ** 8}`;\n    info.version = version;\n\n    info.hash = [...new Uint8Array(await this._hash(image.slice(0, imageSize + 32)))]\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n\n    return info;\n  }\n}\n","import Device, { SendSmpMessageCallback } from \"./Device.ts\";\nimport { getFileBuffer } from \"./utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { MCUManager, constants } from \"./utils/mcumgr.js\";\nimport { FileLike } from \"./utils/ArrayBufferUtils.ts\";\nimport autoBind from \"auto-bind\";\n\nconst _console = createConsole(\"FirmwareManager\", { log: false });\n\nexport const FirmwareMessageTypes = [\"smp\"] as const;\nexport type FirmwareMessageType = (typeof FirmwareMessageTypes)[number];\n\nexport const FirmwareEventTypes = [\n  ...FirmwareMessageTypes,\n  \"firmwareImages\",\n  \"firmwareUploadProgress\",\n  \"firmwareStatus\",\n  \"firmwareUploadComplete\",\n] as const;\nexport type FirmwareEventType = (typeof FirmwareEventTypes)[number];\n\nexport const FirmwareStatuses = [\n  \"idle\",\n  \"uploading\",\n  \"uploaded\",\n  \"pending\",\n  \"testing\",\n  \"erasing\",\n] as const;\nexport type FirmwareStatus = (typeof FirmwareStatuses)[number];\n\nexport interface FirmwareImage {\n  slot: number;\n  active: boolean;\n  confirmed: boolean;\n  pending: boolean;\n  permanent: boolean;\n  bootable: boolean;\n  version: string;\n  hash?: Uint8Array;\n  empty?: boolean;\n}\n\nexport interface FirmwareEventMessages {\n  smp: { dataView: DataView<ArrayBuffer> };\n  firmwareImages: { firmwareImages: FirmwareImage[] };\n  firmwareUploadProgress: { progress: number };\n  firmwareStatus: { firmwareStatus: FirmwareStatus };\n  //firmwareUploadComplete: {};\n}\n\nexport type FirmwareEventDispatcher = EventDispatcher<\n  Device,\n  FirmwareEventType,\n  FirmwareEventMessages\n>;\n\nclass FirmwareManager {\n  sendMessage!: SendSmpMessageCallback;\n\n  constructor() {\n    this.#assignMcuManagerCallbacks();\n    autoBind(this);\n  }\n\n  eventDispatcher!: FirmwareEventDispatcher;\n  get addEventListenter() {\n    return this.eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.eventDispatcher.waitForEvent;\n  }\n\n  parseMessage(\n    messageType: FirmwareMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"smp\":\n        this.#mcuManager._notification(\n          Array.from(new Uint8Array(dataView.buffer))\n        );\n        this.#dispatchEvent(\"smp\", { dataView });\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  async uploadFirmware(file: FileLike) {\n    _console.log(\"uploadFirmware\", file);\n\n    const promise = this.waitForEvent(\"firmwareUploadComplete\");\n\n    await this.getImages();\n\n    const arrayBuffer = await getFileBuffer(file);\n    const imageInfo = await this.#mcuManager.imageInfo(arrayBuffer);\n    _console.log({ imageInfo });\n\n    this.#mcuManager.cmdUpload(arrayBuffer, 1);\n\n    this.#updateStatus(\"uploading\");\n\n    await promise;\n  }\n\n  #status: FirmwareStatus = \"idle\";\n  get status() {\n    return this.#status;\n  }\n  #updateStatus(newStatus: FirmwareStatus) {\n    _console.assertEnumWithError(newStatus, FirmwareStatuses);\n    if (this.#status == newStatus) {\n      _console.log(`redundant firmwareStatus assignment \"${newStatus}\"`);\n      return;\n    }\n\n    this.#status = newStatus;\n    _console.log({ firmwareStatus: this.#status });\n    this.#dispatchEvent(\"firmwareStatus\", { firmwareStatus: this.#status });\n  }\n\n  // COMMANDS\n\n  #images!: FirmwareImage[];\n  get images() {\n    return this.#images;\n  }\n  #assertImages() {\n    _console.assertWithError(this.#images, \"didn't get imageState\");\n  }\n  #assertValidImageIndex(imageIndex: number) {\n    _console.assertTypeWithError(imageIndex, \"number\");\n    _console.assertWithError(\n      imageIndex == 0 || imageIndex == 1,\n      \"imageIndex must be 0 or 1\"\n    );\n  }\n  async getImages() {\n    const promise = this.waitForEvent(\"firmwareImages\");\n\n    _console.log(\"getting firmware image state...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageState()).buffer);\n\n    await promise;\n  }\n\n  async testImage(imageIndex: number = 1) {\n    this.#assertValidImageIndex(imageIndex);\n    this.#assertImages();\n    if (!this.#images[imageIndex]) {\n      _console.log(`image ${imageIndex} not found`);\n      return;\n    }\n    if (this.#images[imageIndex].pending == true) {\n      _console.log(`image ${imageIndex} is already pending`);\n      return;\n    }\n    if (this.#images[imageIndex].empty) {\n      _console.log(`image ${imageIndex} is empty`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"testing firmware image...\");\n    this.sendMessage(\n      Uint8Array.from(\n        this.#mcuManager.cmdImageTest(this.#images[imageIndex].hash)\n      ).buffer\n    );\n\n    await promise;\n  }\n\n  async eraseImage() {\n    this.#assertImages();\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"erasing image...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdImageErase()).buffer);\n\n    this.#updateStatus(\"erasing\");\n\n    await promise;\n    await this.getImages();\n  }\n\n  async confirmImage(imageIndex: number = 0) {\n    this.#assertValidImageIndex(imageIndex);\n    this.#assertImages();\n    if (this.#images[imageIndex].confirmed === true) {\n      _console.log(`image ${imageIndex} is already confirmed`);\n      return;\n    }\n\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"confirming image...\");\n    this.sendMessage(\n      Uint8Array.from(\n        this.#mcuManager.cmdImageConfirm(this.#images[imageIndex].hash)\n      ).buffer\n    );\n\n    await promise;\n  }\n\n  async echo(string: string) {\n    _console.assertTypeWithError(string, \"string\");\n\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"sending echo...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.smpEcho(string)).buffer);\n\n    await promise;\n  }\n\n  async reset() {\n    const promise = this.waitForEvent(\"smp\");\n\n    _console.log(\"resetting...\");\n    this.sendMessage(Uint8Array.from(this.#mcuManager.cmdReset()).buffer);\n\n    await promise;\n  }\n\n  // MTU\n  #mtu!: number;\n  get mtu() {\n    return this.#mtu;\n  }\n  set mtu(newMtu: number) {\n    this.#mtu = newMtu;\n    this.#mcuManager._mtu = newMtu;\n  }\n\n  // MCUManager\n  #mcuManager = new MCUManager();\n\n  #assignMcuManagerCallbacks() {\n    this.#mcuManager.onMessage(this.#onMcuMessage.bind(this));\n\n    this.#mcuManager.onFileDownloadNext(this.#onMcuFileDownloadNext);\n    this.#mcuManager.onFileDownloadProgress(\n      this.#onMcuFileDownloadProgress.bind(this)\n    );\n    this.#mcuManager.onFileDownloadFinished(\n      this.#onMcuFileDownloadFinished.bind(this)\n    );\n\n    this.#mcuManager.onFileUploadNext(this.#onMcuFileUploadNext.bind(this));\n    this.#mcuManager.onFileUploadProgress(\n      this.#onMcuFileUploadProgress.bind(this)\n    );\n    this.#mcuManager.onFileUploadFinished(\n      this.#onMcuFileUploadFinished.bind(this)\n    );\n\n    this.#mcuManager.onImageUploadNext(this.#onMcuImageUploadNext.bind(this));\n    this.#mcuManager.onImageUploadProgress(\n      this.#onMcuImageUploadProgress.bind(this)\n    );\n    this.#mcuManager.onImageUploadFinished(\n      this.#onMcuImageUploadFinished.bind(this)\n    );\n  }\n\n  #onMcuMessage({\n    op,\n    group,\n    id,\n    data,\n    length,\n  }: {\n    op: number;\n    group: number;\n    id: number;\n    data: any;\n    length: number;\n  }) {\n    _console.log(\"onMcuMessage\", ...arguments);\n\n    switch (group) {\n      case constants.MGMT_GROUP_ID_OS:\n        switch (id) {\n          case constants.OS_MGMT_ID_ECHO:\n            _console.log(`echo \"${data.r}\"`);\n            break;\n          case constants.OS_MGMT_ID_TASKSTAT:\n            _console.table(data.tasks);\n            break;\n          case constants.OS_MGMT_ID_MPSTAT:\n            _console.log(data);\n            break;\n        }\n        break;\n      case constants.MGMT_GROUP_ID_IMAGE:\n        switch (id) {\n          case constants.IMG_MGMT_ID_STATE:\n            this.#onMcuImageState(data);\n        }\n        break;\n      default:\n        throw Error(`uncaught mcuMessage group ${group}`);\n    }\n  }\n\n  #onMcuFileDownloadNext() {\n    _console.log(\"onMcuFileDownloadNext\", ...arguments);\n  }\n  #onMcuFileDownloadProgress() {\n    _console.log(\"onMcuFileDownloadProgress\", ...arguments);\n  }\n  #onMcuFileDownloadFinished() {\n    _console.log(\"onMcuFileDownloadFinished\", ...arguments);\n  }\n\n  #onMcuFileUploadNext() {\n    _console.log(\"onMcuFileUploadNext\");\n  }\n  #onMcuFileUploadProgress() {\n    _console.log(\"onMcuFileUploadProgress\");\n  }\n  #onMcuFileUploadFinished() {\n    _console.log(\"onMcuFileUploadFinished\");\n  }\n\n  #onMcuImageUploadNext({ packet }: { packet: number[] }) {\n    _console.log(\"onMcuImageUploadNext\");\n    this.sendMessage(Uint8Array.from(packet).buffer);\n  }\n  #onMcuImageUploadProgress({ percentage }: { percentage: number }) {\n    const progress = percentage / 100;\n    _console.log(\"onMcuImageUploadProgress\", ...arguments);\n    this.#dispatchEvent(\"firmwareUploadProgress\", { progress });\n  }\n  async #onMcuImageUploadFinished() {\n    _console.log(\"onMcuImageUploadFinished\", ...arguments);\n\n    await this.getImages();\n\n    this.#dispatchEvent(\"firmwareUploadProgress\", { progress: 100 });\n    this.#dispatchEvent(\"firmwareUploadComplete\", {});\n  }\n\n  #onMcuImageState({ images }: { images?: FirmwareImage[] }) {\n    if (images) {\n      this.#images = images;\n      _console.log(\"images\", this.#images);\n    } else {\n      _console.log(\"no images found\");\n      return;\n    }\n\n    let newStatus: FirmwareStatus = \"idle\";\n\n    if (this.#images.length == 2) {\n      if (!this.#images[1].bootable) {\n        _console.warn(\n          'Slot 1 has a invalid image. Click \"Erase Image\" to erase it or upload a different image'\n        );\n      } else if (!this.#images[0].confirmed) {\n        _console.log(\n          'Slot 0 has a valid image. Click \"Confirm Image\" to confirm it or wait and the device will swap images back.'\n        );\n        newStatus = \"testing\";\n      } else {\n        if (this.#images[1].pending) {\n          _console.log(\"reset to upload to the new firmware image\");\n          newStatus = \"pending\";\n        } else {\n          _console.log(\n            \"Slot 1 has a valid image. run testImage() to test it or upload a different image.\"\n          );\n          newStatus = \"uploaded\";\n        }\n      }\n    }\n\n    if (this.#images.length == 1) {\n      this.#images.push({\n        slot: 1,\n        empty: true,\n        version: \"Empty\",\n        pending: false,\n        confirmed: false,\n        bootable: false,\n        active: false,\n        permanent: false,\n      });\n\n      _console.log(\"Select a firmware upload image to upload to slot 1.\");\n    }\n\n    this.#updateStatus(newStatus);\n    this.#dispatchEvent(\"firmwareImages\", { firmwareImages: this.#images });\n  }\n}\n\nexport default FirmwareManager;\n","import { ConnectionStatus } from \"./connection/BaseConnectionManager.ts\";\nimport WebBluetoothConnectionManager from \"./connection/bluetooth/WebBluetoothConnectionManager.ts\";\nimport Device, { BoundDeviceEventListeners, DeviceEventMap } from \"./Device.ts\";\nimport { DeviceType } from \"./InformationManager.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInBluefy, isInBrowser } from \"./utils/environment.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"./utils/EventDispatcher.ts\";\nimport { addEventListeners } from \"./utils/EventUtils.ts\";\n\nconst _console = createConsole(\"DeviceManager\", { log: false });\n\nexport interface LocalStorageDeviceInformation {\n  type: DeviceType;\n  bluetoothId: string;\n  ipAddress?: string;\n  isWifiSecure?: boolean;\n}\n\nexport interface LocalStorageConfiguration {\n  devices: LocalStorageDeviceInformation[];\n}\n\nexport const DeviceManagerEventTypes = [\n  \"deviceConnected\",\n  \"deviceDisconnected\",\n  \"deviceIsConnected\",\n  \"availableDevices\",\n  \"connectedDevices\",\n] as const;\nexport type DeviceManagerEventType = (typeof DeviceManagerEventTypes)[number];\n\ninterface DeviceManagerEventMessage {\n  device: Device;\n}\nexport interface DeviceManagerEventMessages {\n  deviceConnected: DeviceManagerEventMessage;\n  deviceDisconnected: DeviceManagerEventMessage;\n  deviceIsConnected: DeviceManagerEventMessage;\n  availableDevices: { availableDevices: Device[] };\n  connectedDevices: { connectedDevices: Device[] };\n}\n\nexport type DeviceManagerEventDispatcher = EventDispatcher<\n  DeviceManager,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEventMap = EventMap<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEventListenerMap = EventListenerMap<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEvent = Event<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type BoundDeviceManagerEventListeners = BoundEventListeners<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\n\nclass DeviceManager {\n  static readonly shared = new DeviceManager();\n\n  constructor() {\n    if (DeviceManager.shared && this != DeviceManager.shared) {\n      throw Error(\"DeviceManager is a singleton - use DeviceManager.shared\");\n    }\n\n    if (this.CanUseLocalStorage) {\n      this.UseLocalStorage = true;\n    }\n  }\n\n  // DEVICE LISTENERS\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    getType: this.#onDeviceType.bind(this),\n    isConnected: this.#OnDeviceIsConnected.bind(this),\n  };\n  /** @private */\n  onDevice(device: Device) {\n    addEventListeners(device, this.#boundDeviceEventListeners);\n  }\n\n  #onDeviceType(event: DeviceEventMap[\"getType\"]) {\n    if (this.#UseLocalStorage) {\n      this.#UpdateLocalStorageConfigurationForDevice(event.target);\n    }\n  }\n\n  // CONNECTION STATUS\n  /** @private */\n  OnDeviceConnectionStatusUpdated(\n    device: Device,\n    connectionStatus: ConnectionStatus\n  ) {\n    if (\n      connectionStatus == \"notConnected\" &&\n      !device.canReconnect &&\n      this.#AvailableDevices.includes(device)\n    ) {\n      const deviceIndex = this.#AvailableDevices.indexOf(device);\n      this.AvailableDevices.splice(deviceIndex, 1);\n      this.#DispatchAvailableDevices();\n    }\n  }\n\n  // CONNECTED DEVICES\n\n  #ConnectedDevices: Device[] = [];\n  get ConnectedDevices() {\n    return this.#ConnectedDevices;\n  }\n\n  #UseLocalStorage = false;\n  get UseLocalStorage() {\n    return this.#UseLocalStorage;\n  }\n  set UseLocalStorage(newUseLocalStorage) {\n    this.#AssertLocalStorage();\n    _console.assertTypeWithError(newUseLocalStorage, \"boolean\");\n    this.#UseLocalStorage = newUseLocalStorage;\n    if (this.#UseLocalStorage && !this.#LocalStorageConfiguration) {\n      this.#LoadFromLocalStorage();\n    }\n  }\n\n  #DefaultLocalStorageConfiguration: LocalStorageConfiguration = {\n    devices: [],\n  };\n  #LocalStorageConfiguration?: LocalStorageConfiguration;\n\n  get CanUseLocalStorage() {\n    return isInBrowser && window.localStorage;\n  }\n\n  #AssertLocalStorage() {\n    _console.assertWithError(\n      isInBrowser,\n      \"localStorage is only available in the browser\"\n    );\n    _console.assertWithError(window.localStorage, \"localStorage not found\");\n  }\n  #LocalStorageKey = \"BS.Device\";\n  #SaveToLocalStorage() {\n    this.#AssertLocalStorage();\n    localStorage.setItem(\n      this.#LocalStorageKey,\n      JSON.stringify(this.#LocalStorageConfiguration)\n    );\n  }\n  async #LoadFromLocalStorage() {\n    this.#AssertLocalStorage();\n    let localStorageString = localStorage.getItem(this.#LocalStorageKey);\n    if (typeof localStorageString != \"string\") {\n      _console.log(\"no info found in localStorage\");\n      this.#LocalStorageConfiguration = Object.assign(\n        {},\n        this.#DefaultLocalStorageConfiguration\n      );\n      this.#SaveToLocalStorage();\n      return;\n    }\n    try {\n      const configuration = JSON.parse(localStorageString);\n      _console.log({ configuration });\n      this.#LocalStorageConfiguration = configuration;\n      if (this.CanGetDevices) {\n        await this.GetDevices(); // redundant?\n      }\n    } catch (error) {\n      _console.error(error);\n    }\n  }\n\n  #UpdateLocalStorageConfigurationForDevice(device: Device) {\n    if (device.connectionType != \"webBluetooth\") {\n      _console.log(\"localStorage is only for webBluetooth devices\");\n      return;\n    }\n    this.#AssertLocalStorage();\n    const deviceInformationIndex =\n      this.#LocalStorageConfiguration!.devices.findIndex(\n        (deviceInformation) => {\n          return deviceInformation.bluetoothId == device.bluetoothId;\n        }\n      );\n    if (deviceInformationIndex == -1) {\n      return;\n    }\n    this.#LocalStorageConfiguration!.devices[deviceInformationIndex].type =\n      device.type;\n    this.#SaveToLocalStorage();\n  }\n\n  // AVAILABLE DEVICES\n  #AvailableDevices: Device[] = [];\n  get AvailableDevices() {\n    return this.#AvailableDevices;\n  }\n\n  get CanGetDevices() {\n    return isInBrowser && navigator.bluetooth?.getDevices;\n  }\n  /**\n   * retrieves devices already connected via web bluetooth in other tabs/windows\n   *\n   * _only available on web-bluetooth enabled browsers_\n   */\n  async GetDevices(): Promise<Device[] | undefined> {\n    if (!isInBrowser) {\n      _console.warn(\"GetDevices is only available in the browser\");\n      return;\n    }\n\n    if (!navigator.bluetooth) {\n      _console.warn(\"bluetooth is not available in this browser\");\n      return;\n    }\n\n    if (isInBluefy) {\n      _console.warn(\"bluefy lists too many devices...\");\n      return;\n    }\n\n    if (!navigator.bluetooth.getDevices) {\n      _console.warn(\"bluetooth.getDevices() is not available in this browser\");\n      return;\n    }\n\n    if (!this.CanGetDevices) {\n      _console.log(\"CanGetDevices is false\");\n      return;\n    }\n\n    if (!this.#LocalStorageConfiguration) {\n      this.#LoadFromLocalStorage();\n    }\n\n    const configuration = this.#LocalStorageConfiguration!;\n    if (!configuration.devices || configuration.devices.length == 0) {\n      _console.log(\"no devices found in configuration\");\n      return;\n    }\n\n    const bluetoothDevices = await navigator.bluetooth.getDevices();\n\n    _console.log({ bluetoothDevices });\n\n    bluetoothDevices.forEach((bluetoothDevice) => {\n      if (!bluetoothDevice.gatt) {\n        return;\n      }\n      let deviceInformation = configuration.devices.find(\n        (deviceInformation) =>\n          bluetoothDevice.id == deviceInformation.bluetoothId\n      );\n      if (!deviceInformation) {\n        return;\n      }\n\n      let existingConnectedDevice = this.ConnectedDevices.filter(\n        (device) => device.connectionType == \"webBluetooth\"\n      ).find((device) => device.bluetoothId == bluetoothDevice.id);\n\n      const existingAvailableDevice = this.AvailableDevices.filter(\n        (device) => device.connectionType == \"webBluetooth\"\n      ).find((device) => device.bluetoothId == bluetoothDevice.id);\n      if (existingAvailableDevice) {\n        if (\n          existingConnectedDevice &&\n          existingConnectedDevice?.bluetoothId ==\n            existingAvailableDevice.bluetoothId &&\n          existingConnectedDevice != existingAvailableDevice\n        ) {\n          this.AvailableDevices[\n            this.#AvailableDevices.indexOf(existingAvailableDevice)\n          ] = existingConnectedDevice;\n        }\n        return;\n      }\n\n      if (existingConnectedDevice) {\n        this.AvailableDevices.push(existingConnectedDevice);\n        return;\n      }\n\n      const device = new Device();\n      const connectionManager = new WebBluetoothConnectionManager();\n      connectionManager.device = bluetoothDevice;\n      if (bluetoothDevice.name) {\n        device._informationManager.updateName(bluetoothDevice.name);\n      }\n      device._informationManager.updateType(deviceInformation.type);\n      device.connectionManager = connectionManager;\n      this.AvailableDevices.push(device);\n    });\n    this.#DispatchAvailableDevices();\n    return this.AvailableDevices;\n  }\n\n  // STATIC EVENTLISTENERS\n\n  #EventDispatcher: DeviceManagerEventDispatcher = new EventDispatcher(\n    this as DeviceManager,\n    DeviceManagerEventTypes\n  );\n\n  get AddEventListener() {\n    return this.#EventDispatcher.addEventListener;\n  }\n  get #DispatchEvent() {\n    return this.#EventDispatcher.dispatchEvent;\n  }\n  get RemoveEventListener() {\n    return this.#EventDispatcher.removeEventListener;\n  }\n  get RemoveEventListeners() {\n    return this.#EventDispatcher.removeEventListeners;\n  }\n  get RemoveAllEventListeners() {\n    return this.#EventDispatcher.removeAllEventListeners;\n  }\n\n  #OnDeviceIsConnected(event: DeviceEventMap[\"isConnected\"]) {\n    const { target: device } = event;\n    if (device.isConnected) {\n      if (!this.#ConnectedDevices.includes(device)) {\n        _console.log(\"adding device\", device);\n        this.#ConnectedDevices.push(device);\n        if (this.UseLocalStorage && device.connectionType == \"webBluetooth\") {\n          const deviceInformation: LocalStorageDeviceInformation = {\n            type: device.type,\n            bluetoothId: device.bluetoothId!,\n            ipAddress: device.ipAddress,\n            isWifiSecure: device.isWifiSecure,\n          };\n          const deviceInformationIndex =\n            this.#LocalStorageConfiguration!.devices.findIndex(\n              (_deviceInformation) =>\n                _deviceInformation.bluetoothId == deviceInformation.bluetoothId\n            );\n          if (deviceInformationIndex == -1) {\n            this.#LocalStorageConfiguration!.devices.push(deviceInformation);\n          } else {\n            this.#LocalStorageConfiguration!.devices[deviceInformationIndex] =\n              deviceInformation;\n          }\n          this.#SaveToLocalStorage();\n        }\n        this.#DispatchEvent(\"deviceConnected\", { device });\n        this.#DispatchEvent(\"deviceIsConnected\", { device });\n        this.#DispatchConnectedDevices();\n      } else {\n        _console.log(\"device already included\");\n      }\n    } else {\n      if (this.#ConnectedDevices.includes(device)) {\n        _console.log(\"removing device\", device);\n        this.#ConnectedDevices.splice(\n          this.#ConnectedDevices.indexOf(device),\n          1\n        );\n        this.#DispatchEvent(\"deviceDisconnected\", { device });\n        this.#DispatchEvent(\"deviceIsConnected\", { device });\n        this.#DispatchConnectedDevices();\n      } else {\n        _console.log(\"device already not included\");\n      }\n    }\n    if (this.CanGetDevices) {\n      this.GetDevices();\n    }\n    if (device.isConnected && !this.AvailableDevices.includes(device)) {\n      const existingAvailableDevice = this.AvailableDevices.find(\n        (_device) => _device.bluetoothId == device.bluetoothId\n      );\n      _console.log({ existingAvailableDevice });\n      if (existingAvailableDevice) {\n        this.AvailableDevices[\n          this.AvailableDevices.indexOf(existingAvailableDevice)\n        ] = device;\n      } else {\n        this.AvailableDevices.push(device);\n      }\n      this.#DispatchAvailableDevices();\n    }\n    this._CheckDeviceAvailability(device);\n  }\n\n  _CheckDeviceAvailability(device: Device) {\n    if (\n      !device.isConnected &&\n      !device.isAvailable &&\n      this.#AvailableDevices.includes(device)\n    ) {\n      _console.log(\"removing device from availableDevices...\");\n      this.#AvailableDevices.splice(this.#AvailableDevices.indexOf(device), 1);\n      this.#DispatchAvailableDevices();\n    }\n  }\n\n  #DispatchAvailableDevices() {\n    _console.log({ AvailableDevices: this.AvailableDevices });\n    this.#DispatchEvent(\"availableDevices\", {\n      availableDevices: this.AvailableDevices,\n    });\n  }\n  #DispatchConnectedDevices() {\n    _console.log({ ConnectedDevices: this.ConnectedDevices });\n    this.#DispatchEvent(\"connectedDevices\", {\n      connectedDevices: this.ConnectedDevices,\n    });\n  }\n}\n\nexport default DeviceManager.shared;\n","import { DeviceEventTypes } from \"../Device.ts\";\nimport {\n  ConnectionMessageType,\n  ConnectionMessageTypes,\n} from \"../connection/BaseConnectionManager.ts\";\nimport { concatenateArrayBuffers } from \"../utils/ArrayBufferUtils.ts\";\nimport { createConsole } from \"../utils/Console.ts\";\nimport { DeviceEventType } from \"../Device.ts\";\n\nconst _console = createConsole(\"ServerUtils\", { log: false });\n\nexport const ServerMessageTypes = [\n  \"isScanningAvailable\",\n  \"isScanning\",\n  \"startScan\",\n  \"stopScan\",\n  \"discoveredDevice\",\n  \"discoveredDevices\",\n  \"expiredDiscoveredDevice\",\n  \"connectToDevice\",\n  \"disconnectFromDevice\",\n  \"connectedDevices\",\n  \"deviceMessage\",\n  \"requiredDeviceInformation\",\n] as const;\nexport type ServerMessageType = (typeof ServerMessageTypes)[number];\n\nexport const DeviceMessageTypes = [\n  \"connectionStatus\",\n  \"batteryLevel\",\n  \"deviceInformation\",\n  \"rx\",\n  \"smp\",\n] as const;\nexport type DeviceMessageType = (typeof DeviceMessageTypes)[number];\n\n// MESSAGING\n\nexport type MessageLike =\n  | number\n  | number[]\n  | ArrayBufferLike\n  | DataView<ArrayBuffer>\n  | boolean\n  | string\n  | any;\n\nexport interface Message<MessageType extends string> {\n  type: MessageType;\n  data?: MessageLike | MessageLike[];\n}\n\nexport function createMessage<MessageType extends string>(\n  enumeration: readonly MessageType[],\n  ...messages: (Message<MessageType> | MessageType)[]\n) {\n  _console.log(\"createMessage\", ...messages);\n\n  const messageBuffers = messages.map((message) => {\n    if (typeof message == \"string\") {\n      message = { type: message };\n    }\n\n    if (message.data != undefined) {\n      if (!Array.isArray(message.data)) {\n        message.data = [message.data];\n      }\n    } else {\n      message.data = [];\n    }\n\n    const messageDataArrayBuffer = concatenateArrayBuffers(...message.data);\n    const messageDataArrayBufferByteLength = messageDataArrayBuffer.byteLength;\n\n    _console.assertEnumWithError(message.type, enumeration);\n    const messageTypeEnum = enumeration.indexOf(message.type);\n\n    const messageDataLengthDataView = new DataView(new ArrayBuffer(2));\n    messageDataLengthDataView.setUint16(\n      0,\n      messageDataArrayBufferByteLength,\n      true\n    );\n\n    return concatenateArrayBuffers(\n      messageTypeEnum,\n      messageDataLengthDataView,\n      messageDataArrayBuffer\n    );\n  });\n  _console.log(\"messageBuffers\", ...messageBuffers);\n  return concatenateArrayBuffers(...messageBuffers);\n}\n\nexport type ServerMessage = ServerMessageType | Message<ServerMessageType>;\nexport function createServerMessage(...messages: ServerMessage[]) {\n  _console.log(\"createServerMessage\", ...messages);\n  return createMessage(ServerMessageTypes, ...messages);\n}\n\nexport type DeviceMessage = DeviceEventType | Message<DeviceEventType>;\nexport function createDeviceMessage(...messages: DeviceMessage[]) {\n  _console.log(\"createDeviceMessage\", ...messages);\n  return createMessage(DeviceEventTypes, ...messages);\n}\n\nexport type ClientDeviceMessage =\n  | ConnectionMessageType\n  | Message<ConnectionMessageType>;\nexport function createClientDeviceMessage(...messages: ClientDeviceMessage[]) {\n  _console.log(\"createClientDeviceMessage\", ...messages);\n  return createMessage(ConnectionMessageTypes, ...messages);\n}\n\n// STATIC MESSAGES\nexport const isScanningAvailableRequestMessage = createServerMessage(\n  \"isScanningAvailable\"\n);\nexport const isScanningRequestMessage = createServerMessage(\"isScanning\");\nexport const startScanRequestMessage = createServerMessage(\"startScan\");\nexport const stopScanRequestMessage = createServerMessage(\"stopScan\");\nexport const discoveredDevicesMessage =\n  createServerMessage(\"discoveredDevices\");\n","import { createConsole } from \"../../utils/Console.ts\";\nimport { createMessage, Message } from \"../ServerUtils.ts\";\n\nconst _console = createConsole(\"WebSocketUtils\", { log: false });\n\nexport const webSocketPingTimeout = 30_000;\nexport const webSocketReconnectTimeout = 3_000;\n\nexport const WebSocketMessageTypes = [\"ping\", \"pong\", \"serverMessage\"] as const;\nexport type WebSocketMessageType = (typeof WebSocketMessageTypes)[number];\n\nexport type WebSocketMessage =\n  | WebSocketMessageType\n  | Message<WebSocketMessageType>;\nexport function createWebSocketMessage(...messages: WebSocketMessage[]) {\n  _console.log(\"createWebSocketMessage\", ...messages);\n  return createMessage(WebSocketMessageTypes, ...messages);\n}\n\n// STATIC MESSAGES\nexport const webSocketPingMessage = createWebSocketMessage(\"ping\");\nexport const webSocketPongMessage = createWebSocketMessage(\"pong\");\n","import { DeviceInformationTypes } from \"../../DeviceInformationManager.ts\";\nimport {\n  createMessage,\n  Message,\n  MessageLike,\n} from \"../../server/ServerUtils.ts\";\nimport { webSocketPingTimeout } from \"../../server/websocket/WebSocketUtils.ts\";\nimport { createConsole } from \"../../utils/Console.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../../utils/EventUtils.ts\";\nimport { parseMessage } from \"../../utils/ParseUtils.ts\";\nimport { Timer } from \"../../utils/Timer.ts\";\nimport BaseConnectionManager, {\n  ConnectionType,\n} from \"../BaseConnectionManager.ts\";\nimport type * as ws from \"ws\";\n\nconst _console = createConsole(\"WebSocketConnectionManager\", { log: false });\n\nconst WebSocketMessageTypes = [\n  \"ping\",\n  \"pong\",\n  \"batteryLevel\",\n  \"deviceInformation\",\n  \"message\",\n] as const;\ntype WebSocketMessageType = (typeof WebSocketMessageTypes)[number];\n\ntype WebSocketMessage = WebSocketMessageType | Message<WebSocketMessageType>;\nfunction createWebSocketMessage(...messages: WebSocketMessage[]) {\n  _console.log(\"createWebSocketMessage\", ...messages);\n  return createMessage(WebSocketMessageTypes, ...messages);\n}\n\nconst WebSocketDeviceInformationMessageTypes: WebSocketMessageType[] = [\n  \"deviceInformation\",\n  \"batteryLevel\",\n];\n\nclass WebSocketConnectionManager extends BaseConnectionManager {\n  #bluetoothId?: string;\n  get bluetoothId() {\n    return this.#bluetoothId ?? \"\";\n  }\n\n  defaultMtu = 2 ** 10;\n\n  constructor(\n    ipAddress: string,\n    isSecure: boolean = false,\n    bluetoothId?: string\n  ) {\n    super();\n    this.ipAddress = ipAddress;\n    this.isSecure = isSecure;\n    this.mtu = this.defaultMtu;\n    this.#bluetoothId = bluetoothId;\n  }\n\n  get isAvailable() {\n    return true;\n  }\n\n  static get isSupported() {\n    return true;\n  }\n  static get type(): ConnectionType {\n    return \"webSocket\";\n  }\n\n  // WEBSOCKET\n  #webSocket?: WebSocket;\n  get webSocket() {\n    return this.#webSocket;\n  }\n  set webSocket(newWebSocket) {\n    if (this.#webSocket == newWebSocket) {\n      _console.log(\"redundant webSocket assignment\");\n      return;\n    }\n\n    _console.log(\"assigning webSocket\", newWebSocket);\n\n    if (this.#webSocket) {\n      removeEventListeners(this.#webSocket, this.#boundWebSocketEventListeners);\n      if (this.#webSocket.readyState == this.#webSocket.OPEN) {\n        this.#webSocket.close();\n      }\n    }\n\n    if (newWebSocket) {\n      addEventListeners(newWebSocket, this.#boundWebSocketEventListeners);\n    }\n    this.#webSocket = newWebSocket;\n\n    _console.log(\"assigned webSocket\");\n  }\n\n  // IP ADDRESS\n  #ipAddress!: string;\n  get ipAddress() {\n    return this.#ipAddress;\n  }\n  set ipAddress(newIpAddress) {\n    this.assertIsNotConnected();\n    if (this.#ipAddress == newIpAddress) {\n      _console.log(`redundnant ipAddress assignment \"${newIpAddress}\"`);\n      return;\n    }\n    this.#ipAddress = newIpAddress;\n    _console.log(`updated ipAddress to \"${this.ipAddress}\"`);\n  }\n\n  // IS SECURE\n  #isSecure = false;\n  get isSecure() {\n    return this.#isSecure;\n  }\n  set isSecure(newIsSecure) {\n    this.assertIsNotConnected();\n    if (this.#isSecure == newIsSecure) {\n      _console.log(`redundant isSecure assignment ${newIsSecure}`);\n      return;\n    }\n    this.#isSecure = newIsSecure;\n    _console.log(`updated isSecure to \"${this.isSecure}\"`);\n  }\n\n  // URL\n  get url() {\n    return `${this.isSecure ? \"wss\" : \"ws\"}://${this.ipAddress}/ws`;\n  }\n\n  // CONNECTION\n  async connect() {\n    const canContinue = await super.connect();\n    if (!canContinue) {\n      return false;\n    }\n    try {\n      this.webSocket = new WebSocket(this.url);\n      return true;\n    } catch (error) {\n      _console.error(\"error connecting to webSocket\", error);\n      this.status = \"notConnected\";\n      return false;\n    }\n  }\n  async disconnect() {\n    const canContinue = await super.disconnect();\n    if (!canContinue) {\n      return false;\n    }\n    _console.log(\"closing websocket\");\n    this.#pingTimer.stop();\n    this.#webSocket?.close();\n    return true;\n  }\n\n  get canReconnect() {\n    return Boolean(this.webSocket);\n  }\n  async reconnect() {\n    const canContinue = await super.reconnect();\n    if (!canContinue) {\n      return false;\n    }\n    this.webSocket = new WebSocket(this.url);\n    return true;\n  }\n\n  // BASE CONNECTION MANAGER\n  async sendSmpMessage(data: ArrayBuffer) {\n    super.sendSmpMessage(data);\n    _console.error(\"smp not supported on webSockets\");\n  }\n\n  async sendTxData(data: ArrayBuffer) {\n    await super.sendTxData(data);\n    if (data.byteLength == 0) {\n      return;\n    }\n    this.#sendWebSocketMessage({ type: \"message\", data });\n  }\n\n  // WEBSOCKET MESSAGING\n  #sendMessage(message: MessageLike) {\n    this.assertIsConnected();\n    _console.log(\"sending webSocket message\", message);\n    this.#webSocket!.send(message);\n    this.#pingTimer.restart();\n  }\n\n  #sendWebSocketMessage(...messages: WebSocketMessage[]) {\n    this.#sendMessage(createWebSocketMessage(...messages));\n  }\n\n  // WEBSOCKET EVENTS\n  #boundWebSocketEventListeners: { [eventType: string]: Function } = {\n    open: this.#onWebSocketOpen.bind(this),\n    message: this.#onWebSocketMessage.bind(this),\n    close: this.#onWebSocketClose.bind(this),\n    error: this.#onWebSocketError.bind(this),\n  };\n\n  #onWebSocketOpen(event: ws.Event) {\n    _console.log(\"webSocket.open\", event);\n    this.#pingTimer.start();\n    this.status = \"connected\";\n    this.#requestDeviceInformation();\n  }\n  async #onWebSocketMessage(event: ws.MessageEvent) {\n    // this.#pingTimer.restart();\n    //@ts-expect-error\n    const arrayBuffer = await event.data.arrayBuffer();\n    const dataView = new DataView(arrayBuffer);\n    _console.log(`webSocket.message (${dataView.byteLength} bytes)`);\n    this.#parseWebSocketMessage(dataView);\n  }\n  #onWebSocketClose(event: ws.CloseEvent) {\n    _console.log(\"webSocket.close\", event);\n    this.status = \"notConnected\";\n    this.#pingTimer.stop();\n  }\n  #onWebSocketError(event: ws.ErrorEvent) {\n    _console.error(\"webSocket.error\", event);\n  }\n\n  // PARSING\n  #parseWebSocketMessage(dataView: DataView<ArrayBuffer>) {\n    parseMessage(\n      dataView,\n      WebSocketMessageTypes,\n      this.#onMessage.bind(this),\n      null,\n      true\n    );\n  }\n\n  #onMessage(\n    messageType: WebSocketMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log(\n      `received \"${messageType}\" message (${dataView.byteLength} bytes)`\n    );\n    switch (messageType) {\n      case \"ping\":\n        this.#pong();\n        break;\n      case \"pong\":\n        break;\n      case \"batteryLevel\":\n        this.onMessageReceived?.(\"batteryLevel\", dataView);\n        break;\n      case \"deviceInformation\":\n        parseMessage(\n          dataView,\n          DeviceInformationTypes,\n          (deviceInformationType, dataView) => {\n            this.onMessageReceived!(deviceInformationType, dataView);\n          }\n        );\n        break;\n      case \"message\":\n        this.parseRxMessage(dataView);\n        break;\n      default:\n        _console.error(`uncaught messageType \"${messageType}\"`);\n        break;\n    }\n  }\n\n  // PING\n  #pingTimer = new Timer(this.#ping.bind(this), webSocketPingTimeout - 1_000);\n  #ping() {\n    _console.log(\"pinging\");\n    this.#sendWebSocketMessage(\"ping\");\n  }\n  #pong() {\n    _console.log(\"ponging\");\n    this.#sendWebSocketMessage(\"pong\");\n  }\n\n  // DEVICE INFORMATION\n  #requestDeviceInformation() {\n    this.#sendWebSocketMessage(...WebSocketDeviceInformationMessageTypes);\n  }\n\n  remove() {\n    super.remove();\n    this.webSocket = undefined;\n  }\n}\n\nexport default WebSocketConnectionManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"./utils/EventDispatcher.ts\";\nimport BaseConnectionManager, {\n  TxMessage,\n  TxRxMessageType,\n  ConnectionStatus,\n  ConnectionMessageType,\n  MetaConnectionMessageTypes,\n  BatteryLevelMessageTypes,\n  ConnectionEventTypes,\n  ConnectionStatusEventMessages,\n  ConnectOptions,\n} from \"./connection/BaseConnectionManager.ts\";\nimport { isInBrowser, isInNode } from \"./utils/environment.ts\";\nimport WebBluetoothConnectionManager from \"./connection/bluetooth/WebBluetoothConnectionManager.ts\";\nimport SensorConfigurationManager, {\n  SendSensorConfigurationMessageCallback,\n  SensorConfiguration,\n  SensorConfigurationEventDispatcher,\n  SensorConfigurationEventMessages,\n  SensorConfigurationEventTypes,\n  SensorConfigurationMessageType,\n  SensorConfigurationMessageTypes,\n} from \"./sensor/SensorConfigurationManager.ts\";\nimport SensorDataManager, {\n  SensorDataEventMessages,\n  SensorDataEventTypes,\n  SensorDataMessageType,\n  SensorDataMessageTypes,\n  SensorType,\n  ContinuousSensorTypes,\n  SensorDataEventDispatcher,\n  RequiredPressureMessageTypes,\n} from \"./sensor/SensorDataManager.ts\";\nimport VibrationManager, {\n  SendVibrationMessageCallback,\n  VibrationConfiguration,\n  VibrationEventDispatcher,\n  VibrationEventTypes,\n  VibrationMessageType,\n  VibrationMessageTypes,\n} from \"./vibration/VibrationManager.ts\";\nimport FileTransferManager, {\n  FileTransferEventTypes,\n  FileTransferEventMessages,\n  FileTransferEventDispatcher,\n  SendFileTransferMessageCallback,\n  FileTransferMessageTypes,\n  FileTransferMessageType,\n  FileType,\n  FileTypes,\n  RequiredFileTransferMessageTypes,\n  SendFileCallback,\n} from \"./FileTransferManager.ts\";\nimport TfliteManager, {\n  TfliteEventTypes,\n  TfliteEventMessages,\n  TfliteEventDispatcher,\n  SendTfliteMessageCallback,\n  TfliteMessageTypes,\n  TfliteMessageType,\n  TfliteSensorTypes,\n  TfliteFileConfiguration,\n  TfliteSensorType,\n  RequiredTfliteMessageTypes,\n} from \"./TfliteManager.ts\";\nimport FirmwareManager, {\n  FirmwareEventDispatcher,\n  FirmwareEventMessages,\n  FirmwareEventTypes,\n  FirmwareMessageType,\n  FirmwareMessageTypes,\n} from \"./FirmwareManager.ts\";\nimport DeviceInformationManager, {\n  DeviceInformationEventDispatcher,\n  DeviceInformationEventTypes,\n  DeviceInformationType,\n  DeviceInformationTypes,\n  DeviceInformationEventMessages,\n} from \"./DeviceInformationManager.ts\";\nimport InformationManager, {\n  DeviceType,\n  InformationEventDispatcher,\n  InformationEventTypes,\n  InformationMessageType,\n  InformationMessageTypes,\n  InformationEventMessages,\n  SendInformationMessageCallback,\n} from \"./InformationManager.ts\";\nimport { FileLike } from \"./utils/ArrayBufferUtils.ts\";\nimport DeviceManager from \"./DeviceManager.ts\";\nimport CameraManager, {\n  CameraEventDispatcher,\n  CameraEventMessages,\n  CameraEventTypes,\n  CameraMessageType,\n  CameraMessageTypes,\n  RequiredCameraMessageTypes,\n  SendCameraMessageCallback,\n} from \"./CameraManager.ts\";\nimport MicrophoneManager, {\n  MicrophoneEventDispatcher,\n  MicrophoneEventMessages,\n  MicrophoneEventTypes,\n  MicrophoneMessageType,\n  MicrophoneMessageTypes,\n  RequiredMicrophoneMessageTypes,\n  SendMicrophoneMessageCallback,\n} from \"./MicrophoneManager.ts\";\nimport DisplayManager, {\n  DisplayEventDispatcher,\n  DisplayEventMessages,\n  DisplayEventTypes,\n  DisplayMessageType,\n  DisplayMessageTypes,\n  RequiredDisplayMessageTypes,\n  SendDisplayMessageCallback,\n} from \"./DisplayManager.ts\";\nimport WifiManager, {\n  RequiredWifiMessageTypes,\n  SendWifiMessageCallback,\n  WifiEventDispatcher,\n  WifiEventMessages,\n  WifiEventTypes,\n  WifiMessageType,\n  WifiMessageTypes,\n} from \"./WifiManager.ts\";\nimport WebSocketConnectionManager from \"./connection/websocket/WebSocketConnectionManager.ts\";\nimport ClientConnectionManager from \"./connection/ClientConnectionManager.ts\";\n\n/** NODE_START */\nimport UDPConnectionManager from \"./connection/udp/UDPConnectionManager.ts\";\nimport { DisplayManagerInterface } from \"./utils/DisplayManagerInterface.ts\";\n/** NODE_END */\n\nconst _console = createConsole(\"Device\", { log: false });\n\nexport const DeviceEventTypes = [\n  \"connectionMessage\",\n  ...ConnectionEventTypes,\n  ...MetaConnectionMessageTypes,\n  ...BatteryLevelMessageTypes,\n  ...InformationEventTypes,\n  ...DeviceInformationEventTypes,\n  ...SensorConfigurationEventTypes,\n  ...SensorDataEventTypes,\n  ...VibrationEventTypes,\n  ...FileTransferEventTypes,\n  ...TfliteEventTypes,\n  ...WifiEventTypes,\n  ...CameraEventTypes,\n  ...MicrophoneEventTypes,\n  ...DisplayEventTypes,\n  ...FirmwareEventTypes,\n] as const;\nexport type DeviceEventType = (typeof DeviceEventTypes)[number];\n\nexport interface DeviceEventMessages\n  extends ConnectionStatusEventMessages,\n    DeviceInformationEventMessages,\n    InformationEventMessages,\n    SensorDataEventMessages,\n    SensorConfigurationEventMessages,\n    TfliteEventMessages,\n    FileTransferEventMessages,\n    WifiEventMessages,\n    CameraEventMessages,\n    MicrophoneEventMessages,\n    DisplayEventMessages,\n    FirmwareEventMessages {\n  batteryLevel: { batteryLevel: number };\n  connectionMessage: {\n    messageType: ConnectionMessageType;\n    dataView: DataView<ArrayBuffer>;\n  };\n}\n\nexport type SendMessageCallback<MessageType extends string> = (\n  messages?: { type: MessageType; data?: ArrayBuffer }[],\n  sendImmediately?: boolean\n) => Promise<void>;\n\nexport type SendSmpMessageCallback = (data: ArrayBuffer) => Promise<void>;\n\nexport type DeviceEventDispatcher = EventDispatcher<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\nexport type DeviceEvent = Event<Device, DeviceEventType, DeviceEventMessages>;\nexport type DeviceEventMap = EventMap<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\nexport type DeviceEventListenerMap = EventListenerMap<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\nexport type BoundDeviceEventListeners = BoundEventListeners<\n  Device,\n  DeviceEventType,\n  DeviceEventMessages\n>;\n\nexport const RequiredInformationConnectionMessages: TxRxMessageType[] = [\n  \"isCharging\",\n  \"getBatteryCurrent\",\n  \"getId\",\n  \"getMtu\",\n\n  \"getName\",\n  \"getType\",\n  \"getCurrentTime\",\n  \"getSensorConfiguration\",\n  \"getSensorScalars\",\n\n  \"getVibrationLocations\",\n\n  \"getFileTypes\",\n\n  \"isWifiAvailable\",\n];\n\nclass Device {\n  get bluetoothId() {\n    return this.#connectionManager?.bluetoothId;\n  }\n\n  get isAvailable() {\n    return this.#connectionManager?.isAvailable;\n  }\n\n  constructor() {\n    this.#deviceInformationManager.eventDispatcher = this\n      .#eventDispatcher as DeviceInformationEventDispatcher;\n\n    this._informationManager.sendMessage = this\n      .sendTxMessages as SendInformationMessageCallback;\n    this._informationManager.eventDispatcher = this\n      .#eventDispatcher as InformationEventDispatcher;\n\n    this.#sensorConfigurationManager.sendMessage = this\n      .sendTxMessages as SendSensorConfigurationMessageCallback;\n    this.#sensorConfigurationManager.eventDispatcher = this\n      .#eventDispatcher as SensorConfigurationEventDispatcher;\n\n    this.#sensorDataManager.eventDispatcher = this\n      .#eventDispatcher as SensorDataEventDispatcher;\n\n    this.#vibrationManager.sendMessage = this\n      .sendTxMessages as SendVibrationMessageCallback;\n    this.#vibrationManager.eventDispatcher = this\n      .#eventDispatcher as VibrationEventDispatcher;\n\n    this.#tfliteManager.sendMessage = this\n      .sendTxMessages as SendTfliteMessageCallback;\n    this.#tfliteManager.eventDispatcher = this\n      .#eventDispatcher as TfliteEventDispatcher;\n\n    this.#fileTransferManager.sendMessage = this\n      .sendTxMessages as SendFileTransferMessageCallback;\n    this.#fileTransferManager.eventDispatcher = this\n      .#eventDispatcher as FileTransferEventDispatcher;\n\n    this.#wifiManager.sendMessage = this\n      .sendTxMessages as SendWifiMessageCallback;\n    this.#wifiManager.eventDispatcher = this\n      .#eventDispatcher as WifiEventDispatcher;\n\n    this.#cameraManager.sendMessage = this\n      .sendTxMessages as SendCameraMessageCallback;\n    this.#cameraManager.eventDispatcher = this\n      .#eventDispatcher as CameraEventDispatcher;\n\n    this.#microphoneManager.sendMessage = this\n      .sendTxMessages as SendMicrophoneMessageCallback;\n    this.#microphoneManager.eventDispatcher = this\n      .#eventDispatcher as MicrophoneEventDispatcher;\n\n    this.#displayManager.sendMessage = this\n      .sendTxMessages as SendDisplayMessageCallback;\n    this.#displayManager.eventDispatcher = this\n      .#eventDispatcher as DisplayEventDispatcher;\n    this.#displayManager.sendFile = this.#fileTransferManager\n      .send as SendFileCallback;\n\n    this.#firmwareManager.sendMessage = this\n      .sendSmpMessage as SendSmpMessageCallback;\n    this.#firmwareManager.eventDispatcher = this\n      .#eventDispatcher as FirmwareEventDispatcher;\n\n    this.addEventListener(\"getMtu\", () => {\n      _console.log(\"updating mtu...\");\n      this.#firmwareManager.mtu = this.mtu;\n      this.#fileTransferManager.mtu = this.mtu;\n      this.connectionManager!.mtu = this.mtu;\n      this.#displayManager.mtu = this.mtu;\n    });\n    this.addEventListener(\"getSensorConfiguration\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.sensorTypes.includes(\"pressure\")) {\n        _console.log(\"requesting required pressure information\");\n        const messages = RequiredPressureMessageTypes.map((messageType) => ({\n          type: messageType,\n        }));\n        this.sendTxMessages(messages, false);\n      } else {\n        _console.log(\"don't need to request pressure infomration\");\n      }\n\n      if (this.sensorTypes.includes(\"camera\")) {\n        _console.log(\"requesting required camera information\");\n        const messages = RequiredCameraMessageTypes.map((messageType) => ({\n          type: messageType,\n        }));\n        this.sendTxMessages(messages, false);\n      } else {\n        _console.log(\"don't need to request camera infomration\");\n      }\n\n      if (this.sensorTypes.includes(\"microphone\")) {\n        _console.log(\"requesting required microphone information\");\n        const messages = RequiredMicrophoneMessageTypes.map((messageType) => ({\n          type: messageType,\n        }));\n        this.sendTxMessages(messages, false);\n      } else {\n        _console.log(\"don't need to request microphone infomration\");\n      }\n    });\n    this.addEventListener(\"getFileTypes\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.fileTypes.length > 0) {\n        this.#fileTransferManager.requestRequiredInformation();\n      }\n      if (this.fileTypes.includes(\"tflite\")) {\n        this.#tfliteManager.requestRequiredInformation();\n      }\n    });\n    this.addEventListener(\"isWifiAvailable\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.connectionType == \"client\" && !isInNode) {\n        return;\n      }\n      if (this.isWifiAvailable) {\n        if (this.connectionType != \"client\") {\n          this.#wifiManager.requestRequiredInformation();\n        }\n      }\n    });\n    this.addEventListener(\"getType\", () => {\n      if (this.connectionStatus != \"connecting\") {\n        return;\n      }\n      if (this.type == \"glasses\") {\n        this.#displayManager.requestRequiredInformation();\n      }\n    });\n    this.addEventListener(\"fileTransferProgress\", (event) => {\n      const { fileType, progress } = event.message;\n      switch (fileType) {\n        case \"spriteSheet\":\n          this.#dispatchEvent(\"displaySpriteSheetUploadProgress\", {\n            spriteSheet: this.#displayManager.pendingSpriteSheet!,\n            spriteSheetName: this.#displayManager.pendingSpriteSheetName!,\n            progress,\n          });\n          break;\n        case \"cameraImage\":\n          this.#dispatchEvent(\"cameraImageProgress\", {\n            progress,\n            type: \"image\",\n          });\n          break;\n        default:\n          break;\n      }\n    });\n    this.addEventListener(\"fileTransferStatus\", (event) => {\n      const { fileType, fileTransferStatus } = event.message;\n      switch (fileType) {\n        case \"spriteSheet\":\n          if (fileTransferStatus == \"sending\") {\n            this.#dispatchEvent(\"displaySpriteSheetUploadStart\", {\n              spriteSheet: this.#displayManager.pendingSpriteSheet!,\n              spriteSheetName: this.#displayManager.pendingSpriteSheetName!,\n            });\n          }\n          break;\n        default:\n          break;\n      }\n    });\n    this.addEventListener(\"fileReceived\", async (event) => {\n      const { fileType, file } = event.message;\n      switch (fileType) {\n        case \"cameraImage\":\n          {\n            const arrayBuffer = await file.arrayBuffer();\n            const dataView = new DataView(arrayBuffer);\n            this.#cameraManager.parseMessage(\"cameraData\", dataView);\n          }\n          break;\n        default:\n          break;\n      }\n    });\n    DeviceManager.onDevice(this);\n    if (isInBrowser) {\n      window.addEventListener(\"beforeunload\", () => {\n        if (this.isConnected && this.clearSensorConfigurationOnLeave) {\n          this.clearSensorConfiguration();\n        }\n      });\n    }\n    if (isInNode) {\n      /** can add more node leave handlers https://gist.github.com/hyrious/30a878f6e6a057f09db87638567cb11a */\n      process.on(\"exit\", () => {\n        if (this.isConnected && this.clearSensorConfigurationOnLeave) {\n          this.clearSensorConfiguration();\n        }\n      });\n    }\n  }\n\n  static #DefaultConnectionManager(): BaseConnectionManager {\n    return new WebBluetoothConnectionManager();\n  }\n\n  #eventDispatcher: DeviceEventDispatcher = new EventDispatcher(\n    this as Device,\n    DeviceEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // CONNECTION MANAGER\n\n  #connectionManager?: BaseConnectionManager;\n  get connectionManager() {\n    return this.#connectionManager;\n  }\n  set connectionManager(newConnectionManager) {\n    if (this.connectionManager == newConnectionManager) {\n      _console.log(\"same connectionManager is already assigned\");\n      return;\n    }\n\n    if (this.connectionManager) {\n      this.connectionManager.remove();\n    }\n    if (newConnectionManager) {\n      newConnectionManager.onStatusUpdated =\n        this.#onConnectionStatusUpdated.bind(this);\n      newConnectionManager.onMessageReceived =\n        this.#onConnectionMessageReceived.bind(this);\n      newConnectionManager.onMessagesReceived =\n        this.#onConnectionMessagesReceived.bind(this);\n    }\n\n    this.#connectionManager = newConnectionManager;\n    _console.log(\"assigned new connectionManager\", this.#connectionManager);\n\n    this._informationManager.connectionType = this.connectionType;\n  }\n  async #sendTxMessages(messages?: TxMessage[], sendImmediately?: boolean) {\n    await this.#connectionManager?.sendTxMessages(messages, sendImmediately);\n  }\n  private sendTxMessages = this.#sendTxMessages.bind(this);\n\n  async connect(options?: ConnectOptions) {\n    if (this.isConnected) {\n      _console.log(\"already connected\");\n      return;\n    }\n    if (this.connectionStatus == \"connecting\") {\n      _console.log(\"already connecting\");\n      return;\n    }\n\n    _console.log(\"connect options\", options);\n    if (options) {\n      switch (options.type) {\n        case \"webBluetooth\":\n          if (this.connectionType != \"webBluetooth\") {\n            this.connectionManager = new WebBluetoothConnectionManager();\n          }\n          break;\n        case \"webSocket\":\n          {\n            let createConnectionManager = false;\n            if (this.connectionType == \"webSocket\") {\n              const connectionManager = this\n                .connectionManager as WebSocketConnectionManager;\n              if (\n                connectionManager.ipAddress != options.ipAddress ||\n                connectionManager.isSecure != options.isWifiSecure\n              ) {\n                createConnectionManager = true;\n              }\n            } else {\n              createConnectionManager = true;\n            }\n            if (createConnectionManager) {\n              this.connectionManager = new WebSocketConnectionManager(\n                options.ipAddress,\n                options.isWifiSecure,\n                this.bluetoothId\n              );\n            }\n          }\n\n          break;\n        case \"udp\":\n          {\n            let createConnectionManager = false;\n            if (this.connectionType == \"udp\") {\n              const connectionManager = this\n                .connectionManager as UDPConnectionManager;\n              if (connectionManager.ipAddress != options.ipAddress) {\n                createConnectionManager = true;\n              }\n              this.reconnectOnDisconnection = true;\n            } else {\n              createConnectionManager = true;\n            }\n            if (createConnectionManager) {\n              this.connectionManager = new UDPConnectionManager(\n                options.ipAddress,\n                this.bluetoothId\n              );\n            }\n          }\n          break;\n      }\n    }\n    if (!this.connectionManager) {\n      this.connectionManager = Device.#DefaultConnectionManager();\n    }\n    this.#clear();\n\n    if (options?.type == \"client\") {\n      _console.assertWithError(\n        this.connectionType == \"client\",\n        \"expected clientConnectionManager\"\n      );\n      const clientConnectionManager = this\n        .connectionManager as ClientConnectionManager;\n      clientConnectionManager.subType = options.subType;\n      return clientConnectionManager.connect();\n    }\n    _console.log(\"connectionManager type\", this.connectionManager.type);\n    return this.connectionManager.connect();\n  }\n  #isConnected = false;\n  get isConnected() {\n    return this.#isConnected;\n  }\n  /** @throws {Error} if not connected */\n  #assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"notConnected\");\n  }\n\n  #didReceiveMessageTypes(messageTypes: ConnectionMessageType[]) {\n    return messageTypes.every((messageType) => {\n      const hasConnectionMessage =\n        this.latestConnectionMessages.has(messageType);\n      if (!hasConnectionMessage) {\n        _console.log(`didn't receive \"${messageType}\" message`);\n      }\n      return hasConnectionMessage;\n    });\n  }\n  get #hasRequiredInformation() {\n    let hasRequiredInformation = this.#didReceiveMessageTypes(\n      RequiredInformationConnectionMessages\n    );\n    if (hasRequiredInformation && this.sensorTypes.includes(\"pressure\")) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredPressureMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.isWifiAvailable) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredWifiMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.fileTypes.length > 0) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredFileTransferMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.fileTypes.includes(\"tflite\")) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredTfliteMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.hasCamera) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredCameraMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.hasMicrophone) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredMicrophoneMessageTypes\n      );\n    }\n    if (hasRequiredInformation && this.isDisplayAvailable) {\n      hasRequiredInformation = this.#didReceiveMessageTypes(\n        RequiredDisplayMessageTypes\n      );\n    }\n    return hasRequiredInformation;\n  }\n  #requestRequiredInformation() {\n    _console.log(\"requesting required information\");\n    const messages: TxMessage[] = RequiredInformationConnectionMessages.map(\n      (messageType) => ({\n        type: messageType,\n      })\n    );\n    this.#sendTxMessages(messages);\n  }\n\n  get canReconnect() {\n    return this.connectionManager?.canReconnect;\n  }\n  #assertCanReconnect() {\n    _console.assertWithError(this.canReconnect, \"cannot reconnect to device\");\n  }\n  async reconnect() {\n    if (this.isConnected) {\n      _console.log(\"already connected\");\n      return;\n    }\n    if (this.connectionStatus == \"connecting\") {\n      _console.log(\"already connecting\");\n      return;\n    }\n    if (!this.canReconnect) {\n      _console.warn(\"cannot reconnect\");\n      return false;\n    }\n    // this.#assertCanReconnect();\n    _console.log(\"attempting to reconnect...\");\n    this.#clear();\n    _console.log(\"reconnecting...\");\n    return this.connectionManager?.reconnect();\n  }\n\n  static async Connect() {\n    const device = new Device();\n    await device.connect();\n    return device;\n  }\n\n  static #ReconnectOnDisconnection = false;\n  static get ReconnectOnDisconnection() {\n    return this.#ReconnectOnDisconnection;\n  }\n  static set ReconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this.#ReconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  #reconnectOnDisconnection = Device.ReconnectOnDisconnection;\n  get reconnectOnDisconnection() {\n    return this.#reconnectOnDisconnection;\n  }\n  set reconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this.#reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n  #reconnectIntervalId?: NodeJS.Timeout | number;\n\n  get connectionType() {\n    return this.connectionManager?.type;\n  }\n  async disconnect() {\n    if (this.connectionStatus == \"notConnected\") {\n      _console.log(\"already not connected\");\n      return;\n    }\n    if (this.connectionStatus == \"disconnecting\") {\n      _console.log(\"already disconnecting\");\n      return;\n    }\n    //this.#assertIsConnected();\n    if (this.reconnectOnDisconnection) {\n      this.reconnectOnDisconnection = false;\n      this.addEventListener(\n        \"isConnected\",\n        () => {\n          this.reconnectOnDisconnection = true;\n        },\n        { once: true }\n      );\n    }\n\n    return this.connectionManager!.disconnect();\n  }\n\n  toggleConnection() {\n    if (this.isConnected) {\n      this.disconnect();\n    } else if (this.canReconnect) {\n      try {\n        this.reconnect();\n      } catch (error) {\n        _console.error(\"error trying to reconnect\", error);\n        this.connect();\n      }\n    } else {\n      this.connect();\n    }\n  }\n\n  get connectionStatus(): ConnectionStatus {\n    switch (this.#connectionManager?.status) {\n      case \"connected\":\n        return this.isConnected ? \"connected\" : \"connecting\";\n      case \"notConnected\":\n      case \"connecting\":\n      case \"disconnecting\":\n        return this.#connectionManager.status;\n      default:\n        return \"notConnected\";\n    }\n  }\n  get isConnectionBusy() {\n    return (\n      this.connectionStatus == \"connecting\" ||\n      this.connectionStatus == \"disconnecting\"\n    );\n  }\n\n  #onConnectionStatusUpdated(connectionStatus: ConnectionStatus) {\n    _console.log({ connectionStatus });\n\n    if (connectionStatus == \"notConnected\") {\n      this.#clearConnection();\n\n      if (this.canReconnect && this.reconnectOnDisconnection) {\n        _console.log(\"starting reconnect interval...\");\n        this.#reconnectIntervalId = setInterval(() => {\n          _console.log(\"attempting reconnect...\");\n          this.reconnect();\n        }, 1000);\n      }\n    } else {\n      if (this.#reconnectIntervalId != undefined) {\n        _console.log(\"clearing reconnect interval\");\n        clearInterval(this.#reconnectIntervalId);\n        this.#reconnectIntervalId = undefined;\n      }\n    }\n\n    this.#checkConnection();\n\n    if (connectionStatus == \"connected\" && !this.#isConnected) {\n      if (this.connectionType != \"client\") {\n        this.#requestRequiredInformation();\n      }\n    }\n\n    DeviceManager.OnDeviceConnectionStatusUpdated(this, connectionStatus);\n  }\n\n  #dispatchConnectionEvents(includeIsConnected: boolean = false) {\n    this.#dispatchEvent(\"connectionStatus\", {\n      connectionStatus: this.connectionStatus,\n    });\n    this.#dispatchEvent(this.connectionStatus, {});\n    if (includeIsConnected) {\n      this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    }\n  }\n  #checkConnection() {\n    this.#isConnected =\n      Boolean(this.connectionManager?.isConnected) &&\n      this.#hasRequiredInformation &&\n      this._informationManager.isCurrentTimeSet;\n\n    switch (this.connectionStatus) {\n      case \"connected\":\n        if (this.#isConnected) {\n          this.#dispatchConnectionEvents(true);\n        }\n        break;\n      case \"notConnected\":\n        this.#dispatchConnectionEvents(true);\n        break;\n      default:\n        this.#dispatchConnectionEvents(false);\n        break;\n    }\n  }\n\n  #clear() {\n    this.#clearConnection();\n    this._informationManager.clear();\n    this.#deviceInformationManager.clear();\n    this.#tfliteManager.clear();\n    this.#fileTransferManager.clear();\n    this.#wifiManager.clear();\n    this.#cameraManager.clear();\n    this.#microphoneManager.clear();\n    this.#sensorConfigurationManager.clear();\n    this.#displayManager.reset();\n    this.#isServerSide = false;\n    this.#batteryLevel = undefined;\n  }\n  #clearConnection() {\n    this.connectionManager?.clear();\n    this.latestConnectionMessages.clear();\n  }\n\n  #onConnectionMessageReceived(\n    messageType: ConnectionMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    _console.log({ messageType, dataView });\n    switch (messageType) {\n      case \"batteryLevel\":\n        const batteryLevel = dataView.getUint8(0);\n        _console.log(\"received battery level\", { batteryLevel });\n        this.#updateBatteryLevel(batteryLevel);\n        break;\n\n      default:\n        if (\n          FileTransferMessageTypes.includes(\n            messageType as FileTransferMessageType\n          )\n        ) {\n          this.#fileTransferManager.parseMessage(\n            messageType as FileTransferMessageType,\n            dataView\n          );\n        } else if (\n          TfliteMessageTypes.includes(messageType as TfliteMessageType)\n        ) {\n          this.#tfliteManager.parseMessage(\n            messageType as TfliteMessageType,\n            dataView\n          );\n        } else if (\n          SensorDataMessageTypes.includes(messageType as SensorDataMessageType)\n        ) {\n          this.#sensorDataManager.parseMessage(\n            messageType as SensorDataMessageType,\n            dataView\n          );\n        } else if (\n          FirmwareMessageTypes.includes(messageType as FirmwareMessageType)\n        ) {\n          this.#firmwareManager.parseMessage(\n            messageType as FirmwareMessageType,\n            dataView\n          );\n        } else if (\n          DeviceInformationTypes.includes(messageType as DeviceInformationType)\n        ) {\n          this.#deviceInformationManager.parseMessage(\n            messageType as DeviceInformationType,\n            dataView\n          );\n        } else if (\n          InformationMessageTypes.includes(\n            messageType as InformationMessageType\n          )\n        ) {\n          this._informationManager.parseMessage(\n            messageType as InformationMessageType,\n            dataView\n          );\n        } else if (\n          SensorConfigurationMessageTypes.includes(\n            messageType as SensorConfigurationMessageType\n          )\n        ) {\n          this.#sensorConfigurationManager.parseMessage(\n            messageType as SensorConfigurationMessageType,\n            dataView\n          );\n        } else if (\n          VibrationMessageTypes.includes(messageType as VibrationMessageType)\n        ) {\n          this.#vibrationManager.parseMessage(\n            messageType as VibrationMessageType,\n            dataView\n          );\n        } else if (WifiMessageTypes.includes(messageType as WifiMessageType)) {\n          this.#wifiManager.parseMessage(\n            messageType as WifiMessageType,\n            dataView\n          );\n        } else if (\n          CameraMessageTypes.includes(messageType as CameraMessageType)\n        ) {\n          this.#cameraManager.parseMessage(\n            messageType as CameraMessageType,\n            dataView\n          );\n        } else if (\n          MicrophoneMessageTypes.includes(messageType as MicrophoneMessageType)\n        ) {\n          this.#microphoneManager.parseMessage(\n            messageType as MicrophoneMessageType,\n            dataView\n          );\n        } else if (\n          DisplayMessageTypes.includes(messageType as DisplayMessageType)\n        ) {\n          this.#displayManager.parseMessage(\n            messageType as DisplayMessageType,\n            dataView\n          );\n        } else {\n          throw Error(`uncaught messageType ${messageType}`);\n        }\n    }\n\n    this.latestConnectionMessages.set(messageType, dataView);\n    if (messageType.startsWith(\"set\")) {\n      this.latestConnectionMessages.set(\n        // @ts-expect-error\n        messageType.replace(\"set\", \"get\"),\n        dataView\n      );\n    }\n    this.#dispatchEvent(\"connectionMessage\", { messageType, dataView });\n  }\n  #onConnectionMessagesReceived() {\n    if (!this.isConnected && this.#hasRequiredInformation) {\n      this.#checkConnection();\n    }\n    if (\n      this.connectionStatus == \"notConnected\" ||\n      this.connectionStatus == \"disconnecting\"\n    ) {\n      return;\n    }\n    this.#sendTxMessages();\n  }\n\n  latestConnectionMessages: Map<ConnectionMessageType, DataView> = new Map();\n\n  // DEVICE INFORMATION\n  #deviceInformationManager = new DeviceInformationManager();\n  get deviceInformation() {\n    return this.#deviceInformationManager.information;\n  }\n\n  // BATTERY LEVEL\n  #batteryLevel?: number = undefined;\n  get batteryLevel() {\n    return this.#batteryLevel ?? 0;\n  }\n  #updateBatteryLevel(updatedBatteryLevel: number) {\n    _console.assertTypeWithError(updatedBatteryLevel, \"number\");\n    if (this.#batteryLevel == updatedBatteryLevel) {\n      _console.log(`duplicate batteryLevel assignment ${updatedBatteryLevel}`);\n      return;\n    }\n    this.#batteryLevel = updatedBatteryLevel;\n    _console.log({ updatedBatteryLevel: this.#batteryLevel });\n    this.#dispatchEvent(\"batteryLevel\", { batteryLevel: this.#batteryLevel });\n  }\n\n  // INFORMATION\n  /** @private */\n  _informationManager = new InformationManager();\n\n  get id() {\n    return this._informationManager.id;\n  }\n\n  get isCharging() {\n    return this._informationManager.isCharging;\n  }\n  get batteryCurrent() {\n    return this._informationManager.batteryCurrent;\n  }\n  get getBatteryCurrent() {\n    return this._informationManager.getBatteryCurrent;\n  }\n\n  get name() {\n    return this._informationManager.name;\n  }\n  get setName() {\n    return this._informationManager.setName;\n  }\n\n  get type() {\n    return this._informationManager.type;\n  }\n  get setType() {\n    return this._informationManager.setType;\n  }\n\n  get isInsole() {\n    return this._informationManager.isInsole;\n  }\n  get isGlove() {\n    return this._informationManager.isGlove;\n  }\n  get side() {\n    return this._informationManager.side;\n  }\n\n  get mtu() {\n    return this._informationManager.mtu;\n  }\n\n  // SENSOR TYPES\n  get sensorTypes() {\n    return Object.keys(this.sensorConfiguration) as SensorType[];\n  }\n  get continuousSensorTypes() {\n    return ContinuousSensorTypes.filter((sensorType) =>\n      this.sensorTypes.includes(sensorType)\n    );\n  }\n\n  // SENSOR CONFIGURATION\n\n  #sensorConfigurationManager = new SensorConfigurationManager();\n\n  get sensorConfiguration() {\n    return this.#sensorConfigurationManager.configuration;\n  }\n\n  get setSensorConfiguration() {\n    this.#assertIsConnected();\n    return this.#sensorConfigurationManager.setConfiguration;\n  }\n  get availableSensorTypes() {\n    return this.#sensorConfigurationManager.availableSensorTypes;\n  }\n  get hasSensorType() {\n    return this.#sensorConfigurationManager.hasSensorType;\n  }\n\n  async clearSensorConfiguration() {\n    this.#assertIsConnected();\n    return this.#sensorConfigurationManager.clearSensorConfiguration();\n  }\n\n  static #ClearSensorConfigurationOnLeave = true;\n  static get ClearSensorConfigurationOnLeave() {\n    return this.#ClearSensorConfigurationOnLeave;\n  }\n  static set ClearSensorConfigurationOnLeave(\n    newClearSensorConfigurationOnLeave\n  ) {\n    _console.assertTypeWithError(newClearSensorConfigurationOnLeave, \"boolean\");\n    this.#ClearSensorConfigurationOnLeave = newClearSensorConfigurationOnLeave;\n  }\n\n  #clearSensorConfigurationOnLeave = Device.ClearSensorConfigurationOnLeave;\n  get clearSensorConfigurationOnLeave() {\n    return this.#clearSensorConfigurationOnLeave;\n  }\n  set clearSensorConfigurationOnLeave(newClearSensorConfigurationOnLeave) {\n    _console.assertTypeWithError(newClearSensorConfigurationOnLeave, \"boolean\");\n    this.#clearSensorConfigurationOnLeave = newClearSensorConfigurationOnLeave;\n  }\n\n  // PRESSURE\n  #assertPressure() {\n    _console.assertWithError(\n      this.hasSensorType(\"pressure\"),\n      \"pressure sensorType not included in device\"\n    );\n  }\n  get numberOfPressureSensors() {\n    if (this.hasSensorType(\"pressure\")) {\n      return this.#sensorDataManager.pressureSensorDataManager.numberOfSensors;\n    } else {\n      return 0;\n    }\n  }\n  get pressureSensorPositions() {\n    if (this.hasSensorType(\"pressure\")) {\n      return this.#sensorDataManager.pressureSensorDataManager.positions;\n    } else {\n      return [];\n    }\n  }\n\n  // SENSOR DATA\n  #sensorDataManager = new SensorDataManager();\n  resetPressureRange() {\n    this.#sensorDataManager.pressureSensorDataManager.resetRange();\n  }\n\n  // VIBRATION\n  get vibrationLocations() {\n    return this.#vibrationManager.vibrationLocations;\n  }\n\n  #vibrationManager = new VibrationManager();\n  async triggerVibration(\n    vibrationConfigurations: VibrationConfiguration[],\n    sendImmediately?: boolean\n  ) {\n    this.#vibrationManager.triggerVibration(\n      vibrationConfigurations,\n      sendImmediately\n    );\n  }\n\n  // FILE TRANSFER\n  #fileTransferManager = new FileTransferManager();\n\n  get fileTypes() {\n    return this.#fileTransferManager.fileTypes;\n  }\n  get maxFileLength() {\n    return this.#fileTransferManager.maxLength;\n  }\n  get validFileTypes() {\n    return FileTypes.filter((fileType) => {\n      if (fileType.includes(\"wifi\") && !this.isWifiAvailable) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  async sendFile(fileType: FileType, file: FileLike) {\n    _console.assertWithError(\n      this.validFileTypes.includes(fileType),\n      `invalid fileType ${fileType}`\n    );\n    const promise = this.waitForEvent(\"fileTransferComplete\");\n    this.#fileTransferManager.send(fileType, file);\n    await promise;\n  }\n  async receiveFile(fileType: FileType) {\n    const promise = this.waitForEvent(\"fileTransferComplete\");\n    this.#fileTransferManager.receive(fileType);\n    await promise;\n  }\n\n  get fileTransferStatus() {\n    return this.#fileTransferManager.status;\n  }\n\n  cancelFileTransfer() {\n    this.#fileTransferManager.cancel();\n  }\n\n  // TFLITE\n  #tfliteManager = new TfliteManager();\n\n  get isTfliteAvailable() {\n    return this.fileTypes.includes(\"tflite\");\n  }\n  get tfliteName() {\n    return this.#tfliteManager.name;\n  }\n  get setTfliteName() {\n    return this.#tfliteManager.setName;\n  }\n\n  async sendTfliteConfiguration(configuration: TfliteFileConfiguration) {\n    configuration.type = \"tflite\";\n    this.#tfliteManager.sendConfiguration(configuration, false);\n    const didSendFile = await this.#fileTransferManager.send(\n      configuration.type,\n      configuration.file\n    );\n    _console.log({ didSendFile });\n    if (!didSendFile) {\n      this.#sendTxMessages();\n      if (this.tfliteIsReady) {\n        this.#dispatchEvent(\"tfliteIsReady\", {\n          tfliteIsReady: this.tfliteIsReady,\n        });\n      }\n    }\n  }\n\n  get tfliteClasses() {\n    return this.#tfliteManager.classes;\n  }\n  get setTfliteClasses() {\n    return this.#tfliteManager.setClasses;\n  }\n\n  // TFLITE MODEL CONFIG\n  get tfliteTask() {\n    return this.#tfliteManager.task;\n  }\n  get setTfliteTask() {\n    return this.#tfliteManager.setTask;\n  }\n  get tfliteSampleRate() {\n    return this.#tfliteManager.sampleRate;\n  }\n  get setTfliteSampleRate() {\n    return this.#tfliteManager.setSampleRate;\n  }\n  get tfliteSensorTypes() {\n    return this.#tfliteManager.sensorTypes;\n  }\n  get allowedTfliteSensorTypes() {\n    return this.sensorTypes.filter((sensorType) =>\n      TfliteSensorTypes.includes(sensorType as TfliteSensorType)\n    );\n  }\n  get setTfliteSensorTypes() {\n    return this.#tfliteManager.setSensorTypes;\n  }\n  get tfliteIsReady() {\n    return this.#tfliteManager.isReady;\n  }\n\n  // TFLITE INFERENCING\n\n  get tfliteInferencingEnabled() {\n    return this.#tfliteManager.inferencingEnabled;\n  }\n  get setTfliteInferencingEnabled() {\n    return this.#tfliteManager.setInferencingEnabled;\n  }\n  async enableTfliteInferencing() {\n    return this.setTfliteInferencingEnabled(true);\n  }\n  async disableTfliteInferencing() {\n    return this.setTfliteInferencingEnabled(false);\n  }\n  get toggleTfliteInferencing() {\n    return this.#tfliteManager.toggleInferencingEnabled;\n  }\n\n  // TFLITE INFERENCE CONFIG\n\n  get tfliteCaptureDelay() {\n    return this.#tfliteManager.captureDelay;\n  }\n  get setTfliteCaptureDelay() {\n    return this.#tfliteManager.setCaptureDelay;\n  }\n  get tfliteThreshold() {\n    return this.#tfliteManager.threshold;\n  }\n  get setTfliteThreshold() {\n    return this.#tfliteManager.setThreshold;\n  }\n\n  // FIRMWARE MANAGER\n\n  #firmwareManager = new FirmwareManager();\n\n  get canUpdateFirmware() {\n    return this.#connectionManager?.canUpdateFirmware;\n  }\n  #assertCanUpdateFirmware() {\n    _console.assertWithError(this.canUpdateFirmware, \"can't update firmware\");\n  }\n\n  #sendSmpMessage(data: ArrayBuffer) {\n    this.#assertCanUpdateFirmware();\n    return this.#connectionManager!.sendSmpMessage(data);\n  }\n  private sendSmpMessage = this.#sendSmpMessage.bind(this);\n\n  get uploadFirmware() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.uploadFirmware;\n  }\n  get canReset() {\n    return this.canUpdateFirmware;\n  }\n  async reset() {\n    _console.assertWithError(\n      this.canReset,\n      \"reset is not enabled for this device\"\n    );\n    await this.#firmwareManager.reset();\n    return this.#connectionManager!.disconnect();\n  }\n  get firmwareStatus() {\n    return this.#firmwareManager.status;\n  }\n  get getFirmwareImages() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.getImages;\n  }\n  get firmwareImages() {\n    return this.#firmwareManager.images;\n  }\n  get eraseFirmwareImage() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.eraseImage;\n  }\n  get confirmFirmwareImage() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.confirmImage;\n  }\n  get testFirmwareImage() {\n    this.#assertCanUpdateFirmware();\n    return this.#firmwareManager.testImage;\n  }\n\n  // SERVER SIDE\n  #isServerSide = false;\n  get isServerSide() {\n    return this.#isServerSide;\n  }\n  set isServerSide(newIsServerSide) {\n    if (this.#isServerSide == newIsServerSide) {\n      _console.log(\"redundant isServerSide assignment\");\n      return;\n    }\n    _console.log({ newIsServerSide });\n    this.#isServerSide = newIsServerSide;\n\n    this.#fileTransferManager.isServerSide = this.isServerSide;\n    this.#displayManager.isServerSide = this.isServerSide;\n  }\n\n  // UKATON\n  get isUkaton() {\n    return this.deviceInformation.modelNumber.includes(\"Ukaton\");\n  }\n\n  // WIFI MANAGER\n  #wifiManager = new WifiManager();\n  get isWifiAvailable() {\n    return this.#wifiManager.isWifiAvailable;\n  }\n  get wifiSSID() {\n    return this.#wifiManager.wifiSSID;\n  }\n  async setWifiSSID(newWifiSSID: string) {\n    return this.#wifiManager.setWifiSSID(newWifiSSID);\n  }\n  get wifiPassword() {\n    return this.#wifiManager.wifiPassword;\n  }\n  async setWifiPassword(newWifiPassword: string) {\n    return this.#wifiManager.setWifiPassword(newWifiPassword);\n  }\n  get isWifiConnected() {\n    return this.#wifiManager.isWifiConnected;\n  }\n  get ipAddress() {\n    return this.#wifiManager.ipAddress;\n  }\n  get wifiConnectionEnabled() {\n    return this.#wifiManager.wifiConnectionEnabled;\n  }\n  get enableWifiConnection() {\n    return this.#wifiManager.enableWifiConnection;\n  }\n  get setWifiConnectionEnabled() {\n    return this.#wifiManager.setWifiConnectionEnabled;\n  }\n  get disableWifiConnection() {\n    return this.#wifiManager.disableWifiConnection;\n  }\n  get toggleWifiConnection() {\n    return this.#wifiManager.toggleWifiConnection;\n  }\n  get isWifiSecure() {\n    return this.#wifiManager.isWifiSecure;\n  }\n\n  async reconnectViaWebSockets() {\n    _console.assertWithError(this.isWifiConnected, \"wifi is not connected\");\n    _console.assertWithError(\n      this.connectionType != \"webSocket\",\n      \"already connected via webSockets\"\n    );\n    _console.assertTypeWithError(this.ipAddress, \"string\");\n    _console.log(\"reconnecting via websockets...\");\n    await this.disconnect();\n    await this.connect({\n      type: \"webSocket\",\n      ipAddress: this.ipAddress!,\n      isWifiSecure: this.isWifiSecure,\n    });\n  }\n\n  async reconnectViaUDP() {\n    _console.assertWithError(isInNode, \"udp is only available in node\");\n    _console.assertWithError(this.isWifiConnected, \"wifi is not connected\");\n    _console.assertWithError(\n      this.connectionType != \"udp\",\n      \"already connected via udp\"\n    );\n    _console.assertTypeWithError(this.ipAddress, \"string\");\n    _console.log(\"reconnecting via udp...\");\n    await this.disconnect();\n    await this.connect({\n      type: \"udp\",\n      ipAddress: this.ipAddress!,\n    });\n  }\n\n  // CAMERA\n  #cameraManager = new CameraManager();\n\n  private get _buildCameraData() {\n    return this.#cameraManager.buildCameraData;\n  }\n  get hasCamera() {\n    return this.sensorTypes.includes(\"camera\");\n  }\n  get cameraStatus() {\n    return this.#cameraManager.cameraStatus;\n  }\n  #assertHasCamera() {\n    _console.assertWithError(this.hasCamera, \"camera not available\");\n  }\n  async takePicture(sensorRate?: number) {\n    this.#assertHasCamera();\n    if (sensorRate == undefined && this.sensorConfiguration.camera == 0) {\n      sensorRate = 20;\n    }\n    if (\n      sensorRate != undefined &&\n      this.sensorConfiguration.camera != sensorRate\n    ) {\n      this.setSensorConfiguration({ camera: sensorRate }, false, false);\n    }\n    await this.#cameraManager.takePicture();\n  }\n  get autoPicture() {\n    return this.#cameraManager.autoPicture;\n  }\n  set autoPicture(newAutoPicture) {\n    this.#cameraManager.autoPicture = newAutoPicture;\n  }\n  async focusCamera(sensorRate?: number) {\n    this.#assertHasCamera();\n    if (sensorRate == undefined && this.sensorConfiguration.camera == 0) {\n      sensorRate = 20;\n    }\n    if (\n      sensorRate != undefined &&\n      this.sensorConfiguration.camera != sensorRate\n    ) {\n      this.setSensorConfiguration({ camera: sensorRate }, false, false);\n    }\n    await this.#cameraManager.focus();\n  }\n  async stopCamera() {\n    this.#assertHasCamera();\n    await this.#cameraManager.stop();\n  }\n  async wakeCamera() {\n    this.#assertHasCamera();\n    await this.#cameraManager.wake();\n  }\n  async sleepCamera() {\n    this.#assertHasCamera();\n    await this.#cameraManager.sleep();\n  }\n\n  get cameraConfiguration() {\n    return this.#cameraManager.cameraConfiguration;\n  }\n  get availableCameraConfigurationTypes() {\n    return this.#cameraManager.availableCameraConfigurationTypes;\n  }\n  get cameraConfigurationRanges() {\n    return this.#cameraManager.cameraConfigurationRanges;\n  }\n\n  get setCameraConfiguration() {\n    return this.#cameraManager.setCameraConfiguration;\n  }\n\n  get isRecordingCamera() {\n    return this.#cameraManager.isRecording;\n  }\n  startRecordingCamera() {\n    this.#cameraManager.startRecording();\n  }\n  stopRecordingCamera() {\n    this.#cameraManager.stopRecording();\n  }\n  toggleCameraRecording() {\n    this.#cameraManager.toggleRecording();\n  }\n\n  // MICROPHONE\n  #microphoneManager = new MicrophoneManager();\n  get hasMicrophone() {\n    return this.sensorTypes.includes(\"microphone\");\n  }\n  get microphoneStatus() {\n    return this.#microphoneManager.microphoneStatus;\n  }\n  #assertHasMicrophone() {\n    _console.assertWithError(this.hasMicrophone, \"microphone not available\");\n  }\n\n  async startMicrophone(sensorRate?: number) {\n    this.#assertHasMicrophone();\n    if (sensorRate == undefined && this.sensorConfiguration.microphone == 0) {\n      sensorRate = 5;\n    }\n    if (\n      sensorRate != undefined &&\n      this.sensorConfiguration.microphone != sensorRate\n    ) {\n      this.setSensorConfiguration({ microphone: sensorRate }, false, false);\n    }\n    await this.#microphoneManager.start();\n  }\n  async stopMicrophone() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.stop();\n  }\n  async enableMicrophoneVad() {\n    this.#assertHasMicrophone();\n    await this.#microphoneManager.vad();\n  }\n  async toggleMicrophone(sensorRate: number = 20) {\n    this.#assertHasMicrophone();\n    if (\n      this.sensorConfiguration.microphone == 0 &&\n      this.sensorConfiguration.microphone != sensorRate\n    ) {\n      this.setSensorConfiguration({ microphone: sensorRate }, false, false);\n    }\n    await this.#microphoneManager.toggle();\n  }\n\n  get microphoneConfiguration() {\n    return this.#microphoneManager.microphoneConfiguration;\n  }\n  get availableMicrophoneConfigurationTypes() {\n    return this.#microphoneManager.availableMicrophoneConfigurationTypes;\n  }\n  get setMicrophoneConfiguration() {\n    return this.#microphoneManager.setMicrophoneConfiguration;\n  }\n\n  #assertWebAudioSupport() {\n    _console.assertWithError(AudioContext, \"WebAudio is not supported\");\n  }\n\n  get audioContext() {\n    this.#assertWebAudioSupport();\n    return this.#microphoneManager.audioContext;\n  }\n  set audioContext(newAudioContext) {\n    this.#assertWebAudioSupport();\n    this.#microphoneManager.audioContext = newAudioContext;\n  }\n  get microphoneMediaStreamDestination() {\n    this.#assertWebAudioSupport();\n    return this.#microphoneManager.mediaStreamDestination;\n  }\n  get microphoneGainNode() {\n    this.#assertWebAudioSupport();\n    return this.#microphoneManager.gainNode;\n  }\n\n  get isRecordingMicrophone() {\n    return this.#microphoneManager.isRecording;\n  }\n  startRecordingMicrophone() {\n    this.#microphoneManager.startRecording();\n  }\n  stopRecordingMicrophone() {\n    this.#microphoneManager.stopRecording();\n  }\n  toggleMicrophoneRecording() {\n    this.#microphoneManager.toggleRecording();\n  }\n\n  // DISPLAY\n  #displayManager = new DisplayManager();\n\n  get isDisplayAvailable() {\n    return this.#displayManager.isAvailable;\n  }\n  get isDisplayReady() {\n    return this.#displayManager.isReady;\n  }\n  get displayContextState() {\n    return this.#displayManager.contextState;\n  }\n  get displayColors() {\n    return this.#displayManager.colors;\n  }\n  get displayBitmapColors() {\n    return this.#displayManager.bitmapColors;\n  }\n  get displayBitmapColorIndices() {\n    return this.#displayManager.bitmapColorIndices;\n  }\n  get displayColorOpacities() {\n    return this.#displayManager.opacities;\n  }\n  #assertDisplayIsAvailable() {\n    _console.assertWithError(this.isDisplayAvailable, \"display not available\");\n  }\n  get displayStatus() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.displayStatus;\n  }\n  get displayBrightness() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.brightness;\n  }\n  get setDisplayBrightness() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBrightness;\n  }\n\n  get displayInformation() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.displayInformation;\n  }\n  get numberOfDisplayColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.numberOfColors;\n  }\n\n  get wakeDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.wake;\n  }\n  get sleepDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.sleep;\n  }\n  get toggleDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.toggle;\n  }\n  get isDisplayAwake() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.isDisplayAwake;\n  }\n\n  get showDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.show;\n  }\n  get clearDisplay() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clear;\n  }\n\n  get setDisplayColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setColor;\n  }\n  get setDisplayColorOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setColorOpacity;\n  }\n  get setDisplayOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setOpacity;\n  }\n\n  get saveDisplayContext() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.saveContext;\n  }\n  get restoreDisplayContext() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.restoreContext;\n  }\n\n  get clearDisplayRect() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearRect;\n  }\n\n  get selectDisplayBackgroundColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectBackgroundColor;\n  }\n  get selectDisplayFillColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectFillColor;\n  }\n  get selectDisplayLineColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectLineColor;\n  }\n  get setDisplayIgnoreFill() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setIgnoreFill;\n  }\n  get setDisplayIgnoreLine() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setIgnoreLine;\n  }\n  get setDisplayFillBackground() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setFillBackground;\n  }\n  get setDisplayLineWidth() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setLineWidth;\n  }\n  get setDisplayRotation() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotation;\n  }\n  get clearDisplayRotation() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearRotation;\n  }\n\n  get setDisplaySegmentStartCap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentStartCap;\n  }\n  get setDisplaySegmentEndCap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentEndCap;\n  }\n  get setDisplaySegmentCap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentCap;\n  }\n\n  get setDisplaySegmentStartRadius() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentStartRadius;\n  }\n  get setDisplaySegmentEndRadius() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentEndRadius;\n  }\n  get setDisplaySegmentRadius() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSegmentRadius;\n  }\n\n  get setDisplayCropTop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropTop;\n  }\n  get setDisplayCropRight() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropRight;\n  }\n  get setDisplayCropBottom() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropBottom;\n  }\n  get setDisplayCropLeft() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCropLeft;\n  }\n  get setDisplayCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setCrop;\n  }\n  get clearDisplayCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearCrop;\n  }\n\n  get setDisplayRotationCropTop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropTop;\n  }\n  get setDisplayRotationCropRight() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropRight;\n  }\n  get setDisplayRotationCropBottom() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropBottom;\n  }\n  get setDisplayRotationCropLeft() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCropLeft;\n  }\n  get setDisplayRotationCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setRotationCrop;\n  }\n  get clearDisplayRotationCrop() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.clearRotationCrop;\n  }\n  get flushDisplayContextCommands() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.flushContextCommands;\n  }\n\n  get drawDisplayRect() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawRect;\n  }\n  get drawDisplayCircle() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawCircle;\n  }\n  get drawDisplayEllipse() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawEllipse;\n  }\n  get drawDisplayRoundRect() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawRoundRect;\n  }\n  get drawDisplayRegularPolygon() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawRegularPolygon;\n  }\n  get drawDisplayPolygon() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawPolygon;\n  }\n  get drawDisplayWireframe() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawWireframe;\n  }\n  get drawDisplaySegment() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawSegment;\n  }\n  get drawDisplaySegments() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawSegments;\n  }\n  get drawDisplayArc() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawArc;\n  }\n  get drawDisplayArcEllipse() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawArcEllipse;\n  }\n  get drawDisplayBitmap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawBitmap;\n  }\n  get imageToDisplayBitmap() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.imageToBitmap;\n  }\n  get quantizeDisplayImage() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.quantizeImage;\n  }\n  get resizeAndQuantizeDisplayImage() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.resizeAndQuantizeImage;\n  }\n\n  get setDisplayContextState() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setContextState;\n  }\n\n  get selectDisplayBitmapColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectBitmapColor;\n  }\n  get selectDisplayBitmapColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectBitmapColors;\n  }\n  get setDisplayBitmapColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapColor;\n  }\n  get setDisplayBitmapColorOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapColorOpacity;\n  }\n\n  get setDisplayBitmapScaleDirection() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScaleDirection;\n  }\n  get setDisplayBitmapScaleX() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScaleX;\n  }\n  get setDisplayBitmapScaleY() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScaleY;\n  }\n  get setDisplayBitmapScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setBitmapScale;\n  }\n  get resetDisplayBitmapScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.resetBitmapScale;\n  }\n\n  get selectDisplaySpriteColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectSpriteColor;\n  }\n  get selectDisplaySpriteColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectSpriteColors;\n  }\n  get setDisplaySpriteColor() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteColor;\n  }\n  get setDisplaySpriteColorOpacity() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteColorOpacity;\n  }\n  get resetDisplaySpriteColors() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.resetSpriteColors;\n  }\n\n  get setDisplaySpriteScaleDirection() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteScaleDirection;\n  }\n  get setDisplaySpriteScaleX() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteScaleX;\n  }\n  get setDisplaySpriteScaleY() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteScaleY;\n  }\n  get setDisplaySpriteScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.setSpriteScale;\n  }\n  get resetDisplaySpriteScale() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.resetSpriteScale;\n  }\n\n  get displayManager() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager as DisplayManagerInterface;\n  }\n\n  get uploadDisplaySpriteSheet() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.uploadSpriteSheet;\n  }\n  get uploadDisplaySpriteSheets() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.uploadSpriteSheets;\n  }\n  get selectDisplaySpriteSheet() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.selectSpriteSheet;\n  }\n  get drawDisplaySprite() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.drawSprite;\n  }\n\n  get startDisplaySprite() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.startSprite;\n  }\n  get endDisplaySprite() {\n    this.#assertDisplayIsAvailable();\n    return this.#displayManager.endSprite;\n  }\n\n  get displaySpriteSheets() {\n    return this.#displayManager.spriteSheets;\n  }\n\n  get serializeDisplaySpriteSheet() {\n    return this.#displayManager.serializeSpriteSheet;\n  }\n\n  get setDisplayAlignment() {\n    return this.#displayManager.setAlignment;\n  }\n  get setDisplayVerticalAlignment() {\n    return this.#displayManager.setVerticalAlignment;\n  }\n  get setDisplayHorizontalAlignment() {\n    return this.#displayManager.setHorizontalAlignment;\n  }\n  get resetDisplayAlignment() {\n    return this.#displayManager.resetAlignment;\n  }\n\n  get setDisplaySpritesDirection() {\n    return this.#displayManager.setSpritesDirection;\n  }\n  get setDisplaySpritesLineDirection() {\n    return this.#displayManager.setSpritesLineDirection;\n  }\n  get setDisplaySpritesSpacing() {\n    return this.#displayManager.setSpritesSpacing;\n  }\n  get setDisplaySpritesLineSpacing() {\n    return this.#displayManager.setSpritesLineSpacing;\n  }\n  get setDisplaySpritesAlignment() {\n    return this.#displayManager.setSpritesAlignment;\n  }\n\n  get drawDisplayQuadraticBezierCurve() {\n    return this.#displayManager.drawQuadraticBezierCurve;\n  }\n  get drawDisplayQuadraticBezierCurves() {\n    return this.#displayManager.drawQuadraticBezierCurves;\n  }\n  get drawDisplayCubicBezierCurve() {\n    return this.#displayManager.drawCubicBezierCurve;\n  }\n  get drawDisplayCubicBezierCurves() {\n    return this.#displayManager.drawCubicBezierCurves;\n  }\n  get drawDisplayPath() {\n    return this.#displayManager.drawPath;\n  }\n  get drawDisplayClosedPath() {\n    return this.#displayManager.drawClosedPath;\n  }\n}\n\nexport default Device;\n","import Device, {\n  BoundDeviceEventListeners,\n  DeviceEventMap,\n} from \"../Device.ts\";\nimport {\n  DisplayBitmapColorPair,\n  DisplayBrightness,\n  DisplaySpriteColorPair,\n  DisplayBitmap,\n  DisplaySegment,\n  DisplayBezierCurve,\n  DisplayBezierCurveType,\n  DisplayWireframe,\n  DisplaySize,\n} from \"../DisplayManager.ts\";\nimport {\n  assertValidBitmapPixels,\n  imageToBitmap,\n  quantizeImage,\n  resizeAndQuantizeImage,\n} from \"./DisplayBitmapUtils.ts\";\nimport { hexToRGB, rgbToHex, stringToRGB } from \"./ColorUtils.ts\";\nimport { createConsole } from \"./Console.ts\";\nimport {\n  DefaultDisplayContextState,\n  DisplayAlignment,\n  DisplayAlignmentDirection,\n  DisplayAlignmentDirections,\n  DisplayContextState,\n  DisplayContextStateKey,\n  DisplayDirection,\n  DisplaySegmentCap,\n  isDirectionHorizontal,\n  isDirectionPositive,\n  PartialDisplayContextState,\n} from \"./DisplayContextState.ts\";\nimport DisplayContextStateHelper from \"./DisplayContextStateHelper.ts\";\nimport {\n  assertAnySelectedSpriteSheet,\n  assertLoadedSpriteSheet,\n  assertSelectedSpriteSheet,\n  assertSprite,\n  assertSpritePaletteSwap,\n  assertSpriteSheetPalette,\n  assertSpriteSheetPaletteSwap,\n  DisplayManagerInterface,\n  drawSpriteFromSpriteSheet,\n  getSprite,\n  getSpritePaletteSwap,\n  getSpriteSheetPalette,\n  getSpriteSheetPaletteSwap,\n  runDisplayContextCommand,\n  runDisplayContextCommands,\n  selectSpritePaletteSwap,\n  selectSpriteSheetPalette,\n  selectSpriteSheetPaletteSwap,\n} from \"./DisplayManagerInterface.ts\";\nimport {\n  assertValidColor,\n  assertValidOpacity,\n  assertValidSegmentCap,\n  DisplayScaleDirection,\n  DisplayColorRGB,\n  DisplayCropDirection,\n  DisplayCropDirections,\n  DisplayCropDirectionToStateKey,\n  DisplayRotationCropDirectionToCommandType,\n  DisplayRotationCropDirectionToStateKey,\n  maxDisplayScale,\n  roundScale,\n  minDisplayScale,\n  DisplayAlignmentDirectionToCommandType,\n  DisplayAlignmentDirectionToStateKey,\n  assertValidAlignment,\n  assertValidDirection,\n  trimWireframe,\n  assertValidNumberOfControlPoints,\n  assertValidPathNumberOfControlPoints,\n  assertValidPath,\n  displayCurveTypeToNumberOfControlPoints,\n  maxNumberOfDisplayCurvePoints,\n  displayCurveToleranceSquared,\n  assertValidWireframe,\n  isWireframePolygon,\n} from \"./DisplayUtils.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"./EventDispatcher.ts\";\nimport { addEventListeners, removeEventListeners } from \"./EventUtils.ts\";\nimport {\n  clamp,\n  degToRad,\n  getVector2DistanceSquared,\n  getVector2Midpoint,\n  normalizeRadians,\n  Vector2,\n} from \"./MathUtils.ts\";\nimport { wait } from \"./Timer.ts\";\nimport { DisplayContextCommand } from \"./DisplayContextCommand.ts\";\nimport {\n  assertValidSpriteLines,\n  DisplaySprite,\n  DisplaySpriteLines,\n  DisplaySpritePaletteSwap,\n  DisplaySpriteSheet,\n  DisplaySpriteSheetPalette,\n  DisplaySpriteSheetPaletteSwap,\n  getSpriteLinesMetrics,\n  serializeSpriteSheet,\n  stringToSpriteLines,\n  stringToSpriteLinesMetrics,\n} from \"./DisplaySpriteSheetUtils.ts\";\n\nconst _console = createConsole(\"DisplayCanvasHelper\", { log: false });\n\nexport const DisplayCanvasHelperEventTypes = [\n  \"contextState\",\n  \"numberOfColors\",\n  \"brightness\",\n  \"color\",\n  \"colorOpacity\",\n  \"resize\",\n  \"update\",\n  \"ready\",\n  \"device\",\n  \"deviceIsConnected\",\n  \"deviceConnected\",\n  \"deviceNotConnected\",\n  \"deviceSpriteSheetUploadStart\",\n  \"deviceSpriteSheetUploadProgress\",\n  \"deviceSpriteSheetUploadComplete\",\n  \"deviceUpdated\",\n] as const;\nexport type DisplayCanvasHelperEventType =\n  (typeof DisplayCanvasHelperEventTypes)[number];\n\nexport interface DisplayCanvasHelperEventMessages {\n  contextState: {\n    contextState: DisplayContextState;\n    differences: DisplayContextStateKey[];\n  };\n  numberOfColors: {\n    numberOfColors: number;\n  };\n  brightness: {\n    brightness: DisplayBrightness;\n  };\n  color: {\n    colorIndex: number;\n    colorRGB: DisplayColorRGB;\n    colorHex: string;\n  };\n  colorOpacity: {\n    opacity: number;\n    colorIndex: number;\n  };\n  opacity: {\n    opacity: number;\n  };\n  resize: {\n    width: number;\n    height: number;\n  };\n  update: {};\n  ready: {};\n\n  device: {\n    device?: Device;\n  };\n  deviceIsConnected: {\n    device: Device;\n    isConnected: boolean;\n  };\n  deviceConnected: {\n    device: Device;\n  };\n  deviceNotConnected: {\n    device: Device;\n  };\n\n  deviceSpriteSheetUploadStart: {\n    device: Device;\n    spriteSheet: DisplaySpriteSheet;\n    spriteSheetName: string;\n  };\n  deviceSpriteSheetUploadProgress: {\n    device: Device;\n    spriteSheet: DisplaySpriteSheet;\n    spriteSheetName: string;\n    progress: number;\n  };\n  deviceSpriteSheetUploadComplete: {\n    device: Device;\n    spriteSheet: DisplaySpriteSheet;\n    spriteSheetName: string;\n  };\n\n  deviceUpdated: {\n    device: Device;\n  };\n}\n\nexport type DisplayCanvasHelperEventDispatcher = EventDispatcher<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type DisplayCanvasHelperEvent = Event<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type DisplayCanvasHelperEventMap = EventMap<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type DisplayCanvasHelperEventListenerMap = EventListenerMap<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\nexport type BoundDisplayCanvasHelperEventListeners = BoundEventListeners<\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEventType,\n  DisplayCanvasHelperEventMessages\n>;\n\nexport type DisplayBoundingBox = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nclass DisplayCanvasHelper implements DisplayManagerInterface {\n  constructor() {\n    this.numberOfColors = 16;\n    this.#bitmapContext = this.#bitmapCanvas.getContext(\"2d\")!;\n    this.#bitmapContext.imageSmoothingEnabled = false;\n    this.addEventListener(\"ready\", () => {\n      this.#isReady = true;\n      this.#onSentContextCommands();\n      this.#drawFrontDrawStack();\n    });\n  }\n\n  // EVENT DISPATCHER\n  #eventDispatcher: DisplayCanvasHelperEventDispatcher = new EventDispatcher(\n    this as DisplayCanvasHelper,\n    DisplayCanvasHelperEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // CANVAS\n  #canvas?: HTMLCanvasElement;\n  get canvas() {\n    return this.#canvas;\n  }\n  set canvas(newCanvas) {\n    _console.assertWithError(\n      newCanvas?.nodeName == \"CANVAS\",\n      `assigned non-canvas type ${newCanvas?.nodeName}`\n    );\n    if (this.#canvas == newCanvas) {\n      // _console.log(\"redundant canvas assignment\", newCanvas);\n      return;\n    }\n    this.#canvas = newCanvas;\n    // _console.log(\"assigned canvas\", this.canvas);\n\n    this.#context = this.#canvas?.getContext(\"2d\", {\n      willReadFrequently: true,\n    })!;\n    this.#updateCanvas();\n  }\n  #context!: CanvasRenderingContext2D;\n  get context() {\n    return this.#context;\n  }\n\n  get width() {\n    return this.canvas?.width || 0;\n  }\n  get height() {\n    return this.canvas?.height || 0;\n  }\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n\n  #updateCanvas() {\n    if (!this.canvas) {\n      return;\n    }\n    this.canvas!.style.aspectRatio = `${this.aspectRatio}`;\n    if (!this.device?.isConnected) {\n      return;\n    }\n\n    // _console.log(\"updateCanvas\");\n\n    const { width, height } = this.device.displayInformation!;\n    // _console.log({ width, height });\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.canvas.style.aspectRatio = `${width / height}`;\n\n    this.#dispatchEvent(\"resize\", { width: this.width, height: this.height });\n\n    this.clear();\n  }\n\n  // CONTEXT STACK\n  #frontDrawStack: Function[] = [];\n  #rearDrawStack: Function[] = [];\n  #drawFrontDrawStack() {\n    if (!this.context) {\n      return;\n    }\n    //_console.log(\"drawFrontDrawStack\");\n    this.#context.imageSmoothingEnabled = false;\n\n    this.#save();\n    this.#context.resetTransform();\n    this.#context.clearRect(0, 0, this.width, this.height);\n    this.#restore();\n\n    this.#drawBackground();\n\n    this.#frontDrawStack.forEach((callback) => callback());\n    if (this.#applyTransparency) {\n      this.#applyTransparencyToCanvas();\n    }\n    this.#dispatchEvent(\"update\", {});\n  }\n  #applyTransparencyToCanvas() {\n    const ctx = this.context;\n    const imageData = ctx.getImageData(\n      0,\n      0,\n      this.canvas!.width,\n      this.canvas!.height\n    );\n    const data = imageData.data;\n\n    const alphaBoost = 1.0; // >1 = more opaque, try 1.11.5 for subtlety\n\n    for (let i = 0; i < data.length; i += 4) {\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n\n      // Perceived brightness\n      const brightness = 0.299 * r + 0.587 * g + 0.114 * b;\n      const alpha = Math.min(255, brightness * alphaBoost);\n\n      // Unpremultiply for clarity\n      const scale = alpha > 0 ? 255 / alpha : 0;\n      data[i] = Math.min(255, r * scale);\n      data[i + 1] = Math.min(255, g * scale);\n      data[i + 2] = Math.min(255, b * scale);\n      data[i + 3] = alpha;\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n  }\n\n  #drawBackground() {\n    // _console.log(\"drawBackground\");\n    this.#save();\n    this.#context.resetTransform();\n    this.#context.fillStyle = this.#colorIndexToRgbString(0);\n    this.#context.fillRect(0, 0, this.width, this.height);\n    this.#restore();\n  }\n  #applyTransparency = false;\n  get applyTransparency() {\n    return this.#applyTransparency;\n  }\n  set applyTransparency(newValue) {\n    this.#applyTransparency = newValue;\n    // _console.log({ applyTransparency: this.applyTransparency });\n    this.#drawFrontDrawStack();\n  }\n\n  // DEVICE\n  #device?: Device;\n  get device() {\n    return this.#device;\n  }\n  get deviceDisplayManager() {\n    return this.#device?.displayManager;\n  }\n  set device(newDevice) {\n    if (this.#device == newDevice) {\n      // _console.log(\"redundant device assignment\", newDevice);\n      return;\n    }\n    if (newDevice) {\n      _console.assertWithError(\n        newDevice.isConnected,\n        \"device must be connected\"\n      );\n      _console.assertWithError(\n        newDevice.isDisplayAvailable,\n        \"display must have a display\"\n      );\n    }\n    if (this.#device) {\n      removeEventListeners(this.device, this.#boundDeviceEventListeners);\n      this.#isReady = true;\n    }\n    this.#device = newDevice;\n    addEventListeners(this.#device, this.#boundDeviceEventListeners);\n    _console.log(\"assigned device\", this.device);\n    if (this.device) {\n      this.numberOfColors = this.device.numberOfDisplayColors!;\n      this.#updateCanvas();\n      this.#updateDevice();\n      this.#isReady = this.device.isDisplayReady;\n\n      this.#dispatchEvent(\"deviceIsConnected\", {\n        device: this.device,\n        isConnected: this.device!.isConnected,\n      });\n      this.#dispatchEvent(\n        this.device.isConnected ? \"deviceConnected\" : \"deviceNotConnected\",\n        {\n          device: this.device,\n        }\n      );\n    }\n    this.#dispatchEvent(\"device\", {\n      device: this.device,\n    });\n  }\n\n  async flushContextCommands() {\n    if (this.#device?.isConnected) {\n      await this.#device.flushDisplayContextCommands();\n    }\n    this.#onSentContextCommands();\n  }\n\n  // DEVICE EVENTLISTENERS\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    isConnected: this.#onDeviceIsConnected.bind(this),\n    connected: this.#onDeviceConnected.bind(this),\n    notConnected: this.#onDeviceNotConnected.bind(this),\n    displayReady: this.#onDeviceDisplayReady.bind(this),\n    displaySpriteSheetUploadStart:\n      this.#onDeviceDisplaySpriteSheetUploadStart.bind(this),\n    displaySpriteSheetUploadProgress:\n      this.#onDeviceDisplaySpriteSheetUploadProgress.bind(this),\n    displaySpriteSheetUploadComplete:\n      this.#onDeviceDisplaySpriteSheetUploadComplete.bind(this),\n    displayContextCommands: this.#onDeviceDisplayContextCommands.bind(this),\n  };\n  #onDeviceIsConnected(event: DeviceEventMap[\"isConnected\"]) {\n    const { isConnected } = event.message;\n    this.#dispatchEvent(\"deviceIsConnected\", {\n      device: this.device!,\n      isConnected,\n    });\n  }\n  #onDeviceConnected(event: DeviceEventMap[\"connected\"]) {\n    // _console.log(\"device connected\");\n    this.#updateCanvas();\n    this.#updateDevice();\n    this.#dispatchEvent(\"deviceConnected\", { device: this.device! });\n    // FIX - messages flushed properly?\n  }\n  #onDeviceNotConnected(event: DeviceEventMap[\"notConnected\"]) {\n    // _console.log(\"device not connected\");\n    this.#dispatchEvent(\"deviceNotConnected\", { device: this.device! });\n  }\n  async #onDeviceDisplayReady(event: DeviceEventMap[\"displayReady\"]) {\n    // _console.log(\"device display ready\");\n    // this.#isReady = true;\n    // await wait(5); // we need to wait for some reason\n    this.#dispatchEvent(\"ready\", {});\n  }\n\n  #onDeviceDisplaySpriteSheetUploadStart(\n    event: DeviceEventMap[\"displaySpriteSheetUploadStart\"]\n  ) {\n    const device = event.target;\n    const { spriteSheet, spriteSheetName } = event.message;\n    this.#dispatchEvent(\"deviceSpriteSheetUploadStart\", {\n      device,\n      spriteSheet,\n      spriteSheetName,\n    });\n  }\n  #onDeviceDisplaySpriteSheetUploadProgress(\n    event: DeviceEventMap[\"displaySpriteSheetUploadProgress\"]\n  ) {\n    const device = event.target;\n    const { spriteSheet, spriteSheetName, progress } = event.message;\n    this.#dispatchEvent(\"deviceSpriteSheetUploadProgress\", {\n      device,\n      spriteSheet,\n      spriteSheetName,\n      progress,\n    });\n  }\n  #onDeviceDisplaySpriteSheetUploadComplete(\n    event: DeviceEventMap[\"displaySpriteSheetUploadComplete\"]\n  ) {\n    const device = event.target;\n    const { spriteSheet, spriteSheetName } = event.message;\n    this.#dispatchEvent(\"deviceSpriteSheetUploadComplete\", {\n      device,\n      spriteSheet,\n      spriteSheetName,\n    });\n  }\n  #onDeviceDisplayContextCommands(\n    event: DeviceEventMap[\"displayContextCommands\"]\n  ) {\n    this.#onSentContextCommands();\n  }\n\n  #onSentContextCommands() {\n    let redraw = false;\n    redraw ||= this.#flushColors();\n    redraw ||= this.#flushOpacities();\n    redraw ||= this.#flushBrightness();\n    _console.log(\"onSentContextCommands\", { redraw });\n    if (redraw) {\n      this.#drawFrontDrawStack();\n    }\n  }\n\n  async #updateDevice() {\n    await this.#updateDeviceColors(true);\n    await this.#updateDeviceOpacity(true);\n    await this.#updateDeviceContextState(true);\n    await this.#updateDeviceBrightness(true);\n    await this.#updateDeviceSpriteSheets();\n    await this.#updateDeviceSelectedSpriteSheet(true);\n    //_console.log(\"deviceUpdated\");\n    this.#dispatchEvent(\"deviceUpdated\", { device: this.device! });\n  }\n\n  // NUMBER OF COLORS\n  #numberOfColors: number = 0;\n  get numberOfColors() {\n    return this.#numberOfColors;\n  }\n  set numberOfColors(newNumberOfColors) {\n    if (this.#numberOfColors == newNumberOfColors) {\n      return;\n    }\n\n    this.#numberOfColors = newNumberOfColors;\n    // _console.log({ numberOfColors: this.numberOfColors });\n\n    this.#colors = new Array(this.numberOfColors).fill(\"#000000\");\n    this.#opacities = new Array(this.numberOfColors).fill(1);\n    this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n\n    this.#dispatchEvent(\"numberOfColors\", {\n      numberOfColors: this.numberOfColors,\n    });\n  }\n\n  // COLORS\n  assertValidColorIndex(colorIndex: number) {\n    _console.assertRangeWithError(\n      \"colorIndex\",\n      colorIndex,\n      0,\n      this.numberOfColors\n    );\n  }\n  #pendingColors: string[] = [];\n  #setColor(colorIndex: number, colorHex: string) {\n    this.#pendingColors[colorIndex] = colorHex;\n  }\n  #colors: string[] = [];\n  get colors() {\n    return this.#colors;\n  }\n  #flushColors() {\n    if (this.#pendingColors.length == 0) {\n      return false;\n    }\n    this.#pendingColors.forEach((colorHex, colorIndex) => {\n      this.#colors[colorIndex] = colorHex;\n      const colorRGB = hexToRGB(colorHex);\n      this.#dispatchEvent(\"color\", { colorIndex, colorHex, colorRGB });\n    });\n    this.#pendingColors.length = 0;\n    _console.log(\"flushColors\");\n    return true;\n  }\n  #resetColors() {\n    this.#colors.length = 0;\n    this.#pendingColors.length = 0;\n  }\n  async #updateDeviceColors(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    for (const [index, color] of this.colors.entries()) {\n      await this.device?.setDisplayColor(index, color, false);\n    }\n    if (sendImmediately) {\n      await this.flushContextCommands();\n    }\n  }\n\n  // OPACITIES\n  #opacities: number[] = [];\n  get opacities() {\n    return this.#opacities;\n  }\n  #pendingOpacities: number[] = [];\n  #setColorOpacity(colorIndex: number, opacity: number) {\n    this.#pendingOpacities[colorIndex] = opacity;\n  }\n  #flushOpacities() {\n    if (this.#pendingOpacities.length == 0) {\n      return false;\n    }\n    this.#pendingOpacities.forEach((opacity, colorIndex) => {\n      this.#opacities[colorIndex] = opacity;\n      this.#dispatchEvent(\"colorOpacity\", { colorIndex, opacity });\n    });\n    this.#pendingOpacities.length = 0;\n    _console.log(\"flushOpacities\");\n    return true;\n  }\n  #resetOpacities() {\n    this.#opacities.length = 0;\n    this.#pendingOpacities.length = 0;\n  }\n\n  async #updateDeviceOpacity(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    for (const [index, opacity] of this.#opacities.entries()) {\n      await this.device?.setDisplayColorOpacity(index, opacity, false);\n    }\n    if (sendImmediately) {\n      await this.flushContextCommands();\n    }\n  }\n\n  // CONEXT STATE\n  #contextStateHelper = new DisplayContextStateHelper();\n  get contextState() {\n    return this.#contextStateHelper.state;\n  }\n  #onContextStateUpdate(differences: DisplayContextStateKey[]) {\n    this.#dispatchEvent(\"contextState\", {\n      contextState: structuredClone(this.contextState),\n      differences,\n    });\n  }\n  #resetContextState() {\n    this.#contextStateHelper.reset();\n    this.contextState.bitmapColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n    this.contextState.spriteColorIndices = new Array(this.numberOfColors).fill(\n      0\n    );\n  }\n  async #updateDeviceContextState(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    // _console.log(\"updateDeviceContextState\");\n    await this.device?.setDisplayContextState(\n      this.contextState,\n      sendImmediately\n    );\n  }\n\n  async show(sendImmediately = true) {\n    // _console.log(\"showDisplay\");\n\n    this.#frontDrawStack = this.#rearDrawStack.slice();\n    this.#rearDrawStack.length = 0;\n\n    this.#isReady = false;\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.show(sendImmediately);\n    } else {\n      await wait(this.#interval);\n      if (this.device) {\n        return;\n      }\n      this.#dispatchEvent(\"ready\", {});\n    }\n  }\n  #interval = 50;\n  get interval() {\n    return this.#interval;\n  }\n  set interval(newInterval) {\n    this.#interval = newInterval;\n    // _console.log({ interval: this.#interval });\n  }\n\n  #isReady = true;\n  get isReady() {\n    return this.#isReady;\n  }\n\n  async clear(sendImmediately = true) {\n    // _console.log(\"clearDisplay\");\n\n    this.#frontDrawStack.length = 0;\n    this.#rearDrawStack.length = 0;\n\n    this.#isReady = false;\n    this.#save();\n    this.#context.resetTransform();\n    this.#context.clearRect(0, 0, this.width, this.height);\n    this.#restore();\n    this.#drawBackground();\n\n    this.#isDrawingBlankSprite = false;\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.clear(sendImmediately);\n    } else {\n      await wait(this.#interval);\n      if (this.device) {\n        return;\n      }\n      this.#dispatchEvent(\"ready\", {});\n    }\n  }\n\n  async setColor(\n    colorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    let colorRGB: DisplayColorRGB;\n    if (typeof color == \"string\") {\n      colorRGB = stringToRGB(color);\n    } else {\n      colorRGB = color;\n    }\n    const colorHex = rgbToHex(colorRGB);\n    if (this.colors[colorIndex] == colorHex) {\n      // _console.log(`redundant color #${colorIndex} ${colorHex}`);\n      return;\n    }\n\n    // _console.log(`setting color #${colorIndex}`, color);\n    this.assertValidColorIndex(colorIndex);\n    assertValidColor(colorRGB);\n\n    this.#setColor(colorIndex, colorHex);\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setColor(\n        colorIndex,\n        color,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n\n  async setColorOpacity(\n    colorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(colorIndex);\n    assertValidOpacity(opacity);\n    if (\n      Math.floor(255 * this.#opacities[colorIndex]) == Math.floor(255 * opacity)\n    ) {\n      // _console.log(`redundant opacity #${colorIndex} ${opacity}`);\n      return;\n    }\n    this.#setColorOpacity(colorIndex, opacity);\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setColorOpacity(\n        colorIndex,\n        opacity,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  async setOpacity(opacity: number, sendImmediately?: boolean) {\n    assertValidOpacity(opacity);\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setOpacity(opacity, sendImmediately);\n    }\n    this.#opacities.forEach((_, colorIndex) => {\n      this.#setColorOpacity(colorIndex, opacity);\n    });\n  }\n\n  // CONTEXT COMMANDS\n  #contextStack: DisplayContextState[] = [];\n  async #saveContext(sendImmediately?: boolean) {\n    //_console.log(\"saveContext\");\n    this.#contextStack.push(structuredClone(this.contextState));\n  }\n  async #restoreContext(sendImmediately?: boolean) {\n    //_console.log(\"restoreContext\");\n    const contextState = this.#contextStack.pop();\n    if (!contextState) {\n      _console.warn(\"#contextStack empty\");\n      return;\n    }\n    this.#contextStateHelper.update(contextState);\n    if (!this.#ignoreDevice) {\n      await this.#updateDeviceContextState(sendImmediately);\n    }\n  }\n  async saveContext(sendImmediately?: boolean) {\n    await this.#saveContext(sendImmediately);\n    // if (this.device?.isConnected && !this.#ignoreDevice) {\n    //   await this.deviceDisplayManager!.saveContext(sendImmediately);\n    // }\n  }\n  async restoreContext(sendImmediately?: boolean) {\n    await this.#restoreContext(sendImmediately);\n    // if (this.device?.isConnected && !this.#ignoreDevice) {\n    //   await this.deviceDisplayManager!.restoreContext(sendImmediately);\n    // }\n  }\n  async selectBackgroundColor(\n    backgroundColorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(backgroundColorIndex);\n    const differences = this.#contextStateHelper.update({\n      backgroundColorIndex,\n    });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.selectBackgroundColor(\n        backgroundColorIndex,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async selectFillColor(fillColorIndex: number, sendImmediately?: boolean) {\n    this.assertValidColorIndex(fillColorIndex);\n    const differences = this.#contextStateHelper.update({\n      fillColorIndex,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.selectFillColor(\n        fillColorIndex,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async selectLineColor(lineColorIndex: number, sendImmediately?: boolean) {\n    this.assertValidColorIndex(lineColorIndex);\n    const differences = this.#contextStateHelper.update({\n      lineColorIndex,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.selectLineColor(\n        lineColorIndex,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setIgnoreFill(ignoreFill: boolean, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      ignoreFill,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setIgnoreFill(\n        ignoreFill,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setIgnoreLine(ignoreLine: boolean, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      ignoreLine,\n    });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setIgnoreLine(\n        ignoreLine,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setFillBackground(fillBackground: boolean, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      fillBackground,\n    });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setFillBackground(\n        fillBackground,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  assertValidLineWidth(lineWidth: number) {\n    _console.assertRangeWithError(\n      \"lineWidth\",\n      lineWidth,\n      0,\n      Math.max(this.width, this.height)\n    );\n  }\n  async setLineWidth(lineWidth: number, sendImmediately?: boolean) {\n    this.assertValidLineWidth(lineWidth);\n    const differences = this.#contextStateHelper.update({\n      lineWidth,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setLineWidth(lineWidth, sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setAlignment(\n    alignmentDirection: DisplayAlignmentDirection,\n    alignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(\n      alignmentDirection,\n      DisplayAlignmentDirections\n    );\n    const alignmentCommand =\n      DisplayAlignmentDirectionToCommandType[alignmentDirection];\n    const alignmentKey =\n      DisplayAlignmentDirectionToStateKey[alignmentDirection];\n    const differences = this.#contextStateHelper.update({\n      [alignmentKey]: alignment,\n    });\n    // _console.log({\n    //   alignmentKey,\n    //   alignment,\n    //   differences,\n    // });\n\n    // _console.log({ [cropCommand]: crop });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setAlignment(\n        alignmentDirection,\n        alignment,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setHorizontalAlignment(\n    horizontalAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    await this.setAlignment(\"horizontal\", horizontalAlignment, sendImmediately);\n  }\n  async setVerticalAlignment(\n    verticalAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    await this.setAlignment(\"vertical\", verticalAlignment, sendImmediately);\n  }\n  async resetAlignment(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      verticalAlignment: DefaultDisplayContextState.verticalAlignment,\n      horizontalAlignment: DefaultDisplayContextState.horizontalAlignment,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.resetAlignment(sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setRotation(\n    rotation: number,\n    isRadians: boolean,\n    sendImmediately?: boolean\n  ) {\n    rotation = isRadians ? rotation : degToRad(rotation);\n    rotation = normalizeRadians(rotation);\n    // _console.log({ rotation });\n\n    const differences = this.#contextStateHelper.update({\n      rotation,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setRotation(\n        rotation,\n        true,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async clearRotation(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotation: 0,\n    });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.clearRotation(sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentStartCap(\n    segmentStartCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentStartCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap,\n    });\n\n    // _console.log({ segmentStartCap });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setSegmentStartCap(\n        segmentStartCap,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndCap(\n    segmentEndCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentEndCap);\n    const differences = this.#contextStateHelper.update({\n      segmentEndCap,\n    });\n\n    // _console.log({ segmentEndCap });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setSegmentEndCap(\n        segmentEndCap,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentCap(\n    segmentCap: DisplaySegmentCap,\n    sendImmediately?: boolean\n  ) {\n    assertValidSegmentCap(segmentCap);\n    const differences = this.#contextStateHelper.update({\n      segmentStartCap: segmentCap,\n      segmentEndCap: segmentCap,\n    });\n\n    // _console.log({ segmentCap });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setSegmentCap(\n        segmentCap,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentStartRadius(\n    segmentStartRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius,\n    });\n\n    // _console.log({ segmentStartRadius });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setSegmentStartRadius(\n        segmentStartRadius,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSegmentEndRadius(\n    segmentEndRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const differences = this.#contextStateHelper.update({\n      segmentEndRadius,\n    });\n\n    // _console.log({ segmentEndRadius });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setSegmentEndRadius(\n        segmentEndRadius,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  // START\n  async setSegmentRadius(segmentRadius: number, sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      segmentStartRadius: segmentRadius,\n      segmentEndRadius: segmentRadius,\n    });\n\n    // _console.log({ segmentRadius });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setSegmentRadius(\n        segmentRadius,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    crop = Math.max(0, crop);\n    const cropKey = DisplayCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setCrop(\n        cropDirection,\n        crop,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setCropTop(cropTop: number, sendImmediately?: boolean) {\n    await this.setCrop(\"top\", cropTop, sendImmediately);\n  }\n  async setCropRight(cropRight: number, sendImmediately?: boolean) {\n    await this.setCrop(\"right\", cropRight, sendImmediately);\n  }\n  async setCropBottom(cropBottom: number, sendImmediately?: boolean) {\n    await this.setCrop(\"bottom\", cropBottom, sendImmediately);\n  }\n  async setCropLeft(cropLeft: number, sendImmediately?: boolean) {\n    await this.setCrop(\"left\", cropLeft, sendImmediately);\n  }\n  async clearCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      cropTop: 0,\n      cropRight: 0,\n      cropBottom: 0,\n      cropLeft: 0,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.clearCrop(sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setRotationCrop(\n    cropDirection: DisplayCropDirection,\n    crop: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertEnumWithError(cropDirection, DisplayCropDirections);\n    const cropCommand =\n      DisplayRotationCropDirectionToCommandType[cropDirection];\n    const cropKey = DisplayRotationCropDirectionToStateKey[cropDirection];\n    const differences = this.#contextStateHelper.update({\n      [cropKey]: crop,\n    });\n\n    // _console.log({ [cropCommand]: crop });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setRotationCrop(\n        cropDirection,\n        crop,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setRotationCropTop(rotationCropTop: number, sendImmediately?: boolean) {\n    await this.setRotationCrop(\"top\", rotationCropTop, sendImmediately);\n  }\n  async setRotationCropRight(\n    rotationCropRight: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"right\", rotationCropRight, sendImmediately);\n  }\n  async setRotationCropBottom(\n    rotationCropBottom: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"bottom\", rotationCropBottom, sendImmediately);\n  }\n  async setRotationCropLeft(\n    rotationCropLeft: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setRotationCrop(\"left\", rotationCropLeft, sendImmediately);\n  }\n  async clearRotationCrop(sendImmediately?: boolean) {\n    const differences = this.#contextStateHelper.update({\n      rotationCropTop: 0,\n      rotationCropRight: 0,\n      rotationCropBottom: 0,\n      rotationCropLeft: 0,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.clearRotationCrop(sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  get bitmapColorIndices() {\n    return this.contextState.bitmapColorIndices;\n  }\n  get bitmapColors() {\n    return this.bitmapColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  async selectBitmapColor(\n    bitmapColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(bitmapColorIndex);\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n\n    // _console.log({ bitmapColorIndex, colorIndex });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.selectBitmapColor(\n        bitmapColorIndex,\n        colorIndex,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async selectBitmapColors(\n    bitmapColorPairs: DisplayBitmapColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"bitmapColors\",\n      bitmapColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const bitmapColorIndices = this.contextState.bitmapColorIndices.slice();\n    bitmapColorPairs.forEach(({ bitmapColorIndex, colorIndex }) => {\n      this.assertValidColorIndex(bitmapColorIndex);\n      this.assertValidColorIndex(colorIndex);\n      bitmapColorIndices[bitmapColorIndex] = colorIndex;\n    });\n\n    const differences = this.#contextStateHelper.update({\n      bitmapColorIndices,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.selectBitmapColors(\n        bitmapColorPairs,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setBitmapColor(\n    bitmapColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.bitmapColorIndices[bitmapColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setBitmapColorOpacity(\n    bitmapColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.bitmapColorIndices[bitmapColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n\n  async setBitmapScaleDirection(\n    direction: DisplayScaleDirection,\n    bitmapScale: number,\n    sendImmediately?: boolean\n  ) {\n    bitmapScale = clamp(bitmapScale, minDisplayScale, maxDisplayScale);\n    bitmapScale = roundScale(bitmapScale);\n    //_console.log({ bitmapScale });\n    const newState: PartialDisplayContextState = {};\n    switch (direction) {\n      case \"all\":\n        newState.bitmapScaleX = bitmapScale;\n        newState.bitmapScaleY = bitmapScale;\n        break;\n      case \"x\":\n        newState.bitmapScaleX = bitmapScale;\n        break;\n      case \"y\":\n        newState.bitmapScaleY = bitmapScale;\n        break;\n    }\n    const differences = this.#contextStateHelper.update(newState);\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setBitmapScaleDirection(\n        direction,\n        bitmapScale,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setBitmapScaleX(bitmapScaleX: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"x\", bitmapScaleX, sendImmediately);\n  }\n  async setBitmapScaleY(bitmapScaleY: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"y\", bitmapScaleY, sendImmediately);\n  }\n  async setBitmapScale(bitmapScale: number, sendImmediately?: boolean) {\n    return this.setBitmapScaleDirection(\"all\", bitmapScale, sendImmediately);\n  }\n  async resetBitmapScale(sendImmediately?: boolean) {\n    //return this.setBitmapScaleDirection(\"all\", 1, sendImmediately);\n\n    const differences = this.#contextStateHelper.update({\n      bitmapScaleX: 1,\n      bitmapScaleY: 1,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.resetBitmapScale(sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  get spriteColorIndices() {\n    return this.contextState.spriteColorIndices;\n  }\n  get spriteColors() {\n    return this.spriteColorIndices.map((colorIndex) => this.colors[colorIndex]);\n  }\n  get spriteBitmapColorIndices() {\n    return this.bitmapColorIndices.map(\n      (colorIndex) => this.spriteColorIndices[colorIndex]\n    );\n  }\n  get spriteBitmapColors() {\n    return this.spriteBitmapColorIndices.map(\n      (colorIndex) => this.colors[colorIndex]\n    );\n  }\n  async selectSpriteColor(\n    spriteColorIndex: number,\n    colorIndex: number,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidColorIndex(spriteColorIndex);\n    const spriteColorIndices = this.contextState.spriteColorIndices.slice();\n    if (this.#isDrawingBlankSprite) {\n      spriteColorIndices[spriteColorIndex] =\n        this.#blankSpriteColorIndices![colorIndex];\n    } else {\n      spriteColorIndices[spriteColorIndex] = colorIndex;\n    }\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n\n    _console.log({ spriteColorIndex, colorIndex });\n    _console.log(\"spriteColorIndices\", spriteColorIndices);\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.selectSpriteColor(\n        spriteColorIndex,\n        colorIndex,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async selectSpriteColors(\n    spriteColorPairs: DisplaySpriteColorPair[],\n    sendImmediately?: boolean\n  ) {\n    _console.assertRangeWithError(\n      \"spriteColors\",\n      spriteColorPairs.length,\n      1,\n      this.numberOfColors\n    );\n    const spriteColorIndices = this.contextState.spriteColorIndices.slice();\n    spriteColorPairs.forEach(({ spriteColorIndex, colorIndex }) => {\n      this.assertValidColorIndex(spriteColorIndex);\n      this.assertValidColorIndex(colorIndex);\n      // FIX\n      if (this.#isDrawingBlankSprite) {\n        spriteColorIndices[spriteColorIndex] =\n          this.#blankSpriteColorIndices![colorIndex];\n      } else {\n        spriteColorIndices[spriteColorIndex] = colorIndex;\n      }\n    });\n\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.selectSpriteColors(\n        spriteColorPairs,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpriteColor(\n    spriteColorIndex: number,\n    color: DisplayColorRGB | string,\n    sendImmediately?: boolean\n  ) {\n    return this.setColor(\n      this.spriteColorIndices[spriteColorIndex],\n      color,\n      sendImmediately\n    );\n  }\n  async setSpriteColorOpacity(\n    spriteColorIndex: number,\n    opacity: number,\n    sendImmediately?: boolean\n  ) {\n    return this.setColorOpacity(\n      this.spriteColorIndices[spriteColorIndex],\n      opacity,\n      sendImmediately\n    );\n  }\n\n  async resetSpriteColors(sendImmediately?: boolean) {\n    const spriteColorIndices = new Array(this.numberOfColors).fill(0);\n    const differences = this.#contextStateHelper.update({\n      spriteColorIndices,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.resetSpriteColors(sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpriteScaleDirection(\n    direction: DisplayScaleDirection,\n    spriteScale: number,\n    sendImmediately?: boolean\n  ) {\n    spriteScale = clamp(spriteScale, minDisplayScale, maxDisplayScale);\n    spriteScale = roundScale(spriteScale);\n    const newState: PartialDisplayContextState = {};\n    switch (direction) {\n      case \"all\":\n        newState.spriteScaleX = spriteScale;\n        newState.spriteScaleY = spriteScale;\n        break;\n      case \"x\":\n        newState.spriteScaleX = spriteScale;\n        break;\n      case \"y\":\n        newState.spriteScaleY = spriteScale;\n        break;\n    }\n    const differences = this.#contextStateHelper.update(newState);\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setSpriteScaleDirection(\n        direction,\n        spriteScale,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpriteScaleX(spriteScaleX: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"x\", spriteScaleX, sendImmediately);\n  }\n  async setSpriteScaleY(spriteScaleY: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"y\", spriteScaleY, sendImmediately);\n  }\n  async setSpriteScale(spriteScale: number, sendImmediately?: boolean) {\n    return this.setSpriteScaleDirection(\"all\", spriteScale, sendImmediately);\n  }\n  async resetSpriteScale(sendImmediately?: boolean) {\n    //return this.setSpriteScaleDirection(\"all\", 1, sendImmediately);\n\n    const differences = this.#contextStateHelper.update({\n      spriteScaleX: 1,\n      spriteScaleY: 1,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.resetSpriteScale(sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpritesLineHeight(\n    spritesLineHeight: number,\n    sendImmediately?: boolean\n  ) {\n    spritesLineHeight = Math.round(spritesLineHeight);\n    this.assertValidLineWidth(spritesLineHeight);\n    const differences = this.#contextStateHelper.update({\n      spritesLineHeight,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setSpritesLineHeight(\n        spritesLineHeight,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n\n  async setSpritesDirectionGeneric(\n    direction: DisplayDirection,\n    isOrthogonal: boolean,\n    sendImmediately?: boolean\n  ) {\n    assertValidDirection(direction);\n    const stateKey: DisplayContextStateKey = isOrthogonal\n      ? \"spritesLineDirection\"\n      : \"spritesDirection\";\n    const differences = this.#contextStateHelper.update({\n      [stateKey]: direction,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      this.deviceDisplayManager!.setSpritesDirectionGeneric(\n        direction,\n        isOrthogonal,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpritesDirection(\n    spritesDirection: DisplayDirection,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesDirectionGeneric(\n      spritesDirection,\n      false,\n      sendImmediately\n    );\n  }\n  async setSpritesLineDirection(\n    spritesLineDirection: DisplayDirection,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesDirectionGeneric(\n      spritesLineDirection,\n      true,\n      sendImmediately\n    );\n  }\n\n  async setSpritesSpacingGeneric(\n    spacing: number,\n    isOrthogonal: boolean,\n    sendImmediately?: boolean\n  ) {\n    const stateKey: DisplayContextStateKey = isOrthogonal\n      ? \"spritesLineSpacing\"\n      : \"spritesSpacing\";\n    const differences = this.#contextStateHelper.update({\n      [stateKey]: spacing,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      this.deviceDisplayManager!.setSpritesSpacingGeneric(\n        spacing,\n        isOrthogonal,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpritesSpacing(spritesSpacing: number, sendImmediately?: boolean) {\n    await this.setSpritesSpacingGeneric(spritesSpacing, false, sendImmediately);\n  }\n  async setSpritesLineSpacing(\n    spritesSpacing: number,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesSpacingGeneric(spritesSpacing, true, sendImmediately);\n  }\n\n  async setSpritesAlignmentGeneric(\n    alignment: DisplayAlignment,\n    isOrthogonal: boolean,\n    sendImmediately?: boolean\n  ) {\n    assertValidAlignment(alignment);\n    const stateKey: DisplayContextStateKey = isOrthogonal\n      ? \"spritesLineAlignment\"\n      : \"spritesAlignment\";\n    const differences = this.#contextStateHelper.update({\n      [stateKey]: alignment,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      this.deviceDisplayManager!.setSpritesAlignmentGeneric(\n        alignment,\n        isOrthogonal,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  async setSpritesAlignment(\n    spritesAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesAlignmentGeneric(\n      spritesAlignment,\n      false,\n      sendImmediately\n    );\n  }\n  async setSpritesLineAlignment(\n    spritesLineAlignment: DisplayAlignment,\n    sendImmediately?: boolean\n  ) {\n    await this.setSpritesAlignmentGeneric(\n      spritesLineAlignment,\n      true,\n      sendImmediately\n    );\n  }\n\n  #clearRectToCanvas(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    {\n      backgroundColorIndex,\n      spriteColorIndices,\n      fillBackground,\n    }: DisplayContextState\n  ) {\n    this.#save();\n    if (this.#useSpriteColorIndices) {\n      backgroundColorIndex = spriteColorIndices[backgroundColorIndex];\n    }\n    //this.context.resetTransform();\n    this.context.fillStyle = this.#colorIndexToRgbString(\n      fillBackground ? backgroundColorIndex : 0\n    );\n    // _console.log({\n    //   useSpriteColorIndices: this.#useSpriteColorIndices,\n    //   backgroundColorIndex,\n    //   fillBackground,\n    //   fillStyle: this.context.fillStyle,\n    // });\n    //this.context.fillStyle = \"red\"; // remove when done debugigng\n    this.context.lineWidth = 0;\n    this.context.fillRect(x, y, width, height);\n    this.#restore();\n  }\n  async clearRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#clearRectToCanvas(x, y, width, height, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.clearRect(\n        x,\n        y,\n        width,\n        height,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #save() {\n    //console.trace(\"save\", window.s);\n    const ctx = this.#context;\n    ctx.save();\n  }\n  #restore() {\n    //console.trace(\"restore\");\n    const ctx = this.#context;\n    ctx.restore();\n  }\n  #transformContext(offsetX: number, offsetY: number, rotation: number) {\n    this.#translateContext(offsetX, offsetY);\n    this.#rotateContext(rotation);\n  }\n  #translateContext(offsetX: number, offsetY: number) {\n    const ctx = this.context;\n    ctx.translate(offsetX, offsetY);\n  }\n  #rotateContext(rotation: number) {\n    const ctx = this.context;\n    ctx.rotate(rotation);\n  }\n  #scaleContext(scaleX: number, scaleY: number) {\n    const ctx = this.context;\n    ctx.scale(scaleX, scaleY);\n  }\n  #correctAlignmentTranslation(\n    { width, height }: DisplayBoundingBox,\n    { verticalAlignment, horizontalAlignment }: DisplayContextState\n  ) {\n    switch (horizontalAlignment) {\n      case \"start\":\n        this.#translateContext(width / 2, 0);\n        break;\n      case \"center\":\n        break;\n      case \"end\":\n        this.#translateContext(-width / 2, 0);\n        break;\n    }\n    switch (verticalAlignment) {\n      case \"start\":\n        this.#translateContext(0, height / 2);\n        break;\n      case \"center\":\n        break;\n      case \"end\":\n        this.#translateContext(0, -height / 2);\n        break;\n    }\n  }\n  #rotateBoundingBox(\n    box: DisplayBoundingBox,\n    rotation: number\n  ): DisplayBoundingBox {\n    const cos = Math.cos(rotation);\n    const sin = Math.sin(rotation);\n\n    const corners = [\n      { x: box.x, y: box.y },\n      { x: box.x, y: box.height + box.y },\n      { x: box.x + box.width, y: box.y },\n      { x: box.x + box.width, y: box.height + box.y },\n    ];\n\n    const rotated = corners.map(({ x, y }) => ({\n      x: x * cos - y * sin,\n      y: x * sin + y * cos,\n    }));\n\n    const xs = rotated.map((p) => p.x);\n    const ys = rotated.map((p) => p.y);\n\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  }\n  #offsetBoundingBox(\n    box: DisplayBoundingBox,\n    offsetX: number,\n    offsetY: number\n  ): DisplayBoundingBox {\n    const offsetBoundingBox = structuredClone(box);\n    offsetBoundingBox.x += offsetX;\n    offsetBoundingBox.y += offsetY;\n    return offsetBoundingBox;\n  }\n  #_clearBoundingBoxOnDraw = true;\n  get #clearBoundingBoxOnDraw() {\n    return this.#_clearBoundingBoxOnDraw && !this.#isDrawingSprite;\n  }\n  #clearBoundingBox(\n    { x, y, width, height }: DisplayBoundingBox,\n    contextState: DisplayContextState\n  ) {\n    this.#clearRectToCanvas(x, y, width, height, contextState);\n  }\n  #getOuterPadding(lineWidth: number) {\n    return Math.ceil(lineWidth / 2);\n  }\n  #getRectBoundingBox(\n    width: number,\n    height: number,\n    { lineWidth, verticalAlignment, horizontalAlignment }: DisplayContextState,\n    applyLineWidth = true\n  ): DisplayBoundingBox {\n    const outerPadding = applyLineWidth ? this.#getOuterPadding(lineWidth) : 0;\n    const boundingBox = {\n      x: 0,\n      y: 0,\n      width: width + outerPadding * 2,\n      height: height + outerPadding * 2,\n    };\n    assertValidAlignment(horizontalAlignment);\n    assertValidAlignment(verticalAlignment);\n    switch (horizontalAlignment) {\n      case \"start\":\n        break;\n      case \"center\":\n        boundingBox.x -= boundingBox.width / 2;\n        break;\n      case \"end\":\n        boundingBox.x -= boundingBox.width;\n        break;\n    }\n    switch (verticalAlignment) {\n      case \"start\":\n        break;\n      case \"center\":\n        boundingBox.y -= boundingBox.height / 2;\n        break;\n      case \"end\":\n        boundingBox.y -= boundingBox.height;\n        break;\n    }\n    return boundingBox;\n  }\n  #applyClip(\n    { x, y, height, width }: DisplayBoundingBox,\n    { cropTop, cropRight, cropBottom, cropLeft }: DisplayContextState\n  ) {\n    const ctx = this.context;\n    ctx.beginPath();\n    ctx.rect(x + cropLeft, y + cropTop, width - cropRight, height - cropBottom);\n    ctx.clip();\n  }\n  #applyRotationClip(\n    { x, y, height, width }: DisplayBoundingBox,\n    {\n      rotationCropTop,\n      rotationCropRight,\n      rotationCropBottom,\n      rotationCropLeft,\n    }: DisplayContextState\n  ) {\n    const ctx = this.context;\n    ctx.beginPath();\n    ctx.rect(\n      x + rotationCropLeft,\n      y + rotationCropTop,\n      width - rotationCropRight,\n      height - rotationCropBottom\n    );\n\n    ctx.clip();\n  }\n\n  #hexToRgbWithOpacity(hex: string, opacity: number): DisplayColorRGB {\n    // Expand shorthand hex (#f00  #ff0000)\n    if (hex.length === 4) {\n      hex = \"#\" + [...hex.slice(1)].map((c) => c + c).join(\"\");\n    }\n\n    const r = parseInt(hex.slice(1, 3), 16);\n    const g = parseInt(hex.slice(3, 5), 16);\n    const b = parseInt(hex.slice(5, 7), 16);\n\n    // Darken color by blending toward black\n    const darken = (c: number) => Math.round(c * opacity);\n\n    const dr = darken(r);\n    const dg = darken(g);\n    const db = darken(b);\n\n    return { r: dr, g: dg, b: db };\n  }\n  #hexToRgbStringWithOpacity(hex: string, opacity: number) {\n    const { r, g, b } = this.#hexToRgbWithOpacity(hex, opacity);\n    return `rgb(${r}, ${g}, ${b})`;\n  }\n  #getColorOpacity(colorIndex: number, includeBrightness = false) {\n    return (\n      this.opacities[colorIndex] *\n      (includeBrightness ? this.#brightnessOpacity : 1)\n    );\n  }\n  #colorIndexToRgbString(colorIndex: number) {\n    return this.#hexToRgbStringWithOpacity(\n      this.colors[colorIndex],\n      this.#getColorOpacity(colorIndex)\n    );\n  }\n  #colorIndexToRgb(colorIndex: number) {\n    return this.#hexToRgbWithOpacity(\n      this.colors[colorIndex],\n      this.#getColorOpacity(colorIndex)\n    );\n  }\n  #ignoreCanvasContextStyle = \"rgba(0,0,0,0)\";\n  #updateContext({\n    lineWidth,\n    fillColorIndex,\n    lineColorIndex,\n    spriteColorIndices,\n    ignoreFill,\n    ignoreLine,\n  }: DisplayContextState) {\n    if (this.#useSpriteColorIndices) {\n      //_console.log(\"spriteColorIndices\", spriteColorIndices);\n      fillColorIndex = spriteColorIndices[fillColorIndex];\n      lineColorIndex = spriteColorIndices[lineColorIndex];\n    }\n    this.context.fillStyle = ignoreFill\n      ? this.#ignoreCanvasContextStyle\n      : this.#colorIndexToRgbString(fillColorIndex);\n    this.context.strokeStyle = ignoreLine\n      ? this.#ignoreCanvasContextStyle\n      : this.#colorIndexToRgbString(lineColorIndex);\n    this.context.lineWidth = lineWidth;\n    // _console.log({ fillColorIndex, lineColorIndex, lineWidth });\n    // _console.log({fillStyle: this.context.fillStyle, strokeStyle: this.context.strokeStyle})\n  }\n  #drawRectToCanvas(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const localBox = this.#getRectBoundingBox(width, height, contextState);\n    const rotatedLocalBox = this.#rotateBoundingBox(\n      localBox,\n      contextState.rotation\n    );\n    const rotatedBox = this.#offsetBoundingBox(\n      rotatedLocalBox,\n      offsetX,\n      offsetY\n    );\n    this.#applyClip(rotatedBox, contextState);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(rotatedBox, contextState);\n    }\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    this.#applyRotationClip(localBox, contextState);\n\n    const outerPadding = this.#getOuterPadding(contextState.lineWidth);\n    const startX = localBox.x + outerPadding;\n    const startY = localBox.y + outerPadding;\n    this.context.fillRect(startX, startY, width, height);\n    if (contextState.lineWidth > 0) {\n      this.context.strokeRect(startX, startY, width, height);\n    }\n    this.#restore();\n  }\n  async drawRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    //console.log(\"drawRect contextState\", contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawRectToCanvas(offsetX, offsetY, width, height, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawRect(\n        offsetX,\n        offsetY,\n        width,\n        height,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #drawRoundRectToCanvas(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    const maxBorderRadius = Math.min(width, height) / 2;\n    borderRadius = Math.min(borderRadius, maxBorderRadius);\n\n    this.#save();\n    const localBox = this.#getRectBoundingBox(width, height, contextState);\n    const rotatedLocalBox = this.#rotateBoundingBox(\n      localBox,\n      contextState.rotation\n    );\n    const rotatedBox = this.#offsetBoundingBox(\n      rotatedLocalBox,\n      offsetX,\n      offsetY\n    );\n    this.#applyClip(rotatedBox, contextState);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(rotatedBox, contextState);\n    }\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    this.#applyRotationClip(localBox, contextState);\n\n    const outerPadding = this.#getOuterPadding(contextState.lineWidth);\n    const startX = localBox.x + outerPadding;\n    const startY = localBox.y + outerPadding;\n\n    this.context.beginPath();\n    this.context.roundRect(startX, startY, width, height, borderRadius);\n    this.context.fill();\n    if (contextState.lineWidth > 0) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawRoundRect(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    borderRadius: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawRoundRectToCanvas(\n        offsetX,\n        offsetY,\n        width,\n        height,\n        borderRadius,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawRoundRect(\n        offsetX,\n        offsetY,\n        width,\n        height,\n        borderRadius,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #getCircleBoundingBox(\n    radius: number,\n    contextState: DisplayContextState\n  ): DisplayBoundingBox {\n    const diameter = radius * 2;\n    return this.#getRectBoundingBox(diameter, diameter, contextState);\n  }\n  #drawCircleToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    contextState: DisplayContextState\n  ) {\n    this.#drawArcEllipseToCanvas(\n      offsetX,\n      offsetY,\n      radius,\n      radius,\n      0,\n      360,\n      false,\n      contextState\n    );\n  }\n  async drawCircle(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawCircleToCanvas(offsetX, offsetY, radius, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawCircle(\n        offsetX,\n        offsetY,\n        radius,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #drawEllipseToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    contextState: DisplayContextState\n  ) {\n    this.#drawArcEllipseToCanvas(\n      offsetX,\n      offsetY,\n      radiusX,\n      radiusY,\n      0,\n      360,\n      false,\n      contextState\n    );\n  }\n  async drawEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    sendImmediately?: boolean\n  ) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawEllipseToCanvas(\n        offsetX,\n        offsetY,\n        radiusX,\n        radiusY,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawEllipse(\n        offsetX,\n        offsetY,\n        radiusX,\n        radiusY,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #getRegularPolygonBoundingBox(\n    radius: number,\n    numberOfSides: number,\n    { lineWidth }: DisplayContextState\n  ): DisplayBoundingBox {\n    let outerPadding = Math.ceil(lineWidth / 2);\n    const shapeFactor = 1 / Math.cos(Math.PI / numberOfSides);\n    outerPadding = Math.ceil(outerPadding * shapeFactor);\n\n    const diameter = radius * 2;\n    const regularPolygonBoundingBox = {\n      x: -radius - outerPadding,\n      y: -radius - outerPadding,\n      width: diameter + outerPadding * 2,\n      height: diameter + outerPadding * 2,\n    };\n    //_console.log(\"regularPolygonBoundingBox\", regularPolygonBoundingBox);\n    return regularPolygonBoundingBox;\n  }\n  #drawRegularPolygonToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    numberOfSides: number,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const localBox = this.#getRegularPolygonBoundingBox(\n      radius,\n      numberOfSides,\n      contextState\n    );\n    const rotatedLocalBox = this.#rotateBoundingBox(\n      localBox,\n      contextState.rotation\n    );\n    const rotatedBox = this.#offsetBoundingBox(\n      rotatedLocalBox,\n      offsetX,\n      offsetY\n    );\n    this.#applyClip(rotatedBox, contextState);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(rotatedBox, contextState);\n    }\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    this.#applyRotationClip(localBox, contextState);\n\n    this.context.beginPath();\n    const angleStep = (Math.PI * 2) / numberOfSides;\n    for (let i = 0; i < numberOfSides; i++) {\n      const angle = i * angleStep;\n      const x = radius * Math.cos(angle);\n      const y = radius * Math.sin(angle);\n      if (i === 0) {\n        this.context.moveTo(x, y);\n      } else {\n        this.context.lineTo(x, y);\n      }\n    }\n    this.context.closePath();\n\n    this.context.fill();\n    if (contextState.lineWidth > 0) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawRegularPolygon(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    numberOfSides: number,\n    sendImmediately?: boolean\n  ) {\n    if (numberOfSides < 3) {\n      _console.error(`invalid numberOfSides ${numberOfSides}`);\n      return;\n    }\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawRegularPolygonToCanvas(\n        offsetX,\n        offsetY,\n        radius,\n        numberOfSides,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawRegularPolygon(\n        offsetX,\n        offsetY,\n        radius,\n        numberOfSides,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #getPointsBoundingBox(\n    points: Vector2[],\n    { lineWidth, verticalAlignment, horizontalAlignment }: DisplayContextState,\n    applyLineWidth = true,\n    applyAlignment = false\n  ): DisplayBoundingBox {\n    const outerPadding = applyLineWidth ? this.#getOuterPadding(lineWidth) : 0;\n\n    let minX = 0;\n    let maxX = 0;\n    let minY = 0;\n    let maxY = 0;\n    points.forEach((point, index) => {\n      if (index == 0) {\n        minX = maxX = point.x;\n        minY = maxY = point.y;\n      } else {\n        minX = Math.min(minX, point.x);\n        maxX = Math.max(maxX, point.x);\n\n        minY = Math.min(minY, point.y);\n        maxY = Math.max(maxY, point.y);\n      }\n    });\n\n    const pointsBoundingBox = {\n      x: minX - outerPadding,\n      y: minY - outerPadding,\n      width: maxX - minX + outerPadding * 2,\n      height: maxY - minY + outerPadding * 2,\n    };\n    if (applyAlignment) {\n      assertValidAlignment(horizontalAlignment);\n      assertValidAlignment(verticalAlignment);\n      switch (horizontalAlignment) {\n        case \"start\":\n          pointsBoundingBox.x = 0;\n          break;\n        case \"center\":\n          break;\n        case \"end\":\n          pointsBoundingBox.x = -pointsBoundingBox.width;\n          break;\n      }\n      switch (verticalAlignment) {\n        case \"start\":\n          pointsBoundingBox.y = 0;\n          break;\n        case \"center\":\n          break;\n        case \"end\":\n          pointsBoundingBox.y = -pointsBoundingBox.height;\n          break;\n      }\n    }\n    //_console.log(\"pointsBoundingBox\", pointsBoundingBox);\n    return pointsBoundingBox;\n  }\n  #alignBoundingBox(\n    boundingBox: DisplayBoundingBox,\n    { verticalAlignment, horizontalAlignment }: DisplayContextState\n  ): DisplayBoundingBox {\n    const alignedBoundingBox = structuredClone(boundingBox);\n    assertValidAlignment(horizontalAlignment);\n    assertValidAlignment(verticalAlignment);\n    switch (horizontalAlignment) {\n      case \"start\":\n        alignedBoundingBox.x = 0;\n        break;\n      case \"center\":\n        break;\n      case \"end\":\n        alignedBoundingBox.x = -alignedBoundingBox.width;\n        break;\n    }\n    switch (verticalAlignment) {\n      case \"start\":\n        alignedBoundingBox.y = 0;\n        break;\n      case \"center\":\n        break;\n      case \"end\":\n        alignedBoundingBox.y = -alignedBoundingBox.height;\n        break;\n    }\n    //_console.log(\"alignedBoundingBox\", alignedBoundingBox);\n    return alignedBoundingBox;\n  }\n  #drawPolygonToCanvas(\n    offsetX: number,\n    offsetY: number,\n    points: Vector2[],\n    contextState: DisplayContextState\n  ) {\n    //_console.log(\"drawPolygonToCanvas\", { offsetX, offsetY, points });\n    this.#updateContext(contextState);\n\n    this.#save();\n    const centeredLocalBox = this.#getPointsBoundingBox(\n      points,\n      contextState,\n      true,\n      false\n    );\n    const localBox = this.#alignBoundingBox(centeredLocalBox, contextState);\n    const rotatedLocalBox = this.#rotateBoundingBox(\n      localBox,\n      contextState.rotation\n    );\n    const rotatedBox = this.#offsetBoundingBox(\n      rotatedLocalBox,\n      offsetX,\n      offsetY\n    );\n    this.#applyClip(rotatedBox, contextState);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(rotatedBox, contextState);\n    }\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    this.#applyRotationClip(localBox, contextState);\n    this.context.translate(\n      localBox.x - centeredLocalBox.x,\n      localBox.y - centeredLocalBox.y\n    );\n\n    this.context.beginPath();\n    points.forEach((point, index) => {\n      //_console.log(index, point);\n      if (index == 0) {\n        this.context.moveTo(point.x, point.y);\n      } else {\n        this.context.lineTo(point.x, point.y);\n      }\n    });\n    this.context.closePath();\n\n    this.context.fill();\n    if (contextState.lineWidth > 0) {\n      this.context.stroke();\n    }\n    this.#restore();\n  }\n  async drawPolygon(points: Vector2[], sendImmediately?: boolean) {\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawPolygonToCanvas(0, 0, points, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawPolygon(points, sendImmediately);\n    }\n  }\n  #getWireframeBoundingBox(\n    { edges, points }: DisplayWireframe,\n    contextState: DisplayContextState\n  ): DisplayBoundingBox {\n    const segments: DisplaySegment[] = [];\n    edges.forEach((edge) => {\n      const { startIndex, endIndex } = edge;\n      const point = points[startIndex];\n      const nextPoint = points[endIndex];\n      segments.push({ start: point, end: nextPoint });\n    });\n    return this.#_getSegmentsBoundingBox(segments, contextState);\n  }\n  #drawWireframeToCanvas(\n    wireframe: DisplayWireframe,\n    contextState: DisplayContextState\n  ) {\n    _console.log(\"drawWireframeToCanvas\", wireframe);\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getWireframeBoundingBox(wireframe, contextState);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box, contextState);\n    }\n\n    const { points, edges } = wireframe;\n    const _clearBoundingBoxOnDraw = this.#_clearBoundingBoxOnDraw;\n    this.#_clearBoundingBoxOnDraw = false;\n    edges.forEach((edge) => {\n      const { startIndex, endIndex } = edge;\n      const startPoint = points[startIndex];\n      const endPoint = points[endIndex];\n\n      this.#drawSegmentToCanvas(\n        startPoint.x,\n        startPoint.y,\n        endPoint.x,\n        endPoint.y,\n        contextState,\n        false\n      );\n    });\n    this.#_clearBoundingBoxOnDraw = _clearBoundingBoxOnDraw;\n\n    this.#restore();\n  }\n  async drawWireframe(wireframe: DisplayWireframe, sendImmediately?: boolean) {\n    wireframe = trimWireframe(wireframe);\n    if (wireframe.points.length == 0) {\n      return;\n    }\n    assertValidWireframe(wireframe);\n    if (this.#contextStateHelper.isSegmentUniform) {\n      const polygon = isWireframePolygon(wireframe);\n      if (polygon) {\n        return this.drawSegments(polygon, sendImmediately);\n      }\n    }\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawWireframeToCanvas(wireframe, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawWireframe(\n        wireframe,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n\n  #appendCurvePoint(curvePoints: Vector2[], curvePoint: Vector2) {\n    if (curvePoints.length >= maxNumberOfDisplayCurvePoints) {\n      _console.warn(\n        `numberOfDisplayCurvePoints ${curvePoints.length} exceeded (max ${maxNumberOfDisplayCurvePoints})`\n      );\n    } else {\n      curvePoints.push(curvePoint);\n      //_console.log(`appendCurvePoint curvePoints.length ${curvePoints.length}`);\n    }\n  }\n  #appendCurvePoints(curvePoints: Vector2[], _curvePoints: Vector2[]) {\n    _curvePoints.forEach((curvePoint) => {\n      this.#appendCurvePoint(curvePoints, curvePoint);\n    });\n  }\n\n  #generateQuadraticCurvePoints(controlPoints: Vector2[]) {\n    assertValidNumberOfControlPoints(\"quadratic\", controlPoints);\n    const [p0, p1, p2] = controlPoints;\n    if (false) {\n      const c1: Vector2 = {\n        x: p0.x + (2 / 3) * (p1.x - p0.x),\n        y: p0.y + (2 / 3) * (p1.y - p0.y),\n      };\n      const c2: Vector2 = {\n        x: p2.x + (2 / 3) * (p1.x - p2.x),\n        y: p2.y + (2 / 3) * (p1.y - p2.y),\n      };\n      return this.#generateCubicCurvePoints([p0, c1, c2, p2]);\n    } else {\n      const curvePoints: Vector2[] = [];\n\n      const p01 = getVector2Midpoint(p0, p1);\n      const p12 = getVector2Midpoint(p1, p2);\n      const mid = getVector2Midpoint(p01, p12);\n\n      const d2 = getVector2DistanceSquared(p1, mid);\n\n      if (d2 <= displayCurveToleranceSquared) {\n        curvePoints.push(p2);\n      } else {\n        curvePoints.push(...this.#generateQuadraticCurvePoints([p0, p01, mid]));\n        curvePoints.push(...this.#generateQuadraticCurvePoints([mid, p12, p2]));\n      }\n\n      return curvePoints;\n    }\n  }\n  #appendQuadraticCurvePoints(\n    curvePoints: Vector2[],\n    controlPoints: Vector2[]\n  ) {\n    this.#appendCurvePoints(\n      curvePoints,\n      this.#generateQuadraticCurvePoints(controlPoints)\n    );\n  }\n\n  #generateCubicCurvePoints(controlPoints: Vector2[]): Vector2[] {\n    assertValidNumberOfControlPoints(\"cubic\", controlPoints);\n    const [p0, p1, p2, p3] = controlPoints;\n    const curvePoints: Vector2[] = [];\n\n    const p01 = getVector2Midpoint(p0, p1);\n    const p12 = getVector2Midpoint(p1, p2);\n    const p23 = getVector2Midpoint(p2, p3);\n    const p012 = getVector2Midpoint(p01, p12);\n    const p123 = getVector2Midpoint(p12, p23);\n    const mid = getVector2Midpoint(p012, p123);\n\n    const d2a = getVector2DistanceSquared(p1, mid);\n    const d2b = getVector2DistanceSquared(p2, mid);\n\n    if (\n      d2a <= displayCurveToleranceSquared &&\n      d2b <= displayCurveToleranceSquared\n    ) {\n      curvePoints.push(p3);\n    } else {\n      curvePoints.push(...this.#generateCubicCurvePoints([p0, p01, p012, mid]));\n      curvePoints.push(...this.#generateCubicCurvePoints([mid, p123, p23, p3]));\n    }\n\n    return curvePoints;\n  }\n  #appendCubicCurvePoints(curvePoints: Vector2[], controlPoints: Vector2[]) {\n    this.#appendCurvePoints(\n      curvePoints,\n      this.#generateCubicCurvePoints(controlPoints)\n    );\n  }\n\n  #generateGenericCurvePoints(\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    isStart: boolean\n  ) {\n    assertValidNumberOfControlPoints(curveType, controlPoints);\n    let curvePoints: Vector2[] = [];\n    if (isStart) {\n      this.#appendCurvePoint(curvePoints, controlPoints[0]);\n    }\n    switch (curveType) {\n      case \"segment\":\n        this.#appendCurvePoint(curvePoints, controlPoints[1]);\n        break;\n      case \"quadratic\":\n        this.#appendQuadraticCurvePoints(curvePoints, controlPoints);\n        break;\n      case \"cubic\":\n        this.#appendCubicCurvePoints(curvePoints, controlPoints);\n        break;\n    }\n    return curvePoints;\n  }\n  #appendGenericCurvePoints(\n    curvePoints: Vector2[],\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    isStart: boolean\n  ) {\n    const _curvePoints = this.#generateGenericCurvePoints(\n      curveType,\n      controlPoints,\n      isStart\n    );\n    this.#appendCurvePoints(curvePoints, _curvePoints);\n  }\n  #drawCurveToCanvas(\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    contextState: DisplayContextState\n  ) {\n    const curvePoints = this.#generateGenericCurvePoints(\n      curveType,\n      controlPoints,\n      true\n    );\n    this.#drawSegmentsToCanvas(curvePoints, contextState);\n  }\n  async drawCurve(\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    assertValidNumberOfControlPoints(curveType, controlPoints);\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawCurveToCanvas(curveType, controlPoints, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawCurve(\n        curveType,\n        controlPoints,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #drawCurvesToCanvas(\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    contextState: DisplayContextState\n  ) {\n    assertValidPathNumberOfControlPoints(curveType, controlPoints);\n    const numberOfControlPoints =\n      displayCurveTypeToNumberOfControlPoints[curveType];\n    const curvePointsJump = numberOfControlPoints - 1;\n    const numberOfCurves =\n      (controlPoints.length - 1) / (numberOfControlPoints - 1);\n    //_console.log({ numberOfControlPoints, curvePointsJump, numberOfCurves });\n\n    const curvePoints: Vector2[] = [];\n    let curvePointOffset = 0;\n    for (let i = 0; i < numberOfCurves; i++) {\n      const isStart = i == 0;\n      this.#appendGenericCurvePoints(\n        curvePoints,\n        curveType,\n        controlPoints.slice(\n          curvePointOffset,\n          curvePointOffset + numberOfControlPoints\n        ),\n        isStart\n      );\n      curvePointOffset += curvePointsJump;\n    }\n    // _console.log({ curveType, controlPoints, curvePoints });\n    this.#drawSegmentsToCanvas(curvePoints, contextState);\n  }\n  async drawCurves(\n    curveType: DisplayBezierCurveType,\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    assertValidPathNumberOfControlPoints(curveType, controlPoints);\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawCurvesToCanvas(curveType, controlPoints, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawCurves(\n        curveType,\n        controlPoints,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n\n  async drawQuadraticBezierCurve(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    await this.drawCurve(\"quadratic\", controlPoints, sendImmediately);\n  }\n  async drawQuadraticBezierCurves(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    await this.drawCurves(\"quadratic\", controlPoints, sendImmediately);\n  }\n\n  async drawCubicBezierCurve(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    await this.drawCurve(\"cubic\", controlPoints, sendImmediately);\n  }\n  async drawCubicBezierCurves(\n    controlPoints: Vector2[],\n    sendImmediately?: boolean\n  ) {\n    await this.drawCurves(\"cubic\", controlPoints, sendImmediately);\n  }\n\n  #drawPathToCanvas(\n    isClosed: boolean,\n    curves: DisplayBezierCurve[],\n    contextState: DisplayContextState\n  ) {\n    const curvePoints: Vector2[] = [];\n    let _controlPoints: Vector2[];\n    curves.forEach((curve, index) => {\n      const isStart = index == 0;\n      const { type, controlPoints } = curve;\n      //_console.log({ type, controlPoints });\n      if (isStart) {\n        _controlPoints = controlPoints;\n      } else {\n        _controlPoints = [_controlPoints.at(-1)!, ...controlPoints];\n      }\n      this.#appendGenericCurvePoints(\n        curvePoints,\n        type,\n        _controlPoints,\n        isStart\n      );\n    });\n\n    contextState.verticalAlignment = \"center\";\n    contextState.horizontalAlignment = \"center\";\n    if (isClosed) {\n      this.#drawPolygonToCanvas(0, 0, curvePoints, contextState);\n    } else {\n      this.#drawSegmentsToCanvas(curvePoints, contextState);\n    }\n  }\n  async _drawPath(\n    isClosed: boolean,\n    curves: DisplayBezierCurve[],\n    sendImmediately?: boolean\n  ) {\n    assertValidPath(curves);\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawPathToCanvas(isClosed, curves, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!._drawPath(\n        isClosed,\n        curves,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  async drawPath(curves: DisplayBezierCurve[], sendImmediately?: boolean) {\n    await this._drawPath(false, curves, sendImmediately);\n  }\n  async drawClosedPath(\n    curves: DisplayBezierCurve[],\n    sendImmediately?: boolean\n  ) {\n    await this._drawPath(true, curves, sendImmediately);\n  }\n\n  #getLocalSegmentBoundingBox(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    {\n      lineWidth,\n      segmentStartRadius,\n      segmentEndRadius,\n      segmentStartCap,\n      segmentEndCap,\n    }: DisplayContextState\n  ): DisplayBoundingBox {\n    const outerPadding = this.#getOuterPadding(lineWidth);\n    const dx = endX - startX;\n    const dy = endY - startY;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const maxRadius =\n      Math.max(segmentStartRadius, segmentEndRadius) + outerPadding;\n    const width = maxRadius * 2;\n    let height = length;\n    height += outerPadding * 2;\n    if (segmentStartCap == \"round\") {\n      height += segmentStartRadius;\n    }\n    if (segmentEndCap == \"round\") {\n      height += segmentEndRadius;\n    }\n\n    let y = -outerPadding;\n    if (segmentStartCap == \"round\") {\n      y -= segmentStartRadius;\n    }\n\n    const box: DisplayBoundingBox = {\n      x: -maxRadius,\n      y,\n      height,\n      width,\n    };\n    return box;\n  }\n  #getSegmentBoundingBox(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    contextState: DisplayContextState\n  ): DisplayBoundingBox {\n    const localBox = this.#getLocalSegmentBoundingBox(\n      startX,\n      startY,\n      endX,\n      endY,\n      contextState\n    );\n    const dx = endX - startX;\n    const dy = endY - startY;\n    const angle = Math.atan2(dy, dx) - Math.PI / 2;\n    const rotatedBox = this.#rotateBoundingBox(localBox, angle);\n    const offsetBox = this.#offsetBoundingBox(rotatedBox, startX, startY);\n    return offsetBox;\n  }\n  #drawSegmentToCanvas(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    contextState: DisplayContextState,\n    clearBoundingBox = true\n  ) {\n    // _console.log(\"drawSegmentToCanvas\", { startX, startY, endX, endY });\n\n    this.#updateContext(contextState);\n\n    const dx = endX - startX;\n    const dy = endY - startY;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const rotation = Math.atan2(dy, dx) - Math.PI / 2;\n\n    if (length == 0) {\n      return;\n    }\n\n    this.#save();\n    const localBox = this.#getLocalSegmentBoundingBox(\n      startX,\n      startY,\n      endX,\n      endY,\n      contextState\n    );\n    const rotatedLocalBox = this.#rotateBoundingBox(localBox, rotation);\n    const rotatedBox = this.#offsetBoundingBox(rotatedLocalBox, startX, startY);\n    this.#applyClip(rotatedBox, contextState);\n    if (this.#clearBoundingBoxOnDraw && clearBoundingBox) {\n      this.#clearBoundingBox(rotatedBox, contextState);\n    }\n    this.#translateContext(startX, startY);\n    this.#rotateContext(rotation);\n    this.#applyRotationClip(localBox, contextState);\n\n    const x0 = 0;\n    const x1 = 0;\n    const y0 = 0;\n    const y1 = length;\n\n    const r0 = contextState.segmentStartRadius;\n    const r1 = contextState.segmentEndRadius;\n\n    if (contextState.segmentStartCap == \"round\") {\n      this.context.beginPath();\n      this.context.arc(x0, y0, r0, 0, Math.PI * 2);\n      this.context.closePath();\n      this.context.fill();\n      if (contextState.lineWidth > 0) {\n        this.context.stroke();\n      }\n    }\n    if (contextState.segmentEndCap == \"round\") {\n      this.context.beginPath();\n      this.context.arc(x1, y1, r1, 0, Math.PI * 2);\n      this.context.closePath();\n      this.context.fill();\n      if (contextState.lineWidth > 0) {\n        this.context.stroke();\n      }\n    }\n\n    // full trapezoid (top right, clockwise)\n    this.context.beginPath();\n    this.context.moveTo(r0, 0);\n    this.context.lineTo(-r0, 0);\n    this.context.lineTo(-r1, length);\n    this.context.lineTo(r1, length);\n    this.context.closePath();\n    this.context.fill();\n\n    // Stroke only the side edges (top right, clockwise)\n    if (contextState.lineWidth > 0) {\n      this.context.beginPath();\n\n      this.context.moveTo(r0, 0);\n      if (contextState.segmentStartCap === \"flat\") {\n        this.context.lineTo(-r0, 0);\n      } else {\n        this.context.moveTo(-r0, 0);\n      }\n\n      this.context.lineTo(-r1, length);\n\n      if (contextState.segmentEndCap === \"flat\") {\n        this.context.lineTo(r1, length);\n      } else {\n        this.context.moveTo(r1, length);\n      }\n\n      this.context.lineTo(r0, 0);\n      if (contextState.segmentStartCap === \"flat\") {\n        this.context.closePath();\n      }\n      this.context.stroke();\n    }\n\n    this.#restore();\n  }\n  async drawSegment(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    sendImmediately?: boolean\n  ) {\n    if (startX == endX && startY == endY) {\n      _console.error(`cannot draw segment of length 0`);\n      return;\n    }\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawSegmentToCanvas(startX, startY, endX, endY, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawSegment(\n        startX,\n        startY,\n        endX,\n        endY,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #getSegmentsBoundingBox(\n    points: Vector2[],\n    contextState: DisplayContextState\n  ): DisplayBoundingBox {\n    const segments: DisplaySegment[] = [];\n    points.forEach((point, index) => {\n      if (index == points.length - 1) {\n        return;\n      }\n      const nextPoint = points[index + 1];\n      segments.push({ start: point, end: nextPoint });\n    });\n    return this.#_getSegmentsBoundingBox(segments, contextState);\n  }\n  #_getSegmentsBoundingBox(\n    segments: DisplaySegment[],\n    { lineWidth, segmentStartRadius, segmentEndRadius }: DisplayContextState\n  ): DisplayBoundingBox {\n    const outerPadding = Math.ceil(lineWidth / 2);\n\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n\n    segments.forEach((segment, index) => {\n      const startX = segment.start.x;\n      const startY = segment.start.y;\n      const endX = segment.end.x;\n      const endY = segment.end.y;\n\n      if (index == 0) {\n        minX = Math.min(startX - segmentStartRadius, endX - segmentEndRadius);\n        maxX = Math.max(startX + segmentStartRadius, endX + segmentEndRadius);\n        minY = Math.min(startY - segmentStartRadius, endY - segmentEndRadius);\n        maxY = Math.max(endY + segmentStartRadius, endY + segmentEndRadius);\n      } else {\n        minX = Math.min(\n          minX,\n          Math.min(startX - segmentStartRadius, endX - segmentEndRadius)\n        );\n        maxX = Math.max(\n          maxX,\n          Math.max(startX + segmentStartRadius, endX + segmentEndRadius)\n        );\n        minY = Math.min(\n          minY,\n          Math.min(startY - segmentStartRadius, endY - segmentEndRadius)\n        );\n        maxY = Math.max(\n          maxY,\n          Math.max(endY + segmentStartRadius, endY + segmentEndRadius)\n        );\n      }\n    });\n\n    const segmentsBoundingBox = {\n      x: minX - outerPadding,\n      y: minY - outerPadding,\n      width: maxX - minX + outerPadding * 2,\n      height: maxY - minY + outerPadding * 2,\n    };\n    //_console.log(\"segmentsBoundingBox\", segmentsBoundingBox);\n    return segmentsBoundingBox;\n  }\n  #drawSegmentsToCanvas(points: Vector2[], contextState: DisplayContextState) {\n    this.#updateContext(contextState);\n\n    this.#save();\n    const box = this.#getSegmentsBoundingBox(points, contextState);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(box, contextState);\n    }\n\n    const _clearBoundingBoxOnDraw = this.#_clearBoundingBoxOnDraw;\n    this.#_clearBoundingBoxOnDraw = false;\n    points.forEach((point, index) => {\n      if (index > 0) {\n        const previousPoint = points[index - 1];\n\n        const startX = previousPoint.x;\n        const startY = previousPoint.y;\n        const endX = point.x;\n        const endY = point.y;\n\n        this.#drawSegmentToCanvas(\n          startX,\n          startY,\n          endX,\n          endY,\n          contextState,\n          false\n        );\n      }\n    });\n    this.#_clearBoundingBoxOnDraw = _clearBoundingBoxOnDraw;\n\n    this.#restore();\n  }\n  async drawSegments(points: Vector2[], sendImmediately?: boolean) {\n    _console.assertRangeWithError(\"numberOfPoints\", points.length, 2, 255);\n    // _console.log({ points });\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawSegmentsToCanvas(points, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawSegments(points, sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #drawArcToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians: boolean,\n    contextState: DisplayContextState\n  ) {\n    this.#drawArcEllipseToCanvas(\n      offsetX,\n      offsetY,\n      radius,\n      radius,\n      startAngle,\n      angleOffset,\n      isRadians,\n      contextState\n    );\n  }\n\n  async drawArc(\n    offsetX: number,\n    offsetY: number,\n    radius: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    startAngle = isRadians ? startAngle : degToRad(startAngle);\n    angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawArcToCanvas(\n        offsetX,\n        offsetY,\n        radius,\n        startAngle,\n        angleOffset,\n        true,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawArc(\n        offsetX,\n        offsetY,\n        radius,\n        startAngle,\n        angleOffset,\n        true,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #drawArcEllipseToCanvas(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians: boolean,\n    contextState: DisplayContextState\n  ) {\n    startAngle = isRadians ? startAngle : degToRad(startAngle);\n    angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n    isRadians = true;\n\n    this.#updateContext(contextState);\n\n    this.#save();\n    const localBox = this.#getRectBoundingBox(\n      radiusX * 2,\n      radiusY * 2,\n      contextState\n    );\n    const rotatedLocalBox = this.#rotateBoundingBox(\n      localBox,\n      contextState.rotation\n    );\n    const rotatedBox = this.#offsetBoundingBox(\n      rotatedLocalBox,\n      offsetX,\n      offsetY\n    );\n    this.#applyClip(rotatedBox, contextState);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(rotatedBox, contextState);\n    }\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    this.#applyRotationClip(localBox, contextState);\n\n    const outerPadding = this.#getOuterPadding(contextState.lineWidth);\n    const startX = localBox.x + outerPadding;\n    const startY = localBox.y + outerPadding;\n    const centerX = startX + radiusX;\n    const centerY = startY + radiusY;\n\n    // draw elliptical pie slice (includes radial lines)\n    this.context.beginPath();\n    this.context.moveTo(centerX, centerY);\n    const clockwise = angleOffset > 0;\n    const endAngle = startAngle + angleOffset;\n\n    this.context.ellipse(\n      centerX,\n      centerY,\n      radiusX,\n      radiusY,\n      0,\n      startAngle,\n      endAngle,\n      !clockwise\n    );\n    this.context.closePath();\n    this.context.fill();\n\n    // Stroke only the elliptical arc\n    if (contextState.lineWidth > 0) {\n      this.context.beginPath();\n      this.context.ellipse(\n        centerX,\n        centerY,\n        radiusX,\n        radiusY,\n        0,\n        startAngle,\n        endAngle,\n        !clockwise\n      );\n      this.context.stroke();\n    }\n\n    this.#restore();\n  }\n  async drawArcEllipse(\n    offsetX: number,\n    offsetY: number,\n    radiusX: number,\n    radiusY: number,\n    startAngle: number,\n    angleOffset: number,\n    isRadians?: boolean,\n    sendImmediately?: boolean\n  ) {\n    startAngle = isRadians ? startAngle : degToRad(startAngle);\n    angleOffset = isRadians ? angleOffset : degToRad(angleOffset);\n    isRadians = true;\n\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawArcEllipseToCanvas(\n        offsetX,\n        offsetY,\n        radiusX,\n        radiusY,\n        startAngle,\n        angleOffset,\n        true,\n        contextState\n      )\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawArcEllipse(\n        offsetX,\n        offsetY,\n        radiusX,\n        radiusY,\n        startAngle,\n        angleOffset,\n        true,\n        sendImmediately\n      );\n    }\n  }\n\n  #bitmapCanvas = document.createElement(\"canvas\");\n  #bitmapContext!: CanvasRenderingContext2D;\n  async #drawBitmapToCanvas(\n    offsetX: number,\n    offsetY: number,\n    bitmap: DisplayBitmap,\n    contextState: DisplayContextState\n  ) {\n    this.#updateContext(contextState);\n\n    const { bitmapScaleX, bitmapScaleY } = contextState;\n    const width = bitmap.width * Math.abs(bitmapScaleX);\n    const height = bitmap.height * Math.abs(bitmapScaleY);\n\n    this.#save();\n    const localBox = this.#getRectBoundingBox(\n      width,\n      height,\n      contextState,\n      false\n    );\n    const rotatedLocalBox = this.#rotateBoundingBox(\n      localBox,\n      contextState.rotation\n    );\n    const rotatedBox = this.#offsetBoundingBox(\n      rotatedLocalBox,\n      offsetX,\n      offsetY\n    );\n    this.#applyClip(rotatedBox, contextState);\n    if (this.#clearBoundingBoxOnDraw) {\n      this.#clearBoundingBox(rotatedBox, contextState);\n    }\n    this.#transformContext(offsetX, offsetY, contextState.rotation);\n    this.#applyRotationClip(localBox, contextState);\n\n    this.#bitmapCanvas.width = bitmap.width;\n    this.#bitmapCanvas.height = bitmap.height;\n\n    const bitmapImageData = this.#bitmapContext.createImageData(\n      bitmap.width,\n      bitmap.height\n    );\n    const rawBitmapImageData = bitmapImageData.data;\n\n    const startX = localBox.x;\n    const startY = localBox.y;\n    bitmap.pixels.forEach((pixel, pixelIndex) => {\n      let colorIndex = contextState.bitmapColorIndices[pixel];\n      if (this.#useSpriteColorIndices) {\n        colorIndex = contextState.spriteColorIndices[colorIndex];\n      }\n      const color = hexToRGB(this.colors[colorIndex]);\n      const opacity = this.#getColorOpacity(colorIndex);\n\n      const imageDataOffset = pixelIndex * 4;\n\n      rawBitmapImageData[imageDataOffset + 0] = color.r;\n      rawBitmapImageData[imageDataOffset + 1] = color.g;\n      rawBitmapImageData[imageDataOffset + 2] = color.b;\n      rawBitmapImageData[imageDataOffset + 3] = Math.floor(opacity * 255);\n    });\n\n    // _console.log(\"rawBitmapImageData\", rawBitmapImageData);\n\n    this.#bitmapContext.putImageData(bitmapImageData, 0, 0);\n    this.#context.scale(Math.sign(bitmapScaleX), Math.sign(bitmapScaleY));\n    this.#context.drawImage(this.#bitmapCanvas, startX, startY, width, height);\n\n    this.#restore();\n  }\n\n  assertValidNumberOfColors(numberOfColors: number) {\n    _console.assertRangeWithError(\n      \"numberOfColors\",\n      numberOfColors,\n      2,\n      this.numberOfColors\n    );\n  }\n  assertValidBitmap(bitmap: DisplayBitmap) {\n    this.assertValidNumberOfColors(bitmap.numberOfColors);\n    assertValidBitmapPixels(bitmap);\n  }\n  async drawBitmap(\n    offsetX: number,\n    offsetY: number,\n    bitmap: DisplayBitmap,\n    sendImmediately?: boolean\n  ) {\n    this.assertValidBitmap(bitmap);\n    // _console.log(\"drawBitmap\", { offsetX, offsetY, bitmap, sendImmediately });\n    const contextState = structuredClone(this.contextState);\n    this.#rearDrawStack.push(() =>\n      this.#drawBitmapToCanvas(offsetX, offsetY, bitmap, contextState)\n    );\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawBitmap(\n        offsetX,\n        offsetY,\n        bitmap,\n        sendImmediately\n      );\n    }\n  }\n\n  // SPRITES\n  #spriteSheets: Record<string, DisplaySpriteSheet> = {};\n  #spriteSheetIndices: Record<string, number> = {};\n  get spriteSheets() {\n    return this.#spriteSheets;\n  }\n  get spriteSheetIndices() {\n    return this.#spriteSheetIndices;\n  }\n  async uploadSpriteSheet(spriteSheet: DisplaySpriteSheet) {\n    spriteSheet = structuredClone(spriteSheet);\n    if (!this.#spriteSheets[spriteSheet.name]) {\n      this.#spriteSheetIndices[spriteSheet.name] = Object.keys(\n        this.#spriteSheets\n      ).length;\n    }\n    this.#spriteSheets[spriteSheet.name] = spriteSheet;\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.uploadSpriteSheet(spriteSheet);\n    }\n  }\n  async uploadSpriteSheets(spriteSheets: DisplaySpriteSheet[]) {\n    for (const spriteSheet of spriteSheets) {\n      _console.log(`uploading spriteSheet \"${spriteSheet.name}\"...`);\n      await this.uploadSpriteSheet(spriteSheet);\n    }\n  }\n  assertLoadedSpriteSheet(spriteSheetName: string) {\n    assertLoadedSpriteSheet(this, spriteSheetName);\n  }\n  assertSelectedSpriteSheet(spriteSheetName: string) {\n    assertSelectedSpriteSheet(this, spriteSheetName);\n  }\n  assertAnySelectedSpriteSheet() {\n    assertAnySelectedSpriteSheet(this);\n  }\n  assertSprite(spriteName: string) {\n    return assertSprite(this, spriteName);\n  }\n  getSprite(spriteName: string): DisplaySprite | undefined {\n    return getSprite(this, spriteName);\n  }\n  getSpriteSheetPalette(\n    paletteName: string\n  ): DisplaySpriteSheetPalette | undefined {\n    return getSpriteSheetPalette(this, paletteName);\n  }\n  getSpriteSheetPaletteSwap(\n    paletteSwapName: string\n  ): DisplaySpriteSheetPaletteSwap | undefined {\n    return getSpriteSheetPaletteSwap(this, paletteSwapName);\n  }\n  getSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string\n  ): DisplaySpritePaletteSwap | undefined {\n    return getSpritePaletteSwap(this, spriteName, paletteSwapName);\n  }\n  get selectedSpriteSheet() {\n    if (this.contextState.spriteSheetName) {\n      return this.#spriteSheets[this.contextState.spriteSheetName];\n    }\n  }\n  get selectedSpriteSheetName() {\n    return this.selectedSpriteSheet?.name;\n  }\n  async selectSpriteSheet(spriteSheetName: string, sendImmediately?: boolean) {\n    this.assertLoadedSpriteSheet(spriteSheetName);\n    const differences = this.#contextStateHelper.update({\n      spriteSheetName,\n    });\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      this.deviceDisplayManager!.selectSpriteSheet(\n        spriteSheetName,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#onContextStateUpdate(differences);\n  }\n  #runSpriteCommand(\n    command: DisplayContextCommand,\n    contextState: DisplayContextState\n  ) {\n    _console.log(\"runSpriteCommand\", command);\n    if (command.type == \"drawSprite\") {\n      const spriteSheet = this.spriteSheets[contextState.spriteSheetName!];\n      const sprite = spriteSheet.sprites[command.spriteIndex];\n      if (sprite) {\n        _console.log(\"drawing sub sprite\", sprite);\n        const _contextState = structuredClone(this.contextState);\n        this.#saveContextForSprite(\n          command.offsetX,\n          command.offsetY,\n          sprite,\n          _contextState\n        );\n        sprite.commands.forEach((command) => {\n          this.#runSpriteCommand(command, _contextState);\n        });\n        this.#restoreContextForSprite();\n      } else {\n        _console.error(\n          `sprite index ${command.spriteIndex} not found in spriteSheet`\n        );\n      }\n    } else {\n      this.runContextCommand(command);\n    }\n  }\n  #drawSpriteToCanvas(\n    offsetX: number,\n    offsetY: number,\n    sprite: DisplaySprite,\n    contextState: DisplayContextState\n  ) {\n    //this.#setIgnoreDevice(true);\n    this.#saveContextForSprite(offsetX, offsetY, sprite, contextState);\n    this.#setIsDrawingSprite(true);\n\n    sprite.commands.forEach((command) => {\n      this.#runSpriteCommand(command, contextState);\n    });\n\n    this.#restoreContextForSprite();\n    this.#setIsDrawingSprite(false);\n    //this.#setIgnoreDevice(false);\n  }\n  async drawSprite(\n    offsetX: number,\n    offsetY: number,\n    spriteName: string,\n    sendImmediately?: boolean\n  ) {\n    _console.assertWithError(\n      this.selectedSpriteSheet,\n      \"no spriteSheet selected\"\n    );\n    const sprite = this.selectedSpriteSheet?.sprites.find(\n      (sprite) => sprite.name == spriteName\n    );\n    _console.assertWithError(sprite, `sprite \"${spriteName}\" not found`);\n    _console.assertWithError(\"width\" in sprite!, \"sprite has no width\");\n    _console.assertWithError(\"height\" in sprite!, \"sprite has no height\");\n\n    const contextState = structuredClone(this.contextState);\n    this.#drawSpriteToCanvas(offsetX, offsetY, sprite!, contextState);\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawSprite(\n        offsetX,\n        offsetY,\n        spriteName,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #drawSpritesToCanvas(\n    offsetX: number,\n    offsetY: number,\n    spriteLines: DisplaySpriteLines,\n    contextState: DisplayContextState\n  ) {\n    // _console.log({ offsetX, offsetY, spriteLines });\n\n    const { expandedSpritesLines, lineBreadths, localSize, size } =\n      getSpriteLinesMetrics(spriteLines, this.#spriteSheets, contextState);\n\n    const isSpritesDirectionPositive = isDirectionPositive(\n      contextState.spritesDirection\n    );\n    const isSpritesLineDirectionPositive = isDirectionPositive(\n      contextState.spritesLineDirection\n    );\n\n    const isSpritesDirectionHorizontal = isDirectionHorizontal(\n      contextState.spritesDirection\n    );\n    const isSpritesLineDirectionHorizontal = isDirectionHorizontal(\n      contextState.spritesLineDirection\n    );\n\n    const areSpritesDirectionsOrthogonal =\n      isSpritesDirectionHorizontal != isSpritesLineDirectionHorizontal;\n\n    const breadthSizeKey = isSpritesDirectionHorizontal ? \"width\" : \"height\";\n\n    const spritesBreadthSign = isSpritesDirectionPositive ? 1 : -1;\n    const spritesDepthSign = isSpritesLineDirectionPositive ? 1 : -1;\n\n    //this.#setIgnoreDevice(true);\n    this.#setCanvasContextTransform(\n      offsetX,\n      offsetY,\n      localSize.width,\n      localSize.height,\n      contextState\n    );\n    this.#setIsDrawingSprite(true);\n\n    this.#saveContext();\n    this.clearCrop();\n    this.clearRotation();\n    this.clearRotationCrop();\n    this.resetSpriteScale();\n\n    if (isSpritesDirectionHorizontal) {\n      if (isSpritesDirectionPositive) {\n        this.setHorizontalAlignment(\"start\");\n      } else {\n        this.setHorizontalAlignment(\"end\");\n      }\n    } else {\n      if (isSpritesDirectionPositive) {\n        this.setVerticalAlignment(\"start\");\n      } else {\n        this.setVerticalAlignment(\"end\");\n      }\n    }\n\n    if (areSpritesDirectionsOrthogonal) {\n      if (isSpritesLineDirectionHorizontal) {\n        if (isSpritesLineDirectionPositive) {\n          this.setHorizontalAlignment(\"start\");\n        } else {\n          this.setHorizontalAlignment(\"end\");\n        }\n      } else {\n        if (isSpritesLineDirectionPositive) {\n          this.setVerticalAlignment(\"start\");\n        } else {\n          this.setVerticalAlignment(\"end\");\n        }\n      }\n    } else {\n      if (isSpritesDirectionHorizontal) {\n        this.setVerticalAlignment(\"start\");\n      } else {\n        this.setHorizontalAlignment(\"start\");\n      }\n    }\n\n    let spritesBreadthStart = 0;\n    switch (contextState.spritesDirection) {\n      case \"right\":\n        spritesBreadthStart = -localSize.width / 2;\n        break;\n      case \"left\":\n        spritesBreadthStart = localSize.width / 2;\n        break;\n      case \"up\":\n        spritesBreadthStart = localSize.height / 2;\n        break;\n      case \"down\":\n        spritesBreadthStart = -localSize.height / 2;\n        break;\n    }\n\n    const spriteOffset = {\n      x: 0,\n      y: 0,\n    };\n\n    const breadthOffsetKey = isSpritesDirectionHorizontal ? \"x\" : \"y\";\n    const depthOffsetKey = isSpritesLineDirectionHorizontal ? \"x\" : \"y\";\n\n    const signedSpritesSpacing =\n      spritesBreadthSign * contextState.spritesSpacing;\n    const signedSpriteLineSpacing =\n      spritesDepthSign * contextState.spritesLineSpacing;\n    const signedSpriteLineHeight =\n      spritesDepthSign * contextState.spritesLineHeight;\n\n    if (!areSpritesDirectionsOrthogonal) {\n      spriteOffset[breadthOffsetKey] = spritesBreadthStart;\n    }\n\n    if (areSpritesDirectionsOrthogonal) {\n      switch (contextState.spritesLineDirection) {\n        case \"right\":\n          spriteOffset[depthOffsetKey] = -localSize.width / 2;\n          break;\n        case \"left\":\n          spriteOffset[depthOffsetKey] = localSize.width / 2;\n          break;\n        case \"up\":\n          spriteOffset[depthOffsetKey] = localSize.height / 2;\n          break;\n        case \"down\":\n          spriteOffset[depthOffsetKey] = -localSize.height / 2;\n          break;\n      }\n    } else {\n      switch (contextState.spritesDirection) {\n        case \"right\":\n        case \"left\":\n          spriteOffset.y = -localSize.height / 2;\n          break;\n        case \"up\":\n        case \"down\":\n          spriteOffset.x = -localSize.width / 2;\n          break;\n      }\n    }\n\n    expandedSpritesLines.forEach((_spritesLine, lineIndex) => {\n      const spritesLineBreadth = lineBreadths[lineIndex];\n      if (areSpritesDirectionsOrthogonal) {\n        switch (contextState.spritesLineAlignment) {\n          case \"start\":\n            spriteOffset[breadthOffsetKey] = spritesBreadthStart;\n            break;\n          case \"center\":\n            spriteOffset[breadthOffsetKey] =\n              spritesBreadthStart +\n              spritesBreadthSign *\n                ((localSize[breadthSizeKey] - spritesLineBreadth) / 2);\n            break;\n          case \"end\":\n            spriteOffset[breadthOffsetKey] =\n              spritesBreadthStart +\n              spritesBreadthSign *\n                (localSize[breadthSizeKey] - spritesLineBreadth);\n            break;\n        }\n      }\n      _spritesLine.forEach((sprite) => {\n        const _spriteOffset = {\n          x: spriteOffset.x,\n          y: spriteOffset.y,\n        };\n\n        const spriteAlignmentOffsetKey = isSpritesDirectionHorizontal\n          ? \"y\"\n          : \"x\";\n        const spriteDepth = isSpritesDirectionHorizontal\n          ? sprite.height\n          : sprite.width;\n\n        switch (contextState.spritesAlignment) {\n          case \"start\":\n            break;\n          case \"center\":\n            _spriteOffset[spriteAlignmentOffsetKey] +=\n              spritesDepthSign *\n              ((contextState.spritesLineHeight - spriteDepth) / 2);\n            break;\n          case \"end\":\n            _spriteOffset[spriteAlignmentOffsetKey] +=\n              spritesDepthSign * (contextState.spritesLineHeight - spriteDepth);\n            break;\n        }\n\n        const spriteContextState = structuredClone(this.contextState);\n        this.#saveContextForSprite(\n          _spriteOffset.x,\n          _spriteOffset.y,\n          sprite,\n          spriteContextState\n        );\n        sprite.commands.forEach((command) => {\n          this.#runSpriteCommand(command, spriteContextState);\n        });\n        this.#restoreContextForSprite();\n\n        spriteOffset[breadthOffsetKey] +=\n          spritesBreadthSign *\n          (isSpritesDirectionHorizontal ? sprite.width : sprite.height);\n        spriteOffset[breadthOffsetKey] += signedSpritesSpacing;\n      });\n\n      spriteOffset[breadthOffsetKey] -= signedSpritesSpacing;\n      if (areSpritesDirectionsOrthogonal) {\n        spriteOffset[depthOffsetKey] += signedSpriteLineHeight;\n      }\n      spriteOffset[depthOffsetKey] += signedSpriteLineSpacing;\n    });\n\n    this.#resetCanvasContextTransform();\n    this.#restoreContext();\n\n    this.#setIsDrawingSprite(false);\n    //this.#setIgnoreDevice(false);\n  }\n  async drawSprites(\n    offsetX: number,\n    offsetY: number,\n    spriteLines: DisplaySpriteLines,\n    sendImmediately?: boolean\n  ) {\n    _console.assertWithError(\n      this.contextState.spritesLineHeight > 0,\n      `spritesLineHeight must be >0`\n    );\n    assertValidSpriteLines(this, spriteLines);\n\n    const contextState = structuredClone(this.contextState);\n    this.#drawSpritesToCanvas(offsetX, offsetY, spriteLines, contextState);\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.drawSprites(\n        offsetX,\n        offsetY,\n        spriteLines,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  async drawSpriteFromSpriteSheet(\n    offsetX: number,\n    offsetY: number,\n    spriteName: string,\n    spriteSheet: DisplaySpriteSheet,\n    paletteName?: string,\n    sendImmediately?: boolean\n  ) {\n    return drawSpriteFromSpriteSheet(\n      this,\n      offsetX,\n      offsetY,\n      spriteName,\n      spriteSheet,\n      paletteName,\n      sendImmediately\n    );\n  }\n  async drawSpritesString(\n    offsetX: number,\n    offsetY: number,\n    string: string,\n    requireAll?: boolean,\n    maxLineBreadth?: number,\n    separators?: string[],\n    sendImmediately?: boolean\n  ) {\n    const spriteLines = this.stringToSpriteLines(\n      string,\n      requireAll,\n      maxLineBreadth,\n      separators\n    );\n    await this.drawSprites(offsetX, offsetY, spriteLines, sendImmediately);\n  }\n  stringToSpriteLines(\n    string: string,\n    requireAll?: boolean,\n    maxLineBreadth?: number,\n    separators?: string[]\n  ): DisplaySpriteLines {\n    return stringToSpriteLines(\n      string,\n      this.spriteSheets,\n      this.contextState,\n      requireAll,\n      maxLineBreadth,\n      separators\n    );\n  }\n  stringToSpriteLinesMetrics(\n    string: string,\n    requireAll?: boolean,\n    maxLineBreadth?: number,\n    separators?: string[]\n  ) {\n    return stringToSpriteLinesMetrics(\n      string,\n      this.spriteSheets,\n      this.contextState,\n      requireAll,\n      maxLineBreadth,\n      separators\n    );\n  }\n\n  // BRIGHTNESS\n  #brightness: DisplayBrightness = \"medium\";\n  get brightness() {\n    return this.#brightness;\n  }\n  #brightnessOpacities: Record<DisplayBrightness, number> = {\n    veryLow: 0.5,\n    low: 0.7,\n    medium: 0.9,\n    high: 0.95,\n    veryHigh: 1,\n  };\n  get #brightnessOpacity() {\n    return this.#brightnessOpacities[this.brightness];\n  }\n  #didSetBrightness = false;\n  #flushBrightness() {\n    if (!this.#didSetBrightness) {\n      return false;\n    }\n    _console.log(\"flushBrightness\");\n    this.#didSetBrightness = false;\n    return true;\n  }\n  async setBrightness(\n    newBrightness: DisplayBrightness,\n    sendImmediately?: boolean\n  ) {\n    if (this.#brightness == newBrightness) {\n      // _console.log(`redundant brightness ${newBrightness}`);\n      return;\n    }\n    this.#brightness = newBrightness;\n    // _console.log({ brightness: this.brightness });\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.setBrightness(\n        newBrightness,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n    this.#didSetBrightness = true;\n    this.#dispatchEvent(\"brightness\", { brightness: this.brightness });\n  }\n  async #resetBrightness() {\n    await this.setBrightness(\"medium\");\n  }\n  async #updateDeviceBrightness(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    // _console.log(\"updateDeviceBrightness\");\n    await this.device?.setDisplayBrightness(this.brightness, sendImmediately);\n  }\n  async #updateDeviceSpriteSheets() {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    const sortedSpriteSheets = Object.values(this.spriteSheets).sort(\n      (a, b) =>\n        this.spriteSheetIndices[a.name] - this.spriteSheetIndices[b.name]\n    );\n    await this.uploadSpriteSheets(sortedSpriteSheets);\n  }\n  async #updateDeviceSelectedSpriteSheet(sendImmediately?: boolean) {\n    if (!this.device?.isConnected) {\n      return;\n    }\n    if (!this.selectedSpriteSheetName) {\n      return;\n    }\n    _console.log(\"updateDeviceSelectedSpriteSheet\");\n    await this.device?.selectDisplaySpriteSheet(\n      this.selectedSpriteSheetName,\n      sendImmediately\n    );\n  }\n\n  async runContextCommand(\n    command: DisplayContextCommand,\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommand(this, command, sendImmediately);\n  }\n  async runContextCommands(\n    commands: DisplayContextCommand[],\n    sendImmediately?: boolean\n  ) {\n    return runDisplayContextCommands(this, commands, sendImmediately);\n  }\n\n  get #contextScale() {\n    const transform = this.#context.getTransform();\n    const scaleX = transform.a;\n    const scaleY = transform.d;\n    return { x: scaleX, y: scaleY };\n  }\n  #setCanvasContextTransform(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    contextState: DisplayContextState\n  ) {\n    this.#rearDrawStack.push(() => {\n      const scaledWidth = width * Math.abs(contextState.spriteScaleX);\n      const scaledHeight = height * Math.abs(contextState.spriteScaleY);\n\n      this.#save();\n      const localBox = this.#getRectBoundingBox(\n        scaledWidth,\n        scaledHeight,\n        contextState,\n        false\n      );\n      const rotatedLocalBox = this.#rotateBoundingBox(\n        localBox,\n        contextState.rotation\n      );\n      const rotatedBox = this.#offsetBoundingBox(\n        rotatedLocalBox,\n        offsetX,\n        offsetY\n      );\n      this.#applyClip(rotatedBox, contextState);\n      if (this.#clearBoundingBoxOnDraw) {\n        this.#clearBoundingBox(rotatedBox, contextState);\n      }\n      this.#transformContext(offsetX, offsetY, contextState.rotation);\n      this.#applyRotationClip(localBox, contextState);\n\n      this.#correctAlignmentTranslation(localBox, contextState);\n      this.#scaleContext(contextState.spriteScaleX, contextState.spriteScaleY);\n    });\n  }\n  #resetCanvasContextTransform() {\n    this.#rearDrawStack.push(() => {\n      //_console.log(\"reset transform\");\n      this.#restore();\n    });\n  }\n\n  #_ignoreDevice = false;\n  #_ignoreDeviceCounter = 0;\n  #setIgnoreDevice(newIgnoreDevice: boolean, override = false) {\n    if (override) {\n      this.#_ignoreDeviceCounter = newIgnoreDevice ? 1 : 0;\n    } else {\n      this.#_ignoreDeviceCounter += newIgnoreDevice ? 1 : -1;\n      this.#_ignoreDeviceCounter = Math.max(0, this.#_ignoreDeviceCounter);\n      _console.log({\n        ignoreDeviceCounter: this.#_ignoreDeviceCounter,\n      });\n    }\n    const ignoreDevice = this.#_ignoreDeviceCounter > 0;\n    this.#_ignoreDevice = ignoreDevice;\n    _console.log({\n      ignoreDevice,\n    });\n    this.#rearDrawStack.push(() => {\n      //_console.log({ ignoreDevice });\n      this.#_ignoreDevice = ignoreDevice;\n    });\n  }\n  get #ignoreDevice() {\n    if (this.#_ignoreDevice) {\n      return true;\n    }\n    if (this.#isDrawingBlankSprite) {\n      return this.#isDrawingSpriteCounter > 1;\n    }\n    return this.#isDrawingSprite;\n  }\n  get #useSpriteColorIndices() {\n    return this.#isDrawingSprite;\n  }\n  #spriteContextStack: DisplayContextState[] = [];\n  #spriteStack: DisplaySprite[] = [];\n  #saveContextForSprite(\n    offsetX: number,\n    offsetY: number,\n    sprite: DisplaySprite | DisplaySize,\n    contextState: DisplayContextState\n  ) {\n    this.#setCanvasContextTransform(\n      offsetX,\n      offsetY,\n      sprite.width,\n      sprite.height,\n      contextState\n    );\n\n    if (\"name\" in sprite) {\n      _console.assertWithError(\n        !this.#spriteStack.includes(sprite),\n        `cyclical sprite ${sprite.name} found in stack`\n      );\n    }\n\n    const spriteColorIndices = contextState.spriteColorIndices.slice();\n    this.#spriteContextStack.push(contextState);\n    this.#resetContextState();\n    this.contextState.spriteColorIndices = spriteColorIndices;\n    //_console.log(\"_saveContextForSprite\", this.contextState);\n  }\n  #restoreContextForSprite() {\n    this.#resetCanvasContextTransform();\n\n    const contextState = this.#spriteContextStack.pop();\n    if (!contextState) {\n      _console.warn(\"#spriteContextStack empty\");\n      return;\n    }\n    //_console.log(\"_restoreContextForSprite\", contextState);\n    this.#contextStateHelper.update(contextState);\n  }\n\n  #runPreviewSpriteCommand(\n    command: DisplayContextCommand,\n    spriteSheet: DisplaySpriteSheet\n  ) {\n    //_console.log(\"runPreviewSpriteCommand\", command);\n    if (command.type == \"drawSprite\") {\n      const sprite = spriteSheet.sprites[command.spriteIndex];\n      if (sprite) {\n        _console.log(\"drawing sub sprite\", sprite);\n        const contextState = structuredClone(this.contextState);\n        this.#saveContextForSprite(\n          command.offsetX,\n          command.offsetY,\n          sprite,\n          contextState\n        );\n        sprite.commands.forEach((command) => {\n          this.#runPreviewSpriteCommand(command, spriteSheet);\n        });\n        this.#restoreContextForSprite();\n      } else {\n        _console.error(\n          `spriteIndex ${command.spriteIndex} not found in spriteSheet`\n        );\n      }\n    } else {\n      this.runContextCommand(command);\n    }\n  }\n  previewSprite(\n    offsetX: number,\n    offsetY: number,\n    sprite: DisplaySprite,\n    spriteSheet: DisplaySpriteSheet\n  ) {\n    //this.#setIgnoreDevice(true);\n    const contextState = structuredClone(this.contextState);\n    this.#saveContextForSprite(offsetX, offsetY, sprite, contextState);\n    this.#setIsDrawingSprite(true);\n\n    sprite.commands.forEach((command) => {\n      this.#runPreviewSpriteCommand(command, spriteSheet);\n    });\n\n    this.#restoreContextForSprite();\n    this.#setIsDrawingSprite(false);\n    //this.#setIgnoreDevice(false);\n  }\n  previewSpriteCommands(commands: DisplayContextCommand[]) {\n    this.#setIsDrawingSprite(true);\n\n    commands.forEach((command) => {\n      this.runContextCommand(command);\n    });\n\n    this.#setIsDrawingSprite(false);\n  }\n\n  // SPRITE SHEET PALETTES\n\n  assertSpriteSheetPalette(paletteName: string) {\n    assertSpriteSheetPalette(this, paletteName);\n  }\n  assertSpriteSheetPaletteSwap(paletteSwapName: string) {\n    assertSpriteSheetPaletteSwap(this, paletteSwapName);\n  }\n  assertSpritePaletteSwap(spriteName: string, paletteSwapName: string) {\n    assertSpritePaletteSwap(this, spriteName, paletteSwapName);\n  }\n  async selectSpriteSheetPalette(\n    paletteName: string,\n    offset?: number,\n    indicesOnly?: boolean,\n    sendImmediately?: boolean\n  ) {\n    await selectSpriteSheetPalette(\n      this,\n      paletteName,\n      offset,\n      indicesOnly,\n      sendImmediately\n    );\n  }\n  async selectSpriteSheetPaletteSwap(\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpriteSheetPaletteSwap(\n      this,\n      paletteSwapName,\n      offset,\n      sendImmediately\n    );\n  }\n  async selectSpritePaletteSwap(\n    spriteName: string,\n    paletteSwapName: string,\n    offset?: number,\n    sendImmediately?: boolean\n  ) {\n    await selectSpritePaletteSwap(\n      this,\n      spriteName,\n      paletteSwapName,\n      offset,\n      sendImmediately\n    );\n  }\n\n  #reset() {\n    this.#setIsDrawingSprite(false, true);\n    this.#setIgnoreDevice(false, true);\n    this.#resetColors();\n    this.#resetOpacities();\n    this.#resetContextState();\n    this.#resetBrightness();\n    Object.keys(this.#spriteSheets).forEach(\n      (spriteSheetName) => delete this.#spriteSheets[spriteSheetName]\n    );\n    Object.keys(this.#spriteSheetIndices).forEach(\n      (spriteSheetName) => delete this.#spriteSheetIndices[spriteSheetName]\n    );\n    this.#isDrawingBlankSprite = false;\n  }\n\n  async imageToBitmap(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors?: number\n  ) {\n    return imageToBitmap(\n      image,\n      width,\n      height,\n      this.colors,\n      this.bitmapColorIndices,\n      numberOfColors\n    );\n  }\n  async quantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number\n  ) {\n    return quantizeImage(image, width, height, numberOfColors);\n  }\n\n  async resizeAndQuantizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number,\n    numberOfColors: number,\n    colors?: string[]\n  ) {\n    return resizeAndQuantizeImage(image, width, height, numberOfColors, colors);\n  }\n\n  serializeSpriteSheet(spriteSheet: DisplaySpriteSheet): ArrayBuffer {\n    return serializeSpriteSheet(this, spriteSheet);\n  }\n\n  #startSprite(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    contextState: DisplayContextState\n  ) {\n    //this.#setIgnoreDevice(true);\n    this.#saveContextForSprite(\n      offsetX,\n      offsetY,\n      { width, height },\n      contextState\n    );\n    this.#setIsDrawingSprite(true);\n\n    this.#blankSpriteColorIndices =\n      this.contextState.spriteColorIndices.slice();\n    _console.log(\"#blankSpriteColorIndices\", this.#blankSpriteColorIndices);\n  }\n  #isDrawingSprite = false;\n  #isDrawingSpriteCounter = 0;\n  #setIsDrawingSprite(newIsDrawingSprite: boolean, override = false) {\n    if (override) {\n      this.#isDrawingSpriteCounter = newIsDrawingSprite ? 1 : 0;\n    } else {\n      this.#isDrawingSpriteCounter += newIsDrawingSprite ? 1 : -1;\n      this.#isDrawingSpriteCounter = Math.max(0, this.#isDrawingSpriteCounter);\n      _console.log({\n        isDrawingSpriteCounter: this.#isDrawingSpriteCounter,\n      });\n    }\n    const isDrawingSprite = this.#isDrawingSpriteCounter > 0;\n    this.#isDrawingSprite = isDrawingSprite;\n    _console.log({\n      isDrawingSprite,\n    });\n    this.#rearDrawStack.push(() => {\n      //_console.log({ isDrawingSprite });\n      this.#isDrawingSprite = isDrawingSprite;\n    });\n  }\n  #isDrawingBlankSprite = false;\n  #blankSpriteColorIndices?: number[];\n  async startSprite(\n    offsetX: number,\n    offsetY: number,\n    width: number,\n    height: number,\n    sendImmediately?: boolean\n  ) {\n    _console.assertWithError(\n      !this.#isDrawingBlankSprite,\n      `already drawing blank sprite`\n    );\n    this.#isDrawingBlankSprite = true;\n\n    const contextState = structuredClone(this.contextState);\n    this.#startSprite(offsetX, offsetY, width, height, contextState);\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.startSprite(\n        offsetX,\n        offsetY,\n        width,\n        height,\n        sendImmediately\n      );\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n  #endSprite() {\n    this.#restoreContextForSprite();\n    this.#blankSpriteColorIndices = undefined;\n    this.#setIsDrawingSprite(false);\n    this.#setIgnoreDevice(false);\n  }\n  async endSprite(sendImmediately?: boolean) {\n    _console.assertWithError(\n      this.#isDrawingBlankSprite,\n      `not drawing blank sprite`\n    );\n    this.#isDrawingBlankSprite = false;\n\n    this.#endSprite();\n\n    if (this.device?.isConnected && !this.#ignoreDevice) {\n      await this.deviceDisplayManager!.endSprite(sendImmediately);\n    } else {\n      if (sendImmediately) {\n        this.#onSentContextCommands();\n      }\n    }\n  }\n}\nexport default DisplayCanvasHelper;\n","import { createConsole } from \"../utils/Console.ts\";\nimport CenterOfPressureHelper from \"../utils/CenterOfPressureHelper.ts\";\nimport {\n  PressureData,\n  PressureSensorPosition,\n  PressureSensorValue,\n} from \"../sensor/PressureSensorDataManager.ts\";\nimport { CenterOfPressure } from \"../utils/CenterOfPressureHelper.ts\";\nimport { Side, Sides } from \"../InformationManager.ts\";\nimport { DeviceEventMap } from \"../Device.ts\";\nimport { RangeHelper } from \"../BS.ts\";\n\nconst _console = createConsole(\"DevicePairPressureSensorDataManager\", {\n  log: false,\n});\n\nexport type DevicePairRawPressureData = { [side in Side]: PressureData };\n\nexport interface DevicePairPressureData {\n  sensors: { [key in Side]: PressureSensorValue[] };\n  scaledSum: number;\n  normalizedSum: number;\n  center?: CenterOfPressure;\n  normalizedCenter?: CenterOfPressure;\n}\n\nexport interface DevicePairPressureDataEventMessage {\n  pressure: DevicePairPressureData;\n}\n\nexport interface DevicePairPressureDataEventMessages {\n  pressure: DevicePairPressureDataEventMessage;\n}\n\nclass DevicePairPressureSensorDataManager {\n  #rawPressure: Partial<DevicePairRawPressureData> = {};\n\n  #centerOfPressureHelper = new CenterOfPressureHelper();\n\n  #normalizedSumRangeHelper = new RangeHelper();\n\n  constructor() {\n    this.resetPressureRange();\n  }\n\n  resetPressureRange() {\n    this.#centerOfPressureHelper.reset();\n    this.#normalizedSumRangeHelper.reset();\n  }\n\n  onDevicePressureData(event: DeviceEventMap[\"pressure\"]) {\n    const { pressure } = event.message;\n    const { side } = event.target;\n    _console.log({ pressure, side });\n    this.#rawPressure[side] = pressure;\n    if (this.#hasAllPressureData) {\n      return this.#updatePressureData();\n    } else {\n      _console.log(\"doesn't have all pressure data yet...\");\n    }\n  }\n\n  get #hasAllPressureData() {\n    return Sides.every((side) => side in this.#rawPressure);\n  }\n\n  #updatePressureData() {\n    const pressure: DevicePairPressureData = {\n      scaledSum: 0,\n      normalizedSum: 0,\n      sensors: { left: [], right: [] },\n    };\n\n    Sides.forEach((side) => {\n      const sidePressure = this.#rawPressure[side]!;\n      pressure.scaledSum += sidePressure.scaledSum;\n      //pressure.normalizedSum += this.#rawPressure[side]!.normalizedSum;\n    });\n    pressure.normalizedSum +=\n      this.#normalizedSumRangeHelper.updateAndGetNormalization(\n        pressure.scaledSum,\n        false\n      );\n\n    if (pressure.scaledSum > 0) {\n      pressure.center = { x: 0, y: 0 };\n      Sides.forEach((side) => {\n        const sidePressure = this.#rawPressure[side]!;\n\n        if (false) {\n          const sidePressureWeight =\n            sidePressure.scaledSum / pressure.scaledSum;\n          if (sidePressureWeight > 0) {\n            if (sidePressure.normalizedCenter?.y != undefined) {\n              pressure.center!.y +=\n                sidePressure.normalizedCenter!.y * sidePressureWeight;\n            }\n            if (side == \"right\") {\n              pressure.center!.x = sidePressureWeight;\n            }\n          }\n        } else {\n          sidePressure.sensors.forEach((sensor) => {\n            const _sensor: PressureSensorValue = structuredClone(sensor);\n            _sensor.weightedValue = sensor.scaledValue / pressure.scaledSum;\n            let { x, y } = sensor.position;\n            x /= 2;\n            if (side == \"right\") {\n              x += 0.5;\n            }\n            _sensor.position = { x, y };\n            pressure.center!.x += _sensor.position.x * _sensor.weightedValue;\n            pressure.center!.y += _sensor.position.y * _sensor.weightedValue;\n            pressure.sensors[side].push(_sensor);\n          });\n        }\n      });\n\n      pressure.normalizedCenter =\n        this.#centerOfPressureHelper.updateAndGetNormalization(\n          pressure.center,\n          false\n        );\n    }\n\n    _console.log({ devicePairPressure: pressure });\n\n    return pressure;\n  }\n}\n\nexport default DevicePairPressureSensorDataManager;\n","import DevicePairPressureSensorDataManager, {\n  DevicePairPressureDataEventMessages,\n} from \"./DevicePairPressureSensorDataManager.ts\";\nimport { createConsole } from \"../utils/Console.ts\";\nimport { Side } from \"../InformationManager.ts\";\nimport { SensorType } from \"../sensor/SensorDataManager.ts\";\nimport { DeviceEventMap } from \"../Device.ts\";\nimport EventDispatcher from \"../utils/EventDispatcher.ts\";\nimport DevicePair from \"./DevicePair.ts\";\nimport { AddKeysAsPropertyToInterface, ExtendInterfaceValues, ValueOf } from \"../utils/TypeScriptUtils.ts\";\n\nconst _console = createConsole(\"DevicePairSensorDataManager\", { log: false });\n\nexport const DevicePairSensorTypes = [\"pressure\", \"sensorData\"] as const;\nexport type DevicePairSensorType = (typeof DevicePairSensorTypes)[number];\n\nexport const DevicePairSensorDataEventTypes = DevicePairSensorTypes;\nexport type DevicePairSensorDataEventType = (typeof DevicePairSensorDataEventTypes)[number];\n\nexport type DevicePairSensorDataTimestamps = { [side in Side]: number };\n\ninterface BaseDevicePairSensorDataEventMessage {\n  timestamps: DevicePairSensorDataTimestamps;\n}\n\ntype BaseDevicePairSensorDataEventMessages = DevicePairPressureDataEventMessages;\ntype _DevicePairSensorDataEventMessages = ExtendInterfaceValues<\n  AddKeysAsPropertyToInterface<BaseDevicePairSensorDataEventMessages, \"sensorType\">,\n  BaseDevicePairSensorDataEventMessage\n>;\n\nexport type DevicePairSensorDataEventMessage = ValueOf<_DevicePairSensorDataEventMessages>;\ninterface AnyDevicePairSensorDataEventMessages {\n  sensorData: DevicePairSensorDataEventMessage;\n}\nexport type DevicePairSensorDataEventMessages = _DevicePairSensorDataEventMessages &\n  AnyDevicePairSensorDataEventMessages;\n\nexport type DevicePairSensorDataEventDispatcher = EventDispatcher<\n  DevicePair,\n  DevicePairSensorDataEventType,\n  DevicePairSensorDataEventMessages\n>;\n\nclass DevicePairSensorDataManager {\n  eventDispatcher!: DevicePairSensorDataEventDispatcher;\n  get dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  #timestamps: { [sensorType in SensorType]?: Partial<DevicePairSensorDataTimestamps> } = {};\n\n  pressureSensorDataManager = new DevicePairPressureSensorDataManager();\n  resetPressureRange() {\n    this.pressureSensorDataManager.resetPressureRange();\n  }\n\n  onDeviceSensorData(event: DeviceEventMap[\"sensorData\"]) {\n    const { timestamp, sensorType } = event.message;\n\n    _console.log({ sensorType, timestamp, event });\n\n    if (!this.#timestamps[sensorType]) {\n      this.#timestamps[sensorType] = {};\n    }\n    this.#timestamps[sensorType]![event.target.side] = timestamp;\n\n    let value;\n    switch (sensorType) {\n      case \"pressure\":\n        value = this.pressureSensorDataManager.onDevicePressureData(event as unknown as DeviceEventMap[\"pressure\"]);\n        break;\n      default:\n        _console.log(`uncaught sensorType \"${sensorType}\"`);\n        break;\n    }\n\n    if (value) {\n      const timestamps = Object.assign({}, this.#timestamps[sensorType]) as DevicePairSensorDataTimestamps;\n      // @ts-expect-error\n      this.dispatchEvent(sensorType as DevicePairSensorDataEventType, { sensorType, timestamps, [sensorType]: value });\n      // @ts-expect-error\n      this.dispatchEvent(\"sensorData\", { sensorType, timestamps, [sensorType]: value });\n    } else {\n      _console.log(\"no value received\");\n    }\n  }\n}\n\nexport default DevicePairSensorDataManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n  EventListenerMap,\n  EventMap,\n} from \"../utils/EventDispatcher.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../utils/EventUtils.ts\";\nimport Device, {\n  DeviceEvent,\n  DeviceEventType,\n  DeviceEventMessages,\n  DeviceEventTypes,\n  BoundDeviceEventListeners,\n  DeviceEventMap,\n} from \"../Device.ts\";\nimport DevicePairSensorDataManager, {\n  DevicePairSensorDataEventDispatcher,\n} from \"./DevicePairSensorDataManager.ts\";\nimport { capitalizeFirstCharacter } from \"../utils/stringUtils.ts\";\nimport { Side, Sides } from \"../InformationManager.ts\";\nimport { VibrationConfiguration } from \"../vibration/VibrationManager.ts\";\nimport { SensorConfiguration } from \"../sensor/SensorConfigurationManager.ts\";\nimport {\n  DevicePairSensorDataEventMessages,\n  DevicePairSensorDataEventTypes,\n} from \"./DevicePairSensorDataManager.ts\";\nimport {\n  AddPrefixToInterfaceKeys,\n  ExtendInterfaceValues,\n  KeyOf,\n} from \"../utils/TypeScriptUtils.ts\";\nimport DeviceManager from \"../DeviceManager.ts\";\n\nconst _console = createConsole(\"DevicePair\", { log: false });\n\ninterface BaseDevicePairDeviceEventMessage {\n  device: Device;\n  side: Side;\n}\ntype DevicePairDeviceEventMessages = ExtendInterfaceValues<\n  AddPrefixToInterfaceKeys<DeviceEventMessages, \"device\">,\n  BaseDevicePairDeviceEventMessage\n>;\ntype DevicePairDeviceEventType = KeyOf<DevicePairDeviceEventMessages>;\nfunction getDevicePairDeviceEventType(deviceEventType: DeviceEventType) {\n  return `device${capitalizeFirstCharacter(\n    deviceEventType\n  )}` as DevicePairDeviceEventType;\n}\nconst DevicePairDeviceEventTypes = DeviceEventTypes.map((eventType) =>\n  getDevicePairDeviceEventType(eventType)\n) as DevicePairDeviceEventType[];\n\nexport const DevicePairConnectionEventTypes = [\"isConnected\"] as const;\nexport type DevicePairConnectionEventType =\n  (typeof DevicePairConnectionEventTypes)[number];\n\nexport interface DevicePairConnectionEventMessages {\n  isConnected: { isConnected: boolean };\n}\n\nexport const DevicePairEventTypes = [\n  ...DevicePairConnectionEventTypes,\n  ...DevicePairSensorDataEventTypes,\n  ...DevicePairDeviceEventTypes,\n] as const;\nexport type DevicePairEventType = (typeof DevicePairEventTypes)[number];\n\nexport type DevicePairEventMessages = DevicePairConnectionEventMessages &\n  DevicePairSensorDataEventMessages &\n  DevicePairDeviceEventMessages;\n\nexport type DevicePairEventDispatcher = EventDispatcher<\n  DevicePair,\n  DevicePairEventType,\n  DevicePairEventMessages\n>;\nexport type DevicePairEventMap = EventMap<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\nexport type DevicePairEventListenerMap = EventListenerMap<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\nexport type DevicePairEvent = Event<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\nexport type BoundDevicePairEventListeners = BoundEventListeners<\n  DevicePair,\n  DeviceEventType,\n  DevicePairEventMessages\n>;\n\nexport const DevicePairTypes = [\"insoles\", \"gloves\"] as const;\nexport type DevicePairType = (typeof DevicePairTypes)[number];\n\nclass DevicePair {\n  constructor(type: DevicePairType) {\n    this.#type = type;\n    this.#sensorDataManager.eventDispatcher = this\n      .#eventDispatcher as DevicePairSensorDataEventDispatcher;\n  }\n\n  get sides() {\n    return Sides;\n  }\n\n  #type: DevicePairType;\n  get type() {\n    return this.#type;\n  }\n\n  #eventDispatcher: DevicePairEventDispatcher = new EventDispatcher(\n    this as DevicePair,\n    DevicePairEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // SIDES\n  #left?: Device;\n  get left() {\n    return this.#left;\n  }\n\n  #right?: Device;\n  get right() {\n    return this.#right;\n  }\n\n  get isConnected() {\n    return Sides.every((side) => this[side]?.isConnected);\n  }\n  get isPartiallyConnected() {\n    return Sides.some((side) => this[side]?.isConnected);\n  }\n  get isHalfConnected() {\n    return this.isPartiallyConnected && !this.isConnected;\n  }\n  #assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"devicePair must be connected\");\n  }\n\n  #isDeviceCorrectType(device: Device) {\n    switch (this.type) {\n      case \"insoles\":\n        return device.isInsole;\n      case \"gloves\":\n        return device.isGlove;\n    }\n  }\n\n  assignDevice(device: Device) {\n    if (!this.#isDeviceCorrectType(device)) {\n      _console.log(\n        `device is incorrect type ${device.type} for ${this.type} devicePair`\n      );\n      return;\n    }\n    const side = device.side;\n\n    const currentDevice = this[side];\n\n    if (device == currentDevice) {\n      _console.log(\"device already assigned\");\n      return;\n    }\n\n    if (currentDevice) {\n      this.#removeDeviceEventListeners(currentDevice);\n    }\n    this.#addDeviceEventListeners(device);\n\n    switch (side) {\n      case \"left\":\n        this.#left = device;\n        break;\n      case \"right\":\n        this.#right = device;\n        break;\n    }\n\n    _console.log(`assigned ${side} ${this.type} device`, device);\n\n    this.resetPressureRange();\n\n    this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    this.#dispatchEvent(\"deviceIsConnected\", {\n      device,\n      isConnected: device.isConnected,\n      side,\n    });\n\n    return currentDevice;\n  }\n\n  #addDeviceEventListeners(device: Device) {\n    addEventListeners(device, this.#boundDeviceEventListeners);\n    DeviceEventTypes.forEach((deviceEventType) => {\n      device.addEventListener(\n        // @ts-expect-error\n        deviceEventType,\n        this.#redispatchDeviceEvent.bind(this)\n      );\n    });\n  }\n  #removeDeviceEventListeners(device: Device) {\n    removeEventListeners(device, this.#boundDeviceEventListeners);\n    DeviceEventTypes.forEach((deviceEventType) => {\n      device.removeEventListener(\n        // @ts-expect-error\n        deviceEventType,\n        this.#redispatchDeviceEvent.bind(this)\n      );\n    });\n  }\n\n  #removeDevice(device: Device) {\n    const foundDevice = Sides.some((side) => {\n      if (this[side] != device) {\n        return false;\n      }\n\n      _console.log(`removing ${side} ${this.type} device`, device);\n      removeEventListeners(device, this.#boundDeviceEventListeners);\n\n      switch (side) {\n        case \"left\":\n          this.#left = undefined;\n          break;\n        case \"right\":\n          this.#right = undefined;\n          break;\n      }\n\n      return true;\n    });\n    if (foundDevice) {\n      this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    }\n    return foundDevice;\n  }\n\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    isConnected: this.#onDeviceIsConnected.bind(this),\n    sensorData: this.#onDeviceSensorData.bind(this),\n    getType: this.#onDeviceType.bind(this),\n  };\n\n  #redispatchDeviceEvent(deviceEvent: DeviceEvent) {\n    const { type, target: device, message } = deviceEvent;\n    // @ts-ignore\n    this.#dispatchEvent(getDevicePairDeviceEventType(type), {\n      ...message,\n      device,\n      side: device.side,\n    });\n  }\n\n  #onDeviceIsConnected(deviceEvent: DeviceEventMap[\"isConnected\"]) {\n    this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n  }\n\n  #onDeviceType(deviceEvent: DeviceEventMap[\"getType\"]) {\n    const { target: device } = deviceEvent;\n    if (this[device.side] == device) {\n      return;\n    }\n    const foundDevice = this.#removeDevice(device);\n    if (!foundDevice) {\n      return;\n    }\n    this.assignDevice(device);\n  }\n\n  // SENSOR CONFIGURATION\n  async setSensorConfiguration(sensorConfiguration: SensorConfiguration) {\n    for (let i = 0; i < Sides.length; i++) {\n      const side = Sides[i];\n      if (this[side]?.isConnected) {\n        await this[side].setSensorConfiguration(sensorConfiguration);\n      }\n    }\n  }\n\n  // SENSOR DATA\n  #sensorDataManager = new DevicePairSensorDataManager();\n  #onDeviceSensorData(deviceEvent: DeviceEventMap[\"sensorData\"]) {\n    if (this.isConnected) {\n      this.#sensorDataManager.onDeviceSensorData(deviceEvent);\n    }\n  }\n  resetPressureRange() {\n    Sides.forEach((side) => this[side]?.resetPressureRange());\n    this.#sensorDataManager.resetPressureRange();\n  }\n\n  // VIBRATION\n  async triggerVibration(\n    vibrationConfigurations: VibrationConfiguration[],\n    sendImmediately?: boolean\n  ) {\n    const promises = Sides.map((side) => {\n      return this[side]?.triggerVibration(\n        vibrationConfigurations,\n        sendImmediately\n      );\n    }).filter(Boolean);\n    return Promise.allSettled(promises);\n  }\n\n  // SHARED INSTANCES\n  static #insoles = new DevicePair(\"insoles\");\n  static get insoles() {\n    return this.#insoles;\n  }\n  static #gloves = new DevicePair(\"gloves\");\n  static get gloves() {\n    return this.#gloves;\n  }\n  static {\n    DeviceManager.AddEventListener(\"deviceConnected\", (event) => {\n      const { device } = event.message;\n      if (device.isInsole) {\n        this.#insoles.assignDevice(device);\n      }\n      if (device.isGlove) {\n        this.#gloves.assignDevice(device);\n      }\n    });\n  }\n}\n\nexport default DevicePair;\n","import { createConsole } from \"../utils/Console.ts\";\nimport { isInBrowser } from \"../utils/environment.ts\";\nimport BaseConnectionManager, {\n  ConnectionType,\n  ConnectionMessageType,\n  ClientConnectionType,\n} from \"./BaseConnectionManager.ts\";\nimport { DeviceEventTypes } from \"../Device.ts\";\nimport { parseMessage } from \"../utils/ParseUtils.ts\";\nimport { DeviceInformationTypes } from \"../DeviceInformationManager.ts\";\nimport { DeviceEventType } from \"../Device.ts\";\nimport { ClientDeviceMessage } from \"../server/ServerUtils.ts\";\nimport BaseClient from \"../server/BaseClient.ts\";\nimport { DiscoveredDevice } from \"../BS.ts\";\n\nconst _console = createConsole(\"ClientConnectionManager\", { log: false });\n\nexport type SendClientMessageCallback = (\n  ...messages: ClientDeviceMessage[]\n) => void;\n\nexport type SendClientConnectMessageCallback = (\n  connectionType?: ClientConnectionType\n) => void;\n\nconst ClientDeviceInformationMessageTypes: ConnectionMessageType[] = [\n  ...DeviceInformationTypes,\n  \"batteryLevel\",\n];\n\nclass ClientConnectionManager extends BaseConnectionManager {\n  static get isSupported() {\n    return isInBrowser;\n  }\n  static get type(): ConnectionType {\n    return \"client\";\n  }\n\n  subType?: ClientConnectionType;\n\n  get canUpdateFirmware() {\n    // FIX - how to know if it has an smp characteristic?\n    return false;\n  }\n\n  client!: BaseClient;\n  discoveredDevice!: DiscoveredDevice;\n\n  #bluetoothId!: string;\n  get bluetoothId() {\n    return this.#bluetoothId!;\n  }\n  set bluetoothId(newBluetoothId) {\n    _console.assertTypeWithError(newBluetoothId, \"string\");\n    if (this.#bluetoothId == newBluetoothId) {\n      _console.log(\"redundant bluetoothId assignment\");\n      return;\n    }\n    this.#bluetoothId = newBluetoothId;\n  }\n\n  #isConnected = false;\n  get isConnected() {\n    return this.#isConnected;\n  }\n  set isConnected(newIsConnected) {\n    _console.assertTypeWithError(newIsConnected, \"boolean\");\n    // if (this.#isConnected == newIsConnected) {\n    //   _console.log(\"redundant newIsConnected assignment\", newIsConnected);\n    //   return;\n    // }\n    this.#isConnected = newIsConnected;\n\n    this.status = this.#isConnected ? \"connected\" : \"notConnected\";\n\n    if (this.isConnected) {\n      this.#requestDeviceInformation();\n    }\n  }\n\n  get isAvailable() {\n    return this.client.isConnected;\n  }\n\n  async connect() {\n    const canContinue = await super.connect();\n    if (!canContinue) {\n      return false;\n    }\n    this.sendClientConnectMessage(this.subType);\n    return true;\n  }\n  async disconnect() {\n    const canContinue = await super.disconnect();\n    if (!canContinue) {\n      return false;\n    }\n    this.sendClientDisconnectMessage();\n    return true;\n  }\n\n  get canReconnect() {\n    return true;\n  }\n  async reconnect() {\n    const canContinue = await super.reconnect();\n    if (!canContinue) {\n      return false;\n    }\n    this.sendClientConnectMessage();\n    return true;\n  }\n\n  sendClientMessage!: SendClientMessageCallback;\n  sendClientConnectMessage!: SendClientConnectMessageCallback;\n  sendClientDisconnectMessage!: Function;\n  sendRequiredDeviceInformationMessage!: Function;\n\n  async sendSmpMessage(data: ArrayBuffer) {\n    super.sendSmpMessage(data);\n    this.sendClientMessage({ type: \"smp\", data });\n  }\n\n  async sendTxData(data: ArrayBuffer) {\n    super.sendTxData(data);\n    if (data.byteLength == 0) {\n      return;\n    }\n    this.sendClientMessage({ type: \"tx\", data });\n  }\n\n  #requestDeviceInformation() {\n    //this.sendClientMessage(...ClientDeviceInformationMessageTypes);\n    this.sendRequiredDeviceInformationMessage();\n  }\n\n  onClientMessage(dataView: DataView<ArrayBuffer>) {\n    _console.log({ dataView });\n    parseMessage(\n      dataView,\n      DeviceEventTypes,\n      this.#onClientMessageCallback.bind(this),\n      null,\n      true\n    );\n    this.onMessagesReceived!();\n  }\n\n  #onClientMessageCallback(\n    messageType: DeviceEventType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    let byteOffset = 0;\n\n    _console.log({ messageType }, dataView);\n\n    switch (messageType) {\n      case \"isConnected\":\n        const isConnected = Boolean(dataView.getUint8(byteOffset++));\n        _console.log({ isConnected });\n        this.isConnected = isConnected;\n        break;\n\n      case \"rx\":\n        this.parseRxMessage(dataView);\n        break;\n\n      default:\n        this.onMessageReceived!(messageType as ConnectionMessageType, dataView);\n        break;\n    }\n  }\n}\n\nexport default ClientConnectionManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport {\n  ServerMessageTypes,\n  ServerMessage,\n  ClientDeviceMessage,\n  createClientDeviceMessage,\n  ServerMessageType,\n} from \"./ServerUtils.ts\";\nimport { parseMessage, parseStringFromDataView } from \"../utils/ParseUtils.ts\";\nimport EventDispatcher, {\n  BoundEventListeners,\n  Event,\n} from \"../utils/EventDispatcher.ts\";\nimport Device from \"../Device.ts\";\nimport {\n  concatenateArrayBuffers,\n  sliceDataView,\n  stringToArrayBuffer,\n} from \"../utils/ArrayBufferUtils.ts\";\nimport {\n  DiscoveredDevice,\n  DiscoveredDevicesMap,\n  ScannerEventMessages,\n} from \"../scanner/BaseScanner.ts\";\nimport ClientConnectionManager from \"../connection/ClientConnectionManager.ts\";\nimport { DeviceManager } from \"../BS.ts\";\nimport {\n  ClientConnectionType,\n  ConnectionTypes,\n} from \"../connection/BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"BaseClient\", { log: false });\n\nexport const ClientConnectionStatuses = [\n  \"notConnected\",\n  \"connecting\",\n  \"connected\",\n  \"disconnecting\",\n] as const;\nexport type ClientConnectionStatus = (typeof ClientConnectionStatuses)[number];\n\nexport const ClientEventTypes = [\n  ...ClientConnectionStatuses,\n  \"connectionStatus\",\n  \"isConnected\",\n  \"isScanningAvailable\",\n  \"isScanning\",\n  \"discoveredDevice\",\n  \"expiredDiscoveredDevice\",\n] as const;\nexport type ClientEventType = (typeof ClientEventTypes)[number];\n\ninterface ClientConnectionEventMessages {\n  connectionStatus: { connectionStatus: ClientConnectionStatus };\n  isConnected: { isConnected: boolean };\n}\n\nexport type ClientEventMessages = ClientConnectionEventMessages &\n  ScannerEventMessages;\n\nexport type ClientEventDispatcher = EventDispatcher<\n  BaseClient,\n  ClientEventType,\n  ClientEventMessages\n>;\nexport type ClientEvent = Event<\n  BaseClient,\n  ClientEventType,\n  ClientEventMessages\n>;\nexport type BoundClientEventListeners = BoundEventListeners<\n  BaseClient,\n  ClientEventType,\n  ClientEventMessages\n>;\n\nexport type ServerURL = string | URL;\n\ntype DevicesMap = { [deviceId: string]: Device };\n\nabstract class BaseClient {\n  protected get baseConstructor() {\n    return this.constructor as typeof BaseClient;\n  }\n\n  #reset() {\n    this.#isScanningAvailable = false;\n    this.#isScanning = false;\n    for (const id in this.#devices) {\n      const device = this.#devices[id];\n      const connectionManager =\n        device.connectionManager! as ClientConnectionManager;\n      connectionManager.isConnected = false;\n      // device.removeAllEventListeners();\n    }\n    this.#receivedMessageTypes.length = 0;\n    //this.#devices = {};\n  }\n\n  // DEVICES\n  #devices: DevicesMap = {};\n  get devices(): Readonly<DevicesMap> {\n    return this.#devices;\n  }\n\n  #eventDispatcher: ClientEventDispatcher = new EventDispatcher(\n    this as BaseClient,\n    ClientEventTypes\n  );\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  protected get dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n\n  abstract isConnected: boolean;\n  protected assertConnection() {\n    _console.assertWithError(this.isConnected, \"notConnected\");\n  }\n\n  abstract isDisconnected: boolean;\n  protected assertDisconnection() {\n    _console.assertWithError(this.isDisconnected, \"not disconnected\");\n  }\n\n  abstract connect(): void;\n  abstract disconnect(): void;\n  abstract reconnect(): void;\n  abstract toggleConnection(url?: ServerURL): void;\n\n  private static _reconnectOnDisconnection = true;\n  static get ReconnectOnDisconnection() {\n    return this._reconnectOnDisconnection;\n  }\n  static set ReconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this._reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  protected _reconnectOnDisconnection =\n    this.baseConstructor.ReconnectOnDisconnection;\n  get reconnectOnDisconnection() {\n    return this._reconnectOnDisconnection;\n  }\n  set reconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this._reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  abstract sendServerMessage(...messages: ServerMessage[]): void;\n\n  // CONNECTION STATUS\n  #_connectionStatus: ClientConnectionStatus = \"notConnected\";\n  protected get _connectionStatus() {\n    return this.#_connectionStatus;\n  }\n  protected set _connectionStatus(newConnectionStatus) {\n    _console.assertTypeWithError(newConnectionStatus, \"string\");\n    _console.log({ newConnectionStatus });\n    this.#_connectionStatus = newConnectionStatus;\n\n    this.dispatchEvent(\"connectionStatus\", {\n      connectionStatus: this.connectionStatus,\n    });\n    this.dispatchEvent(this.connectionStatus, {});\n\n    switch (newConnectionStatus) {\n      case \"connected\":\n      case \"notConnected\":\n        this.dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n        if (this.isConnected) {\n          // this._sendRequiredMessages();\n        } else {\n          this.#reset();\n        }\n        break;\n    }\n  }\n  get connectionStatus() {\n    return this._connectionStatus;\n  }\n\n  static #RequiredMessageTypes: ServerMessage[] = [\n    \"isScanningAvailable\",\n    \"discoveredDevices\",\n    \"connectedDevices\",\n  ];\n  get #requiredMessageTypes(): ServerMessage[] {\n    return BaseClient.#RequiredMessageTypes;\n  }\n  protected _sendRequiredMessages() {\n    _console.log(\"sending required messages\", this.#receivedMessageTypes);\n    this.sendServerMessage(...this.#requiredMessageTypes);\n  }\n\n  #receivedMessageTypes: ServerMessage[] = [];\n  #checkIfFullyConnected() {\n    if (this.connectionStatus != \"connecting\") {\n      return;\n    }\n    _console.log(\"checking if fully connected...\");\n\n    if (!this.#receivedMessageTypes.includes(\"isScanningAvailable\")) {\n      _console.log(\"not fully connected - didn't receive isScanningAvailable\");\n      return;\n    }\n\n    if (this.isScanningAvailable) {\n      if (!this.#receivedMessageTypes.includes(\"isScanning\")) {\n        _console.log(\"not fully connected - didn't receive isScanning\");\n        return;\n      }\n    }\n\n    _console.log(\"fully connected\");\n    this._connectionStatus = \"connected\";\n  }\n\n  protected parseMessage(dataView: DataView<ArrayBuffer>) {\n    _console.log(\"parseMessage\", { dataView });\n    parseMessage(\n      dataView,\n      ServerMessageTypes,\n      this.#parseMessageCallback.bind(this),\n      null,\n      true\n    );\n    this.#checkIfFullyConnected();\n  }\n\n  #parseMessageCallback(\n    messageType: ServerMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    let byteOffset = 0;\n\n    _console.log({ messageType }, dataView);\n\n    switch (messageType) {\n      case \"isScanningAvailable\":\n        {\n          const isScanningAvailable = Boolean(dataView.getUint8(byteOffset++));\n          _console.log({ isScanningAvailable });\n          this.#isScanningAvailable = isScanningAvailable;\n        }\n        break;\n      case \"isScanning\":\n        {\n          const isScanning = Boolean(dataView.getUint8(byteOffset++));\n          _console.log({ isScanning });\n          this.#isScanning = isScanning;\n        }\n        break;\n      case \"discoveredDevice\":\n        {\n          const { string: discoveredDeviceString } = parseStringFromDataView(\n            dataView,\n            byteOffset\n          );\n          _console.log({ discoveredDeviceString });\n\n          const discoveredDevice: DiscoveredDevice = JSON.parse(\n            discoveredDeviceString\n          );\n          _console.log({ discoveredDevice });\n\n          this.onDiscoveredDevice(discoveredDevice);\n        }\n        break;\n      case \"expiredDiscoveredDevice\":\n        {\n          const { string: bluetoothId } = parseStringFromDataView(\n            dataView,\n            byteOffset\n          );\n          this.#onExpiredDiscoveredDevice(bluetoothId);\n        }\n        break;\n      case \"connectedDevices\":\n        {\n          if (dataView.byteLength == 0) {\n            break;\n          }\n          const { string: connectedBluetoothDeviceIdStrings } =\n            parseStringFromDataView(dataView, byteOffset);\n          _console.log({ connectedBluetoothDeviceIdStrings });\n          const connectedBluetoothDeviceIds = JSON.parse(\n            connectedBluetoothDeviceIdStrings\n          ).connectedDevices;\n          _console.log({ connectedBluetoothDeviceIds });\n          this.onConnectedBluetoothDeviceIds(connectedBluetoothDeviceIds);\n        }\n        break;\n      case \"deviceMessage\":\n        {\n          const { string: bluetoothId, byteOffset: _byteOffset } =\n            parseStringFromDataView(dataView, byteOffset);\n          byteOffset = _byteOffset;\n          const device = this.#devices[bluetoothId];\n          _console.assertWithError(\n            device,\n            `no device found for id ${bluetoothId}`\n          );\n          const connectionManager =\n            device.connectionManager! as ClientConnectionManager;\n          const _dataView = sliceDataView(dataView, byteOffset);\n          connectionManager.onClientMessage(_dataView);\n        }\n        break;\n      default:\n        _console.error(`uncaught messageType \"${messageType}\"`);\n        break;\n    }\n\n    if (this.connectionStatus == \"connecting\") {\n      this.#receivedMessageTypes.push(messageType);\n    }\n  }\n\n  // SCANNING\n  #_isScanningAvailable = false;\n  get #isScanningAvailable() {\n    return this.#_isScanningAvailable;\n  }\n  set #isScanningAvailable(newIsAvailable) {\n    _console.assertTypeWithError(newIsAvailable, \"boolean\");\n    this.#_isScanningAvailable = newIsAvailable;\n    this.dispatchEvent(\"isScanningAvailable\", {\n      isScanningAvailable: this.isScanningAvailable,\n    });\n    if (this.isScanningAvailable) {\n      this.#requestIsScanning();\n    }\n  }\n  get isScanningAvailable() {\n    return this.#isScanningAvailable;\n  }\n  #assertIsScanningAvailable() {\n    this.assertConnection();\n    _console.assertWithError(\n      this.isScanningAvailable,\n      \"scanning is not available\"\n    );\n  }\n  protected requestIsScanningAvailable() {\n    this.sendServerMessage(\"isScanningAvailable\");\n  }\n\n  #_isScanning = false;\n  get #isScanning() {\n    return this.#_isScanning;\n  }\n  set #isScanning(newIsScanning) {\n    _console.assertTypeWithError(newIsScanning, \"boolean\");\n    this.#_isScanning = newIsScanning;\n    this.dispatchEvent(\"isScanning\", { isScanning: this.isScanning });\n  }\n  get isScanning() {\n    return this.#isScanning;\n  }\n  #requestIsScanning() {\n    this.sendServerMessage(\"isScanning\");\n  }\n\n  #assertIsScanning() {\n    _console.assertWithError(this.isScanning, \"is not scanning\");\n  }\n  #assertIsNotScanning() {\n    _console.assertWithError(!this.isScanning, \"is already scanning\");\n  }\n\n  startScan() {\n    this.#assertIsNotScanning();\n    this.sendServerMessage(\"startScan\");\n  }\n  stopScan() {\n    this.#assertIsScanning();\n    this.sendServerMessage(\"stopScan\");\n  }\n  toggleScan() {\n    this.#assertIsScanningAvailable();\n\n    if (this.isScanning) {\n      this.stopScan();\n    } else {\n      this.startScan();\n    }\n  }\n\n  // PERIPHERALS\n  #discoveredDevices: DiscoveredDevicesMap = {};\n  get discoveredDevices(): Readonly<DiscoveredDevicesMap> {\n    return this.#discoveredDevices;\n  }\n\n  protected onDiscoveredDevice(discoveredDevice: DiscoveredDevice) {\n    _console.log({ discoveredDevice });\n    this.#discoveredDevices[discoveredDevice.bluetoothId] = discoveredDevice;\n    this.dispatchEvent(\"discoveredDevice\", { discoveredDevice });\n  }\n  requestDiscoveredDevices() {\n    this.sendServerMessage({ type: \"discoveredDevices\" });\n  }\n  #onExpiredDiscoveredDevice(bluetoothId: string) {\n    _console.log({ expiredBluetoothDeviceId: bluetoothId });\n    const discoveredDevice = this.#discoveredDevices[bluetoothId];\n    if (!discoveredDevice) {\n      _console.warn(`no discoveredDevice found with id \"${bluetoothId}\"`);\n      return;\n    }\n    _console.log({ expiredDiscoveredDevice: discoveredDevice });\n    delete this.#discoveredDevices[bluetoothId];\n    this.dispatchEvent(\"expiredDiscoveredDevice\", { discoveredDevice });\n  }\n\n  // DEVICE CONNECTION\n  connectToDevice(bluetoothId: string, connectionType?: ClientConnectionType) {\n    return this.requestConnectionToDevice(bluetoothId, connectionType);\n  }\n  protected requestConnectionToDevice(\n    bluetoothId: string,\n    connectionType?: ClientConnectionType\n  ) {\n    this.assertConnection();\n    _console.assertTypeWithError(bluetoothId, \"string\");\n    const device = this.#getOrCreateDevice(bluetoothId);\n    if (connectionType) {\n      device.connect({ type: \"client\", subType: connectionType });\n    } else {\n      device.connect();\n    }\n    return device;\n  }\n  protected sendConnectToDeviceMessage(\n    bluetoothId: string,\n    connectionType?: ClientConnectionType\n  ) {\n    if (connectionType) {\n      this.sendServerMessage({\n        type: \"connectToDevice\",\n        data: concatenateArrayBuffers(\n          stringToArrayBuffer(bluetoothId),\n          ConnectionTypes.indexOf(connectionType)\n        ),\n      });\n    } else {\n      this.sendServerMessage({ type: \"connectToDevice\", data: bluetoothId });\n    }\n  }\n\n  // DEVICE CONNECTION\n  createDevice(bluetoothId: string) {\n    const device = new Device();\n    const discoveredDevice = this.#discoveredDevices[bluetoothId];\n    const clientConnectionManager = new ClientConnectionManager();\n    clientConnectionManager.discoveredDevice = Object.assign(\n      {},\n      discoveredDevice\n    );\n    clientConnectionManager.client = this;\n    clientConnectionManager.bluetoothId = bluetoothId;\n    clientConnectionManager.sendClientMessage = this.sendDeviceMessage.bind(\n      this,\n      bluetoothId\n    );\n    clientConnectionManager.sendRequiredDeviceInformationMessage =\n      this.sendRequiredDeviceInformationMessage.bind(this, bluetoothId);\n    clientConnectionManager.sendClientConnectMessage =\n      this.sendConnectToDeviceMessage.bind(this, bluetoothId);\n    clientConnectionManager.sendClientDisconnectMessage =\n      this.sendDisconnectFromDeviceMessage.bind(this, bluetoothId);\n    device.connectionManager = clientConnectionManager;\n    return device;\n  }\n\n  #getOrCreateDevice(bluetoothId: string) {\n    let device = this.#devices[bluetoothId];\n    if (!device) {\n      device = this.createDevice(bluetoothId);\n      this.#devices[bluetoothId] = device;\n    }\n    return device;\n  }\n  protected onConnectedBluetoothDeviceIds(bluetoothIds: string[]) {\n    _console.log({ bluetoothIds });\n    bluetoothIds.forEach((bluetoothId) => {\n      const device = this.#getOrCreateDevice(bluetoothId);\n      const connectionManager =\n        device.connectionManager! as ClientConnectionManager;\n      connectionManager.isConnected = true;\n      DeviceManager._CheckDeviceAvailability(device);\n    });\n  }\n\n  disconnectFromDevice(bluetoothId: string) {\n    this.requestDisconnectionFromDevice(bluetoothId);\n  }\n  protected requestDisconnectionFromDevice(bluetoothId: string) {\n    this.assertConnection();\n    _console.assertTypeWithError(bluetoothId, \"string\");\n    const device = this.devices[bluetoothId];\n    _console.assertWithError(device, `no device found with id ${bluetoothId}`);\n    device.disconnect();\n    return device;\n  }\n  protected sendDisconnectFromDeviceMessage(bluetoothId: string) {\n    this.sendServerMessage({ type: \"disconnectFromDevice\", data: bluetoothId });\n  }\n\n  protected sendDeviceMessage(\n    bluetoothId: string,\n    ...messages: ClientDeviceMessage[]\n  ) {\n    this.sendServerMessage({\n      type: \"deviceMessage\",\n      data: [bluetoothId, createClientDeviceMessage(...messages)],\n    });\n  }\n\n  protected sendRequiredDeviceInformationMessage(bluetoothId: string) {\n    this.sendServerMessage({\n      type: \"requiredDeviceInformation\",\n      data: [bluetoothId],\n    });\n  }\n}\n\nexport default BaseClient;\n","import { createConsole } from \"../../utils/Console.ts\";\nimport {\n  createServerMessage,\n  MessageLike,\n  ServerMessage,\n} from \"../ServerUtils.ts\";\nimport {\n  addEventListeners,\n  removeEventListeners,\n} from \"../../utils/EventUtils.ts\";\nimport ClientConnectionManager from \"../../connection/ClientConnectionManager.ts\";\nimport BaseClient, { ServerURL } from \"../BaseClient.ts\";\nimport type * as ws from \"ws\";\nimport { Timer } from \"../../utils/Timer.ts\";\nimport {\n  createWebSocketMessage,\n  WebSocketMessageType,\n  WebSocketMessageTypes,\n  webSocketPingTimeout,\n  webSocketReconnectTimeout,\n  WebSocketMessage,\n} from \"./WebSocketUtils.ts\";\nimport { parseMessage } from \"../../utils/ParseUtils.ts\";\nimport { isInLensStudio, isInBrowser } from \"../../utils/environment.ts\";\n\nconst _console = createConsole(\"WebSocketClient\", { log: false });\n\nclass WebSocketClient extends BaseClient {\n  // WEBSOCKET\n  #webSocket?: WebSocket;\n  get webSocket() {\n    return this.#webSocket;\n  }\n  set webSocket(newWebSocket) {\n    if (this.#webSocket == newWebSocket) {\n      _console.log(\"redundant webSocket assignment\");\n      return;\n    }\n\n    _console.log(\"assigning webSocket\", newWebSocket);\n\n    if (this.#webSocket) {\n      removeEventListeners(this.#webSocket, this.#boundWebSocketEventListeners);\n    }\n\n    addEventListeners(newWebSocket, this.#boundWebSocketEventListeners);\n    this.#webSocket = newWebSocket;\n\n    _console.log(\"assigned webSocket\");\n  }\n  get readyState() {\n    return this.webSocket?.readyState;\n  }\n  get isConnected() {\n    return this.readyState == WebSocket.OPEN;\n  }\n  get isDisconnected() {\n    return this.readyState == WebSocket.CLOSED;\n  }\n\n  connect(\n    url: string | URL = `${\n      location.protocol.includes(\"https\") ? \"wss\" : \"ws\"\n    }://${location.host}`\n  ) {\n    if (this.webSocket) {\n      this.assertDisconnection();\n    }\n    this._connectionStatus = \"connecting\";\n\n    if (isInLensStudio) {\n      // FILL\n    } else {\n      this.webSocket = new WebSocket(url);\n    }\n  }\n\n  disconnect() {\n    this.assertConnection();\n    if (this.reconnectOnDisconnection) {\n      this.reconnectOnDisconnection = false;\n      this.webSocket!.addEventListener(\n        \"close\",\n        () => {\n          this.reconnectOnDisconnection = true;\n        },\n        { once: true }\n      );\n    }\n    this._connectionStatus = \"disconnecting\";\n    this.webSocket!.close();\n  }\n\n  reconnect() {\n    this.assertDisconnection();\n    this.connect(this.webSocket!.url);\n  }\n\n  toggleConnection(url?: ServerURL) {\n    if (this.isConnected) {\n      this.disconnect();\n    } else if (url && this.webSocket?.url == url) {\n      this.reconnect();\n    } else {\n      this.connect(url);\n    }\n  }\n\n  // WEBSOCKET MESSAGING\n  sendMessage(message: MessageLike) {\n    this.assertConnection();\n    this.#webSocket!.send(message);\n    this.#pingTimer.restart();\n  }\n\n  sendServerMessage(...messages: ServerMessage[]) {\n    this.sendMessage(\n      createWebSocketMessage({\n        type: \"serverMessage\",\n        data: createServerMessage(...messages),\n      })\n    );\n  }\n\n  #sendWebSocketMessage(...messages: WebSocketMessage[]) {\n    this.sendMessage(createWebSocketMessage(...messages));\n  }\n\n  // WEBSOCKET EVENTS\n  #boundWebSocketEventListeners: { [eventType: string]: Function } = {\n    open: this.#onWebSocketOpen.bind(this),\n    message: this.#onWebSocketMessage.bind(this),\n    close: this.#onWebSocketClose.bind(this),\n    error: this.#onWebSocketError.bind(this),\n  };\n\n  #onWebSocketOpen(event: ws.Event) {\n    _console.log(\"webSocket.open\", event);\n    this.#pingTimer.start();\n    //this._connectionStatus = \"connected\";\n    this._sendRequiredMessages();\n  }\n  async #onWebSocketMessage(event: ws.MessageEvent) {\n    _console.log(\"webSocket.message\", event);\n    //this.#pingTimer.restart();\n    //@ts-expect-error\n    const arrayBuffer = await event.data.arrayBuffer();\n    const dataView = new DataView(arrayBuffer);\n    this.#parseWebSocketMessage(dataView);\n  }\n  #onWebSocketClose(event: ws.CloseEvent) {\n    _console.log(\"webSocket.close\", event);\n\n    this._connectionStatus = \"notConnected\";\n\n    Object.entries(this.devices).forEach(([id, device]) => {\n      const connectionManager =\n        device.connectionManager! as ClientConnectionManager;\n      connectionManager.isConnected = false;\n    });\n\n    this.#pingTimer.stop();\n    if (this.reconnectOnDisconnection) {\n      setTimeout(() => {\n        this.reconnect();\n      }, webSocketReconnectTimeout);\n    }\n  }\n  #onWebSocketError(event: ws.ErrorEvent) {\n    _console.error(\"webSocket.error\", event);\n  }\n\n  // PARSING\n  #parseWebSocketMessage(dataView: DataView<ArrayBuffer>) {\n    parseMessage(\n      dataView,\n      WebSocketMessageTypes,\n      this.#onServerMessage.bind(this),\n      null,\n      true\n    );\n  }\n\n  #onServerMessage(\n    messageType: WebSocketMessageType,\n    dataView: DataView<ArrayBuffer>\n  ) {\n    switch (messageType) {\n      case \"ping\":\n        this.#pong();\n        break;\n      case \"pong\":\n        break;\n      case \"serverMessage\":\n        this.parseMessage(dataView);\n        break;\n      default:\n        _console.error(`uncaught messageType \"${messageType}\"`);\n        break;\n    }\n  }\n\n  // PING\n  #pingTimer = new Timer(this.#ping.bind(this), webSocketPingTimeout);\n  #ping() {\n    this.#sendWebSocketMessage(\"ping\");\n  }\n  #pong() {\n    this.#sendWebSocketMessage(\"pong\");\n  }\n}\n\nexport default WebSocketClient;\n","import {\n  setAllConsoleLevelFlags,\n  setConsoleLevelFlagsForType,\n} from \"./utils/Console.ts\";\nexport { setAllConsoleLevelFlags, setConsoleLevelFlagsForType };\n\nimport * as Environment from \"./utils/environment.ts\";\nexport { Environment };\n\nimport { Vector2, Vector3, Quaternion, Euler } from \"./utils/MathUtils.ts\";\nexport { Vector2, Vector3, Quaternion, Euler };\n\nimport {\n  default as Device,\n  DeviceEvent,\n  DeviceEventMap,\n  DeviceEventListenerMap,\n  BoundDeviceEventListeners,\n} from \"./Device.ts\";\nexport {\n  Device,\n  DeviceEvent,\n  DeviceEventMap,\n  DeviceEventListenerMap,\n  BoundDeviceEventListeners,\n};\n\nimport {\n  default as DeviceManager,\n  DeviceManagerEvent,\n  DeviceManagerEventMap,\n  DeviceManagerEventListenerMap,\n  BoundDeviceManagerEventListeners,\n} from \"./DeviceManager.ts\";\nexport {\n  DeviceManager,\n  DeviceManagerEvent,\n  DeviceManagerEventMap,\n  DeviceManagerEventListenerMap,\n  BoundDeviceManagerEventListeners,\n};\n\nimport { DeviceInformation } from \"./DeviceInformationManager.ts\";\nexport { DeviceInformation };\n\nimport {\n  DeviceType,\n  DeviceTypes,\n  MinNameLength,\n  MaxNameLength,\n  Sides,\n  Side,\n} from \"./InformationManager.ts\";\nexport { DeviceType, DeviceTypes, MinNameLength, MaxNameLength, Sides, Side };\n\nimport {\n  MinWifiSSIDLength,\n  MaxWifiSSIDLength,\n  MinWifiPasswordLength,\n  MaxWifiPasswordLength,\n} from \"./WifiManager.ts\";\nexport {\n  MinWifiSSIDLength,\n  MaxWifiSSIDLength,\n  MinWifiPasswordLength,\n  MaxWifiPasswordLength,\n};\n\nimport {\n  SensorType,\n  SensorTypes,\n  ContinuousSensorType,\n  ContinuousSensorTypes,\n} from \"./sensor/SensorDataManager.ts\";\nexport { SensorType, SensorTypes, ContinuousSensorType, ContinuousSensorTypes };\n\nimport {\n  MaxSensorRate,\n  SensorRateStep,\n  SensorConfiguration,\n} from \"./sensor/SensorConfigurationManager.ts\";\nexport { MaxSensorRate, SensorRateStep, SensorConfiguration };\n\nimport {\n  DefaultNumberOfPressureSensors,\n  PressureData,\n} from \"./sensor/PressureSensorDataManager.ts\";\nexport { DefaultNumberOfPressureSensors, PressureData };\n\nimport { CenterOfPressure } from \"./utils/CenterOfPressureHelper.ts\";\nexport { CenterOfPressure };\n\nimport {\n  VibrationConfiguration,\n  VibrationLocation,\n  VibrationLocations,\n  VibrationType,\n  VibrationTypes,\n  MaxNumberOfVibrationWaveformEffectSegments,\n  MaxVibrationWaveformSegmentDuration,\n  MaxVibrationWaveformEffectSegmentDelay,\n  MaxVibrationWaveformEffectSegmentLoopCount,\n  MaxNumberOfVibrationWaveformSegments,\n  MaxVibrationWaveformEffectSequenceLoopCount,\n} from \"./vibration/VibrationManager.ts\";\nexport {\n  VibrationConfiguration,\n  VibrationLocation,\n  VibrationLocations,\n  VibrationType,\n  VibrationTypes,\n  MaxNumberOfVibrationWaveformEffectSegments,\n  MaxVibrationWaveformSegmentDuration,\n  MaxVibrationWaveformEffectSegmentDelay,\n  MaxVibrationWaveformEffectSegmentLoopCount,\n  MaxNumberOfVibrationWaveformSegments,\n  MaxVibrationWaveformEffectSequenceLoopCount,\n};\n\nimport {\n  VibrationWaveformEffect,\n  VibrationWaveformEffects,\n} from \"./vibration/VibrationWaveformEffects.ts\";\nexport { VibrationWaveformEffect, VibrationWaveformEffects };\n\nimport {\n  FileType,\n  FileTypes,\n  FileTransferDirection,\n  FileTransferDirections,\n} from \"./FileTransferManager.ts\";\nexport { FileType, FileTypes, FileTransferDirection, FileTransferDirections };\n\nimport {\n  TfliteSensorType,\n  TfliteSensorTypes,\n  TfliteTask,\n  TfliteTasks,\n  TfliteFileConfiguration,\n} from \"./TfliteManager.ts\";\nexport {\n  TfliteSensorType,\n  TfliteSensorTypes,\n  TfliteTask,\n  TfliteTasks,\n  TfliteFileConfiguration,\n};\n\nimport {\n  CameraConfiguration,\n  CameraCommand,\n  CameraCommands,\n  CameraConfigurationType,\n  CameraConfigurationTypes,\n} from \"./CameraManager.ts\";\nexport {\n  CameraConfiguration,\n  CameraCommand,\n  CameraCommands,\n  CameraConfigurationType,\n  CameraConfigurationTypes,\n};\n\nimport {\n  MicrophoneConfiguration,\n  MicrophoneCommand,\n  MicrophoneCommands,\n  MicrophoneConfigurationType,\n  MicrophoneConfigurationTypes,\n  MicrophoneConfigurationValues,\n} from \"./MicrophoneManager.ts\";\nexport {\n  MicrophoneConfiguration,\n  MicrophoneCommand,\n  MicrophoneCommands,\n  MicrophoneConfigurationType,\n  MicrophoneConfigurationTypes,\n  MicrophoneConfigurationValues,\n};\n\nimport {\n  DisplayBrightness,\n  DisplayBrightnesses,\n  DisplaySize,\n  DisplayBitmapColorPair,\n  DisplayPixelDepths,\n  DefaultNumberOfDisplayColors,\n  MinSpriteSheetNameLength,\n  MaxSpriteSheetNameLength,\n  DisplayBitmap,\n  DisplaySpriteColorPair,\n  DisplayWireframeEdge,\n  DisplayWireframe,\n  DisplayBezierCurveType,\n  DisplayBezierCurveTypes,\n} from \"./DisplayManager.ts\";\nexport {\n  DisplayBrightness,\n  DisplayBrightnesses,\n  DisplaySize,\n  DisplayBitmapColorPair,\n  DisplayPixelDepths,\n  DefaultNumberOfDisplayColors,\n  MinSpriteSheetNameLength,\n  MaxSpriteSheetNameLength,\n  DisplayBitmap,\n  DisplaySpriteColorPair,\n  DisplayWireframeEdge,\n  DisplayWireframe,\n  DisplayBezierCurveType,\n  DisplayBezierCurveTypes,\n};\n\nimport { wait, Timer } from \"./utils/Timer.ts\";\nexport { wait, Timer };\n\nimport {\n  DisplaySegmentCap,\n  DisplaySegmentCaps,\n  DisplayAlignment,\n  DisplayAlignments,\n  DisplayDirection,\n  DisplayDirections,\n} from \"./utils/DisplayContextState.ts\";\nexport {\n  DisplaySegmentCap,\n  DisplaySegmentCaps,\n  DisplayAlignment,\n  DisplayAlignments,\n  DisplayDirection,\n  DisplayDirections,\n};\n\nimport {\n  maxDisplayScale,\n  DisplayColorRGB,\n  pixelDepthToNumberOfColors,\n  displayCurveTypeToNumberOfControlPoints,\n  mergeWireframes,\n  intersectWireframes,\n  isWireframePolygon,\n} from \"./utils/DisplayUtils.ts\";\nexport {\n  maxDisplayScale,\n  DisplayColorRGB,\n  pixelDepthToNumberOfColors,\n  displayCurveTypeToNumberOfControlPoints,\n  mergeWireframes,\n  intersectWireframes,\n  isWireframePolygon,\n};\n\n/** BROWSER_START */\nimport {\n  svgToDisplayContextCommands,\n  svgToSprite,\n  svgToSpriteSheet,\n  isValidSVG,\n  getSvgStringFromDataUrl,\n} from \"./utils/SvgUtils.ts\";\nexport {\n  svgToDisplayContextCommands,\n  svgToSprite,\n  svgToSpriteSheet,\n  isValidSVG,\n  getSvgStringFromDataUrl,\n};\n/** BROWSER_END */\n\nimport {\n  DisplayContextCommand,\n  DisplayContextCommandType,\n  DisplayContextCommandTypes,\n  DisplaySpriteContextCommandType,\n  DisplaySpriteContextCommandTypes,\n} from \"./utils/DisplayContextCommand.ts\";\nexport {\n  DisplayContextCommand,\n  DisplayContextCommandType,\n  DisplayContextCommandTypes,\n  DisplaySpriteContextCommandType,\n  DisplaySpriteContextCommandTypes,\n};\n\nimport {\n  simplifyPoints,\n  simplifyCurves,\n  simplifyPointsAsCubicCurveControlPoints,\n} from \"./utils/PathUtils.ts\";\nexport {\n  simplifyPoints,\n  simplifyCurves,\n  simplifyPointsAsCubicCurveControlPoints,\n};\n\nimport {\n  DisplaySprite,\n  DisplaySpriteSheet,\n  DisplaySpriteSheetPalette,\n  DisplaySpritePaletteSwap,\n  parseFont,\n  getFontUnicodeRange,\n  stringToSprites,\n  fontToSpriteSheet,\n  getFontMetrics,\n  DisplaySpriteSubLine,\n  DisplaySpriteLine,\n  DisplaySpriteLines,\n  getFontMaxHeight,\n  getMaxSpriteSheetSize,\n  englishRegex,\n  FontToSpriteSheetOptions,\n} from \"./utils/DisplaySpriteSheetUtils.ts\";\nexport {\n  DisplaySprite,\n  DisplaySpriteSheet,\n  DisplaySpriteSheetPalette,\n  DisplaySpritePaletteSwap,\n  parseFont,\n  getFontUnicodeRange,\n  stringToSprites,\n  fontToSpriteSheet,\n  getFontMetrics,\n  DisplaySpriteSubLine,\n  DisplaySpriteLine,\n  DisplaySpriteLines,\n  getFontMaxHeight,\n  getMaxSpriteSheetSize,\n  englishRegex,\n  FontToSpriteSheetOptions,\n};\n\n/** BROWSER_START */\nimport {\n  default as DisplayCanvasHelper,\n  DisplayCanvasHelperEvent,\n  DisplayCanvasHelperEventMap,\n  DisplayCanvasHelperEventListenerMap,\n} from \"./utils/DisplayCanvasHelper.ts\";\nexport {\n  DisplayCanvasHelper,\n  DisplayCanvasHelperEvent,\n  DisplayCanvasHelperEventMap,\n  DisplayCanvasHelperEventListenerMap,\n};\n/** BROWSER_END */\n\n/** BROWSER_START */\nimport { Font, Glyph } from \"opentype.js\";\nexport { Font, Glyph };\n/** BROWSER_END */\n\n/** BROWSER_START */\nimport {\n  resizeAndQuantizeImage,\n  quantizeImage,\n  imageToSprite,\n  imageToSpriteSheet,\n  canvasToSprite,\n  canvasToSpriteSheet,\n  resizeImage,\n  imageToBitmaps,\n  canvasToBitmaps,\n} from \"./utils/DisplayBitmapUtils.ts\";\nexport {\n  resizeAndQuantizeImage,\n  quantizeImage,\n  imageToSprite,\n  imageToSpriteSheet,\n  canvasToSprite,\n  canvasToSpriteSheet,\n  resizeImage,\n  imageToBitmaps,\n  canvasToBitmaps,\n};\n/** BROWSER_END */\n\nimport { rgbToHex, hexToRGB } from \"./utils/ColorUtils.ts\";\nexport { rgbToHex, hexToRGB };\n\nimport {\n  default as DevicePair,\n  DevicePairEvent,\n  DevicePairEventMap,\n  DevicePairEventListenerMap,\n  BoundDevicePairEventListeners,\n  DevicePairType,\n  DevicePairTypes,\n} from \"./devicePair/DevicePair.ts\";\nexport {\n  DevicePair,\n  DevicePairEvent,\n  DevicePairEventMap,\n  DevicePairEventListenerMap,\n  BoundDevicePairEventListeners,\n  DevicePairType,\n  DevicePairTypes,\n};\n\nimport { addEventListeners, removeEventListeners } from \"./utils/EventUtils.ts\";\nexport const EventUtils = {\n  addEventListeners,\n  removeEventListeners,\n};\n\nimport { throttle, debounce } from \"./utils/ThrottleUtils.ts\";\nexport const ThrottleUtils = {\n  throttle,\n  debounce,\n};\n\nimport {\n  ConnectionMessageType,\n  ConnectionMessageTypes,\n  ConnectionEventType,\n  ConnectionEventTypes,\n  TxRxMessageType,\n  TxRxMessageTypes,\n} from \"./connection/BaseConnectionManager.ts\";\nexport {\n  ConnectionMessageType,\n  ConnectionMessageTypes,\n  ConnectionEventType,\n  ConnectionEventTypes,\n  TxRxMessageType,\n  TxRxMessageTypes,\n};\n\nimport { DiscoveredDevice } from \"./scanner/BaseScanner.ts\";\nexport { DiscoveredDevice };\n\n/** NODE_START */\nimport { default as Scanner } from \"./scanner/Scanner.ts\";\nimport { default as WebSocketServer } from \"./server/websocket/WebSocketServer.ts\";\nimport { default as UDPServer } from \"./server/udp/UDPServer.ts\";\n\nexport { Scanner };\nexport { WebSocketServer };\nexport { UDPServer };\n/** NODE_END */\n\n/** LS_START */\n// export { default as WebSocketClient } from \"./server/websocket/WebSocketClient.ts\";\n/** LS_END */\n/** BROWSER_START */\nimport { default as WebSocketClient } from \"./server/websocket/WebSocketClient.ts\";\nexport { WebSocketClient };\n/** BROWSER_END */\n\nimport { default as RangeHelper, Range } from \"./utils/RangeHelper.ts\";\nexport { RangeHelper, Range };\n","export function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  interval: number,\n  trailing = false\n): (...args: Parameters<T>) => void {\n  let lastTime = 0;\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let lastArgs: Parameters<T> | null = null;\n\n  return function (...args: Parameters<T>) {\n    const now = Date.now();\n    const remaining = interval - (now - lastTime);\n\n    if (remaining <= 0) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      lastTime = now;\n      fn(...args);\n    } else if (trailing) {\n      lastArgs = args;\n      if (!timeout) {\n        timeout = setTimeout(() => {\n          lastTime = Date.now();\n          timeout = null;\n          if (lastArgs) {\n            fn(...lastArgs);\n            lastArgs = null;\n          }\n        }, remaining);\n      }\n    }\n  };\n}\n\nexport function debounce<T extends (...args: any[]) => void>(\n  fn: T,\n  interval: number,\n  callImmediately = false\n): (...args: Parameters<T>) => void {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n\n  return function (...args: Parameters<T>) {\n    const callNow = callImmediately && !timeout;\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (!callImmediately) {\n        fn(...args);\n      }\n    }, interval);\n\n    if (callNow) {\n      fn(...args);\n    }\n  };\n}\n"],"names":["isInDev","isInBrowser","window","document","isInNode","process","versions","node","userAgent","navigator","isBluetoothSupported","Boolean","bluetooth","isInBluefy","test","isInWebBLE","isAndroid","isSafari","isIOS","isMac","isInLensStudio","__console","log","args","wrapWithLocation","fn","functionPath","stack","Error","match","callerLine","getCallerFunctionPath","assert","warn","data","table","emptyFunction","error","table$1","bind","Console","static","constructor","type","consoles","this","levelFlags","setLevelFlags","setLevelFlagsForType","create","condition","message","assertWithError","value","enumeration","includes","assertRangeWithError","name","min","max","createConsole","setConsoleLevelFlagsForType","setAllConsoleLevelFlags","setAllLevelFlags","_console$J","EventDispatcher","target","validEventTypes","isValidEventType","updateEventListeners","listeners","filter","listenerObj","shouldRemove","find","listenerObject","listener","once","options","push","length","removeEventListeners","forEach","console","waitForEvent","Promise","resolve","addEventListener","event","_console$I","async","wait","delay","callback","assertTypeWithError","newCallback","isRunning","interval","newInterval","intervalId","undefined","setInterval","clearInterval","start","startImmediately","crc32ForByte","r","j","crc32Table","Uint32Array","i","crc32","dataIterable","dataBytes","Uint8Array","byteLength","crcLowByte","crc","dataByte","_TextEncoder","_TextDecoder","TextEncoder","encode","string","from","encoding","TextDecoder","decode","Array","map","String","fromCharCode","textEncoder","textDecoder","_console$H","concatenateArrayBuffers","arrayBuffers","arrayBuffer","Math","floor","number","boolean","stringToArrayBuffer","ArrayBuffer","buffer","DataView","object","objectToArrayBuffer","uint8Array","byteOffset","end","dataView","begin","slice","getFileBuffer","file","fileBuffer","response","fetch","File","UInt8ByteBuffer","autoBind","self","include","exclude","key","pattern","some","properties","Set","Reflect","ownKeys","add","getPrototypeOf","Object","prototype","getAllProperties","descriptor","getOwnPropertyDescriptor","_console$G","FileTransferMessageTypes","FileTypes","FileTransferStatuses","FileTransferCommands","FileTransferEventTypes","RequiredFileTransferMessageTypes","FileTransferManager","sendMessage","eventDispatcher","dispatchEvent","removeEventListener","assertValidType","assertEnumWithError","isValidType","assertValidTypeEnum","typeEnum","assertValidStatusEnum","statusEnum","assertValidCommand","command","fileTypes","parseFileTypes","MaxLength","maxLength","_a$5","parseMaxLength","updateMaxLength","assertValidLength","parseType","updateType","setType","newType","sendImmediately","promise","parseLength","updateLength","setLength","newLength","checksum","parseChecksum","updateChecksum","setChecksum","newChecksum","setCommand","commandEnum","status","parseStatus","updateStatus","receivedBlocks","isCancelling","bytesTransferred","fileTransferStatus","progress","bytesReceived","isServerSide","direction","fileType","messageType","parseBlock","parseBytesTransferred","send","override","fileLength","promises","all","sendBlock","mtu","offset","slicedBuffer","cancel","newIsServerSide","messages","_console$F","Uint16Max","parseTimestamp","now","Date","nowWithoutLower2Bytes","timestamp","lower2Bytes","timestampDifference","getVector2DistanceSquared","a","b","getVector2Midpoint","getVector3Length","vector","sqrt","x","y","z","clamp","degToRad","deg","twoPi","PI","normalizeRadians","rad","pointInPolygon","pt","polygon","xi","yi","xj","yj","inside","initialRange","Infinity","span","RangeHelper","range","structuredClone","newMin","newMax","update","normalization","CenterOfPressureHelper","reset","centerOfPressure","getNormalization","weightByRange","_console$E","PressureSensorTypes","ContinuousPressureSensorTypes","DefaultNumberOfPressureSensors","PressureSensorDataManager","positions","numberOfSensors","parsePositions","getUint8","arrayLength","objectOrCallback","sensorRangeHelpers","fill","_","index","normalizedSumRangeHelper","centerOfPressureHelper","rangeHelper","pressure","sensors","scaledSum","normalizedSum","weightedValue","scaledValue","center","sensor","position","normalizedCenter","_console$D","ActivityTypes","DeviceOrientations","MotionSensorDataManager","getInt16","quaternion","heading","pitch","roll","euler","parseStepCounter","stepCount","parseActivity","activityBitfield","toString","activity","activityType","parseDeviceOrientation","deviceOrientation","BarometerSensorTypes","ContinuousBarometerSensorTypes","_console$C","BarometerSensorDataManager","calculcateAltitude","L","getUint32","scalar","_console$B","parseMessage","messageTypes","context","parseMessageLengthAsUint16","messageTypeEnum","messageLength","_dataView","_console$A","CameraCommands","CameraStatuses","CameraDataTypes","CameraConfigurationTypes","CameraMessageTypes","RequiredCameraMessageTypes","CameraEventTypes","CameraManager","cameraStatus","parseCameraStatus","newCameraStatus","cameraStatusIndex","updateCameraStatus","previousCameraStatus","latestTakingPictureTimestamp","didBuildImage","sendCameraCommand","focus","takePicture","stop","sleep","wake","parseCameraData","onCameraData","headerData","headerProgress","headerSize","imageData","imageProgress","imageSize","footerProgress","footerData","footerSize","buildImage","blob","Blob","url","cameraImage","latency","isRecording","cameraRecordingData","recordingCanvasContext","recordingCanvas","width","height","drawImage","recordingImage","autoPicture","headerDataView","setUint8","indexOf","footerDataView","cameraConfiguration","availableCameraConfigurationTypes","cameraConfigurationRanges","parseCameraConfiguration","cameraConfigurationType","cameraConfigurationTypeIndex","parsedCameraConfiguration","isCameraConfigurationRedundant","every","newCameraConfiguration","setCameraConfigurationData","assertAvailableCameraConfigurationType","isCameraConfigurationTypeAvailable","cameraConfigurationTypeEnum","createData","cameraConfigurationTypes","_a$4","AssertValidCameraConfigurationType","isRecordingAvailable","MediaRecorder","recordingCanvasStream","recordingMediaRecorder","recordingChunks","mimeType","images","onstop","configuration","newAutoPicture","interleaved","sampleRate","numChannels","view","writeString","setUint32","wavBuffer","charCodeAt","LOG_TABLE","encodeSample$1","sample","compandedValue","sign","exponent","decodeSample$1","aLawSample","decoded","samples","pcmSamples","Int16Array","aLawSamples","encodeTable","decodeTable","encodeSample","mantissa","muLawSample","decodeSample","muLawSamples","alawmulaw","mulaw","_console$z","MicrophoneCommands","MicrophoneStatuses","MicrophoneBitDepths","MicrophoneMessageTypes","MicrophoneConfigurationValues","bitDepth","RequiredMicrophoneMessageTypes","MicrophoneEventTypes","MicrophoneManager","microphoneStatus","parseMicrophoneStatus","newMicrophoneStatus","microphoneStatusIndex","updateMicrophoneStatus","previousMicrophoneStatus","sendMicrophoneCommand","vad","toggle","parseMicrophoneData","Float32Array","numberOfSamples","microphoneRecordingData","audioContext","gainNode","bufferSource","audioBuffer","fadeDuration","channelData","connect","playbackTime","duration","bytesPerSample","microphoneConfiguration","availableMicrophoneConfigurationTypes","parseMicrophoneConfiguration","microphoneConfigurationType","MicrophoneConfigurationTypes","microphoneConfigurationTypeIndex","values","rawValue","parsedMicrophoneConfiguration","isMicrophoneConfigurationRedundant","newMicrophoneConfiguration","setMicrophoneConfigurationData","assertAvailableMicrophoneConfigurationType","isMicrophoneConfigurationTypeAvailable","microphoneConfigurationTypeEnum","microphoneConfigurationTypes","_a$3","AssertValidMicrophoneConfigurationType","newAudioContext","mediaStreamDestination","disconnect","createMediaStreamDestination","float32ArrayToWav","Number","_console$y","SensorTypes","ContinuousSensorTypes","SensorDataMessageTypes","RequiredPressureMessageTypes","SensorDataEventTypes","SensorDataManager","pressureSensorDataManager","motionSensorDataManager","barometerSensorDataManager","scalars","Map","sensorType","sensorTypeEnum","parseScalars","parseData","sensorTypeIndex","sensorScalar","getFloat32","parseDataCallback","get","isLast","_console$x","SensorRateStep","SensorConfigurationMessageTypes","SensorConfigurationEventTypes","SensorConfigurationManager","availableSensorTypes","assertAvailableSensorType","isSensorTypeAvailable","hasSensorType","updateConfiguration","updatedConfiguration","isRedundant","sensorConfiguration","setConfiguration","newSensorConfiguration","clearRest","assign","zeroSensorConfiguration","setSensorConfigurationData","parse","sensorRate","getUint16","parsedSensorConfiguration","assertValidSensorRate","_a$2","AssertValidSensorRate","sensorTypes","AssertValidSensorType","setUint16","ZeroSensorConfiguration","clearSensorConfiguration","_console$w","TfliteMessageTypes","TfliteEventTypes","RequiredTfliteMessageTypes","TfliteSensorTypes","TfliteManager","assertValidTask","task","TfliteTasks","assertValidTaskEnum","taskEnum","addEventListenter","classes","setClasses","newClasses","parseName","updateName","setName","newName","setNameData","parseTask","updateTask","setTask","newTask","parseSampleRate","updateSampleRate","tfliteSampleRate","setSampleRate","newSampleRate","tfliteSensorType","parseSensorTypes","updateSensorTypes","tfliteSensorTypes","setSensorTypes","newSensorTypes","array","sort","newSensorTypeEnums","isReady","parseIsReady","updateIsReady","captureDelay","parseCaptureDelay","updateCaptueDelay","tfliteCaptureDelay","setCaptureDelay","newCaptureDelay","threshold","parseThreshold","updateThreshold","setThreshold","newThreshold","inferencingEnabled","parseInferencingEnabled","updateInferencingEnabled","tfliteInferencingEnabled","setInferencingEnabled","newInferencingEnabled","toggleInferencingEnabled","enableInferencing","disableInferencing","parseInference","inference","maxValue","maxIndex","maxClass","classValues","_console$v","DeviceInformationTypes","DeviceInformationEventTypes","DeviceInformationManager","information","isComplete","partialDeviceInformation","deviceInformationName","manufacturerName","modelNumber","softwareRevision","hardwareRevision","firmwareRevision","pnpId","source","vendorId","serialNumber","_console$u","DeviceTypes","MinNameLength","MaxNameLength","InformationMessageTypes","InformationEventTypes","InformationManager","isCharging","updateIsCharging","updatedIsCharging","batteryCurrent","getBatteryCurrent","updateBatteryCurrent","updatedBatteryCurrent","id","updateId","updatedId","updatedName","assertValidDeviceType","assertValidDeviceTypeEnum","updatedType","newTypeEnum","setTypeData","setTypeEnum","isInsole","isGlove","side","updateMtu","newMtu","isCurrentTimeSet","onCurrentTime","currentTime","setCurrentTime","setBigUint64","BigInt","connectionType","getBigUint64","VibrationWaveformEffects","_console$t","VibrationMessageTypes","VibrationEventTypes","MaxNumberOfVibrationWaveformEffectSegments","MaxVibrationWaveformSegmentDuration","MaxVibrationWaveformEffectSegmentDelay","MaxVibrationWaveformEffectSegmentLoopCount","MaxNumberOfVibrationWaveformSegments","MaxVibrationWaveformEffectSequenceLoopCount","VibrationManager","verifyLocation","location","VibrationLocations","verifyLocations","locations","assertNonEmptyArray","createLocationsBitmask","locationsBitmask","locationIndex","isArray","verifyWaveformEffect","waveformEffect","verifyWaveformEffectSegment","waveformEffectSegment","effect","loopCount","verifyWaveformEffectSegmentLoopCount","waveformEffectSegmentLoopCount","verifyWaveformEffectSegments","waveformEffectSegments","verifyWaveformEffectSequenceLoopCount","waveformEffectSequenceLoopCount","verifyWaveformSegment","waveformSegment","amplitude","verifyWaveformSegments","waveformSegments","createWaveformEffectsData","includeAllWaveformEffectSegments","includeAllWaveformEffectSegmentLoopCounts","dataArray","bitOffset","verifyVibrationType","vibrationType","VibrationTypes","vibrationTypeIndex","triggerVibration","vibrationConfigurations","triggerVibrationData","vibrationConfiguration","vibrationLocations","segments","onVibrationLocations","_console$s","MinWifiSSIDLength","MaxWifiSSIDLength","MinWifiPasswordLength","MaxWifiPasswordLength","WifiMessageTypes","RequiredWifiMessageTypes","WifiEventTypes","WifiManager","isWifiAvailable","updateIsWifiAvailable","updatedIsWifiAvailable","wifiSSID","updateWifiSSID","updatedWifiSSID","wifiConnectionEnabled","newWifiSSID","setWifiSSIDData","wifiPassword","updateWifiPassword","updatedWifiPassword","newWifiPassword","setWifiPasswordData","updateWifiConnectionEnabled","setWifiConnectionEnabled","newWifiConnectionEnabled","toggleWifiConnection","enableWifiConnection","disableWifiConnection","isWifiConnected","updateIsWifiConnected","updatedIsWifiConnected","ipAddress","updateIpAddress","updatedIpAddress","isWifiSecure","updateIsWifiSecure","updatedIsWifiSecure","ssid","password","_console$r","hexToRGB","hex","parseInt","substring","g","blackColor","stringToRGB","startsWith","colorName","temp","style","color","body","appendChild","removeChild","colorNameToRGB","rgbToHex","v","toHex","colorDistanceSq","defaultKMeansOptions","useInputColors","maxIterations","DisplayAlignments","DisplayAlignmentDirections","DisplayDirections","DefaultDisplayContextState","backgroundColorIndex","fillColorIndex","lineColorIndex","ignoreFill","ignoreLine","fillBackground","lineWidth","rotation","horizontalAlignment","verticalAlignment","segmentStartCap","segmentEndCap","segmentStartRadius","segmentEndRadius","cropTop","cropRight","cropBottom","cropLeft","rotationCropTop","rotationCropRight","rotationCropBottom","rotationCropLeft","bitmapScaleX","bitmapScaleY","spriteScaleX","spriteScaleY","spriteSheetName","spritesLineHeight","spritesDirection","spritesLineDirection","spritesSpacing","spritesLineSpacing","spritesAlignment","spritesLineAlignment","isDirectionPositive","isDirectionHorizontal","deepEqual","obj1","obj2","keys1","keys2","_console$q","DisplayContextStateHelper","state","isSegmentUniform","diff","other","differences","newState","_console$p","rotationRad","rotationDeg","minDisplayScale","maxDisplayScale","formatScale","bitmapScale","roundScale","step","round","assertValidSegmentCap","segmentCap","DisplaySegmentCaps","assertValidDisplayBrightness","displayBrightness","DisplayBrightnesses","assertValidColorValue","assertValidColor","assertValidOpacity","DisplayCropDirections","DisplayCropDirectionToStateKey","top","right","bottom","left","DisplayCropDirectionToCommandType","DisplayRotationCropDirectionToStateKey","DisplayRotationCropDirectionToCommandType","DisplayAlignmentDirectionToCommandType","horizontal","vertical","DisplayAlignmentDirectionToStateKey","pixelDepthToNumberOfColors","pixelDepth","pixelDepthToPixelsPerByte","numberOfColorsToPixelDepth","numberOfColors","DisplayPixelDepths","DisplayBitmapScaleDirectionToCommandType","DisplaySpriteScaleDirectionToCommandType","assertValidAlignment","alignment","assertValidDirection","displayCurveTypeToNumberOfControlPoints","segment","quadratic","cubic","assertValidNumberOfControlPoints","curveType","controlPoints","isPath","numberOfControlPoints","assertValidPathNumberOfControlPoints","assertValidPath","curves","curve","points","edges","edge","startIndex","endIndex","_edges","pointIndices","splice","point","mergeWireframes","wireframe","pointIndexOffset","trimWireframe","intersectWireframes","ignoreDirection","bPointIndex","aPointIndices","aPointIndex","bPointIndices","bStartIndex","bEndIndex","startPoint","endPoint","trimmedStartIndex","trimmedPoints","trimmedEndIndex","trimmedEdge","trimmedEdgeIndex","trimmedEdges","getPointDataType","pointDataType","serializePoints","DisplayPointDataTypes","pointDataSize","displayPointDataTypeToSize","dataViewLength","setInt8","RgbQuant","opts","boxSize","palLocked","histogram","idxrgb","palette","idxi32","i32idx","i32rgb","reIndex","colorDist","distManhattan","distEuclidean","rgb","i32","HueStats","numGroups","minCols","stats","num","cols","groupsFull","img","colorStats1D","buf32","colorStats2D","reduce","retType","dithKern","dithSerp","out32","dither","getImageData","len","out","kernel","serpentine","FloydSteinberg","FalseFloydSteinberg","Stucki","Atkinson","Jarvis","Burkes","Sierra","TwoSierra","SierraLite","ds","kernels","dir","lni","xend","idx","r1","g1","b1","r2","i32x","g2","b2","dithDelta","er","eg","eb","lni2","y1","r4","histG","sorted","obj","keys","sortedHashKeys","initColors","freq","pos","hueStats","inject","reducePal","noSort","cacheHistogram","tuples","buildPal","keep","uniques","pruned","prunePal","colors","thold","initDist","palLen","pxi","pxj","i32j","dist","memDist","distIncr","k","col","check","boxH","area","boxW","boxes","wrem","wid","w0","hrem","hgt","h0","bxs","w","h","yend","makeBoxes","box","effc","boxPxls","histL","cnt","incr","i0","call","idxB","rgbA","idxA","rgbB","hslA","rgb2hsl","hslB","hueA","hueGroup","hueGroups","hueDiff","lumDiff","satDiff","useCache","cacheFreq","nearestIndex","hg","gr","typeOf","Pr","Pg","rgb0","rgb1","manhMax","Pb","rd","abs","gd","bd","s","d","hue","segs","seg","haf","mid","val","split","join","ord","can","createElement","naturalWidth","naturalHeight","ctx","getContext","canvas","imgd","buf8","module","exports","commonjsGlobal","_console$o","DisplayContextCommandTypes","DisplaySpriteContextCommandTypes","serializeContextCommand","displayManager","colorIndex","colorRGB","colorHex","assertValidColorIndex","opacity","opacities","assertValidLineWidth","alignmentEnum","isRadians","formatRotation","segmentCapEnum","segmentRadius","bitmapColorIndex","bitmapColorPairs","bitmapColorIndices","setInt16","spriteColorIndex","spriteColorPairs","spriteColorIndices","spriteScale","offsetX","offsetY","borderRadius","numberOfSides","pointsDataView","edgesDataView","controlPoint","allControlPoints","typesDataView","typeByteIndex","typeValue","controlPointsDataViews","controlPointsDataView","controlPointsBuffer","radius","startAngle","angleOffset","Int16Max","radiusX","radiusY","assertValidBitmap","bitmap","pixels","bitmapData","pixelDataLength","getBitmapNumberOfBytes","pixelsPerByte","byteSlot","pixelIndex","pixelBitWidth","pixelDepthToPixelBitWidth","shift","byteIndex","getBitmapData","spriteSheetIndex","spriteSerializedLines","spriteLines","subSpriteLine","subLineSpriteIndicesDataView","spriteIndex","subLineHeaderDataView","concatenatedSubLineArrayBuffers","subLineArrayBuffers","concatenatedLineArrayBuffers","lineArrayBuffers","contextCommandDependencies","appendContextCommandDependencyPair","set","defineProperty","codePointAt","$defineProperty","result","TypeError","size","second","first","configurable","writable","Tree","Uint16Array","trans","Data","dest","sourceIndex","tag","bitcount","destLen","ltree","dtree","sltree","sdtree","length_bits","length_base","dist_bits","dist_base","clcidx","code_tree","lengths","tinf_build_bits_base","bits","base","delta","sum","offs","tinf_build_tree","t","off","tinf_getbit","bit","tinf_read_bits","tinf_decode_symbol","cur","tinf_decode_trees","lt","dt","hlit","hdist","hclen","clen","sym","prev","tinf_inflate_block_data","tinf_inflate_uncompressed_block","tinf_build_fixed_trees","tinyInflate","bfinal","res","subarray","derive","v0","v1","v2","v3","pow","BoundingBox","x1","NaN","x2","y2","Path","commands","stroke","strokeWidth","fail","argument","predicate","isEmpty","isNaN","addPoint","addX","addY","addBezier","x0","y0","p0","p1","p2","p3","c","b2ac","t1","t2","addQuad","cp1x","cp1y","cp2x","cp2y","moveTo","lineTo","curveTo","bezierCurveTo","quadTo","quadraticCurveTo","close","closePath","extend","pathOrCommands","apply","getBoundingBox","startX","startY","prevX","prevY","cmd","draw","beginPath","fillStyle","strokeStyle","toPathData","decimalPlaces","floatToString","toFixed","packValues","arguments$1","arguments","toSVG","svg","toDOMElement","temporaryPath","newPath","createElementNS","setAttribute","LIMIT32","decode$1","encode$1","sizeOf","constant","BYTE","CHAR","CHARARRAY","USHORT","SHORT","UINT24","ULONG","LONG","FIXED","FWORD","UFWORD","LONGDATETIME","TAG","Card8","Card16","OffSize","SID","NUMBER16","NUMBER32","NUMBER","m","exec","epsilon","parseFloat","nibbles","ii","i$1","ii$1","substr","REAL","NAME","STRING","codePoints","numChars","numBytes","codepoint","UTF16","eightBitMacEncodings","macintosh","dataLength","macEncodingCacheKeys","macEncodingTableCache","WeakMap","isByteEncodable","encodeVarDeltaRunAsZeroes","deltas","runLength","numDeltas","encodeVarDeltaRunAsBytes","encodeVarDeltaRunAsWords","e","cacheKey","cachedTable","decodingTable","encodingTable","getMacEncodingTable","str","MACSTRING","offsets","l","OBJECT","encodedOffsets","offSize","offsetEncoder","encodedOffset","concat","INDEX","OPERAND","OPERATOR","DICT","OP","wmm","Table","tableName","fields","field","optionKeys","ushortList","itemName","list","count","tableList","records","itemCallback","recordList","Coverage","coverageTable","format","glyphs","ranges","RangeRecord","ScriptList","scriptListTable","scriptRecord","script","defaultLangSys","reqFeatureIndex","featureIndexes","langSysRecords","langSysRecord","langSys","FeatureList","featureListTable","featureRecord","feature","featureParams","lookupListIndexes","LookupList","lookupListTable","subtableMakers","lookupTable","subtableCallback","lookupType","lookupFlag","subtables","cachedValue","ops","op","CHARSTRING","encodingFunction","sizeOfFunction","subtableOffsets","bytes","o","TABLE","RECORD","LITERAL","Record","getByte","getUShort","getULong","getFixed","typeOffsets","byte","uShort","short","uLong","fixed","longDateTime","Parser","relativeOffset","parseByte","parseChar","getInt8","parseCard8","parseUShort","parseCard16","parseSID","parseOffset16","parseShort","parseF2Dot14","parseULong","parseOffset32","parseFixed","parseString","parseTag","parseLongDateTime","parseVersion","minorBase","major","minor","skip","amount","parseULongList","parseOffset16List","parseUShortList","parseShortList","parseByteList","parseList","parseList32","parseRecordList","recordDescription","rec","fieldName","fieldType","parseRecordList32","parseStruct","description","struct","parseValueRecord","valueFormat","valueRecord","xPlacement","yPlacement","xAdvance","yAdvance","xPlaDevice","yPlaDevice","xAdvDevice","yAdvDevice","parseValueRecordList","valueCount","parsePointer","structOffset","parsePointer32","parseListOfLists","subOffsets","subList","parseCoverage","startOffset","parseClassDef","startGlyph","classId","list32","recordList32","pointer","pointer32","offset16","uShortList","offset32","uLongList","coverage","classDef","langSysTable","reserved","parseScriptList","parseFeatureList","parseLookupList","lookupTableParsers","useMarkFilteringSet","markFilteringSet","parseFeatureVariationsList","majorVersion","minorVersion","conditionSetOffset","featureTableSubstitutionOffset","getCard8","getCard16","getShort","getTag","getOffset","getBytes","endOffset","bytesToString","addSegment","code","glyphIndex","cmap","version","numTables","platformId","encodingId","p","groupCount","language","glyphIndexMap","startCharCode","endCharCode","startGlyphId","parseCmapTableFormat12","segCount","endCountParser","startCountParser","idDeltaParser","idRangeOffsetParser","glyphIndexOffset","endCount","startCount","idDelta","idRangeOffset","parseCmapTableFormat4","make","isPlan0Only","unicode","cmapTable","glyph","unicodes","addTerminatorSegment","segCountToRemove","endCounts","startCounts","idDeltas","idRangeOffsets","glyphIds","cmap12Groups","glyphId","segCountX2","searchRange","entrySelector","rangeShift","cmap4Length","cmap12Length","cmap12Offset","cffStandardStrings","cffStandardEncoding","cffExpertEncoding","standardNames","DefaultEncoding","font","CmapEncoding","CffEncoding","charset","GlyphNames","post","names","numberOfGlyphs","glyphNameIndex","addGlyphNames","opt","lowMemory","_IndexToUnicodeMap","tables","charCodes","addGlyphNamesToUnicodeMap","addUnicode","cffEncoding","isCIDFont","glyphNames","glyphIndexToName","addGlyphNamesAll","charToGlyphIndex","charName","nameToGlyphIndex","gid","line","Glyph","bindConstructorValues","defineDependentProperty","externalName","internalName","path","newValue","enumerable","GlyphSet","unitsPerEm","_path","xMin","yMin","xMax","yMax","advanceWidth","getPath","fontSize","hPoints","xScale","yScale","hinting","getCommands","scale","getContours","contours","currentContour","lastPointOfContour","getMetrics","xCoords","yCoords","metrics","leftSideBearing","isFinite","rightSideBearing","drawPoints","drawCircles","arc","blueCircles","redCircles","drawMetrics","_push","unicodeObj","_hmtxTableData","loader","glyphset","glyphLoader","ttfGlyphLoader","parseGlyph","buildPath","cffGlyphLoader","parseCFFCharstring","charstring","equals","calcCFFSubroutineBias","subrs","parseCFFIndex","conversionFn","objectOffset","objects","offsetSize","parseOperand","parser","b0","lookup","n1","n2","parseFloatOperand","parseCFFDict","entries","operands","hasOwnProperty","entriesToObject","getCFFString","strings","interpretDict","dict","meta","newDict","TOP_DICT_META","PRIVATE_DICT_META","parseCFFTopDict","parseCFFPrivateDict","gatherCFFTopDicts","cffIndex","topDictArray","iTopDict","topDict","_subrs","_subrsBias","_defaultWidthX","_nominalWidthX","privateSize","private","privateOffset","privateDict","defaultWidthX","nominalWidthX","subrIndex","_privateDict","c1x","c1y","c2x","c2y","subrsBias","nStems","haveWidth","open","fdIndex","cff","_fdSelect","fdDict","_fdArray","newContour","parseStems","b3","b4","codeIndex","subrCode","jpx","jpy","c3x","c3y","c4x","c4y","pop","gsubrsBias","gsubrs","encodeString","sid","makeDict","attrs","entry","makeTopDict","makeTopDictIndex","topDicts","glyphToOps","dx","dy","_13","_23","dx1","dy1","dx2","dy2","header","formatMajor","formatMinor","parseCFFHeader","nameIndex","topDictIndex","stringIndex","globalSubrIndex","ros","fdArrayOffset","fdArray","fdSelectOffset","fdSelect","fdArrayIndex","nGlyphs","fdArrayCount","iGid","next","nRanges","iRange","parseCFFFDSelect","numGlyphs","charStringsIndex","privateDictOffset","subrOffset","parseCFFIndexLowMemory","charStrings","i$2","parseCFFCharset","enc","nCodes","nLeft","parseCFFEncoding","charString","getCffIndexObject","fontScale","fullName","familyName","weight","weightName","fontBBox","fontMatrix","fontNames","makeNameIndex","postScriptName","charsets","glyphSID","makeCharsets","makeCharStringsIndex","makePrivateDict","makeStringIndex","head","fontRevision","checkSumAdjustment","magicNumber","flags","created","modified","macStyle","lowestRecPPEM","fontDirectionHint","indexToLocFormat","glyphDataFormat","getTime","createdTimestamp","hhea","ascender","descender","lineGap","advanceWidthMax","minLeftSideBearing","minRightSideBearing","xMaxExtent","caretSlopeRise","caretSlopeRun","caretOffset","metricDataFormat","numberOfHMetrics","hmtx","numMetrics","parseHmtxTableOnLowMemory","parseHmtxTableAll","ltag","tags","stringPool","stringPoolOffset","tableVersion","numTags","maxp","maxPoints","maxContours","maxCompositePoints","maxCompositeContours","maxZones","maxTwilightPoints","maxStorage","maxFunctionDefs","maxInstructionDefs","maxStackElements","maxSizeOfInstructions","maxComponentElements","maxComponentDepth","nameTableNames","macLanguages","macLanguageToScript","windowsLanguages","getLanguageCode","platformID","languageID","utf16","macScriptEncodings","macLanguageEncodings","getEncoding","encodingID","reverseDict","makeNameRecord","nameID","addStringToPool","pool","needle","haystack","needleLength","limit","loop","findSubArray","_name","stringOffset","property","text","translations","nameIDs","namesWithNumericKeys","nameTableIds","macLanguageIds","windowsLanguageIds","nameRecords","lang","macPlatform","macLanguage","macScript","macEncoding","macName","macNameOffset","winLanguage","winName","winNameOffset","unicodeRanges","os2","xAvgCharWidth","usWeightClass","usWidthClass","fsType","ySubscriptXSize","ySubscriptYSize","ySubscriptXOffset","ySubscriptYOffset","ySuperscriptXSize","ySuperscriptYSize","ySuperscriptXOffset","ySuperscriptYOffset","yStrikeoutSize","yStrikeoutPosition","sFamilyClass","panose","ulUnicodeRange1","ulUnicodeRange2","ulUnicodeRange3","ulUnicodeRange4","achVendID","fsSelection","usFirstCharIndex","usLastCharIndex","sTypoAscender","sTypoDescender","sTypoLineGap","usWinAscent","usWinDescent","ulCodePageRange1","ulCodePageRange2","sxHeight","sCapHeight","usDefaultChar","usBreakChar","usMaxContent","getUnicodeRange","italicAngle","underlinePosition","underlineThickness","isFixedPitch","minMemType42","maxMemType42","minMemType1","maxMemType1","nameLength","subtableParsers","substFormat","deltaGlyphId","substitute","sequences","alternateSets","ligatureSets","ligGlyph","components","lookupRecordDesc","sequenceIndex","lookupListIndex","ruleSets","glyphCount","substCount","input","lookupRecords","classSets","coverages","chainRuleSets","backtrack","lookahead","backtrackClassDef","inputClassDef","lookaheadClassDef","chainClassSet","backtrackCoverage","inputCoverage","lookaheadCoverage","extensionLookupType","extensionParser","extension","substitutes","subtable","sequenceSet","alternateSet","ligatureSet","ligature","returnTable","chainRuleSet","chainRule","tableData","record","gsub","scripts","features","lookups","variations","numDataMaps","dataOffset","UTF8","log2","computeCheckSum","makeTableRecord","checkSum","makeSfntTable","sfnt","highestPowerOf2","recordFields","tableFields","tableLength","tableRecord","metricsForChar","chars","notFoundMetrics","average","vs","fontToTable","firstCharIndex","xMins","yMins","xMaxs","yMaxs","advanceWidths","leftSideBearings","rightSideBearings","lastCharIndex","globals","advanceWidthAvg","maxLeftSideBearing","headTable","hheaTable","maxpTable","os2Table","hasChar","hmtxTable","englishFamilyName","getEnglishName","englishStyleName","englishFullName","replace","n","uniqueID","en","preferredFamily","fontFamily","preferredSubfamily","fontSubfamily","languageTags","nameTable","ltagTable","postTable","cffTable","metaTable","metas","sfntTable","checkSumAdjusted","searchTag","arr","imin","imax","imid","binSearch","Layout","Position","Substitution","arraysEqual","ar1","ar2","getSubstFormat","defaultSubtable","nodeBufferToArrayBuffer","ab","checkArgument","expression","parseGlyphCoordinate","flag","previousValue","shortVectorBitMask","sameBitMask","numberOfContours","_xMin","_yMin","_xMax","_yMax","endPointIndices","instructionLength","instructions","numberOfCoordinates","repeatCount","i$3","onCurve","px","i$4","py","i$5","isComposite","moreComponents","component","scale01","scale10","matchedPoints","i$6","transformPoints","transform","newPoints","newPt","contourIndex","contour","curr","next2","componentGlyph","transformedPoints","firstPt","secondPt","getTable","layout","createDefaultTable","getScriptNames","getDefaultScriptName","hasLatn","getScriptTable","scr","getLangSysTable","scriptTable","getFeatureTable","featIndexes","allFeatures","params","getLookupTables","featureTable","allLookups","getGlyphClass","classDefTable","getCoverageIndex","expandCoverage","init","defaultKerningTables","getKerningTables","getKerningValue","kerningLookups","leftIndex","rightIndex","covIndex","posFormat","pairSet","pairSets","pair","secondGlyph","value1","class1","classDef1","class2","classDef2","pair$1","classRecords","gpos","getSingle","substitutions","lookupTables","sub","by","getMultiple","replacements","getAlternates","alternates","getLigatures","ligatures","ligSet","lig","addSingle","substitution","coverageGlyph","addMultiple","addAlternate","addLigature","ligComponents","ligatureTable","getFeature","instructionTable","execGlyph","execComponent","glyf","loca","parseGlyfTableOnLowMemory","parseGlyfTableAll","Hinting","_fpgmState","_prepState","_errorState","roundOff","roundToGrid","roundToDoubleGrid","roundToHalfGrid","roundUpToGrid","ceil","roundDownToGrid","roundSuper","period","srPeriod","phase","srPhase","srThreshold","trunc","xUnitVector","axis","distance","o1","o2","xo","interpolate","rp1","rp2","pv","do1","do2","doa1","doa2","dm1","dm2","setRelative","normalSlope","NEGATIVE_INFINITY","rp","org","rpx","rpy","yo","rpdx","rpdy","slope","touch","xTouched","touched","untouch","yUnitVector","POSITIVE_INFINITY","yTouched","UnitVector","freeze","getUnitVector","HPoint","prevPointOnContour","nextPointOnContour","preventExtensions","pvns","fvs","nextTouched","prevTouched","HPZero","defaultState","cvCutIn","deltaBase","deltaShift","minDis","autoFlip","State","env","prog","zp0","zp1","zp2","rp0","fv","dpv","initTZone","tZone","gZone","handleElse","ins","ip","nesting","SVTCA","DEBUG","SPVTCA","SFVTCA","SPVTL","p2i","p1i","z2","z1","SFVTL","POP","MDAP","pi","z0","IUP","cp","pp","np","pLen","SHP","rpi","SHC","ci","sp","SHZ","MSIRP","MIAP","cv","cvt","GC","MD","pi2","pi1","DELTAP123","ppem","arg","mag","ROUND$1","DELTAC123","SDPVTL","PUSHB","PUSHW","MDRP_MIRP","indirect","setRp0","keepD","ro","od","cvte","rp0i","md","Token","char","activeState","ContextRange","contextName","ContextChecker","checkStart","checkEnd","openRange","ContextParams","currentIndex","current","Event","eventId","subscribers","initializeCoreEvents","events","this$1$1","coreEvents","subscribe","updateContextsRanges","Tokenizer","tokens","registeredContexts","contextCheckers","registeredModifiers","isArabicChar","isIsolatedArabicChar","isTashkeelArabicChar","isLatinChar","FeatureQuery","SubstitutionAction","action","lookupCoverage","singleSubstitutionFormat1","singleSubstitutionFormat2","substituteIndex","lookupCoverageList","coverageList","contextParams","lookupList","lookupIndex","chainingSubstitutionFormat3","lookupsCount","inputLookups","lookaheadOffset","lookaheadContext","lookaheadParams","lookaheadLookups","backtrackContext","reverse","backtrackParams","backtrackLookups","getLookupByIndex","subtable$1","getLookupMethod","getSubstitutionType","ligatureSubstitutionFormat1","ligSetIndex","decompositionSubstitutionFormat1","prepState","fpgmState","fpgm","funcs","prep","oCvt","cg","gz","cc","gLen","inhibitGridFit","pa0i","pa1i","pb0i","pb1i","pa0","pa1","pb0","pb1","x3","y3","x4","y4","div","f1","f2","cip","cprog","ipBegin","rp1i","rp2i","store","e2","e1","sel","ignoreCvt","setState","getState","stateId","inboundIndex","composeRUD","RUDs","RUD","hasFAILObject","FAIL","report","dispatch","replaceRange","silent","isTokenType","token","replaced","replaceToken","removeRange","removeToken","insertToken","registerModifier","modifierId","modifier","newToken","conditionParams","modifierParams","newStateValue","eventHandler","unsubscribe","subsId","setCurrentIndex","rangeToText","getRangeTokens","getText","on","eventName","subscriber","registerContextChecker","contextStartCheck","contextEndCheck","getContextRanges","resetContextsRanges","runContextCheck","setEndOffset","rangeId","contextChecker","tokenize","getDefaultScriptFeaturesIndexes","getScriptFeaturesIndexes","scriptTag","mapTagsToFeatures","getScriptFeatures","featuresIndexes","lookupFeature","query","getFeatureLookups","getLookupSubtables","substType","supports","supportedScript","supportedFeature","scriptFeatures","arabicWordCheck","startCheck","prevChar","endCheck","nextChar","arabicSentenceCheck","nextIsWhitespace","arabicCharAhead","SUBSTITUTIONS","subst","compsCount","applySubstitution","arabicPresentationForms","featuresTags","tokenizer","charContextParams","CONNECT","isolated","tashkeel","willConnectPrev","willConnectNext","info","getContextParams","arabicRequiredLigatures","latinWordCheck","getContextParams$1","latinLigature","Bidi","baseDir","checkId","contextChecks","tokenizeText","reverseArabicSentences","rangeTokens","checkGlyphIndexStatus","applyArabicPresentationForms","applyArabicRequireLigatures","applyLatinLigatures","Font","empty","styleName","designer","designerURL","manufacturer","manufacturerURL","license","licenseURL","copyright","trademark","weightClass","usWeightClasses","MEDIUM","widthClass","usWidthClasses","fsSelectionValues","REGULAR","supported","_hinting","outlinesFormat","addName","nameString","JSON","stringify","nameKey","makeFvarAxis","minValue","defaultValue","parseFvarAxis","makeFvarInstance","inst","axes","axisTag","coordinates","parseFvarInstance","setText","registerFeatures","supportedTags","applyFeatures","f","checkContextReady","contextId","applyFeaturesToContexts","processText","getBidiText","getTextGlyphs","indexes","deleted","charToGlyph","updateFeatures","defaultRenderOptions","stringToGlyphs","bidi","notdef","nameToGlyph","leftGlyph","rightGlyph","gposKerning","kerningPairs","kerning","forEachGlyph","letterSpacing","tracking","fullPath","gX","gY","gFontSize","glyphPath","getPaths","glyphPaths","getAdvanceWidth","validate","_this","assertNamePresent","englishName","trim","toTables","toBuffer","toArrayBuffer","intArray","download","fileName","URL","webkitURL","link","href","createObjectURL","createEvent","initEvent","fs","require","Buffer","arrayBufferToNodeBuffer","writeFileSync","ITALIC","UNDERSCORE","NEGATIVE","OUTLINED","STRIKEOUT","BOLD","USER_TYPO_METRICS","WWS","OBLIQUE","ULTRA_CONDENSED","EXTRA_CONDENSED","CONDENSED","SEMI_CONDENSED","SEMI_EXPANDED","EXPANDED","EXTRA_EXPANDED","ULTRA_EXPANDED","THIN","EXTRA_LIGHT","LIGHT","NORMAL","SEMI_BOLD","EXTRA_BOLD","BLACK","fvar","instances","offsetToData","axisCount","axisSize","instanceCount","instanceSize","instanceStart","attachList","attachPoints","caretValue","coordinate","pointindex","ligCaretList","ligGlyphs","markGlyphSets","gdef","markAttachClassDef","subtableParsers$1","posformat","valueFormat1","valueFormat2","value2","class1Count","class2Count","subtableMakers$1","kern","pairs","subtableVersion","nPairs","parseWindowsKernTable","parseMacKernTable","shortVersion","parseFn","glyphOffsets","glyphOffset","loadFromFile","readFile","err","loadFromUrl","request","XMLHttpRequest","responseType","onload","statusText","onerror","parseOpenTypeTableEntries","tableEntries","compression","uncompressTable","tableEntry","inBuffer","compressedLength","outBuffer","parseBuffer","cffTableEntry","fvarTableEntry","glyfTableEntry","gdefTableEntry","gposTableEntry","gsubTableEntry","hmtxTableEntry","kernTableEntry","locaTableEntry","nameTableEntry","metaTableEntry","signature","flavor","compLength","origLength","parseWOFFTableEntries","locaTable","locaOffsets","glyfTable","kernTable","gdefTable","gposTable","gsubTable","fvarTable","A","opentype","__proto__","_parse","load","loadFn","isUrl","reject","loadSync","readFileSync","ready","C","B","Q","E","D","G","Y","F","N","K","R","H","Z","M","W","currentScript","src","lastIndexOf","print","printErr","thisProgram","quit","wasmBinary","noExitRuntime","WebAssembly","X","HEAP8","Int8Array","HEAP16","HEAPU8","HEAPU16","HEAP32","Int32Array","HEAPU32","HEAPF32","HEAPF64","Float64Array","S","q","V","onAbort","RuntimeError","u","locateFile","excPtr","ptr","set_type","get_type","set_destructor","get_destructor","set_caught","get_caught","set_rethrown","get_rethrown","set_adjusted_ptr","get_adjusted_ptr","get_exception_ptr","AP","P","T","AA","ignoreDuplicateRegistrations","I","Ag","allocated","freelist","AC","AB","refcount","free","AI","allocate","AQ","fromWireType","AE","Aw","AD","AG","Ai","overloadTable","argCount","Ao","numArguments","AY","Ac","Ah","AF","AN","As","Aa","Ar","AO","AH","Ak","AW","Ay","Ad","AU","Ap","Ab","Al","AS","Am","Aq","AX","grow","BindingError","super","InternalError","has","count_emval_handles","UnboundTypeError","Ax","toWireType","argPackAdvance","readValueFromPointer","destructorFunction","AL","AK","AR","$","Function","Uint8ClampedArray","AM","Av","AJ","AZ","isVoid","At","copyWithin","An","Aj","unshift","monitorRunDependencies","instantiateWasm","then","atob","instantiate","instance","catch","__embind_initialize_bindings","Az","calledRun","onRuntimeInitialized","postRun","preRun","setStatus","setTimeout","preInit","getSqSegDist","last","sqDist","maxSqDist","sqTolerance","simplifyDPStep","simplified","simplifyDouglasPeucker","simplify","tolerance","highestQuality","prevPoint","default","_classCallCheck","Constructor","item","leftTangent","createTangent","rightTangent","fitCubic","maxError","progressCallback","bezCurve","uPrime","centerVector","toCenterTangent","fromCenterTangent","beziers","MaxIterations","_generateAndReport","generateAndReport","chordLengthParameterize","splitPoint","_generateAndReport2","prevSplit","errChange","prevErr","maths","subtract","_ref","normalize","generateBezier","paramsPrime","_computeMaxError","maxPoint","det_C0_C1","det_C0_X","det_X_C1","alpha_l","alpha_r","segLength","tmp","ux","firstPoint","parameters","mulItems","dot","vectorLen","lastPoint","addArrays","bezier","bez","denominator","squareItems","qprime","mulMatrix","qprimeprime","numerator","currU","prevU","prevP","maxDist","find_t","t_distMap","B_t_curr","B_t_dist","B_t_prev","B_parts","sumLen","param","tMin","tMax","lenMin","pointA","pointB","zs","items","arr2","divItems","tx","pA","ctrlPoly","pB","pC","pD","fitCurve","perpendicularDistance","hypot","projX","projY","rdp","cursor","isFirst","lastCommand","sampled","steps","sampleQuadratic","at","mt","sampleCubic","simplifyPoints","simplifyPointsAsCubicCurveControlPoints","isBuffer_1","isBuffer","isSlowBuffer","_isBuffer","kindOf","RegExp","createCommonjsModule","renameKeys","rename","cb","eventemitter3","_events","Events","_eventsCount","getOwnPropertySymbols","EventEmitter","exists","available","evt","ee","removeListener","a1","a2","EE","prefixed","prefix","noop","attributeValue","Action","space","gt","quote","equal","getAction","create$1","_State$data","_State$tagBegin","_State$tagName","_State$tagEnd","_State$attributeNameS","_State$attributeName","_State$attributeNameE","_State$attributeValue","_State$attributeValue2","_lexer$stateMachine","debug","lexer","tagName","emit","stateMachine","_defineProperty","Type$1","tagBegin","tagEnd","attributeNameStart","openTag","closeTag","cdata","attributeName","attributeNameEnd","attrName","attributeValueBegin","attrValue","openingQuote","slash","write","Type","createNode","NodeType","element","children","lexer$1","reader","handleLexerData","parent","parentNodes","rootNode","tagPrefix","removeAllListeners","attributes","reader_1","stream","xml","parseInput","parsed","camelize","deepRenameKeys","notCamelcase","toCamelCase","prop","letter","toUpperCase","escapeText","escapeAttr","attr","svgsonSync","_ref$transformNode","transformNode","_ref$camelcase","camelcase","applyFilters","_ast","_ref$transformAttr","transformAttr","escape","_ref$selfClose","selfClose","ast","attrStr","WSP","rotate","cos","sin","assertNumbers","numbers","annotateArcCommand","lArcFlag","sweepFlag","rX","rY","cX","cY","phi1","phi2","xRotRad","xRot","x1_","y1_","testValue","c_ScaleTemp","c_Scale","cx_","cy_","cRot","atan2","intersectionUnitCircleLine","termSqr","term","DEG","lerp","arcAt","phiDeg","bezierRoot","EPS","x01","x12","PRECISION","discriminantX4","root","pqFormula","bezierAt","arePointsCollinear","v1x","v1y","v2x","v2y","cross","lenSqV2","reverseSubpath","isExplicitlyClosed","SVGPathData","CLOSE_PATH","startPointIndex","reversed","MOVE_TO","relative","curCmd","HORIZ_LINE_TO","VERT_LINE_TO","LINE_TO","CURVE_TO","SMOOTH_CURVE_TO","SMOOTH_QUAD_TO","ARC","QUAD_TO","TO_ABS","INFO","NORMALIZE_ST","prevCurveC2X","prevCurveC2Y","prevQuadCX","prevQuadCY","QT_TO_C","prevQuadX1","prevQuadY1","prevXAbs","prevYAbs","pathStartXAbs","pathStartYAbs","MATRIX","pathStartX","origX1","origX2","comRel","sqr","det","sinRot","cosRot","xCurve","yCurve","A1","B1","C1","newXRot","newSinRot","newCosRot","CLONE","SVGPathDataTransformer","ROUND","roundVal","rf","TO_REL","NORMALIZE_HVZ","normalizeZ","normalizeH","normalizeV","normalizeC","pathStartY","control1","control2","SANITIZE","x1Rel","y1Rel","LINE_COMMANDS","xRel","yRel","x2Rel","y2Rel","ROTATE","TRANSLATE","dX","dY","SCALE","SKEW_X","tan","SKEW_Y","X_AXIS_SYMMETRY","xOffset","Y_AXIS_SYMMETRY","yOffset","A_TO_C","phiMin","deltaPhi","partCount","xTemp","yTemp","phiStart","phiEnd","cp1","cp2","a2c","ANNOTATE_ARCS","CALCULATE_BOUNDS","clone","toAbs","qtToC","normST","fixX","absX","maxX","minX","fixY","absY","maxY","minY","DRAWING_COMMANDS","xDerivRoots","derivRoot","yDerivRoots","x90","y90","phiMax","normalizeXiEta","eta","phi","REVERSE_PATH","preserveSubpathOrder","normalized","processing","original","REMOVE_COLLINEAR","results","pXAbs","pYAbs","isRelatve","nextCmd","nextPoint","TransformableSVG","toRel","normalizeHVZ","normalizeST","aToC","sanitize","eps","translate","matrix","skewX","skewY","xSymmetry","ySymmetry","annotateArcs","isWhiteSpace","isDigit","SVGPathDataParser","curNumber","curCommandType","curCommandRelative","canParseCommandOrComma","curNumberHasExp","curNumberHasExpDigits","curNumberHasDecimal","curArgs","finish","SyntaxError","finishCommand","isAArcFlag","isEndingDigit","COMMAND_ARG_COUNTS","chunk","parsedCommands","cT","content","getBounds","boundsTransform","transformFunction","newCommands","transformedCommand","removeCollinear","encodeSVGPath","_console$n","identity","multiply","applyTransform","circleBezierConstant","svgJsonToCanvasCommands","svgJson","traverse","parentTransform","transformStr","part","argsStr","angle","cx","cy","isScaleUniform","ty","scaleX","scaleY","decomposeTransform","nodeTransform","uniformScale","styleStr","fillRule","pathData","c1","c2","ce","qcp","qe","rx","ry","tr","br","bl","ox","oy","p4","p5","p6","p7","p8","pTop","pRight","pBottom","pLeft","cpTopRight","cpRightTop","cpRightBottom","cpBottomRight","cpBottomLeft","cpLeftBottom","cpLeftTop","cpTopLeft","acc","fontStyle","fontWeight","strokeDasharray","child","getSvgJsonSize","viewBox","relativeTo","getSvgJsonViewBox","defaultParseSvgOptions","fit","centered","transformCanvasCommands","canvasCommands","xCallback","yCallback","cpx","cpy","offsetCanvasCommands","bboxContains","centroid","subpath","subBBox","previous","insideCount","winding","contourArea","SVG_XMLNS","getSvgString","SVGSVGElement","ensureSvgXmlnsFromElement","trimmed","svgText","DOMParser","doc","documentElement","ensureSvgXmlns","pathOrUrl","ok","svgToDisplayContextCommands","svgString","paletteOffset","svgson_umdExports","parseSync","boundingBox","getSvgJsonBoundingBox","intrinsicWidth","intrinsicHeight","aspectRatio","vectorCallback","canvasCommand","svgColors","mapping","bestDist","bestIdx","mapToClosestPaletteIndex","maxIter","colorMap","uniqueColors","uniqueKeys","iter","clusters","cluster","centroids","orig","DisplayColorRGB","kMeansColors","colorToIndex","displayCommands","simplifyCurves","flatMap","isHole","wasHole","parsedPaths","endX","endY","newIgnoreFill","newIgnoreLine","contextState","stringToSpriteLines","spriteSheets","spriteLinesToSerializedLines","dependencies","similarCommandIndex","dependentCommandIndex","trimmedCommand","trimmedCommands","findIndex","trimContextCommands","svgToSprite","spriteName","paletteName","overridePalette","spriteSheet","palettes","sprite","paletteSwaps","sprites","svgToSpriteSheet","getSvgStringFromDataUrl","decodeURIComponent","isValidSVG","querySelector","nodeName","toLowerCase","removeRedundantCharacters","removeSubstrings","substrings","_console$m","serializeSpriteSheet","numberOfSprites","serializedContextCommands","serializedContextCommandArray","serializedSprite","spriteOffsetsDataView","spritePayload","serializedSpriteSheet","defaultFontToSpriteSheetOptions","unicodeOnly","englishOnly","usePath","overrideMaxSpriteHeight","parseFont","isWoff2","decompress","getFontUnicodeRange","englishRegex","fonts","maxSpriteY","filteredGlyphs","hasUnicode","bbox","minSpriteY","maxSpriteHeight","fontToSpriteSheet","getFontMetrics","spriteWidth","bitmapWidth","bitmapHeight","bitmapY","spriteHeight","pathOffset","bitmapX","allCurves","isSegments","_bitmapWidth","_bitmapHeight","imageSmoothingEnabled","fillRect","colorIndices","stringToSprites","requireAll","longestSprite","getReferencedSprites","_sprite","reduceSpriteSheet","spriteNames","reducedSpriteSheet","maxLineBreadth","separators","areSpritesDirectionsOrthogonal","isSpritesDirectionHorizontal","isSpritesLineDirectionHorizontal","latestSeparator","latestSeparatorLineBreadth","latestSeparatorBreadth","latestSeparatorIndex","lineStrings","lineString","spritesLineIndices","lineBreadth","lineSubstring","longestSpriteSheet","isSeparator","newLineBreadth","spriteSubLine","spriteLine","_sprites","getFontMaxHeight","getMaxSpriteSheetSize","getExpandedSpriteLinesSize","expandedSpritesLines","localSize","expandedSpriteLine","spritesLineBreadth","breadthSizeKey","depthSizeKey","lineBreadths","spritesScaledWidth","spritesScaledHeight","_spritesLine","stringToSpriteLinesMetrics","assertLoadedSpriteSheet","serializedSubLine","spriteIndices","use2Bytes","serializedLine","_console$l","drawBitmapHeaderLength","quantizeCanvas","willReadFrequently","quantOptions","orDist","quantizer","RGBQuant","quantizedImageData","quantizedPaletteData","numberOfQuantizedPaletteColors","vector3","quantizedPaletteColors","distanceToBlack","closestColorDistanceToBlack","closestColorIndexToBlack","currentBlack","newBlack","toBlob","quantizedColors","quantizedColorIndices","quantizeImage","image","resizeImage","cropCanvas","targetCanvas","removeAlphaFromCanvas","resizeAndQuantizeImage","imageToBitmap","bitmapColors","canvasToBitmaps","numberOfPixels","maxBitmapWidth","maxBitmapHeight","bitmapRows","bitmapRow","bitmapCanvas","imageToBitmaps","assertValidBitmapPixels","pixel","canvasToSprite","imageToSprite","spriteSheetWithSingleBitmapCommandLength","canvasToSpriteSheet","maxFileLength","spriteCanvas","imageIndex","imageToSpriteSheet","_console$k","runDisplayContextCommand","hide","show","clear","clearRotation","clearCrop","clearRotationCrop","resetBitmapScale","resetSpriteScale","resetAlignment","clearRect","drawRect","drawRoundRect","drawCircle","drawEllipse","drawRegularPolygon","drawSegment","drawSegments","drawArc","drawBitmap","selectedSpriteSheet","drawSprite","spriteSerializedLine","spriteSerializedSubLine","drawSprites","spriteSheetIndices","resetSpriteColors","startSprite","endSprite","runDisplayContextCommands","assertSelectedSpriteSheet","selectedSpriteSheetName","assertAnySelectedSpriteSheet","getSprite","assertSprite","getSpriteSheetPalette","getSpriteSheetPaletteSwap","paletteSwapName","paletteSwap","assertSpriteSheetPalette","displayManagerInterface","assertSpriteSheetPaletteSwap","selectSpriteSheetPalette","indicesOnly","selectSpriteSheetPaletteSwap","selectSpriteColors","selectSpritePaletteSwap","drawSpriteFromSpriteSheet","uploadSpriteSheet","_console$j","DefaultNumberOfDisplayColors","DisplayCommands","DisplayStatuses","DisplayInformationTypes","DisplayMessageTypes","DisplayBezierCurveTypes","displayCurveTypeBitWidth","displayCurveTypesPerByte","displayPointDataTypeToRange","int8","int16","DisplayInformationValues","RequiredDisplayMessageTypes","DisplayEventTypes","MinSpriteSheetNameLength","MaxSpriteSheetNameLength","DisplayManager","isAvailable","parseIsDisplayAvailable","newIsDisplayAvailable","contextStateHelper","onContextStateUpdate","displayContextState","setContextState","difference","selectBackgroundColor","setFillBackground","setIgnoreFill","setIgnoreLine","selectFillColor","selectLineColor","setLineWidth","setHorizontalAlignment","setVerticalAlignment","setSegmentCap","setSegmentStartCap","setSegmentEndCap","setSegmentRadius","setSegmentStartRadius","setSegmentEndRadius","setCropTop","setCropRight","setCropBottom","setCropLeft","setRotationCropTop","setRotationCropRight","setRotationCropBottom","setRotationCropLeft","selectBitmapColors","setBitmapScale","setBitmapScaleX","setBitmapScaleY","spriteColors","setSpriteScale","setSpriteScaleX","setSpriteScaleY","setSpritesLineHeight","setSpritesDirection","setSpritesLineDirection","setSpritesSpacing","setSpritesLineSpacing","setSpritesAlignment","setSpritesLineAlignment","sendContextCommands","displayStatus","isDisplayAwake","parseDisplayStatus","newDisplayStatus","displayStatusIndex","updateDisplayStatus","previousDisplayStatus","sendDisplayCommand","displayInformation","parseDisplayInformation","displayInformationType","displayInformationTypeIndex","parsedDisplayInformation","missingDisplayInformationType","brightness","parseDisplayBrightness","newDisplayBrightness","newDisplayBrightnessEnum","setBrightness","newDisplayBrightnessData","assertValidDisplayContextCommandType","displayContextCommand","maxCommandDataLength","sendContextCommand","contextCommandType","contextCommandBuffers","_arrayBuffer","flushContextCommands","lastShowRequestTime","setColor","setColorOpacity","commandType","setOpacity","saveContext","contextStack","restoreContext","setAlignment","alignmentDirection","alignmentCommand","alignmentKey","setRotation","setCrop","cropDirection","crop","cropCommand","cropKey","setRotationCrop","selectBitmapColor","setBitmapColor","setBitmapColorOpacity","setBitmapScaleDirection","selectSpriteColor","setSpriteColor","setSpriteColorOpacity","setSpriteScaleDirection","setSpritesDirectionGeneric","isOrthogonal","setSpritesSpacingGeneric","spacing","setSpritesAlignmentGeneric","drawPolygon","drawWireframe","isWireframePolygon","drawCurve","drawCurves","drawQuadraticBezierCurve","drawQuadraticBezierCurves","drawCubicBezierCurve","drawCubicBezierCurves","_drawPath","isClosed","drawPath","drawClosedPath","firstHalf","secondHalf","drawArcEllipse","assertValidNumberOfColors","assertValidBitmapSize","runContextCommand","runContextCommands","minReadyInterval","timeSinceLastDraw","timeSinceLastReady","lastReadyTime","timeToWait","setSpriteSheetName","setSpriteSheetNameData","pendingSpriteSheet","pendingSpriteSheetName","updateSpriteSheetName","updatedSpriteSheetName","sendFile","selectSpriteSheet","isDrawingBlankSprite","getSpriteLinesMetrics","firstHalfOffsetX","firstHalfOffsetY","firstHalfSize","secondHalfOffsetX","secondHalfOffsetY","drawSpritesString","parseSpriteSheetIndex","parseDisplayReady","assertSpritePaletteSwap","_console$i","ConnectionTypes","ConnectionStatuses","ConnectionEventTypes","TxRxMessageTypes","BatteryLevelMessageTypes","MetaConnectionMessageTypes","ConnectionMessageTypes","BaseConnectionManager","onStatusUpdated","onMessageReceived","onMessagesReceived","baseConstructor","isSupported","canUpdateFirmware","newConnectionStatus","isConnected","timer","defaultMtu","canReconnect","reconnect","sendTxMessages","isSendingMessages","pendingMessages","AssertValidTxRxMessageType","arrayBufferByteLength","arrayBufferCount","arrayBuffersToSend","sendTxData","parseRxMessage","onRxMessage","Timer","checkConnection","_console$h","addEventListeners","boundEventListeners","addListener","AddEventListener","eventType","eventListener","RemoveEventListener","_console$g","BluetoothUUID","generateBluetoothUUID","stringToCharacteristicUUID","identifier","getCharacteristic","stringToServiceUUID","getService","bluetoothUUIDs","services","deviceInformation","uuid","characteristics","battery","batteryLevel","main","smp","serviceUUIDs","optionalServiceUUIDs","getServiceNameFromUUID","serviceUUID","serviceName","characteristicUUIDs","allCharacteristicUUIDs","getCharacteristicNameFromUUID","characteristicUUID","characteristicName","serviceInfo","getCharacteristicProperties","broadcast","read","writeWithoutResponse","notify","indicate","authenticatedSignedWrites","reliableWrite","writableAuxiliaries","characteristicNames","characteristicInfo","_console$f","BluetoothConnectionManager","writeCharacteristic","sendSmpMessage","_console$e","WebBluetoothConnectionManager","bluetoothId","device","boundBluetoothCharacteristicEventListeners","boundBluetoothDeviceEventListeners","newDevice","server","gatt","connected","requestDevice","filters","getServicesAndCharacteristics","serviceIndex","service","getCharacteristics","characteristicIndex","characteristic","characteristicProperties","startNotifications","readValue","onCharacteristicValueChanged","stopNotifications","allSettled","onCharacteristicvaluechanged","writeValueWithoutResponse","writeValueWithResponse","isInRange","POW_2_32","POW_2_53","CBOR","lastLength","prepareWrite","newByteLength","requiredLength","oldDataView","uint32count","commitWrite","writeUint8","writeUint8Array","writeTypeAndLength","writeUint16","writeUint32","low","high","writeUint64","encodeItem","utf8data","setFloat64","writeFloat64","charCode","ret","retView","tagger","simpleValue","commitRead","readArrayBuffer","readUint8","readUint16","readUint32","readBreak","readLength","additionalInformation","readIndefiniteStringLength","majorType","initialByte","appendUtf16Data","utf16data","decodeItem","tempArrayBuffer","tempDataView","fraction","readFloat16","getFloat64","retArray","retObject","elements","fullArrayLength","fullArray","fullArrayOffset","_console$d","constants","MCUManager","_mtu","_messageCallback","_imageUploadProgressCallback","_imageUploadNextCallback","_fileUploadProgressCallback","_fileUploadNextCallback","_uploadIsInProgress","_downloadIsInProgress","_buffer","_seq","onMessage","onImageUploadNext","onImageUploadProgress","onImageUploadFinished","_imageUploadFinishedCallback","onFileUploadNext","onFileUploadProgress","onFileUploadFinished","_fileUploadFinishedCallback","onFileDownloadNext","_fileDownloadNextCallback","onFileDownloadProgress","_fileDownloadProgressCallback","onFileDownloadFinished","_fileDownloadFinishedCallback","_getMessage","group","encodedData","lengthLo","_notification","_processMessage","lengthHi","groupHi","groupLo","_uploadOffset","_uploadNext","_uploadFileOffset","_uploadFileNext","_downloadFileOffset","_downloadFileLength","percentage","_downloadFileNext","cmdReset","smpEcho","cmdImageState","cmdImageErase","cmdImageTest","hash","confirm","cmdImageConfirm","_hash","crypto","subtle","digest","_uploadImage","sha","packet","cmdUpload","slot","_uploadSlot","cmdUploadFile","filebuf","destFilename","_uploadFile","_uploadFilename","cmdDownloadFile","filename","_downloadRemoteFilename","_downloadLocalFilename","imageInfo","padStart","_console$c","FirmwareMessageTypes","FirmwareEventTypes","FirmwareStatuses","FirmwareManager","mcuManager","getImages","newStatus","firmwareStatus","assertValidImageIndex","testImage","eraseImage","confirmImage","onMcuMessage","onMcuFileDownloadProgress","onMcuFileDownloadFinished","onMcuFileUploadNext","onMcuFileUploadProgress","onMcuFileUploadFinished","onMcuImageUploadNext","onMcuImageUploadProgress","onMcuImageUploadFinished","tasks","onMcuImageState","pending","confirmed","bootable","active","permanent","firmwareImages","_console$b","DeviceManagerEventTypes","DeviceManager","CanUseLocalStorage","UseLocalStorage","boundDeviceEventListeners","onDevice","onDeviceType","UpdateLocalStorageConfigurationForDevice","ConnectedDevices","newUseLocalStorage","DefaultLocalStorageConfiguration","devices","LocalStorageConfiguration","localStorage","setItem","LocalStorageKey","LoadFromLocalStorage","localStorageString","CanGetDevices","GetDevices","deviceInformationIndex","AvailableDevices","getDevices","bluetoothDevices","bluetoothDevice","existingConnectedDevice","existingAvailableDevice","Device","connectionManager","DispatchEvent","RemoveEventListeners","RemoveAllEventListeners","removeAllEventListeners","OnDeviceIsConnected","_CheckDeviceAvailability","DeviceManager$1","shared","_console$a","ServerMessageTypes","messageDataArrayBufferByteLength","messageDataArrayBuffer","messageBuffers","createServerMessage","createMessage","createClientDeviceMessage","_console$9","WebSocketMessageTypes$1","createWebSocketMessage$1","createWebSocketMessage","_console$8","WebSocketMessageTypes","WebSocketDeviceInformationMessageTypes","WebSocketConnectionManager","isSecure","webSocket","newWebSocket","readyState","OPEN","boundWebSocketEventListeners","newIpAddress","newIsSecure","pingTimer","restart","onWebSocketOpen","parseWebSocketMessage","onWebSocketClose","onWebSocketError","deviceInformationType","ping","webSocketPingTimeout","sendWebSocketMessage","_console$7","DeviceEventTypes","RequiredInformationConnectionMessages","deviceInformationManager","_informationManager","sensorConfigurationManager","sensorDataManager","vibrationManager","tfliteManager","fileTransferManager","wifiManager","cameraManager","microphoneManager","firmwareManager","connectionStatus","requestRequiredInformation","DefaultConnectionManager","newConnectionManager","remove","onConnectionStatusUpdated","onConnectionMessageReceived","onConnectionMessagesReceived","reconnectOnDisconnection","UDPConnectionManager","_a$1","clientConnectionManager","subType","didReceiveMessageTypes","hasConnectionMessage","hasRequiredInformation","hasCamera","hasMicrophone","isDisplayAvailable","ReconnectOnDisconnection","newReconnectOnDisconnection","reconnectIntervalId","isConnectionBusy","OnDeviceConnectionStatusUpdated","dispatchConnectionEvents","latestConnectionMessages","updateBatteryLevel","updatedBatteryLevel","continuousSensorTypes","setSensorConfiguration","ClearSensorConfigurationOnLeave","newClearSensorConfigurationOnLeave","clearSensorConfigurationOnLeave","numberOfPressureSensors","pressureSensorPositions","resetRange","validFileTypes","receive","isTfliteAvailable","tfliteName","setTfliteName","didSendFile","tfliteIsReady","tfliteClasses","setTfliteClasses","tfliteTask","setTfliteTask","setTfliteSampleRate","allowedTfliteSensorTypes","setTfliteSensorTypes","setTfliteInferencingEnabled","enableTfliteInferencing","disableTfliteInferencing","toggleTfliteInferencing","setTfliteCaptureDelay","tfliteThreshold","setTfliteThreshold","uploadFirmware","canReset","getFirmwareImages","eraseFirmwareImage","confirmFirmwareImage","testFirmwareImage","isUkaton","reconnectViaWebSockets","reconnectViaUDP","_buildCameraData","buildCameraData","camera","stopCamera","wakeCamera","sleepCamera","setCameraConfiguration","isRecordingCamera","startRecording","stopRecording","toggleRecording","microphone","stopMicrophone","enableMicrophoneVad","toggleMicrophone","setMicrophoneConfiguration","AudioContext","microphoneMediaStreamDestination","microphoneGainNode","isRecordingMicrophone","isDisplayReady","displayColors","displayBitmapColors","displayBitmapColorIndices","displayColorOpacities","setDisplayBrightness","numberOfDisplayColors","wakeDisplay","sleepDisplay","toggleDisplay","showDisplay","clearDisplay","setDisplayColor","setDisplayColorOpacity","setDisplayOpacity","saveDisplayContext","restoreDisplayContext","clearDisplayRect","selectDisplayBackgroundColor","selectDisplayFillColor","selectDisplayLineColor","setDisplayIgnoreFill","setDisplayIgnoreLine","setDisplayFillBackground","setDisplayLineWidth","setDisplayRotation","clearDisplayRotation","setDisplaySegmentStartCap","setDisplaySegmentEndCap","setDisplaySegmentCap","setDisplaySegmentStartRadius","setDisplaySegmentEndRadius","setDisplaySegmentRadius","setDisplayCropTop","setDisplayCropRight","setDisplayCropBottom","setDisplayCropLeft","setDisplayCrop","clearDisplayCrop","setDisplayRotationCropTop","setDisplayRotationCropRight","setDisplayRotationCropBottom","setDisplayRotationCropLeft","setDisplayRotationCrop","clearDisplayRotationCrop","flushDisplayContextCommands","drawDisplayRect","drawDisplayCircle","drawDisplayEllipse","drawDisplayRoundRect","drawDisplayRegularPolygon","drawDisplayPolygon","drawDisplayWireframe","drawDisplaySegment","drawDisplaySegments","drawDisplayArc","drawDisplayArcEllipse","drawDisplayBitmap","imageToDisplayBitmap","quantizeDisplayImage","resizeAndQuantizeDisplayImage","setDisplayContextState","selectDisplayBitmapColor","selectDisplayBitmapColors","setDisplayBitmapColor","setDisplayBitmapColorOpacity","setDisplayBitmapScaleDirection","setDisplayBitmapScaleX","setDisplayBitmapScaleY","setDisplayBitmapScale","resetDisplayBitmapScale","selectDisplaySpriteColor","selectDisplaySpriteColors","setDisplaySpriteColor","setDisplaySpriteColorOpacity","resetDisplaySpriteColors","setDisplaySpriteScaleDirection","setDisplaySpriteScaleX","setDisplaySpriteScaleY","setDisplaySpriteScale","resetDisplaySpriteScale","uploadDisplaySpriteSheet","uploadDisplaySpriteSheets","uploadSpriteSheets","selectDisplaySpriteSheet","drawDisplaySprite","startDisplaySprite","endDisplaySprite","displaySpriteSheets","serializeDisplaySpriteSheet","setDisplayAlignment","setDisplayVerticalAlignment","setDisplayHorizontalAlignment","resetDisplayAlignment","setDisplaySpritesDirection","setDisplaySpritesLineDirection","setDisplaySpritesSpacing","setDisplaySpritesLineSpacing","setDisplaySpritesAlignment","drawDisplayQuadraticBezierCurve","drawDisplayQuadraticBezierCurves","drawDisplayCubicBezierCurve","drawDisplayCubicBezierCurves","drawDisplayPath","drawDisplayClosedPath","_console$6","DisplayCanvasHelperEventTypes","DisplayCanvasHelper","bitmapContext","newCanvas","resetTransform","frontDrawStack","applyTransparency","alpha","deviceDisplayManager","onDeviceIsConnected","onDeviceConnected","onDeviceNotConnected","onDeviceDisplaySpriteSheetUploadStart","onDeviceDisplaySpriteSheetUploadProgress","onDeviceDisplaySpriteSheetUploadComplete","onDeviceDisplayContextCommands","redraw","flushColors","flushOpacities","flushBrightness","updateDevice","updateDeviceColors","updateDeviceOpacity","updateDeviceContextState","updateDeviceBrightness","updateDeviceSpriteSheets","updateDeviceSelectedSpriteSheet","newNumberOfColors","pendingColors","pendingOpacities","rearDrawStack","ignoreDevice","spriteBitmapColorIndices","spriteBitmapColors","blankSpriteColorIndices","clearRectToCanvas","useSpriteColorIndices","colorIndexToRgbString","transformContext","translateContext","rotateContext","rotated","xs","ys","offsetBoundingBox","clearBoundingBoxOnDraw","getOuterPadding","getRectBoundingBox","applyLineWidth","outerPadding","applyClip","rect","applyRotationClip","darken","hexToRgbWithOpacity","getColorOpacity","includeBrightness","brightnessOpacity","hexToRgbStringWithOpacity","colorIndexToRgb","updateContext","localBox","rotatedLocalBox","rotateBoundingBox","rotatedBox","clearBoundingBox","strokeRect","maxBorderRadius","roundRect","diameter","drawCircleToCanvas","drawArcEllipseToCanvas","getRegularPolygonBoundingBox","shapeFactor","angleStep","getPointsBoundingBox","applyAlignment","pointsBoundingBox","alignBoundingBox","alignedBoundingBox","drawPolygonToCanvas","centeredLocalBox","getWireframeBoundingBox","_clearBoundingBoxOnDraw","drawWireframeToCanvas","curvePoints","curvePoint","_curvePoints","appendCurvePoint","generateQuadraticCurvePoints","displayCurveTolerance","p01","p12","appendCurvePoints","generateCubicCurvePoints","p012","p123","p23","generateGenericCurvePoints","isStart","appendQuadraticCurvePoints","appendCubicCurvePoints","appendGenericCurvePoints","drawCurveToCanvas","drawSegmentsToCanvas","drawCurvesToCanvas","curvePointsJump","numberOfCurves","drawPathToCanvas","_controlPoints","getLocalSegmentBoundingBox","maxRadius","drawSegmentToCanvas","r0","previousPoint","drawArcToCanvas","centerX","centerY","clockwise","endAngle","bitmapImageData","createImageData","rawBitmapImageData","imageDataOffset","saveContextForSprite","_contextState","runSpriteCommand","drawSpriteToCanvas","setIsDrawingSprite","drawSpritesToCanvas","spritesBreadthSign","isSpritesDirectionPositive","spritesDepthSign","isSpritesLineDirectionPositive","setCanvasContextTransform","spritesBreadthStart","spriteOffset","signedSpritesSpacing","signedSpriteLineSpacing","signedSpriteLineHeight","breadthOffsetKey","lineIndex","_spriteOffset","spriteContextState","depthOffsetKey","assertValidSpriteLines","brightnessOpacities","veryLow","medium","veryHigh","didSetBrightness","newBrightness","resetBrightness","sortedSpriteSheets","contextScale","scaledWidth","scaledHeight","correctAlignmentTranslation","setIgnoreDevice","newIgnoreDevice","_ignoreDeviceCounter","_ignoreDevice","isDrawingSpriteCounter","spriteStack","spriteContextStack","runPreviewSpriteCommand","previewSprite","previewSpriteCommands","newIsDrawingSprite","isDrawingSprite","_console$5","DevicePairPressureSensorDataManager","onDevicePressureData","rawPressure","hasAllPressureData","updatePressureData","Sides","sidePressure","_sensor","_console$4","DevicePairSensorDataEventTypes","DevicePairSensorDataManager","resetPressureRange","onDeviceSensorData","timestamps","_console$3","getDevicePairDeviceEventType","deviceEventType","DevicePairEventTypes","DevicePair","sides","isPartiallyConnected","isHalfConnected","isDeviceCorrectType","assignDevice","currentDevice","removeDeviceEventListeners","addDeviceEventListeners","removeDevice","foundDevice","redispatchDeviceEvent","deviceEvent","insoles","gloves","_console$2","ClientConnectionManager","client","discoveredDevice","newBluetoothId","newIsConnected","sendClientConnectMessage","sendClientMessage","sendClientDisconnectMessage","sendRequiredDeviceInformationMessage","onClientMessage","onClientMessageCallback","_console$1","ClientEventTypes","BaseClient","isScanningAvailable","isScanning","receivedMessageTypes","_reconnectOnDisconnection","_connectionStatus","requiredMessageTypes","parseMessageCallback","discoveredDeviceString","parseStringFromDataView","onDiscoveredDevice","onExpiredDiscoveredDevice","connectedBluetoothDeviceIdStrings","connectedBluetoothDeviceIds","onConnectedBluetoothDeviceIds","_byteOffset","newIsAvailable","_isScanningAvailable","sendServerMessage","newIsScanning","_isScanning","discoveredDevices","createDevice","sendDeviceMessage","getOrCreateDevice","bluetoothIds","disconnectFromDevice","requestDisconnectionFromDevice","sendDisconnectFromDeviceMessage","_console","WebSocketClient","WebSocket","isDisconnected","CLOSED","toggleConnection","onServerMessage","EventUtils","ThrottleUtils","trailing","remaining","timeout","lastTime","lastArgs","callImmediately","callNow"],"mappings":"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CA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,UACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,GAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,KACA,IAAA,aACA,IAAA,KACA,IAAA,KACA,IAAA,MAeAC,GAAA,CACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,GACA,GAAA,EACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,GACA,GAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,GACA,GAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,GACA,GAAA,GACA,GAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,GACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,GACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,GAmBAC,GAAA,CACA,KAAA,KACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,QACA,MAAA,QACA,KAAA,KACA,KAAA,QACA,MAAA,QACA,MAAA,QACA,MAAA,QACA,KAAA,QACA,KAAA,MACA,KAAA,QACA,MAAA,QACA,KAAA,QACA,MAAA,QACA,KAAA,MACA,MAAA,QACA,KAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,UACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,QACA,KAAA,UACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,QACA,KAAA,QACA,KAAA,KACA,KAAA,QACA,KAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,QACA,KAAA,KACA,KAAA,QACA,MAAA,QACA,KAAA,QACA,KAAA,SACA,MAAA,QACA,KAAA,QACA,KAAA,QACA,MAAA,QACA,KAAA,QACA,MAAA,QACA,MAAA,QACA,KAAA,QACA,MAAA,QACA,KAAA,QACA,KAAA,KACA,MAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,QACA,KAAA,QACA,KAAA,KACA,KAAA,QACA,KAAA,QACA,KAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,QACA,KAAA,KACA,KAAA,QACA,KAAA,QACA,KAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,UACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,KACA,KAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,QACA,KAAA,KACA,KAAA,QACA,KAAA,QACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,MACA,KAAA,SACA,KAAA,MACA,KAAA,QACA,KAAA,KACA,KAAA,QACA,KAAA,MACA,KAAA,SACA,KAAA,MACA,KAAA,KACA,KAAA,aACA,KAAA,KACA,KAAA,aACA,KAAA,UACA,KAAA,MACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,MAAA,QACA,MAAA,QACA,MAAA,QACA,KAAA,QACA,KAAA,QACA,KAAA,QACA,MAAA,QACA,MAAA,QACA,KAAA,QACA,MAAA,QACA,KAAA,QACA,MAAA,QACA,KAAA,QACA,MAAA,QACA,MAAA,QACA,MAAA,QASA,KAAA,KACA,KAAA,KAEA,MAAA,QACA,MAAA,QACA,KAAA,QACA,KAAA,QACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,MACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA,KACA,KAAA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F,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,MACA,CAAAE,MAAA,KAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,CAAAE,MAAA,MAAAF,IAAA,OACA,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,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA,GACAkuE,GAAA/xE,UAAA6D,EAAA,EAAA,EAAA,EAAA,EAAA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","x_google_ignoreList":[7,19,20,35,38,39,40,41,43,44,45,46,47,48,49,50,51]}