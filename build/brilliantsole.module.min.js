/**
 * @copyright Zack Qattan 2024
 * @license MIT
 */
const e=!1;function t(){}const n=console.log.bind(console),s=console.warn.bind(console),i=console.error.bind(console),r=console.assert.bind(console);class c{static#e={};constructor(e){if(c.#e[e])throw new Error(`"${e}" console already exists`);c.#e[e]=this}#t={log:e,warn:e,error:e};setLevelFlags(e){Object.assign(this.#t,e)}static setLevelFlagsForType(e,t){if(!this.#e[e])throw new Error(`no console found with type "${e}"`);this.#e[e].setLevelFlags(t)}static setAllLevelFlags(e){for(const t in this.#e)this.#e[t].setLevelFlags(e)}static create(e,t){const n=this.#e[e]||new c(e);return n.setLevelFlags(t),n}get log(){return this.#t.log?n:t}get warn(){return this.#t.warn?s:t}get error(){return this.#t.error?i:t}get assert(){return this.#t.assert?r:t}assertWithError(e,t){if(!e)throw new Error(t)}assertWithWarning(e,...t){e||this.warn(...t)}}function o(e,t){return c.create(e,t)}const a=o("EventDispatcher",{log:!1});class h{constructor(e){a.assertWithError(Array.isArray(e)||null==e,"eventTypes must be an array"),this.#n=e}#n;#s(e){return!this.#n||this.#n.includes(e)}#i(e){a.assertWithError(this.#s(e),`invalid event type "${e}"`)}#r;addEventListener(e,t,n){if(a.log(`adding "${e}" eventListener`,t),this.#i(e),this.#r||(this.#r={}),n?.once){const n=t;t=function t(s){n.apply(this,arguments),this.removeEventListener(e,t)}}const s=this.#r;s[e]||(s[e]=[]),s[e].includes(t)||s[e].push(t)}hasEventListener(e,t){return a.log(`has "${e}" eventListener?`,t),this.#i(e),this.#r?.[e]?.includes(t)}removeEventListener(e,t){if(a.log(`removing "${e}" eventListener`,t),this.#i(e),this.hasEventListener(e,t)){const n=this.#r[e].indexOf(t);return this.#r[e].splice(n,1),!0}return!1}dispatchEvent(e){if(this.#i(e.type),this.#r?.[e.type]){e.target=this;const t=this.#r[e.type].slice(0);for(let n=0,s=t.length;n<s;n++)t[n].call(this,e)}}}function d(e,t,n){e.forEach((e=>{const s=`_on${i=e,i.replace(/(?:^\w|\b\w)/g,(function(e){return e.toUpperCase()})).replace(/\s+/g,"")}`;var i;const r=n[s].bind(n);n[s]=r,t[e]=r}))}const l=o("ConnectionManager");class u{static#c=["connecting","connected","disconnecting","disconnected","connection changed"];static get EventTypes(){return this.#c}get eventTypes(){return u.#c}#o=new h(this.eventTypes);addEventListener(e,t,n){return this.#o.addEventListener(...arguments)}#a(e){this.#o.dispatchEvent(e)}removeEventListener(e,t){return this.#o.removeEventListener(...arguments)}static#h(e){throw new Error(`"${e}" is not implemented by "${this.name}" subclass`)}#d(e){throw new Error(`"${e}" is not implemented by "${this.constructor.name}" subclass`)}static get isSupported(){return!1}get isSupported(){return this.constructor.isSupported}static get type(){this.#h("type")}get type(){return this.constructor.type}#l(){l.assertWithError(this.isSupported,`${this.constructor.name} is not supported`)}#u(){l.assertWithError(this.constructor!=u,`${this.constructor.name} must be subclassed`)}constructor(){this.#u(),this.#l()}get isConnected(){return!1}#v(){l.assertWithError(this.isConnected,"device is not connected")}#g(){l.assertWithError(!this.isConnected,"device is already connected")}async connect(){this.#g(),this.#a({type:"connecting"})}async disconnect(){this.#v(),this.#a({type:"disconnected"})}}function v(e){return`6e40000${e}-b5a3-f393-e0a9-e50e24dcca9e`}function g(e){return BluetoothUUID.getCharacteristic(e)}function p(e){return BluetoothUUID.getService(e)}const y=Object.freeze({services:{deviceInformation:{uuid:p("device_information"),characteristics:{manufacturerName:{uuid:g("manufacturer_name_string")},modelNumber:{uuid:g("model_number_string")},hardwareRevision:{uuid:g("hardware_revision_string")},firmwareRevision:{uuid:g("firmware_revision_string")},softwareRevision:{uuid:g("software_revision_string")}}},battery:{uuid:p("battery_service"),characteristics:{batteryLevel:{uuid:g("battery_level")}}},data:{uuid:v("1"),characteristics:{dataWrite:{uuid:v("2")},dataNotify:{uuid:v("3")}}},unknown:{uuid:g(65113),characteristics:{unknown1:{uuid:"8ec90003-f315-4f60-9fb8-838830daea50"}}}},get serviceUUIDs(){return[this.services.deviceInformation.uuid,this.services.battery.uuid,this.services.data.uuid,this.services.unknown.uuid]},getServiceNameFromUUID(e){return Object.entries(this.services).find((([t,n])=>e==n.uuid))?.[0]},getCharacteristicNameFromUUID(e){var t;return Object.values(this.services).some((n=>(t=Object.entries(n.characteristics).find((([t,n])=>e==n.uuid))?.[0],t))),t}}),E=y.serviceUUIDs;const f=o("WebBluetoothConnectionManager");class m extends u{constructor(){super(),d(["characteristicvaluechanged"],this.#p,this)}#p={};static get isSupported(){return"bluetooth"in navigator}static get type(){return"web bluetooth"}#y;get device(){return this.#y}set device(e){this.#y!=e?(this.#y?.addEventListener(""),this.#y=e):f.warn("assigning the same BluetoothDevice")}get server(){return this.#y?.gatt}get isConnected(){return this.server?.connected}#E=new Map;#f=new Map;async connect(){super.connect();const e=await navigator.bluetooth.requestDevice({filters:[{namePrefix:"Brilliant"}],optionalServices:E});f.log("got BluetoothDevice",e),this.device=e,f.log("connecting to device...");const t=await this.device.gatt.connect();f.log(`connected to device? ${t.connected}`),f.log("getting services...");const n=await t.getPrimaryServices();f.log("got services",n),f.log("getting characteristics...");const s=n.map((async e=>{const t=(n=e.uuid,y.getServiceNameFromUUID(n));var n;f.assertWithError(t,`no name found for service uuid "${e.uuid}"`),f.log(`got "${t}" service`),e._name=t,this.#E.set(t,e),f.log("getting characteristics for service",e);const s=await e.getCharacteristics();f.log("got characteristics for service",e,s);const i=s.map((async e=>{const n=(s=e.uuid,y.getCharacteristicNameFromUUID(s));var s;f.assertWithError(n,`no name found for characteristic uuid "${e.uuid}" in "${t}" service`),f.log(`got "${n}" characteristic in "${t}" service`),e._name=n,this.#f.set(n,e),e.addEventListener("characteristicvaluechanged",this.#p.characteristicvaluechanged),e.properties.read&&await e.readValue(),e.properties.notify&&(f.log(`starting notifications for "${n}" characteristic`,e),await e.startNotifications())}));await Promise.all(i)}));await Promise.all(s),f.log("got all characteristics")}async disconnect(){super.disconnect(),f.log("disconnecting from device..."),this.server.disconnect()}_onCharacteristicvaluechanged(e){f.log("oncharacteristicvaluechanged",e);const t=e.target,n=t._name;f.assertWithError(n,`no name found for characteristic with uuid "${t.uuid}"`),f.log(`oncharacteristicvaluechanged for "${n}" characteristic`,e);const s=t.value;if(f.assertWithError(s,`no data found for "${n}" characteristic`),f.log(`data for "${n}" characteristic`,Array.from(new Uint8Array(s.buffer))),"dataNotify"!==n)throw new Error(`uncaught characteristicName "${n}"`)}}const w=o("BrilliantSole");class b{constructor(){d(u.EventTypes,this.#m,this),this.connectionManager=new m}static#c=[...u.EventTypes];get#n(){return b.#c}#o=new h(this.#n);addEventListener(e,t,n){this.#o.addEventListener(...arguments)}#a(e){this.#o.dispatchEvent(e)}removeEventListener(e,t){return this.#o.removeEventListener(...arguments)}#w;get connectionManager(){return this.#w}set connectionManager(e){w.assertWithWarning(this.connectionManager!=e,"same connectionManager is already assigned"),w.log("assigning new connectionManager...",e),this.connectionManager?.eventTypes.forEach((e=>{connectionManager.removeEventListener(e,this.#m[e])})),e?.eventTypes.forEach((t=>{e.addEventListener(t,this.#m[t])})),this.#w=e}#m={};async connect(){return this.connectionManager.connect()}get isConnected(){return this.connectionManager.isConnected}get connectionType(){return this.connectionManager?.type}async disconnect(){return this.connectionManager.disconnect()}_onConnecting(){w.log(this),w.log("connecting"),this.#a({type:"connecting"})}_onConnected(){w.log("connected"),this.#a({type:"connected"})}_onDisconnecting(){w.log("disconnecting"),this.#a({type:"disconnecting"})}_onDisconnected(){w.log("disconnected"),this.#a({type:"disconnected"})}_onConnectionChanged(){w.log("connection changed"),this.#a({type:"connection changed"})}}b.setConsoleLevelFlagsForType=function(e,t){c.setLevelFlagsForType(e,t)},b.setAllConsoleLevelFlags=function(e){c.setAllLevelFlags(e)};export{b as default};
