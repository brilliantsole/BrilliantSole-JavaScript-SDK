/**
 * @copyright Zack Qattan 2024
 * @license MIT
 */
function e(e,t){if(!e)throw new Error(t)}class t{constructor(t){e(Array.isArray(t)||null==t,"eventTypes must be an array"),this.#e=t}#e;#t(e){return!this.#e||this.#e.includes(e)}#n(t){e(this.#t(t),`invalid event type "${t}"`)}#s;addEventListener(e,t,n){if(this.#n(e),this.#s||(this.#s={}),n?.once){const n=t;t=function t(s){n.apply(this,arguments),this.removeEventListener(e,t)}}const s=this.#s;s[e]||(s[e]=[]),s[e].includes(t)||s[e].push(t)}hasEventListener(e,t){return this.#n(e),this.#s?.[e]?.includes(t)}removeEventListener(e,t){if(this.#n(e),this.hasEventListener(e,t)){const n=this.#s[e].indexOf(t);return this.#s[e].splice(n,1),!0}return!1}dispatchEvent(e){if(this.#n(e.type),this.#s?.[e.type]){e.target=this;const t=this.#s[e.type].slice(0);for(let n=0,s=t.length;n<s;n++)t[n].call(this,e)}}}class n{static#i=["not connected","connecting","connected","disconnected"];static get EventTypes(){return this.#i}get#e(){return n.#i}#r=new t(this.#e);addEventListener(e,t,n){return this.#r.addEventListener(...arguments)}#c(e){this.#r.dispatchEvent(e)}removeEventListener(e,t){return this.#r.removeEventListener(...arguments)}static#o(e){throw new Error(`"${e}" is not implemented by "${this.name}" subclass`)}#a(e){throw new Error(`"${e}" is not implemented by "${this.constructor.name}" subclass`)}static get isSupported(){return!1}get isSupported(){return this.constructor.isSupported}static get type(){this.#o("type")}get type(){return this.constructor.type}#d(){e(this.isSupported,`${this.constructor.name} is not supported`)}#u(){e(this.constructor!=n,`${this.constructor.name} must be subclassed`)}constructor(){this.#u(),this.#d()}get isConnected(){return!1}#h(){e(this.isConnected,"device is not connected")}#v(){e(!this.isConnected,"device is already connected")}async connect(){this.#v()}async disconnect(){this.#h()}}function s(e){return`6e40000${e}-b5a3-f393-e0a9-e50e24dcca9e`}const i=Object.freeze({deviceInformationService:{uuid:"device_information",characteristics:{manufacturerName:{uuid:"manufacturer_name_string"},modelNumber:{uuid:"model_number_string"},hardwareRevision:{uuid:"hardware_revision_string"},firmwareRevision:{uuid:"firmware_revision_string"},softwareRevision:{uuid:"software_revision_string"}}},batteryService:{uuid:"battery_service",characteristics:{batteryLevel:{uuid:"battery_level"}}},dataService:{uuid:s("1"),characteristics:{write:{uuid:s("2")},notify:{uuid:s("3")}}},unknownService:{uuid:65113,characteristics:{}},get serviceUUIDs(){return[this.deviceInformationService.uuid,this.batteryService.uuid,this.dataService.uuid,this.unknownService.uuid]}});const r=new class{#l=function(){};set prefix(e){const t=[console];e&&(Array.isArray(e)?t.push(...e):t.push(e)),this.#p=console.log.bind(...t),this.#g=console.warn.bind(...t),this.#y=console.error.bind(...t)}isLoggingEnabled=!0;get log(){return this.#l}#p=console.log.bind(console);isWarningEnabled=!0;get warn(){return this.#l}#g=console.warn.bind(console);isErrorEnabled=!0;get error(){return this.#l}#y=console.error.bind(console);set isEnabled(e){this.isLoggingEnabled=e,this.isWarningEnabled=e,this.isErrorEnabled=e}constructor(e){e&&(this.prefix=e)}};class c extends n{static get isSupported(){return"bluetooth"in navigator}static get type(){return"bluetooth"}#E;get device(){return this.#E}set device(e){this.device!=e?this.#E=e:r.warn("assigning the same BluetoothDevice")}get server(){return this.#E?.gatt}get isConnected(){return this.server?.connected}async connect(){super.connect();const e=await navigator.bluetooth.requestDevice({filters:[{namePrefix:"Brilliant"}],optionalServices:i.serviceUUIDs});r.log("got BluetoothDevice",e),this.device=e,r.log("connecting to device..."),await this.device.gatt.connect(),r.log(`connected to device? ${this.server.connected}`)}async disconnect(){super.disconnect(),r.log("disconnecting from device..."),this.server.disconnect()}}class o{static#i=[...n.EventTypes];get#e(){return o.#i}#r=new t(this.#e);addEventListener(e,t,n){this.#r.addEventListener(...arguments)}removeEventListener(e,t){return this.#r.removeEventListener(...arguments)}#m=new c;get connectionManager(){return this.#m}set connectionManager(t){e(this.connectionManager!=t,"cannot assign same connectionManager"),this.#m=t}async connect(){return this.connectionManager.connect()}get isConnected(){return this.connectionManager.isConnected}get connectionType(){return this.connectionManager?.type}async disconnect(){return this.connectionManager.disconnect()}}export{o as default};
