/**
 * @copyright Zack Qattan 2024
 * @license MIT
 */
const e = !1;
function t() {}
const s = console.log.bind(console),
    n = console.warn.bind(console),
    i = console.error.bind(console),
    r = console.assert.bind(console);
class a {
    static #e = {};
    constructor(e) {
        if (a.#e[e]) throw new Error(`"${e}" console already exists`);
        a.#e[e] = this;
    }
    #t = { log: e, warn: e, error: e };
    setLevelFlags(e) {
        Object.assign(this.#t, e);
    }
    static setLevelFlagsForType(e, t) {
        if (!this.#e[e]) throw new Error(`no console found with type "${e}"`);
        this.#e[e].setLevelFlags(t);
    }
    static setAllLevelFlags(e) {
        for (const t in this.#e) this.#e[t].setLevelFlags(e);
    }
    static create(e, t) {
        const s = this.#e[e] || new a(e);
        return s.setLevelFlags(t), s;
    }
    get log() {
        return this.#t.log ? s : t;
    }
    get warn() {
        return this.#t.warn ? n : t;
    }
    get error() {
        return this.#t.error ? i : t;
    }
    get assert() {
        return this.#t.assert ? r : t;
    }
    assertWithError(e, t) {
        if (!e) throw new Error(t);
    }
}
function o(e, t) {
    return a.create(e, t);
}
const c = o("EventDispatcher", { log: !0 });
class h {
    constructor(e) {
        c.assertWithError(Array.isArray(e) || null == e, "eventTypes must be an array"), (this.#s = e);
    }
    #s;
    #n(e) {
        return !this.#s || this.#s.includes(e);
    }
    #i(e) {
        c.assertWithError(this.#n(e), `invalid event type "${e}"`);
    }
    #r;
    addEventListener(e, t, s) {
        if ((c.log(`adding "${e}" eventListener`, t), this.#i(e), this.#r || (this.#r = {}), s?.once)) {
            const s = t;
            t = function t(n) {
                s.apply(this, arguments), this.removeEventListener(e, t);
            };
        }
        const n = this.#r;
        n[e] || (n[e] = []), n[e].includes(t) || n[e].push(t);
    }
    hasEventListener(e, t) {
        return c.log(`has "${e}" eventListener?`, t), this.#i(e), this.#r?.[e]?.includes(t);
    }
    removeEventListener(e, t) {
        if ((c.log(`removing "${e}" eventListener`, t), this.#i(e), this.hasEventListener(e, t))) {
            const s = this.#r[e].indexOf(t);
            return this.#r[e].splice(s, 1), !0;
        }
        return !1;
    }
    dispatchEvent(e) {
        if ((this.#i(e.type), this.#r?.[e.type])) {
            e.target = this;
            const t = this.#r[e.type].slice(0);
            for (let s = 0, n = t.length; s < n; s++) t[s].call(this, e);
        }
    }
}
function d(e, t, s) {
    c.log("bindEventListeners", { eventTypes: e, object: t, target: s }),
        e.forEach((e) => {
            const n = `_on${
                ((i = e),
                i
                    .replace(/(?:^\w|\b\w)/g, function (e) {
                        return e.toUpperCase();
                    })
                    .replace(/\s+/g, ""))
            }`;
            var i;
            c.log(`binding eventType "${e}" as ${n} from target`, s);
            const r = s[n].bind(s);
            (s[n] = r), (t[e] = r);
        });
}
const v = o("ConnectionManager");
class l {
    static #a = [
        "connecting",
        "connected",
        "disconnecting",
        "disconnected",
        "manufacturerName",
        "modelNumber",
        "softwareRevision",
        "hardwareRevision",
        "firmwareRevision",
        "batteryLevel",
    ];
    static get EventTypes() {
        return this.#a;
    }
    get eventTypes() {
        return l.#a;
    }
    #o = new h(this.eventTypes);
    addEventListener(e, t, s) {
        return this.#o.addEventListener(...arguments);
    }
    _dispatchEvent(e) {
        this.#o.dispatchEvent(e);
    }
    removeEventListener(e, t) {
        return this.#o.removeEventListener(...arguments);
    }
    static #c(e) {
        throw new Error(`"${e}" is not implemented by "${this.name}" subclass`);
    }
    #h(e) {
        throw new Error(`"${e}" is not implemented by "${this.constructor.name}" subclass`);
    }
    static get isSupported() {
        return !1;
    }
    get isSupported() {
        return this.constructor.isSupported;
    }
    static get type() {
        this.#c("type");
    }
    get type() {
        return this.constructor.type;
    }
    #d() {
        v.assertWithError(this.isSupported, `${this.constructor.name} is not supported`);
    }
    #v() {
        v.assertWithError(this.constructor != l, `${this.constructor.name} must be subclassed`);
    }
    constructor() {
        this.#v(), this.#d();
    }
    get isConnected() {
        return !1;
    }
    #l() {
        v.assertWithError(this.isConnected, "device is not connected");
    }
    #u() {
        v.assertWithError(!this.isConnected, "device is already connected");
    }
    async connect() {
        this.#u(), this._dispatchEvent({ type: "connecting" });
    }
    async disconnect() {
        this.#l(), this._dispatchEvent({ type: "disconnected" });
    }
}
function u(e) {
    return `6e40000${e}-b5a3-f393-e0a9-e50e24dcca9e`;
}
function g(e) {
    return BluetoothUUID.getCharacteristic(e);
}
function m(e) {
    return BluetoothUUID.getService(e);
}
const p = Object.freeze({
        services: {
            deviceInformation: {
                uuid: m("device_information"),
                characteristics: {
                    manufacturerName: { uuid: g("manufacturer_name_string") },
                    modelNumber: { uuid: g("model_number_string") },
                    hardwareRevision: { uuid: g("hardware_revision_string") },
                    firmwareRevision: { uuid: g("firmware_revision_string") },
                    softwareRevision: { uuid: g("software_revision_string") },
                },
            },
            battery: { uuid: m("battery_service"), characteristics: { batteryLevel: { uuid: g("battery_level") } } },
            data: { uuid: u("1"), characteristics: { dataWrite: { uuid: u("2") }, dataNotify: { uuid: u("3") } } },
            unknown: {
                uuid: g(65113),
                characteristics: { unknown1: { uuid: "8ec90003-f315-4f60-9fb8-838830daea50" } },
            },
        },
        get serviceUUIDs() {
            return [
                this.services.deviceInformation.uuid,
                this.services.battery.uuid,
                this.services.data.uuid,
                this.services.unknown.uuid,
            ];
        },
        getServiceNameFromUUID(e) {
            return Object.entries(this.services).find(([t, s]) => e == s.uuid)?.[0];
        },
        getCharacteristicNameFromUUID(e) {
            var t;
            return (
                Object.values(this.services).some(
                    (s) => ((t = Object.entries(s.characteristics).find(([t, s]) => e == s.uuid)?.[0]), t)
                ),
                t
            );
        },
    }),
    f = p.serviceUUIDs;
const y = o("WebBluetoothConnectionManager", { log: !1 });
class E extends l {
    constructor() {
        super(), d(["characteristicvaluechanged"], this.#g, this);
    }
    #g = {};
    static get isSupported() {
        return "bluetooth" in navigator;
    }
    static get type() {
        return "web bluetooth";
    }
    #m = new TextDecoder();
    #p;
    get device() {
        return this.#p;
    }
    set device(e) {
        this.#p != e ? (this.#p?.addEventListener(""), (this.#p = e)) : y.warn("assigning the same BluetoothDevice");
    }
    get server() {
        return this.#p?.gatt;
    }
    get isConnected() {
        return this.server?.connected;
    }
    #f = new Map();
    #y = new Map();
    async connect() {
        super.connect();
        const e = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: "Brilliant" }],
            optionalServices: f,
        });
        y.log("got BluetoothDevice", e), (this.device = e), y.log("connecting to device...");
        const t = await this.device.gatt.connect();
        y.log(`connected to device? ${t.connected}`), y.log("getting services...");
        const s = await t.getPrimaryServices();
        y.log("got services", s), y.log("getting characteristics...");
        const n = s.map(async (e) => {
            const t = ((s = e.uuid), p.getServiceNameFromUUID(s));
            var s;
            y.assertWithError(t, `no name found for service uuid "${e.uuid}"`),
                y.log(`got "${t}" service`),
                (e._name = t),
                this.#f.set(t, e),
                y.log("getting characteristics for service", e);
            const n = await e.getCharacteristics();
            y.log("got characteristics for service", e, n);
            const i = n.map(async (e) => {
                const s = ((n = e.uuid), p.getCharacteristicNameFromUUID(n));
                var n;
                y.assertWithError(s, `no name found for characteristic uuid "${e.uuid}" in "${t}" service`),
                    y.log(`got "${s}" characteristic in "${t}" service`),
                    (e._name = s),
                    this.#y.set(s, e),
                    e.addEventListener("characteristicvaluechanged", this.#g.characteristicvaluechanged),
                    e.properties.read && (await e.readValue()),
                    e.properties.notify &&
                        (y.log(`starting notifications for "${s}" characteristic`, e), await e.startNotifications());
            });
            await Promise.all(i);
        });
        await Promise.all(n), y.log("got all characteristics"), this._dispatchEvent({ type: "connected" });
    }
    async disconnect() {
        super.disconnect(), y.log("disconnecting from device..."), this.server.disconnect();
    }
    _onCharacteristicvaluechanged(e) {
        y.log("oncharacteristicvaluechanged", e);
        const t = e.target,
            s = t._name;
        y.assertWithError(s, `no name found for characteristic with uuid "${t.uuid}"`),
            y.log(`oncharacteristicvaluechanged for "${s}" characteristic`, e);
        const n = t.value;
        switch (
            (y.assertWithError(n, `no data found for "${s}" characteristic`),
            y.log(`data for "${s}" characteristic`, Array.from(new Uint8Array(n.buffer))),
            s)
        ) {
            case "manufacturerName":
                const e = this.#m.decode(n);
                y.log(`manufacturerName: "${e}"`),
                    this._dispatchEvent({ type: "manufacturerName", message: { manufacturerName: e } });
                break;
            case "modelNumber":
                const t = this.#m.decode(n);
                y.log(`modelNumber: "${t}"`), this._dispatchEvent({ type: "modelNumber", message: { modelNumber: t } });
                break;
            case "softwareRevision":
                const i = this.#m.decode(n);
                y.log(`softwareRevision: "${i}"`),
                    this._dispatchEvent({ type: "softwareRevision", message: { softwareRevision: i } });
                break;
            case "hardwareRevision":
                const r = this.#m.decode(n);
                y.log(`hardwareRevision: "${r}"`),
                    this._dispatchEvent({ type: "hardwareRevision", message: { hardwareRevision: r } });
                break;
            case "firmwareRevision":
                const a = this.#m.decode(n);
                y.log(`firmwareRevision: "${a}"`),
                    this._dispatchEvent({ type: "firmwareRevision", message: { firmwareRevision: a } });
                break;
            case "batteryLevel":
                const o = n.getUint8(0);
                y.log(`batteryLevel: ${o}`),
                    this._dispatchEvent({ type: "batteryLevel", message: { batteryLevel: o } });
                break;
            case "dataNotify":
                break;
            default:
                throw new Error(`uncaught characteristicName "${s}"`);
        }
    }
}
const w = o("BrilliantSole");
class b {
    constructor() {
        d(l.EventTypes, this.#E, this), (this.connectionManager = new E());
    }
    static #a = [...l.EventTypes];
    get #s() {
        return b.#a;
    }
    #o = new h(this.#s);
    addEventListener(e, t, s) {
        this.#o.addEventListener(...arguments);
    }
    #w(e) {
        this.#o.dispatchEvent(e);
    }
    removeEventListener(e, t) {
        return this.#o.removeEventListener(...arguments);
    }
    #b;
    get connectionManager() {
        return this.#b;
    }
    set connectionManager(e) {
        this.connectionManager != e
            ? (w.log("assigning new connectionManager...", e),
              this.connectionManager?.eventTypes.forEach((e) => {
                  connectionManager.removeEventListener(e, this.#E[e]);
              }),
              e?.eventTypes.forEach((t) => {
                  e.addEventListener(t, this.#E[t]);
              }),
              (this.#b = e))
            : w.warn("same connectionManager is already assigned");
    }
    #E = {};
    async connect() {
        return this.connectionManager.connect();
    }
    get isConnected() {
        return this.connectionManager.isConnected;
    }
    get connectionType() {
        return this.connectionManager?.type;
    }
    async disconnect() {
        return this.connectionManager.disconnect();
    }
    _onConnecting() {
        w.log(this), w.log("connecting"), this.#w({ type: "connecting" });
    }
    _onConnected() {
        w.log("connected"), this.#w({ type: "connected" });
    }
    _onDisconnecting() {
        w.log("disconnecting"), this.#w({ type: "disconnecting" });
    }
    _onDisconnected() {
        w.log("disconnected"), this.#w({ type: "disconnected" });
    }
    #L = {};
    get deviceInformation() {
        return this.#L;
    }
    _onManufacturerName(e) {
        const { manufacturerName: t } = e.message;
        w.log(`manufacturerName: "${t}"`),
            (this.#L.manufacturerName = t),
            this.#w({ type: "manufacturerName", message: { manufacturerName: t } });
    }
    _onModelNumber(e) {
        const { modelNumber: t } = e.message;
        w.log(`modelNumber: "${t}"`),
            (this.#L.modelNumber = t),
            this.#w({ type: "modelNumber", message: { modelNumber: t } });
    }
    _onSoftwareRevision(e) {
        const { softwareRevision: t } = e.message;
        w.log(`softwareRevision: "${t}"`),
            (this.#L.softwareRevision = t),
            this.#w({ type: "softwareRevision", message: { softwareRevision: t } });
    }
    _onHardwareRevision(e) {
        const { hardwareRevision: t } = e.message;
        w.log(`hardwareRevision: "${t}"`),
            (this.#L.hardwareRevision = t),
            this.#w({ type: "hardwareRevision", message: { hardwareRevision: t } });
    }
    _onFirmwareRevision(e) {
        const { firmwareRevision: t } = e.message;
        w.log(`firmwareRevision: "${t}"`),
            (this.#L.firmwareRevision = t),
            this.#w({ type: "firmwareRevision", message: { firmwareRevision: t } });
    }
    #$;
    get batteryLevel() {
        return this.#$;
    }
    _onBatteryLevel(e) {
        const { batteryLevel: t } = e.message;
        w.log(`batteryLevel: ${t}%`), (this.#$ = t), this.#w({ type: "batteryLevel", message: { batteryLevel: t } });
    }
}
(b.setConsoleLevelFlagsForType = function (e, t) {
    a.setLevelFlagsForType(e, t);
}),
    (b.setAllConsoleLevelFlags = function (e) {
        a.setAllLevelFlags(e);
    });
export { b as default };
